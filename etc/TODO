Emacs TODO List                                                   -*-outline-*-

Copyright (C) 2001-2019 Free Software Foundation, Inc.
See the end of the file for license conditions.


If you are ready to start working on any of these TODO items, we
appreciate your help; please write to emacs-devel@gnu.org so we can be
aware that the problem is being addressed, and talk with you how to do
it best.  Also to check that it hasn't been done already, since we
don't always remember to update this file!  It is best to consult
the latest version of this file in the Emacs source code repository.

Since Emacs is an FSF-copyrighted package, please be prepared to sign
legal papers to transfer the copyright on your work to the FSF.
Copyright assignment is a simple process.  Residents of some countries
can do it entirely electronically.  We can help you get started, and
answer any questions you may have (or point you to the people with the
answers), at the emacs-devel@gnu.org mailing list.

For more information about getting involved, see the CONTRIBUTE file.

As well as the issues listed here, there are bug reports at
<https://debbugs.gnu.org>.  Bugs tagged "easy" ought to be suitable for
beginners to work on, but unfortunately we are not very good at using
this tag.  Bugs tagged "help" are ones where assistance is required,
but may be difficult to fix.  Bugs with severity "important" or higher
are the ones we consider more important, but these also may be
difficult to fix.  Bugs with severity "minor" may be simpler, but this
is not always true.

* Speed up Elisp execution
** Speed up function calls
Change src/bytecode.c so that calls from byte-code functions to byte-code
functions don't go through Ffuncall/funcall_lambda/exec_byte_code but instead
stay within exec_byte_code.

** Improve the byte-compiler to recognize immutable (lexical) bindings
and get rid of them if they're used only once and/or they're bound to
a constant expression.

Such things aren't present in hand-written code, but macro expansion and
defsubst can often end up generating things like
(funcall (lambda (arg) (body)) actual) which then get optimized to
(let ((arg actual)) (body)) but should additionally get optimized further
when 'actual' is a constant/copyable expression.

** Add an "indirect goto" byte-code and use it for local lambda expressions.
E.g. when you have code like

   (let ((foo (lambda (x) bar)))
     (dosomething
      (funcall foo toto)
      (blabla (funcall foo titi))))

turn those 'funcalls' into jumps and their return into indirect jumps back.

** Compile efficiently local recursive functions

Similar to the previous point, we should be able to handle something like

   (letrec ((loop () (blabla) (if (toto) (loop))))
     (loop))

which ideally should generate the same byte-code as

   (while (progn (blabla) (toto)))

* Things that were planned for Emacs-24

** concurrency: including it as an "experimental" compile-time option
  sounds good.  Of course there might still be big questions around "which form
  of concurrency" we'll want.
** better support for dynamic embedded graphics: I like this idea (my
  mpc.el code could use it for the volume widget), though I wonder if the
  resulting efficiency will be sufficient.
** Spread Semantic.
** Improve the "code snippets" support: consolidate skeleton.el, tempo.el,
  and expand.el (any other?) and then advertise/use/improve it.
** Improve VC: yes, there's a lot of work to be done there :-(

** Random things that cross my mind right now that I'd like to see (some of
them from my local hacks), but it's not obvious at all whether they'll
make it.
*** prog-mode could/should provide a better fill-paragraph default
  that uses syntax-tables to recognize string/comment boundaries.
*** provide more completion-at-point-functions.  Make existing
  in-buffer completion use completion-at-point.
*** "functional" function-key-map that would make it easy to add (and
  remove) mappings like "FOO-mouse-4 -> FOO-scroll-down",
  "FOO-tab -> ?\FOO-\t", "uppercase -> lowercase", "[fringe KEY...] ->
  [KEY]", "H-FOO -> M-FOO", "C-x C-y FOO -> H-FOO", ...

* Things related to elpa.gnu.org.

** Move idlwave to elpa.gnu.org.
Need to sync up the Emacs and external versions.
See <https://lists.gnu.org/r/emacs-devel/2014-07/msg00008.html>

** Move Org mode to elpa.gnu.org.
See <https://lists.gnu.org/r/emacs-devel/2014-08/msg00300.html>
<https://lists.gnu.org/r/emacs-devel/2014-11/msg00257.html>

** Move verilog-mode to elpa.gnu.org.
See <https://lists.gnu.org/r/emacs-devel/2015-02/msg01180.html>

** Move vhdl-mode to elpa.gnu.org.
See <https://lists.gnu.org/r/emacs-devel/2015-02/msg01180.html>

* Simple tasks. These don't require much Emacs knowledge, they are
suitable for anyone from beginners to experts.

** Convert modes that use view-mode to be derived from special-mode instead.

** Major modes should have a menu entry.

** Check if all items on the mode-line have a suitable tooltip for all modes.

** edebug and debugger-mode should have a toolbar.
It can use the same icons as gud.

** Check what minor modes don't use define-minor-mode and convert them
to use it.

** Convert all defvars with leading '*' in the doc-strings into defcustoms
of appropriate :type and :group.

** Remove any leading '*'s from defcustom doc-strings.
[done?] [A lot of them are in CC Mode.]

** Remove unnecessary autoload cookies from defcustoms.
This needs a bit of care, since often people have become used to
expecting such variables to always be defined, eg when they modify
things in their .emacs.

** See if other files can use generated-autoload-file (see eg ps-print).

** Write more tests.  Pick a fixed bug from the database, write a test
case to make sure it stays fixed.  Or pick your favorite programming
major-mode, and write a test for its indentation.  Or a version
control backend, and write a test for its status parser.  Etc.
See the 'test' directory for examples.

* Small but important fixes needed in existing features:

** Flymake's customization mechanism needs to be both simpler (fewer
levels of indirection) and better documented, so it is easier to
understand.  I find it quite hard to figure out what compilation
command it will use.

I suggest totally rewriting that part of Flymake, using the simplest
mechanism that suffices for the specific needs.  That will be easy
for users to customize.

** Distribute a bar cursor of width > 1 evenly between the two glyphs
   on each side of the bar (what to do at the edges?).

** revert-buffer should eliminate overlays and the mark.
   For related problems consult the thread starting with
   https://lists.gnu.org/r/emacs-devel/2005-11/msg01346.html

** erase-buffer should perhaps disregard read-only properties of text.

** Fix the kill/yank treatment of invisible text.  At the moment,
  invisible text is placed in the kill-ring, so that the contents of
  the ring may not correspond to the text as displayed to the user.
  It ought to be possible to omit text which is invisible (due to a
  text-property, overlay, or selective display) from the kill-ring.

** Feature to change cursor shape when Emacs is idle (for more than
  a specified time).

** The buttons at the top of a custom buffer should not omit
  variables whose values are currently hidden.

** Clean up the variables in browse-url.  Perhaps use a shell command string to
  specify the browser instead of the mushrooming set of functions.
  See also ESR's proposal for a BROWSER environment variable
  <URL:http://www.catb.org/~esr/BROWSER/browse-url.patch>.

** Enhance scroll-bar to handle tall line (similar to line-move).

** In Custom buffers, put the option that turns a mode on or off first,
  using a heuristic of some kind?

** Define recompute-arg and recompute-arg-if for fix_command to use.
  See rms message of 11 Dec 05 in
  https://lists.gnu.org/r/emacs-pretest-bug/2005-12/msg00165.html,
  and the rest of that discussion.

** In Emacs Info, examples of using Customize should be clickable
   and they should create Custom buffers.

** The toolbar should show keyboard equivalents in its tooltips.

** Add function to redraw the tool bar.

** Redesign the load-history data structure so it can cope better
  with evaluating definitions of the same function from different files,
  recording which file the latest definition came from.

** make back_comment use syntax-ppss or equivalent.

** Consider improving src/sysdep.c's search for a fqdn.
https://lists.gnu.org/r/emacs-devel/2007-04/msg00782.html

** Find a proper fix for rcirc multiline nick adding.
https://lists.gnu.org/r/emacs-devel/2007-04/msg00684.html

** Check for any included packages that define obsolete bug-reporting commands.
Change them to use report-emacs-bug.
*** Related functions:
**** gnus-bug
**** report-calc-bug
**** org-submit-bug-report
**** lm-report-bug
**** tramp-bug
**** c-submit-bug-report
[Do all of them need changing?]

** Allow fringe indicators to display a tooltip (provide a help-echo property?)

** Add a defcustom that supplies a function to name numeric backup files,
like make-backup-file-name-function for non-numeric backup files.

** 'dired-mode' should specify the semantics of 'buffer-modified-p' for
dired buffers and DTRT WRT 'auto-revert-mode'.

** Check uses of prin1 for error-handling.
https://lists.gnu.org/r/emacs-devel/2008-08/msg00456.html

* Important features:

** "Emacs as word processor"
https://lists.gnu.org/r/emacs-devel/2013-11/msg00515.html
    rms writes:
    25 years ago I hoped we would extend Emacs to do WYSIWYG word
    processing.  That is why we added text properties and variable
    width fonts.  However, more features are still needed to achieve this.

** Extend text-properties and overlays
*** Several text-property planes
This would get us rid of font-lock-face property (and I'd be happy to
get rid of char-property-alias-alist as well) since font-lock would
simply use the 'face' property in the 'font-lock' plane.

Basically 'put-text-property' and friends would take an extra argument PLANE
(maybe the best backward-compatible way to do that is to make it so that
PROPERTY can be a cons cell (PLANE . PROP)).  So font-lock would
do (put-text-property start end '(font-lock . face) value).

All the properties coming from the various planes would get merged via an Elisp
function (so it can merge 'face' differently than 'keymap' or it could give
different priorities to different planes (we could imagine enabling/disabling
planes)).  The merging would not happen lazily while looking up properties but
instead it would take place eagerly in 'add-text-properties'.  This is based on
the idea that it's much more frequent to lookup properties than to
modify them.  Also, when properties are looked up during redisplay, we
generally can't run Elisp code, whereas we generally can do that when
properties are added.

*** Move overlays to intervals.c

Currently overlays are implemented as (two) sorted singly linked lists (one
for overlays_before some position and one for overlay_after that
position, for some quirky definition of "before" and "after").
The function 'overlay-recenter' changes the position used for the split
(and is called internally in various situations).

Each overlay is itself implemented with two markers (which keep track of
the overlay-start and overlay-end).  Markers are implemented as
a non-sorted singly linked list of markers.  So every text
insertion/deletion requires O(N) time, where N is the number of markers
since we have to go down that list to update those markers that are
affected by the modification.

You can start in src/buffer.[ch], maybe grepping for overlays_before for
a starting point.

Text-properties, OTOH, are implemented with a (mostly) balanced binary
tree.  This is implemented in src/intervals.[ch].

So we'd like to change overlays so that they don't use markers (and we
don't keep them in two sorted singly-linked lists) any more.  Instead,
we'll store them inside the balanced binary tree used for
text-properties.  I think we can use the "augmented tree" approach
described in https://en.wikipedia.org/wiki/Interval_tree.

To ease up debugging during development, I'd guess the implementation
would first add the new stuff, keeping the old stuff (i.e. add to
Lisp_Overlay whichever fields are needed for the new code, while keeping
the old ones, add needed overlay fields to the intervals tree, but keep
the old fields, the overlays_before etc...).  This way, you can add
consistency checks that make sure the new code computes the same results
as the old code.  And once that works well, we can remove the old code
and old fields.

** Having tabs above a window to switch buffers in it.

** "Perspectives" are named persistent window configurations.  We have
had the window configuration mechanism in GNU Emacs since the
beginning but we have never developed a good user interface to take
advantage of them.  Eclipse's user interface seems to be good.

Perspectives work well even if you do the equivalent of C-x 4 C-f
because of the distinction between view windows vs file windows.  In
Emacs this is more or less the "dedicated window" feature, but we have
never really made it work for this.

Perspectives also need to interact with the tabs.

** FFI (foreign function interface)
See eg https://lists.gnu.org/r/emacs-devel/2013-10/msg00246.html

One way of doing this is to start with fx's dynamic loading, and use it
to implement things like auto-loaded buffer parsers and database
access in cases which need more than Lisp.

** Replace unexec with a more portable form of dumping
See eg https://lists.gnu.org/r/emacs-devel/2014-01/msg01034.html
       https://lists.gnu.org/r/emacs-devel/2014-06/msg00452.html

One way is to provide portable undumping using mmap (per gerd design).

** Imenu could be extended into a file-structure browsing mechanism
using code like that of customize-groups.

** Display something in the margin on lines that have compilation errors.

** Compilation error navigation bar, parallel to the scroll bar,
indicating where in the buffer there are compilation errors.
Perhaps we could arrange to display these error indications on top
of the scroll bar itself.  That depends on to what extent toolkit
scroll bars are extensible.

** Provide user-friendly ways to list all available font families,
  list fonts, display a font as a sample, etc.  [fx is looking at
  multilingual font selection for the Unicode branch of Emacs.]

** Provide a convenient way to select a color with the mouse.

** Rewrite the face code to be simpler, clearer and faster.

** Program Enriched mode to read and save in RTF.  [Is there actually a
  decent single definition of RTF?  Maybe see info at
  http://latex2rtf.sourceforge.net/.]  This task seems to be addressed
  by https://savannah.nongnu.org/projects/emacs-rtf/, which is still in
  very early stages.

  Another place to look is the Wikipedia article at
  http://en.wikipedia.org/wiki/Rich_Text_Format

  It currently points to the latest spec of RTF v1.9.1 at
  http://www.microsoft.com/en-us/download/details.aspx?id=10725

** Implement primitive and higher-level functions to allow filling
  properly with variable-pitch faces.

** Implement intelligent search/replace, going beyond query-replace
  (see http://groups.csail.mit.edu/uid/projects/clustering/chi04.pdf).

** Implement other text formatting properties.
*** Footnotes that can appear either in place or at the end of the page.
*** text property that says "don't break line in middle of this".
   Don't break the line between two characters that have the
   same value of this property.
*** Discretionary hyphens that are not visible when they are at end of line.

** Internationalize Emacs's messages.

** Set up a facility to save backtraces when errors happen during
specified filters, specified timers, and specified hooks.

** Install mmc@maruska.dyndns.org's no-flicker change.

** Add a "current vertical pixel level" value that goes with point,
  so that motion commands can also move through tall images.
  This value would be to point as window-vscroll is to window-start.

** Address internationalization of symbols names essentially
  as documentation, e.g. in command names and Custom.

** Make the Lucid menu widget display multilingual text.  [This
  probably needs to be done from actual Emacs buffers, either directly
  in the menu or by rendering in an unmapped window and copying the
  pixels.  The current code assumes a specific locale; that isn't good
  enough even if X can render the arbitrary text] [The gtk
  port now displays multilingual text in menus, but only insofar as
  Emacs can encode it as utf-8 and gtk can display the result.]
  Maybe making Lucid menus work like Gtk's (i.e. just force utf-8) is good
  enough now that Emacs can encode most chars into utf-8.

** The GNUstep port needs some serious attention, ideally from someone
familiar with GNUstep and Objective C.

* Other features we would like:

** A more modern printing interface.  One that pops up a dialog that lets
you choose printer, page style, etc.
Integration with the Gtk print dialog is apparently difficult.  See eg:
https://lists.gnu.org/r/emacs-devel/2009-03/msg00501.html
https://lists.gnu.org/r/emacs-devel/2009-04/msg00034.html

** Allow frames(terminals) created by emacsclient to inherit their environment
from the emacsclient process.

** Give Tar mode all the features of Archive mode.

** Create a category of errors called 'process-error'
  for some or all errors associated with using subprocesses.

** Maybe reinterpret 'parse-error' as a category of errors
  and put some other errors under it.

** Make byte-compile warn when a doc string is too wide.

** Make byte-optimization warnings issue accurate line numbers.

** Record the sxhash of the default value for customized variables
  and notify the user (maybe by adding a menu item or toolbar button,
  as the detection can occur during autoload time) when the default
  changes (meaning that new versions of the Lisp source with a changed
  default value got installed) and offer ediff on the respective
  customization buffers.

** Emacs Lisp mode could put an overlay on the defun for every
  function that has advice.  The overlay could have 'after-text' like
  " [Function has advice]".  It might look like (defun foo [Function
  has advice] (x y) The overlay could also be a button that you could
  use to view the advice.

** Add a function to get the insertion-type of the markers in an overlay.

** ange-ftp
*** understand sftp
   This is hard to make work because sftp doesn't print status messages.

*** Use MLS for ange-ftp-insert-directory if a list of files is specified.

** Ability to map a key, including all modified-combinations.
   E.g map mouse-4 to wheel-up as well as M-mouse-4 -> M-wheel-up
   M-C-mouse-4 -> M-C-wheel-up, H-S-C-M-s-double-mouse-4 ->
   H-S-C-M-s-double-wheel-up, ...

** Beefed-up syntax-tables.
*** recognize multi-character syntactic entities like 'begin' and 'end'.
*** nested string-delimiters (for PostScript's (foo(bar)baz) strings).
*** support for infix operators (with precedence).
*** support for the $ (paired delimiter) in parse-partial-sexp.
*** support for hook-chars whose effect on the parsing-state is specified
	by elisp code.  Thus a char could both close a string and open a comment
	at the same time and do it in a context-sensitive way.
*** ability to add mode-specific data to the partial-parse-state.

** Add a way to convert a keyboard macro to equivalent Lisp code.

** Have a command suggestion help system that recognizes patterns
  of commands which could be replaced with a simpler common command.
  It should not make more than one suggestion per 10 minutes.

** Add a way to define input methods by computing them (when first used)
  from other input methods.  Then redefine C-x 8 to use a
  user-selected input method, with the default being the union of
  latin-1-prefix and latin-1-postfix.

** Implement a clean way to use different major modes for
  different parts of a buffer.  This could be useful in editing
  Bison input files, for instance, or other kinds of text
  where one language is embedded in another language.  See
  http://www.loveshack.ukfsn.org/emacs/multi-mode.el and also
  mmm-mode, as reference for approaches taken by others.

** Arrange a way for an input method to return the first character
  immediately, then replace it later.  So that C-s a with
  input method latin-1-postfix would immediately search for an a.

** Give start-process the ability to direct standard-error
  output to a different filter.

** Give desktop.el a feature to switch between different named desktops.

** Add a cpio mode, more or less like tar mode.

** Save undo information in special temporary files, and reload it
  when needed for undoing.  This could extend undo capacity.
  undo-tree, in ELPA, already does this; its saving code could be
  integrated without requiring the use of undo-tree.

** Change the Windows NT menu code
  so that it handles the deep_p argument and avoids
  regenerating the whole menu bar menu tree except
  when the user tries to use the menubar.

  This requires the RIT to forward the WM_INITMENU message to
  the main thread, and not return from that message until the main
  thread has processed the MENU_BAR_ACTIVATE_EVENT and regenerated
  the whole menu bar.  In the mean time, it should process other messages.

** Get some major packages installed: W3 (development version needs
  significant work), PSGML, _possibly_ ECB.
  https://lists.gnu.org/r/emacs-devel/2007-05/msg01493.html
  Check the assignments file for other packages which might go in and
  have been missed.

** Make compiler warnings about functions that might be undefined at run time
 smarter, so that they know which files are required by the file being
 compiled and don't warn about functions defined in them.

** Split out parts of lisp.h.

** Update the FAQ.

** Allow auto-compression-mode to use zlib calls if zlib is available.
  [It's required for PNG, so may be linked anyhow.]

** Improve the GC (generational, incremental).  (We may be able to use
  the Boehm collector.)  [See the Boehm-GC branch in CVS for work on this.]

** Check what hooks would help Emacspeak -- see the defadvising in W3.

** Add definitions for symbol properties, for documentation purposes.

** Temporarily remove scroll bars when they are not needed, typically
  when a buffer can be fully displayed in its window.

** Provide an optional feature which computes a scroll bar slider's
  size and its position from lines instead of characters.

** Allow unknown image types to be rendered via an external program
  converting them to, say, PBM (in the same way as PostScript?). [does
  doc-view.el do this, or could it be extended to do this?
  Does ImageMagick obsolete this idea?]

** Allow displaying an X window from an external program in a buffer,
  e.g. to render graphics from Java applets.  [gerd and/or wmperry
  thought this was feasible.]

** Allow images (not just text) in the margin to be mouse-sensitive.
  (Requires recursing through display properties).  Provide some way
  to simulate mouse-clicks on marginal text without a mouse.

** Extend ps-print to deal with multiple font sizes, images, and extra
  encodings.

** Use the XIE X extension, if available, for image display.

** Make monochrome images display using the foreground and background
  colors of the applicable faces.

** Make 'format-time-string' preserve text properties like 'format'.

** Optionally make the cursor a little thinner at the end of a line
  or the end of the buffer.

** Port the conservative stack marking code of Emacs's garbage collector
  to more systems, so that we can completely get rid of GCPROs.  Note
  that Boehm garbage collector provides this.

** Reorder defcustom's in each package so that the more important
  options come first in the Customize buffers.  This could be done by
  either rearranging the file (since options are shown in the order
  they appear in the *.el files), or by adding a few :set-after attributes.

** Maybe document the features of libraries missing from the manual (or
  ancillary manuals, including the Lisp manual in some cases).
  This is not worth doing for all of these packages and we need not
  aim for completeness, but some may be worth documenting.

  Here's a list which is probably not complete/correct: align, allout,
  artist, ansi-color, array, calculator, cdl, cmuscheme,
  completion, delim-col, dirtrack, double, echistory, elide-head,
  easymenu, expand, flow-ctrl, format [format-alist],
  generic/generic-x [various modes], kermit, log-edit,
  makesum, midnight [other than in Kill Buffer node],
  mouse-copy [?], mouse-drag, mouse-sel, net-utils, rcompile,
  snmp-mode [?], soundex [should be interactive?], strokes [start from
  the web page], talk, thingatpt [interactive functions?], type-break,
  vcursor, xscheme, zone-mode [?], mlconvert [?], iso-cvt,
  feedmail [?], uce, gametree, page-ext,
  refbib, refer, scribe, texinfo, underline,
  cmacexp, hideif, mantemp [obsolete?], pcomplete, xml,
  cvs-status (should be described in PCL-CVS manual); other progmodes,
  probably in separate manual.

** Convert the XPM bitmaps to PPM, replace the PBMs with them and scrap
  the XPMs so that the color versions work generally.  (Requires care
  with the color used for the transparent regions.)

** Convenient access to the 'values' variable.  It would be nice to have an
  interface that would show you the printed reps of the elements of the
  list in a menu, let you select one of the values, and put it into some
  other variable, without changing the value of 'values'.

** (Controlled by a flag) make open and close syntax match exactly,
  i.e. '(' doesn't match ']'.

** Specify parameter ID-FORMAT in all calls to 'file-attributes' and
  'directory-files-and-attributes' where attributes UID or GID are used.
  Whenever possible, use value 'string.
  When done, change meaning of default value from 'integer to 'string.
  If value 'integer is used nowhere, remove the parameter ID-FORMAT from
  the definition of 'file-attributes' and 'directory-files-and-attributes'
  and from the calls.

** Make language-info-alist customizable.  Currently a user can customize
  only the variable 'current-language-environment'.

** Improve language environment handling so that Emacs can fit
  better to a users locale.  Currently Emacs uses utf-8 language
  environment for all utf-8 locales, thus a user in ja_JP.UTF-8 locale
  are also put in utf-8 lang. env.  In such a case, it is
  better to use Japanese lang. env. but prefer utf-8 coding system.

** Enhance locale handling:  handle language, territory and charset
  orthogonally and de-emphasize language environments.  Use the locale
  to set up more things, such as fontsets, the default Ispell
  dictionary, diary format, calendar holidays and display, quoting
  characters and phrase boundaries, sentence endings, collation for
  sorting (at least for unicodes), HTTP Accept-language, patterns for
  directory listings and compilation messages, yes-or-no replies,
  common menu items when the toolkit supports it ...  'locale-info'
  needs extending for LC_COLLATE &c.  [fx started on this.]

** Eliminate the current restriction on header printing by ps-print.
  Currently, a header can contain only single 1-byte charset in
  addition to ASCII.

** In ps-print, provide an user friendly interface to specify fonts.

** Enhance word boundary detection for such a script that doesn't use
  space at word boundary (e.g. Thai).

** Implement interface programs with major Japanese conversion server
  in lib-src so that they can be used from the input method
  "japanese".  Currently, most Japanese users are using external
  packages (e.g. tamago, anthy) or an input method via XIM.

** Let LEIM handle the Mode_switch key like XIM does (i.e. a toggle like C-\
   but which can also be used as a modifier).

** Improve Help buffers: Change the face of previously visited links (like
   Info, but also with regard to namespace), and give the value of
   lisp expressions, e.g auto-mode-alist, the right face.

** Possibly make 'list-holidays' eval items in the calendar-holidays variable.
   See thread
   <https://lists.gnu.org/r/emacs-devel/2006-02/msg01034.html>.
   [rgm@gnu.org will look at this after 22.1]

** Possibly make cal-dst use the system timezone database directly.
   See thread
   <https://lists.gnu.org/r/emacs-pretest-bug/2006-11/msg00060.html>

** Possibly add a "close" button to the modeline.
   The idea is to add an "X" of some kind, that when clicked deletes
   the window associated with that modeline.
   https://lists.gnu.org/r/emacs-devel/2007-09/msg02416.html

* Things to be done for specific packages or features

** NeXTstep port

*** Missing features

This sections contains features found in other official Emacs ports.

**** Support for xwidgets

Emacs 25 has support for xwidgets, a system to include operating
system components into an Emacs buffer.  The components range from
simple buttons to webkit (effectively, a web browser).

Currently, xwidgets works only for the gtk+ framework but it is
designed to be compatible with multiple Emacs ports.

**** Respect 'frame-inhibit-implied-resize'

When the variable 'frame-inhibit-implied-resize' is non-nil, frames
should not be resized when operations like changing font or toggling
the tool bar is performed.

Unfortunately, the tool bar (and possible other operations) always
resize the frame.

**** Support 'proced' (implement 'process-attributes')

Unfortunately, a user-level process like Emacs does not have the
privileges to get information about other processes under macOS.

There are other ways to do this:

 1) Spawn "ps" and parse the output ("ps" has superuser privileges).

 2) Sign Emacs as part of the distribution process.

 3) Ask the user to self-sign Emacs, if this feature is of interest.

Anders Lindgren <andlind@gmail.com> has implemented
'process-attributes' for macOS, which currently only work when
running Emacs as root.

See this article by Bozhidar Batsov for an overview of Proced:
http://emacsredux.com/blog/2013/05/02/manage-processes-with-proced/

**** Tooltip properties

Tooltip properties like the background color and font are hard-wired,
even though Emacs allows a user to customize such features.

*** New features

This section contains features unique to Nextstep and/or macOS.

**** PressAndHold for writing accented character

On macOS, many application support the press and hold pattern to
invoke a menu of accented characters.  (See example at
https://support.apple.com/en-us/HT201586 .)

Currently, this doesn't work in Emacs.

Note that "ns-win.el" explicitly disables this.

Note: This feature might not be allowed to be implemented until also
implemented in Emacs for a free system.

**** Floating scroll bars

In modern macOS applications, the scroll bar often floats over the
content, and is invisible unless actually used.  This makes the user
interface less cluttered and more area could be used to contain text.

With floating scroll bars, the user interface would look like it does
when they are disabled today.  However, they will be made visible when
a scroll action is initiated, e.g. by putting two fingers on a
trackpad.

Note: This feature might not be allowed to be implemented until also
implemented in Emacs for a free system.

*** Features from the "mac" port

This section contains features available in the "mac" Emacs port.

As the "mac" port (as of this writing) isn't an official Emacs port,
it might contain features not following the FSF rule "must exist on
free systems".

The "mac" port is based on the Emacs 22 C-based Carbon interface.
It has been maintained in parallel to the official Cocoa-based NS
interface.  The Carbon interface has been enhanced, and a number of the
features of that interface could be implemented NS.

**** Smooth scrolling -- maybe not a good idea

Today, by default, scrolling with a trackpad makes the text move in
steps of five lines.  (Scrolling with SHIFT scrolls one line at a time.)

The "mac" port provides smooth, pixel-based, scrolling.  This is a very
popular features.  However, there are drawbacks to this method: what
happens if only a fraction of a line is visible at the top of a
window, is the partially visible text considered part of the window or
not?  (Technically, what should 'window-start' return.)

An alternative would be to make one-line scrolling the default on NS
(or in Emacs in general).

Note: This feature might not be allowed to be implemented until also
implemented in Emacs for a free system.

**** Mouse gestures

The "mac" port defines the gestures 'swipe-left/right/up/down',
'magnify-up/down', and 'rotate-left/right'.

It also binds the magnification commands to change the font
size.  (This should be not be done in a specific interface, instead
Emacs should do this binding globally.)

Note: This feature might not be allowed to be implemented until also
implemented in Emacs for a free system.

**** Synthesize bold fonts

*** Open issues

This section contains issues where there is an ongoing debate.

**** Key bindings of CMD and ALT

Currently in the "ns" port, ALT is bound to Meta and CMD is bound to
Super -- allowing the user to use typical macOS commands like CMD-A to
mark everything.

Unfortunately, when using an international keyboard, you can't type
normal characters like "(" etc.

There are many alternative key bindings.  One solution is to bind CMD
to Meta and pass ALT to the system.  In fact, this is what Emacs did up
to, and including, version 22.  Also, this is how the "mac" port binds
the keys.

One could envision asymmetrical variants as well, however, this is
inappropriate for the default setting.

See the discussion on emacs-devel:
https://lists.gnu.org/r/emacs-devel/2015-12/msg01575.html
https://lists.gnu.org/r/emacs-devel/2016-01/msg00008.html

*** Internal development features

**** Regression test system (or at least a checklist)

Today, after each change to the user interface, Emacs must be manually
tested.  Often, small details are overlooked ("Oh, I didn't test
toggling the tool-bar in one of the full screen modes, when multiple
frame were open -- silly me.")

It would be an enormous help if this could be tested automatically.
Many features are generic, however, the NS interface provides a number
of unique features.

**** Existing packages

Note that there is a generic UI test named frame-test.el, see
https://debbugs.gnu.org/21415#284 .
The NS interface passes this, with the exception of two toolbar-related errors.

**** Anders frame test

Anders Lindgren <andlind@gmail.com> has implemented some (very basic)
tests for full screen, toolbar, and auto-hiding the menu bar.

**** Make sure all build variants work

Emacs can be build in a number of different ways.  For each feature,
consider if is really is "NS" specific, or if it should be applied to
all build versions.

- With the "NS" interface.  This is the normal way to build Emacs on
  macOS.

- With the "X11" interface.  On macOS, this is mainly of interest to
  developers of Emacs to get a "reference" interface implementations.
  However, it might be of interest for people working remotely, as X11
  applications can be used over a network connection.

- Console only.

*** Bugs

**** Incorrect translation of Super modifier with Ctrl or Meta on macOS

When pressing 'M-s-a', Emacs replies "M-s-å is undefined".  What
happened is a mix of Emacs view that Meta and Super has been pressed,
and macOS view that ALT-a should yield "å" (U+00E5 LATIN SMALL LETTER
A WITH RING ABOVE).

The bug reports suggest two different patches; unfortunately, neither
works properly.  For example:

   Use a Swedish keyboard layout

   (setq ns-alternate-modifier nil)

   "CMD-ALT-9"

Today, this correctly yields that s-] is undefined.  With either
of the two patches, Emacs responds that s-9 was pressed.

More investigation is needed to fix this problem.

Links:
- https://debbugs.gnu.org/19977
- https://debbugs.gnu.org/21330
- https://debbugs.gnu.org/21551

**** Toggling the toolbar in fullheight or maximized modes

The toolbar, in the NS interface, is not considered part of the text
area.  When it is toggled, the Emacs frame change height accordingly.

Unfortunately, this also occurs when the frame is in fullheight or
maximized modes (N.B. this is not the same as "fullscreen").  The
effect is that the full frame size either increases (stretching down
below the lower edge of the screen) or decreases (leaving space
between the lower edge of the frame and the lower edge of the screen).

A better solution would be for the frame to retain its size,
i.e. change the text area.

This is related to the 'frame-inhibit-implied-resize' issue.

**** The event loop does not redraw.
A problem is that redraw don't happen during resize,
because we can't break out from the NSapp loop during resize.
There was a special trick to detect mouse press in the lower right
corner and track mouse movements, but this did not work well, and was
not scalable to the new Lion "resize on every window edge" behavior.
[As of trunk r109635, 2012-08-15, the event loop no longer polls.]

**** (mouse-avoidance-mode 'banish) then minimize Emacs, will pop window back
up on top of all others (probably fixed in bug#17439)

**** free_frame_resources, face colors

**** Numeric keysetting bug.

*** Mac-related

**** Open file:/// URLs.

**** Put frame autopositioning into C code somewhere -- if loc = same, offset.

**** Automap ctrl-mouse-1 to mouse-3.

**** Deal with Finder aliases somehow.

**** Ctrl-F2 won't pull up menus.

*** Other / Low Priority:

**** Better recognition of Unicode scripts / Greek / composition.

**** Undo for color-drag face customization.

** Bidirectional editing

*** Support reordering structured text
Two important use cases: (1) comments and strings in program sources,
and (2) text with markup, like HTML or XML.

One idea is to invent a special text property that would instruct the
display engine to reorder only the parts of buffer text covered by
that property.  The display engine will then push its state onto the
iterator stack, restrict the bidi iterator to accessing only the
portion of buffer text covered by the property, reorder the text, then
pop its state from stack and continue as usual.  This will require
minor changes in the bidi_it structure.

This design requires Lisp-level code to put the text properties on the
relevant parts of the buffer text.  That could be done using JIT
fontifications, or as a preliminary processing when the file is
visited.  With HTML/XML, the code that puts text properties needs to
pay attention to the bidi directives embedded in the HTML/XML stream.

*** Allow the user to control the direction of the UI

**** Introduce user option to control direction of mode line.
One problem is the header line, which is produced by the same routines
as the mode line.  While it makes sense to have the mode-line
direction controlled by a single global variable, header lines are
buffer-specific, so they need a separate treatment in this regard.

**** User options to control direction of menu bar and tool bar.
For the tool bar, it's relatively easy: set it.paragraph_embedding
in redisplay_tool_bar according to the user variable, and make
f->desired_tool_bar_string multibyte with STRING_SET_MULTIBYTE.  Some
minor changes will be needed to set the right_box_line_p and
left_box_line_p flags correctly for the R2L tool bar.

However, it makes no sense to display the tool bar right to left if
the menu bar cannot be displayed in the same direction.

R2L menu bar is tricky for the same reasons as the mode line.  In
addition, toolkit builds create their menu bars in toolkit-specific
parts of code, bypassing xdisp.c, so those parts need to be enhanced
with toolkit-specific code to display the menu bar right to left.

** Custom

*** Extend :set-after to also mean initialize after.
If defcustom A specifies :set-after '(B), then if a user customizes
both A and B, custom will set A after B.  But if the user only customizes
A, then if B is already defined, it gets left at its original setting.
Instead, if B has not been customized it should be re-initialized
(on the assumption that the default value depends on A).
See the places where we manually call custom-reevaluate-setting,
such as for mail-host-address and user-mail-address in startup.el.

** ImageMagick support

*** image-type-header-regexps priorities the jpeg loader over the
ImageMagick one.  This is not wrong, but how should a user go about
preferring the ImageMagick loader?  The user might like zooming etc in jpegs.

Try (setq image-type-header-regexps nil) for a quick hack to prefer
ImageMagick over the jpg loader.

*** For some reason it's unbearably slow to look at a page in a large
image bundle using the :index feature.  The ImageMagick "display"
command is also a bit slow, but nowhere near as slow as the Emacs
code.  It seems ImageMagick tries to unpack every page when loading the
bundle.  This feature is not the primary usecase in Emacs though.

ImageMagick 6.6.2-9 introduced a bugfix for single page djvu load.  It
is now much faster to use the :index feature, but still not very fast.

*** Try to cache the num pages calculation.  It can take a while to
calculate the number of pages, and if you need to do it for each page
view, page-flipping becomes uselessly slow.

*** Integrate with image-dired.

*** Integrate with docview.

*** Integrate with image-mode.
Some work has been done, e.g. M-x image-transform-fit-to-height will
fit the image to the height of the Emacs window.

*** Look for optimizations for handling images with low depth.
Currently the code seems to default to 24 bit RGB which is costly for
images with lower bit depth.

*** Decide what to do with some uncommitted imagemagick support
functions for image size etc.

** nxml mode

*** High priority

**** Command to insert an element template, including all required
attributes and child elements.  When there's a choice of elements
possible, we could insert a comment, and put an overlay on that
comment that makes it behave like a button with a pop-up menu to
select the appropriate choice.

**** Command to tag a region.  With a schema should complete using legal
tags, but should work without a schema as well.

**** Provide a way to conveniently rename an element.  With a schema should
complete using legal tags, but should work without a schema as well.

*** Outlining

**** Implement C-c C-o C-q.

**** Install pre/post command hook for moving out of invisible section.

**** Put a modify hook on invisible sections that expands them.

**** Integrate dumb folding somehow.

**** An element should be able to be its own heading.

**** Optimize to avoid complete buffer scan on each command.

**** Make it work with HTML-style headings (i.e. level indicated by
name of heading element rather than depth of section nesting).

**** Recognize root element as a section provided it has a title, even
if it doesn't match section-element-name-regex.

**** Support for incremental search automatically making hidden text visible.

**** Allow title to be an attribute.

**** Command that says to recognize the tag at point as a section/heading.

**** Explore better ways to determine when an element is a section
or a heading.

**** rng-next-error needs to either ignore invisible portion or reveal it
(maybe use isearch oriented text properties).

**** Errors within hidden section should be highlighted by underlining the
ellipsis.

**** Make indirect buffers work.

**** How should nxml-refresh outline recover from non well-formed tags?

**** Hide tags in title elements?

**** Use overlays instead of text properties for holding outline state?
Necessary for indirect buffers to work?

**** Allow an outline to go in the speedbar.

**** Split up outlining manual section into subsections.

**** More detail in the manual about each outlining command.

**** More menu entries for hiding/showing?

**** Indication of many lines have been hidden?

*** Locating schemas

**** Should rng-validate-mode give the user an opportunity to specify a
schema if there is currently none? Or should it at least give a hint
to the user how to specify a non-vacuous schema?

**** Support for adding new schemas to schema-locating files.
Add documentElement and namespace elements.

**** C-c C-w should be able to report current type id.

**** Implement doctypePublicId.

**** Implement typeIdBase.

**** Implement typeIdProcessingInstruction.

**** Support xml:base.

**** Implement group.

**** Find preferred prefix from schema-locating files.  Get rid of
rng-preferred-prefix-alist.

**** Inserting document element with vacuous schema should complete using
document elements declared in schema locating files, and set schema
appropriately.

**** Add a ruleType attribute to the <include> element?

**** Allow processing instruction in prolog to contain the compact syntax
schema directly.

**** Use RDDL to locate a schema based on the namespace URI.

**** Should not prompt to add redundant association to schema locating file.

**** Command to reload current schema.

*** Schema-sensitive features

**** Should filter dynamic markup possibilities using schema validity, by
adding hook to nxml-mode.

**** Dynamic markup word should (at least optionally) be able to look in
other buffers that are using nxml-mode.

**** Should clicking on Invalid move to next error if already on an error?

**** Take advantage of a:documentation.  Needs change to schema format.

**** Provide feasible validation (as in Jing) toggle.

**** Save the validation state as a property on the error overlay to enable
more detailed diagnosis.

**** Provide an Error Summary buffer showing all the validation errors.

**** Pop-up menu.  What is useful?  Tag a region (should be grayed out if
the region is not balanced).  Suggestions based on error messages.

**** Have configurable list of namespace URIs so that we can provide
namespace URI completion on extension elements or with schema-less documents.

**** Allow validation to handle XInclude.

**** ID/IDREF support.

*** Completion

**** Make it work with icomplete.  Only use a function to complete when
some of the possible names have undeclared namespaces.

**** How should C-return in mixed text work?

**** When there's a vacuous schema, C-return after < will insert the end-tag.
Is this a bug or a feature?

**** After completing start-tag, ensure we don't get unhelpful message
from validation

**** Syntax table for completion.

**** Should complete start-tag name with a space if namespace attributes
are required.

**** When completing start-tag name with no prefix and it doesn't match
should try to infer namespace from local name.

**** Should completion pay attention to characters after point?  If so, how?

**** When completing start-tag name, add required atts if only one required
attribute.

**** When completing attribute name, add attribute value if only one value
is possible.

**** After attribute-value completion, insert space after close delimiter
if more attributes are required.

**** Complete on enumerated data values in elements.

**** When in context that allows only elements, should get tag
completion without having to type < first.

**** When immediately after start-tag name, and name is valid and not
prefix of any other name, should C-return complete on attribute names?

**** When completing attributes, more consistent to ignore all attributes
after point.

**** Inserting attribute value completions needs to be sensitive to what
delimiter is used so that it quotes the correct character.

**** Complete on encoding-names in XML decl.

**** Complete namespace declarations by searching for all namespaces
mentioned in the schema.

*** Well-formed XML support

**** Deal better with Mule-UCS

**** Deal with UTF-8 BOM when reading.

**** Complete entity names.

**** Provide some support for entity names for MathML.

**** Command to repeat the last tag.

**** Support for changing between character references and characters.
Need to check that context is one in which character references are
allowed.  xmltok prolog parsing will need to distinguish parameter
literals from other kinds of literal.

**** Provide a comment command to bind to M-; that works better than the
normal one.

**** Make indenting in a multi-line comment work.

**** Structure view.  Separate buffer displaying element tree.
Be able to navigate from structure view to document and vice-versa.

**** Flash matching >.

**** Smart selection command that selects increasingly large syntactically
coherent chunks of XML.  If point is in an attribute value, first
select complete value; then if command is repeated, select value plus
delimiters, then select attribute name as well, then complete
start-tag, then complete element, then enclosing element, etc.

**** ispell integration.

**** Block-level items in mixed content should be indented, e.g:
  <para>This is list:
    <ul>
      <li>item</li>

**** Provide option to indent like this:
    <para>This is a paragraph
     occupying multiple lines.</para>

**** Option to add make a / that closes a start-tag electrically insert a
space for the XHTML guys.

**** C-M-q should work.

*** Datatypes

**** Figure out workaround for CJK characters with regexps.

**** Does category C contain Cn?

**** Do ENTITY datatype properly.

*** XML Parsing Library

**** Parameter entity parsing option, nil (never), t (always),
unless-standalone (unless standalone="yes" in XML declaration).

**** When a file is currently being edited, there should be an option to
use its buffer instead of the on-disk copy.

*** Handling all XML features

**** Provide better support for editing external general parsed entities.
Perhaps provide a way to force ignoring undefined entities; maybe turn
this on automatically with <?xml encoding=""?> (with no version
pseudo-att).

**** Handle internal general entity declarations containing elements.

**** Handle external general entity declarations.

**** Handle default attribute declarations in internal subset.

**** Handle parameter entities (including DTD).

*** RELAX NG

**** Do complete schema checking, at least optionally.

**** Detect include/external loops during schema parse.

**** Coding system detection for schemas.  Should use utf-8/utf-16 per the
spec.  But also need to allow encodings other than UTF-8/16 to support
CJK charsets that Emacs cannot represent in Unicode.

*** Catching XML errors

**** Check public identifiers.

**** Check default attribute values.

*** Performance

**** Explore whether overlay-recenter can cure overlays performance problems.

**** Cache schemas.  Need to have list of files and mtimes.

**** Make it possible to reduce rng-validate-chunk-size significantly,
perhaps to 500 bytes, without bad performance impact: don't do
redisplay on every chunk; pass continue functions on other uses of
rng-do-some-validation.

**** Cache after first tag.

**** Introduce a new name class that is a choice between names (so that
we can use member)

**** intern-choice should simplify after patterns with same 1st/2nd args

**** Large numbers of overlays slow things down dramatically.  Represent
errors using text properties.  This implies we cannot incrementally
keep track of the number of errors, in order to determine validity.
Instead, when validation completes, scan for any characters with an
error text property; this seems to be fast enough even with large
buffers.  Problem with error at end of buffer, where there's no
character; need special variable for this.  Need to merge face from
font-lock with the error face: use :inherit attribute with list of two
faces.  How do we avoid making rng-valid depend on nxml-mode?

*** Error recovery

**** Don't stop at newline in looking for close of start-tag.

**** Use indentation to guide recovery from mismatched end-tags

**** Don't keep parsing when currently not well-formed but previously
well-formed

**** Try to recover from a bad start-tag by popping an open element if
there was a mismatched end-tag unaccounted for.

**** Try to recover from a bad start-tag open on the hypothesis that there
was an error in the namespace URI.

**** Better recovery from ill-formed XML declarations.

*** Usability improvements

**** Should print a "Parsing..." message during long movements.

**** Provide better position for reference to undefined pattern error.

**** Put Well-formed in the mode-line when validating against any-content.

**** Trim marking of illegal data for leading and trailing whitespace.

**** Show Invalid status as soon as we are sure it's invalid, rather than
waiting for everything to be completely up to date.

**** When narrowed, Valid or Invalid status should probably consider only
validity of narrowed region.

*** Bug fixes

**** Need to give an error for a document like: <foo/><![CDATA[  ]]>

**** Make nxml-forward-balanced-item work better for the prolog.

**** Make filling and indenting comments work in the prolog.

**** Should delete RNC Input buffers.

**** Figure out what regex use for NCName and use it consistently,

**** Should have not-well-formed tokens in ref.

**** Require version in XML declaration? Probably not because prevents
use for external parsed entities.  At least forbid standalone without version.

**** Reject schema that compiles to rng-not-allowed-ipattern.

**** Move point backwards on schema parse error so that it's on the right token.

*** Internal

**** Use rng-quote-string consistently.

**** Use parsing library for XML to texinfo conversion.

**** Rename xmltok.el to nxml-token.el.  Use nxml-t- prefix instead of
xmltok-.  Change nxml-t-type to nxml-t-token-type, nxml-t-start to
nxml-t-token-start.

**** Can we set fill-prefix to nil and rely on indenting?

**** xmltok should make available replacement text of entities containing
elements

**** In rng-valid, instead of using modification-hooks and
insert-behind-hooks on dependent overlays, use same technique as nxml-mode.

*** Fontification

**** Allow face to depend on element qname, attribute qname, attribute
value.  Use list with pairs of (R . F), where R specifies regexps and
F specifies faces.  How can this list be made to depend on the document type?

*** Other

**** Support RELAX NG XML syntax (use XML parsing library).

**** Support W3C XML Schema (use XML parsing library).

**** Command to infer schema from current document (like trang).

*** Schemas

**** XSLT schema should take advantage of RELAX NG to express cooccurrence
constraints on attributes (e.g. xsl:template).

*** Documentation

**** Move material from README to manual.

**** Document encodings.

*** Notes

**** How can we allow an error to be displayed on a different token from
where it is detected?  In particular, for a missing closing ">" we
will need to display it at the beginning of the following token.  At the
moment, when we parse the following token the error overlay will get cleared.

**** How should rng-goto-next-error deal with narrowing?

**** Perhaps should merge errors having same start position even if they
have different ends.

**** How to handle surrogates? One possibility is to be compatible with
utf8.e: represent as sequence of 4 chars.  But utf-16 is incompatible
with this.

**** Should we distinguish well-formedness errors from invalidity errors?
(I think not: we may want to recover from a bad start-tag by implying
an end-tag.)

**** Seems to be a bug with Emacs, where a mouse movement that causes
help-echo text to appear counts as pending input but does not cause
idle timer to be restarted.

**** Use XML to represent this file.

**** I had a TODO which said simply "split-string".  What did I mean?

**** Investigate performance on large files all on one line.

*** Issues for Emacs versions >= 22

**** Take advantage of UTF-8 CJK support.

**** Supply a next-error-function.

**** Investigate this NEWS item "Emacs now tries to set up buffer coding
systems for HTML/XML files automatically."

**** Take advantage of the pointer text property.

**** Leverage char-displayable-p.

** RefTeX

*** Provide a wdired-like mode for editing RefTeX TOC buffers.
As a first step, renaming of sections could be supported.  Ultimately,
it would be great if it also supported moving sections, e.g., by
killing and yanking or providing org-mode like "move section
upwards/downwards" commands.  However, that's not so easy in the
presence of multi-file documents.

* Internal changes

** Cleanup all the GC_ mark bit stuff -- there is no longer any distinction
   since the mark bit is no longer stored in the Lisp_Object itself.

** Refine the 'predicate' arg to read-file-name.
   Currently, it mixes up the predicate to apply when doing completion and the
   one to use when terminating the selection.

** Merge ibuffer.el and buff-menu.el.
   More specifically do what's needed to make ibuffer.el the default,
   or just an extension of buff-menu.el.

** Replace linum.el with nlinum.el
   https://lists.gnu.org/r/emacs-devel/2013-08/msg00379.html

** Merge sendmail.el and messages.el.
   Probably not a complete merge, but at least arrange for messages.el to be
   a derived mode of sendmail.el.  Or arrange for messages.el to be split
   into a small core and "the rest" so that we use less resources as long as
   we stick to the features provided in sendmail.el.

** Replace gmalloc.c with the modified Doug Lea code from the current
   GNU libc so that the special mmapping of buffers can be removed --
   that apparently loses under Solaris, at least. [fx has mostly done
   this.]

** Rewrite make-docfile to be clean and maintainable.
   It might be better to replace it with Lisp, using the byte compiler.
   https://lists.gnu.org/r/emacs-devel/2012-06/msg00037.html

** Add an inferior-comint-minor-mode to capture the common set of operations
   offered by major modes that offer an associated inferior
   comint-derived mode.  I.e. basically make cmuscheme.el/inf-lisp.el generic.
   For use by sml-mode, python-mode, tex-mode, scheme-mode, lisp-mode,
   haskell-mode, tuareg-mode, ...

** Add "link" button class
   Add a standard button-class named "link", and make all other link-like
   button classes inherit from it.  Set the default face of the "link" button
   class to the standard "link" face.

* Wishlist items:

** Maybe replace etags.c with a Lisp implementation.
https://lists.gnu.org/r/emacs-devel/2012-06/msg00354.html

** Maybe replace lib-src/rcs2log with a Lisp implementation.
It wouldn't have to be a complete replacement, just enough
for vc-rcs-update-changelog.

* Other known bugs:

** 'make-frame' forgets unhandled parameters, at least for X11 frames.

** a two-char comment-starter whose two chars are symbol constituents will
not be noticed if it appears within a word.


This file is part of GNU Emacs.

GNU Emacs is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

GNU Emacs is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

;; Local Variables:
;; coding: utf-8
;; End:
