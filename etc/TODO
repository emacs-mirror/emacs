Emacs TODO List                                                   -*-outline-*-

Copyright (C) 2001-2022 Free Software Foundation, Inc.
See the end of the file for license conditions.


If you are ready to start working on any of these TODO items, we
appreciate your help; please write to emacs-devel@gnu.org so we can be
aware that the problem is being addressed, and talk with you how to do
it best.  Also to check that it hasn't been done already, since we
don't always remember to update this file!  It is best to consult
the latest version of this file in the Emacs source code repository.

Since Emacs is an FSF-copyrighted package, please be prepared to sign
legal papers to transfer the copyright on your work to the FSF.
Copyright assignment is a simple process.  Residents of some countries
can do it entirely electronically.  We can help you get started, and
answer any questions you may have (or point you to the people with the
answers), at the emacs-devel@gnu.org mailing list.

For more information about getting involved, see the CONTRIBUTE file.

As well as the issues listed here, there are bug reports at
<https://debbugs.gnu.org>.  Bugs tagged "easy" ought to be suitable for
beginners to work on, but unfortunately we are not very good at using
this tag.  Bugs tagged "help" are ones where assistance is required,
but may be difficult to fix.  Bugs with severity "important" or higher
are the ones we consider more important, but these also may be
difficult to fix.  Bugs with severity "minor" may be simpler, but this
is not always true.

* High Priority Items

** Things related to elpa.gnu.org.
We need to figure out how to best include GNU ELPA packages in the
Emacs tarball before doing any of the items below.

*** Move idlwave to elpa.gnu.org
Need to sync up the Emacs and external versions.
See <https://lists.gnu.org/r/emacs-devel/2014-07/msg00008.html>
<https://debbugs.gnu.org/39992>

*** Move Org mode to elpa.gnu.org
See <https://lists.gnu.org/r/emacs-devel/2014-08/msg00300.html>
<https://lists.gnu.org/r/emacs-devel/2014-11/msg00257.html>

*** Move verilog-mode to elpa.gnu.org
See <https://lists.gnu.org/r/emacs-devel/2015-02/msg01180.html>

*** Move vhdl-mode to elpa.gnu.org
See <https://lists.gnu.org/r/emacs-devel/2015-02/msg01180.html>

* Simple tasks
These don't require much Emacs knowledge and are suitable for anyone
from beginners to experts.

** Convert modes that use view-mode to be derived from special-mode instead

** Major modes should have a menu entry

** Check if all items on the mode-line have a suitable tooltip for all modes

** edebug and debugger-mode should have a toolbar
It can use the same icons as gud.

** Check what minor modes don't use define-minor-mode
Convert those to use it.

** Remove unnecessary autoload cookies from defcustoms
This needs a bit of care, since often people have become used to
expecting such variables to always be defined, eg when they modify
things in their .emacs.

** See if other files can use generated-autoload-file (see eg ps-print)

** Do interactive mode tagging for commands
Change "(interactive)" to "(interactive nil foo-mode)" for command
completion purposes.  Pick a major mode or ELisp library, and check
all interactive commands to see if they are only relevant in one
particular mode.  This requires care as some commands might be useful
outside of the mode they were written for.

** Write more tests
Pick a fixed bug from the database, write a test case to make sure it
stays fixed.  Or pick your favorite programming major-mode, and write
a test for its indentation.  Or a version control backend, and write a
test for its status parser.  Etc.  See the 'test' directory for
examples.

* Small but important fixes needed in existing features

** A better display of the bar cursor
Distribute a bar cursor of width > 1 evenly between the two glyphs on
each side of the bar (what to do at the edges?).

** revert-buffer should eliminate overlays and the mark
For related problems consult the thread starting with
https://lists.gnu.org/r/emacs-devel/2005-11/msg01346.html

** erase-buffer should perhaps disregard read-only properties of text

** Fix the kill/yank treatment of invisible text
At the moment, invisible text is placed in the kill-ring, so that the
contents of the ring may not correspond to the text as displayed to
the user.  It ought to be possible to omit text which is invisible
(due to a text-property, overlay, or selective display) from the
kill-ring.

** Change cursor shape when Emacs is idle
When Emacs is idle for more than a specified time, change the cursor
shape to indicate the idleness.

** Improve buttons in the Custom buffer
The buttons at the top of a Custom buffer should not omit variables
whose values are currently hidden.

** Clean up the variables in browse-url
Perhaps use a shell command string to specify the browser instead of
the mushrooming set of functions.

See also ESR's proposal for a BROWSER environment variable
<URL:http://www.catb.org/~esr/BROWSER/browse-url.patch>.

** Enhance scroll-bar to handle tall line (similar to line-move)

** In Custom buffers, put the option that turns a mode on or off first
This should use a heuristic of some kind?

** Define recompute-arg and recompute-arg-if for fix_command to use
See rms message of 11 Dec 05 in
https://lists.gnu.org/r/emacs-pretest-bug/2005-12/msg00165.html,
and the rest of that discussion.

** In Emacs Info, examples of using Customize should be clickable
They should create Custom buffers when clicked.

** Add function to redraw the tool bar

** Redesign the load-history data structure
It should cope better with evaluating definitions of the same function
from different files, recording which file the latest definition came
from.

** Make back_comment use syntax-ppss or equivalent

** Consider improving src/sysdep.c's search for a fqdn
https://lists.gnu.org/r/emacs-devel/2007-04/msg00782.html

** Find a proper fix for rcirc multiline nick adding
https://lists.gnu.org/r/emacs-devel/2007-04/msg00684.html

** Check for any included packages that define obsolete bug-reporting commands
Change them to use report-emacs-bug.

*** Related functions (do all of them need changing?):
**** org-submit-bug-report
**** lm-report-bug
**** tramp-bug
**** c-submit-bug-report

** Allow fringe indicators to display a tooltip
Provide a help-echo property?

** Add a defcustom that supplies a function to name numeric backup files
Like 'make-backup-file-name-function' for non-numeric backup files.

** 'dired-mode' should specify the semantics of 'buffer-modified-p'
Needed for dired buffers and DTRT WRT 'auto-revert-mode'.

** Check uses of prin1 for error-handling
https://lists.gnu.org/r/emacs-devel/2008-08/msg00456.html

* Important features

** Speed up Elisp execution

*** Speed up function calls
Change src/bytecode.c so that calls from byte-code functions to byte-code
functions don't go through Ffuncall/funcall_lambda/exec_byte_code but instead
stay within exec_byte_code.

*** Improve the byte-compiler to recognize immutable bindings
Recognize immutable (lexical) bindings and get rid of them if they're
used only once and/or they're bound to a constant expression.

Such things aren't present in hand-written code, but macro expansion and
defsubst can often end up generating things like
(funcall (lambda (arg) (body)) actual) which then get optimized to
(let ((arg actual)) (body)) but should additionally get optimized further
when 'actual' is a constant/copyable expression.

** Add an "indirect goto" byte-code
Such a byte-code can be used for local lambda expressions.
E.g. when you have code like

   (let ((foo (lambda (x) bar)))
     (dosomething
      (funcall foo toto)
      (blabla (funcall foo titi))))

turn those 'funcalls' into jumps and their return into indirect jumps back.

*** Compile efficiently local recursive functions
Similar to the previous point, we should be able to handle something like

   (letrec ((loop () (blabla) (if (toto) (loop))))
     (loop))

which ideally should generate the same byte-code as

   (while (progn (blabla) (toto)))

** "Emacs as word processor"
https://lists.gnu.org/r/emacs-devel/2013-11/msg00515.html
 rms writes:
    25 years ago I hoped we would extend Emacs to do WYSIWYG word
    processing.  That is why we added text properties and variable
    width fonts.  However, more features are still needed to achieve this.

Specifically, a major mode with the following features and abilities
should be added to Emacs:

 . import / export MS Office documents
 . import / export Open Document Format (.odt) files
 . import / export RTF files
 . export to a PDF file
 . select a font and its size
 . apply a bold / italic / underline / strikethrough effect
 . superscripts / subscripts
 . apply a left / center / right / justified effect
 . change the font color and the background color
 . pixel-level text fill, justification, and indentation (so that
   variable-pitch fonts could be freely used)
 . create a list
 . insert and change a table
 . insert a picture
 . define / use / modify styles
 . print preview / print, in a way that is similar to what's on screen
   (e.g., wrt the place where lines wrap)
 . use footnotes
 . support for "track changes" markings, including those which come
   from Office documents
 . multiple columns
 . change page headers and footers
 . save all the properties and settings mentioned above with the text
   to a file, so that they are restored when later visiting that file

The existing Enriched mode can be used as a starting point.

** Support ligatures out of the box
For the list of frequently-used typographical ligatures, see

  https://en.wikipedia.org/wiki/Orthographic_ligature#Ligatures_in_Unicode_(Latin_alphabets)

(Note that in general, the number of possible ligatures can be much
larger, and there's no way, in principle, to specify the superset of
all the ligatures that could exist.  Each font can support different
ligatures.  The reliable way of supporting any and all ligatures is to
hand all text to be displayed to the shaping engine and get back the
font glyphs to display that text.  However, doing this is impossible
with the current design of the Emacs display engine, since it examines
buffer text one character at a time, and implements character
composition by calls to Lisp, which makes doing this for every
character impractically slow.  Therefore, the rest of this item
describes a limited form of ligature support which is compatible with
the current display engine design and uses automatic compositions.)

For Text and derived modes, the job is to figure out which ligatures
we want to support, how to let the user customize that, and probably
define a minor mode for automatic ligation (as some contexts might not
want, say, "fi" or "ff" always yield a ligature, and also because it
might slow down redisplay, because character composition goes through
Lisp).

For ligature support in programming language modes, one can look at
the various add-on packages out there that provide the feature via
prettify-symbols-mode.  We need to figure out which ligatures are
needed for each programming language, and provide user options to turn
this on and off.

The implementation should use the infrastructure for automatic
character compositions, i.e., we should define appropriate
regexp-based rules for character sequences that need to be composed
into ligatures, and populate composition-function-table with those
rules.  See composite.el for examples of this, and also grep
lisp/language/*.el for references to composition-function-table.

One problem with character compositions that will need to be solved is
that composition-function-table, the char-table which holds the
composition rules, is a global variable, whereas use of ligatures is
inherently specific to buffer-local stuff like the major mode and the
script or language in use.  So there should be a buffer-local variable
to augment/customize/override the global composition rules.

Another problem is that ligatures are frequently composed of ASCII
characters, and some of those ASCII characters are present in the mode
line, for example "--".  Since displaying a ligature instead of 2
separate '-' characters on a mode line is not right, there should be a
way of preventing the ligation from happening.  One possibility is to
have a ZWNJ character separate these ASCII characters; another
possibility is to introduce a special text property that prevents
character composition, and place that property on the relevant parts
of the mode line.  Yet another possibility would be to write a
specialized composition function, which would detect that it is called
on mode-line strings, and return nil to signal that composition is not
possible in this case; then use that function in the rules for
ligatures stored in composition-function-table.

The prettify-symbols-mode should be deprecated once ligature support
is in place.

A related, but somewhat independent, feature is being able to move the
cursor "into a ligature", whereby cursor motion commands shows some
pseudo-cursor on some part of a ligature.  For example, if "ffi" is
displayed as a ligature, then moving by one buffer position should
show the middle part of the ligature's glyph similar to the cursor
display: some special background and perhaps also a special
foreground.  There are two possible ways of figuring out the offset at
which to display the pseudo-cursor:

  . Arbitrarily divide the ligature's glyph width W into N parts,
    where N is the number of codepoints composed into the ligature, then
    move that pseudo-cursor by W/N pixels each time a cursor-motion
    command is invoked;
  . Use the font information.  For example, HarfBuzz has the
    hb_ot_layout_get_ligature_carets API for that purpose.  However,
    it could be that few fonts actually have that information recorded
    in them, in which case the previous heuristics will be needed as
    fallback.

One subtle issue needs to be resolved to have this feature of
"sub-glyph" cursor movement inside composed characters.  The way Emacs
currently displays the default block cursor is by simply redrawing the
glyph at point in reverse video.  So Emacs currently doesn't have a
way of displaying a cursor that "covers" only part of a glyph.  To
make this happen, the display code will probably need to be changed to
draw the cursor as part of drawing the foreground and/or background of
the corresponding glyph, which is against the current flow of the
display code: it generally first completely draws the background and
foreground of the entire text that needs to be redrawn, and only then
draws the cursor where it should be placed.

** Support for Stylistic Sets
This will allow using "alternate glyphs" supported by modern fonts.
For an overview of this feature, see

  https://www.typography.com/faq/157
  https://glyphsapp.com/tutorials/stylistic-sets

HarfBuzz supports this, see this discussion:

  https://lists.freedesktop.org/archives/harfbuzz/2019-September/007434.html

One possible way of letting Lisp program support this would be to
introduce a new text property 'stylistic-set' whose value will be the
set name(s), a symbol or a list of symbols.  Characters that have this
property should be processed specially by 'get_glyph_face_and_encoding':
instead of calling the 'encode_char' method of the font driver, we
should invoke the 'shape' method.  'hbfont_shape' should be extended
to pass to 'hb_shape_full' the required array of features, as
mentioned in the above HarfBuzz discussion.

** Concurrency
Stefan Monnier writes: "Including it as an 'experimental' compile-time
option sounds good.  Of course there might still be big questions
around 'which form of concurrency' we'll want."

** Better support for displaying Emoji
Emacs is capable of displaying Emoji and some of the Emoji sequences,
provided that its fontsets are configured with a suitable font.  To
make this easier out of the box, the following should be done:

*** Special face for displaying text presentation of Emoji
Emoji-capable fonts support Emoji sequences with the U+FE0F VARIATION
SELECTOR-16 (VS16) for emoji-style display, but usually don't support
the U+FE0F VARIATION SELECTOR-15 (VS15) for text-style display.  There
are other fonts which support the text-style sequences, but not
emoji-style.  Since Emacs selects a font based on a single character,
it cannot choose 2 different fonts for displaying both styles of the
same base character.  To display both styles in the same buffer, one
could use a special face, placing a 'face' text property on portions
of the text.  This special face could specify a specific font known to
support text-style Emoji sequences.  Emacs could have such a face
built-in.

See the discussion of bug#39799 for more details about this task.
Another relevant resource is the Unicode Technical Standard #51
"Unicode Emoji" (https://www.unicode.org/reports/tr51/).

** Extend text-properties and overlays

*** Several text-property planes
This would get us rid of font-lock-face property (and I'd be happy to
get rid of char-property-alias-alist as well) since font-lock would
simply use the 'face' property in the 'font-lock' plane.

Basically 'put-text-property' and friends would take an extra argument PLANE
(maybe the best backward-compatible way to do that is to make it so that
PROPERTY can be a cons cell (PLANE . PROP)).  So font-lock would
do (put-text-property start end '(font-lock . face) value).

All the properties coming from the various planes would get merged via an Elisp
function (so it can merge 'face' differently than 'keymap' or it could give
different priorities to different planes (we could imagine enabling/disabling
planes)).  The merging would not happen lazily while looking up properties but
instead it would take place eagerly in 'add-text-properties'.  This is based on
the idea that it's much more frequent to lookup properties than to
modify them.  Also, when properties are looked up during redisplay, we
generally can't run Elisp code, whereas we generally can do that when
properties are added.

*** Move overlays to intervals.c
Currently overlays are implemented as (two) sorted singly linked lists (one
for overlays_before some position and one for overlay_after that
position, for some quirky definition of "before" and "after").
The function 'overlay-recenter' changes the position used for the split
(and is called internally in various situations).

Each overlay is itself implemented with two markers (which keep track of
the overlay-start and overlay-end).  Markers are implemented as
a non-sorted singly linked list of markers.  So every text
insertion/deletion requires O(N) time, where N is the number of markers
since we have to go down that list to update those markers that are
affected by the modification.

You can start in src/buffer.[ch], maybe grepping for overlays_before for
a starting point.

Text-properties, OTOH, are implemented with a (mostly) balanced binary
tree.  This is implemented in src/intervals.[ch].

So we'd like to change overlays so that they don't use markers (and we
don't keep them in two sorted singly-linked lists) any more.  Instead,
we'll store them inside the balanced binary tree used for
text-properties.  I think we can use the "augmented tree" approach
described in https://en.wikipedia.org/wiki/Interval_tree.

To ease up debugging during development, I'd guess the implementation
would first add the new stuff, keeping the old stuff (i.e. add to
Lisp_Overlay whichever fields are needed for the new code, while keeping
the old ones, add needed overlay fields to the intervals tree, but keep
the old fields, the overlays_before etc...).  This way, you can add
consistency checks that make sure the new code computes the same results
as the old code.  And once that works well, we can remove the old code
and old fields.

** Implement Unicode-compliant display of "default-ignorable" characters
See the "Characters Ignored for Display" section of paragraph 5.21 in
the Unicode Standard for the details.

The implementation would import the data from Unicode UCD file
DerivedCoreProperties.txt, and provide a minor mode that arranges for
the characters with the Default_Ignorable_Code_Point (DI) property to
be hidden on display.  One way of implementing that could be via
glyphless-char-display-control; that one is global, but maybe there's
a way of making it buffer-local.  Alternatively, this could be
implemented in C in the display engine.

An additional aspect of this is the display of U+00AD SOFT HYPHEN as
invisible except at line boundaries.  Note that this would need to
support hard (physical) newlines in the buffer as well as soft
wrapping of long lines under 'visual-line-mode'.  The algorithm for
selecting the wrap point may also need be changed to break at the soft
hyphen.

** FFI (foreign function interface)
See eg https://lists.gnu.org/r/emacs-devel/2013-10/msg00246.html

One way of doing this is to start with fx's dynamic loading, and use it
to implement things like auto-loaded buffer parsers and database
access in cases which need more than Lisp.

** Fix portable dumping so that you can redump without using -batch

*** Redumps and native compiler "preloaded" sub-folder.
In order to depose new .eln files being compiled into the "preloaded"
sub-folder the native compiler needs to know in advance if this file
will be preloaded or not.  As .eln files are not moved afterwards
subsequent redumps might refer to .eln file out of the "preloaded"
sub-folder.

** Imenu could be extended into a file-structure browsing mechanism
This could use code like that of customize-groups.

** Display something in the margin on lines that have compilation errors

** Compilation error navigation bar, parallel to the scroll bar
The bar should indicate where in the buffer there are compilation
errors.  Perhaps we could arrange to display these error indications
on top of the scroll bar itself.  That depends on to what extent
toolkit scroll bars are extensible.

** Provide user-friendly ways to list all available font families
Also for listing fonts, displaying a font as a sample, etc.

** Provide a convenient way to select a color with the mouse

** Rewrite the face code to be simpler, clearer and faster

** Program Enriched mode to read and save in RTF
Is there actually a decent single definition of RTF?  Maybe see info at
http://latex2rtf.sourceforge.net/.

This task seems to be addressed by
https://savannah.nongnu.org/projects/emacs-rtf/, which is still in
very early stages.

Another place to look is the Wikipedia article at
https://en.wikipedia.org/wiki/Rich_Text_Format.  It currently points to
the latest spec of RTF v1.9.1 at
https://web.archive.org/web/20190708132914/http://www.kleinlercher.at/tools/Windows_Protocols/Word2007RTFSpec9.pdf

** Better support for variable-pitch faces
Implement primitive and higher-level functions to allow filling
properly with variable-pitch faces.

** Implement intelligent search/replace, going beyond query-replace
See http://groups.csail.mit.edu/uid/projects/clustering/chi04.pdf.

** Implement other text formatting properties

*** Footnotes that can appear either in place or at the end of the page

*** text property that says "don't break line in middle of this"
Don't break the line between two characters that have the same value
of this property.

*** Discretionary hyphens that are not visible when they are at end of line

** Internationalize Emacs's messages

** Set up a facility to save backtraces
Save backtraces when errors happen during specified filters, specified
timers, and specified hooks.

** Install mmc@maruska.dyndns.org's no-flicker change
https://lists.gnu.org/r/emacs-devel/2005-12/msg00699.html

I don't know if this is still relevant.  I can't reach the URLs in
the above message thread and double-buffering may have solved some
of the problems.

** Add a "current vertical pixel level" value
This should go with point, so that motion commands can also move
through tall images.  This value would be to point as window-vscroll
is to window-start.

** Make redisplay smarter about which parts to redraw
Currently, redisplay has only 2 levels of redrawing: either it
redisplays only the selected window on the selected frame, or it
redisplays all the windows on all the frames.  This doesn't scale well
when the number of visible frames is large.

Currently, two variables are used to make the decision what to
redisplay: update_mode_lines and windows_or_buffers_changed.  These
are set by various functions called from Lisp, and if redisplay finds
one of them to be non-zero, it considers all the windows on all the
frames for redisplay.

The idea is to make the decision which parts need to be redrawn more
fine-grained.  Instead of simple boolean variables, we could have a
bitmapped variable which records the kinds of changes done by Lisp
since the previous redisplay cycle.  Then the decision what exactly
needs to be redrawn could be made based on the bits that are set.

For example, one reason to consider all frames is that some scrolling
command sets the update_mode_lines variable non-zero.  This is done
because the frame title, which doesn't belong to any window, needs to
be reconsidered when the selected window is scrolled.  But considering
the frame title doesn't have to redisplay all the other windows on the
frame, doesn't need to recompute the menu items and the tool-bar
buttons, and doesn't need to consider frames other than the selected
one.  Being selective about what parts of the Emacs display need to be
reconsidered and redrawn given the changes since the last redisplay
will go along way towards making redisplay more scalable.

One way of making this change is to go through all the places that set
update_mode_lines and windows_or_buffers_changed, figure out which
portions of the Emacs display could be affected by each change, and
then implement the bitmap which will record each of these affected
display portions.  The logic in redisplay_internal will then need to
be restructured so as to support this fine-grained redisplay.

** Address internationalization of symbols names
Essentially as if they were documentation, e.g. in command names and
Custom.

** Make the Lucid menu widget display multilingual text
This probably needs to be done from actual Emacs buffers, either
directly in the menu or by rendering in an unmapped window and copying
the pixels.  The current code assumes a specific locale; that isn't
good enough even if X can render the arbitrary text.  The gtk port now
displays multilingual text in menus, but only insofar as Emacs can
encode it as utf-8 and gtk can display the result.  Maybe making
Lucid menus work like Gtk's (i.e. just force utf-8) is good enough now
that Emacs can encode most chars into utf-8.

** The GNUstep port needs some serious attention
Ideally from someone familiar with GNUstep and Objective C.

* Other features we would like

** A more modern printing interface
A UI that pops up a dialog that lets you choose printer, page style,
etc.  Integration with the Gtk print dialog is apparently difficult.
See eg: https://lists.gnu.org/r/emacs-devel/2009-03/msg00501.html
https://lists.gnu.org/r/emacs-devel/2009-04/msg00034.html

** Allow frames(terminals) created by emacsclient to inherit their environment
They should inherit environment from the emacsclient process.

** Give Tar mode all the features of Archive mode

** Create a category of errors called 'process-error'
Do this for some or all errors associated with using subprocesses.

** Maybe reinterpret 'parse-error' as a category of errors
Put some other errors under it.

** Make byte-optimization warnings issue accurate line numbers

** Record the sxhash of the default value for customized variables
Also, the user (maybe by adding a menu item or toolbar button, as the
detection can occur during autoload time) when the default changes
(meaning that new versions of the Lisp source with a changed default
value got installed) and offer ediff on the respective customization
buffers.

** Emacs Lisp mode could put an overlay on the defun for advised functions
The overlay could have 'after-text' like " [Function has advice]".  It
might look like (defun foo [Function has advice] (x y) The overlay
could also be a button that you could use to view the advice.

** Add a function to get the insertion-type of the markers in an overlay

** Improve VC
Yes, there's a lot of work to be done there :-(

** Improve the "code snippets" support
Consolidate skeleton.el, tempo.el, and expand.el (any other?) and then
advertise/use/improve it.

** ange-ftp

*** Make ange-ftp understand sftp
This is hard to make work because sftp doesn't print status messages.

*** Use MLS for ange-ftp-insert-directory if a list of files is specified

** Ability to map a key, including all modified-combinations
E.g map mouse-4 to wheel-up as well as M-mouse-4 -> M-wheel-up
M-C-mouse-4 -> M-C-wheel-up, H-S-C-M-s-double-mouse-4 ->
H-S-C-M-s-double-wheel-up, ...

** Beefed-up syntax-tables

*** Recognize multi-character syntactic entities like 'begin' and 'end'

*** Nested string-delimiters (for PostScript's (foo(bar)baz) strings)

*** Support for infix operators (with precedence)

*** Support for the $ (paired delimiter) in parse-partial-sexp

*** Support for hook-chars whose effect is specified by ELisp code
Hook-chars could have their effect on the parsing-state specified by
ELisp code.  Thus a character could both close a string and open a
comment at the same time and do it in a context-sensitive way.

*** Ability to add mode-specific data to the partial-parse-state

** Add a way to convert a keyboard macro to equivalent Lisp code

** Have a command suggestion help system
The idea is to recognize patterns of commands which could be replaced
with a simpler common command.  It should not make more than one
suggestion per 10 minutes.

** Add a way to define input methods by computing them
When an input method is first used, redefine C-x 8 to use a
user-selected input method, with the default being the union of
latin-1-prefix and latin-1-postfix.

** Implement a clean way to use several major modes in a buffer
Different parts of a buffer could use different major modes.  This
could be useful in editing Bison input files, for instance, or other
kinds of text where one language is embedded in another language.  See
http://www.loveshack.ukfsn.org/emacs/multi-mode.el and also mmm-mode,
as reference for approaches taken by others.

** A more convenient use of input methods in search
Arrange a way for an input method to return the first character
immediately, then replace it later.  So that C-s a with input method
latin-1-postfix would immediately search for an a.

** Give start-process the ability to redirect standard-error
It should be possible to redirect stderr to a different filter.
(Isn't this already possible in Emacs 27?)

** Give desktop.el a feature to switch between different named desktops

** Add a cpio mode, more or less like tar mode

** Save undo information in special temporary files, and reload it
Reload the file when needed for undoing.  This could extend undo
capacity.  undo-tree, in ELPA, already does this; its saving code
could be integrated without requiring the use of undo-tree.

** Change the Windows NT menu code
Change the code so that it handles the deep_p argument and avoids
regenerating the whole menu-bar menu tree except when the user tries
to use the menubar.

This requires the RIT to forward the WM_INITMENU message to the main
thread, and not return from that message until the main thread has
processed the MENU_BAR_ACTIVATE_EVENT and regenerated the whole menu
bar.  In the mean time, it should process other messages.

** Get some major packages installed

*** W3 (development version needs significant work)

*** PSGML, _possibly_ ECB
https://lists.gnu.org/r/emacs-devel/2007-05/msg01493.html Check the
assignments file for other packages which might go in and have been
missed.

** Make byte-compiler warnings smarter
Byte-compiler warnings about functions that might be undefined at run
time should be smarter, so that they know which files are required by
the file being compiled and don't warn about functions defined in
them.

** Split out parts of lisp.h

** Update the FAQ

** Allow auto-compression-mode to use zlib calls if zlib is available
Zlib is required for PNG, so may be linked anyhow.

** Improve the GC
Introduce generational or incremental GC.  We may be able to use the
Boehm collector.)  See the Boehm-GC branch in CVS for work on this.

** Check what hooks would help Emacspeak
See the defadvising in W3.

** Add definitions for symbol properties, for documentation purposes

** Temporarily remove scroll bars when they are not needed
Typically when a buffer can be fully displayed in its window.

** Compute scroll bar's slider by lines
Provide an optional feature which computes a scroll bar slider's
size and its position from lines instead of characters.

** Allow displaying an X window from an external program in a buffer
E.g. to render graphics from Java applets.  [gerd and/or wmperry
thought this was feasible.]  [Is xwidget that feature?]

** Allow images (not just text) in the margin to be mouse-sensitive
This requires recursing through display properties.  Provide some way
to simulate mouse-clicks on marginal text without a mouse.

** Extend ps-print

*** It should deal with multiple font sizes, images, and extra encodings

*** Eliminate the current restriction on header printing by ps-print
Currently, a header can contain only single 1-byte charset in addition
to ASCII.

*** Provide a user friendly interface to specify fonts

** Use the XIE X extension, if available, for image display
This is obsolete, as XIE itself is now considered obsolete.

** Make monochrome images honor the face
Display those images using the foreground and background colors of the
applicable faces.

** Make 'format-time-string' preserve text properties like 'format'

** Optionally make the cursor a little thinner at EOL and EOB

** Reorder defcustom's in each package by importance
The more important options should come first in the Customize buffers.
This could be done by either rearranging the file (since options are
shown in the order they appear in the *.el files), or by adding a few
:set-after attributes.

** Maybe document the features of libraries missing from the manual
Also in ancillary manuals, including the Lisp manual in some cases.
This is not worth doing for all of these packages and we need not aim
for completeness, but some may be worth documenting.

Here's a list which is probably not complete/correct: align, allout,
artist, ansi-color, array, calculator, cdl, cmuscheme, completion,
delim-col, dirtrack, double, echistory, elide-head, easymenu, expand,
flow-ctrl, format [format-alist], generic/generic-x [various modes],
kermit, log-edit, makesum, midnight [other than in Kill Buffer node],
mouse-copy [?], mouse-drag, mouse-sel, net-utils, rcompile, snmp-mode
[?], soundex [should be interactive?], strokes [start from the web
page], talk, thingatpt [interactive functions?], type-break, vcursor,
xscheme, zone-mode [?], mlconvert [?], iso-cvt, feedmail [?], uce,
gametree, page-ext, refbib, refer, scribe, texinfo, underline,
cmacexp, hideif, pcomplete, xml, cvs-status (should be described in
PCL-CVS manual); other progmodes, probably in separate manual.

** Convenient access to the 'values' variable
It would be nice to have an interface that would show you the printed
reps of the elements of the list in a menu, let you select one of the
values, and put it into some other variable, without changing the
value of 'values'.

** Make open and close syntax match exactly
Make open and close syntax match exactly, i.e. '(' doesn't match ']'.
This should be controlled by a flag.

** Use ID-FORMAT in 'file-attributes' and 'directory-files-and-attributes'
Specify an explicit parameter ID-FORMAT in all calls to these
functions where attributes UID or GID are used.  Whenever possible,
use 'string'.  When done, change meaning of default value from
'integer' to 'string'.  If value 'integer' is used nowhere, remove the
parameter ID-FORMAT from the definition of 'file-attributes' and
'directory-files-and-attributes' and from the calls.

** Make language-info-alist customizable
Currently a user can customize only the variable
'current-language-environment'.

** Improve language environment handling
Allow Emacs to fit better to a user's locale.  Currently Emacs uses
UTF-8 language environment for all UTF-8 locales, thus a user in
ja_JP.UTF-8 locale are also put in UTF-8 language environment.  In
such a case, it is better to use Japanese language environment, while
preferring the utf-8 coding system.

** Enhance locale handling
Handle language, territory and charset orthogonally, and de-emphasize
language environments.  Use the locale to set up more things, such as
fontsets, the default Ispell dictionary, diary format, calendar
holidays and display, quoting characters and phrase boundaries,
sentence endings, collation for sorting (at least for unicodes), HTTP
Accept-language, patterns for directory listings and compilation
messages, yes-or-no replies, common menu items when the toolkit
supports it ...  'locale-info' needs extending for LC_COLLATE &c.  [fx
started on this.]

** Enhance word boundary detection
This is needed for scripts that don't use space at word boundary
(e.g., Thai).

** Implement interface programs with major Japanese input methods
The idea is to write programs in lib-src for interfacing with Japanese
conversion servers so that they can be used from the input method
"japanese".  Currently, most Japanese users are using external
packages (e.g. tamago, anthy) or an input method via XIM.

** Let LEIM handle the Mode_switch key like XIM does
I.e. a toggle like C-\ but which can also be used as a modifier.

** Improve Help buffers
Change the face of previously visited links (like Info, but also with
regard to namespace), and give the value of lisp expressions, e.g
auto-mode-alist, the right face.

** Possibly make 'list-holidays' eval items in the calendar-holidays variable
See thread <https://lists.gnu.org/r/emacs-devel/2006-02/msg01034.html>.
[rgm@gnu.org will look at this after 22.1]

** Possibly make cal-dst use the system timezone database directly
See thread <https://lists.gnu.org/r/emacs-pretest-bug/2006-11/msg00060.html>.

** Possibly add a "close" button to the modeline
The idea is to add an "X" of some kind, that when clicked deletes the
window associated with that modeline.
https://lists.gnu.org/r/emacs-devel/2007-09/msg02416.html

** Random things that were planned for Emacs-24

Stefan Monnier writes: "Random things that cross my mind right now
that I'd like to see.  Some of them from my local hacks, but it's not
obvious at all whether they'll make it."

*** Prog-mode could/should provide a better fill-paragraph default
That default should use syntax-tables to recognize string/comment
boundaries.

*** Provide more completion-at-point-functions
Make existing in-buffer completion use completion-at-point.

*** "Functional" function-key-map
It would make it easy to add (and remove) mappings like
"FOO-mouse-4 -> FOO-scroll-down",   "FOO-tab -> ?\FOO-\t",
"uppercase -> lowercase", "[fringe KEY...] -> [KEY]",
"H-FOO -> M-FOO", "C-x C-y FOO -> H-FOO", ...

* Things to be done for specific packages or features

** NeXTstep port

*** Missing features
This sections contains features found in other official Emacs ports.

**** Support for xwidgets
Emacs 25 has support for xwidgets, a system to include operating
system components into an Emacs buffer.  The components range from
simple buttons to webkit (effectively, a web browser).

Currently, xwidgets work only for the gtk+ framework but they are
designed to be compatible with multiple Emacs ports.

(See the scratch/nsxwidget branch, and the discussion around
Objective-C code and GCC at
https://lists.gnu.org/r/emacs-devel/2019-08/msg00072.html )

**** Respect 'frame-inhibit-implied-resize'
When the variable 'frame-inhibit-implied-resize' is non-nil, frames
should not be resized when operations like changing font or toggling
the tool bar is performed.

Unfortunately, the tool bar (and possible other operations) always
resize the frame.

**** Support 'proced' (implement 'process-attributes')
Unfortunately, a user-level process like Emacs does not have the
privileges to get information about other processes under macOS.

There are other ways to do this:

 1) Spawn "ps" and parse the output ("ps" has superuser privileges).

 2) Sign Emacs as part of the distribution process.

 3) Ask the user to self-sign Emacs, if this feature is of interest.

Anders Lindgren <andlind@gmail.com> has implemented
'process-attributes' for macOS, which currently only work when
running Emacs as root.

See this article by Bozhidar Batsov for an overview of Proced:
https://emacsredux.com/blog/2013/05/02/manage-processes-with-proced/

**** Tooltip properties
Tooltip properties like the background color and font are hard-wired,
even though Emacs allows a user to customize such features.

*** New features
This section contains features unique to Nextstep and/or macOS.

**** PressAndHold for writing accented character
On macOS, many application support the press and hold pattern to
invoke a menu of accented characters.  (See example at
https://support.apple.com/en-us/HT201586 .)

Currently, this doesn't work in Emacs.

Note that "ns-win.el" explicitly disables this.

Note: This feature might not be allowed to be implemented until also
implemented in Emacs for a free system.

**** Floating scroll bars
In modern macOS applications, the scroll bar often floats over the
content, and is invisible unless actually used.  This makes the user
interface less cluttered and more area could be used to contain text.

With floating scroll bars, the user interface would look like it does
when they are disabled today.  However, they will be made visible when
a scroll action is initiated, e.g. by putting two fingers on a
trackpad.

Note: This feature might not be allowed to be implemented until also
implemented in Emacs for a free system.

*** Features from the "mac" port
This section contains features available in the "mac" Emacs port.

As the "mac" port (as of this writing) isn't an official Emacs port,
it might contain features not following the FSF rule "must exist on
free systems".

The "mac" port is based on the Emacs 22 C-based Carbon interface.
It has been maintained in parallel to the official Cocoa-based NS
interface.  The Carbon interface has been enhanced, and a number of the
features of that interface could be implemented NS.

**** Smooth scrolling -- maybe not a good idea
Today, by default, scrolling with a trackpad makes the text move in
steps of one line.  (Scrolling with SHIFT scrolls horizontally.)

The "mac" port provides smooth, pixel-based, scrolling.  This is a very
popular feature.  However, there are drawbacks to this method: what
happens if only a fraction of a line is visible at the top of a
window, is the partially visible text considered part of the window or
not?  (Technically, what should 'window-start' return.)

Note: This feature might not be allowed to be implemented until also
implemented in Emacs for a free system.

**** Mouse gestures
The "mac" port defines the gestures 'swipe-left/right/up/down',
'magnify-up/down', and 'rotate-left/right'.

It also binds the magnification commands to change the font
size.  (This should be not be done in a specific interface, instead
Emacs should do this binding globally.)

Note: This feature might not be allowed to be implemented until also
implemented in Emacs for a free system.

**** Synthesize bold fonts

*** Open issues
This section contains issues where there is an ongoing debate.

**** Key bindings of CMD and ALT
Currently in the "ns" port, ALT is bound to Meta and CMD is bound to
Super -- allowing the user to use typical macOS commands like CMD-A to
mark everything.

Unfortunately, when using an international keyboard, you can't type
normal characters like "(" etc.

There are many alternative key bindings.  One solution is to bind CMD
to Meta and pass ALT to the system.  In fact, this is what Emacs did up
to, and including, version 22.  Also, this is how the "mac" port binds
the keys.

One could envision asymmetrical variants as well, however, this is
inappropriate for the default setting.

See the discussion on emacs-devel:
https://lists.gnu.org/r/emacs-devel/2015-12/msg01575.html
https://lists.gnu.org/r/emacs-devel/2016-01/msg00008.html

*** Internal development features

**** Regression test system (or at least a checklist)
Today, after each change to the user interface, Emacs must be manually
tested.  Often, small details are overlooked ("Oh, I didn't test
toggling the tool-bar in one of the full screen modes, when multiple
frame were open -- silly me.")

It would be an enormous help if this could be tested automatically.
Many features are generic, however, the NS interface provides a number
of unique features.

**** Existing packages
Note that there is a generic UI test named frame-test.el, see
https://debbugs.gnu.org/21415#284 .
The NS interface passes this, with the exception of two toolbar-related errors.

**** Anders frame test
Anders Lindgren <andlind@gmail.com> has implemented some (very basic)
tests for full screen, toolbar, and auto-hiding the menu bar.

**** Make sure all build variants work
Emacs can be build in a number of different ways.  For each feature,
consider if is really is "NS" specific, or if it should be applied to
all build versions.

- With the "NS" interface.  This is the normal way to build Emacs on
  macOS.

- With the "X11" interface.  On macOS, this is mainly of interest to
  developers of Emacs to get a "reference" interface implementations.
  However, it might be of interest for people working remotely, as X11
  applications can be used over a network connection.

- Console only.

*** Bugs

**** Toggling the toolbar in fullheight or maximized modes
The toolbar, in the NS interface, is not considered part of the text
area.  When it is toggled, the Emacs frame change height accordingly.

Unfortunately, this also occurs when the frame is in fullheight or
maximized modes (N.B. this is not the same as "fullscreen").  The
effect is that the full frame size either increases (stretching down
below the lower edge of the screen) or decreases (leaving space
between the lower edge of the frame and the lower edge of the screen).

A better solution would be for the frame to retain its size,
i.e. change the text area.

This is related to the 'frame-inhibit-implied-resize' issue.

**** The event loop does not redraw
A problem is that redraw don't happen during resize,
because we can't break out from the NSapp loop during resize.
There was a special trick to detect mouse press in the lower right
corner and track mouse movements, but this did not work well, and was
not scalable to the new Lion "resize on every window edge" behavior.
[As of trunk r109635, 2012-08-15, the event loop no longer polls.]

**** mouse-avoidance-mode
(mouse-avoidance-mode 'banish) then minimize Emacs, will pop window back
up on top of all others (probably fixed in bug#17439).

**** free_frame_resources, face colors

**** Numeric keysetting bug.

*** Mac-related

**** Open file:/// URLs.

**** Put frame autopositioning into C code somewhere -- if loc = same, offset.

**** Automap ctrl-mouse-1 to mouse-3.

**** Deal with Finder aliases somehow.

**** Ctrl-F2 won't pull up menus.

*** Other / Low Priority:

**** Better recognition of Unicode scripts / Greek / composition.

**** Undo for color-drag face customization.

** Bidirectional editing

*** Support reordering structured text
Two important use cases: (1) comments and strings in program sources,
and (2) text with markup, like HTML or XML.

One idea is to invent a special text property that would instruct the
display engine to reorder only the parts of buffer text covered by
that property.  The display engine will then push its state onto the
iterator stack, restrict the bidi iterator to accessing only the
portion of buffer text covered by the property, reorder the text, then
pop its state from stack and continue as usual.  This will require
minor changes in the bidi_it structure.

This design requires Lisp-level code to put the text properties on the
relevant parts of the buffer text.  That could be done using JIT
fontifications, or as a preliminary processing when the file is
visited.  With HTML/XML, the code that puts text properties needs to
pay attention to the bidi directives embedded in the HTML/XML stream.

*** Allow the user to control the direction of the UI

**** Introduce user option to control direction of mode line
One problem is the header line, which is produced by the same routines
as the mode line.  While it makes sense to have the mode-line
direction controlled by a single global variable, header lines are
buffer-specific, so they need a separate treatment in this regard.

**** User options to control direction of menu bar and tool bar
For the tool bar, it's relatively easy: set it.paragraph_embedding
in redisplay_tool_bar according to the user variable, and make
f->desired_tool_bar_string multibyte with STRING_SET_MULTIBYTE.  Some
minor changes will be needed to set the right_box_line_p and
left_box_line_p flags correctly for the R2L tool bar.

However, it makes no sense to display the tool bar right to left if
the menu bar cannot be displayed in the same direction.

R2L menu bar is tricky for the same reasons as the mode line.  In
addition, toolkit builds create their menu bars in toolkit-specific
parts of code, bypassing xdisp.c, so those parts need to be enhanced
with toolkit-specific code to display the menu bar right to left.

** Custom

*** Extend :set-after to also mean initialize after
If defcustom A specifies :set-after '(B), then if a user customizes
both A and B, custom will set A after B.  But if the user only customizes
A, then if B is already defined, it gets left at its original setting.
Instead, if B has not been customized it should be re-initialized
(on the assumption that the default value depends on A).
See the places where we manually call custom-reevaluate-setting,
such as for mail-host-address and user-mail-address in startup.el.

** nxml mode

*** High priority

**** Command to insert an element template
This should include all required attributes and child elements.  When
there's a choice of elements possible, we could insert a comment, and
put an overlay on that comment that makes it behave like a button with
a pop-up menu to select the appropriate choice.

**** Command to tag a region
With a schema should complete using legal tags, but should work
without a schema as well.

**** Provide a way to conveniently rename an element
With a schema should complete using legal tags, but should work
without a schema as well.

*** Outlining

**** Implement C-c C-o C-q

**** Install pre/post command hook for moving out of invisible section

**** Put a modify hook on invisible sections that expands them

**** Integrate dumb folding somehow

**** An element should be able to be its own heading

**** Optimize to avoid complete buffer scan on each command

**** Make it work with HTML-style headings
I.e., level indicated by name of heading element rather than depth of
section nesting.

**** Recognize root element as a section provided it has a title
Even if it doesn't match section-element-name-regex.

**** Support for incremental search automatically making hidden text visible

**** Allow title to be an attribute

**** Command that says to recognize the tag at point as a section/heading

**** Explore better ways to determine when an element is a section or a heading

**** Extend 'rng-next-error'
'rng-next-error' needs to either ignore invisible portion or reveal it
(maybe use isearch oriented text properties).

**** Errors within hidden section should be highlighted
They should be highlighted by underlining the ellipsis.

**** Make indirect buffers work
[??? Don't they already work?]

**** How should nxml-refresh outline recover from non well-formed tags?

**** Hide tags in title elements?

**** Use overlays instead of text properties for holding outline state?
Necessary for indirect buffers to work?

**** Allow an outline to go in the speedbar

**** Split up outlining manual section into subsections

**** More detail in the manual about each outlining command

**** More menu entries for hiding/showing?

**** Indication of many lines have been hidden?

*** Locating schemas

**** Should 'rng-validate-mode' allow to specify a schema?
Give the user an opportunity to specify a schema if there is currently
none?  Or should it at least give a hint to the user how to specify a
non-vacuous schema?

**** Support for adding new schemas to schema-locating files
Add documentElement and namespace elements.

**** C-c C-w should be able to report current type id

**** Implement doctypePublicId

**** Implement typeIdBase

**** Implement typeIdProcessingInstruction

**** Support xml:base

**** Implement group

**** Find preferred prefix from schema-locating files
Get rid of 'rng-preferred-prefix-alist'.

**** Inserting document element with vacuous schema should complete
Completion should use document elements declared in schema locating
files, and set schema appropriately.

**** Add a ruleType attribute to the <include> element?

**** Syntax of schema in prologue
Allow processing instruction in prologue to contain the compact syntax
schema directly.

**** Use RDDL to locate a schema based on the namespace URI

**** Should not prompt to add redundant association to schema locating file

**** Command to reload current schema

*** Schema-sensitive features

**** Should filter dynamic markup possibilities using schema validity
Should do this by adding hook to nxml-mode.

**** Dynamic markup word should be able to look in other buffers
It should be able to look in other buffers that are using nxml-mode
(at least optionally).

**** Should clicking on Invalid move to next error if already on an error?

**** Take advantage of a:documentation
Needs change to schema format.

**** Provide feasible validation (as in Jing) toggle

**** Save the validation state as a property on the error overlay
This would enable more detailed diagnosis.

**** Provide an Error Summary buffer showing all the validation errors

**** Pop-up menu
What is useful?  Tag a region (should be grayed out if the region is
not balanced).  Suggestions based on error messages.

**** Have configurable list of namespace URIs
So that we can provide namespace URI completion on extension elements
or with schema-less documents.

**** Allow validation to handle XInclude

**** ID/IDREF support

*** Completion

**** Make it work with icomplete
Only use a function to complete when some of the possible names have
undeclared namespaces.

**** How should C-return in mixed text work?

**** When there's a vacuous schema, C-return after < will insert the end-tag
Is this a bug or a feature?

**** Validation messages after completing start-tag
After completing start-tag, ensure we don't get unhelpful message from
validation

**** Syntax table for completion

**** Should complete start-tag name with a space
If namespace attributes are required.

**** Completing start-tag name with no prefix
When completing start-tag name with no prefix and it doesn't match
should try to infer namespace from local name.

**** Should completion pay attention to characters after point?
If so, how?

**** Completion of start-tag with only one attribute
When completing start-tag name, add required atts if only one required
attribute.

**** Completion of name of attribute with only one attribute value
When completing attribute name, add attribute value if only one value
is possible.

**** Completion of attribute values
After attribute-value completion, insert space after close delimiter
if more attributes are required.

**** Complete on enumerated data values in elements

**** Tag completion in context that allows only elements
When in context that allows only elements, should get tag completion
without having to type < first.

**** C-return completion immediately after start-tag name
When immediately after start-tag name, and name is valid and not
prefix of any other name, should C-return complete on attribute names?

**** Ignoring all attributes during attribute completion
When completing attributes, more consistent to ignore all attributes
after point.

**** Inserting attribute value by completions
Completions inserting attribute value need to be sensitive to what
delimiter is used so that they quote the correct character.

**** Complete on encoding-names in XML decl

**** Complete namespace declarations
Can be done by searching for all namespaces mentioned in the schema.

*** Well-formed XML support

**** Deal better with Mule-UCS

**** Deal with UTF-8 BOM when reading
[Isn't this already working when visiting XML files?]

**** Complete entity names

**** Provide some support for entity names for MathML

**** Command to repeat the last tag

**** Support for changing between character references and characters
Need to check that context is one in which character references are
allowed.  xmltok prolog parsing will need to distinguish parameter
literals from other kinds of literal.

**** Provide a comment command to bind to M-;
The command should work better than the normal one.

**** Make indenting in a multi-line comment work

**** Structure view
Separate buffer displaying element tree.  Be able to navigate from
structure view to document and vice-versa.

**** Flash matching >

**** Smart selection command
Provide a command that selects increasingly large syntactically
coherent chunks of XML.  If point is in an attribute value, first
select complete value; then if command is repeated, select value plus
delimiters, then select attribute name as well, then complete
start-tag, then complete element, then enclosing element, etc.

**** Ispell integration

**** Block-level items in mixed content
This should be indented, e.g:
  <para>This is list:
    <ul>
      <li>item</li>

**** Optionally different indentation style
Provide an option to indent like this:
    <para>This is a paragraph
     occupying multiple lines.</para>

**** Option to make a / that closes a start-tag electrically insert a space
Important for the XHTML guys.

**** C-M-q should work

*** Datatypes

**** Figure out workaround for CJK characters with regexps

**** Does category C contain Cn?

**** Do ENTITY datatype properly

*** XML Parsing Library

**** Parameter entity parsing option
Values: nil (never), t (always), unless-standalone (unless
standalone="yes" in XML declaration).

**** Option to parse a buffer
When a file is currently being edited, there should be an option to
use its buffer instead of the on-disk copy.

*** Handling all XML features

**** Provide better support for editing external general parsed entities
Perhaps provide a way to force ignoring undefined entities; maybe turn
this on automatically with <?xml encoding=""?> (with no version
pseudo-att).

**** Handle internal general entity declarations containing elements

**** Handle external general entity declarations

**** Handle default attribute declarations in internal subset

**** Handle parameter entities (including DTD)

*** RELAX NG

**** Do complete schema checking, at least optionally

**** Detect include/external loops during schema parse

**** Coding system detection for schemas
Should use utf-8/utf-16 per the spec.  But also need to allow
encodings other than UTF-8/16 to support CJK charsets that Emacs
cannot represent in Unicode.

*** Catching XML errors

**** Check public identifiers

**** Check default attribute values

*** Performance

**** Make the implementation of markers more efficient
Markers are implemented as a non-sorted singly linked list of markers.
This makes them scale badly when thousands of markers are created in a
buffer for some purpose, because some low-level primitives in Emacs
traverse the markers' list (e.g., when converting between character
and byte positions), and also because searching for a marker (e.g.,
with 'buffer-has-markers-at') becomes very slow.

**** Explore whether overlay-recenter can cure overlays performance problems

**** Cache schemas.  Need to have list of files and mtimes

**** Make it possible to reduce rng-validate-chunk-size significantly
Perhaps up to 500 bytes, without bad performance impact: don't do
redisplay on every chunk; pass continue functions on other uses of
rng-do-some-validation.

**** Cache after first tag

**** Introduce a new name class that is a choice between names
So that we can use member.

**** intern-choice should simplify after patterns with same 1st/2nd args

**** Large numbers of overlays slow things down dramatically
Represent errors using text properties.  This implies we cannot
incrementally keep track of the number of errors, in order to
determine validity.  Instead, when validation completes, scan for any
characters with an error text property; this seems to be fast enough
even with large buffers.  Problem with error at end of buffer, where
there's no character; need special variable for this.  Need to merge
face from font-lock with the error face: use :inherit attribute with
list of two faces.  How do we avoid making rng-valid depend on
nxml-mode?

*** Error recovery

**** Don't stop at newline in looking for close of start-tag

**** Use indentation to guide recovery from mismatched end-tags

**** Smarter parsing in presence of errors
Don't keep parsing when currently not well-formed but previously
well-formed.

**** Recovery from bad start-tag
Try to recover from a bad start-tag by popping an open element if
there was a mismatched end-tag unaccounted for.

Try to recover from a bad start-tag open on the hypothesis that there
was an error in the namespace URI.

**** Better recovery from ill-formed XML declarations

*** Usability improvements

**** Should print a "Parsing..." message during long movements

**** Provide better position for reference to undefined pattern error

**** Put Well-formed in the mode-line when validating against any-content

**** Trim marking of illegal data for leading and trailing whitespace

**** Show Invalid status as soon as we are sure it's invalid
That's instead of waiting for everything to be completely up to date.

**** Operation when narrowed
When narrowed, Valid or Invalid status should probably consider only
validity of narrowed region.

*** Bug fixes

**** Need to give an error for a document like: <foo/><![CDATA[  ]]>

**** Make nxml-forward-balanced-item work better for the prologue

**** Make filling and indenting comments work in the prologue

**** Should delete RNC Input buffers

**** Figure out what regex use for NCName and use it consistently

**** Should have not-well-formed tokens in ref

**** Require version in XML declaration?
Probably not because prevents use for external parsed entities.  At
least forbid standalone without version.

**** Reject schema that compiles to rng-not-allowed-ipattern

**** Move point backwards on schema parse error so that it's on the right token

*** Internal

**** Use rng-quote-string consistently

**** Use parsing library for XML to texinfo conversion

**** Rename xmltok.el to nxml-token.el
Use nxml-t- prefix instead of xmltok-.  Change nxml-t-type to
nxml-t-token-type, nxml-t-start to nxml-t-token-start.

**** Can we set fill-prefix to nil and rely on indenting?

**** xmltok should make available replacement text of entities with elements

**** In rng-valid, use same technique as nxml-mode
That's instead of using modification-hooks and insert-behind-hooks on
dependent overlays.

*** Fontification

**** Allow face to depend on element qname, attribute qname, attribute value
Use list with pairs of (R . F), where R specifies regexps and F
specifies faces.  How can this list be made to depend on the document
type?

*** Other

**** Support RELAX NG XML syntax (use XML parsing library)

**** Support W3C XML Schema (use XML parsing library)

**** Command to infer schema from current document (like trang)

*** Schemas

**** XSLT schema should take advantage of RELAX NG
So as to express co-occurrence constraints on attributes
(e.g. xsl:template).

*** Documentation

**** Move material from README to manual

**** Document encodings

*** Notes

**** Error display
How can we allow an error to be displayed on a different token from
where it is detected?  In particular, for a missing closing ">" we
will need to display it at the beginning of the following token.  At
the moment, when we parse the following token the error overlay will
get cleared.

**** How should rng-goto-next-error deal with narrowing?

**** Perhaps should merge errors
Merge errors having same start position even if they have different
ends.

**** How to handle surrogates?
One possibility is to be compatible with utf8.e: represent as sequence
of 4 chars.  But utf-16 is incompatible with this.

**** Should we distinguish well-formedness errors from invalidity errors?
(I think not: we may want to recover from a bad start-tag by implying
an end-tag.)

**** Mouse movement that causes help-echo
Seems to be a bug with Emacs, where a mouse movement that causes
help-echo text to appear counts as pending input but does not cause
idle timer to be restarted.

**** Use XML to represent this file

**** I had a TODO which said simply "split-string"
What did I mean?

**** Investigate performance on large files all on one line

*** Issues for Emacs versions >= 22

**** Take advantage of UTF-8 CJK support

**** Supply a next-error-function

**** Investigate a NEWS item
There's a NEWS item which says "Emacs now tries to set up buffer
coding systems for HTML/XML files automatically."

**** Take advantage of the pointer text property

**** Leverage char-displayable-p

** RefTeX

*** Provide a wdired-like mode for editing RefTeX TOC buffers
As a first step, renaming of sections could be supported.  Ultimately,
it would be great if it also supported moving sections, e.g., by
killing and yanking or providing org-mode like "move section
upwards/downwards" commands.  However, that's not so easy in the
presence of multi-file documents.

* Internal changes

** Cleanup all the GC_ mark bit stuff
There is no longer any distinction since the mark bit is no longer
stored in the Lisp_Object itself.

** Refine the 'predicate' arg to read-file-name
Currently, it mixes up the predicate to apply when doing completion
and the one to use when terminating the selection.

** Merge ibuffer.el and buff-menu.el
More specifically do what's needed to make ibuffer.el the default, or
just an extension of buff-menu.el.

** Replace linum.el with nlinum.el
https://lists.gnu.org/r/emacs-devel/2013-08/msg00379.html

(Since Emacs 26 introduced native line numbers, this item is
probably obsolete.)

** Merge sendmail.el and messages.el
Probably not a complete merge, but at least arrange for messages.el to
be a derived mode of sendmail.el.  Or arrange for messages.el to be
split into a small core and "the rest" so that we use less resources
as long as we stick to the features provided in sendmail.el.

(Probably obsolete, as Emacs 24 switched to message.el as the
default mail composer.)

** Replace gmalloc.c
Replace it with the modified Doug Lea code from the current GNU libc
so that the special mmapping of buffers can be removed -- that
apparently loses under Solaris, at least. [fx has mostly done this.]

(Obsolete, since gmalloc.c is nowadays only used on MS-DOS.)

** Rewrite make-docfile to be clean and maintainable
It might be better to replace with Lisp the part of make-docfile that
produces the etc/DOC file by scanning *.el files, for example by
reusing the code in the byte compiler or in autoload.el that already
scans *.el files.
https://lists.gnu.org/r/emacs-devel/2012-06/msg00037.html
https://lists.gnu.org/r/emacs-devel/2021-05/msg00235.html

** Eliminate the etc/DOC file altogether
As an alternative to the previous item, we could try and eliminate the
DOC file altogether.  See
https://lists.gnu.org/r/emacs-devel/2021-05/msg00237.html

** Add an inferior-comint-minor-mode
The purpose is to have a mode to capture the common set of operations
offered by major modes that offer an associated inferior
comint-derived mode.  I.e. basically make cmuscheme.el/inf-lisp.el
generic.  For use by sml-mode, python-mode, tex-mode, scheme-mode,
lisp-mode, haskell-mode, tuareg-mode, ...

** Add "link" button class
Add a standard button-class named "link", and make all other link-like
button classes inherit from it.  Set the default face of the "link"
button class to the standard "link" face.

* Wishlist items

** Maybe replace etags.c with a Lisp implementation.
https://lists.gnu.org/r/emacs-devel/2012-06/msg00354.html

** Maybe replace lib-src/rcs2log with a Lisp implementation
It wouldn't have to be a complete replacement, just enough
for vc-rcs-update-changelog.

* Other known bugs

** 'make-frame' forgets unhandled parameters, at least for X11 frames

** Problem with comment-start
A two-char comment-starter whose two chars are symbol constituents will
not be noticed if it appears within a word.


This file is part of GNU Emacs.

GNU Emacs is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

GNU Emacs is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

;; Local Variables:
;; coding: utf-8
;; End:
