# ==== NTI3MV NMAKE FILE ====
#
# $HopeName: MMsrc!nti3mv.nmk(trunk.23) $
#
# Copyright (C) 1995 Harlequin Group, all rights reserved
#
PFM = nti3mv
PFMDEFS = /DWIN32 /D_WINDOWS

MPM = <assert> <ring> <liban> <mpm> \
      <arenavm> <vmnt> <space> <pool> <poolmfs> \
      <poolmv> <root> <format> <buffer> <locknt> \
      <ref> <trace> <protnt> <shield> \
      <thnti3> <ssnti3> <mpsi> <mpsint> <ld>
SW  = <assert> <ring> <liban> <mpm> \
      <arenavm> <vmrm> <space> <pool> <poolmfs> \
      <poolmv> <root> <format> <buffer> <locknt> \
      <ref> <trace> <protnt> <shield> \
      <thnti3> <ssnti3> <mpsi> <mpsint> <ld>
AMC = <amc>
LO = <lo>
DW  = <dw> <fmtdy>
TESTLIB = <testlib>

#!INCLUDE mv.nmk

# ==== ALMOST GENERIC PRODUCT BUILD FOR NMAKE ====
#
# $HopeName: MMsrc!nti3mv.nmk(trunk.23) $
#
# Copyright (C) 1995 Harlequin Group, all rights reserved
#
# DESCRIPTION
#
# This makefile fragment is conceptually included in more specific
# makefiles for platforms which use the "mv" builder.  Alas
# due to shortcomings in nmake and the fact that only nti3mv uses mv
# at the moment it is physically part of mti3mv.nmk. [It is not possible
# use a macro in a substituion, hence this file uses nti3mv instead of $(PFM)]
#
# %%PART: Add a new parameter for the files included in the part
# Parameters:
#   PFM      platform code, e.g. "nti3mv"
#   PFMDEFS  /D options to define platforms preprocessor symbols
#            to the compiler.  Eg "/DOS_NT /DARCH_386 /DBUILD_MVC"
#   MPM      list of sources which make up the "mpm" part for this
#            platform.  Each source is stripped of its .c extension
#            and surrounded in angle brackets (<>)
#   AMC      as above for the "amc" part
#   LO      as above for the "lo" part
#   DW      as above for the "amc" part
#   TESTLIB  as above for the "testlib" part
#   NOISY    if defined, causes command to be emitted
#
#
# EDITING
#
# To add new targets. varieties, and parts:
# Search for the string "%%TARGET", "%%VARIETY", or "%%PART" in this makefile
# and follow the instructions.  If you're adding a part, you'll have to change
# the makefile for all the platforms which use this makefile to define the
# source list for that part.
#

# CHECK PARAMETERS
#
# [These only test if the symbol is defined; there is opportunity to be more
#  comprehensive]
#
# %%PART: Add checks for the parameter with the sources for the new part.

!IFNDEF PFM
!ERROR mv.nmk: PFM not defined
!ENDIF
!IFNDEF PFMDEFS
!ERROR mv.nmk: PFMDEFS not defined
!ENDIF
!IFNDEF MPM
!ERROR mv.nmk: MPM not defined
!ENDIF
!IFNDEF LO
!ERROR mv.nmk: LO not defined
!ENDIF
!IFNDEF AMC
!ERROR mv.nmk: AMC not defined
!ENDIF
!IFNDEF DW
!ERROR mv.nmk: DW not defined
!ENDIF
!IFNDEF SW
!ERROR mv.nmk: SW not defined
!ENDIF
!IFNDEF TESTLIB
!ERROR mv.nmk: TESTLIB not defined
!ENDIF


# DECLARATIONS


!IFDEF NOISY
ECHO = rem
!ELSE
.SILENT:
ECHO = echo
!ENDIF


# C FLAGS
# %%VARIETY: Define a macro containing the set of flags for the new variety.

# All compilations
# [Sadly /W4 causes <windows.h> to emit thousands of warnings]
# /MT means compile for multi-threaded environment.
# /ML means compile for single-threaded environment.
# some C flags depend on the target we are building.

!ifdef TARGET
!if "$(TARGET)" == "mmsw.lib"
CFLAGSTARGET = /ML /DTARGET_VM_RM
!else
CFLAGSTARGET = /MT
!endif
!endif

CFLAGSCOMMON = /nologo /W3 /WX $(PFMDEFS) $(CFLAGSTARGET)


# "debug" variety flags
# [Used to use /Zi instead of /Z7.  /Z7 generates debugging output in the
#  object and linked files themselves, whereas /Zi generated debugging
#  output in a .PDB file.]
CFDF = /DTARGET_VAR_DF /Z7

CFDP = /DTARGET_VAR_DP /Z7

CFDS = /DTARGET_VAR_DS /Z7

# "release" variety flags
# Microsoft documentation is not very clear on the point of using bothing
# optimzation and debug information
CFRO = /DTARGET_VAR_RO /Z7 /O2

# "cover" variety flags
CFCV = /DTARGET_VAR_DP /Z7

# LINKER FLAGS
# %%VARIETY: define a macro containing the flags for the new variety
LINKER = link
LINKFLAGSCOMMON = /nologo
LFDF = /DEBUG:full /DEBUGTYPE:cv
LFDP = /DEBUG:full /DEBUGTYPE:cv
LFDS = /DEBUG:full /DEBUGTYPE:cv
LFRO = /RELEASE /DEBUG:full /DEBUGTYPE:cv
LFCV = /PROFILE /DEBUG:full /DEBUGTYPE:cv

# Library manager
# %%VARIETY: define a macro containing the flags for the new variety
LIBMAN = lib                  # can't call this LIB - it screws the environment
LIBFLAGSCOMMON = /nologo
LIBFLAGSDF = 
LIBFLAGSDP = 
LIBFLAGSDS = 
LIBFLAGSRO = 
LIBFLAGSCV =

# Browser database manager [not used at present]
#BSC = bscmake
#BSCFLAGS = /nologo /n


# Source to object file mappings
# and CFLAGS amalgamation
# %%VARIETY %%PART: Add new macros which expand to the files included 
# in the part for each variety
# %%VARIETY: Add a CFLAGS macro which expands to the flags that that variety
# should use when compiling C.  And a LINKFLAGS macro which expands to the
# flags that the variety should use when building executables.  And a LIBFLAGS
# macro which expands to the flags that the variety should use when builing
# libraries

!IF "$(VARIETY)" == "df"
CFLAGS=$(CFLAGSCOMMON) $(CFDF)
LINKFLAGS=$(LINKFLAGSCOMMON) $(LFDF)
LIBFLAGS=$(LIBFLAGSCOMMON) $(LIBFLAGSDF)
MPMOBJ0 = $(MPM:<=nti3mv\df\)
MPMOBJ = $(MPMOBJ0:>=.obj)
SWOBJ0 = $(SW:<=nti3mv\df\)
SWOBJ = $(SWOBJ0:>=.obj)
AMCOBJ0 = $(AMC:<=nti3mv\df\)
AMCOBJ = $(AMCOBJ0:>=.obj)
LOOBJ0 = $(LO:<=nti3mv\df\)
LOOBJ = $(LOOBJ0:>=.obj)
DWOBJ0 = $(DW:<=nti3mv\df\)
DWOBJ = $(DWOBJ0:>=.obj)
TESTLIBOBJ0 = $(TESTLIB:<=nti3mv\df\)
TESTLIBOBJ = $(TESTLIBOBJ0:>=.obj)

!ELSEIF "$(VARIETY)" == "dp"
CFLAGS=$(CFLAGSCOMMON) $(CFDP)
LINKFLAGS=$(LINKFLAGSCOMMON) $(LFDP)
LIBFLAGS=$(LIBFLAGSCOMMON) $(LIBFLAGSDP)
MPMOBJ0 = $(MPM:<=nti3mv\dp\)
MPMOBJ = $(MPMOBJ0:>=.obj)
SWOBJ0 = $(SW:<=nti3mv\dp\)
SWOBJ = $(SWOBJ0:>=.obj)
AMCOBJ0 = $(AMC:<=nti3mv\dp\)
AMCOBJ = $(AMCOBJ0:>=.obj)
LOOBJ0 = $(LO:<=nti3mv\dp\)
LOOBJ = $(LOOBJ0:>=.obj)
DWOBJ0 = $(DW:<=nti3mv\dp\)
DWOBJ = $(DWOBJ0:>=.obj)
TESTLIBOBJ0 = $(TESTLIB:<=nti3mv\dp\)
TESTLIBOBJ = $(TESTLIBOBJ0:>=.obj)

!ELSEIF "$(VARIETY)" == "ds"
CFLAGS=$(CFLAGSCOMMON) $(CFDS)
LINKFLAGS=$(LINKFLAGSCOMMON) $(LFDS)
LIBFLAGS=$(LIBFLAGSCOMMON) $(LIBFLAGSDS)
MPMOBJ0 = $(MPM:<=nti3mv\ds\)
MPMOBJ = $(MPMOBJ0:>=.obj)
SWOBJ0 = $(SW:<=nti3mv\ds\)
SWOBJ = $(SWOBJ0:>=.obj)
AMCOBJ0 = $(AMC:<=nti3mv\ds\)
AMCOBJ = $(AMCOBJ0:>=.obj)
LOOBJ0 = $(LO:<=nti3mv\ds\)
LOOBJ = $(LOOBJ0:>=.obj)
DWOBJ0 = $(DW:<=nti3mv\ds\)
DWOBJ = $(DWOBJ0:>=.obj)
TESTLIBOBJ0 = $(TESTLIB:<=nti3mv\ds\)
TESTLIBOBJ = $(TESTLIBOBJ0:>=.obj)

!ELSEIF "$(VARIETY)" == "ro"
CFLAGS=$(CFLAGSCOMMON) $(CFRO)
LINKFLAGS=$(LINKFLAGSCOMMON) $(LFRO)
LIBFLAGS=$(LIBFLAGSCOMMON) $(LIBFLAGSRO)
MPMOBJ0 = $(MPM:<=nti3mv\ro\)
MPMOBJ = $(MPMOBJ0:>=.obj)
SWOBJ0 = $(SW:<=nti3mv\ro\)
SWOBJ = $(SWOBJ0:>=.obj)
AMCOBJ0 = $(AMC:<=nti3mv\ro\)
AMCOBJ = $(AMCOBJ0:>=.obj)
LOOBJ0 = $(LO:<=nti3mv\ro\)
LOOBJ = $(LOOBJ0:>=.obj)
DWOBJ0 = $(DW:<=nti3mv\ro\)
DWOBJ = $(DWOBJ0:>=.obj)
TESTLIBOBJ0 = $(TESTLIB:<=nti3mv\ro\)
TESTLIBOBJ = $(TESTLIBOBJ0:>=.obj)

!ELSEIF "$(VARIETY)" == "cv"
CFLAGS=$(CFLAGSCOMMON) $(CFCV)
LINKFLAGS=$(LINKFLAGSCOMMON) $(LFCV)
LIBFLAGS=$(LIBFLAGSCOMMON) $(LIBFLAGSCV)
MPMOBJ0 = $(MPM:<=nti3mv\cv\)
MPMOBJ = $(MPMOBJ0:>=.obj)
AMCOBJ0 = $(AMC:<=nti3mv\cv\)
AMCOBJ = $(AMCOBJ0:>=.obj)
LOOBJ0 = $(LO:<=nti3mv\cv\)
LOOBJ = $(LOOBJ0:>=.obj)
DWOBJ0 = $(DW:<=nti3mv\cv\)
DWOBJ = $(DWOBJ0:>=.obj)
TESTLIBOBJ0 = $(TESTLIB:<=nti3mv\cv\)
TESTLIBOBJ = $(TESTLIBOBJ0:>=.obj)

!ENDIF


# == Pseudo-targets

# "all" builds all the varieties of all targets
# %%TARGET: Add the target  to the all dependencies

all: mpmss.exe amcss.exe dwstress.exe lockutnt.exe lockcov.exe \
     mpsicv.exe poolncv.exe locv.exe qs.exe mpm.lib weakcv.exe

# Convenience targets
# %%TARGET: Add a pseudo-target for the new part

dwstress.exe amcss.exe lockutnt.exe lockcov.exe \
     mpmss.exe protcv.exe mpsicv.exe poolncv.exe locv.exe qs.exe \
     mpm.lib mmdw.lib mmsw.lib weakcv.exe:
	$(MAKE) /nologo /f $(PFM).nmk TARGET=$@ target

mpsicv.cov:
	$(MAKE) /nologo /f $(PFM).nmk TARGET=$@ VARIETY=cv variety

# "clean" removes the directory containing the build results for the platform

clean:
	$(ECHO) $(PFM): $@
	-echo y | rmdir/s $(PFM)
	-deltree /Y $(PFM)

# target target
# %%VARIETY: Add a recusive make call for the new variety

!IFDEF TARGET
!IFNDEF VARIETY
target:
	$(MAKE) /nologo /f $(PFM).nmk VARIETY=df variety
	$(MAKE) /nologo /f $(PFM).nmk VARIETY=dp variety
	$(MAKE) /nologo /f $(PFM).nmk VARIETY=ds variety
	$(MAKE) /nologo /f $(PFM).nmk VARIETY=ro variety
!ENDIF
!ENDIF

# variety

!IFDEF VARIETY
!IFDEF TARGET
variety: $(PFM)\$(VARIETY)\$(TARGET)
!ENDIF
!ENDIF


# GENUINE TARGETS
#
# Each line defines an executable or library target to be built and the object
# files it is build from.  For an executable these lines add dependencies to
# the generic rules below, and should not include commands to execute.
# For a library this is not possible and the target should include commands
# to build it.
# %%TARGET: Add your new target here

!IFDEF VARIETY

$(PFM)\$(VARIETY)\weakcv.exe: $(PFM)\$(VARIETY)\weakcv.obj \
	$(MPMOBJ) $(AMCOBJ) $(DWOBJ) $(TESTLIBOBJ)

$(PFM)\$(VARIETY)\mpmss.exe: $(PFM)\$(VARIETY)\mpmss.obj \
	$(MPMOBJ)

$(PFM)\$(VARIETY)\lockcov.exe: $(PFM)\$(VARIETY)\lockcov.obj \
	$(MPMOBJ)

$(PFM)\$(VARIETY)\lockutnt.exe: $(PFM)\$(VARIETY)\lockutnt.obj \
	$(MPMOBJ)

$(PFM)\$(VARIETY)\qs.exe:  $(PFM)\$(VARIETY)\qs.obj \
	$(AMCOBJ) $(MPMOBJ) $(TESTLIBOBJ)

$(PFM)\$(VARIETY)\amcss.exe:  $(PFM)\$(VARIETY)\amcss.obj \
	$(MPMOBJ) $(AMCOBJ) $(DWOBJ) $(TESTLIBOBJ)

$(PFM)\$(VARIETY)\mpsicv.exe:  $(PFM)\$(VARIETY)\mpsicv.obj \
	$(MPMOBJ) $(AMCOBJ) $(DWOBJ) $(TESTLIBOBJ)

$(PFM)\$(VARIETY)\dwstress.exe:  $(PFM)\$(VARIETY)\dwstress.obj \
	$(DWOBJ) $(MPMOBJ) $(AMCOBJ)

$(PFM)\$(VARIETY)\protcv.exe:  $(PFM)\$(VARIETY)\protcv.obj \
	$(MPMOBJ)

$(PFM)\$(VARIETY)\poolncv.exe:  $(PFM)\$(VARIETY)\poolncv.obj \
	$(MPMOBJ) $(TESTLIBOBJ) $(PFM)\$(VARIETY)\pooln.obj

$(PFM)\$(VARIETY)\locv.exe:  $(PFM)\$(VARIETY)\locv.obj \
	$(MPMOBJ) $(TESTLIBOBJ) $(LOOBJ)

$(PFM)\$(VARIETY)\mpm.lib: $(MPMOBJ)
	$(ECHO) $@
	$(LIBMAN) $(LIBFLAGS) /OUT:$@ $**

$(PFM)\$(VARIETY)\amc.lib: $(MPMOBJ) $(AMCOBJ)
	$(ECHO) $@
	$(LIBMAN) $(LIBFLAGS) /OUT:$@ $**

$(PFM)\$(VARIETY)\mmsw.lib: $(SWOBJ)
	$(ECHO) $@
	$(LIBMAN) $(LIBFLAGS) /OUT:$@ $**

$(PFM)\$(VARIETY)\mmdw.lib: $(MPMOBJ) $(AMCOBJ) $(DWOBJ)
	$(ECHO) $@
	$(LIBMAN) $(LIBFLAGS) /OUT:$@ $**

!ENDIF

# GENERIC RULES

# Object files
# [builds objects for static linking with libc]

{}.c{$(PFM)\$(VARIETY)}.obj:
	$(ECHO) $@
	@if not exist $(PFM) mkdir $(PFM)
	@if not exist $(PFM)\$(VARIETY) mkdir $(PFM)\$(VARIETY)
	cl /c $(CFLAGS) /FR$*.sbr /Fd$(PFM)\$(VARIETY)\$(<:.obj=.pdb) /Fo$@ $<

{}.asm{$(PFM)\$(VARIETY)}.obj:
	$(ECHO) $@
	@if not exist $(PFM) mkdir $(PFM)
	@if not exist $(PFM)\$(VARIETY) mkdir $(PFM)\$(VARIETY)
	ml /nologo /c /coff /FR$*.sbr  /Fo$@ $<

# Coverage files
{$(PFM)\$(VARIETY)}.exe{$(PFM)\$(VARIETY)}.cov:
	$(ECHO) $@
 	cd $(PFM)\$(VARIETY)
	prep /nologo /lv  $(<F)
	profile /nologo $(<B)
	prep /nologo /m $(<B)
	plist /nologo /D ..\.. $(<B) > $(@F)


# Dependencies
# [we can't build these at the moment]

# Executables
# libcmt.lib is the library needed for multi-threaded programs.

{$(PFM)\$(VARIETY)}.obj{$(PFM)\$(VARIETY)}.exe:
	$(ECHO) $@
	$(LINKER) $(LINKFLAGS) /OUT:$@ $(**) libcmt.lib
#!INCLUDE depend.mak
