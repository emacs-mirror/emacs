#!/usr/bin/env python
#
# $Id$
# Copyright (c) 2018 Ravenbrook Limited. See end of file for license.
#
# This program reads a telemetry stream from a program using the MPS,
# and constructs a model of the MPS data structures in the progam.


import argparse
from collections import namedtuple
import os
from struct import Struct
import sys

import matplotlib.pyplot
import numpy as np

import mpsevent


# Mapping from event code to a namedtuple for that event.
EVENT_NAMEDTUPLE = {
    code: namedtuple(desc.name, ['header'] + [p.name for p in desc.params])
    for code, desc in mpsevent.EVENT.items()
}

# Mapping from event code to event name.
EVENT_NAME = {code:desc.name for code, desc in mpsevent.EVENT.items()}


def decode_events(read):
    """Decode the events in an I/O stream and generate them as tuples.

    The argument must be a function implementing the io.RawIOBase.read
    specification (that is, it takes a size and returns up to size
    bytes from the I/O stream).

    """
    # Cache frequently-used values in local variables.
    header_desc = mpsevent.HeaderDesc
    header_size = mpsevent.HEADER_SIZE
    event_dict = mpsevent.EVENT
    event_namedtuple = EVENT_NAMEDTUPLE

    # Special handling for Intern.
    Intern_desc = mpsevent.Event.Intern
    Intern_code = Intern_desc.code
    Intern_struct = Struct(Intern_desc.format)
    Intern_size = Intern_struct.size
    Intern_unpack = Intern_struct.unpack
    Intern_namedtuple = event_namedtuple[Intern_code]

    # Build unpacker functions for each type of event.
    header_struct = Struct(mpsevent.HEADER_FORMAT)
    assert header_struct.size == header_size
    header_unpack = header_struct.unpack
    event_unpack = {}
    for code, desc in event_dict.items():
        assert code == desc.code
        s = Struct(desc.format)
        assert code == Intern_code or s.size == desc.maxsize
        event_unpack[code] = s.unpack

    while True:
        header_data = read(header_size)
        if not header_data:
            break
        header = header_desc(*header_unpack(header_data))
        code = header.code
        event_desc = event_dict[code]
        size = header.size - header_size
        if code == Intern_code:
            assert size <= event_desc.maxsize
            event = Intern_namedtuple(header,
                                      *Intern_unpack(read(Intern_size)),
                                      read(size - Intern_size).rstrip(b'\0'))
        else:
            assert size == event_desc.maxsize
            event = event_namedtuple[code](header,
                                           *event_unpack[code](read(size)))
        yield event


class TimeSeries:
    "Series of data points in time order."
    def __init__(self):
        self.t = []
        self.y = []

    def append(self, t, y):
        "Append data y at time t."
        assert not self.t or t >= self.t[-1]
        self.t.append(t)
        self.y.append(y)


class Accumulator(TimeSeries):
    "Time series that is always non-negative and updates by accumulation."
    def __init__(self, initial=0):
        super().__init__()
        self.value = initial

    def add(self, t, delta):
        "Add delta to the accumulator at time t."
        self.append(t, self.value)
        self.value += delta
        self.append(t, self.value)

    def sub(self, t, delta):
        "Subtract delta from the accumulator at time t."
        assert self.value >= delta
        self.append(t, self.value)
        self.value -= delta
        self.append(t, self.value)


class EventHandler:
    """Object that handles a telemetry event by dispatching to the method
    with the same name as the event.

    """
    def ignore(self, event):
        "Handle a telemetry event by doing nothing."

    def handle(self, event):
        "Handle a telemetry event by dispatching."
        getattr(self, EVENT_NAME[event.header.code], self.ignore)(event)


class Pool(EventHandler):
    "Model of an MPS pool."
    def __init__(self, arena, pointer):
        self.arena = arena
        self.model = arena.model
        self.pointer = pointer
        self.pool_class = None
        self.serial = None
        self.alloc = Accumulator()
        self.model.add_time_series(self, "alloc", self.alloc)

    @property
    def name(self):
        label = self.model.label(self.pointer)
        if label:
            return label
        class_name = self.model.label(self.pool_class) or 'Pool'
        if self.serial is not None:
            return f"{class_name}[{self.serial}]"
        else:
            return f"{class_name}[{self.pointer:x}]"

    def ArenaAlloc(self, event):
        self.alloc.add(event.header.clock, event.size)

    def ArenaFree(self, event):
        self.alloc.sub(event.header.clock, event.size)

    def PoolInit(self, event):
        self.pool_class = event.poolClass
        self.serial = event.serial


class Arena(EventHandler):
    "Model of an MPS arena."
    def __init__(self, model, pointer):
        self.model = model
        self.pointer = pointer
        self.arena_class = None
        self.serial = None
        self.pool = {}          # pointer -> Pool

    @property
    def name(self):
        if len(self.model.arena) <= 1:
            # No need to distinguish arenas if there's just one.
            return ""
        label = self.model.label(self.pointer)
        if label:
            return label
        class_name = self.model.label(self.arena_class) or 'Arena'
        if self.serial is not None:
            return f"{class_name}[{self.serial}]"
        else:
            return f"{class_name}[{self.pointer:x}]"

    def delegate_to_pool(self, event):
        "Handle a telemetry event by delegating to the pool model."
        pointer = event.pool
        try:
            pool = self.pool[pointer]
        except KeyError:
            self.pool[pointer] = pool = Pool(self, pointer)
        pool.handle(event)

    ArenaAlloc = ArenaFree = PoolInit = delegate_to_pool

    def ArenaCreateVM(self, event):
        self.arena_class = event.arenaClass
        self.serial = event.serial

    ArenaCreateCL = ArenaCreateVM


class Line:
    "A line in a Matplotlib plot wrapping a TimeSeries."
    def __init__(self, owner, desc, series):
        self.owner = owner
        self.desc = desc
        self.series = series
        self.line = None

    def update(self, axes, seconds):
        """Update the line in the given set of axes. seconds is a function
        converting eventclocks to seconds.

        """
        if len(self.series.t) < 2:
            return
        x = seconds(self.series.t)
        y = self.series.y
        label = f"{self.owner.name}.{self.desc}"
        if self.line is None:
            self.line, = axes.plot(x, y, label=label)
        else:
            self.line.set_data(x, y)
            self.line.set_label(label)


class Model(EventHandler):
    "Model of an application using the MPS."
    def __init__(self):
        self._intern = {}       # stringId -> string
        self._label = {}        # address or pointer -> stringId
        self.arena = {}         # pointer -> Arena
        self.lines = []         # list(Line)
        self.clocks_per_second = None
        self.sync = TimeSeries()

    def add_time_series(self, owner, desc, series):
        "Add a time series to the model."
        self.lines.append(Line(owner, desc, series))

    def label(self, pointer):
        "Return string labelling address or pointer, or None if unlabelled."
        return self._intern.get(self._label.get(pointer))

    @property
    def eventclocks_to_seconds(self):
        "Return function converting eventclocks to seconds."
        cps = self.clocks_per_second
        if len(self.sync.t) < 2 or cps is None:
            # Don't have enough data to compute seconds.
            return lambda e: e
        else:
            # The cycle counter frequency can vary due to thermal
            # throttling, turbo boost etc., so use piecewise linear
            # interpolation to convert to clocks and thence to seconds.
            return lambda e: np.interp(e, self.sync.t, self.sync.y) / cps

    def update(self, axes):
        "Update time series on the given axes."
        seconds = self.eventclocks_to_seconds
        for line in self.lines:
            line.update(axes, seconds)
        axes.legend(loc=2)

    def delegate_to_arena(self, event):
        "Handle a telemetry event by delegating to the arena model."
        addr = event.arena
        try:
            arena = self.arena[addr]
        except KeyError:
            self.arena[addr] = arena = Arena(self, addr)
        arena.handle(event)

    ArenaCreateVM = ArenaCreateCL = ArenaAlloc = ArenaFree = PoolInit = delegate_to_arena

    def EventInit(self, event):
        stream_version = event.major, event.median
        monitor_version = mpsevent.__version__[:2]
        if stream_version != monitor_version:
            raise RuntimeError("Monitor version {} is incompatible with "
                               "telemetry stream version {}.".format(
                                   '.'.join(map(str, monitor_version)),
                                   '.'.join(map(str, stream_version))))
        self.clocks_per_second = event.clocksPerSec

    def EventClockSync(self, event):
        self.sync.append(event.header.clock, event.clock)

    def Intern(self, event):
        self._intern[event.stringId] = event.string.decode('ascii', 'replace')

    def Label(self, event):
        self._label[event.address] = event.stringId

    def LabelPointer(self, event):
        self._label[event.pointer] = event.stringId


def main():
    parser = argparse.ArgumentParser(description="Memory Pool System Monitor.")
    parser.add_argument(
        'telemetry', metavar='FILENAME', nargs='?',
        type=argparse.FileType('rb'),
        default=os.environ.get('MPS_TELEMETRY_FILENAME', 'mpsio.log'),
        help="telemetry output from the MPS instance")
    args = parser.parse_args()

    model = Model()
    events = decode_events(args.telemetry.read)
    for event in events:
        model.handle(event)

    plt = matplotlib.pyplot
    figure, axes = plt.subplots()
    axes.set_xlabel("time (seconds)")
    axes.set_ylabel("bytes")
    model.update(axes)
    plt.show()


if __name__ == '__main__':
    main()


# C. COPYRIGHT AND LICENCE
#
# Copyright (c) 2018 Ravenbrook Ltd.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the
#    distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#
# $Id$
