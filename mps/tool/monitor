#!/usr/bin/env python
#
# $Id$
# Copyright (c) 2018 Ravenbrook Limited. See end of file for license.
#
# Read a telemetry stream from a program using the MPS, construct a
# model of the MPS data structures in the progam, and display selected
# time series from the model in a graphical user interface.
# 
# Requirements: Python 3.6, Matplotlib, PyQt5.


import argparse
from collections import defaultdict, deque, namedtuple
from itertools import count, cycle
import os
import queue
from struct import Struct
import sys
import threading
import time
import math

from matplotlib.backends.qt_compat import QtCore, QtGui, QtWidgets
from matplotlib.backends.backend_qt5agg import (
    FigureCanvas, NavigationToolbar2QT as NavigationToolbar)
from matplotlib.figure import Figure

import mpsevent

class YAxis:
    "The Y-axis of a plot."
    def __init__(self, label, fmt):
        self._label = label
        self.fmt = fmt

    def label(self): return self._label

def bytesFormat(y):
    "Format a number of bytes as a string."
    i = 0
    while y > 10000:
        y /= 1000
        i += 1
    if i == 0:
        return '{:,.0f} bytes'.format(y)
    else:
        return '{:.2f} {}B'.format(y,' KMGTPE'[i])

# The three y axes which we support
bytesAxis = YAxis('bytes', bytesFormat)
fractionAxis = YAxis('fraction', lambda v: f'{v:.5f}')
traceAxis = YAxis('gens', lambda v: f'{v} gens')

# Mapping from event code to a namedtuple for that event.
EVENT_NAMEDTUPLE = {
    code: namedtuple(desc.name, ['header'] + [p.name for p in desc.params])
    for code, desc in mpsevent.EVENT.items()
}

# Mapping from event code to event name.
EVENT_NAME = {code:desc.name for code, desc in mpsevent.EVENT.items()}

# Unpack function for event header.
HEADER_UNPACK = Struct(mpsevent.HEADER_FORMAT).unpack

# Unpack function for each event code.
EVENT_UNPACK = {c:Struct(d.format).unpack for c, d in mpsevent.EVENT.items()}

# Icon for the toolbar pause button.
PAUSE_ICON = os.path.abspath(os.path.join(os.path.dirname(__file__), 'pause'))


def telemetry_decoder(read):
    """Decode the events in an I/O stream and generate batches of events
    as lists of pairs (time, event) in time order, where time is CPU
    time in seconds and event is a tuple.

    Unknown event codes are read but ignored.

    The 'read' argument must be a function implementing the
    io.RawIOBase.read specification (that is, it takes a size and
    returns up to size bytes from the I/O stream).

    """
    # Cache frequently-used values in local variables.
    header_desc = mpsevent.HeaderDesc
    header_size = mpsevent.HEADER_SIZE
    event_dict = mpsevent.EVENT
    event_namedtuple = EVENT_NAMEDTUPLE
    event_unpack = EVENT_UNPACK
    header_unpack = HEADER_UNPACK
    EventClockSync_code = mpsevent.Event.EventClockSync.code
    EventInit_code = mpsevent.Event.EventInit.code

    # Special handling for Intern events.
    Intern_desc = mpsevent.Event.Intern
    Intern_code = Intern_desc.code
    Intern_struct = Struct(Intern_desc.format)
    Intern_size = Intern_struct.size
    Intern_unpack = Intern_struct.unpack
    Intern_namedtuple = event_namedtuple[Intern_code]

    batch = []                  # Current batch of (unordered) events.
    clocks_per_sec = None       # CLOCKS_PER_SEC value from EventInit event.

    # last two EventClockSync events with distinct clock values
    eventclocks = deque(maxlen=2) # header clock values
    clocks = deque(maxlen=2)    # clock values

    def key(event):
        # Key function for sorting events into time order.
        return event.header.clock

    def decoder(n=None):
        # Generate up to n batches of events decoded from the I/O stream.
        nonlocal clocks_per_sec
        for _ in (count() if n is None else range(n)):
            header_data = read(header_size)
            if not header_data:
                break
            header = header_desc(*header_unpack(header_data))
            code = header.code
            size = header.size - header_size
            if code == Intern_code:
                event_desc = event_dict[code]
                assert size <= event_desc.maxsize
                event = Intern_namedtuple(
                    header,
                    *Intern_unpack(read(Intern_size)),
                    read(size - Intern_size).rstrip(b'\0'))
            elif code in event_dict:
                event_desc = event_dict[code]
                assert size == event_desc.maxsize
                event = event_namedtuple[code](
                    header, *event_unpack[code](read(size)))
            else:
                # Unknown code might indicate a new event added since
                # mpsevent.py was updated, so just read and ignore.
                read(size)
                continue

            batch.append(event)
            if event.header.code == EventClockSync_code:
                # Events are output in batches terminated by an
                # EventClockSync event. So when we see an
                # EventClockSync event with a new clock value, we know
                # that we've received all events up to that one and
                # can sort and emit the batch.
                #
                # The Time Stamp Counter frequency can vary due to thermal
                # throttling, turbo boost etc., so linearly interpolate within
                # each batch to convert to clocks and thence to seconds. (This
                # requires at least two EventClockSync events.)
                #
                # In theory the Time Stamp Counter can wrap around, but it is
                # a 64-bit register even on IA-32, and at 2.5 GHz it will take
                # hundreds of years to do so, so we ignore this possibility.
                # 
                # TODO: on 32-bit platforms at 1 MHz, clock values will wrap
                # around in about 72 minutes and so this needs to be handled.
                #
                # TODO: reduce problems caused by discretized clock
                # values. See job004100.
                if clocks and event.clock == clocks[-1]:
                    # The clock value hasn't changed since the last
                    # EventClockSync (because clocks_per_sec isn't
                    # high enough) so we disregard this event,
                    # otherwise linearising gives us loads of events
                    # with identical timestamps.
                    continue
                clocks.append(event.clock)
                eventclocks.append(event.header.clock)
                if len(clocks) == 2:
                    batch.sort(key=key)
                    dt = (clocks[1] - clocks[0]) / clocks_per_sec
                    dTSC = eventclocks[1] - eventclocks[0]
                    m = dt / dTSC # gradient
                    t0 = clocks[0] / clocks_per_sec
                    c = t0 - m * eventclocks[0] # y-intercept
                    yield [(m * e.header.clock + c, e) for e in batch]
                    batch.clear()
            elif event.header.code == EventInit_code:
                stream_version = event.major, event.median, event.minor
                if stream_version[:2] != mpsevent.__version__[:2]:
                    raise RuntimeError(
                        "Monitor version {} is incompatible with "
                        "telemetry stream version {}.".format(
                            '.'.join(map(str, mpsevent.__version__)),
                            '.'.join(map(str, stream_version))))
                clocks_per_sec = event.clocksPerSec

    return decoder


def bits_of_word(w, n):
    "Generate the bits in the word w, which has n bits."
    for _ in range(n):
        w, bit = divmod(w, 2)
        yield bit


class TimeSeries:
    "Series of data points in time order."
    def __init__(self, note=None, draw=None):
        self.t = []
        self.y = []
        self.note = note
        self.draw = draw

    def append(self, t, y):
        "Append data y at time t."
        assert not self.t or t >= self.t[-1]
        self.t.append(t)
        self.y.append(y)


class Accumulator(TimeSeries):
    "Time series that is always non-negative and updates by accumulation."
    def __init__(self, initial=0):
        super().__init__()
        self.value = initial

    def add(self, t, delta):
        "Add delta to the accumulator at time t."
        assert self.value >= -delta
        self.append(t, self.value)
        self.value += delta
        self.append(t, self.value)

    def sub(self, t, delta):
        "Subtract delta from the accumulator at time t."
        assert self.value >= delta
        self.append(t, self.value)
        self.value -= delta
        self.append(t, self.value)


class OnOffSeries(TimeSeries):
    """Series of on/off events; can draw as an exponentially weighted moving
average on/off ratio or (potentially) as shading bars."""
    def __init__(self, t, k=1):
        super().__init__()
        self._ons = []
        self._last = t
        self._k = k
        self._ratio = 0.0

    def off(self, t):
        dt = t - self._last
        f = math.exp(-self._k * dt)
        self._ratio = 1 - f * (1 - self._ratio)
        self._ons.append((self._last, t))
        self._last = t
        self.append(t, self._ratio)

    def on(self, t):
        dt = t - self._last
        f = math.exp(-self._k * dt)
        self._ratio = f * self._ratio
        self._last = t
        self.append(t, self._ratio)


class EventHandler:
    """Object that handles a telemetry event by dispatching to the method
    with the same name as the event.

    """
    def ignore(self, t, event):
        "Handle a telemetry event at time t by doing nothing."

    def handle(self, t, event):
        "Handle a telemetry event at time t by dispatching."
        getattr(self, EVENT_NAME[event.header.code], self.ignore)(t, event)


class Pool(EventHandler):
    "Model of an MPS pool."
    def __init__(self, arena, pointer, t):
        "Create Pool owned by arena, at pointer, at time t."
        self._arena = arena       # Owning arena.
        self._model = arena.model # Owning model.
        self._pointer = pointer   # Pool's pointer.
        self._pool_class = None   # Pool's class pointer.
        self._serial = None       # Pool's serial number within arena.
        self._alloc = Accumulator()
        self._model.add_time_series(
            self, self._alloc, bytesAxis, "alloc",
            "memory allocated by the pool from the arena",
            draw=False)

    @property
    def name(self):
        name = self._model.label(self._pointer)
        if not name:
            class_name = self._model.label(self._pool_class) or 'Pool'
            if self._serial is not None:
                name = f"{class_name}[{self._serial}]"
            else:
                name = f"{class_name}[{self._pointer:x}]"
        return f"{self._arena.name}.{name}"

    def ArenaAlloc(self, t, event):
        self._alloc.add(t, event.size)

    def ArenaFree(self, t, event):
        self._alloc.sub(t, event.size)

    def PoolInit(self, t, event):
        self._pool_class = event.poolClass
        self._serial = event.serial


class Gen(EventHandler):
    "Model of an MPS generation."
    def __init__(self, arena, pointer):
        self._arena = arena       # Owning arena.
        self._model = arena.model # Owning model.
        self._pointer = pointer   # Gen's pointer.
        self._serial = None       # Gen's serial number.
        self.zone_set = 0         # Gen's current zone set.

    def update_ref_size(self, t, seg_summary, seg_size):
        """Update the size of segments referencing this generation.
        seg_summary must be a mapping from segment to its summary, and
        seg_size a mapping from segment to its size in bytes.

        """
        ref_size = 0
        for seg, summary in seg_summary.items():
            if self.zone_set & summary:
                ref_size += seg_size[seg]
        self._ref_size.append(t, ref_size)

    @property
    def name(self):
        name = self._model.label(self._pointer)
        if not name:
            if self._serial is not None:
                name = f"gen-{self._serial}"
            else:
                name = f"gen-{self._pointer:x}"
        return f"{self._arena.name}.{name}"

    def GenZoneSet(self, t, event):
        self.zone_set = event.zoneSet

    def GenInit(self, t, event):
        self._serial = serial = event.serial
        self._mortality_trace = mortality_trace = TimeSeries()
        per_trace_line = self._model.add_time_series(
            self, mortality_trace, fractionAxis, f"mortality.trace",
            f"mortality of data in generation, per trace",
            draw=False, marker='+', linestyle='None')
        self._mortality_average = mortality_average = TimeSeries()
        self._model.add_time_series(
            self, mortality_average, fractionAxis, f"mortality.avg",
            f"mortality of data in generation, moving average",
            draw=False, color_as=per_trace_line)
        mortality_average.append(t, event.mortality);
        self._ref_size = ref_size = TimeSeries()
        self._model.add_time_series(
            self, ref_size, bytesAxis, f"ref",
            f"size of segments referencing generation")

    def TraceEndGen(self, t, event):
        self._mortality_trace.append(t, event.mortalityTrace)
        self._mortality_average.append(t, event.mortalityAverage)

class Trace(EventHandler):
    def __init__(self, arena, t, event):
        self._arena = arena
        self.create = t
        self.why = event.why
        self.gens = 'none'
        self.times = [(t, event.header.clock, 'create')]
        self.sizes = []
        self.counts = []

    def add_time(self, name, t, event):
        self.times.append((t, event.header.clock, name))

    def add_size(self, name, s):
        self.sizes.append((name, s))

    def add_count(self, name, c):
        self.counts.append((name, c))

    def TraceDestroy(self, t, event):
        self.add_time("destroy", t, event)

    def TraceStart(self, t, event):
        self.add_time("start", t, event)
        self.add_size("condemned", event.condemned)
        self.add_size("notCondemned", event.notCondemned)
        self.add_size("foundation", event.foundation)
        self.whiteRefSet = event.white

    def TraceFlipBegin(self, t, event):
        self.add_time("flip begin", t, event)

    def TraceFlipEnd(self, t, event):
        self.add_time("flip end", t, event)

    def TraceBandAdvance(self, t, event):
        self.add_time(f"band advance {event.rank}", t, event)

    def TraceReclaim(self, t, event):
        self.add_time("reclaim", t, event)

    def TraceStatScan(self, t, event):
        self.add_count('roots scanned', event.rootScanCount)
        self.add_size('roots scanned', event.rootScanSize)
        self.add_size('copied during root scan', event.rootCopiedSize)
        self.add_count('segments scanned', event.segScanCount)
        self.add_size('segments scanned', event.segScanSize)
        self.add_size('copied during segment scan', event.segCopiedSize)
        self.add_count('single ref scan', event.singleScanCount)
        self.add_size('single refs scanned', event.singleScanSize)
        self.add_size('copied during scan of single refs', event.singleCopiedSize)
        self.add_count('read barrier hits', event.readBarrierHitCount)
        self.add_count('max grey segments', event.greySegMax)
        self.add_count('segments scanned pointlessly', event.pointlessScanCount)

    def TraceStatFix(self, t, event):
        self.add_count('fixed refs', event.fixRefCount)
        self.add_count('fixed refs referring to segs', event.segRefCount)
        self.add_count('fixed white refs', event.whiteSegRefCount)
        self.add_count('nails', event.nailCount)
        self.add_count('snaps', event.snapCount)
        self.add_count('forwarded', event.forwardedCount)
        self.add_size('forwarded', event.forwardedSize)
        self.add_count('preseved in place', event.preservedInPlaceCount)
        self.add_size('preserved in place', event.preservedInPlaceSize)

    def TraceStatReclaim(self, t, event):
        self.add_count('segs reclaimed', event.reclaimCount)
        self.add_size('reclaimed', event.reclaimSize)

    def ChainCondemnAuto(self, t, event):
        self.gens = event.topCondemnedGenIndex + 1

    def TraceCondemnAll(self, t, event):
        self.gens = "all"

    def note(self):
        log = f"Trace at {self.times[0][0]:f}:\nTimes: \n"
        base_t, base_cycles, _ = self.times[0]
        for (t,c,n) in self.times[1:]:
            log += "  {}: {:f} ms ({:,d} cycles)\n".format(n, (t-base_t)*1000, c-base_cycles)
        log += "Sizes:\n"
        for (n, s) in self.sizes:
            log += f"  {n}: {bytesFormat(s)}\n"
        for (n, c) in self.counts:
            log += f"  {n}: {c:,d}\n"
        log += f"white ref set: {self.whiteRefSet:064b}"
        
        return f"trace\n{self.create:f} s\n{self.gens}", log
    
    def draw(self, axes_dict):
        # uniquify axes based on bounding boxes
        axes_to_draw = {ax.bbox.bounds: ax for ax in axes_dict.values()}.values()
        drawn = ([ax.axvline(t)
                  for ax in axes_to_draw
                  for (t,_,_) in self.times] +
                 [ax.axvspan(self.times[0][0], self.times[-1][0], alpha=0.5,facecolor='r')
                  for ax in axes_to_draw])
        return drawn
        

class Arena(EventHandler):
    "Model of an MPS arena."
    # Number of pools that are internal to the arena; see the list in
    # global.c:GlobalsPrepareToDestroy.
    _internal_pools = 4

    def __init__(self, model, pointer, t):
        "Create Arena owned by model, at pointer, at time t."
        self.model = model       # Owning model.
        self._pointer = pointer  # Arena's pointer.
        self._arena_class = None # Arena's class pointer.
        self._serial = None      # Arena's serial number.
        self._pools = []         # List of Pools ever belonging to arena.
        self._pool = {}          # pointer -> Pool (for live pools)
        self._gens = []          # List of Gens ever belonging to arena.
        self._gen = {}           # pointer -> Gen (for live gens)
        self._alloc = Accumulator()
        self.model.add_time_series(
            self, self._alloc, bytesAxis, "alloc",
            "total allocation by client pools")
        self._poll = OnOffSeries(t)
        self.model.add_time_series(
            self, self._poll, fractionAxis, "poll",
            "polling time moving average")
        self._seg_size = {}      # segment pointer -> size
        self._seg_summary = {}   # segment pointer -> summary
        self._zone_ref_size = {} # zone -> refsize Accumulator
        self._univ_ref_size = Accumulator()
        self.model.add_time_series(
            self, self._univ_ref_size, bytesAxis, "zone-univ.ref",
            "size of segments referencing the universe")
        self._live_traces = {} # trace pointer -> dictionary
        self._all_traces = {} # start time -> dictionary
        self._traces = TimeSeries(note=self.trace_note,
                                  draw=self.trace_draw)
        self.model.add_time_series(
            self, self._traces, traceAxis, "trace",
            "generations condemned by trace", clickdraw=True,
            marker='x', linestyle='None')
        self._condemned_size = TimeSeries()
        self.model.add_time_series(
            self, self._condemned_size, bytesAxis, "condemned.size",
            "size of segments condemned by trace", marker='+',
            linestyle='None')

    @property
    def name(self):
        if len(self.model.arenas) <= 1:
            # No need to distinguish arenas if there's just one.
            return ""
        name = self.model.label(self._pointer)
        if not name:
            class_name = self.model.label(self._arena_class) or 'Arena'
            if self._serial is not None:
                name = f"{class_name}[{self._serial}]"
            else:
                name = f"{class_name}[{self._pointer:x}]"
        return name

    def delegate_to_pool(self, t, event):
        "Handle a telemetry event by delegating to the pool model."
        pointer = event.pool
        try:
            pool = self._pool[pointer]
        except KeyError:
            self._pool[pointer] = pool = Pool(self, pointer, t)
            self._pools.append(pool)
        pool.handle(t, event)

    def ArenaAlloc(self, t, event):
        self.delegate_to_pool(t, event)
        if self._pool[event.pool]._serial >= self._internal_pools:
            self._alloc.add(t, event.size)

    def ArenaFree(self, t, event):
        self.delegate_to_pool(t, event)
        if self._pool[event.pool]._serial >= self._internal_pools:
            self._alloc.sub(t, event.size)

    PoolInit = \
        delegate_to_pool

    def delegate_to_gen(self, t, event):
        "Handle a telemetry event by delegating to the generation model."
        pointer = event.gen
        try:
            gen = self._gen[pointer]
        except KeyError:
            self._gen[pointer] = gen = Gen(self, pointer)
            self._gens.append(gen)
        gen.handle(t, event)

    GenInit = \
    GenZoneSet = \
    TraceEndGen = \
        delegate_to_gen

    def ArenaCreateVM(self, t, event):
        self._arena_class = event.arenaClass
        self._serial = event.serial

    ArenaCreateCL = ArenaCreateVM

    def PoolFinish(self, t, event):
        del self._pool[event.pool]

    def GenFinish(self, t, event):
        del self._gen[event.gen]

    def ArenaPollBegin(self, t, event):
        self._poll.on(t)

    def ArenaPollEnd(self, t, event):
        self._poll.off(t)

    def trace_note(self, t):
        if t not in self._all_traces:
            return f'no trace {t}', f'no trace {t}'
        return self._all_traces[t].note()
    
    def trace_draw(self, t, axes_dict):
        if t not in self._all_traces:
            return []
        return self._all_traces[t].draw(axes_dict)

    def TraceCreate(self, t, event):
        assert event.trace not in self._live_traces
        assert t not in self._all_traces
        trace = Trace(self, t, event)
        self._live_traces[event.trace] = self._all_traces[t] = trace

    def delegate_to_trace(self, t, event):
        "Handle a telemetry event by delegating to the trace model."
        trace = self._live_traces[event.trace]
        trace.handle(t, event)
        return trace

    TraceFlipBegin = \
    TraceFlipEnd = \
    TraceBandAdvance = \
    TraceReclaim = \
    TraceStatScan = \
    TraceStatFix = \
    TraceStatReclaim = \
        delegate_to_trace

    def ChainCondemnAuto(self, t, event):
        trace = self.delegate_to_trace(t, event)
        self._traces.append(trace.create, event.topCondemnedGenIndex + 1)

    def TraceCondemnAll(self, t, event):
        trace = self.delegate_to_trace(t, event)
        self._traces.append(trace.create, len(self._gens)) # TODO what's the right number here??!

    def TraceDestroy(self, t, event):
        self.delegate_to_trace(t, event)
        del self._live_traces[event.trace]

    def TraceStart(self, t, event):
        self.delegate_to_trace(t, event)
        self._condemned_size.append(t, event.condemned)
        if self._seg_summary:
            for gen in self._gen.values():
                gen.update_ref_size(t, self._seg_summary, self._seg_size)
    
    def SegSetSummary(self, t, event):
        size = event.size
        self._seg_summary[event.seg] = event.newSummary
        self._seg_size[event.seg] = size
        n = self.model.word_width
        univ = (1 << n) - 1
        new_univ = event.newSummary == univ
        old_univ = event.oldSummary == univ
        self._univ_ref_size.add(t, (new_univ - old_univ) * size)
        old_summary = 0 if old_univ else event.oldSummary
        new_summary = 0 if new_univ else event.newSummary
        for zone, old, new in zip(reversed(range(n)),
                                  bits_of_word(old_summary, n),
                                  bits_of_word(new_summary, n)):
            if new == old:
                continue
            if zone not in self._zone_ref_size:
                self._zone_ref_size[zone] = ref_size = Accumulator()
                self.model.add_time_series(
                    self, ref_size, bytesAxis, f"zone-{zone}.ref",
                    f"size of segments referencing zone {zone}")
            self._zone_ref_size[zone].add(t, (new - old) * size)

class Line:
    "A line in a Matplotlib plot wrapping a TimeSeries."
    colors = cycle('blue orange green red purple brown pink gray olive cyan'
                   .split())

    def __init__(self, owner, series, yaxis, name, desc,
                 draw=True, color_as=None, clickdraw=False,
                 **kwargs):
        self.owner = owner      # Owning object.
        self.series = series    # Time series.
        self.yaxis = yaxis      # Y Axis
        self._name = name       # Brief description.
        self.desc = desc        # Brief description.
        self.draw = draw        # Plot this line?
        self.clickdraw = clickdraw # should a click on a data point draw something on the axes?
        if color_as:
            self.color = color_as.color
        else:
            self.color = next(self.colors)
        self.axes = None        # Currently plotted on axes.
        self.line = None        # Matplotlib Line2D object.
        self._kwargs = kwargs   # Keyword arguments for Axes.plot.

    @property
    def name(self):
        return f"{self.owner.name}.{self._name}"

    @property
    def ready(self):
        return len(self.series.t) >= 1

    def count(self):
        return len(self.series.t)

    def unplot(self):
        if self.axes:
            self.line.remove()
            self.axes = None

    def plot(self, axes):
        "Plot or update line on axes."
        x = self.series.t
        y = self.series.y
        if self.line is None:
            self.axes = axes
            self.line, = axes.plot(x, y, color=self.color, label=self.name,
                                   **self._kwargs)
        else:
            if self.axes != axes:
                self.unplot()
                axes.add_line(self.line)
                self.axes = axes
            self.line.set_data(x, y)
            self.line.set_label(self.name)

    def contains(self, event):
        if self.line is None:
            return False, None
        return self.line.contains(event)

    def note(self, index):
        "Return annotation text and log box text for a selected point."
        t = self.series.t[index]
        note = log = None
        if self.series.note is not None:
            return self.series.note(t)
        return None, None

    def drawPoint(self, index, axes_dict):
        "Draw in response to a click on a data point, and return a list of drawn items."
        t = self.series.t[index]
        drawn = None
        # Could just draw on axes_dict[self.yaxis] ??
        if self.clickdraw:
            if self.series.draw is None:
                drawn = [ax.axvline(t) for ax in axes_dict.values()]
            else:
                drawn = self.series.draw(t, axes_dict)
        return drawn

class Model(EventHandler):
    "Model of an application using the MPS."
    def __init__(self, event_queue):
        "Create model based on queue of batches of telemetry events."
        self._queue = event_queue
        self._intern = {}       # stringId -> string
        self._label = {}        # address or pointer -> stringId
        self._arena = {}        # pointer -> Arena (for live arenas)
        self.arenas = []        # All arenas created in the model.
        self.lines = []         # All Lines available for plotting.
        self._needs_redraw = True # Plot needs redrawing?

    def add_time_series(self, *args, **kwargs):
        "Add a time series to the model."
        line = Line(*args, **kwargs)
        self.lines.append(line)
        return line

    def label(self, pointer):
        "Return string labelling address or pointer, or None if unlabelled."
        return self._intern.get(self._label.get(pointer))

    def plot(self, axes_dict):
        "Draw time series on the given axes."
        if not self._needs_redraw:
            return
        self._needs_redraw = False

        # Collate drawable lines by y axis
        yaxis_lines = defaultdict(list)
        for line in self.lines:
            if line.ready and line.draw:
                yaxis_lines[line.yaxis].append(line)
            else:
                line.unplot()

        axes_used = set()
        bounds_axes = defaultdict(list) # axes drawn in each area

        # Draw the lines
        for yax in yaxis_lines:
            axes = axes_dict[yax]
            axes_used.add(axes)
            axes.set_axis_on()
            axes.set_ylabel(yax.label())
            for line in yaxis_lines[yax]:
                line.plot(axes)
            axes.relim()
            axes.autoscale_view()
            bounds_axes[axes.bbox.bounds].append((axes, yax))

        # Set the format_coord method for each axes
        for bounds, ax_list in bounds_axes.items():
            if len(ax_list) > 1:
                # If format_coord iterates of ax_list, it may iterate
                # over the wrong value of ax_list (the last value
                # bound by the bounds_axes iteration). So build this
                # separate yax_trans_list here.
                yax_trans_list = [(yax, ax.transData)
                                  for ax, yax in ax_list]
                for ax, yax in ax_list:
                    tData = ax.transData
                    def format_coord(x, y):
                        # x, y are data coordinates
                        _, axy = tData.transform((0, y)) # y in display coordinates
                        # Invert the transforms here. If you invert them at plotting time
                        # and cache them so we don't have to invert them every time format_coord
                        # is called, then you get the wrong answer.
                        return (f'{x:f} s, ' +
                                ', '.join(inner_yax.fmt(t.inverted().transform((0, axy))[1])
                                          for inner_yax, t in yax_trans_list))
                    ax.format_coord = format_coord
            else:
                ax, yax = ax_list[0]
                def format_coord(x, y):
                    return f'{x:f} s, {yax.fmt(y)}'
                ax.format_coord = format_coord

        # Remaining axes are not needed.
        for ax in axes_dict.values():
            if ax not in axes_used:
                axes.set_axis_off()

    def update(self):
        "Consume available telemetry events and update the model."
        while True:
            try:
                batch = self._queue.get_nowait()
            except queue.Empty:
                break
            else:
                for t, event in batch:
                    self.handle(t, event)

    def needs_redraw(self):
        "Call this when the model needs redrawing."
        self._needs_redraw = True

    def delegate_to_arena(self, t, event):
        "Handle a telemetry event by delegating to the arena model."
        addr = event.arena
        try:
            arena = self._arena[addr]
        except KeyError:
            self._arena[addr] = arena = Arena(self, addr, t)
            self.arenas.append(arena)
        arena.handle(t, event)

    ArenaAlloc = \
    ArenaCreateCL = \
    ArenaCreateVM = \
    ArenaFree = \
    ArenaPollBegin = \
    ArenaPollEnd = \
    ChainCondemnAuto = \
    GenInit = \
    GenFinish = \
    GenZoneSet = \
    PoolFinish = \
    PoolInit = \
    SegSetSummary = \
    TraceCondemnAll = \
    TraceEndGen = \
    TraceStart = \
    TraceCreate = \
    TraceDestroy = \
    TraceStart = \
    TraceFlipBegin = \
    TraceFlipEnd = \
    TraceBandAdvance = \
    TraceReclaim = \
    TraceStatScan = \
    TraceStatFix = \
    TraceStatReclaim = \
        delegate_to_arena

    def EventClockSync(self, t, event):
        self.needs_redraw()

    def Intern(self, t, event):
        self._intern[event.stringId] = event.string.decode('ascii', 'replace')

    def Label(self, t, event):
        self._label[event.address] = event.stringId

    def LabelPointer(self, t, event):
        self._label[event.pointer] = event.stringId

    def ArenaDestroy(self, t, event):
        del self._arena[event.arena]

    def EventInit(self, t, event):
        self.word_width = event.wordWidth


class ApplicationToolbar(NavigationToolbar):
    "Subclass of Matplotlib's navigation toolbar adding a pause button."
    def __init__(self, *args):
        self.toolitems += (('Pause', 'Pause', PAUSE_ICON, 'pause'),)
        super().__init__(*args)
        self._actions['pause'].setCheckable(True)
        self.paused = False

    def pause(self):
        "Toggle the pause button."
        self.paused = not self.paused
        self._actions['pause'].setChecked(self.paused)


class ApplicationWindow(QtWidgets.QMainWindow):
    """PyQt5 application displaying time series derived from MPS telemetry
    output.

    """
    def __init__(self, model : Model, title : str):
        """Create application. 'model' is the MPS model whose time series are
        to be displayed, and 'title' is the main window title.

        """
        super().__init__()

        self._model = model      # The MPS model.
        self._home_limits = None # Limits of the graph in "home" position.
        self._line_checkbox = {} # Line -> QCheckbox

        self.setWindowTitle(title)

        # Control-W (Command-W on macOS) shortcut for closing the window.
        shortcut = QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+W"), self)
        shortcut.activated.connect(self.close)

        # Arrow key shortcuts for moving along lines.
        shortcut = QtWidgets.QShortcut(QtGui.QKeySequence("Right"), self)
        shortcut.activated.connect(self._rightArrow)
        shortcut = QtWidgets.QShortcut(QtGui.QKeySequence("Left"), self)
        shortcut.activated.connect(self._leftArrow)

        main = QtWidgets.QWidget()
        self.setCentralWidget(main)
        
        # make a splitter and a layout to contain it
        main_layout = QtWidgets.QHBoxLayout()
        splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)
        main_layout.addWidget(splitter)
        main.setLayout(main_layout)

        # Above the splitter, an hbox layout
        upper = QtWidgets.QWidget()
        upper_layout = QtWidgets.QHBoxLayout()
        upper.setLayout(upper_layout)
        splitter.addWidget(upper)

        # Scrollable list of checkboxes, one for each time series.
        self._lines = QtWidgets.QVBoxLayout()
        self._lines_scroll = QtWidgets.QScrollArea(
            horizontalScrollBarPolicy=QtCore.Qt.ScrollBarAlwaysOff)
        self._lines_widget = QtWidgets.QWidget()
        lines_layout = QtWidgets.QVBoxLayout(self._lines_widget)
        lines_layout.addLayout(self._lines)
        lines_layout.addStretch(1)
        self._lines_scroll.setWidget(self._lines_widget)
        self._lines_scroll.setWidgetResizable(True)
        upper_layout.addWidget(self._lines_scroll)

        # Matplot canvas and toolbar.
        self._canvas = FigureCanvas(Figure(figsize=(10, 6)))
        bytes_axes, trace_axes = self._canvas.figure.subplots(nrows=2, sharex=True, gridspec_kw={'hspace':0, 'height_ratios':(5, 1)})
        fraction_axes = bytes_axes.twinx()
        self._axes_dict = {bytesAxis: bytes_axes,
                           fractionAxis: fraction_axes,
                           traceAxis: trace_axes}
        trace_axes.set_xlabel("time (seconds)")
        bytes_axes.set_xlabel("time (seconds)")
        # trace_axes.set_yticks([])
        # trace_axes.tick_params(axis='y', which='both', left=False)
        upper_layout.addWidget(self._canvas)
        self._toolbar = ApplicationToolbar(self._canvas, self)
        self.addToolBar(QtCore.Qt.TopToolBarArea, self._toolbar)

        # Below the splitter, a text box for logging
        self._logbox = QtWidgets.QTextEdit()
        self._logbox.setReadOnly(True)
        self._logbox.setLineWrapMode(True)
        splitter.addWidget(self._logbox)

        # Line annotations.
        self._line_annotation = bytes_axes.annotate(
            "", xy=(0, 0), xytext=(-20, 20),
            textcoords='offset points',
            bbox=dict(boxstyle='round', fc='w'),
            arrowprops=dict(arrowstyle='->'),
            annotation_clip=False,
            visible=False)
        self._line_annotation.get_bbox_patch().set_alpha(0.8)
        self._annotated_line = None
        self._annotated_point = None
        self._canvas.mpl_connect("button_release_event", self._click)

        # Things drawn in response to a click
        self._clickdrawn = defaultdict(dict)

        # Call self._update in a loop forever.
        self._update()
        self._timer = self._canvas.new_timer(100, [(self._update, (), {})])
        self._timer.start()

    def _rightArrow(self):
        if self._annotated_line is None:
            return
        self.annotate_point(self._annotated_line, self._annotated_point+1)

    def _leftArrow(self, *args, **kwArgs):
        if self._annotated_line is None:
            return
        self.annotate_point(self._annotated_line, self._annotated_point-1)

    def annotate_point(self, line, i):
        if i < 0 or i > line.count():
            return False
        a = self._line_annotation
        a.remove()
        x, y = line.line.get_data()
        note, log = line.note(i)
        if note is None:
            note = [f"{line.name}",f"{x[i]:f} s",f"{line.yaxis.fmt(y[i])}"]
            log = ' '.join(note)
            note = '\n'.join(note)
        self._logbox.append(log)
        line.axes.add_artist(a)
        a.xy = x[i], y[i]
        a.set_text(note)
        a.set_visible(True)
        self._annotated_line = line
        self._annotated_point = i
        return True

    def _click(self, event):
        "Handle left mouse click by annotating line clicked on."
        if event.button != 1 or not event.inaxes:
            return
        modifiers = QtGui.QGuiApplication.keyboardModifiers()
        # if control not held down, make all existing clickdraws go away
        if not (modifiers & QtCore.Qt.ControlModifier):
            for cl in self._clickdrawn.values():
                for ls in cl.values():
                    for l in ls:
                        l.set_visible(False)
            self._clickdrawn = defaultdict(dict)
        for line in self._model.lines:
            if not (line.ready and line.draw):
                continue
            contains, index = line.contains(event)
            if contains:
                x, y = line.line.get_data()
                i = index['ind'][0]
                if i in self._clickdrawn[line]: # remove things previously drawn for this point
                    for l in self._clickdrawn[line][i]:
                        l.set_visible(False)
                    del self._clickdrawn[line][i]
                else:
                    drawn = line.drawPoint(i, self._axes_dict)
                    if drawn is not None:
                        self._clickdrawn[line][i] = drawn
                self.annotate_point(line, i)
                break
        else:
            a.set_visible(False)
            self._annotated_line = None

    @property
    def _limits(self):
        "Current x and y limits of the Matplotlib graph."
        ax = self._axes_dict[bytesAxis]
        return ax.get_xlim(), ax.get_ylim()

    def _update(self):
        "Update the model and redraw if not paused."
        if (not self._toolbar.paused
            and self._home_limits not in (None, self._limits)):
            # Limits changed (for example, because user zoomed in), so pause
            # further updates to give user a chance to explore.
            self._toolbar.pause()
            self._home_limits = None
        self._model.update()
        if not self._toolbar.paused:
            self._model.plot(self._axes_dict)
            self._home_limits = self._limits
            self._canvas.draw()

        # Find new time series and create corresponding checkboxes.
        checkboxes_changed = False
        for line in self._model.lines:
            if not line.ready:
                continue
            new_name = line.name
            if line in self._line_checkbox:
                # A line's name can change dynamically (for example, because
                # of the creation of a second arena, or a Label event), so
                # ensure that it is up to date.
                old_name = self._line_checkbox[line].text()
                if old_name != new_name:
                    self._line_checkbox[line].setText(new_name)
                    checkboxes_changed = True
            else:
                checkboxes_changed = True
                checkbox = QtWidgets.QCheckBox(new_name)
                self._line_checkbox[line] = checkbox
                checkbox.setChecked(line.draw)
                checkbox.setToolTip(f"{line.desc} ({line.yaxis.label})")
                self._lines.addWidget(checkbox)
                def state_changed(state, line=line):
                    line.draw = bool(state)
                    if line == self._annotated_line:
                        self._line_annotation.set_visible(False)
                    self._model.needs_redraw()
                checkbox.stateChanged.connect(state_changed)
                checkbox.setStyleSheet(f"color:{line.color}")

        # Sort checkboxes into order by name and update width.
        if checkboxes_changed:
            checkboxes = self._line_checkbox.values()
            for checkbox in checkboxes:
                self._lines.removeWidget(checkbox)
            for checkbox in sorted(checkboxes, key=lambda c:c.text()):
                self._lines.addWidget(checkbox)
            self._lines_scroll.setFixedWidth(
                self._lines_widget.sizeHint().width())


def main():
    parser = argparse.ArgumentParser(description="Memory Pool System Monitor.")
    parser.add_argument(
        'telemetry', metavar='FILENAME', nargs='?', type=str,
        default=os.environ.get('MPS_TELEMETRY_FILENAME', 'mpsio.log'),
        help="telemetry output from the MPS instance")
    args = parser.parse_args()

    with open(args.telemetry, 'rb') as telemetry_file:
        event_queue = queue.Queue()
        model = Model(event_queue)
        decoder = telemetry_decoder(telemetry_file.read)
        for batch in decoder(1):
            event_queue.put(batch)
            model.update()
        stop = threading.Event()

        def decoder_thread():
            while not stop.isSet():
                for batch in decoder():
                    if stop.isSet():
                        break
                    event_queue.put(batch)

        thread = threading.Thread(target=decoder_thread)
        thread.start()
        qapp = QtWidgets.QApplication([])
        app = ApplicationWindow(model, args.telemetry)
        app.show()
        result = qapp.exec_()
        stop.set()
        thread.join()
        return result


if __name__ == '__main__':
    exit(main())


# C. COPYRIGHT AND LICENCE
#
# Copyright (c) 2018 Ravenbrook Ltd.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the
#    distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#
# $Id$
