<?xml version="1.0" encoding="UTF-8"?>



<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">



 <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>

  <head>

   <title>MPS Allocation Point Protocol</title>

  </head>

  <body bgcolor='#FFFFFF' text='#000000' link='#000099' vlink='#660066' alink='#FF0000'>

   <div align='center'>

    <h1>MPS Allocation Point Protocol</h1>

    <p>incomplete</p>

    <address>lmb, 1997-06-10</address>

   </div>

   <h2>

    <a id='section-introduction' name='section-introduction'>Introduction</a>

   </h2>

   <p>This document describes the protocols which can be used in conjunction with MPS allocation points.  Currently there are three protocols: reserve/commit allocation, stack discipline, allocation patterns.</p>

   <p>Reserve/commit allocation is intended to be used for fast (in particular lock-free) allocation of formatted objects.  This protocol ensures uninitialized (i.e., uncommitted) objects are never scanned.</p>

   <p>Stack discipline is intended to be used both for the fast freeing of object sets which obey a stack-like discipline and for declaring object sets to be mostly dead.  </p>

   <p>

    Allocation patterns can be used to declare particular idioms of object creation and destruction.  They aren't described in this document, but should be.  The "ramp" allocation pattern (which is a particular pattern) is described in protocol.mps.alloc-pattern-ramp

    .

   </p>

   <h2>

    <a id='section-definitions' name='section-definitions'>Definitions</a>

   </h2>

   <p>

    <strong>.def.ap</strong>

    : AP.  An abbreviation for Allocation Point.

   </p>

   <h2>

    <a id='section-creating-and-destroying' name='section-creating-and-destroying'>Creating And Destroying</a>

   </h2>

   <p>

    <strong>.create</strong>

    : An allocation point is created using mps_ap_create or mps_ap_create_v.  mps_ap_create takes a variable number of arguments; mps_ap_create_v is just the same as mps_ap_create except with the extra arguments passed as a single va_list argument.  The extra arguments are interpreted by the pool in a pool class dependent way.

   </p>

   <p>

    <strong>.destroy</strong>

    : An allocation point is destroyed with mps_ap_destroy.  You cannot destroy an allocation point that is between reserve and commit.  Note that before you destroy a pool (mps_pool_destroy), you should destroy all allocation points in it.

   </p>

   <h2>

    <a id='section-using-allocation-points' name='section-using-allocation-points'>Using Allocation Points</a>

   </h2>

   <p>

    <strong>.use</strong>

    :

     The client has five options about how to use allocation points:

   </p>

   <p>

    <strong>.use.own.as</strong>

    : Write their own allocation point code in assembler 

   </p>

   <p>

    <strong>.use.own.c</strong>

    : Write their own allocation point code in C 

   </p>

   <p>

    <strong>.use.mps.fn</strong>

    :

     Use MPS functions 

   </p>

   <p>

    <strong>.use.mps.macro</strong>

    :

     Use MPS macros 

   </p>

   <p>

    <strong>.use.mps.macro-block</strong>

    :

     Use MPS block macros

   </p>

   <p>

    <strong>.use.tradeoff</strong>

    : The different options trade off convenience for control.  Clients writing their own assembler get to control (within the limits of the protocols) the exact code sequence, but they may well have to know how certain structures get laid out in C and exactly what sequence of operations the protocol consists of.

   </p>

   <h2>

    <a id='section-type' name='section-type'>Type</a>

   </h2>

   <p>

    <strong>.type</strong>

    : Allocation points are not abstract data types.  There are some opaque aspects and some transparent aspects.  Client programs can know the structure and directly modify fields, but must obey certain protocols.

   </p>

   <p>

    <strong>.type.structure</strong>

    : Allocation points have a structure of five words -- abstractly referred to as Init, Alloc, Limit, FramePointer, Enabled.

   </p>

   <p>

    <strong>.type.structure.protocol</strong>

    : Not all the fields are used by all of the protocols.

   </p>

   <p>

    <strong>.type.structure.detail</strong>

    : Depending on how the client is using APs (see .use above) they may or may not need to know about the details of the structure.  If the client is using MPS provided macros then they should not need to know anything about the structure for example.

   </p>

   <h2>

    <a id='section-allocation' name='section-allocation'>Allocation</a>

   </h2>

   <p>

    <strong>.alloc</strong>

    : APs are primarily used to allocate objects:

   </p>

   <p>

    <strong>.alloc.kind</strong>

    :

     There are four kinds of allocation:

   </p>

   <p>

    <strong>.alloc.reserve-commit-loop</strong>

    : 

    Two-phase allocations with looping.

   </p>

   <p>

    <strong>.alloc.reserve-commit-linear</strong>

    : 

    Two-phase allocations that are always successful.

   </p>

   <p>

    <strong>.alloc.one-phase</strong>

    : 

    One-phase allocations -- Reserve and Commit are done at the same time (see below).

   </p>

   <p>

    <strong>.alloc.promise</strong>

    : 

    Promises -- you can ask for a certain amount of memory.  This type of allocation only deals with Limit (see below).

   </p>

   <p>

    <strong>.alloc.class-dependent</strong>

    : 

    The pool classes you are using determine which allocation protocols you can use; some pool classes require certain allocation protocols.

   </p>

   <p>

    <strong>.alloc.speed</strong>

    : In general allocation using APs is intended to be fast.  This is achieved by:

   </p>

   <p>

    <strong>.alloc.lock-free</strong>

    : By avoiding locking synchronization.

   </p>

   <p>

    <strong>.alloc.inline</strong>

    : By avoiding function calls.

   </p>

   <p>RESERVE/COMMIT</p>

   <p>

    <strong>.reserve-commit</strong>

    : This part of the document describes the reserve/commit protocol.

   </p>

   <p>Pseudo-code</p>

   <p>

    <strong>.reserve-commit.pseudo-code</strong>

    :

     The pseudo-code for a reserve/commit sequence on an allocation point is as follows:

   </p>

   <p>

    <pre>  do { 

    res = mps_reserve(&amp;p, ap, size);

    if(res != RES_OK) {

      do something;

    }

    else init(p);

  } while (!mps_commit (ap, p, size));</pre>

   </p>

   <p>

    <strong>.reserve-commit.reserve</strong>

    :

     If mps_reserve fails, the client program doesn't get the memory it needs.  If it succeeds, the memory is allocated in a block whose address is "p".

   </p>

   <p>

    <strong>.reserve-commit.client-init</strong>

    : "init" is code that you write.  The memory has to be filled in with a correctly formatted object (the interpretation of "correctly formatted" will depend on the pool class used).

   </p>

   <p>

    <strong>.reserve-commit.commit</strong>

    : After initialization, you can do the commit.  The pool needs to know that the object has been initialized, and the commit informs the pool that the object is ready.  If the commit fails, which should be rare (some pool classes may be able to guarantee that it never happens), the memory is not allocated and you have to start from scratch.  The code returns TRUE if okay, FALSE if it fails.

   </p>

   <p>Pool Class Dependencies</p>

   <p>

    <strong>.reserve-commit.pool-class.format</strong>

    :

     The initialization phase of reserve/commit depends on the format of the object being allocated.  Some pool classes may not be formatted (perhaps the objects have no references or are scanned ambiguously).  In this case the reserve and the commit can be done at the same time.

   </p>

   <p>

    <strong>.reserve-commit.pool-class.commit</strong>

    :

     Some pool classes occasionally need to have the commit fail; other pool classes may be able to guarantee that commit will never fail.  This is mainly to synchronize with the garbage collector and will happen at most once per collection cycle; there are other reasons for failing commit, but this will happen very rarely.

   </p>

   <p>Implementation Details</p>

   <p>

    <strong>.reserve-commit.details</strong>

    :

     A chunk of memory is passed to the client application, which can allocate it using the protocol.

   </p>

   <p>Doing a reserve increments Alloc (but not past Limit).</p>

   <p>

    <strong>.reserve-commit.reserve.code</strong>

    :

     Reserve:

   </p>

   <p>  T = Alloc + size;</p>

   <p>  if(T &gt; Limit || T &lt;= Alloc)           /* overflow check */ </p>

   <p>    res = mps_ap_fill(&amp;p, ap, size)     /* ask MM to give you a */</p>

   <p>                                        /* bigger chunk of memory */ </p>

   <p>  else {</p>

   <p>    Alloc = T;</p>

   <p>    P = Init;</p>

   <p>    res = OK;</p>

   <p>  }</p>

   <p>Then the client initializes the memory, then commits it:</p>

   <p>

    <strong>.reserve-commit.commit.code</strong>

    :

     Commit:

   </p>

   <p>  Alloc = Init;</p>

   <p>  if(Limit = 0)</p>

   <p>    b = mps_ap_trip(ap, &amp;p, size)   /* calls MM */ </p>

   <p>  else b = TRUE   /* b = boolean result */</p>

   <p>

    <strong>.reserve-commit.check.limit</strong>

    :

     The MPS can poke Limit to 0 whenever necessary in order to regain control, so the commit code has to check that the MPS has not done this between the reserve phase and the commit phase. Whenever the MM is invoked, it can do whatever it needs to, so the client cannot assume that the values of any of the AP's fields will stay the same.

   </p>

   <p>Outside of invoking the MM, Alloc and Init will not change unless the client application changes them.  However, Limit can change at any point.  The client application is not allowed to change Limit; it can change Alloc and Init as long as it follows the protocol.</p>

   <p>

    <strong>.reserve-commit.atomic</strong>

    :

     The updates (writes) and reads of Alloc and Init have to be atomic with respect to threads.  This means that the client application must read the whole field at once (one instruction in machine code).

   </p>

   <p>Macros and Functions</p>

   <p>

    <strong>.reserve-commit.c</strong>

    : The reserve/commit protocol is provided through the MPS C interface by the functions:

   </p>

   <p>   mps_reserve</p>

   <p>   mps_commit </p>

   <p>and macros:</p>

   <p>   MPS_RESERVE</p>

   <p>   MPS_COMMIT</p>

   <p>   MPS_RESERVE_BLOCK</p>

   <p>

    <strong>.reserve-commit.c.macro.side-effects</strong>

    : The difference between macros and functions is that macros may evaluate their arguments more than once.  For example, the macro MPS_RESERVE(&amp;p, ap, size++) expands into code that may contain size++ in more than one location, causing the compiler to evaluate it more than once.  Therefore, you should not use side effects in macros.

   </p>

   <p>

    <strong>.reserve-commit.macro.warning.l-values</strong>

    : In the block macro MPS_RESERVE_BLOCK(res_var, ptr_var, ap, size), the variables have to be l-values -- that is, things that values can be assigned to -- because the compiler handles variables better than pointers.

   </p>

   <h2>

    <a id='section-stack-discipline' name='section-stack-discipline'>Stack Discipline</a>

   </h2>

   <p>

    <strong>.stack</strong>

    : This part of the document describes the stack discipline protocol.

   </p>

   <p>

    <strong>.stack.what</strong>

    : Stack discipline is a means by which object lifetimes can be declared to observe a stack-like behavior.  By stack-like behavior we mean that if a particular object is dead then all objects allocated since that object are dead as well (so one can imagine managing the objects using a stack).  In fact the protocol can be less strict about the liveness of the objects; it can be used to mean that all the objects allocated since a particular object are _likely_ to be dead rather than actually are dead.  Which of these two interpretations is used depends on the pool class involved.

   </p>

   <p>

    <strong>.stack.frames</strong>

    : All APs have a stack of frames associated with them (if the function used in this protocol are not used then it isn't necessary to consider this stack of frames).  

    <strong>.stack.frames.inde</strong>

    : 

    The stacks belonging to each AP are independent of each other.  

    <strong>.stack.frames.order</strong>

    : 

    The frames in a stack are arranged in a partial order with a parent/child relationship (the stack frames form a tree).

   </p>

   <p>

    <strong>.stack.frame.what</strong>

    : A frame is used to group a set of objects together.  The ordering of frames (see .stack.frames.order) provides a larger grouping.  

    <strong>.stack.frame.why</strong>

    : The chief purpose of frames is so that a set of objects can be declared dead at once (so it provides a kind of mass free interface).

   </p>

   <p>

    <strong>.stack.frame.current</strong>

    : Every AP has a current frame.  

    <strong>.stack.frame.current.top</strong>

    : Some pool classes may restrict the current frame to be the (unique) frame with no child (see the push operation below, .stack.frame.push), in this case the stack frames form a linear order.  

    <strong>.stack.frame.current.any</strong>

    : Other pool classes may allow the current frame to be selected from any of the frames in the stack.  

    <strong>.stack.frame.alloc</strong>

    : Objects that are allocated in an AP are allocated in the current frame.

   </p>

   <p>

    <strong>.stack.frame.init</strong>

    : Initially, when APs are created they have a single frame; it is the current frame; this frame cannot be popped (see below).

   </p>

   <p>

    <strong>.stack.frame.push</strong>

    : Stack frames are created and linked into the ordered tree with a push operation.  This create a new frame and makes it a child of the current frame; the newly created frame becomes the current frame  (Note that as observed above, .stack.frame.current.top, if the current frame always has no children then a linear ordering of the frames is formed.)  The previously current frame is still valid and its objects are still alive.

   </p>

   <p>

    <strong>.stack.frame.pop</strong>

    : The pop operation pops the stack back to a specified frame.  The specified frame and all its descendants (i.e., its children and all their children transitively) become invalid; the objects in those frames are dead.  If the frames form a linear order then the descendants of a particular frame are all the frames pushed since that one.  Actually the meaning associated with the objects in the frames is pool class dependent.  Some pool classes will use the pop operation to mean that all the denoted objects are dead and their storage space may be reclaimed; other pool classes use the pop operation to that the denoted objects are mostly dead (they are likely to be good candidates for garbage collection).  Consult the pool class documentation for details.

   </p>

   <p>Implementation</p>

   <p>

    <strong>.stack.c</strong>

    : The push and pop operations are provided in the MPS C interface in the form of the functions:

   </p>

   <p>mps_ap_frame_push</p>

   <p>mps_ap_frame_pop</p>

   <h2>

    <a id='section-summary-of-restrictions' name='section-summary-of-restrictions'>Summary Of Restrictions</a>

   </h2>

   <p>* You have to initialize memory if you are using formatted pool classes.</p>

   <p>* You cannot assume that the values of Alloc and Init will remain the same if you invoke the MM.</p>

   <p>* You cannot assume that the value of Limit will ever remain the same; you have to check it before using it.</p>

   <p>* You cannot change the value of Limit yourself.</p>

   <h2>

    <a id='section-notes' name='section-notes'>Notes</a>

   </h2>

   <p>

    <strong>.decision</strong>

    : 

    Some constraints can be relaxed depending on the environment in which the MPS is being used.  In particular, in a single-threaded system, you can do just about anything as long as you don't invoke the MPS.

   </p>

   <p>

    <strong>.mem-barriers</strong>

    : On some multiprocessor systems (say, DEC Alpha), memory reads and writes can get reordered and so appear out of order on another processor (a.k.a. "Relaxed Memory Ordering" or "Weak Memory Ordering"), so we need to use "memory barriers" that ensure that the code is executed with enough order to guarantee the invariants.  This is not shown in this document yet.

   </p>

   <h2>

    <a id='section-A' name='section-A'>A. References</a>

   </h2>

   <h2>

    <a id='section-B' name='section-B'>B. Document History</a>

   </h2>

   <table>

    <tr valign='top'>

     <td>1997-06-10 11:59:47 -04</td>

     <td />

     <td>New document saved</td>

    </tr>

    <tr valign='top'>

     <td>1997-06-20 16:13:22 -04</td>

     <td />

     <td>Some minor edits.</td>

    </tr>

    <tr valign='top'>

     <td>1997-10-22 15:43:47 +01</td>

     <td />

     <td>fixed formatting</td>

    </tr>

    <tr valign='top'>

     <td>1998-06-08 18:53:25 +01</td>

     <td>pekka</td>

     <td>Added description of create and destroy</td>

    </tr>

    <tr valign='top'>

     <td>1998-06-15 15:52:01 +00</td>

     <td>drj</td>

     <td>minor comments</td>

    </tr>

    <tr valign='top'>

     <td>1998-10-19 16:34:48 +00</td>

     <td />

     <td>edited up to ###</td>

    </tr>

    <tr valign='top'>

     <td>1998-10-19 16:35:32 +00</td>

     <td>drj</td>

     <td>stuff</td>

    </tr>

    <tr valign='top'>

     <td>1998-10-20 12:05:33 +00</td>

     <td>drj</td>

     <td>paranoia</td>

    </tr>

    <tr valign='top'>

     <td>1998-10-20 14:05:17 +00</td>

     <td>drj</td>

     <td>add .stack.*</td>

    </tr>

    <tr valign='top'>

     <td>1998-10-23 16:01:41 +00</td>

     <td>drj</td>

     <td>ref allocation pattern</td>

    </tr>

    <tr valign='top'>

     <td>1998-10-27 18:04:27 +00</td>

     <td />

     <td>minore updates</td>

    </tr>

    <tr valign='top'>

     <td>1998-10-27 18:04:33 +00</td>

     <td>drj</td>

     <td>minor updates</td>

    </tr>

    <tr valign='top'>

     <td>2000-05-22 16:01:36 +01</td>

     <td>pekka</td>

     <td>clean up all the internal comments; move alignment stuff to Alloc Protocol</td>

    </tr>

    <tr valign='top'>

     <td>2000-05-22 16:02:12 +01</td>

     <td>pekka</td>

     <td>fix title</td>

    </tr>

    <tr valign='top'>

     <td>2000-07-19 18:08:30 +01</td>

     <td>pekka</td>

     <td>note on scanning</td>

    </tr>

    <tr valign='top'>

     <td>2001-09-26</td>

     <td>

      <a href='mailto:ndl@ravenbrook.com'>NDL</a>

     </td>

     <td>Converted from xml to html (second pass).</td>

    </tr>

   </table>

   <hr />

   <p>

    <small>Copyright &copy; 2001 Ravenbrook Limited.  This document is provided "as is", without any express or implied warranty.  In no event will the authors be held liable for any damages arising from the use of this document.  You may not duplicate or reproduce this document in any form without the express permission of the copyright holder.</small>

   </p>

   <div align='center'>

    <p>

     <code>$Id$</code>

    </p>

   </div>

  </body>

 </html>

