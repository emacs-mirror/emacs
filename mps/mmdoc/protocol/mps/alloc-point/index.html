<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>

<title>MPS Allocation Point Protocol</title>

</head>

<body bgcolor="#FFFFFF" text="#000000" link="#000099" vlink="#660066" alink="#FF0000">

<div align="center">

<h1>MPS Allocation Point Protocol</h1>

<p>incomplete</p>

<address>
<a href="mailto:nb@ravenbrook.com">Nick Barnes</a>,
<a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>,
2001-11-15
</address>

</div>

<h2><a id="section-Contents" name="section-Contents">Contents</a></h2>

<ul>

<li><a href="#section-1">1. Introduction</a></li>

<li><a href="#section-2">2. Definitions</a></li>

<li><a href="#section-3">3. Creating and Destroying</a></li>

<li><a href="#section-4">4. Using Allocation Points</a></li>

<li><a href="#section-5">5. Type</a></li>

<li><a href="#section-6">6. Allocation</a></li>

<li>

  <a href="#section-7">7. Reserve/Commit</a>

  <ul>

  <li><a href="#section-7.1">7.1. Pseudo-Code</a></li>

  <li><a href="#section-7.2">7.2. Pool Class Dependencies</a></li>

  <li><a href="#section-7.3">7.3. Implementation Details</a></li>

  <li><a href="#section-7.4">7.4. Macros and Functions</a></li>

  </ul>

</li>

<li>

  <a href="#section-8">8. Stack Discipline</a>

  <ul>

  <li><a href="#section-8.1">8.1. Overview</a></li>

  <li><a href="#section-8.2">8.2. Detail</a></li>

  <li><a href="#section-8.3">8.3. Implementation</a></li>

  </ul>

</li>

<li><a href="#section-9">9. Summary of Restrictions</a></li>

<li><a href="#section-10">10. Notes</a></li>

<li><a href="#section-A">A. References</a></li>

<li><a href="#section-B">B. Document history</a></li>

</ul>

<h2><a id="section-1" name="section-1">1. Introduction</a></h2>

<p>This document describes the protocols which can be used in
conjunction with MPS allocation points.  Currently there are three
protocols: reserve/commit allocation, stack discipline, allocation
patterns.</p>

<p>Reserve/commit allocation is intended to be used for fast (in
particular lock-free) allocation of formatted objects.  This protocol
ensures uninitialized (i.e., uncommitted) objects are never
scanned.</p>

<p>Stack discipline is intended to be used both for the fast freeing
of object sets which obey a stack-like discipline and for declaring
object sets to be mostly dead. </p>

<p>Allocation patterns can be used to declare particular idioms of
object creation and destruction.  They aren't described in this
document, but should be.  The "ramp" allocation pattern (which is a
particular pattern) is described in <a
href="../alloc-pattern-ramp/">protocol.mps.alloc-pattern-ramp.</a>
</p>

<h2><a id="section-2" name="section-2">2. Definitions</a></h2>

<p><a id="def.ap" name="def.ap"><strong>.def.ap:</strong></a>

AP.  An abbreviation for Allocation Point.</p>

<h2><a id="section-3" name="section-3">3. Creating And Destroying</a></h2>

<p><a id="create" name="create"><strong>.create:</strong></a>

An allocation point is created using <code
class="source">mps_ap_create</code> or <code
class="source">mps_ap_create_v</code>.  <code
class="source">mps_ap_create</code> takes a variable number of
arguments; <code class="source">mps_ap_create_v</code> is just the
same as <code class="source">mps_ap_create</code> except with the
extra arguments passed as a single <code class="source">va_list</code>
argument.  The extra arguments are interpreted by the pool in a pool
class dependent way.</p>

<p><a id="destroy" name="destroy"><strong>.destroy:</strong></a>

An allocation point is destroyed with <code
class="source">mps_ap_destroy</code>.  You cannot destroy an
allocation point that is between reserve and commit.  Note that before
you destroy a pool (<code class="source">mps_pool_destroy</code>), you
should destroy all allocation points in it.</p>

<h2><a id="section-4" name="section-4">4. Using Allocation Points</a></h2>

<p><a id="use" name="use"><strong>.use:</strong></a>

The client has five options about how to use allocation points:</p>

<p><a id="use.own.as" name="use.own.as"><strong>.use.own.as:</strong></a>

Write their own allocation point code in assembler</p>

<p><a id="use.own.c" name="use.own.c"><strong>.use.own.c:</strong></a>

Write their own allocation point code in C</p>

<p><a id="use.mps.fn" name="use.mps.fn"><strong>.use.mps.fn:</strong></a>

Use MPS functions</p>

<p><a id="use.mps.macro" name="use.mps.macro"><strong>.use.mps.macro:</strong></a>

Use MPS macros</p>

<p><a id="use.mps.macro-block" name="use.mps.macro-block"><strong>.use.mps.macro-block:</strong></a>

Use MPS block macros</p>

<p><a id="use.tradeoff" name="use.tradeoff"><strong>.use.tradeoff:</strong></a>

The different options trade off convenience for control.  Clients
writing their own assembler get to control (within the limits of the
protocols) the exact code sequence, but they may well have to know how
certain structures get laid out in C and exactly what sequence of
operations the protocol consists of.</p>

<h2><a id="section-5" name="section-5">5. Type</a></h2>

<p><a id="type" name="type"><strong>.type:</strong></a>

Allocation points are not abstract data types.  There are some opaque
aspects and some transparent aspects.  Client programs can know the
structure and directly modify fields, but must obey certain
protocols.</p>

<p><a id="type.structure" name="type.structure"><strong>.type.structure:</strong></a>

Allocation points have a structure of five words -- abstractly
referred to as Init, Alloc, Limit, FramePointer, Enabled.</p>

<p><a id="type.structure.protocol" name="type.structure.protocol"><strong>.type.structure.protocol:</strong></a>

Not all the fields are used by all of the protocols.</p>

<p><a id="type.structure.detail" name="type.structure.detail"><strong>.type.structure.detail:</strong></a>

Depending on how the client is using APs (see <a href="#use">.use</a> above) they may or
may not need to know about the details of the structure.  If the
client is using MPS provided macros then they should not need to know
anything about the structure for example.</p>

<h2><a id="section-6" name="section-6">6. Allocation</a></h2>

<p><a id="alloc" name="alloc"><strong>.alloc:</strong></a>

APs are primarily used to allocate objects:</p>

<p><a id="alloc.kind" name="alloc.kind"><strong>.alloc.kind:</strong></a>

There are four kinds of allocation:</p>

<p><a id="alloc.reserve-commit-loop" name="alloc.reserve-commit-loop"><strong>.alloc.reserve-commit-loop:</strong></a>

Two-phase allocations with looping.</p>

<p><a id="alloc.reserve-commit-linear" name="alloc.reserve-commit-linear"><strong>.alloc.reserve-commit-linear:</strong></a>

Two-phase allocations that are always successful.</p>

<p><a id="alloc.one-phase" name="alloc.one-phase"><strong>.alloc.one-phase:</strong></a>

One-phase allocations -- Reserve and Commit are done at the same time
(see below).</p>

<p><a id="alloc.promise" name="alloc.promise"><strong>.alloc.promise:</strong></a>

Promises -- you can ask for a certain amount of memory.  This type of
allocation only deals with Limit (see below).</p>

<p><a id="alloc.class-dependent" name="alloc.class-dependent"><strong>.alloc.class-dependent:</strong></a>

The pool classes you are using determine which allocation protocols
you can use; some pool classes require certain allocation protocols.</p>

<p><a id="alloc.speed" name="alloc.speed"><strong>.alloc.speed:</strong></a>

In general allocation using APs is intended to be fast.  This is
achieved by:</p>

<p><a id="alloc.lock-free" name="alloc.lock-free"><strong>.alloc.lock-free:</strong></a>

By avoiding locking synchronization.</p>

<p><a id="alloc.inline" name="alloc.inline"><strong>.alloc.inline:</strong></a>

By avoiding function calls.</p>


<h2><a id="section-7" name="section-7">7. Reserve/Commit</a></h2>

<p><a id="reserve-commit" name="reserve-commit"><strong>.reserve-commit:</strong></a>

This part of the document describes the reserve/commit protocol.</p>


<h3><a id="section-7.1" name="section-7.1">7.1. Pseudo Code</a></h3>

<p><a id="reserve-commit.pseudo-code" name="reserve-commit.pseudo-code"><strong>.reserve-commit.pseudo-code:</strong></a>

The pseudo-code for a reserve/commit sequence on an allocation point
is as follows:</p>

<blockquote><code class="source">
do {<br />
&nbsp;&nbsp;res = mps_reserve(&amp;p, ap, size);<br />
&nbsp;&nbsp;if(res != RES_OK) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;do something;<br />
&nbsp;&nbsp;}<br />
&nbsp;&nbsp;else init(p);<br />
} while (!mps_commit (ap, p, size));<br />
</code></blockquote>

<p><a id="reserve-commit.reserve" name="reserve-commit.reserve"><strong>.reserve-commit.reserve:</strong></a>

If mps_reserve fails, the client program doesn't get the memory it
needs.  If it succeeds, the memory is allocated in a block whose
address is <code class="source">p</code>.</p>

<p><a id="reserve-commit.client-init" name="reserve-commit.client-init"><strong>.reserve-commit.client-init:</strong></a>

<code class="source">init</code> is code that you write.  The memory
has to be filled in with a correctly formatted object (the
interpretation of "correctly formatted" will depend on the pool class
used).</p>

<p><a id="reserve-commit.commit" name="reserve-commit.commit"><strong>.reserve-commit.commit:</strong></a>

After initialization, you can do the commit.  The pool needs to know
that the object has been initialized, and the commit informs the pool
that the object is ready.  If the commit fails, which should be rare
(some pool classes may be able to guarantee that it never happens),
the memory is not allocated and you have to start from scratch.  The
code returns <code class="source">TRUE</code> if okay, <code
class="source">FALSE</code> if it fails.</p>


<h3><a id="section-7.2" name="section-7.2">7.2. Pool Class Dependencies</a></h3>

<p><a id="reserve-commit.pool-class.format" name="reserve-commit.pool-class.format"><strong>.reserve-commit.pool-class.format:</strong></a>

The initialization phase of reserve/commit depends on the format of
the object being allocated.  Some pool classes may not be formatted
(perhaps the objects have no references or are scanned ambiguously).
In this case the reserve and the commit can be done at the same
time.</p>

<p><a id="reserve-commit.pool-class.commit" name="reserve-commit.pool-class.commit"><strong>.reserve-commit.pool-class.commit:</strong></a>

Some pool classes occasionally need to have the commit fail; other
pool classes may be able to guarantee that commit will never fail.
This is mainly to synchronize with the garbage collector and will
happen at most once per collection cycle; there are other reasons for
failing commit, but this will happen very rarely.</p>


<h3><a id="section-7.3" name="section-7.3">7.3. Implementation Details</a></h3>

<p><a id="reserve-commit.details" name="reserve-commit.details"><strong>.reserve-commit.details:</strong></a>

A chunk of memory is passed to the client application, which can
allocate it using the protocol.</p>

<p>Doing a reserve increments Alloc (but not past Limit).</p>

<p><a id="reserve-commit.reserve.code" name="reserve-commit.reserve.code"><strong>.reserve-commit.reserve.code:</strong></a>

Reserve:</p>

<blockquote><code class="source">
&nbsp;&nbsp;T = Alloc + size;<br />
&nbsp;&nbsp;if(T &gt; Limit || T &lt;= Alloc)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* overflow check */ <br />
&nbsp;&nbsp;&nbsp;&nbsp;res = mps_ap_fill(&amp;p, ap, size);&nbsp;&nbsp;&nbsp;&nbsp;/* ask MM to give you a */<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* bigger chunk of memory */ <br />
&nbsp;&nbsp;else {<br />
&nbsp;&nbsp;&nbsp;&nbsp;Alloc = T;<br />
&nbsp;&nbsp;&nbsp;&nbsp;p = Init;<br />
&nbsp;&nbsp;&nbsp;&nbsp;res = OK;<br />
&nbsp;&nbsp;}<br />
</code></blockquote>

<p>Then the client initializes the memory, then commits it:</p>

<p><a id="reserve-commit.commit.code" name="reserve-commit.commit.code"><strong>.reserve-commit.commit.code:</strong></a>

Commit:</p>

<blockquote><code class="source">
&nbsp;&nbsp;Init = Alloc;<br />
&nbsp;&nbsp;if(Limit == 0)<br />
&nbsp;&nbsp;&nbsp;&nbsp;b = mps_ap_trip(ap, &amp;p, size);&nbsp;&nbsp;&nbsp;/* calls MM */ <br />
&nbsp;&nbsp;else<br />
&nbsp;&nbsp;&nbsp;&nbsp;b = TRUE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* b = boolean result */<br />
</code></blockquote>

<p><a id="reserve-commit.check.limit" name="reserve-commit.check.limit"><strong>.reserve-commit.check.limit:</strong></a>

The MPS can poke Limit to 0 whenever necessary in order to regain
control, so the commit code has to check that the MPS has not done
this between the reserve phase and the commit phase.  Whenever the MM
is invoked, it can do whatever it needs to, so the client cannot
assume that the values of any of the AP's fields will stay the
same.</p>

<p>Outside invocations of the MM, Alloc and Init will not change
unless the client application changes them.  However, Limit can change
at any point.  The client application is not allowed to change Limit;
it can change Alloc and Init as long as it follows the protocol.</p>

<p><a id="reserve-commit.atomic" name="reserve-commit.atomic"><strong>.reserve-commit.atomic:</strong></a>

The updates (writes) and reads of Alloc and Init have to be atomic
with respect to threads.  This means that the client application must
read the whole field at once (one instruction in machine code).</p>


<h3><a id="section-7.4" name="section-7.4">7.4. Macros and Functions</a></h3>

<p><a id="reserve-commit.c" name="reserve-commit.c"><strong>.reserve-commit.c:</strong></a>

The reserve/commit protocol is provided through the MPS C interface by the functions:</p>

<ul>

<li><code class="source">mps_reserve</code></li>

<li><code class="source">mps_commit</code></li>

</ul>

<p>and macros:</p>

<ul>

<li><code class="source">MPS_RESERVE</code></li>

<li><code class="source">MPS_COMMIT</code></li>

<li><code class="source">MPS_RESERVE_BLOCK</code></li>

</ul>

<p><a id="reserve-commit.c.macro.side-effects" name="reserve-commit.c.macro.side-effects"><strong>.reserve-commit.c.macro.side-effects:</strong></a>

The difference between macros and functions is that macros may
evaluate their arguments more than once.  For example, the macro <code
class="source">MPS_RESERVE(&amp;p, ap, size++)</code> expands into
code that may contain <code class="source">size++</code> in more than
one location, causing the compiler to evaluate it more than once.
Therefore, you should not use side effects in macros.</p>

<p><a id="reserve-commit.macro.warning.l-values" name="reserve-commit.macro.warning.l-values"><strong>.reserve-commit.macro.warning.l-values:</strong></a>

In the block macro <code class="source">MPS_RESERVE_BLOCK(res_var,
ptr_var, ap, size)</code>, the variables have to be l-values -- that
is, things that values can be assigned to -- because the compiler
handles variables better than pointers.</p>


<h2><a id="section-8" name="section-8">8. Stack Discipline</a></h2>


<h3><a id="section-8.1" name="section-8.1">8.1. Overview</a></h3>

<p><a id="stack" name="stack"><strong>.stack:</strong></a>

This part of the document describes the stack discipline protocol.</p>

<p><a id="stack.what" name="stack.what"><strong>.stack.what:</strong></a>

Stack discipline is a means by which object lifetimes can be declared
to observe a stack-like behavior.  By stack-like behavior we mean that
if a particular object is dead then all objects allocated since that
object are dead as well (so one can imagine managing the objects using
a stack).  In fact the protocol can be less strict about the liveness
of the objects; it can be used to mean that all the objects allocated
since a particular object are <em>likely</em> to be dead rather than
actually are dead.  Which of these two interpretations is used depends
on the pool class involved.</p>


<h3><a id="section-8.2" name="section-8.2">8.2. Detail</a></h3>

<p><a id="stack.frames" name="stack.frames"><strong>.stack.frames:</strong></a>

All APs have a stack of frames associated with them (if the functions
used in this protocol are not used then it isn't necessary to consider
this stack of frames).

<a id="stack.frames.inde" name="stack.frames.inde"><strong>.stack.frames.inde:</strong></a>

The stacks belonging to each AP are independent of each other.

<a id="stack.frames.order" name="stack.frames.order"><strong>.stack.frames.order:</strong></a>

The frames in a stack are arranged in a partial order with a
parent/child relationship (the stack frames form a tree).</p>

<p><a id="stack.frame.what" name="stack.frame.what"><strong>.stack.frame.what:</strong></a>

A frame is used to group a set of objects together.  The ordering of
frames (see <a href="#stack.frames.order">.stack.frames.order</a>) provides a larger grouping.

<a id="stack.frame.why" name="stack.frame.why"><strong>.stack.frame.why:</strong></a>

 The chief purpose of frames is so that a set of objects can be
 declared dead at once (so it provides a kind of mass free interface).</p>

<p><a id="stack.frame.current" name="stack.frame.current"><strong>.stack.frame.current:</strong></a>

Every AP has a current frame.

<a id="stack.frame.current.top" name="stack.frame.current.top"><strong>.stack.frame.current.top:</strong></a>

Some pool classes may restrict the current frame to be the (unique)
frame with no child (see the push operation below, <a href="#stack.frame.push">.stack.frame.push</a>),
in this case the stack frames form a linear order.

<a id="stack.frame.current.any" name="stack.frame.current.any"><strong>.stack.frame.current.any:</strong></a>

Other pool classes may allow the current frame to be selected from any
of the frames in the stack.

<a id="stack.frame.alloc" name="stack.frame.alloc"><strong>.stack.frame.alloc:</strong></a>

Objects that are allocated in an AP are allocated in the current
frame.</p>

<p><a id="stack.frame.init" name="stack.frame.init"><strong>.stack.frame.init:</strong></a>

Initially, when APs are created they have a single frame; it is the
current frame; this frame cannot be popped (see below).</p>

<p><a id="stack.frame.push" name="stack.frame.push"><strong>.stack.frame.push:</strong></a>

Stack frames are created and linked into the ordered tree with a push
operation.  This create a new frame and makes it a child of the
current frame; the newly created frame becomes the current frame (Note
that as observed above, <a
href="#stack.frame.current.top">.stack.frame.current.top</a>, if the
current frame always has no children then a linear ordering of the
frames is formed.)  The previously current frame is still valid and
its objects are still alive.</p>

<p><a id="stack.frame.pop" name="stack.frame.pop"><strong>.stack.frame.pop:</strong></a>

The pop operation pops the stack back to a specified frame.  The
parent of the specified frame becomes the current frame.  The fate of
the specified frame and all its descendents (i.e., its children and
all their children transitively) depends on the pool class.  In some
pool classes, all those frames and their contained objects are dead
and their storage space may be reclaimed.  In other pool classes, the
contained objects are "mostly dead" (likely to be good candidates for
garbage collection).  Consult the pool class documentation for
details.</p>


<h3><a id="section-8.3" name="section-8.3">8.3. Implementation</a></h3>

<p><a id="stack.c" name="stack.c"><strong>.stack.c:</strong></a>

 The push and pop operations are provided in the MPS C interface in
 the form of the functions:</p>

<ul>

<li><code class="source">mps_ap_frame_push</code></li>

<li><code class="source">mps_ap_frame_pop</code></li>

</ul>


<h2><a id="section-9" name="section-9">9. Summary of Restrictions</a></h2>

<ul>

<li>You have to initialize memory if you are using formatted pool
classes.</li>

<li>You cannot assume that the values of Alloc and Init will remain
the same if you invoke the MM.</li>

<li>You cannot assume that the value of Limit will ever remain the
same; you have to check it before using it.</li>

<li>You cannot change the value of Limit yourself.</li>

</ul>



<h2><a id="section-10" name="section-10">10. Notes</a></h2>

<p><a id="decision" name="decision"><strong>.decision:</strong></a>

Some constraints can be relaxed depending on the environment in which
the MPS is being used.  In particular, in a single-threaded system,
you can do just about anything as long as you don't invoke the MPS.</p>

<p><a id="mem-barriers" name="mem-barriers"><strong>.mem-barriers:</strong></a>

On some multiprocessor systems (say, DEC Alpha), memory reads and
writes can get reordered and so appear out of order on another
processor (a.k.a. "Relaxed Memory Ordering" or "Weak Memory
Ordering"), so we need to use "memory barriers" that ensure that the
code is executed with enough order to guarantee the invariants.  This
is not shown in this document yet.</p>

<h2><a id="section-A" name="section-A">A. References</a></h2>


<h2><a id="section-B" name="section-B">B. Document History</a></h2>

<table>

<tr valign="top">

<td>1997-06-10 15:59:47</td>

  <td>lmb</td>

  <td>Created</td>

</tr>

<tr valign="top">

  <td>1997-06-10 to 2000-07-09</td>

  <td />

  <td>Developed at Harlequin.</td>

</tr>

<tr valign="top">

  <td>2001-09-26</td>

  <td><a href="mailto:ndl@ravenbrook.com">NDL</a></td>

  <td>Converted from xml to html (second pass).</td>

</tr>

<tr valign="top">

  <td>2001-11-15</td>

  <td><a href="mailto:nb@ravenbrook.com">NB</a></td>

  <td>reformatted and adopted.</td>

</tr>

</table>

<hr />

<p><small>Copyright &copy; 2001 Ravenbrook Limited.  This document is
provided "as is", without any express or implied warranty.  In no
event will the authors be held liable for any damages arising from the
use of this document.  You may not duplicate or reproduce this
document in any form without the express permission of the copyright
holder.</small></p>

<div align="center">

<p><code>$Id$</code></p>

</div>

</body>

</html>

