<?xml version="1.0" encoding="UTF-8"?>



<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">



 <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>

  <head>

   <title>MPS Root Protocol</title>

  </head>

  <body bgcolor='#FFFFFF' text='#000000' link='#000099' vlink='#660066' alink='#FF0000'>

   <div align='center'>

    <h1>MPS Root Protocol</h1>

    <p>incomplete</p>

    <address>pekka, 1997-09-22</address>

   </div>

   <h2>

    <a id='section-introduction' name='section-introduction'>Introduction</a>

   </h2>

   <p>

    <strong>.intro.doc:</strong>

     This document describes the MPS root protocol.  This is used to tell the garbage collector where to start tracing.  The protocol gives the client application a high degree of freedom in how organize its static data and references between static and dynamic data.

   </p>

   <h2>

    <a id='section-overview' name='section-overview'>Overview</a>

   </h2>

   <p>

    <strong>.over.gc:</strong>

     We'd like garbage collection to keep only live objects and reclaim all the dead ones.  However, it is theoretically impossible for the GC to determine which objects are live and which are dead.  Instead, the GC determines which objects are reachable from _the roots_, and reclaims the unreachable ones.  This is quite efficient and can be a very good approximation to liveness.

   </p>

   <p>

    <strong>.over.root:</strong>

     Note that it is important the roots contain everything that the program can directly refer to, otherwise the GC might recycle an object that would be used in the future.  Some GCs, like Boehm's, assume that all static data are roots; the MPS allows the programmer to declare which objects are roots.  If you're using an automatically managed pool class, then you've got to declare roots.

   </p>

   <p>

    <strong>.root.reg:</strong>

     In one sense, the only roots are registers; that is, a program can only use values that can be referenced from the registers.

   </p>

   <p>

    <strong>.root.reg.prob:</strong>

     This is the logical way of thinking about the problem; however, the practice is much more tricky.  For example, it requires complete knowledge of the layout of static data.  Another difficulty is that a multi-threaded program has multiple sets of registers that the OS kernel keeps track of, and that the GC, running as a user program, can't access.

   </p>

   <p>

    <strong>.root.specify:</strong>

     It isn't possible to do this in practice; the client program has to tell the GC what the roots are, and to be conservative in determining them.

   </p>

   <p>

    <strong>.root.stack:</strong>

     The MPS assumes nothing about stacks being roots.  The client has to create a root from the stack, if necessary.

    <strong>.root.var:</strong>

     Global variables that might refer to automatically managed objects must be declared to the MPS.  

    <strong>.root.other:</strong>

     There might be other roots, as well.

   </p>

   <h2>

    <a id='section-declaring-roots' name='section-declaring-roots'>Declaring Roots</a>

   </h2>

   <p>

    <strong>.declare:</strong>

     You can declare a root at any 

    time.

      Roots may not be declared twice, and no two roots may overlap.

      You must not declare an object that could get GCed to be a root.  Everything in a root is of the same rank (like in an object).  Declaring a root creates a root object that the MPS uses to keep track of the root.

   </p>

   <p>

    <strong>.modes:</strong>

     Roots have modes that are set when declaring the root; these are additional information about the behaviour of the root.

   </p>

   <p>

    <strong>.remove:</strong>

     Roots can be removed at any time by passing the root object to 

    <code>mps_root_destroy</code>

    .  All roots must be destroyed before the arena is destroyed.

   </p>

   <p>

    <strong>.valid:</strong>

    If the rank of the root is not ambiguous, the contents of the root have to be valid whenever a GC happens

    , i.e., they have to be references to actual objects or null pointers

    .  If you're using asynchronous GC, this could be right after the root is registered, so the root has to be valid when it is 

    registered

    .  

    It's OK for a root to have entries which point to

     memory not 

    managed by the MPS -- they will simply be ignored.

   </p>

   <p>

    <strong>.kind:</strong>

     You can declare roots in four different ways:

   </p>

   <p>

    <strong>.kind.table:</strong>

    <code>mps_root_create_table</code>

     &amp;

    <pre> mps_root_create_table</pre>

    _

    <code>masked</code>

    declare a root that is a vector of pointers somewhere in memory.

   </p>

   <p>

    <strong>.kind.reg:</strong>

    Threads are declared roots using 

    <code>mps_root_create_reg</code>

    .  

    <code>mps_stack_scan_ambig</code>

     is the only supported scanning function

    : it will scan every word on the stack and in the (integer) registers

    .  It's OS- and architecture-dependent (and possibly compiler-dependent).  MM provide it, 'cos it's hard to write and hard to specify an interface for it.

   </p>

   <p>

    <strong>.kind.format:</strong>

    <code>mps_root_create_fmt</code>

    declares a root that is 

    a block of formatted objects.

   </p>

   <p>

    <strong>.kind.general:</strong>

    <code>mps_root_create</code>

    declares a root that consists of all the references indicated by a scanning function that you supply.

   </p>

   <h2>

    <a id='section-notes-on-optimizing-compilers' name='section-notes-on-optimizing-compilers'>Notes On Optimizing Compilers</a>

   </h2>

   <p>

    <strong>.optimizing.problem:</strong>

     Optimizing compilers might optimize stores away, so that references that have notionally been stored, in fact only exist in the thread state.  Registering the thread will ensure these will be scanned.

   </p>

   <p>

    <strong>.optimizing.no-stack:</strong>

     It's not always necessary to register every thread.  For example, in C, if you take the address of a variable then the compiler is constrained to keep the variable up to date under certain circumstances.  However, you have to be _very_ careful.  If you're using incremental GC, then the MPS might look at things when the compiler didn't expect, and things will go wrong.  When using incremental GC, you almost certainly must declare thread state as a root.

   </p>

   <p>

    <strong>.non-incremental:</strong>

     Non-incremental GC will occur during a function call to the MM (e.g. on request, or during allocation, etc.).  So C knows to store things in addressed variables during those calls, so you can deal with it.

   </p>

   <p>

    <strong>.virtual-machine:</strong>

     For example, a common C virtual machine declares a stack-within-stack of roots.  e.g.,

   </p>

   <p>

      struct stack_frame {val *next, locals[N];};

    <br />

      struct stack_frame *sp;

   </p>

   <p>

      main()

    <br />

      {

    <br />

        ...

    <br />

        mps_root_create_table(..., &amp;sp);

    <br />

        ...

  }

   </p>

   <p>

      foo(...)

    <br />

      {

    <br />

        struct stack_frame frame;

    <br />

        frame.next = sp;

    <br />

        sp = &amp;frame;

    /* Do stuff using locals.  A GC can safely happen because sp points

    <br />

         * at frame, so the compiler must write local values back to the frame

     * before any side-effect can happen.

   </p>

   <p>

         */

    <br />

        sp = frame.next;

    <br />

      }

   </p>

   <p>This sort of thing is safe, so you can do without scanning the real processor state.  You only need the VM state.  This isn't terribly good for ordinary programming, but is fine for a virtual machine which is the output of a compiler, for example.  In ordinary programming, you'll want to include the processor state for convenience.  It helps the compiler optimise, and it's necessary for asynchronous MM operation, such as incremental GC.</p>

   <h2>

    <a id='section-A' name='section-A'>A. References</a>

   </h2>

   <h2>

    <a id='section-B' name='section-B'>B. Document History</a>

   </h2>

   <table>

    <tr valign='top'>

     <td>1997-09-22 13:50:24 +01</td>

     <td>pekka</td>

     <td>New document saved</td>

    </tr>

    <tr valign='top'>

     <td>1997-09-22 14:14:07 +01</td>

     <td>pekka</td>

     <td>Describe reg roots</td>

    </tr>

    <tr valign='top'>

     <td>1998-01-21 17:52:19 +00</td>

     <td>pekka</td>

     <td>Described root kinds; improved introduction</td>

    </tr>

    <tr valign='top'>

     <td>1998-01-23 13:50:52 +00</td>

     <td>pekka</td>

     <td>some small improvements</td>

    </tr>

    <tr valign='top'>

     <td>1998-01-26 17:28:22 +00</td>

     <td>pekka</td>

     <td>Add validity criterion</td>

    </tr>

    <tr valign='top'>

     <td>1998-01-27 17:49:33 +00</td>

     <td>pekka</td>

     <td>One more restriction</td>

    </tr>

    <tr valign='top'>

     <td>2000-05-22 16:10:35 +01</td>

     <td>pekka</td>

     <td>clean up</td>

    </tr>

    <tr valign='top'>

     <td>2001-09-26</td>

     <td>

      <a href='mailto:ndl@ravenbrook.com'>NDL</a>

     </td>

     <td>Converted from xml to html (second pass).</td>

    </tr>

   </table>

   <hr />

   <p>

    <small>Copyright &copy; 2001 Ravenbrook Limited.  This document is provided "as is", without any express or implied warranty.  In no event will the authors be held liable for any damages arising from the use of this document.  You may not duplicate or reproduce this document in any form without the express permission of the copyright holder.</small>

   </p>

   <div align='center'>

    <p>

     <code>$Id$</code>

    </p>

   </div>

  </body>

 </html>

