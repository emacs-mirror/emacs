<?xml version="1.0" encoding="UTF-8"?>



<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">



 <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>

  <head>

   <title>A guide to MPS pool classes and their properties</title>

  </head>

  <body bgcolor='#FFFFFF' text='#000000' link='#000099' vlink='#660066' alink='#FF0000'>

   <div align='center'>

    <h1>A guide to MPS pool classes and their properties</h1>

    <p>draft</p>

    <address>rit, 1998-07-01</address>

   </div>

   <p>

    <strong>.purpose:</strong>

     This document is intended to enable you to answer questions like: "Does MV move objects around?" and "Does AMCZ support interior references?", and also to allow you to pick the right pool classes to use in your programs.  It addresses the functional differences between pool classes, without dealing with questions of performance.  It also defines some terminology for properties of references, objects and pools, which may be useful in discussing memory management and the MPS in particular.

   </p>

   <p>

    <strong>.readership:</strong>

     Any MM developer or user within Harlequin.

   </p>

   <p>

    <strong>.structure:</strong>

     First we state some properties that references, objects and pools might have.  There follows a big table of pool classes and their properties.

   </p>

   <p>

    <strong>.convention.definitions:</strong>

     Words and phrases being defined appear in double quotation marks.

   </p>

   <p>

    <strong>.caveat:</strong>

     In some cases, there is no appropriate documentation of the behaviour of pool classes.  Therefore it is not always possible to distinguish between behaviour which was specified for a pool class and behaviour which is present but was not intended to be part of the specification.

   </p>

   <p>

    <strong>.hist.0:</strong>

     rit wrote version 0 based on his understanding of the MPS pool classes at the time.

   </p>

   <p>

    <strong>.hist.1:</strong>

     updated following comments from drj and pekka. rit 1998-08-24

   </p>

   <p>

    <strong>.hist.2:</strong>

     added table column for MVFF pool class. rit 1998-10-14

   </p>

   <h2>

    <a id='section-properties-of-references' name='section-properties-of-references'>Properties Of References</a>

   </h2>

   <p>These properties apply to references in non-leaf objects (.prop.obj.non-leaf), and to references in roots. I have arranged them in pairs; exactly one of the properties in each pair applies to any reference.</p>

   <p>

    <strong>.prop.ref.containment:</strong>

     An object or root is said to "contain" a reference if scanning the object or root causes that reference to be fixed.

   </p>

   <p>

    <strong>.prop.ref.real:</strong>

     A "real reference" is one that points to an object.

    <br />

    <strong>.prop.ref.ambiguous:</strong>

     An "ambiguous reference" is one that may be interpreted either as a reference to an object, or as other data.

   </p>

   <p>

    <strong>

     .prop

     .ref.strong:

    </strong>

     A "strong reference" keeps the object it refers to alive (unless it is explicitly discarded for some other reason).

    <br />

    <strong>

     .prop

     .ref.weak:

    </strong>

     A "weak reference does" not keep the object it refers to alive. If the object is discarded, the reference will be splatted. "splatting" is removing the reference; in the mps, by changing it to NULL. Note that there may be various different kinds of weak references, depending on their interaction with finalisation -- see .prop.rank.weak below.

   </p>

   <p>

    <strong>

     .prop

     .ref.fixed:

    </strong>

     A "fixed reference" may not be updated by the collector, except by splatting if the reference is weak (.prop.ref.weak).

    <br />

    <strong>

     .prop

     .ref.moving:

    </strong>

     A "moving reference" may be updated by the collector. This means the collector has the opportunity to move the object referred to.

   </p>

   <p>

    <strong>

     .prop

     .ref.immutable:

    </strong>

     An "immutable reference" is one the client guarantees not to change.

    <br />

    <strong>

     .prop

     .ref.mutable:

    </strong>

     A "mutable reference" is one the client may change when it likes.

   </p>

   <p>

    <strong>.implications.prop.ref:</strong>

     Because it would be dangerous for the collector to change something which wasn't really a reference, ambiguous references (.prop.ref.ambiguous) must be both fixed (.prop.ref.fixed) and strong (.prop.ref.strong).

   </p>

   <h2>

    <a id='section-ranks' name='section-ranks'>Ranks</a>

   </h2>

   <p>At present, the mps understands only the following types of reference, known as ranks:</p>

   <p>

    <strong>

     .prop

     .rank.exact:

    </strong>

    References of rank mps_rank_exact are real, strong and moving (.prop

    .ref.{real, 

    strong, 

    moving

    }).

    <br />

    <strong>

     .prop

     .rank.ambiguous:

    </strong>

    References of rank mps_rank_ambiguous are ambiguous, strong and fixed (.prop

    .ref.{ambiguous, 

    strong, 

    fixed

    }).

    <br />

    <strong>

     .prop

     .rank.weak:

    </strong>

     References of rank mps_rank_weak are real, weak and moving (

    .prop

    .ref.

    {real, weak,

     moving

    }). This rank is "weak-after-final", i.e. a weak reference to an object which would have died but was registered for finalisation, will not be splatted until the object subsequently dies.

   </p>

   <p>For references in roots, the client may specify whether they are mutable (.prop.ref.mutable) or immutable (.prop.ref.immutable).</p>

   <p>All references in objects are mutable (.prop.ref.mutable), but subject to the constraint that the reference will not change without the client writing to the object/root that contains it. This is because write-barriers are used to maintain remembered sets. The EPVM pool class is an exception to this rule: see .prop.pool.remote-references below.</p>

   <p>Note to developers: mps_rank_final is not usable by mps clients, so I haven't mentioned it. Except for just now, that is.</p>

   <h2>

    <a id='section-properties-of-objects' name='section-properties-of-objects'>Properties Of Objects</a>

   </h2>

   <p>

    <strong>.prop.obj.leaf:</strong>

     A "leaf object" is one that does not (and can not) contain references.

   </p>

   <p>

    <strong>.prop.obj.non-leaf:</strong>

     A "non-leaf object" is one that may contain references.

    <br />

   </p>

   <p>

    <strong>

     .prop

     .obj.collected:

    </strong>

     A "collected object" is one that may be automatically discarded when the collector determines it is no longer needed.

    <br />

    <strong>

     .prop

     .obj.manual:

    </strong>

     A "manually-managed" object is one that should be discarded when the client explicitly says so. Any object allocated by the MPS can be discarded by calling mps_pool_destroy, but we don't consider an object to have .prop.obj.manual unless there is some more specific way of discarding it. (Note that .obj.collect and .obj.manual are _not_ mutually exclusive.)

   </p>

   <p>

    <strong>

     .prop

     .obj.base-ref:

    </strong>

     An object "supports base references only" if only a reference to the base of the object is considered to be a reference to the object.

    <br />

    <strong>.prop</strong>

    .

    <strong>obj.internal-ref:</strong>

     An object "supports internal references" if a reference to any byte within the object is considered to be a reference to the object.

   </p>

   <p>

    <strong>

     .prop

     .obj.no-protect:

    </strong>

     An "unprotectable object" is one that the collector promises not to place a read or write barrier on.

    <br />

    <strong>

     .prop

     .obj.protect:

    </strong>

     A "protectable object" is one that the collector may place a read or write barrier on.

   </p>

   <p>

    <strong>

     .prop

     .obj.no-move:

    </strong>

     A "non-movable object" is one that the collector will not move.

    <br />

    <strong>

     .prop

     .obj.move:

    </strong>

     A "movable object" is one that the collector may move.

   </p>

   <p>

    <strong>

     .prop

     .obj.finalize:

    </strong>

     A "finalizable object" is one that the client may later register for finalisation. [At present, this applies only to collected objects (.prop.obj.collected.)]

   </p>

   <p>

    <strong>

     .prop

     .obj.formatted:

    </strong>

     At the moment, objects are formatted if and only if they have either of 

    .prop

    .obj.scanned or 

    .prop

    .obj.collected. This is a coincidence, and indeed the possibility of an unformatted but collected pool has been raised (see mail.tony.1998-06-30.17-20(0)).

   </p>

   <h2>

    <a id='section-pool-and-pool-class-properties' name='section-pool-and-pool-class-properties'>Pool And Pool Class Properties</a>

   </h2>

   <p>Allocation and freeing</p>

   <p>

    <strong>

     .prop

     .pool.alloc:

    </strong>

     A pool "with alloc" supports an interface for allocating individual objects (mps_alloc in the MPS).

    <br />

    <strong>

     .prop

     .pool.free:

    </strong>

     A pool "with free" supports an interface for discarding individual objects.

    <br />

    <strong>

     .prop

     .pool.buffered-alloc:

    </strong>

     A "buffered pool" supports allocation using allocation points.

    <br />

    <strong>

     .prop

     .pool.save-restore:

    </strong>

     A "save-restore pool" supports "save" and "restore" operations for allocating and discarding nested sets of objects.

   </p>

   <p>Collection</p>

   <p>

    <strong>

     .prop

     .pool.collection.auto:

    </strong>

     An "automatically-collected pool" is one where garbage collection is under the control of the collector, which decides when collection should take place and performs it automatically and incrementally.

    <br />

    <strong>

     .prop

     .pool.collection.demand:

    </strong>

     A "demand-collected pool" is one where garbage collection takes place when the client explicitly requests it.

   </p>

   <p>

    <strong>.question.combine.prop.pool.collection:</strong>

     How well can the two of these be combined in the same mps? Consequences for read and write barriers? This is an important question, considering the differences between product.dylan and product.epcore.

   </p>

   <p>

    <strong>.question.prop.pool.collection.incremental:</strong>

     Should there be a separate pool property for being incrementally collected? At the moment, all MPS-originated collection is incremental and all client-requested collection is non-incremental, irrespective of the pools involved, but perhaps this might become a pool property in the future.

   </p>

   <p>Size and alignment</p>

   <p>

    <strong>

     .prop

     .pool.alignment.fixed:

    </strong>

     A "fixed-alignment pool class" has a fixed object alignment.

    <br />

    <strong>

     .prop

     .pool.alignment.config:

    </strong>

     A "configurable-alignment pool" class allows the client to specify alignment for each pool.

    <br />

    <strong>

     .prop

     .pool.alignment.variable:

    </strong>

     A "variable-alignment pool class" allows the client to specify alignment for each object.

    <br />

    <strong>

     .prop

     .pool.size.fixed:

    </strong>

     A "fixed-size pool class" has a fixed object size.

    <br />

    <strong>

     .prop

     .pool.size.config:

    </strong>

     A "configurable-size pool class" allows the client to specify an object size for each pool.

    <br />

    <strong>

     .prop

     .pool.size.variable:

    </strong>

     A "variable-size pool class" allows the client to specify a size for each object.

   </p>

   <p>Special Powers</p>

   <p>

    <strong>

     .prop

     .pool.assoc-object:

    </strong>

     Each object in an "associated-object pool" can specify an associated object which the mutator guarantees will be accessible during scanning of the first object. (Applies to the AWL pool class, where is it used to help Dylan manage weak hash tables.)

   </p>

   <p>

    <strong>

     .prop

     .pool.remote-references:

    </strong>

     The references contained in an object in a "remote-references pool" need not be stored directly in the object itself. Therefore, the collector may not rely on write-barriers to detect changing references. (Applies to the EPVM pool class

    , where it is used to help support the ScriptWorks object format.

    )

   </p>

   <p>

    <strong>

     .prop

     .pool.ambiguous.not-supported:

    </strong>

     If a pool "does not support ambiguous references", then ambiguous references which could otherwise be interpreted as references to objects in that pool will not be so interpreted. i.e. they will be ignored, and will not keep objects alive. (Applies to the EPVM pool class.)

   </p>

   <h2>

    <a id='section-general-issues' name='section-general-issues'>General Issues</a>

   </h2>

   <p>

    <strong>.issue.endian:</strong>

     Properties like "whether ref must be to base of object" can perhaps be specified both as properties of a reference _from_ a specific reference and _to_ a specific object. For example: AMC doesn't allow weak references out of it. EPVM doesn't allow ambiguous references into it. (Why this is, I have no idea.) For most types of properties, the MPS design has made a choice: either it's a property at the _from_ end or at the _to_ end. (E.g., base/middle is at the _to_ end, rank is (usually) at the _from_ end. Format, of course, is always at the _from_ end.)

   </p>

   <h2>

    <a id='section-a-table-of-pool-classes-and-their-properties' name='section-a-table-of-pool-classes-and-their-properties'>A Table Of Pool Classes And Their Properties</a>

   </h2>

   <p>

    <strong>.table.pool-classes:</strong>

     In the following table, a "yes" for an object property means (unless otherwise indicated) that that property holds for _all_ objects in the pool. A "yes" for a rank means that the pool allows objects containing references of that rank. Gaps in the table indicate properties that aren't applicable: for example is it silly to ask whether a pool which doesn't have .prop.obj.scanned has .prop.rank.weak.

   </p>

   <p>Name of pool class:            AMC    AMCZ   AWL    LO     EPVM   MV     MV2    EPDL/R MVFF</p>

   <p>

    .prop

    .pool.alloc               no     no     no     no     no     yes    no     yes    yes

   </p>

   <p>

    .prop

    .pool.free                no     no     no     no     no     yes    yes    yes    yes

   </p>

   <p>

    .prop

    .pool.buffered-alloc      yes    yes    yes    yes    yes    no     yes    no     no

   </p>

   <p>

    .prop

    .pool.save-restore        no     no     no     no     yes    no     no     no     no

   </p>

   <p>

    .prop

    .obj.collected            yes    yes    yes    yes    yes    no     no     no     no

   </p>

   <p>

    .prop

    .obj.manual               no     no     no     no     yes(1) yes    yes    yes    yes

   </p>

   <p>

    .prop

    .pool.collection          auto   auto   auto   auto   manual

   </p>

   <p>

    .prop

    .obj.non-leaf             yes    no     yes    no     (2)    no     no     no     no

   </p>

   <p>.prop.rank.exact               yes           yes           yes</p>

   <p>

    .prop

    .rank.ambiguous           no            no            no

   </p>

   <p>

    .prop

    .rank.weak                no            yes           no

   </p>

   <p>

    .prop

    .obj.base-ref             yes    yes    yes    yes    yes(2)

   </p>

   <p>

    .prop

    .obj.internal-ref         no     no     no     no     yes(2)

   </p>

   <p>

    .prop

    .obj.protect              yes    no     yes    no     no     no     no     no     no

   </p>

   <p>

    .prop

    .obj.move                 yes    yes    no     no     no     no     no     no     no

   </p>

   <p>

    .prop

    .obj.finalize             yes    yes    yes    yes    no(3)  no     no     no     no

   </p>

   <p>

    .prop

    .obj.formatted            yes    yes    yes    yes    yes    no     no     no     no

   </p>

   <p>

    .prop

    .pool.size                var    var    var    var    8      var    var    var    var

   </p>

   <p>

    .prop

    .pool.alignment           config config config config 8      (4)    (4)    config config(5)

   </p>

   <p>

    .prop

    .pool.assoc-object        no            yes           no

   </p>

   <p>

    .prop

    .pool.remote-references   no            no            yes

   </p>

   <p>

    .prop

    .pool.ambiguous-          no     no     no     no     yes

   </p>

   <p> not-supported</p>

   <p>Notes:</p>

   <p>(1) because EPVM pools are save-restore pools (.prop.pool.save-restore).</p>

   <p>

    (2) EPVM pools can allocate two distinct types of object: one type is non-leaf and supports base-references only (

    .prop

    .obj.non-leaf, 

    .prop

    .obj.base-ref). The other is leaf and supports internal-references (

    .prop

    .obj.leaf

    , .prop

    .obj.internal-ref).

   </p>

   <p>(3) Finalisation of EPVM objects may be a future requirement for ScriptWorks, so this might change.</p>

   <p>(4) MV and MV2 alignment is platform dependent.</p>

   <p>(5) MVFF pools may not have alignment less than MPS_PF_ALIGN (which should be the "platform alignment").</p>

   <h2>

    <a id='section-A' name='section-A'>A. References</a>

   </h2>

   <h2>

    <a id='section-B' name='section-B'>B. Document History</a>

   </h2>

   <table>

    <tr valign='top'>

     <td>1998-07-02 11:16:54 +01</td>

     <td>rit</td>

     <td>New document saved</td>

    </tr>

    <tr valign='top'>

     <td>1998-07-23 18:20:33 +01</td>

     <td>pekka</td>

     <td>fixed readership</td>

    </tr>

    <tr valign='top'>

     <td>1998-08-24 11:54:30 +01</td>

     <td>rit</td>

     <td>updated following comments from drj and pekka</td>

    </tr>

    <tr valign='top'>

     <td>1998-10-14 12:03:10 +01</td>

     <td>rit</td>

     <td>added table column for MVFF pool class</td>

    </tr>

    <tr valign='top'>

     <td>2000-05-22 13:36:03 +01</td>

     <td>pekka</td>

     <td>change tag from guide.mps.pool-classes</td>

    </tr>

    <tr valign='top'>

     <td>2001-09-26</td>

     <td>

      <a href='mailto:ndl@ravenbrook.com'>NDL</a>

     </td>

     <td>Converted from xml to html (second pass).</td>

    </tr>

   </table>

   <hr />

   <p>

    <small>Copyright &copy; 2001 Ravenbrook Limited.  This document is provided "as is", without any express or implied warranty.  In no event will the authors be held liable for any damages arising from the use of this document.  You may not duplicate or reproduce this document in any form without the express permission of the copyright holder.</small>

   </p>

   <div align='center'>

    <p>

     <code>$Id$</code>

    </p>

   </div>

  </body>

 </html>

