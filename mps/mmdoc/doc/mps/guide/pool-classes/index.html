<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>

<title>A guide to MPS pool classes and their properties</title>

</head>

<body bgcolor="#FFFFFF" text="#000000" link="#000099" vlink="#660066" alink="#FF0000">

<div align="center">

<h1>A guide to MPS pool classes and their properties</h1>

<p>draft</p>

<address>
<a href="mailto:nb@ravenbrook.com">Nick Barnes</a>,
<a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>,
2001-11-14
</address>

</div>

<h2><a id="section-Contents" name="section-Contents">Contents</a></h2>


<ul>

<li><a href="#section-1">1. Introduction</a></li>

<li><a href="#section-2">2. Properties of References</a></li>

<li><a href="#section-3">3. Ranks</a></li>

<li><a href="#section-4">4. Properties of Objects</a></li>

<li>
  <a href="#section-5">5. Pool And Pool Class Properties</a>

  <ul>

  <li><a href="#section-5.1">5.1. Allocation and Freeing</a></li>

  <li><a href="#section-5.2">5.2. Collection</a></li>

  <li><a href="#section-5.3">5.3. Size and alignment</a></li>

  <li><a href="#section-5.4">5.4. Special powers</a></li>

  </ul>

</li>

<li><a href="#section-6">6. General Issues</a></li>

<li><a href="#section-7">7. A Table Of Pool Classes And Their Properties</a></li>

<li><a href="#section-A">A. References</a></li>

<li><a href="#section-B">B. Document history</a></li>

</ul>


<h2><a id="section-1" name="section-1">1. Introduction</a></h2>

<p><a id="purpose" name="purpose"><strong>.purpose:</strong></a> This
document is intended to enable you to answer questions like: "Does MV
move objects around?" and "Does AMCZ support interior references?",
and also to allow you to pick the right pool classes to use in your
programs.  It addresses the functional differences between pool
classes, without dealing with questions of performance.  It also
defines some terminology for properties of references, objects and
pools, which may be useful in discussing memory management and the MPS
in particular.</p>

<p><a id="readership" name="readership"><strong>.readership:</strong></a>

Any MM developer or user within Harlequin.</p>

<p><a id="structure" name="structure"><strong>.structure:</strong></a>

First we state some properties that references, objects and pools
might have.  There follows a big table of pool classes and their
properties.</p>

<p><a id="convention.definitions" name="convention.definitions"><strong>.convention.definitions:</strong></a>

Words and phrases being defined appear in double quotation marks.</p>

<p><a id="caveat" name="caveat"><strong>.caveat:</strong></a>

In some cases, there is no appropriate documentation of the behaviour
of pool classes.  Therefore it is not always possible to distinguish
between behaviour which was specified for a pool class and behaviour
which is present but was not intended to be part of the
specification. </p>

<h2> <a id="section-2" name="section-2">2. Properties Of References</a> </h2>

<p>These properties apply to references in non-leaf objects (<a
href="#prop.obj.non-leaf">.prop.obj.non-leaf</a>), and to references
in roots. I have arranged them in pairs; exactly one of the properties
in each pair applies to any reference.</p>

<p><a id="prop.ref.containment" name="prop.ref.containment"><strong>.prop.ref.containment:</strong></a>

An object or root is said to "contain" a reference if scanning the
object or root causes that reference to be fixed.</p>

<p>

<a id="prop.ref.real" name="prop.ref.real"><strong>.prop.ref.real:</strong></a>

A "real reference" is one that points to an object.</p>

<p><a id="prop.ref.ambiguous" name="prop.ref.ambiguous"><strong>.prop.ref.ambiguous:</strong></a>

An "ambiguous reference" is one that may be interpreted either as a
reference to an object, or as other data.</p>

<p><a id="prop.ref.strong" name="prop.ref.strong"><strong>.prop.ref.strong:</strong></a>

A "strong reference" keeps the object it refers to alive (unless it is
explicitly discarded for some other reason).</p>

<p><a id="prop.ref.weak" name="prop.ref.weak"><strong>.prop.ref.weak:</strong></a>

A "weak reference does" not keep the object it refers to alive. If the
object is discarded, the reference will be splatted. "splatting" is
removing the reference; in the mps, by changing it to NULL. Note that
there may be various different kinds of weak references, depending on
their interaction with finalisation -- see <a
href="#prop.rank.weak">.prop.rank.weak</a> below.</p>

<p><a id="prop.ref.fixed" name="prop.ref.fixed"><strong>.prop.ref.fixed:</strong></a>

A "fixed reference" may not be updated by the collector, except by
splatting if the reference is weak (<a
href="#prop.ref.weak">.prop.ref.weak</a>).</p>

<p><a id="prop.ref.moving" name="prop.ref.moving"><strong>.prop.ref.moving:</strong></a>

A "moving reference" may be updated by the collector. This means the
collector has the opportunity to move the object referred to.</p>

<p><a id="prop.ref.immutable" name="prop.ref.immutable"><strong>.prop.ref.immutable:</strong></a>

An "immutable reference" is one the client guarantees not to change.</p>

<p><a id="prop.ref.mutable" name="prop.ref.mutable"><strong>.prop.ref.mutable:</strong></a>

A "mutable reference" is one the client may change when it likes.</p>

<p><a id="implications.prop.ref" name="implications.prop.ref"><strong>.implications.prop.ref:</strong></a>

Because it would be dangerous for the collector to change something
which wasn't really a reference, ambiguous references
(<a href="#prop.ref.ambiguous">.prop.ref.ambiguous</a>) must be both fixed (<a href="#prop.ref.fixed">.prop.ref.fixed</a>) and strong
(<a href="#prop.ref.strong">.prop.ref.strong</a>).</p>

<h2><a id="section-3" name="section-3">3. Ranks</a></h2>

<p>At present, the mps understands only the following types of
reference, known as ranks:</p>

<p><a id="prop.rank.exact" name="prop.rank.exact"><strong>.prop.rank.exact:</strong></a>

References of rank <code class="source">mps_rank_exact</code> are
real, strong and moving (<a href="#prop.ref.real">.prop.ref.real</a>,
<a href="#prop.ref.strong">.prop.ref.strong</a>, <a
href="#prop.ref.moving">.prop.ref.moving</a>).</p>

<p><a id="prop.rank.ambiguous" name="prop.rank.ambiguous"><strong>.prop.rank.ambiguous:</strong></a>

References of rank <code class="source">mps_rank_ambiguous</code> are
ambiguous, strong and fixed (<a
href="#prop.ref.ambiguous">.prop.ref.ambiguous</a>, <a
href="#prop.ref.strong">.prop.ref.strong</a>, <a
href="#prop.ref.fixed">.prop.ref.fixed</a>).</p>

<p><a id="prop.rank.weak" name="prop.rank.weak"><strong>.prop.rank.weak:</strong></a>

References of rank <code class="source">mps_rank_weak</code> are real,
weak and moving (<a href="#prop.ref.real">.prop.ref.real</a>, <a
href="#prop.ref.weak">.prop.ref.weak</a>, <a
href="#prop.ref.moving">.prop.ref.moving</a>). This rank is
"weak-after-final", i.e. a weak reference to an object which would
have died but was registered for finalisation, will not be splatted
until the object subsequently dies.</p>

<p>For references in roots, the client may specify whether they are
mutable (<a href="#prop.ref.mutable">.prop.ref.mutable</a>) or
immutable (<a href="#prop.ref.immutable">.prop.ref.immutable</a>).</p>

<p>All references in objects are mutable (<a
href="#prop.ref.mutable">.prop.ref.mutable</a>), but subject to the
constraint that the reference will not change without the client
writing to the object/root that contains it. This is because
write-barriers are used to maintain remembered sets. The EPVM pool
class is an exception to this rule: see <a
href="#prop.pool.remote-references">.prop.pool.remote-references</a>
below.</p>

<p>Note to developers: <code class="source">mps_rank_final</code> is
not usable by MPS clients, so I haven't mentioned it. Except for just
now, that is.</p>

<h2><a id="section-4" name="section-4">4. Properties Of Objects</a></h2>

<p><a id="prop.obj.leaf" name="prop.obj.leaf"><strong>.prop.obj.leaf:</strong></a>

A "leaf object" is one that does not (and can not) contain
references.</p>

<p><a id="prop.obj.non-leaf" name="prop.obj.non-leaf"><strong>.prop.obj.non-leaf:</strong></a>

A "non-leaf object" is one that may contain references.</p>

<p><a id="prop.obj.collected" name="prop.obj.collected"><strong>.prop.obj.collected:</strong></a>

A "collected object" is one that may be automatically discarded when
the collector determines it is no longer needed.</p>

<p><a id="prop.obj.scanned" name="prop.obj.scanned"><strong>.prop.obj.scanned:</strong></a>

A "scanned object" is one that may be scanned by the collector to fix
references.</p>

<p><a id="prop.obj.manual" name="prop.obj.manual"><strong>.prop.obj.manual:</strong></a>

A "manually-managed" object is one that should be discarded when the
client explicitly says so. Any object allocated by the MPS can be
discarded by calling <code class="source">mps_pool_destroy</code>, but we don't consider an object
to have <a href="#prop.obj.manual">.prop.obj.manual</a> unless there is some more specific way of
discarding it. (Note that <a href="#prop.obj.collected">.prop.obj.collected</a> and <a href="#prop.obj.manual">.prop.obj.manual</a> are <em>not</em>
mutually exclusive.)</p>

<p><a id="prop.obj.base-ref" name="prop.obj.base-ref"><strong>.prop.obj.base-ref:</strong></a>

An object "supports base references only" if only a reference to the
base of the object is considered to be a reference to the object.</p>

<p><a id="prop.obj.internal-ref" name="prop.obj.internal-ref"><strong>.prop.obj.internal-ref:</strong></a>

An object "supports internal references" if a reference to any byte
within the object is considered to be a reference to the object.</p>

<p><a id="prop.obj.no-protect" name="prop.obj.no-protect"><strong>.prop.obj.no-protect:</strong></a>

An "unprotectable object" is one that the collector promises not to
place a read or write barrier on.</p>

<p><a id="prop.obj.protect" name="prop.obj.protect"><strong>.prop.obj.protect:</strong></a>

A "protectable object" is one that the collector may place a read or
write barrier on.</p>

<p><a id="prop.obj.no-move" name="prop.obj.no-move"><strong>.prop.obj.no-move:</strong></a>

A "non-movable object" is one that the collector will not move.</p>

<p><a id="prop.obj.move" name="prop.obj.move"><strong>.prop.obj.move:</strong></a>

A "movable object" is one that the collector may move.</p>

<p><a id="prop.obj.finalize" name="prop.obj.finalize"><strong>.prop.obj.finalize:</strong></a>

A "finalizable object" is one that the client may later register for
finalisation. [At present, this applies only to collected objects
(<a href="#prop.obj.collected">.prop.obj.collected</a>.)]</p>

<p><a id="prop.obj.formatted" name="prop.obj.formatted"><strong>.prop.obj.formatted:</strong></a>

At the moment, objects are formatted if and only if they have either
of <a href="#prop.obj.scanned">.prop.obj.scanned</a> or <a
href="#prop.obj.collected">.prop.obj.collected</a>.  This is a
coincidence, and indeed the possibility of an unformatted but
collected pool has been raised (see
mail.tony.1998-06-30.17-20(0)).</p>

<h2><a id="section-5" name="section-5">5. Pool And Pool Class Properties</a></h2>


<h3><a id="section-5.1" name="section-5.1">5.1. Allocation and freeing</a></h3>

<p><a id="prop.pool.alloc" name="prop.pool.alloc"><strong>.prop.pool.alloc:</strong></a>

A pool "with alloc" supports an interface for allocating individual
objects (<code class="source">mps_alloc</code> in the MPS).</p>

<p><a id="prop.pool.free" name="prop.pool.free"><strong>.prop.pool.free:</strong></a>

A pool "with free" supports an interface for discarding individual
objects.</p>

<p><a id="prop.pool.buffered-alloc" name="prop.pool.buffered-alloc"><strong>.prop.pool.buffered-alloc:</strong></a>

A "buffered pool" supports allocation using allocation points.</p>

<p><a id="prop.pool.save-restore" name="prop.pool.save-restore"><strong>.prop.pool.save-restore:</strong></a>

A "save-restore pool" supports "save" and "restore" operations for
allocating and discarding nested sets of objects.</p>


<h3><a id="section-5.2" name="section-5.2">5.2. Collection</a></h3>

<p><a id="prop.pool.collection" name="prop.pool.collection"><strong>.prop.pool.collection:</strong></a>

A "collected pool" is one which may be garbage-collected by the MPS.</p>

<p><a id="prop.pool.collection.auto" name="prop.pool.collection.auto"><strong>.prop.pool.collection.auto:</strong></a>

An "automatically-collected pool" is one where garbage collection is
under the control of the collector, which decides when collection
should take place and performs it automatically and incrementally.</p>

<p><a id="prop.pool.collection.demand" name="prop.pool.collection.demand"><strong>.prop.pool.collection.demand:</strong></a>

A "demand-collected pool" is one where garbage collection takes place
when the client explicitly requests it.</p>

<p><a id="question.combine.prop.pool.collection" name="question.combine.prop.pool.collection"><strong>.question.combine.prop.pool.collection:</strong></a>

How well can the two of these be combined in the same MPS?
Consequences for read and write barriers? This is an important
question, considering the differences between product.dylan and
product.epcore.</p>

<p><a id="question.prop.pool.collection.incremental" name="question.prop.pool.collection.incremental"><strong>.question.prop.pool.collection.incremental:</strong></a>

Should there be a separate pool property for being incrementally
collected? At the moment, all MPS-originated collection is incremental
and all client-requested collection is non-incremental, irrespective
of the pools involved, but perhaps this might become a pool property
in the future.</p>


<h3><a id="section-5.3" name="section-5.3">5.3. Size and alignment</a></h3>

<a id="prop.pool.alignment" name="prop.pool.alignment"></a>

<p><a id="prop.pool.alignment.fixed" name="prop.pool.alignment.fixed"><strong>.prop.pool.alignment.fixed:</strong></a>

A "fixed-alignment pool class" has a fixed object alignment.</p>

<p><a id="prop.pool.alignment.config" name="prop.pool.alignment.config"><strong>.prop.pool.alignment.config:</strong></a>

A "configurable-alignment pool" class allows the client to specify
alignment for each pool.</p>

<p><a id="prop.pool.alignment.variable" name="prop.pool.alignment.variable"><strong>.prop.pool.alignment.variable:</strong></a>

A "variable-alignment pool class" allows the client to specify
alignment for each object.</p>

<a id="prop.pool.size" name="prop.pool.size"></a>

<p><a id="prop.pool.size.fixed" name="prop.pool.size.fixed"><strong>.prop.pool.size.fixed:</strong></a>

A "fixed-size pool class" has a fixed object size.</p>

<p><a id="prop.pool.size.config" name="prop.pool.size.config"><strong>.prop.pool.size.config:</strong></a>

A "configurable-size pool class" allows the client to specify an
object size for each pool.</p>

<p><a id="prop.pool.size.variable" name="prop.pool.size.variable"><strong>.prop.pool.size.variable:</strong></a>

A "variable-size pool class" allows the client to specify a size for
each object.</p>


<h3><a id="section-5.4" name="section-5.4">5.4. Special powers</a></h3>

<p><a id="prop.pool.assoc-object" name="prop.pool.assoc-object"><strong>.prop.pool.assoc-object:</strong></a>

Each object in an "associated-object pool" can specify an associated
object which the mutator guarantees will be accessible during scanning
of the first object. (Applies to the AWL pool class, where is it used
to help Dylan manage weak hash tables.)</p>

<p><a id="prop.pool.remote-references" name="prop.pool.remote-references"><strong>.prop.pool.remote-references:</strong></a>

The references contained in an object in a "remote-references pool"
need not be stored directly in the object itself. Therefore, the
collector may not rely on write-barriers to detect changing
references. (Applies to the EPVM pool class, where it is used to help
support the ScriptWorks object format).</p>

<p><a id="prop.pool.ambiguous" name="prop.pool.ambiguous"><strong>.prop.pool.ambiguous:</strong></a>

If a pool "supports ambiguous references", then ambiguous references
which could be interpreted as references to objects in that pool will
be so interpreted. i.e. they will keep objects alive. (Does not apply
to the EPVM pool class.)</p>

<h2><a id="section-6" name="section-6">6. General Issues</a></h2>

<p><a id="issue.endian" name="issue.endian"><strong>.issue.endian:</strong></a>

Properties like "whether ref must be to base of object" can perhaps be
specified both as properties of a reference <em>from</em> a specific
reference and <em>to</em> a specific object. For example: AMC doesn't
allow weak references out of it. EPVM doesn't allow ambiguous
references into it. (Why this is, I have no idea.) For most types of
properties, the MPS design has made a choice: either it's a property
at the <em>from</em> end or at the <em>to</em> end. (E.g., base/middle
is at the <em>to</em> end, rank is (usually) at the <em>from</em>
end. Format, of course, is always at the <em>from</em> end.)</p>

<h2><a id="section-7" name="section-7">7. A Table Of Pool Classes And Their Properties</a></h2>

<p><a id="table.pool-classes" name="table.pool-classes"><strong>.table.pool-classes:</strong></a>

In the following table, a "yes" for an object property means (unless
otherwise indicated) that that property holds for <em>all</em> objects
in the pool. A "yes" for a rank means that the pool allows objects
containing references of that rank. Gaps in the table indicate
properties that aren't applicable: for example is it silly to ask
whether a pool which doesn't have <a
href="#prop.obj.scanned">.prop.obj.scanned</a> has <a
href="#prop.rank.weak">.prop.rank.weak</a>.</p>

<table border="1" cellspacing="1" cellpadding="5">

<tr valign="top">

  <th>Name of pool class</th>

  <th>AMC</th>

  <th>AMCZ</th>

  <th>AWL</th>

  <th>LO</th>

  <th>EPVM</th>

  <th>MV</th>

  <th>MV2</th>

  <th>EPDL/R</th>

  <th>MVFF</th>

</tr>

<tr valign="top">

  <td><a href="#prop.pool.alloc">.prop.pool.alloc</a></td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>yes</td>

  <td>no</td>

  <td>yes</td>

  <td>yes</td>

</tr>

<tr valign="top">

  <td><a href="#prop.pool.free">.prop.pool.free</a></td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

</tr>

<tr valign="top">

  <td><a href="#prop.pool.buffered-alloc">.prop.pool.buffered-alloc</a></td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>no</td>

  <td>yes</td>

  <td>no</td>

  <td>no</td>

</tr>

<tr valign="top">

  <td><a href="#prop.pool.save-restore">.prop.pool.save-restore</a></td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>yes</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

</tr>

<tr valign="top">

  <td><a href="#prop.obj.collected">.prop.obj.collected</a></td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

</tr>

<tr valign="top">

  <td><a href="#prop.obj.scanned">.prop.obj.scanned</a></td>

  <td>yes</td>

  <td>no</td>

  <td>yes</td>

  <td>no</td>

  <td>yes</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

</tr>

<tr valign="top">

  <td><a href="#prop.obj.manual">.prop.obj.manual</a></td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>yes<a href="#table.pool-classes.note.1">(1)</a></td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

</tr>

<tr valign="top">

  <td><a href="#prop.pool.collection">.prop.pool.collection</a></td>

  <td>auto</td>

  <td>auto</td>

  <td>auto</td>

  <td>auto</td>

  <td>manual</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

</tr>

<tr valign="top">

  <td><a href="#prop.obj.non-leaf">.prop.obj.non-leaf</a></td>

  <td>yes</td>

  <td>no</td>

  <td>yes</td>

  <td>no</td>

  <td><a href="#table.pool-classes.note.2">(2)</a></td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

</tr>

<tr valign="top">

  <td><a href="#prop.rank.exact">.prop.rank.exact</a></td>

  <td>yes</td>

  <td>&nbsp;</td>

  <td>yes</td>

  <td>&nbsp;</td>

  <td>yes</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

</tr>

<tr valign="top">

  <td><a href="#prop.rank.ambiguous">.prop.rank.ambiguous</a></td>

  <td>no</td>

  <td>&nbsp;</td>

  <td>no</td>

  <td>&nbsp;</td>

  <td>no</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

</tr>

<tr valign="top">

  <td><a href="#prop.rank.weak">.prop.rank.weak</a></td>

  <td>no</td>

  <td>&nbsp;</td>

  <td>yes</td>

  <td>&nbsp;</td>

  <td>no</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

</tr>

<tr valign="top">

  <td><a href="#prop.obj.base-ref">.prop.obj.base-ref</a></td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>yes<a href="#table.pool-classes.note.2">(2)</a></td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

</tr>

<tr valign="top">

  <td><a href="#prop.obj.internal-ref">.prop.obj.internal-ref</a></td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>yes<a href="#table.pool-classes.note.2">(2)</a></td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

</tr>

<tr valign="top">

  <td><a href="#prop.obj.protect">.prop.obj.protect</a></td>

  <td>yes</td>

  <td>no</td>

  <td>yes</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

</tr>

<tr valign="top">

  <td><a href="#prop.obj.move">.prop.obj.move</a></td>

  <td>yes</td>

  <td>yes</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

</tr>

<tr valign="top">

  <td><a href="#prop.obj.finalize">.prop.obj.finalize</a></td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>no<a href="#table.pool-classes.note.3">(3)</a></td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

</tr>

<tr valign="top">

  <td><a href="#prop.obj.formatted">.prop.obj.formatted</a></td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>yes</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

</tr>

<tr valign="top">

  <td><a href="#prop.pool.size">.prop.pool.size</a></td>

  <td>var</td>

  <td>var</td>

  <td>var</td>

  <td>var</td>

  <td>8</td>

  <td>var</td>

  <td>var</td>

  <td>var</td>

  <td>var</td>

</tr>

<tr valign="top">

  <td><a href="#prop.pool.alignment">.prop.pool.alignment</a></td>

  <td>config</td>

  <td>config</td>

  <td>config</td>

  <td>config</td>

  <td>8</td>

  <td><a href="#table.pool-classes.note.4">(4)</a></td>

  <td><a href="#table.pool-classes.note.4">(4)</a></td>

  <td>config</td>

  <td>config<a href="#table.pool-classes.note.5">(5)</a></td>

</tr>

<tr valign="top">

  <td><a href="#prop.pool.assoc-object">.prop.pool.assoc-object</a></td>

  <td>no</td>

  <td>&nbsp;</td>

  <td>yes</td>

  <td>&nbsp;</td>

  <td>no</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

</tr>

<tr valign="top">

  <td><a href="#prop.pool.remote-references">.prop.pool.remote-references</a></td>

  <td>no</td>

  <td>&nbsp;</td>

  <td>no</td>

  <td>&nbsp;</td>

  <td>yes</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

</tr>

<tr valign="top">

  <td><a href="#prop.pool.ambiguous">.prop.pool.ambiguous</a></td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>no</td>

  <td>yes</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

  <td>&nbsp;</td>

</tr>
</table>

<p>Notes:</p>

<p><a id="table.pool-classes.note.1"
name="table.pool-classes.note.1">(1)</a> because EPVM pools are
save-restore pools (<a
href="#prop.pool.save-restore">.prop.pool.save-restore</a>).</p>

<p><a id="table.pool-classes.note.2"
name="table.pool-classes.note.2">(2)</a> EPVM pools can allocate two
distinct types of object: one type is non-leaf and supports
base-references only (<a
href="#prop.obj.non-leaf">.prop.obj.non-leaf</a>, <a
href="#prop.obj.base-ref">.prop.obj.base-ref</a>). The other is leaf
and supports internal-references (<a
href="#prop.obj.leaf">.prop.obj.leaf</a>, <a
href="#prop.obj.internal-ref">.prop.obj.internal-ref</a>).</p>

<p><a id="table.pool-classes.note.3"
name="table.pool-classes.note.3">(3)</a> Finalisation of EPVM objects
may be a future requirement for ScriptWorks, so this might change.</p>

<p><a id="table.pool-classes.note.4"
name="table.pool-classes.note.4">(4)</a> MV and MV2 alignment is
platform dependent.</p>

<p><a id="table.pool-classes.note.5"
name="table.pool-classes.note.5">(5)</a> MVFF pools may not have
alignment less than <code class="source">MPS_PF_ALIGN</code> (which
should be the "platform alignment").</p>

<h2><a id="section-A" name="section-A">A. References</a></h2>

<h2><a id="section-B" name="section-B">B. Document History</a></h2>

<table>

<tr valign="top">

  <td>1998-07-02 12:16:54</td>

  <td>rit</td>

  <td>Created</td>

</tr>

<tr valign="top">

  <td>1998-07-02 to 2000-05-22</td>

  <td />

  <td>Developed at Harlequin</td>

</tr>

<tr valign="top">

  <td>2001-09-26</td>

  <td>

<a href="mailto:ndl@ravenbrook.com">NDL</a>

</td>

  <td>Converted from xml to html (second pass).</td>

</tr>

<tr valign="top">

  <td>2001-11-14</td>

  <td><a href="mailto:nb@ravenbrook.com">NB</a></td>

  <td>Reformatted and adopted.  Added .prop.obj.scanned.</td>

</tr>

</table>

<hr />

<p>

<small>Copyright &copy; 2001 Ravenbrook Limited.  This document is provided "as is", without any express or implied warranty.  In no event will the authors be held liable for any damages arising from the use of this document.  You may not duplicate or reproduce this document in any form without the express permission of the copyright holder.</small>

</p>

<div align="center">

<p>

<code>$Id$</code>

</p>

</div>

</body>

</html>

