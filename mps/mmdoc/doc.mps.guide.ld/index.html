<?xml version="1.0" encoding="UTF-8"?>



<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">



 <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>

  <head>

   <title>Using the MPS Location Dependency Interface</title>

  </head>

  <body bgcolor='#FFFFFF' text='#000000' link='#000099' vlink='#660066' alink='#FF0000'>

   <div align='center'>

    <h1>Using the MPS Location Dependency Interface</h1>

    <p>draft</p>

    <address>drj, 1996-10-15</address>

   </div>

   <h2>

    <a id='section-introduction' name='section-introduction'>Introduction</a>

   </h2>

   <p>The MPS's location dependency interface is a means by which clients of the MPS can depend on the location of objects (i.e., the "bit-pattern" of a pointer to an object) in the presence of a moving memory manager (where the location of objects may change and the client will need to recognize and correctly deal with such cases).</p>

   <p>The interface is intended to support (amongst other things) hash-tables and that will be used as a running example.  In addition to which a complete hash-table example in C is available [in another document].</p>

   <h2>

    <a id='section-terminology' name='section-terminology'>Terminology</a>

   </h2>

   <p>

    A "location dependency" is the name given to an object of type mps_ld_s.  

    A location dependency encapsulates what dependencies have been made on objects and when.  It can be used (as detailed below) to determine whether any of the objects whose location has been depended on have been moved by the memory manager.

   </p>

   <p>To "depend" on the location of an object is to perform a computation whose result depends on the particular representation (i.e., the "bit-pattern") of a pointer to the object.  An example of this is practically any sort of hash on the pointer to an object (such as treating the pointer as an integer and taking it modulo 257).  It is possible to depend on the location of more than one object.</p>

   <p>A dependency has been made "stale" if the object whose location was depended on has moved since the dependency was made.  If this is the case, then computations that depend on the location of an object may give different results.  A location dependency has been made "stale" if any of the objects whose location has been depended on have moved since the respective dependency was made.</p>

   <h2>

    <a id='section-c-interface' name='section-c-interface'>C Interface</a>

   </h2>

   <p>The C interface is in the file mps.h.  Two types are needed: mps_ld_s (a structure type) and mps_ld_t (a pointer to the structure type mps_ld_s).  The key type is mps_ld_t; mps_ld_s, the structure type, is provided merely so that clients can inline into their own structures.  The interface comprises four functions: mps_ld_reset, mps_ld_add, mps_ld_merge, and mps_ld_isstale.</p>

   <h2>

    <a id='section-protocol' name='section-protocol'>Protocol</a>

   </h2>

   <p>Creation</p>

   <p>The only way for clients to create location dependencies is for clients to provide space for the structure.  It is envisaged that this will typically be inlined in some larger structure (for example, in a hash table design, each hash table might have a location dependency structure inlined at the "beginning" of it).  This can be in MPS-managed memory or outside it; that doesn't matter.</p>

   <p>Reset</p>

   <p>Before the first use, the location dependency must be reset using the function mps_ld_reset.  Note that this means that it is not possible for clients to statically create a reset location dependency.</p>

   <p>Depend</p>

   <p>Before the location of an object is depended on (for example, hashed) the pointer should be added to a location dependency using the function mps_ld_add.  This location dependency can then be used in some lookup operation (see below) to determine if the object has moved.  Many dependencies can be added to the same location dependency.</p>

   <p>It is also possible to merge two location dependencies by calling mps_ld_merge, which adds all of the pointers from one dependency into another.</p>

   <p>Use</p>

   <p>When dependencies on the location of objects are used (during a hash-table lookup for example), the computation is carried out and the result used in the usual way (the pointer is hashed and indexed into the table for example).  At this point one of three situations can occur:  1) everything is successful (for example, the object was found in the hash-table at the indicated place); 2) the location of these objects has not been depended on before (for example, this key has never been added to the hash-table); 3) the location of these objects has been depended on before, but the one or more of the objects has moved and the dependency has been made stale.</p>

   <p>cases 2 and 3 can be distinguished with a call to mps_ld_isstale, but only partially.  A call to mps_ld_isstale can positively identify case 2, it will return 0 (so, in the hash-table example, the key should be added to the table, or the lookup failed).  When mps_ld_isstale returns non-zero (indicating case 3) then the computation should be performed using an algorithm that doesn't depend on the location of any objects, and in addition, the dependencies made on the locations of objects represented by the location dependency should be remade by resetting the location dependency and performing the computations again (for example, in a hash-table lookup, the location dependency associated with the table should be reset and the table rehashed; the key should be looked up using a search after or during the rehash).  Note that mps_ld_isstale only guarantees to return 0 for a freshly reset location dependency, in all other cases it may return non-zero, hence the requirement that it be possible to perform the computation without depending on the location of any objects (linear search in the hash-table example).</p>

   <p>Redepend</p>

   <p>It is permissible at any time to reset the location dependency and recompute all the dependencies made on the locations of objects.  This should probably be done whenever mps_ld_isstale returns non-zero.</p>

   <h2>

    <a id='section-examples' name='section-examples'>Examples</a>

   </h2>

   <p>These are simple examples given in a pseudo-code for a hash table.</p>

   <p>

    get key table

    <br />

      i = hash(key)

    <br />

      if (key, val) member of table[i]

    <br />

        return (true, val)

  else if mps_ld_isstale(table.ld, arena)

    <br />

        rehash(table)

    <br />

        if (key, val) linear-lookup table

      return (true, val)

    <br />

      return (false, unit)

   </p>

   <p>

    add key val table

    <br />

      mps_ld_add(table.ld, arena, key)

    <br />

      i = hash(key)

    <br />

      table[i] cons= (key, val)

   </p>

   <p>

    rehash table

    <br />

      mps_ld_reset(table.ld, arena)

    <br />

      // some sort of cunning in-place rehash

   </p>

   <p>

    new table

    <br />

      mps_ld_reset(table.id)

   </p>

   <h2>

    <a id='section-performance' name='section-performance'>Performance</a>

   </h2>

   <p>mps_ld_add is intended to be a fast operation.  mps_ld_isstale is intended to be a fast operation.  mps_ld_reset is inexpensive, but not intended to be very fast.  To be more precise, the following are what one could expect from a good implementation; every function has a function call overhead as well, but this can be removed by using a macro if the requirements justify this.  This section takes the view that memory-cycles are much more expensive than ALU operations.</p>

   <p>mps_ld_add performs one read memory-cycle and one write memory-cycle to the same location; it performs a few ALU operations.</p>

   <p>mps_ld_merge performs a few ALU operations, four reads, and two writes to the destination ld.</p>

   <p>mps_ld_isstale performs up to 4 read memory-cycles; it performs a few ALU operations.</p>

   <p>mps_ld_reset claims a lock.</p>

   <p>Thread safety</p>

   <p>In general, the functions are all thread-safe with respect to operations on different location dependencies.  That means that it is not necessary for threads to interlock if they are performing operations on different location dependencies.  The descriptions of the individual functions detail their thread-safety attributes in other circumstances.</p>

   <h2>

    <a id='section-reference' name='section-reference'>Reference</a>

   </h2>

   <p>Types</p>

   <p>

      typedef struct mps_ld_s {

    <br />

        mps_word_t w0, w1;

    <br />

      } mps_ld_s;

   </p>

   <p>The type mps_ld_s is an opaque structure type.  The intent is that clients can inline the structure (because its size is known) but not access it other than through the methods provided.</p>

   <p>  typedef struct mps_ld_s *mps_ld_t</p>

   <p>The type mps_ld_t is an abstract type.  Objects of type mps_ld_t are pointers to objects of type mps_ld_s.</p>

   <p>Functions</p>

   <p>  void mps_ld_add(mps_ld_t mps_ld, mps_arena_t mps_arena, mps_addr_t addr)</p>

   <p>The dependency on the object at location addr is added to the location dependency mps_ld.  Until a call to mps_ld_reset(mps_ld, arena) calls to mps_ld_isstale(mps_ld, mps_arena, addr) will return a non-zero value if the object has moved.</p>

   <p>It is possible to add the same address more than once.  mps_ld_add can accept any address, including things not in this arena.</p>

   <p>mps_ld_add is not thread-safe with respect to mps_ld_add, mps_ld_merge, or mps_ld_reset on the same location dependency, but it is thread-safe with respect to mps_ld_isstale operations.  This means that calls to mps_ld_add from different threads must interlock if they are using the same location dependency (the practical upshot is that there should be a lock associated with each location dependency).</p>

   <p>mps_ld_add does not allocate.</p>

   <p>void mps_ld_merge(mps_ld_t mps_ld_dest, mps_arena_t mps_arena, mps_ld_t mps_ld_source)</p>

   <p>The location dependency mps_ld_source is merged into mps_ld_dest.  The effect of this is to add all the pointers added to the source to the destination.  mps_ld_merge has the same thread-safety properties as mps_ld_add.</p>

   <p>  mps_bool_t mps_ld_isstale(mps_ld_t mps_ld, mps_arena_t mps_arena, mps_addr_t addr)</p>

   <p>The location dependency is examined to determine whether any of the dependencies encapsulated in it have been made stale.  If any of the dependencies encapsulated in the location dependency are stale (i.e., objects whose location has been depended on have moved) then mps_ld_isstale will return a non-zero value.  If there have been no calls to mps_ld_add on mps_ld since the last call to mps_ld_reset, then mps_ld_isstale will return 0.  mps_ld_isstale may return any value in other circumstances (but will strive to return zero if the objects encapsulated in the location dependency have not moved).  mps_ld_isstale is thread-safe with respect to itself and with respect to mps_ld_add, but not with respect to mps_ld_reset.</p>

   <p>  void mps_ld_reset(mps_ld_t mps_ld, mps_arena_t mps_arena)</p>

   <p>Resets the location dependency.  After the call, mps_ld encapsulates no dependencies.  After the call to mps_ld_reset and prior to any call to mps_ld_add (on the same location dependency), mps_ld_isstale on this location dependency will return 0 for all addresses.  mps_ld_reset is not thread-safe with respect to any other mps_ld function.</p>

   <h2>

    <a id='section-A' name='section-A'>A. References</a>

   </h2>

   <h2>

    <a id='section-B' name='section-B'>B. Document History</a>

   </h2>

   <table>

    <tr valign='top'>

     <td>1996-10-15 13:21:48 +01</td>

     <td />

     <td>New document saved</td>

    </tr>

    <tr valign='top'>

     <td>1996-10-17 10:36:39 +01</td>

     <td>drj</td>

     <td></td>

    </tr>

    <tr valign='top'>

     <td>1996-10-17 11:54:17 +01</td>

     <td>drj</td>

     <td></td>

    </tr>

    <tr valign='top'>

     <td>1996-10-17 14:27:18 +01</td>

     <td>drj</td>

     <td></td>

    </tr>

    <tr valign='top'>

     <td>1997-01-29 14:06:04 +00</td>

     <td>drj</td>

     <td></td>

    </tr>

    <tr valign='top'>

     <td>1997-04-23 16:40:19 +01</td>

     <td>

      <a href='mailto:rb@ravenbrook.com'>RB</a>

     </td>

     <td></td>

    </tr>

    <tr valign='top'>

     <td>1997-06-25 16:43:21 +00</td>

     <td>

      <a href='mailto:rb@ravenbrook.com'>RB</a>

     </td>

     <td>Added documentation of mps_ld_merge.</td>

    </tr>

    <tr valign='top'>

     <td>1998-10-30 14:56:24 +00</td>

     <td>pekka</td>

     <td>some edits</td>

    </tr>

    <tr valign='top'>

     <td>2000-05-22 13:09:30 +01</td>

     <td>pekka</td>

     <td>change tag from guide.mps.ld; clean up</td>

    </tr>

    <tr valign='top'>

     <td>2000-07-05 20:03:12 +01</td>

     <td>pekka</td>

     <td>some notes</td>

    </tr>

    <tr valign='top'>

     <td>2000-08-01 18:56:28 +01</td>

     <td>pekka</td>

     <td>clarify thread safety of merge</td>

    </tr>

    <tr valign='top'>

     <td>2001-09-26</td>

     <td>

      <a href='mailto:ndl@ravenbrook.com'>NDL</a>

     </td>

     <td>Converted from xml to html (second pass).</td>

    </tr>

   </table>

   <hr />

   <p>

    <small>Copyright &copy; 2001 Ravenbrook Limited.  This document is provided "as is", without any express or implied warranty.  In no event will the authors be held liable for any damages arising from the use of this document.  You may not duplicate or reproduce this document in any form without the express permission of the copyright holder.</small>

   </p>

   <div align='center'>

    <p>

     <code>$Id$</code>

    </p>

   </div>

  </body>

 </html>

