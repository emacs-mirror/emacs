<?xml version="1.0" encoding="UTF-8"?>



<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">



 <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>

  <head>

   <title>MPS Interface Conventions</title>

  </head>

  <body bgcolor='#FFFFFF' text='#000000' link='#000099' vlink='#660066' alink='#FF0000'>

   <div align='center'>

    <h1>MPS Interface Conventions</h1>

    <p>incomplete</p>

    <address>lmb, 1997-05-29</address>

   </div>

   <h2>

    <a id='section-naming' name='section-naming'>Naming</a>

   </h2>

   <p>

    <strong>.naming</strong>

    : 

    The MPS interface naming conventions resemble the C, UNIX, or POSIX conventions.

   </p>

   <p>   - Identifiers are in lower case, except for macros that do not behave like functions,</p>

   <p>     which are in upper case.</p>

   <p>   - All publicized identifiers start with the prefix "mps_" or "MPS_". </p>

   <p>   - Types end with the suffix "_t", except for structure and union types; see below. </p>

   <p>   - Structure types and tags end with "_s". </p>

   <p> - Union types and tags end with "_u".</p>

   <p>   - Enumeration types are not used; we don't think it's good C style.</p>

   <p>

    <strong>.naming.reserve:</strong>

     We reserve the right to use "mps_" or "MPS_" for undocumented internal names.  Future versions may use symbols that aren't defined in current versions, but they will also begin with "mps_" or "MPS_".  

    In addition, you should not use _mps_ for your own names if you are using our macros.

   </p>

   <h2>

    <a id='section-opaque-and-transparent-types' name='section-opaque-and-transparent-types'>Opaque And Transparent Types</a>

   </h2>

   <p>

    <strong>.mps.types:</strong>

     Types declared in the MPS interface are of three sorts:

   </p>

   <p>

       - Transparent types

    <br />

       - Opaque types

    <br />

       - Derived types

   </p>

   <p>

    <strong>.transparent:</strong>

     The transparent types, such as mps_res_t, are types whose implementation is deliberately exposed.  You may use properties of the underlying types to manipulate values of these types.  For instance:

   </p>

   <p>

    - mps_addr_t is void*.  You may cast an mps_addr_t to a structure pointer, if you acquired it from an MPS allocation function (and you didn't specify an alignment that is too small for this type of structure).

    <br />

   </p>

   <p>- mps_bool_t is int.  You may combine mps_bool_t values with Boolean operators, use them as conditions, and so on.</p>

   <p>You should always use the type name declared in mps.h when using the MPS interface (so, for instance, you should not use "int" where you mean "mps_res_t").</p>

   <p>

    <strong>.opaque:</strong>

     The opaque types, such as mps_class_t, are declared as pointers to incomplete structure types (such as struct mps_class_s).  This means that the implementation of these types is invisible to you.  You should not use anything about the implementation of an opaque type.  The value of an opaque type might be NULL, or an invalid pointer (for instance, it might point to unmapped memory).  You cannot generate values of opaque type; only the MPS may generate them.  The value of an opaque type can only be used in a call to the MPS or a test for equality with another value of the same type.

   </p>

   <p>

    <strong>.derived:</strong>

     The derived types, such as mps_ap_s, mps_assert_t, and mps_root_scan_t, are structure and function types based on transparent and opaque types and on built-in C types.  The degree to which you may or must depend upon the implementation of a derived type depends upon the type, and is covered by the documentation for the type.

   </p>

   <h2>

    <a id='section-result-code-return' name='section-result-code-return'>Result Code Return</a>

   </h2>

   <p>

    <strong>.res</strong>

    : Operations that might fail return a result code, rather than a "special value" of the return type.  In other C interfaces, it is common to do the following:

   </p>

   <p>

      p = malloc(s);

    <br />

      if (p == NULL) there was an error;

    <br />

      otherwise p is meaningful

   </p>

   <p>

    <strong>.res.special</strong>

    : Here, NULL is a special value.  We shun special values.  It is too easy to ignore them, and then they trip you up later.  Also, there is not always one available.  There is only one special value in many cases, so you cannot distinguish between different errors.  Other justification is given in Maguire, 1993, Chapter 5.

   </p>

   <p>

    <strong>.res.code</strong>

    : There is a single fixed set of result codes defined in mps.h, all beginning "MPS_RES_".  

    <strong>.res.code.ok</strong>

    : MPS_RES_OK means "operation succeeded".  We guarantee that MPS_RES_OK is zero, so we support the following code:

   </p>

   <p>

      res = mps_alloc(...);

    <br />

      if(res) handle error;

   </p>

   <p>as shorthand for:</p>

   <p>

      res = mps_alloc(...);

    <br />

      if(res != MPS_RES_OK) handle error;

   </p>

   <p>

    <strong>.res.code.meaning</strong>

    : The other codes have rough global meanings, but what they mean specifically depends on the method that they come from.  So, for example, MPS_RES_MEMORY indicates failure due to lack of memory, but might mean something in particular for some methods. 

   </p>

   <p>

    <strong>.res.error-path</strong>

    : We recommend handling errors using error unwind paths.  That is, functions that could fail always return an error code and pass back return values via reference parameters.  In the event of an error, a function must leave the system in a state as if nothing has happened.  You can do this by constructing an "error path" at the end of the function that will unwind its effect, in a manner similar to an exception handler.

   </p>

   <p>Here is what a typical function might look like:</p>

   <p>

    <pre>  res_t frobulate(frob_t *frob_return, size_t s)

  {

    res_t res;

    frob_t frob;

    void *p;

    size_t i;

    ASSERT(frob_return != NULL);        /* see frob spec 1.3.4 */

    ASSERT(s &gt; 0);                      /* see frob spec 1.3.5 */

    ASSERT(s &lt; FROB_SIZE_LIMIT);        /* see frob spec 1.3.5 */

    res = alloc(&amp;p, sizeof(frob_struct));

    if(res != RES_OK) goto fail_frob;

    frob = (frob_t)p;

    res = alloc(&amp;p, sizeof(spong_struct) * s);

    if(res != RES_OK) goto fail_spong;

    frob-&gt;spong_vector = (spong_t)p;

    for(i = 0; i &lt; s; ++i) {

      res = spong_splat(&amp;frob-&gt;spong_vector[i]);

      if(res != RES_OK) goto fail_splats;

    }

    /* etc. */

    ASSERT(check_frob(frob));

    *frob_return = frob;                /* only update result on success */

    return RES_SUCCESS;

  fail_splats:

    /* spongs don't need to be unsplatted individually (spong spec 2.3.1), */

    /* so it's OK to just deallocate the spong vector. */

    dealloc((void *)frob-&gt;spong_vector);

  fail_spong:

    dealloc((void *)frob);

  fail_frob:

    return res;

  }</pre>

   </p>

   <p>

    <strong>.res.params</strong>

    : If the result 

    code is non-zero (th

    at is, not MPS_RES_OK), then none of the input/output or output parameters will have been modified (see below).

   </p>

   <p>INPUT/OUTPUT AND OUTPUT PARAMETERS</p>

   <p>

    <strong>.io</strong>

    : We use I/O and O parameters where

   </p>

   <p>

    <strong>-</strong>

     we need to return a value _and_ there may be an error case.

    <br />

       - we need to return more than one value.

   </p>

   <p>

    <strong>.io.out</strong>

    : An output parameter is just a pointer to somewhere where the result can be stored.  You tell the function where to put the result.  For example:

   </p>

   <p>

    <pre>  mps_addr_t p;

  res = mps_alloc(&amp;p, pool, size);

  if(res) {

    /* p hasn't been touched in this case. */

    handle error;

  }

  /* p now contains the result, which is the address of the new block */

  /* in this case. */</pre>

   </p>

   <p>Here, the first parameter of mps_alloc, p, is an "output" parameter.  The value of p when mps_alloc is called is not used by mps_alloc.  p is only modified if mps_alloc succeeds.</p>

   <p>

    <strong>.io.io</strong>

    : An input/output parameter is very similar, except that the value _is_ used when the function is called.

   </p>

   <p>

    <pre>  res = mps_fix(ss, &amp;ref);</pre>

   </p>

   <p>In this case the value of ref when mps_fix is called is significant.  mps_fix _may_ update ref, but only if res is MPS_RES_OK (that is, only if successful.)</p>

   <p>Unless otherwise documented for a specific function, the pointers passed as input/output and output parameters must be valid pointers to storage of the correct type, and in particular must be non-null and correctly aligned.  In addition, input/output parameters must be pointers to storage containing valid values of the appropriate type.</p>

   <p>

    <strong>.io.pun</strong>

    : It's tempting to use cast to change the type of a I/O or O parameter, like this:

   </p>

   <p>

    <pre>  struct foo *fp;

  res = mps_alloc((mps_addr_t *)&amp;fp, pool, sizeof(struct foo));

  if(res) ...</pre>

   </p>

   <p>This is called a pun, and is illegal in standard C [xref to standard.ansic].  In fact, it will work on almost all architectures, but it relies on the fact that fp has the same underlying representation as an mps_addr_t.  As a result, the code is not portable.  We do not condone this usage.  Instead, we recommend this:</p>

   <p>

    <pre>  mps_addr_t p;

  struct foo *fp;

  res = mps_alloc(&amp;p, pool, sizeof(struct foo));

  if(res) ...

  fp = (struct foo *)p;</pre>

   </p>

   <h2>

    <a id='section-general-operations-on-abstract-data-types' name='section-general-operations-on-abstract-data-types'>General Operations On Abstract Data Types</a>

   </h2>

   <p>

    <strong>.adt.naming</strong>

    : Usually, abstract data types (ADTs) have names like "pool".  Objects of the type are of type "mps_pool_t", which is actually a pointer to a structure of type "mps_pool_s".  All the operations on that type begin with "mps_pool_".

   </p>

   <p>

    <strong>.adt.create</strong>

    : To create an object, use the "mps_*_create" method.  In general, this has a return parameter into which the new object is placed, and the other parameters specify what it is created inside and other options or attributes it has.  For example, a pool is made in the space, and has a class as an attribute, and maybe some optional arguments (see above).

   </p>

   <p>

    <strong>.adt.destroy</strong>

    : When you have finished with the object, it is destroyed using "mps_*_destroy", which takes the object as a parameter and doesn't fail.

   </p>

   <p>

    <strong>.adt.finish</strong>

    : As a general rule, you must "finish off" the object before it is destroyed.  For example, you must destroy all the pools before you destroy the arena (thus "finishing off" the arena).  This has a kind of symmetry which helps you to get things correct and therefore improves reliability.

   </p>

   <h2>

    <a id='section-macro-naming' name='section-macro-naming'>Macro Naming</a>

   </h2>

   <p>

    <strong>.macro.intro:</strong>

     We use two kinds of macro.  One kind behaves like a function.  The following paragraphs describe this type.

   </p>

   <p>

    <strong>.macro.std</strong>

    : We follow a convention that's almost exactly the same as the standard C library.  To quote 7.1.7:

   </p>

   <p>

      Any function declared in a header may additionally be implemented as a

    <br />

      macro defined in the header, so a library function should not be declared

  explicitly if its header is included.  Any macro definition of a function

    <br />

      can be suppressed locally be enclosing the name of the function in

  parentheses, because the name is then not followed by the left parenthesis

    <br />

      that indicates expansion of a macro function name.

  ... Any invocation of a library function that is implemented as a macro

    <br />

      shall expand to code that evaluates each of its arguments exactly once,

  fully protected by parentheses where necessary, so it is generally safe

    <br />

      to use arbitrary expressions as arguments.

   </p>

   <p>

    <strong>.macro.multi</strong>

    : In some cases an argument may be evaluated more than once, so it is not safe to have a side effect in an argument of such a method.  These special cases are documented in the reference entry

    .

   </p>

   <p>

    <strong>.macro.call</strong>

    : If you definitely want to call the function, there are two ways:

   </p>

   <p>   - You can undefine the macro as follows:</p>

   <p>

    <pre>     #undef mps_reserve

     res = mps_reserve(...);  /* definitely calls the function */</pre>

   </p>

   <p>   - You can put the name in parentheses, as follows:</p>

   <p>

    <pre>     res = (mps_reserve)(...);  /* definitely calls the function */</pre>

   </p>

   <p>We recommend the latter.</p>

   <p>

    <strong>.macro.void</strong>

    : 

    (Technical detail for people writing macros mainly.)  

    When a function returns void, we may implement it as a macro that expands to a _statement_ (when terminated by a semicolon).  Therefore, it is not supported to use such functions where only an expression is valid -- for example, on the left-hand side of a comma.  This is not supported:

   </p>

   <p>  (mps_tramp(...), ...)</p>

   <p>but this is:</p>

   <p>  mps_tramp(...);</p>

   <p>

    <strong>.macro.special</strong>

    : The other kind of macro is not a version of a function.  These are always written in all caps.  The exact details depend on the macro; see the reference documentation.  For example, there is a macro that reserves (like mps_reserve) but does not behave like a function syntactically, called MPS_RESERVE_BLOCK.

   </p>

   <p>

    <strong>.macro.expansion:</strong>

     Details of the macro expansion, although visible in the header file, are not part of the MPS interface, and might change between releases.  Don't rely on them, unless they are documented separately (as the internals of allocation points are).

   </p>

   <h2>

    <a id='section-header-files' name='section-header-files'>Header Files</a>

   </h2>

   <p>

    <strong>.h.main</strong>

    : The main interface is called "mps.h".  

    This header contains all the core MPS interfaces.   

    In practice,

     you always need at least one arena class and one pool class header file as well.

   </p>

   <p>

    <strong>.h.prefix</strong>

    : We will always prefix header file names with "mps" to avoid clashes.  We reserve the right to create new headers beginning with "mps" in future versions.

   </p>

   <p>

    <strong>.h.class</strong>

    : Pool class headers begin with "mpsc".  So the header for pool class XX is "mpscxx.h".  Such a header contains the declaration of the pool class itself (that is, mps_class_xx()) and any class-specific stuff.

   </p>

   <p>

    <strong>.h.arena</strong>

    : Arena class headers begin with "mpsa".  So the header for arena class YY is "mpsayy.h".  Such a header contains the declaration of the arena class itself (that is, mps_arena_class_yy()) and any class-specific stuff.

   </p>

   <h2>

    <a id='section-summary-of-interface-conventions' name='section-summary-of-interface-conventions'>Summary Of Interface Conventions</a>

   </h2>

   <p>- The MPS interface naming convention resembles a conventional C, UNIX, or POSIX convention.  We reserve the right to use mps_ or MPS_ for undocumented internal names.  In addition, you should not use _mps_ for your own names if you are using our macros.</p>

   <p>- Types are transparent, opaque, or derived.  The implementations of transparent types are exposed; the implementations of opaque types are not.  For information on derived types, consult the documentation for that type.</p>

   <p>- Operations that might fail return a result code, rather than a "special value" of the return type.  The MPS uses a fixed set of result codes, all beginning "MPS_RES_".  MPS_RES_OK indicates success and is always 0.  The other codes have rough global meanings, but what they mean specifically depends on the method that they come from.</p>

   <p>- We recommend handling errors using error unwind paths.</p>

   <p>- We use I/O and O parameters where</p>

   <p>

    <strong>-</strong>

     we need to return a value _and_ there may be an error case.

    <br />

       - we need to return more than one value.

   </p>

   <p>An output parameter is a pointer to somewhere where the result can be stored.  You tell the function where to put the result.  An input/output parameter is very similar, except that the value _is_ used when the function is called.  We do not support punning.</p>

   <p>- You can pass a set of optional arguments to a function as a structure.  The structure can contain default values that you can override if you want to.</p>

   <p>- ADTs are of type mps_*_t.  All operations on an ADT begin with mps_*.  To create or destroy an object, use mps_*_create or mps_*_destroy, respectively.  You usually must finish off the object before you destroy it.</p>

   <p>- The MPS's macro naming convention is almost the same as the standard C library's.  The exception is that, in some cases, MPS macros may be evaluated more than once, so it is not safe to have a side effect in an argument to such a method.  These special cases are documented in the reference entry.</p>

   <h2>

    <a id='section-A' name='section-A'>A. References</a>

   </h2>

   <h2>

    <a id='section-B' name='section-B'>B. Document History</a>

   </h2>

   <table>

    <tr valign='top'>

     <td>1997-05-29 14:05:54 +01</td>

     <td />

     <td>New document saved</td>

    </tr>

    <tr valign='top'>

     <td>1997-05-29 14:14:19 +01</td>

     <td />

     <td>Created document and edited halfway</td>

    </tr>

    <tr valign='top'>

     <td>1997-05-29 15:50:13 +01</td>

     <td />

     <td>Intermediate edit save</td>

    </tr>

    <tr valign='top'>

     <td>1997-05-29 16:55:42 +01</td>

     <td />

     <td>Finished first pass at editing</td>

    </tr>

    <tr valign='top'>

     <td>1997-05-29 17:17:49 +01</td>

     <td />

     <td>Added summary</td>

    </tr>

    <tr valign='top'>

     <td>1997-05-29 17:27:27 +01</td>

     <td>lmb</td>

     <td>Moved summary to beginning</td>

    </tr>

    <tr valign='top'>

     <td>1997-06-20 14:43:57 -04</td>

     <td />

     <td>Some small edits and additions.</td>

    </tr>

    <tr valign='top'>

     <td>1997-06-20 15:50:59 -04</td>

     <td>lmb</td>

     <td>Lots of small edits.</td>

    </tr>

    <tr valign='top'>

     <td>1998-10-30 20:01:20 +00</td>

     <td />

     <td>space</td>

    </tr>

    <tr valign='top'>

     <td>1998-10-30 20:15:02 +00</td>

     <td>pekka</td>

     <td>Fixed formatting; removed _MPS conflicting with ANSI C</td>

    </tr>

    <tr valign='top'>

     <td>1998-11-05 12:42:14 +00</td>

     <td>drj</td>

     <td>edits to .naming, removed convention for enum types</td>

    </tr>

    <tr valign='top'>

     <td>1999-02-08 12:19:53 +00</td>

     <td>drj</td>

     <td>comment on .naming, .transparent.  corrected sentence in .naming.reserve</td>

    </tr>

    <tr valign='top'>

     <td>1999-02-11 15:54:27 +00</td>

     <td>pekka</td>

     <td>improved mps_addr_t in .transparent</td>

    </tr>

    <tr valign='top'>

     <td>1999-05-06 12:57:39 +01</td>

     <td>pekka</td>

     <td>added note on macro expansions</td>

    </tr>

    <tr valign='top'>

     <td>2000-05-22 14:08:16 +01</td>

     <td>pekka</td>

     <td>clean up</td>

    </tr>

    <tr valign='top'>

     <td>2001-09-26</td>

     <td>

      <a href='mailto:ndl@ravenbrook.com'>NDL</a>

     </td>

     <td>Converted from xml to html (second pass).</td>

    </tr>

   </table>

   <hr />

   <p>

    <small>Copyright &copy; 2001 Ravenbrook Limited.  This document is provided "as is", without any express or implied warranty.  In no event will the authors be held liable for any damages arising from the use of this document.  You may not duplicate or reproduce this document in any form without the express permission of the copyright holder.</small>

   </p>

   <div align='center'>

    <p>

     <code>$Id$</code>

    </p>

   </div>

  </body>

 </html>

