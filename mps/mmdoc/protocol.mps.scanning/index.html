<?xml version="1.0" encoding="UTF-8"?>



<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">



 <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>

  <head>

   <title>MPS Scanning Protocol</title>

  </head>

  <body bgcolor='#FFFFFF' text='#000000' link='#000099' vlink='#660066' alink='#FF0000'>

   <div align='center'>

    <h1>MPS Scanning Protocol</h1>

    <p>incomplete</p>

    <address>pekka, 1998-01-27</address>

   </div>

   <h2>

    <a id='section-background' name='section-background'>Background</a>

   </h2>

   <p>The purpose of scanning an object is to locate and process all the references in that object.  Scanning is usually done as a part of tracing.</p>

   <p>Scanning is one of the most critical client functions.  In order for GC to proceed quickly, the scanner has to be fast, because that is what the GC is doing most of the time.</p>

   <h2>

    <a id='section-scanning-functions' name='section-scanning-functions'>Scanning Functions</a>

   </h2>

   <p>

    References are indicated to the MPS by "fixing" them.  The MPS C interface provides a function called 

    <code>mps_fix</code>

     that fixes a single reference, and several macros that can be used to do that more efficiently.

   </p>

   <p>The general layout of a scan method is as follows:</p>

   <p>Scan(ScanState, Base, Limit)</p>

   <p>  for Object = each object between Base and Limit</p>

   <p>    for Location = location of each reference in Object</p>

   <p>      Fix(ScanState, Location)</p>

   <p>This might modify the contents of the locations.</p>

   <p>The references in the objects could be stored in a form that's different from the one supported by the MPS interface (see doc.mps.ref-man.concepts.reference for examples); in that case, the scan method has to decode the reference before passing it to Fix, and possibly re-encode the updated reference after Fix.  An example about stripping off a tag:</p>

   <p>  1. copying the tag portion of the reference to another location, </p>

   <p>  2. removing the tag section of the old location,</p>

   <p>  3. fixing the reference, and </p>

   <p>  4. copying the tag back.</p>

   <p>Examples of a Scan Methods in C</p>

   <p>Here's a simple scan method:</p>

   <p>

    <pre>mps_res_t foo_scan(mps_ss_t scan_state, mps_addr_t base, mps_addr_t limit)

{

  /* We have Objects which contain two pointer fields, left and right. */

  Object *obj;

  Object *obj_limit;

  obj_limit = limit;

  for(obj = base; obj &lt; obj_limit; obj++) {

    if(mps_fix(scan_state, &amp;obj-&gt;left) != MPS_RES_OK)

      return res;

    if(mps_fix(scan_state, &amp;obj-&gt;right) != MPS_RES_OK)

      return res;

  }

  return MPS_RES_OK;

}</pre>

   </p>

   <p>If the fixing fails, the scan method must stop and return the error code (as in the code above).  Later, the scan method will (probably) be called again on the same object to complete the scanning.</p>

   <p>We can speed things up a bit by using the macros:</p>

   <p>

    <pre>mps_res_t foo_scan(mps_ss_t scan_state, mps_addr_t base, mps_addr_t limit)

{

  Object *obj;

  Object *obj_limit;

  obj_limit = limit;

  MPS_SCAN_BEGIN(scan_state)

    for(obj = base; obj &lt; obj_limit; obj++) {

      if(MPS_FIX12(scan_state, &amp;obj-&gt;left) != MPS_RES_OK)

        return res;

      if(MPS_FIX12(scan_state, &amp;obj-&gt;right) != MPS_RES_OK)

        return res;

    }

  MPS_SCAN_END(scan_state);

  return MPS_RES_OK;

}</pre>

   </p>

   <p>MPS_SCAN_BEGIN sets up local information used by MPS_FIX12, MPS_FIX1 and MPS_FIX2, making things faster.  MPS_SCAN_END completes the scanning started by MPS_SCAN_BEGIN.  The MPS_FIX* macros may not be used except within MPS_SCAN_BEGIN and MPS_SCAN_END, which can only be used in scan methods.</p>

   <p>Further speedups can be achieved by splitting MPS_FIX12 into two macros: MPS_FIX1 and MPS_FIX2.  MPS_FIX1 is a fast test to see if the reference is likely to be interesting to the MPS; if it returns false, the scanner can proceed to the next reference.  If it returns true, the scan method can apply further, slower tests to it, before deciding to invoke MPS_FIX2, which does the actual fixing.</p>

   <p>A general pseudo-code implementation of a scan method is:</p>

   <p>

    <pre>mps_res_t foo_scan(mps_ss_t state, mps_addr_t base, mps_addr_t limit)

{

  [setup]

  MPS_SCAN_BEGIN(state)

    [loop over the objects]

      [find pointers in the object]

        if(MPS_FIX1(state, ptr)) /* test whether interesting to scanner */ {

          [possibly more format-specific tests]

          res = MPS_FIX2(state, &amp;ptr) /* if yes, then fix */ 

          if(res != MPS_RES_OK)

            return res;

        }

  MPS_SCAN_END(state);

  return MPS_RES_OK;

}</pre>

   </p>

   <p>

    Note that you do not have to separate all non-pointers before calling MPS_FIX*, it is permitted for the reference (

    <code>*ref_io</code>

    ) to point outside any MPS arena, or to be NULL; in that case, it is simply ignored.  However, passing a bogus value that looks like a pointer into an arena, but isn't (doesn't actually point to an MPS-allocated object), is not permitted and will cause a failure either immediately or even during a subsequent collection.  This restriction doesn't apply to ambiguous references, naturally, they can be anything.

   </p>

   <p>When using the macros, you can't directly use a separate function to do part of the scanning, because between MPS_SCAN_BEGIN and MPS_SCAN_END, the scan_state parameter is in a strange state, so you shouldn't pass it as an argument to a function.  However, if you want to split off part of the scanning to a separate function (say, because you have an embedded structure shared between two scan methods), you can pass the scan state using MPS_FIX_CALL.</p>

   <p>

    <pre>mps_res_t foo_scan(mps_ss_t scan_state, mps_addr_t base, mps_addr_t limit)

{

  Object *obj;

  Object *obj_limit;

  mps_res_t res;

  obj_limit = limit;

  MPS_SCAN_BEGIN(scan_state)

    for(obj = base; obj &lt; obj_limit; obj++) {

      if((res = MPS_FIX(scan_state, &amp;obj-&gt;left)) != MPS_RES_OK)

        return res;

      MPS_FIX_CALL(scan_state,

                   res = scan_data(scan_state, &amp;obj-&gt;data));

      if(res != MPS_RES_OK) return res;

      if((res = MPS_FIX(scan_state, &amp;obj-&gt;right)) != MPS_RES_OK)

        return res;

    }

  MPS_SCAN_END(scan_state);

  return MPS_RES_OK;

}</pre>

   </p>

   <p>Scanner Optimization</p>

   <p>One way to make the scan fast is to avoid calling the mps_fix function unless necessary.  When writing a scanner, you can use the special macros described above - MPS_SCAN_BEGIN, MPS_SCAN_END, MPS_FIX12, MPS_FIX1, and MPS_FIX2 - to aid in optimizing the scanner code.  You can also try varying the order of your tests and MPS_FIX1 to see which is faster.</p>

   <p>Writing good scanning functions is tricky.  You should avoid invoking MPS_FIX2 unless necessary, and also avoid using too many local variables between SCAN_BEGIN and SCAN_END.  The latter constraint is useful because the number of registers is limited, and the scanner is faster if it can store all values in registers.</p>

   <p>Example of a Scanner Using a Simple Lisp Object</p>

   <p>The cons contains a bit that is clear if the object contains pointers, and set if it does not.  If the bit is clear, then the scanner needs to fix the object.  If the bit is set, the scanner can skip the object.  Because the object is so simple, the scanner can perform FIX1 and FIX2 at the same time.</p>

   <p>cons_scan </p>

   <p>  if (flag) </p>

   <p>    MPS_SCAN_BEGIN(fixer) </p>

   <p>      res = MPS_FIX12(...car) ; </p>

   <p>      if res = ...</p>

   <p>      res = MPS_FIX12(...cdr) ; </p>

   <p>      if res = ...</p>

   <p>   MPS_SCAN_END(...)</p>

   <p>Restrictions on Scanners</p>

   <p>If a reference is hidden from the MPS - that is, the scanner is unable to "fix" the reference - then that reference might become invalid.  The client program will probably continue to run for some time, but at some point, it will probably crash. </p>

   <p>For an example of how to avoid a hidden pointer, imagine a cons with a flag that is clear if only the car is a reference (and the cdr is ignored) and set if both car and cdr are references.  The correct approach to set the cdr is to first set the cdr field to zero, then set the bit, then make the cdr into a reference.  Otherwise, the client program will end up with junk in the cdr that will cause it to crash.</p>

   <h2>

    <a id='section-A' name='section-A'>A. References</a>

   </h2>

   <h2>

    <a id='section-B' name='section-B'>B. Document History</a>

   </h2>

   <table>

    <tr valign='top'>

     <td>1998-01-27 19:52:31 +00</td>

     <td>pekka</td>

     <td>New document saved</td>

    </tr>

    <tr valign='top'>

     <td>1998-02-03 18:27:51 +00</td>

     <td>drj</td>

     <td>kibbitzed on APs</td>

    </tr>

    <tr valign='top'>

     <td>1998-08-27 14:14:56 +00</td>

     <td>drj</td>

     <td>modified my kibbitz</td>

    </tr>

    <tr valign='top'>

     <td>2000-05-19 19:11:26 +01</td>

     <td>pekka</td>

     <td>improve; fix bug in example</td>

    </tr>

    <tr valign='top'>

     <td>2000-05-22 16:11:12 +01</td>

     <td>pekka</td>

     <td>fix title</td>

    </tr>

    <tr valign='top'>

     <td>2000-06-06 15:10:23 +01</td>

     <td>pekka</td>

     <td>MPS_FIX_12; remove tags</td>

    </tr>

    <tr valign='top'>

     <td>2001-02-06 20:30:14 +00</td>

     <td>pekka</td>

     <td>describe outside the arena case</td>

    </tr>

    <tr valign='top'>

     <td>2001-09-26</td>

     <td>

      <a href='mailto:ndl@ravenbrook.com'>NDL</a>

     </td>

     <td>Converted from xml to html (second pass).</td>

    </tr>

   </table>

   <hr />

   <p>

    <small>Copyright &copy; 2001 Ravenbrook Limited.  This document is provided "as is", without any express or implied warranty.  In no event will the authors be held liable for any damages arising from the use of this document.  You may not duplicate or reproduce this document in any form without the express permission of the copyright holder.</small>

   </p>

   <div align='center'>

    <p>

     <code>$Id$</code>

    </p>

   </div>

  </body>

 </html>

