<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">

 <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
  <head>
   <title>MPS Concepts and Terms</title>
  </head>
  <body bgcolor='#FFFFFF' text='#000000' link='#000099' vlink='#660066' alink='#FF0000'>
   <div align='center'>
    <h1>MPS Concepts and Terms</h1>
    <p>draft</p>
    <address>lmb, 1997-05-28</address>
   </div>
   <p>
    Some concepts and terms used in the MPS documentation are described here.  These definitions are aimed at understanding MPS usage; for wider background on these and common memory management terms, please refer to our Memory Management Reference 
    <pre>&lt;URL:http://www.harlequin.com/mm/reference/&gt;</pre>
    .
   </p>
   <p>The Memory Manager</p>
   <p>A library that you use to manage memory.  This term is interchangeable with MPS.</p>
   <p>Arena</p>
   <p>An objects that represents the state of the MPS. </p>
   <p>
    You start a session with the MPS by making an arena and end the session by destroying 
    <br />
    the arena.  Even if you do not destroy it, it is guaranteed not to hang on to resources; but it is better to destroy it, to finish off properly.  Before destroying the arena, you must first destroy all objects and data in it.
   </p>
   <p>Other types of objects are created "in the arena".  They are part of the world within the arena, and may interoperate with each other.</p>
   <p>
    It is possible to create multiple arenas, but you would only do this in unusual circumstances.  It might be useful to have two active arenas and to try different things out in them.  The maximum number of arenas that the system can support is around 10.  Using multiple arenas is an advanced technique.  For more information, see the Arena Protocol
    .
   </p>
   <p>Arenas do not interact.  However, they may conflict with each other in terms of resources.</p>
   <p>Client application</p>
   <p>The application using MPS to manage (at least a part of) its memory.</p>
   <p>MPS object</p>
   <p>A single block of memory allocated from the MPS.</p>
   <p>Client object</p>
   <p>An object of the client application, usually matches MPS objects one-to-one, but more complicated schemes are possible (suballocation within an MPS block and multi-part objects).</p>
   <p>Pool class</p>
   <p>
    Code that dictates an MPS policy.  Different pool classes are suitable for different purposes.  At the moment, there are five pool classes; we hope to ship more in future.  For information on the individual pool classes, see the 
    <cite>Pool Class Catalog</cite>
    .
   </p>
   <p>Policy</p>
   <p>A set of rules for handling program objects and memory blocks.  Some examples of policies are:</p>
   <p>   - whether the pool class garbage collects or not,</p>
   <p>   - whether the formats of the objects need to be known in advance.</p>
   <p>Allocating</p>
   <p>The act of finding a block of memory of a certain size on request.</p>
   <p>Freeing</p>
   <p>The act of recycling a block of memory for later reuse.</p>
   <p>Pool</p>
   <p>A set of memory blocks managed according to a policy determined by the pool class and its parameters; Client objects are allocated in a pool.  A pool lives in an arena.  Multiple pools can coexist in one arena.</p>
   <p>Reference</p>
   <p>A reference represents potentially shared access to an object.  In typical languages and runtime systems, a reference will be represented as a "pointer" -- that is, the address of the object in memory.  Sometimes a reference contains more information, such as a type and a length.</p>
   <p>The MPS C interface admits only one representation of a reference.  A reference is represented by an object of type "void *" which, when cast to a suitable type, points to the base of the object.  The pointer returned by mps_alloc and mps_reserve is a reference to the object allocated.</p>
   <p>The client application is free to represent references in any way, the only restriction being that the client application should be able to "decode" a
reference from the client representation into the MPS C interface representation and "encode" a reference from the MPS C interface representation into the client representation.</p>
   <p>An example encoding might be to "tag" pointers.  A client application might wish to distinguish between a pointer and an integer purely by their representations.  On a byte-addressed architecture where pointers are aligned to 4-byte boundaries, one way to achieve this would be to add a constant offset (between 0 and 3) to all pointers, and multiply all integers by 4 and add a different constant offset (note that this reduces the range of available integers).</p>
   <p>Concretely, imagine we represented pointers using offset 2 and integers using offset 1:</p>
   <p>
    <br />
    Pointer to object at address 0x0008:
    <br />
       0x000a
    <br />
   </p>
   <p>
    The integer 8:
    <br />
       0x0021 (8*4 + 1)
   </p>
   <p>Note that it is possible to easily distinguish between pointers and integers and to easily convert between the client application's pointer representation and the MPS C interface representation.</p>
   <p>Format</p>
   <p>An MPS object that allows you to tell the MPS how client objects are laid out.  Some pool classes require formats; these are called "formatted pool classes" and are generally the pool classes that include garbage collection. </p>
   <p>
    You must tell the MPS the format.  For information on how to do this, see MPS Format Protocol
    .
   </p>
   <p>Allocation point</p>
   <p>
    An object that allows your application to do fast in-line groups of allocations.  The MPS hands over a block of memory to your application for allocation, with the requirement that your application obey a certain protocol.  For more information, see MPS Allocation Point Protocol
    .
   </p>
   <p>Root</p>
   <p>An MPS object that you must create to tell the MPS what objects are assumed to be alive.  The MPS assumes that some things are alive, such as registers.  You must explicitly declare that other objects are alive. </p>
   <p>Thread registration</p>
   <p>
    An MPS object that you must create if you are using threads, to tell the MPS what threads are around.  For information on how to do this, see 
    <code>mps_thread_reg</code>
    .
   </p>
   <p>Location dependency</p>
   <p>
    An MPS object that tells the client application when client objects have been moved.  Some pool classes move objects around and change the objects' addresses.  For more information on using location dependencies, see 
    Using the MPS Location Dependency Interface in the User Guide
    .
   </p>
   <p>Tracing</p>
   <p>The act of following the chains of references from the roots to find all the objects reachable in this way.  We typically do this as a part of a collection, in order to find the objects that aren't garbage.</p>
   <p>Scan</p>
   <p>Locating all the references in an object and fixing them (q.v.).  The MPS does this when it needs to examine (and possibly modify) references, for example, as a part of tracing (q.v.).</p>
   <p>Fix</p>
   <p>This is an abstract term designating the operation that we're performing on each reference while scanning (q.v.) an object.  Typical things that the MPS might do are scanning the object that the reference points to (as a part of tracing) and updating the reference (as a part of a moving GC).</p>
   <p>Opaque ADT</p>
   <p>An abstract data type that you may not know the internals of.  We cannot support code that depends on the internals of an opaque ADT.</p>
   <p>Transparent ADT</p>
   <p>
    An 
    abstract data type
     that you may know the internals of.  For information on the internal structure of transparent ADTs, see the reference page for the type.
   </p>
   <p>Plinth</p>
   <p>A program module providing the MPS with all the support it needs from the execution environment.  Mainly this includes simple I/O facilities to support debugging.</p>
   <p>The plinth is provided by the client application; however, a sample implementation of the plinth using standard ANSI C library facilities is included with the MPS, and this is good enough for most applications.</p>
   <p>Client pointer</p>
   <p>Some client applications use memory layouts where the object pointers in the program point some distance into the memory block containing the object, rather than to the base of the block.  This is often because the objects have a common header used for memory management or class system purposes, or this situation can also arise when the low bits of a pointer are used for a tag.  The MPS does not care what the reason is, only about the offset of the pointer in relation to the memory block.  To be absolutely clear about where the pointers are expected to point, we call the object pointers of the client application "client pointers" as opposed to "base pointers" (q.v.).</p>
   <p>Base pointer</p>
   <p>A base pointer is a pointer to the base of a memory block.  This is the most common way of referring to an object represented by the block, but sometimes we need to make a distinction between these and client pointers (q.v.).</p>
   <h2>
    <a id='section-A' name='section-A'>A. References</a>
   </h2>
   <h2>
    <a id='section-B' name='section-B'>B. Document History</a>
   </h2>
   <table>
    <tr valign='top'>
     <td>1997-05-28 15:49:09 +01</td>
     <td />
     <td>New document saved</td>
    </tr>
    <tr valign='top'>
     <td>1997-05-28 16:46:11 +01</td>
     <td>lmb</td>
     <td>Edited from meeting notes to proto-doc</td>
    </tr>
    <tr valign='top'>
     <td>1997-05-29 11:04:44 +01</td>
     <td />
     <td>Edited</td>
    </tr>
    <tr valign='top'>
     <td>1997-05-29 12:18:39 +01</td>
     <td>lmb</td>
     <td>Added some protocols</td>
    </tr>
    <tr valign='top'>
     <td>1997-06-20 16:23:54 -04</td>
     <td>lmb</td>
     <td>Made some small edits; added some concepts.</td>
    </tr>
    <tr valign='top'>
     <td>1997-06-20 17:01:17 -04</td>
     <td>lmb</td>
     <td>Added reference concept from DRJ's format doc.</td>
    </tr>
    <tr valign='top'>
     <td>1998-01-13 12:14:23 +00</td>
     <td>pekka</td>
     <td>added definitions for 'tracing', 'scan', and 'fix'; updated space-&gt;arena</td>
    </tr>
    <tr valign='top'>
     <td>2000-05-19 17:07:08 +01</td>
     <td>pekka</td>
     <td>remove silly comments; write definition of "pool"; refer to MMRef</td>
    </tr>
    <tr valign='top'>
     <td>2000-06-05 20:06:20 +01</td>
     <td>pekka</td>
     <td>add plinth; remove all tags</td>
    </tr>
    <tr valign='top'>
     <td>2000-06-06 17:46:51 +01</td>
     <td>pekka</td>
     <td>fix xrefs</td>
    </tr>
    <tr valign='top'>
     <td>2000-07-19 16:31:20 +01</td>
     <td>pekka</td>
     <td>add client pointer</td>
    </tr>
    <tr valign='top'>
     <td>2001-09-26</td>
     <td>
      <a href='mailto:ndl@ravenbrook.com'>NDL</a>
     </td>
     <td>Converted from xml to html (second pass).</td>
    </tr>
   </table>
   <hr />
   <p>
    <small>Copyright &copy; 2001 Ravenbrook Limited.  This document is provided "as is", without any express or implied warranty.  In no event will the authors be held liable for any damages arising from the use of this document.  You may not duplicate or reproduce this document in any form without the express permission of the copyright holder.</small>
   </p>
   <div align='center'>
    <p>
     <code>$Id$</code>
    </p>
   </div>
  </body>
 </html>
