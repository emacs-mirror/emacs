                        RULES FOR C SOURCE CODE
                              rule.impl.c
                            incomplete rule
                           richard 1995-07-28

Scope: This rule set is to be used for checking C source code files; for both .c and 
.h files.


File Name

.name.form: The file name will be composed of a base name (see .name.base) of 
no more than eight characters, a period, and an extension (see .name.ext) of no 
more than three characters, in that order.

.name.base: The base name of the file will consist of letters from the lower 
case or digits; the leading character will be a letter.

.name.adt: If the source file implements an Abstract Data Type, the base name 
will commence with the name of the type, possibly truncated.

.name.plat: If the source file is platform-specific, the platform will be 
indicated by appending the two letter platform abbreviation.  See platform.* 
for the platform abbreviations.  [That's not the whole story -- drj 1999-02-10]

.name.ext: The extension will be "c" for implementation files, "h" for header 
files.

.name.tag: The corresponding tag for the document (see .head.title) will be 
"impl.c.<basename>" generically, or "impl.c.<basename>.<version>" in the case 
of a specific trunk version.


File Format

.format: Files are either .c files or .h files.

.format.c: .c files will be composed of a header (see .head), any inclusions 
(see .inc), a SRCID declaration (see .srcid), any file scope macro or type 
definitions [order?], and any function definitions, in that order.  [we also 
have forward declarations somewhere sometimes drj 1999-02-10]

.format.h: .h files with be composed of a header, the first part of a 
multiple-inclusion guard (see .multi.inc), any inclusions (see .inc), the 
declarations.  the final part of a multiple-inclusion guard.


Header

.head: The file will have a header comment composed of three paragraphs, in 
order:
  .head.title: Generic file tag (see .name.tag), a colon, and file title from 
upper case;
  .head.hopename: Hopename (form "$HopeName: ... $"), line break, copyright 
notice;
  .head.des: Short description of file purpose, and any source documents.


Inclusions

.inc: The inclusions will be as follows, in order:
  .inc.mpm: mpm.h; compulsory for any .c file in the MPM and must only be used 
by .c files in the MPM.  Tests, formats, interface glue, are not in the MPM and 
should not include mpm.h;
  .inc.local: Any local headers, the following are compulsory:
    .inc.local.used: Any headers whose definitions are lexically used (except 
where included via mpm.h);
    .inc.local.mod: The header for the module being implemented, if any.
  .inc.plat: Any platform-specific headers, permissible only in 
platform-specific files (see .name.plat).

.inc.unused: A file may be included only if definitions from it are lexically 
used (but see .inc.mpm).


Multiple Inclusions

.multi.inc: A header file shall be protected from multiple inclusion by using a 
multiple-inclusion guard.  This wraps the entire header file in a #ifndef 
directive:

#ifndef foo_h
#define foo_h

shall appear at the beginning of the file (after the header).

#endif /* foo_h */

shall appear as the last line of the file.  foo_h is illustrative and shall be 
replaced by the name of the file with the "." replaced by "_".


Checking Functions

.check.exist: Every implementation of an abstract data type shall provide a 
function to check instances of that class.

.check.name: The checking function shall have a name of the form "<type>Check".

.check.proto: The checking function shall received only one argument, which is 
of the class type, and return a Bool.

.check.sense: The checking function shall return FALSE if and only if the class 
instance is detected to be invalid.

.check.complete: The checking function shall test every field in the underlying 
structure, or document why not.

.check.brief: The checking function shall use appropriate support macros, such 
as CHECK* in assert.h, to yield a concise and obvious implementation.  [Need 
more detailed documentation.]

.check.open: The checking function shall call subsidiary checking functions, 
where appropriate, to yield an open and extensible implementation, but see 
.check.quick.

.check.quick: The complexity of a checking function shall be O(1).


Abstract Data Types

.adt.init: The implementation of an abstract data type shall have a function to 
initialise an instance of that class; the function name shall be of the form 
"<type>Init"; the function shall receive a instance of the class as its first 
input parameter; the function return shall be of type Res.

.adt.create: The implementation of an abstract data type shall have a function 
to create an instance of that class (constructor); the function name shall be 
of the form "<type>Create"; the function shall return an instance of the class 
as its first output parameter; the function return shall be of type Res.

.adt.create.init: The creation function of an abstract data type shall invoke 
the initialisation function.

.adt.create.check: The creation function of an abstract data type shall invoke 
the checking function.

.adt.dest: The implementation of an abstract data type shall have a function to 
destroy an instance of that class (destructor); the function name shall be of 
the form "<type>Finish"; the function shall receive an instance of the class as 
its first input parameter.  It shall also finish all fields of the type, as 
appropriate.  [What about Destroy?]

.adt.method: Any function which operates on, or returns data from an abstract 
data type should be considered to be a method on that class, where appropriate; 
the function name shall commence with the class name; the function should 
received an instance of the class as its first input parameter.

.adt.sig: The first field of an abstract data type structures shall be of type 
Sig and will be initialised to a signature constant, unique to the class, which 
is mnemonic when represented in hexadecimal.  [sometimes sig is not the first 
field, but there are usually good reasons -- drj 1999-02-10]


Assertions

.assert.exist: Any function that forms part of the module's external interface 
(which usually includes all functions with external linkage but also any static 
functions exported via a class mechanism), and file internal functions where 
appropriate, shall have assertions.

.assert.complete: The assertions shall check, as far as possible, all input 
parameters, the non-nullness of output or in-out parameters, and any global 
preconditions for the function.  This includes blocking any unhandled domain 
values.  If there are any unchecked parameters a comment must explain why.

.assert.brief: The assertions shall use appropriate support macros, such as 
AVER* in mpm.h, to yield a concise and obvious implementation.  [Need more 
detailed documentation.]

.assert.open: The assertions shall call subsidiary checking functions, where 
appropriate, to yield an open and extensible implementation.

.assert.doc: Non-obvious (generally non-trivial) assertions must be documented.

.assert.missing: Any dependencies which cannot be checked, must be documented.  
See also .assert.open.

.assert.init: External data (typically function parameters) must not be used 
before assertion checking.


Documentation

.doc.sec: Sections of the document should be delimited with section comments 
(see guide.impl.c.format.section.comment); a section comment applies to 
everything following, until the next section comment or end-of-file.

.doc.para: A paragraph comment applies to the following paragraph, which is 
usually to the next blank line or the to end of a block.

.doc.tag: Any code or comment which may be referred to elsewhere, either for a 
definition, or because two things must be updated in parallel, must be tagged 
(see guide.tag).

.doc.ref: Any piece of code which must be updated in parallel with something 
external to the file, or distant in the file, should have a comment referencing 
the appropriate tag.

.doc.correct: Documentation must agree with the code.


General

.srcid: The SRCID macro invocation should appear at top level and receive the 
basename (see .name.base) as a token and the hope name (formatted as 
.head.hopename) as a string as arguments.  [in fact it takes the concatenation 
of the basename and the platfornm code if any -- drj 1999-02-10]

.static: Static data should only be used where absolutely necessary, e.g. 
constants, once-initialised tables.

.varargs: Where a function receives a variable length argument list, denoted by 
an ellipsis (...), there shall be a corresponding function which receives a 
parameter of type "va_list" and name "args" in place of the ellipsis; the name 
of this function shall be composed of the name of the original function, 
followed by "V".

.cast.correct: Casts should be used where appropriate to ensure correct 
promotions and convertion behaviour, e.g. in varargs, for constants.

.cast.avoid: Casts should be avoid in preference to conversion functions or 
macros where appropriate.

.ansi: The ANSI library functions should be used via the sanitised forms 
delcared in mpslib.h which can be assumed to have been included via mpm.h, 
except when used as platform-specific versions (set .name.plat).

.cond: Conditional expressions should be of boolean type, without 
side-effects.  [what no function calls?  surely not.  drj 1999-02-10]

.return: Output (returned) parameters must be suffixed with "Return", and come 
before in-out or input parameters.

.io: In-out (modified) parameters must be suffixed with "IO", and come after 
output parameters and before input parameters.  An instance of an abstract data 
type whose value is modified in a method (see .adt.method) is not an in-out 
parameter.

.magic: Any "magic" values (typically other than 0, 1, and -1) should be 
documented and, where appropriate, assigned to constants.

.atomic: Updates should be as atomic as possible; code should avoid leaving 
data in an inconsistent state.


Exception handling

.exc.test: Status (typically Res) returns shall be tested against success 
(ResOK).

.exc.clear: Exception behaviour shall be clear.

.exc.correct: Exceptions shall be propagated appropriately.

.exc.ret: If a function returns an exceptional status, its returns have 
undefined value and must not be used.


Macros

.macro.fun: Function-style macros shall be named as for functions, and shall 
have function implementations.  [What about DEBUG_NOINLINE?]

.macro.const: Constant-style macros shall be named as constants.

.macro.special: Macros with special form or side-effects ( e.g. take type 
parameters, affect control flow, do token pasting) shall have names entirely 
from the upper case.

.macro.multi: Any macro which expands to multiple statements should use BEGIN 
and END from misc.h.  [What about MPS_BEGIN and MPS_END from mps.h?]

.macro.wrapped: Any macro shall be wrapped with BEGIN and END (for macros 
expanding to statements) or parentheses (for macros expanding to expressions) 
or have a good reason why not.

.macro.paren: Macros parameters should be parenthesized in the definition, 
except for token pasting or stringization.  Even where they are already 
parenthesized for syntactic reasons.  For example: "#define foo(x) (bar(x))" is 
bad; "#define foo(x) (bar((x)))" is good.


Obsolete Rules

[The following are obsolete legacy rules and should not be used.  They are 
candidates for rewriting, however.]
[many of these belong in a guide not in this ruleset (which is already massive) 
-- drj 1999-02-10]

/ indicates incorporation into the above document as of 1999-02-10  drj 
1999-02-10

.REAL           Deal with the real problem and not just the symptoms.
.EXT            Externally visible changes must spawn tasks to change external 
documentation.
.DOC.MISSING    Missing documentation is a defect.  Create it.
/ .DOC.UPDATE     Documentation must be updated consistently with the code.
/ .DOC.LEADER     All files must start with a correctly formatted leader 
comment of the form header: title, HOPE ID, copyright, description, properties, 
notes; source: title, HOPE ID, copyright, description, implementation details, 
notes.
.DOC.TYPE       Type declarations must document the properties of the type.
.DOC.FUN        Function interfaces must document the properties of the 
function.
.DOC.FIELDS     Aggregate fields must be described.  Informative terse comments 
will do.
/ .DOC.ASSERT     Non-obvious assertions must be documented with nearby 
comments.
/ (in modified form) .STD            std.h must be included first, except after 
header wrapper.
.IMPORT         Check that all referenced headers are included.
/ .MULTI          Headers must be wrapped in #ifndef foo_h/#endif.
.METHODS        Abstract types must have (Create/Destroy|Init/Finish)/IsValid 
methods.
/ .NO-STATIC      No static data except constants or once-initialized tables.
.MACRO.FUN      All macro methods must have function implementations.
.MACRO.CONTROL  All macro methods must be wrapped in a test for DEBUG_NOINLINE.
.OPT            Optimize appropriately.  Optimization effort must be 
justifiable.
.STYLE          Formatting must be clear and consistent.
.COVER          Cover all points in the domain correctly.
.INIT           Variable initialization may only occur after consistency checks.
/ .RETURN         Return values may not be ignored if they contain error 
information.
/ .COND           Conditionals must be boolean expressions without side effects.
/ .OUT            Return parameters must be suffixed with Return.
/ .ERROR          Error information may not be buried inside other returned 
values.
.IGNORE         Ignored results must be cast to void.
.VARARGS        Varargs and constants often need casting to get the right 
promotion.
.LIMIT.ONCE     Declare limitations once.
.LIMIT.EXHIBIT  Exhibit limitations to the client.
.LIMIT.JUSTIFY  Limits must be justified thorougly in a comment nearby.
/ .MAGIC          Avoid "magic" or "special" parameter values.  Document them 
thoroughly.
.RANGE          Ranged values must be checked.  Be careful with the endpoints.
/ .MACRO.MULTI    Multiple statement macros must begin M_BEGIN and end M_END.
/ .MACRO.PAREN    Macro arguments must be parenthesized except when used with # 
or ##.
.PAREN          Complex non-arithmetic expressions must be parenthesized.
.PROTO          All objects with external linkage must be prototyped in the 
interface.
/ (as magic) .CONSTANTS      Avoid constants in code except 0, 1, or -1.  
Document others.
.SUBTLE         Subtle or tricky code must be documented, including hazards.
.DEPEND         Uncheckable dependencies must be documented conspicuously.
.SYMMETRY       Responsibility is symmetrical: code which creates must also 
destroy.
.FAILURE        Methods may not update return parameters on faiure.
.CLEANUP        Functions must clean up completely on error.
/ .ATOMIC         Update state atomically.  Don't update with unfinished 
structure.
.RETURN         When functions have multiple return parameters, make sure you 
set them before returning.
.SIG            Descriptor structures must be signed if DEBUG_SIGN is defined.
.VALID.FIELDS   IsValid must check every field in the descriptor structure.
.VALID.SIG      IsValid must check validity of signature, when used.
/ .VALID.COMPLEX  IsValid should be of complexity O(1).
/ .VALID.ARGS     Functions must assert the validity of all arguments.
/ .VALID.NEW      Construction code must assert the validity of constructed 
objects.


