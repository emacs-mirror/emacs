                  PROCEDURE FOR DEVELOPMENT BRANCHING
                            proc.dev.branch
                            incomplete proc
                           richard 1996-04-15


INTRODUCTION

.scope: This is a procedure for identifiable "stages" of development which 
affect multiple source files.  The procedure should be applied for all such 
development tasks.

.aims: An important aim of this procedure is that the trunk of the source code 
should always be in an approved working state.

.note.global: Don't forget that checkpoint and branch names are global in HOPE, 
so we must use "MM" to prefix them all.  The prefix for development branches 
(as opposed to release, QA, etc.) is "MMdevel_".



.fig.1: How changes (deltas) get merged from branch to trunk.
 - proc.dev.branch.fig.1 


PROCEDURE

.tag: Think of a name (tag) for the branch (shown as "X" below).  You may want 
to include your username in the tag (e.g. "gavinm_foo").

.select.compound: Select the compound you want to branch.  Normally this is 
MMsrc.

  select -compound MMsrc

.select.base: Select the place you want to branch from.  Normally this is the 
tip of the trunk.

  select -branch trunk

.create: Create a branch at the selected point.  The branch name is "MMdevel_" 
followed by the tag, shown below as "X".

  branch -label MMdevel_X

.select.branch: Select the branch, and do the development work.  You are 
responsible for the branch, and for the status of the stuff on it.  Other 
people should check with you before using it.

  select -branch MMdevel_X
  co -claim soft ...

.review: Have your changes reviewed, and edited.  [We could use checkpoints to 
record stages of review and edit -- richard 1996-04-16]

.merge: Merge changes back to the trunk once they have been approved.  
[Unfortunately, this is currently a lie -- gavinM 1997-04-07]  Unfortunately, 
merging doesn't automatically add new files or remove files, so if you've done 
this on the branch you'll need to carry across those changes manually to the 
trunk (see .merge.add and .merge.remove).

.merge.note: Merging the branch changes is essentially the same as making an 
edit to the trunk -- it's just that the edit is the differences between the 
base and tip of the branch (see .fig.1).  The following example commands assume 
you have the compound selected as in .select.compound, and the base branch 
selected as in .select.base.

.merge.claim: In a new source directory, check out the compound and claim the 
units on the trunk which are going to be changed.

    co    
    report -branch MMdevel_X -versions MMdevel_X.2:
[ May also show new files.  gavinm 1998-08-04 ]
    co -reason "Merge of MMdevel_X" -claim soft unit1 -and unit2 -and ...

.merge.new: Check out any units which are new in the branch into the directory 
containing the merged files.

    report -branch MMdevel_X -type add
    co -branch MMdevel_X new-unit1 -and new-unit2 -and ...

.merge.merge: Merge the changes.  This modifies your checked-out files.  This 
is where most of the "edit" is done -- see .merge.note.  The version string 
"MMdevel_X.1" refers to the lowest version of everything on the branch, i.e., 
the point at which the branch was created.  This command therefore applies all 
edits made in the branch into the checked out files (see .fig.1).

    merge -base MMdevel_X.1 -branch MMdevel_X -ignore keywords

.merge.manual: Hope should warn you if there were overlapping changes between 
your edits and other work on the trunk.  Fix up any overlapping changes or 
remove similar problems.  Tip: Grep your source for "<<<".

.merge.test: Test the result and fix up problems.  A merge is an arbitrary 
edit, so make sure it works.  At this point, you have a working merged set of 
sources checked out from the trunk.  Now you need to get them checked in.

.merge.inform: Tell everyone that there's about to be a change if it's 
significant.  You might consider composing a mail message describing the 
changes, since they're going to affect everyone else.

.merge.add: Add any units which are new in the branch to the trunk.

    add -reason "Merge of MMdevel_X" new-unit1 -and new-unit2 -and ...

.merge.ci: Check in the changed units.  If someone else has made a change to 
the trunk this will cause a Hope error and you'll have to merge those changes 
by using the "merge" command alone, probably.  It's not clear whether Hope will 
partially succeed in this case.  It's best to avoid it by making sure everyone 
is co-operating at this point.

    ci unit1 -and unit2 -and ...

.merge.remove: Remove any files made obsolete by the changes from the branch.

    remove obsolete-unit1 -and obsolete-unit2 -and ...

.merge.all: You can also do the merge by claiming the whole compound.  This is 
useful for large merges, because you don't have to determine which files have 
changed (but you still need to determine your adds and removes), but you'll be 
disrupting other development more.  The procedure is the same as above, except 
that you omit the unit names from the co and ci commands, and use the 
'-unmodified abandon' switch in the ci command.  Note that this will go wrong 
if you already have any claims in the same compound, so make sure you don't 
have any if you're going to do this.

.test: Check out and test the trunk in a new directory!  Fix up any problems.


