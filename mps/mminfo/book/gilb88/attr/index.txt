                         ATTRIBUTE REQUIREMENTS
                            book.gilb88.attr
                               draft doc
                           richard 1995-09-18

INTRODUCTION

This document contains extracts from book.gilb88, mainly from "Software 
Engineering Templates", a chapter which describes an attribute requirements 
tree in detail.  The text is mainly Gilb's but the structure and tags are mine.


SUMMARY

qualities
  working ability
    speed
    throughput
    responsiveness
    storage capacity
  availability
    reliability
      mean time between failure
    maintainability
      recovery time
        problem recognition
        administrative delay
        tool gathering
        problem analysis
        solution formation
        inspection
        deployment
        testing
        test evaluation
    integrity against attack
      integrity against various attacks
      comparison with standard security ratings
  adaptability
    improvability
    extensibility
    portability
  usability
    integration effort
    entry requirement
    learning effort
    handling effort
    niceness
resource
  time
    deliveries
  people
  money
  machines
  tools
  goodwill
  reputation
  image


QUALITIES

Working Ability

.qual.work: "Working ability" measures the raw ability of the system to do 
work.  This is the same as "performance" in the narrow sense, not including 
availability and usability.

.qual.work.tp: "Throughput" is a measure of the ability to process units of 
work in units of time.  .attr.qual.work.tp.unit: work unit / time unit.  
Examples: transactions per second, records per minute, bytes per line, bits per 
node per second.

.qual.work.resp: "Responsiveness" is a measure of the reaction time to a single 
event.  .qual.work.resp.unit: actions per time unit under stated conditions.  
Examples: time from question understood by operator until answer displayed on 
screen under no load; response time (when worst case activity load exists); 
time until beginning of execution of a logic page not in primary memory; time 
from telephone contact established with client until satisfactory delivery of 
an answer is completed (assuming no load on central processing facility or 
lines).

.qual.work.cap: "Storage capacity" is the capacity of the system to store units 
of a defined thing.  .qual.work.cap.unit: units stored per container.  
Examples: bytes per record; characters compressed per 1000 bytes of storage; 
characters per line (bold double-size format); source instructions; colour 
pictures per diskette; sound syllables per 1000 bytes.

Availability

.qual.avail: "Availability" is a measure of how much a system is usefully (not 
merely technically) available to perform the work which it was designed to do.  
Availability is determined by a set of ideas: reliability, maintainability, and 
integrity.  Scale: probability that a system is operating satisfactorily at any 
point in time, when under stated conditions.

  availability (general measure) =
    [time actually available] / [time that it should be available].

  intrinsic availability =
     [operate time] / [operate time + active down-time]
  or [mean time to maintenance] / [MTTM + active down-time]

  operational availability =
    [operational time] / [operate time + off time - total down time]

  (total down time = active down time + down time when system not needed)

  use availability =
    [operate time + off time] /
    [operate time + off time + total down time]

Examples:
  - % time database contents actually available to requests during office days 
per month;
  - % time correct and up-to-the-minute updated material available immediately 
to requester;
  - % time a remote and foreign node is available;
  - % time a printer on the same office floor as user is available to begin 
printing within one minute;
  - % time which the up-to-last-night maintenance changes to logicware are 
available from local storage, offline to main processor centre.

Reliability

.qual.avail.rel: "Reliability" is a measure of the degree to which the system 
does what it is intended to do, as opposed to something else (like producing 
the wrong answer or producing nothing).  Definitions of reliability will 
therefore vary according to the definition of what the system is supposed to 
do.  In general, a system which is not doing what it is supposed to be doing 
(an unreliable state) is 'unavailable' for its intended work.

Reliability is a very general measure, because it can take so many different 
definitions, depending on what we decide to define as the 'right thing'.  
Reliability is simply 'doing what the system ought to', and we must have a 
clear definition of what 'ought to' means before trying to measure 
reliability.  Software reliability, one critical part of system reliability, 
can fruitfully be specified and controlled for the different software 
subsystems.

.qual.avail.rel.lw.fid: "Logicware fidelity" is the measure of accuracy with 
which a given algorithm has been implemented for a specific software and 
hardware environment.  Does it work as intended?  For example are mathematical 
functions within real number tolerances?  Does it work correctly to 
specification and verification?

.qual.avail.rel.lw.ver: "Logicware veracity" is the measure of the adequacy 
with which the implemented algorithm relates to the real world with which it 
must interact.  Does it do what we would want it to do when we find out about 
how the 'real world' really is now?  Does it solve the user's problem?  
Validation.

.qual.avail.rel.dw: "Dataware" is the 'passive' data in the system (inputs, 
outputs, files, and the store programs, as opposed to the 'active' algorithm: 
the program being executed).  A program can be viewed in both lights, since it 
is stored data and may consume critical resources -- or may be actively 
interpreted as a logical process.

.qual.avail.rel.dw.fid: "Dataware fidelity" (or precision) is the measure of 
the accuracy of representation of an idea within a particular software and 
hardware environment.  Does the data representation lose any information which 
we would want to keep (because of abbreviation, compression, batch sums)?

.qual.avail.rel.dw.ver: "Dataware veracity" is the measure of the adequacy with 
which data represents the 'real world' to which it is suppose to refer.  Does 
it give a true picture or a misleading one?

.qual.avail.rel.dw.via: "Dataware viability" is the measure of how well the 
data meets the design constraints in areas such as retrieval timing, storage 
space, and security.

Maintainability

.qual.avail.maint: "Maintainability" is a measure of how quickly an unreliable 
system can be brought to a reliable state.  In general this will need to cover 
not only the repair of the fault, but recovery from the effects of the fault, 
so that the system is ready again to do its intended work.  From a technical 
system point of view, there may be little or no difference between 
maintainability and improvability.  The difference is mainly the subjective one 
of deciding what is a fault needing maintenance, and what will be considered 
'faulty' in the future if we do not improve it.

Maintainability can be exploded into several typical sub-attributes, not all of 
which are useful in every case.  This explosion is useful when the expected 
maintenance costs are high, and rapid and sure maintenance is important.  This 
explosion will allow designers to focus on the several very different 
components of maintenance, and reduce the danger of lack of sufficient design 
for any one of them.

The term maintainability is conventionally reserved for the process of fault 
handling, rather than for improvement of a faultless system.

.qual.avail.maint.pr: "Problem recognition" is the time needed for people or 
machines to recognize the existence of a fault in the system which needs repair.

.qual.avail.maint.admin: "Administrative delay" is the time required after the 
problem is recognized, until someone or something (such as a 'distinct 
software' module) is activated to the task of correcting the fault.

.qual.avail.maint.tool: "Tool collection" is the time needed to collect the 
documentation, analyse the programs, the test sets, the result sets, and the 
files which are necessary for analysing the nature of the fault.

.qual.avail.maint.anal: "Problem analysis" is the time needed to trace the 
symptoms of the fault to its source.

.qual.avail.maint.corr: "Correction hypothesis formation" is the time needed to 
translate the understanding of the current cause of the fault into a suitable 
correction action idea.

.qual.avail.maint.insp: "Inspection" is the time needed to inspect (Fagan's 
method) the correction hypothesis for consistency and correctness with regard 
to the local change, and with regard to the total system.

.qual.avail.maint.act: "Active correction" is the time needed to carry out the 
inspected correction hypothesis correctly.

.qual.avail.maint.test: "Test" is the time needed to run adequate test cases to 
validate that the change is working as expected, and that there are no 
undesired side-effects as a result of it.

.qual.avail.maint.rec: "Recovery" is the time needed to recover from the fault 
and restore files.

This definition (problem recognition through to recovery) is intended to force 
technologists to define 'maintainability' from a user point of view, rather 
than a repair technician's point of view.  Software engineering management 
should 
ensure that this wider view is adopted.

Integrity

.qual.avail.int: "Integrity" is a measure of the trustworthiness of the 
system.  Is it in the state it is supposed to be in?  Has it been altered by 
persons or by accident, or has it been tapped for information (which is now 
less secret that supposed)?  Integrity is the result of various built-in 
security techniques used to detect or thwart those attacks.  A system which 
does not have its full intended integrity may be 'available' in the technical 
sense, but the intended results may not be available, due to reduced integrity. 
 If you got some garbage in there, you risk delivering that garbage, unless 
your design captures it before it gets out.

The integrity of a system is a measure of its ability to survive from attacks 
by threats to its integrity, by means of a suitable security design 
technology.  Integrity is an objective of the system user.  It is a cousin to 
the idea of availability.  Threats are potential attacks on the system 
integrity (both accidental and intentional).  Security techniques are devices 
for counteracting the attack.

.qual.avail.int.threat: "Threat" (of attack on system integrity) is measured by 
an estimated probability of an attack of a specific type occurring within a 
time frame.  A threat potential can be analysed and estimated, however great 
the uncertainty.  It can also be controlled by the system designer, and may 
well be set up as a design objective.  A threat can be defined to cover any 
'error' producing a type of attack, from humans (intentional or not) or 
machines (hard or soft).

.qual.avail.int.sec: "Security" (the potential to counteract threats on system 
integrity) can be measured as the probability of counteracting attacks of a 
particular type.  In the most general view of the system, both maintainability, 
recovery, and even improvability represent ideas of 'security' (of keeping the 
system in the state you want it to be in).

.qual.avail.int.att: The types of attack which must be considered by the 
software engineer include: attacks on logicware (corruption, stealing, 
disabling), attacks on dataware (corruption, stealing of knowledge, 
eliminating), attacks on paperware (documentation, instructions, training).

.qual.avail.int.sys: In addition, the software engineer must make sure that the 
related aspects of people and machines and premises are handled by the system 
engineering level of design.  Software cannot exist or be secured in a vacuum 
apart from the hard factors within which it operates.

.qual.avail.int.arith: Integrity is arithmetically related to threat frequency 
and security effectiveness.  Note that the mathematical relationship between 
these three ideas; integrity is a function of the threat potential and security 
strength.  Knowing two of these factors allows you to calculate the third.  But 
to be realistic, you must work it out on a threat type by type basis.  The 
combined set of type calculations gives you total integrity, security, or 
threat potential for the system.  The simple formula is:

  integrity = sigma (1 - threat * (1 - security))

Adaptability

.qual.adapt: "Adaptability" is the measure of a system's ability to change.  
Since any system can somehow be changed to almost any other state, given enough 
resources, the primary concern is with the need for resources (such as time, 
people, money, and tools) needed to make a certain degree and type of change.  
So, adaptability is a measure of a system's ability to change 'efficiently'.

.qual.adapt.improv: "Improvability" is a measure of the efficiency of making 
minor adaptations, changes, and improvements of faults, except for the fact 
that there is no 'fault' (yet, or at this time) with the system, only with the 
desire to improve.  The basic measure is time to change the state of the 
system, which depends on a clear definition of the degree of change to be 
effected (for example, one instruction, or 2000 records, or 100 pages of 
documentation, or a combination of these).  Improvability, like its sister 
maintainability, can be exploded into about ten interesting sub-measures of the 
change process.  The only difference is that there is a reaction to future 
definitions given in the corresponding maintainability steps, but note that the 
concept of a fault or a problem needing 'correction' is exchanged with the 
concept of a 'change need', and instead of recovery, there is no fault to 
recover from.

.qual.adapt.ext: "Extendibility" is a measure of the ease of adding new factors 
to an existing system.  In order to define it you will need to consider the 
degree of extension (functions, lines of logic, data) the cost for the 
extension in resources invested, and the impact (side-effects) of the extension 
on any critical properties of the system, such as performance, security, 
reliability, and running cost.

.qual.adapt.port: "Portability" is a measure of the easy of moving the system 
from one environment to another.  To define it you must consider the size of 
what is being transported, the original and target environments 
('compatibility'), the means of transport (hand conversion, automated 
conversion), the resources needed to transport the system, and the attributes 
of the new system compared to the old (side-effects).

Usability

.qual.use: "Usability" is the measure of how well people are going to be able 
and be motivated to use the system practically.

.qual.use.entry: "Entry requirement" is the measure of the human requirements 
for success in learning and handling the system.  This might be expressed in 
terms of physical requirements (vision, hearing, manual dexterity) and in terms 
of intelligence, education, culture, or vocation.

.qual.use.learn: "Learning requirement" is the measure of resources, 
principally time, needed to attain some measurable level of ability with the 
system -- for example passing a test.  The tests could be set at several levels 
of proficiency -- giving several learning requirements.  Further, the learning 
requirement would be expected to vary with the entry level capability of the 
subject, and other factors (teacher, motivation).

.qual.use.hand: "Handling ability" is the net productivity over time, when 
error time is deducted.  The handling ability can be specified differently for 
different classes of entry level people, who have undertaken defined learning 
processes.

.qual.use.like: "Likability" is the measure of how well people like to use the 
system.  This could be measured by opinion surveys, for example.  It might also 
be measured by turnover rates of employees.  If people are negative in their 
attitude towards the system, many critical factors might be threatened, even if 
productivity is high.  The most dramatic examples occur when trade unions 
refuse to accept such systems (such as newspaper typesetting done by reporters).


RESOURCES

.res: Resource attributes are measures of the costs of existence (development, 
use, and maintenance) of a system.  We are primarily concerned with critically 
limited resources here, because they must be identified so that we can design 
appropriate solutions within this limit.  We also need to tell the designers 
which resources are most scarce in this particular case.  The worst case 
levels, and planned levels of each resource will tell the designer what to aim 
for.  Resource requirements are a 'budget' concept.  Resources belong to the 
category 'attribute' because they quantitatively describe dimensions of 
function.

.res.time: "Time" covers two aspects of development: calendar time elapsed to 
build a system (when will it be delivered?), and working days needed to 
accomplish a task.

.res.people: "People" covers all people-related resources such as 'work years' 
to construct a system, and people needed to staff or operate it.

These serve as limiting objectives or 'constraints' when designing a system, 
and when controlling its resource consumption in operation.  If a goal was set 
that a system would only require one human clerk operator per terminal per day, 
and in practice it required two (because of legal regulations concerning 
continuous hours sitting at a terminal) then there is some evidence for design 
error -- and perhaps a need to redesign the system.

.res.money: "Money" covers all types of monetary costs of building and 
maintaining the system.  'Maintenance cost' would fit in here, even though 
maintainability is also specified as a quality.  Money is a budget limit.  
Maintainability is a quality which has some influence on whether we stay within 
that budget limit.

.res.tools: "Tools" could also have been called 'plant'.  It covers the 
physical resources which can somehow be limited, and can be critical to 
success.  It includes computer capacity (use of any sort of computer and 
communications hardware), office space, air conditioning capacity, and the 
rights to use software packages and designs.

