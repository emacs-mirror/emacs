                        REVIEW OF IMPL.C.LO(29)
                          review.impl.c.lo.29
                           incomplete review
                           gavinm 1997-06-18

Rules: rule.impl
Source: design.mps.poollo(0, incomplete)
Candidate status: draft

Author: drj
Leader: gavinm
Editor: drj
Scribe: gavinm

Entry: entry.universal, entry.impl
Entry manpower: .2


Entry notes:

entry.universal.source-approved: Design in incomplete, but may be used.
entry.universal.training: As usual
entry.impl.auto-check: Verson 28 fails compilation because of "harmless" code rearrangement.  Version 29 revised.


Loggingstart: 15:34 BST (10:34 EDT)
Loggingend: 15:57
Logginglength: 22
Loggingrate: 2.6

Checkers: GavinM (source;correctness);DRJ (source;consistency;backwards);PTW (source;clarity)
Rate: 10
Length: 609
Actual checking time: 202

Kickoff start: 1997-06-18 14:00 BST (09:00 EDT) Pool Hall
Kickoff end: 14:07

Kickoff notes: Try to beat 1.8 issues/minute logging.


ISSUES:

PTW: 3M 7m 2q 11I -- 54 minutes
GavinM: 4M 14m 5q 3I -- 74 minutes for lines 1-460
DRJ: 1M 5m 2I -- lines 280-209

1. DRJ 236 M design here is critical 
2. PTW - M .req Are only "C" leaf objects supported by leaf pools, or are 
"Dylan" leaf objects supported (despite their having a reference -- the 
wrapper).
3. PTW 132 M .clear Why is the allocated range not marked allocated?
4. PTW 529 M .design This seems like the wrong modularity, to have the pool 
know the semantics of WEAK
5. GavinM 181,188 M Modularity: BTSize return is not guaranteed to be rounded 
to the word size
6. GavinM 229 M Don't invalidate sig
7. GavinM 309 M Why such a weak check?
8. GavinM 386 M Don't check buffer
9. DRJ 177 NM this is a stupid trick
10. DRJ 358 m this should tagged and in the design
11. DRJ 393 q surely the size should already be aligned?
12. DRJ 515 m we seem to get from alignment the wrong place (pool not format)
13. DRJ design.mps.poollo I the whole question of alignment is unclear
14. DRJ 583 m justify not having a describe method
15. DRJ 588 m the function seems to be completely useless and so does impl.h.lo
16. PTW design.mps.pool I  .def.leaf roots in pool must not move (or be updated 
in any way)
17. PTW design.mps.pool I  .overview.ms.justify what are the cons? cost of 
bit-tables?
18. PTW design.mps.pool I  if.init.format Format A needs a better descriptive 
name
19. PTW design.mps.pool I  Should there be a root structure associated with the 
pool that enumerates all the roots in objects in the pool?  That is scanned at 
Ambiguous time?
20. PTW design.mps.pool I  Should buffer allocation automatically capture 
roots?  E.g., should there be a separate buffer for each Dylan type so that the 
wrapper is known to be captured (and the wrapper can be AVERred to have no 
other roots in it)?
21. PTW design.mps.pool I  .group.diagram Fit to one page
22. PTW Segments I  How many pools need more than just a ³p² field.  Would more 
pool-specific fields in segments descriptors be better than pools implementing 
groups?
23. PTW 46 m .purpose The purpose of a group is simply to associate the 
bit-tables with the segment.
24. PTW 98 m .clear non-descriptive names
25. PTW 116 m .clear This seems to be the wrong place to be checking this
26. GavinM - IN The concepts of groups should be glossed somewhere.
27. PTW 125 I  Bit tables should store their size
28. PTW 177 q .design Are separate allocated and mark tables necessary?  
Condemned=>Mark
29. PTW 231 m .clear This is not the reverse order in which members are 
allocated
30. PTW 266 q .clear Why would we try to reclaim a group that is buffered?
31. PTW 295 m .clear Needs a reference to trace design
32. PTW 298 I .design Should there be some hysteresis on destruction of groups?
33. PTW 487 I .clear trace->ti needs a more descriptive name
34. PTW 515 m .clear Explain what is being done, how this is an approximation
35. PTW 515 I .clear fix.protocol shoul have separate call for FINAL and WEAK 
to discover was-marked
36. PTW 521 m .clear Why are FINAL and WEAK the same as EXACT?
37. GavinM 50-51 m Type is inconsistent with design, but probably correct
38. GavinM60 m Modularity breach: access of seg structure member buffer
39. GavinM 66 m Redundant parentheses
40. GavinM 78,79 I BTCheck?
41. GavinM 95 m Unnecessarily abbreviated formal parameter names
42. GavinM 125,226 q How expensive is this calculation compared with an extra 
field?
43. DRJ design.mps.poollo NI buffered memory should be allocated
44. GavinM 108,163 q Why does the client know about alignment on allocation, 
but not on creation?
45. GavinM 175 m Modularity: access of seg structure member p
46. GavinM 192 m Modularity: access of seg structure member white
47. GavinM 210,416 m Suggest: AVER(res != ResOK)
48. GavinM 250-251 m Odd unsymmetrical use of base and limit
49. GavinM 243,254-257,264 m i and j are different types
50. GavinM 262 m Loop invariant
51. GavinM 280 m Suggest: AVER not marked
    DRJ: (we can't)
52. GavinM 295 m Modularity: access of seg structure member white
53. GavinM 297 m Suggest: AVER invariants for value of marked 
54. DRJ design.mps.poollo NI make it clear what happens with AMBIG fixes
55. GavinM 303,330 m static functions should start with a lower case letter
56. GavinM 339-340 I Could we have a more robust ring iterator?
57. GavinM 341-349 q Why not use part.impl.c.ring.iter
58. GavinM - q Why is This not impl.c.poollo?
59. GavinM design.mps.poollo.group.mark q Is the mark sense constant or 
alternating?  How do I tell what it means?



Brainstorm start: 16:05
Brainstorm end: 16:34
Brainstorm length: 29


BRAINSTORM:

[ Constructed freely from irc.review.1997-06-18.]

Issue 3:
PTW: 132 M .clear Why is the allocated range not marked allocated?
DRJ: though this decision in the design it is not necessarily the correct 
decision
PTW: It is not justified
GavinM: Do we only ever allocate by buffering?
DRJ: Yes, the only way to allocate is by buffering.
PTW: Is that documented?
DRJ: design wasn't revised in view of subsequent experience
PTW: So we don't have the case where we allocate "around" the buffer to avoid 
decaching the buffer on one big object?
DRJ: AWL treats the alloc bits as you might expect.
PTW: It would seem more honest to mark buffered as allocated.
GavinM: How did this happen?  How could it have been prevented?
DRJ: this design is first thing that came into drj's head
GavinM: Perhaps some guidance on writing this sort of pool?
PTW: It would mean you wouldn't have to look at buffer specially later
GavinM: Maybe we should only write things we've written before.
DRJ: write it and then throw it away
GavinM: Always throw away your first attempt.
  PTW: Perhaps modifying an existing pool rather than writing a new one?
  GavinM: Like PoolEPDL?
  DRJ: comparing AWL and LO would be interesting exercise
GavinM: But this breaks our rule about don't copy-and-paste.  Rather have 
common code.
PTW: Yes we need a common M&S core.  Why could this not be based on the copying 
pool?  You would not need the simplicity of M&S if you could base your pool on 
a known working pool.
GavinM: Can we base pools on each other?  Could AWL and LO have used common 
code?
PTW: At some point trying to create commonality leads to complexity
DRJ: ptw is right.  It is also interesting to write a mark and sweep pool.
PTW: But it is the wave of the future -- component software
DRJ: Pool wasn't written with enough experience, or modified in the light of 
experience.
PTW: Pool or design?
DRJ: Design.  Not that the design was written down before the pool as 
implemented.  When you create a design of a new thing that is like an old 
thing, it is likely to be better in ways that can be applied to the old design.
PTW: A common implementation can be improved simultaneously.  If you have a 
common implementation, there should only be one design!
GavinM: What part of the process do we fit this followup into?
DRJ: After having written the design... go and look at the designs it is 
similar to.
PTW: New rule:  Don't create a new design without justifying why existing 
design cannot be adapted to the task.
DRJ: yes ptw's rule is good

Issue 4:
PTW: 529 M .design This seems like the wrong modularity, to have the pool know 
the semantics of WEAK
GavinM: Might we have common weak code?
PTW: Is it just that the WEAK design is not finished?
DRJ: either weak design is not finished or is not sufficiently well justified.
GavinM: Ought to have design for ranks.  We certainly ought to have more 
placeholders.
PTW: Perhaps PTW should be better informed?
GavinM: Is it possible to abstract knowledge about weakness outside specific 
pool classes?
PTW: Yes.  Here the pool is fixing the reference from _another_ pool to meet 
the weak semantics.
GavinM: PTW is in the intended readership.
DRJ: Certainly there are more abstract implementations of weak
GavinM: Process improvements?
PTW: To me, the pool the reference originates should be responsible
DRJ: wrong design?
PTW: More review
GavinM: That's not what review's for.
PTW: More peer review?
GavinM: More RFC.
DRJ: ah.  more design then.  experiemce at creating design will naturally lead 
to us writing better design.  surely
GavinM: Perhaps we should have a proc.rfc
PTW: Approval of designs before they can be implemented?
GavinM: That would involve writing them.
DRJ: ptw's suggestion about improving rfc is good
PTW: Not neccessarily.  Must approval be on a written document?
DRJ: usually designs are written in sketch first, surely this can vbe rfced 
before impl?
PTW: Or must we just have buy-in from more than one member of the group?
GavinM: It makes the justification network harder. (See design.infosys.req.just)
DRJ: ...surely this can be RFCed before implemented
PTW:: Exactly.
PTW: Do we need a chief architect and a chief anti-architect?
DRJ: tick
GavinM: Partner-in-crime idea.
PTW: responsibility for reviewing design must be assigned as a task.  Devil's 
advocate.

Review process:
DRJ: would it possible to put the role documents so that each document is one 
line?
GavinM: I find it helpful to remember what I'm doing by what I've been handed 
by me.
DRJ: in general I still seem to have a mountain of paper.
PTW: I can listen while I type, but I can't talk while I type.  Is this a 
problem?  Is the phone useful or useless?
DRJ: this review spent ages looking through all the paper
GavinM: I think about it.
PTW: I guess I would like a hardbound guide that I could mark with sticky notes.
GavinM: Ah,  You will.

GavinM: Two of us didn't finish.  Why?
DRJ: dunno.  I find I can only say what I'm typing if I am typing.
GavinM: I spent a lot of tim eon the design document..
DRJ: I was kibbitzing dylan problem going on in same room
PTW: I took the liberty of reading the design document before review started 
(for the first time!)
GavinM: The estimated checking time makes no allowance for source documents.  
Is that right?
DRJ: I think review shoudl include time for looking at source
PTW: I wouldn not have finished otherwise.  Is it really not allowed to 
"prepare" by reading source?
GavinM: Yes.  It is allowed.
DRJ: I think ptw is right.  should eb allowed to read source before review

Issue 9:
GavinM What about DRj's "stupid trick"
PTW: Don't use stupid tricks?
DRJ: Predates BT module.  It is annoying to write gotos and labels
PTW: It's simply a buffer fill and allocate from buffer.
GavinM: Wouldn't be an issue with a proper BT type.
PTW: Maybe it is not a trick?
DRJ: indeed it is
PTW: If MPM had internal buffers, it would not be a trick.
GavinM: Perhaps we should leap to optimise space and eliminate error handling 
prematurely?
DRJ: of course, problem with buffers is that they need a moving MM to get lots 
of contiguous space to work efficiently.
PTW: Perhaps we should have internal buffers because this will be a common 
problem.
GavinM: It's a general problem with internal data structures.  We don't handle 
them cleanly.
PTW: Don't really need a moving mm if most of your internal structures stick 
around.
GavinM: If only we had a memory manager.
DRJ: EP have an atomic "allocate me this load of heterogenous objects" (using 
an array of sizes as it happens
PTW: And the ones that don't are "resourced"
GavinM: That's a good idea.
PTW: Yes.  EP's thing is just a buffer in disguise.
DRJ: except it can allocate each object in a different place.
PTW: Time pressure
GavinM: But why doesn't this come up in writing?
PTW: Human nature?
DRJ: time now is more expensive than time in the future.
PTW: Does an implementation have to get Approval before it can enter review?
GavinM: Review should only find defects that could reasonably have been found 
in writing.
Richard: Review shouldn't find defects.



Number of major issues: 9
Number of minor issues: 25
Number of issues: 59

Edit manpower: 6


Edit notes:

1. Fix: edited design.mps.poollo
2. Fix: edited design.mps.poollo to make it clear how dylan leaf objects are 
supported.
3. Fix: edited design.mps.poollo to add note about how it could be clearer.
4. Raise: request.mps.170417
5. Fix: modular.  now allocates both table separately.
6. Fix: invalidate sig
7. Fix: strengthened check
8. Fix: now check
9. Fix: same as 5
10. Fix: is now in design
11. reclassified as minor, fix: surely yes, now checks
12. Fix: now uses pool alignment
13. edit: design.mps.poollo
14. fix: justified
15. fix: removed PoolClassLO()
16. edit: clarified design.mps.poollo
17. edit: added design.mps.poollo.group.bit
18. edit: added design.mps.format.variant and note to 
design.mps.poollo.overview.format
19. edit: create analysis.mps.poollo and mention this design alternate.
20. raise: issue unclear to editor, raised discussion in mail
21. fix: scaled to 70% in design.mps.poollo
22. edit: edited design.mps.seg
23. fix: design.mps.poollo.group.purpose
24. fix: clearer names




Exit: exit.universal
