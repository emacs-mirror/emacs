                   REVIEW OF IMPL.C.POOLEPDL.SW_EQ(2)
                     review.impl.c.poolepdl.sw_eq.2
                           incomplete review
                           gavinm 1997-03-12

Rules: rule.universal, rule.impl
Checklists: check.impl.*, check.universal.cons
Source: design.mps.poolepdl, impl.h.poolepdl.sw_eq(2)
Candidate status: draft

Author: nickb
Leader: gavinm
Editor: nickb
Scribe: gavinm

Entry: entry.universal, entry.impl
Entry manpower: .2


Entry notes:

Failed entry.universal.training, entry.universal.source-approved, entry.universal.rules-approved


Loggingstart: 16:30
Loggingend: 17:45

Rate: 10 lines
Length: 629

Kickoff start: 1997-03-12 14:56 UTC, Byre, Longstanton
Kickoff end: 15:06
Kickoff length: 10


ISSUES:

DRJ: 65 minutes; completed; 4M 6m adapt, platform, guide
Richard: 65 minutes; half; 11M 15m 1q 7I 8C; dep, design, backwards; got 
20minute phone call from Allied Dunbar
LMB: 52 minutes (+21 minutes consulting and writing up); completed; 1C 2I 17m; 
clarity, constrain
NickB: 61 minutes; completed; 3M 29m 3I; simple, req, trick, backwards
PTW: 87 minutes; 63% done; 6M 10m 6q; quality, justify, backwards
GavinM: 79 minutes; half; 4M 12m 3q 3I; mod, min, limits

DRJ:
1. 3 M Inconsistent with others in code
2. 450 M Stolen from MV and still dubious
3. 450 M In particular, if extendBy is less than twice avgSize, e.g. both 64k, 
then this will cause assertion in poolClassMFS, see request.mps.170108
4. 498 M unclear: I didn't realise you could do this with SegNext

Richard:
[ increasing in cost; not necessarily big ] 
5. - M check.impl.design.ref: Doesn't refer to design
6. 613-615 M check.impl.dep.ref: Refer to similar code in EPDLInit
7. 590-602 M check.impl.design.ref: Should refer to 
design.mps.poolepdl.space-enter
8. 494-499 M Need to explain why segFirst is being used here, rather than some 
other mechanism
9. " M Need to explain what's going to happen to this code in future; in 
particular, when you merge into the trunk
10. 450 M Rationale of such a calculation must be explained
11. 424 M Justify 
12. 84-86 M Should use CHECKL, not AVER 
13. 327 M Refer to extension policy in design
14. - M Code not very clear; more comments including summaries and risks needed
15. 440-442 M check.impl.dep.ref: Refer to similar code in EPDLCheck

NickB:
16. 24,209,218 M Remove this dependency
17. 269 M Need to fix prev->next

PTW: 
18. - M Why didn't we just fix MV?
19. 436 M Can we AVERT pool at this point?
20. 437 M Don't we have to va_start first?
21. 439 M Shouldn't we also va_end?
22. 414 M Should we AVER that pool of seg of addr of old == pool?
23. 282,294 M lost bytes don't seem to be accounted for
24. 284,296 M EPDL->length doesn't seem to be accounted for

GavinM:
25. 70 M length isn't in bytes, shouldn't be Size
26. 166-168 M Res isn't properly treated
27. 191 M Should document freeBase and freeLimit are for
28. 214 M Should AVER(freeBase >= block->base)

[+25]

DRJ:
29. 78,- m parameter EPDL should be lower case
30. 96,? m First parameter should be blockReturn
31. 108 m PoolMV had a suggested improvement for reclaiming lost space; the 
same improvement would work here and should be documented
32. 262 m Should AVER that limit is <= next->base [or next is NULL]
33. 286-287 m Same as 32

Richard: 
34. - I Review process: Don't give the implementor the Trick role; it's a bit 
subjective
35. - I Review process: I have too many bits of paper; too many things to 
comprehend; lots of duplication
36. - I Para 3 of design: Why not free seg when adding a new one?
37. - I Para 4 of design: size slot definitely premature
38. - I Para 5 of design: Why record lost space
39. - I Para 7 of design: Must deal with this issue by merge time
40. mpscepdl.h,line12-13 I Need a naming convention for these sorts of methods
41. 609 m Use EPDLPool as elsewhere [also 610]
42. 616 m Clarity: A comment would be nice
43. 601,585 m Should we assert that size_t is large enough in some way?
44. 564,- m Comment not in block style (guide.impl.c.format)
45. 555 I Should write a general pool design guide for this tag
46. 542-547 C This pool should be designed for buffered allocation in future
47. 516 I mpslib.h could provide FileCheck
48. 494-499 C Could exit the loop early when the total is emptied by counting 
the number of bytes gone; alternatively, this is a good place for a check
49. 456,460-463 m Erro path convention
50. 465-467 m Insert a note about SegPref's future
51. 469-472 m Cast literal constants
52. 390-391 m Inconsistent with lines 372-372; swapped lines
53. 335 m Policy should go in design
54. 343 m pool's use og seg->p should go in design
55. 304-306,? m,I Not conventional comment style, but quite a good idea
56. 237 m "done" unclear
57. 255 C Redundant parenthesis
58. 256 m What isn't?
59. 255 I (coding conventions) dismiss simple cases first, perhaps?
60. 255,264,? C A sentinal would remove all the ==NULL cases
61. 266 m All this fidling with the size field negates the optimization of 
having it; see also rule.impl.simple
62. 498 IN arena: SegNext shouldn't allow line 497

LMB:
63. 3 I The copyright notice is different from the one used in Doc.  Consult 
legal.
64. 32 I It would be nice to have a poniter to a file containing the 
conventinos that you're using, for new people.
65. 44-46 m There are no comments, inconsistent with lines 61-73 and elsewhere.
66. 78 m Explain this line briefly.
67. throughout m Need justification for explicit numbers, especially zero, and 
the 2 in line 450.

NickB:
68. 6,7 m For requirements refer to .req.
69. 18-19 m Refer to req.epcore.fun.dl.*.
70. 18-19 m Copy some requirements into this file.
71. 22 m There's a widowed close paren.
72. 45 m Separate these two onto separate lines for consistency.
73. 46 m Premature optimizatino.
74. 52 m Useless tag.
75. 103 m AVER size > 0
76. 103 m AVER alignments
77. 103 m AVER return parameters not NULL
78. 151 m Inside loop AVER *blockPointer is not NULL
79. 180 m Second occurence of "block" should read "freeList".
80. 214 m Move to after line 211.
81. 214 m Duplicate at line 200.
82. 202 m Document that we expect this to be the common case.
83. 219 m AVER(SegBase(space, segNext) == segLimit)
84. 234,238 m Copy comments like this to design and refer to them.
85. 236,238 m Disambiguate these two sentences, e.g. by exchaning them.
86. 263 m AVER(next == NULL || limit <= next->base);
87. 287 m Same as issue 86.
88. 287 m Add comment inside brace: merge with first block.
89. 327-340 m Refer to design and document there.
90. 347 m Clarify this comment -- we are discarding the variable, not the block.
91. 357 m Simplify by taking declaration into block at 376.
92. 358-359 m Same as issue 91 but at 372.
93. design I Once this is in SW do some measurements of common cases and put in 
design and comments.
94. mps arena design I 424 The Arena should prod pools to free segments in low 
memory conditions.  Ultimately, this needs SegSplit etc. so that pools can 
return part segments to the arena.
95. 450 m Refer to design discussion.
96. design I discuss lnie 450 in design document.
97. 453-454 m Indentation wrong.
98. 458 and following m Refer to request analysis.
99. mps design I 504 Decide and document how checking interacts with 
Finish/Destroy and SigInvalid.
100. 521-522 m For consistency these Ws should be Us.
101. impl.c.poolmv I Check that these WriteF types and $ things for consistency 
there too.
102. 528 m Could do a lot more describing here.  e.g. maps
103. 552 m Transposition in comment.
104. 555 m This impl.h.mpmst... ought to be in design.mps.sig.pool or 
something.  Not in an impl.h file.

PTW:
105. 624-625 m I don't get it.  Unclear.
106. 590 m Calling this size is unclear.  Should be total size.
107. 597-599 m THis is a common sequence which perhaps should be a subroutine 
or something.
108. 526+ m Field name "length" is insufficiently descriptive.
109. 516 Q Is this the best check we can do?
110. 482+ Q We don't verify that everything is free when we finish a pool?
111. 465-467 Q How does the fact that a preference could be optional interact 
with assumption about segments in address order.
112. 452-454 Q Do we have a policy on support pools and how many you create?  
Should they be shared amongst pools of the same class or across classes?
113. 424 m Should this only be called if block size is greater than a segment?
114. 397 m Isn't this really only a two-pass loop?  Shouldn't we enforce that.
115. 347 m Comment is unclear.
116. 343 Q I have no idea what this is doing.
117. 327+ Q Why is extendBy not aligned at init time?
118. 323 Q Why doesn't PoolSegAlloc handle arena alignment already?
119. 344 Q Is seg size guaranteed to equal limit - base?
120. 247 m AVER base is non-zero

Gavin:
121. design I Paragraph 6 lost size needs explanation.
122. design I Paragraph 8 entirely unclear.
123. general I It would've helped if we'd had the design ready first.
124. 43 Q Why no sig?
125. 46 NQ Why do we have a size, isn't it redundant?
126. 52 Nm I thought tags were lower case.
127. 92 m "b" unclear.  Not clearly a return.  Not a p.
128. 97 Q Why do we need all three?
129. general NI We ought to have some means of checking Addr which incorporates 
alignment, etc.
130. 117 m Could NULLify next.
131. 150-152 m trick
132. 173 m Undocumented fall-through.
133. 207 Q Why is this not >=?
134. 234,240 m Inconsistent naming.
135. 251 m AVER size > 0.
136. 268 m There is no comment.

DRJ:
137. throughout in comments Nm Sentences do not conform to 
guide.text.punct.space.

Richard:
138. NI Need to document why issue 110.
139. NI Could have a ReturnCheck method which apply to return parameters.
140. 370-397 m Unclear.  I have suggestions.  Outer loop unclear purpose.  
Don't need loop at all.
Time is 17:45.



Brainstorm start: 1997-03-13 16:04 UTC (LMB, DRJ, Richard, RIT, NickB, GavinM)
Brainstorm end: 16:30


BRAINSTORM:

2. Richard: When I originally wrote this calculation for MV I didn't think the 
requirements though properly.
NickB: I did think about the requirements when I copied this.  We are trying to 
acheive enough control pool than we won't need to extend it except in 
exceptional circumstances.
Richard: What was wrong with the process?
NickB: It was wrong because of defect 3, not defect 2.
Richard: We can avoid it happening by not inserting random calculations without 
thinking them through.  How about a rule that calculations have to be more 
thoroughly justified than other things.  Maybe specific MPS rule that 
calculations involving blocks and sizes need design.
NickB: How about any involving division.
Richard: or multiplication.

4. Richard: NickB, did you realise you were doing this?
NickB: I did the right thing elsewhere, I'm a bit mystified as to how I did 
this.
Richard: For rings we have a recommended iterator.  Have we still got this 
part?  We should also fix up RING_FOR.  This sort of problem could be solved by 
a similar part for other iterators that involve any sort of destruction.  You 
have to be very careful when doing this.
DRJ: Could have TYPE_FOR.
NickB: The approximate cause of this bug is that I cut and pasted some code 
which had spans in it.  It was using a RING_FOR.
Richard: Suggest only cut and paste invalid code.  Also SegNext in ArenaCL 
isn't checking its arguments.  
Richard: [More to discuss here.]

17. NickB: Removing item from singly linked list.
DRJ: There was a similar bug in MV that didn't get provoked immediately.
NickB: No way to prevent this sort of bug.
Richard: So you'd do it every time?  What about a particular way of dealing 
with linked lists?
DRJ: Supposing we'd used a Ring, instead of a linked list.
Richard: Taking the size out and using a Ring costs the same as before.
NickB: Possibly having a Ring would be better.  I have to find blocks again a 
couple of times.
Richard: The improvement is to use common code.  Possibly we could have a 
singly linked version of a Ring.
GavinM: If it's worth writing three times, it's worth writing correctly.

18. Richard: Not a defect.
NickB: Clarity defect in design; innadequate documentation.
Richard: We decided this a couple of weeks ago.  
NickB: I didn't want to check that EPDL met all MV solutions.  Also DL will 
have other special requirements.
Richard: Something should justify existence of designs.
GavinM: Specifically, should we justify every pool?  What are the criteria?

20. NickB: Works fine.  Don't need them.
DRJ: Tucker brought up lots of issues, and the reason is that they're all done 
in pool.c
Richard: How much can we assume?
GavinM: It's part of the module interface; a dependency.
NickB: Clearly we omit some AVERs for brevity.
Richard: We use them where they will have good effect.  Tucker was unaware of 
these other things.  There is no guide to pool classes, etc.  This could do 
with fixing.
DRJ: This is particularly important for pools.
Richard: This interface wants thinking about anyway in case we ship pools 
spearately.
NickB: We want to design AVERs properly anyway.
---
[More from discussion between GavinM and Richard on issue 4.]
Richard: SegCheck doesn't do adequate checks.  AVERT(Seg, seg) doesn't find 
deallocated segments.  Improvement: rule that AVERT must detect dead
things?  How did SegCheck get into such a bad state?
GavinM: There are two issues here: the process one of stopping this from 
happenning; and the development one of fixing SegCheck and testing what breaks.



Exit: exit.universal
