            REVIEW OF IMPL.C.POOLMRG(MMDEVEL_DRJ_MESSAGE.9)
                    review.impl.c.poolmrg.message.9
                              draft review
                           gavinm 1997-09-03

Rules: rule.impl, rule.universal 
Source: design.mps.message, design.mps.finalize, design.mps.poolmrg, impl.h.poolmrg
Candidate status: accepted

Author: drj;gavinm
Leader: gavinm
Editor: gavinm
Scribe: gavinm
Approved: 1997-09-17

Entry: entry.universal, entry.impl
Entry manpower: .3


Entry notes:

entry.universal.author: DRJ is on holiday, so I have polished it in his absence.
entry.universal.source-approved: The source documents are not only unapproved, but incomplete.
entry.universal.brief-check: Richard has checked this and found around 9 major defects.
entry.universal.training: Failed as usual

While this document has grave flaws, Richard and I feel that we will gain from reviewing it.
GavinM 1997-09-03


Loggingstart: 15:22
Loggingend: 15:55
Logginglength: 33
Loggingrate: 2.7

Checkers: Richard;NickB;GavinM;PTW
Rate: 10 lines
Length: 608 lines
Actual checking time: 207

Kickoff start: 1997-09-03 14:00 BST (09:00 EDT)
Kickoff end: 14:07
Kickoff length: 7


ISSUES:

GavinM: 5M 12m 4q 3I  60 minutes
NickB: 3M, 5I, 1C, 2Q, 9m, 60 minutes
Richard: 3M, 6m, 1C, 1I, 2Q, 40 minutes
PTW: 2q, 8I, 47 minutes.  I got through 40% of my source document and that's it!

1. GavinM 115,141 M Should check that this difference is positive.
2. GavinM 164 M No attempt to remove from entry, free, or message rings
3. GavinM 164 M Sig not invalidated
4. GavinM 231 M Should AVERT created group
5. GavinM 231 M Should set groupReturn to created group!
6. NickB 44-46, 83 M it is normal to call RingStruct fields <foo>Ring; I found
  this very confusing.
7. NickB - M never returns unused segs to the arena.
8. Richard 340 M  Missing RingFinish (would assert if it were there).
9. Richard 165 M  Missing RingFinish (would assert)
10. Richard ? M Missing RingFinish (wouldn't assert)
11. Richard 92-93 M These aren't forward declarations, they're tentative 
declarations.  The definition may not have an initializer [6.1.2.2, 6.7.2].  
Not entirely sure about this.  Even if this works, it is bad, because it is 
obscure and in doubt.
12. GavinM - NI Write what Richard just said down somewhere.
  Richard: In general, when a FooStruct has a ring of BarStructs attached, the 
FooStruct has a RingStruct field called barRing and the BarStructs have a 
RingStruct field called fooRing.
13. GavinM 24 m Can check SegLimit
14. GavinM 123,149 m Should check that the return is non-null.
15. GavinM 170,272 m Could be nGuardians
16. GavinM 207 m Should be at line 197.
17. GavinM 217,218 m Bad style to use loop variables outside loop.
  Richard: Disagree
  GavinM: 217,218 not robust
  Richard: 217,218 Disagree in this case.  Useful check
  GavinM: 217,218 Agree useful check, disagree robust implementation
  NickB: 217,218 useful check on what? the compiler??
  GavinM: 217,218 Lighter atomic weights are available.
18. GavinM 281 m Non-localized knowledge.
19. GavinM 314,596 q Why is ArenaAlign a good choice for the extension size?
20. GavinM 331-338 I Should have delete-safe RING_FOR
21. GavinM 331-338 I Could have a Ring method that takes a destructor function.
22. GavinM 353 m Poor variable name
23. Richard impl.arena  NI  SegBase, SegLimit, etc. needn't have space/arena as 
an argument.  Could simplify quite a lot of code.
  NickB: Richard, I'm intrigued by how you'd implement SegBase without the 
arena in your hand?
  Richard: nickb: seg->pool->arena
  NickB: Richard: fair enough; I guess this is an optimization issue.
24. GavinM 379,371 m Better to use RingIsSingle here.
25. GavinM 426 m Initialization is redundant.
26. GavinM 426-432 m Need design note here.
27. GavinM 512 m It would be clearer to calculate the pool here, instead of the 
seg.
28. GavinM 555 q How can the pool be "Incremental, requiring a read barrier" if 
it's manual?
29. GavinM design.mps.types q What are the invariants on a set of attributes?
30. GavinM design.mps.pool q What are the invariants on the set of provided, 
trivial, and no methods?
31. GavinM - I Destroy methods should ANTI_AVERT
32. GavinM - m Order of document is not helpful; forward references are 
avoidable
33. PTW q design.mps.poolmrg.object.note Is there a concensus that this is 
acceptable?
34. PTW q design.mps.poolmrg.def.guardian I'm confused as to whether the MRG 
pool has references of rank "final" or of rank "guardian".
35. PTW I design.mps.poolmrg.def.mrg What does "manual rank guardian" mean?
36. PTW I design.mps.poolmrg.def.finalize agree with .def.final.object on the 
use of the term "state"
37. PTW I design.mps.poolmrg.over Do we have a document that defines 
"finalization"?  We should and it should be referenced
38. PTW I design.mps.poolmrg.over.scan mentions "exit queue" in contradiction 
with .over.queue.exit.not
39. PTW I design.mps.poolmrg I'm not convinced that this is the simplest design 
we could have.  Did we consider and justify not using the Apple design of 
managing guardians as an array of object references, rather than as individual 
objects containing the reference and "some fields for the pool's internal 
use"?  (Could we implement this as an array in a MFS pool with the correct rank 
and scan functions?  This could either be a separate pool or we could bite the 
40. PTW I design.mps.message I'm not convinced that messages are the simplest 
design we could have (I might be convinced if there were additional messages 
posited).  For the purposes of finalization, only one scalar value needs to be 
passed -- passing it as a (n algebraic == non-immediate) seems unnecessary.
41. PTW I design.mps.poolmrg.protocol.finalizer This section is misleading -- 
whether any finalizer is run or not is up to the client.  Suggest it be 
rewritten to reflect the contract of finalization from the point of view of the 
MPS.  A separate document on finalization (e.g., the one that defines what it 
is) should discuss what is typically expected by the client's clients, as 
opposed to this document which describes what is expected by/provided to the 
MPS's cli
  GavinM: The reference passed in the message needs to be scanned or manually 
managed. 
  It's an "only" reference. 
  PTW: Yes, so?
42. GavinM design.mps.poolmrg NI Should clarify requirements on handling of 
message "only" reference.
43. PTW I design.mps.poolmrg.guardian.state.final This is 
inaccurate/inconsistent.  The object is in the finalizable state, but the 
client has not yet been notified, so the object has not been finalized.  Cf., 
.def.finalize above.
  Richard: I think the use of the terms "final", "finalize", "finalizable", 
etc. is very misleading in that document.  We need some other terms.
  GavinM: Agree.
  PTW: At the very least, their use is loose.
44. GavinM design.mps.poolmrg.def.* NI These terms need sorting out.
45. NickB m - Why are the functions in such a strange order?
46. NickB m 66,67 what about state = PostFinal?
47. NickB m 65-68,70 I'd rather this was taken outside the LinkStruct typedef.
48. NickB m 65-68,70,74,76 why name LinkUnion at all? Can't linkOfMessage be 
done with PARENT(LinkStruct, the.messageStruct, message), &c.
49. NickB m 123,149 I'd find these more consistent with 115 and 141 if you used 
"+".
50. NickB m 190,191 clarity - exchange these lines?
51. NickB m 212-214,422-424 share this common code
52. NickB m - clarity: I would find it much clearer if all the dinking around 
with casting SegBase() and adding indices &c was wrapped up in macros.
53. NickB m 353 &c: clarity: would be nice to have a comment for this.
54. NickB Nm 220, 482: Add .improve.rank
55. NickB Nq 421: isn't this a bit restrictive?
56. NickB I design.mps.finalize.if.deregister: No it doesn't. Suggest rewriting 
.if to talk about a 'finalization count'.
57. NickB I design.mps.finalize.if.register: Doesn't say how many messages will 
be sent (assume it's one per mps_finalize call).
58. NickB I design.mps.finalize.if.deregister.not: Should document how it will 
work once it is implemented (i.e. linear search???) and justify this solution 
(i.e. its slowness, if it is to be linear search).
59. NickB I design.mps.finalize.int.finalize.error.nowunwind: Suspect this 
should be tagged .no-unwind.
60. NickB C 286,287: I much prefer "if (something to do) {do something}" to "if 
(!something to do) continue; do something;" !
61. NickB Q 24-27: can you justify this trade-off between checking and 
modularity?
62. Richard -  Q  Why two segments per group?
63. Richard 536-538,etc.  m  These two "ref" things are not the same.  One 
appears to be a pointer to a Ref.  This occurs a lot in this file.
  GavinM: 536-538, In fact it occurs almost entirely.
  It used to be a horrible mix between Addr and Addr *.
64. Richard 444  m  Usually called "node" not "r".
65. Richard pool.c  I  The generic part of PoolDescribe should list the 
segments.
66. Richard 425  m  Ugly block, with strange scope.
67. Richard 371  m  Should use RingIsSingle.
68. Richard 353  m  "f" is a bad name for a ring node.
69. Richard 243  m  I believe the whole pool is the "guardian" not the link 
nodes.
70. Richard 190,191 C  Swap these lines to make the code clearer.
71. Richard 56-59 m Should be "MRGGuardingFREE" etc.
72. Richard 73-76 m Assumes pointer to union is pointer to members.  Use 
"the.foo" in PARENT?
73. Richard 46 m Should be "groupRing".
74. Richard 44 m Should be "entryLinkRing" or something similar.
75. Richard 45 m Should be "freeLinkRing" or something similar.
76. Richard 83 m  Should be "mrgRing".
77. Richard 70-71,87 m Put typedefs before structure declarations, to allow 
recursive definition.
78. Richard * m We should have a rule against the use of tentative definitions.
79. Richard 96,etc. m "per seg" unclear
80. Richard * m (Link)SegBase and (Ref)SegBase should be lifted out, e.g. 
MRGSegLink(space, seg, i)
81. Richard 100,etc. m It's best if all methods begin "MRG" or "mrg" so they 
are identifiable within a debugger.
82. Richard 232 M Missing AVERT(Group, group)
83. Richard * m Badly formed banner comments throughout.
84. Richard 259 M Failed to RingFinish
85. Richard * m No "RingFinish" anywhere!
86. Richard - NM  Too complex.
87. GavinM NQ Why do we scan free references?
88. PTW nI If the documents were made available sooner, perhaps I would not 
have a delayed start.  Then again, that would rely on me actually fetching them 
sooner...



Brainstorm start: 16:08
Brainstorm end: 17:17
Brainstorm length: 69


BRAINSTORM:

> 2. GavinM 164 M No attempt to remove from entry, free, or message rings
GavinM: It's not clear that unlinking all these rings is worthwhile when 
destroying the entire pool.
Richard: This is quite interesting.  In order to remove the nodes from the ring 
you'd have to iterate through the segment, even though you know that it's going 
to be destroyed.
  So, how did this happen?  Perhaps David put it to one side and meant to come 
back for it, in which case he should've left a note for himself.
GavinM: Or me.
Richard: If he forgot, how could we detect?  This would've been detected by a 
RingFinish.
  So, we have a double failure.
  Perhaps we need a method to detach a section of a ring in one go, or 
something.
PTW: I lay blame at an overly complex solution in the first place.
GavinM: The rings partition the MRG pool into three sets.  Is it worth 
departitioning them when destroying the pool?
Richard: It's possible we've talked ourselves into a complex solution.  I'd be 
interested in a proposal for a simpler one.
PTW: PTW suggested an array of references, I think.
NickB: It's not clear to me that a pool is the right solution for finalization.
  In particular, it contributes to making mps_definalize slow.
Richard: I think "guardians" are quite a good model, though.
PTW: As I said in my improvement suggestion, Apple manage this with a single 
array, partitioned by some indices, and managed by copying
Richard: I think Apple don't have to worry about a generic interface.  They can 
do something language specific to communicate with Dylan.
PTW: The model is fine, the implementation is overly complex, to my mind.
GavinM: I believe that all this ring/message rubbish brings a high memory 
overhead.
NickB: Whereas we never do anything client-specific, of course :-)
PTW: generic interface -- please explain
Richard: How would you tell the client that something has just become a 
candidate for finalization?
NickB: I think GavinM is right w.r.t. overhead.
  I quite like the messaging aspect of this, actually.
PTW: Apple have a message interface similar to ours.
GavinM: A factor of about 7.
PTW: But the messages are "immediate" values
Richard: I think David wanted to avoid allocating when something became 
finalizable.
GavinM: .... over an O(1) partition.
PTW: They just manage Addr's
Richard: ptw: "immediate"?
PTW: Not a struct, a void*
NickB: 7 = O(1)
PTW: Hence no allocation.
NickB: "unboxed"
PTW: nickb: yes
  They have one object, an array of unboxed references
GavinM: The reason we have messages that are manually managed is that a 
self-deleting message would require the client's stack to be a root.
PTW: Er, isn't the client's stack a root?
Richard: Sometimes it is, sometimes it isn't.
GavinM: We don't require it to be.
Richard: I'm not sure that's the important restriction, though.
NickB: If we want to be able to provide exact collectors, we mustn't require 
the stack to be a root.
PTW: You still don't need a message.  The client can pass in a root to deposit 
the unboxed value in
NickB: ptw: indeed.
GavinM: We could pass back an immediate reference, lock it, and require that 
the client "free" it.
NickB: Anyway, the space overhead isn't really the issue here IMO.
PTW: exact collectors -- why must the stack not be a root?
  I think the complexity overhead is the issue
  We could use a 2-phase message:  read/delete
Richard: ptw: Do you think the message _interface_ is too complex?
NickB: Because we don't have information about which stack slots are 
references, so we have to scan the stack ambiguously.
Richard: ptw: We have that already.  Take a look at design.mps.message.
GavinM: Or we don't want to require that the stack can be scanned exactly.
PTW: and we can't have ambiguous roots?
Richard: No ambiguous roots in an exact collector, no.
GavinM: It's a question of introducing arbitrary restrictions on what we can 
provide.
Richard: Of course, we're talking about an exact _and_ incremental collector.
PTW: I see we have a 2phase recieve, hence we don't need "messages".  unboxed 
values work.
GavinM: PTW, agreed.
PTW: I think implementing a whole dang pool to get guardians is overly complex
Richard: ptw: Only with extra complexity internally.
NickB: Later message types may well need more structure.
Richard: nickb: I can guarantee it.
PTW: I'd cross that bridge when we had a later message type.
GavinM: I'm tempted to say that we shouldn't set our message interface in stone 
until we have at least three message types.
Richard: But then we'd need to have an incompatible change to the interface.
PTW: Don't we have a rule about overgeneralization, using simplest sol'n, etc.?
Richard: But we are _required_ not to change the interface to often.
GavinM: Yes.  We also want to avoid changing our external interfaces.
PTW: If this is a general message interface, then it should not be in poolMRG, 
but it's own design and implementation.
NickB: Are we getting anywhere with our process brainstorm?
  What major defect are we even discussing?
Richard: (Chris and Nick laid down requirements for hte product, and there are 
pragmatic considerations for Dylan.)
GavinM: PTW, it is.  design.mps.message, impl.c.message.
PTW: How simple is simple enough
NickB: What process improvements are we arriving at?
Richard: -  NM  Too complex.
GavinM: How can we avoid this sort of defect being introduced?
Richard: I though we were discussing that.
NickB: Mind you, I don't think this implementation is disastrously bad.
Richard: But it does seem a lot of stuff to do something relatively simple.
NickB: Right.
Richard: I think the messaging interface is right, if we want to remain 
compatible.  The question is, how can we implement finalization more simply.
GavinM: David was implementing three things at once.  MRG pool, finalization, 
and messages.
NickB: The cross-indexing between segs seems to be the major design fault.
Richard: I'm thinking about the single array.
GavinM: Cross-indexing as in linked rings?
Richard: What we almost have here is a bunch of arrays in segments.  There is 
extra bulk in the links.
NickB: No, cross-indexing as in &refBase[link - linkBase]
Richard: How do Apple allocate new references in their array?
GavinM: Richard, that's valuable, but is more like a design discussion than a 
process brainstorm.
Richard: It's why this defect arose.
PTW: As in any stretchy array implementation.  There is some slack, eventually 
you must realloc
GavinM: Because we failed to consider simpler designs?
Richard: Yes.
NickB: erm, "review high-level design before writing impl"?
  :-)
GavinM: Why did that happen?
Richard: ptw: But they remove elements by copying half the array?
PTW: We reviewed this design, did we not?  What came out of that review?
GavinM: ...
NickB: I suspect they remove elements by swapping.
  (that's how I would do it, I think)
Richard: What, swap the middle with the end, then chop off the end, as it were?
PTW: I don't recall what Moon said.  He did imply the array management was 
"simple", but perhaps not "brute force".
GavinM: It should be possible to have O(1) space overhead on the partition.
  What's the cost?  It the trade-off worthwhile?
Richard: Our code scales well.
NickB: I think we do have O(1) space overhead.
Richard: If Jonathan starts registering every object on the heap for 
finalization we will cope.
  (Kind of.)
PTW: Erm, guardians are bigger than conses
GavinM: NQ Why do we scan free references?
NickB: GavinM: I know, crap, isn't it. But not unsafe.
Richard: Hmmm.  I think this pool could be less than half as long.
NickB: I'm still not sure that this wants to be a pool at all.
GavinM: That would make it faster to review.
Richard: What is it then?
NickB: Dunno; finalize.c.
Richard: It has to own segments, therefore it's a pool.  (Bald statatement.)
GavinM: We reviewed design.mps.poolmrg(2) on 1997-02-12.
NickB: Right; I guess so....
Richard: Pool classes aren't expensive, or shouldn't be.
GavinM: It was accepted on 1997-02-28 with an estimated 5 major defects 
remaining.
Richard: What's wrong with having a pool for a special purpose?  My guess is 
that it's the bulk that's worrying, not the type.
GavinM: We're now on revision 4.
NickB: Is there any reason to have the refs and links in separate segments? Is 
this for protection reasons?
Richard: nickb: Yes.
NickB: (because I think this is the main reason for the unpleasant feeling I 
get about this impl)
GavinM: We must be able to protect reference.
  We can't protect links.
PTW: per another Improvement suggestion, if we understood having references of 
more than one rank in a pool, this could all be implemented as an object in an 
already existing pool, say MV.
Richard: We do understand that.
  But why do it that way?
PTW: I just looked at the review of the design and found:
  51. - q This document doesn't seem to reflect some of the mail discussion 
about the design (M?)
NickB: In that case the design should have made links protectable.
GavinM: Oh, yes.  Look at the exit notes.
PTW: "why do it that way": The question is, why not?  Justify design decision
Richard: OK.  To add ranked reference segments to another pool would complicate 
that pool for a special purpose.  The scanner of the object containing the 
final references must be special.  We'd have to build that special scanner into 
the other pool.  The reason for making this a pool is that it needs a special 
scanner and a specially distinguished set of segments.  That's what makes a 
pool a pool, pretty much.
GavinM: Remember that the purpose of a process brainstorm to suggest ways to 
prevent classes of defects from being introduced.
Richard: I think the fact that this pool is so bulky is a problem.
  Gavin: If you want to derail this discussion you can, but I'm not sure it's 
wise.
PTW: Is the pool bulky because is duplicates everything but a scanner from an 
existing pool?
Richard: ptw: I think that has a lot to do with it.
  ptw: And I think that's bad.
  We should be able to write a pool like this in just a few tens of lines.
NickB: We ought to be able to inherit in the obvious way (and actually I don't 
think it's that hard).
PTW: So one wonders if a better way is to take an existing pool and 
generalize/replace its scnner
GavinM: Can we piggy-back pools?
  Can we implement finalization using an existing pool without specialising it?
Richard: I've been thinking about this.  We need more components shared between 
pools.
NickB: C can't initialize a struct to be the same as another struct except for 
some fields. Shame!
Richard: Then we can build pools out of shared components.
GavinM: It would be easy to create a pool class that stole methods from another 
pool class.
  This wouldn't be very robust.
PTW: Wouldn't it be easy in C++?
Richard: Hmmm.  I'd like to sit and work this through, but we're under a lot of 
Dylan time-pressure at the moment.
  ptw: Famous last words.
GavinM: Who's keen to be involved in this design discussion?
Richard: I don't have much more to say.
PTW: I mean, we already have Vtables of a sort.
Richard: (Until I've thought about this some more.)
NickB: Me either.
GavinM: Ok.  Perhaps we should move on.
Richard: ptw: I'm increasingly aware of all the pseudo-classes we have.
  Conclusion: We should have thought this through earlier.
GavinM: We can continue design consultation offline.
PTW: I think we could profit from a more thourough post-mortem of the process 
here.  We _did_ do a review of this design, yet we are harping on design issues 
now that we see the implementation.  There has got to be some process 
improvement here.
GavinM: PTW, could you research whether your comments were satisfacrotily dealt 
with?
Richard: ptw: I agree.
PTW: I believe I complained at the time that the review of the _design_ was at 
too low a level (that formal review was too detailed and missed the bigger 
issues).
GavinM: I don't think we have information to analyse what went wrong here and 
now.
PTW: I can take an action to go back over the review of the design and see if I 
can summarize.  Then we can at least start a mail discussion.
Richard: ptw: OK.  Good idea.
GavinM: Please.


> 7. NickB - M never returns unused segs to the arena.
Richard: Perhaps we didn't really get a good mail discussion going.  Perhaps we 
should _force_ such a discussion.
GavinM: Suggest: proc.rfc
NickB: Perhaps we should have formal design meetings, just as we have formal 
review meetings?
Richard: Tucker suggested design presentations (didn't you?)
  I suggest another meeting for this.  Gavin>
Richard: I think this has a lot to do with the fact that the design doesn't 
deal with the bigger issues either.
Richard: If it did, then we could point out defects in that.
Richard: In the old days, when I only had ptw to talk to, we discussed design 
more thoroughly.
GvainM: Don't start that again.
Richard: (We used to have days of design flame wars.)
GavinM: I think our design process needs to be more directed.
Richard: We came up with some good stuff, though.
GavinM: We should have a Director of Design.
Richard: Uh oh.
  I don't think issue 7 is very interesting.
Richard: We should have a rule about monotonic behaviour.
GavinM: ?
Richard: No monotonically increasing resource usage allowed.
PTW: 7: not returning is a degenerate case of low-water mark, if you stay below 
some high.
GavinM: PTW, yes.


> 11. Richard 92-93 M These aren't forward declarations, they're tentative 
declarations.  The definition may not have an initializer [6.1.2.2, 6.7.2].  
Not entirely sure about this.  Even if this works, it is bad, because it is 
obscure and in doubt.
Richard: I suggest a new rule to deal with 11.  Don't use new features of the 
language without getting approval somehow.
GavinM: Ah.  Parts again.
  Is on vishlist, Captain.
PTW: Is this really a "new" feature of the language, or is the usage new?
Richard: New usage.
  When I say "new feature" I mean "feature we don't use", i.e. "new for us".
  e.g. introducing long longs, etc.
PTW: Is this new usage necessary?
Richard: I don't think it's necessary.
GavinM: It's not.
PTW: Then, by .simplicity...
GavinM: Ergo, we shouldn't have it.
NickB: Right.
GavinM: Sorted.
NickB: Although it's not all that different from putting in a static function 
prototype, so unless we have a guideline against this particular idiom, it will 
creep in.


NickB: Process: I'm not convinced that IRC logging is a good idea.
GavinM: I wondered whether it would be worth logging as we checked. 
  I am.  I do far more re-checking.
Richard: We could go back to verbal logging for a week, as a sanity check.
PTW: nI If the documents were made available sooner, perhaps I would not have a 
delayed start.  Then again, that would rely on me actually fetching them 
sooner...
NickB: In particular, IRC logging incurs a substantial post-logging overhead.
PTW: What is the logging rate these days?
GavinM: Of course, that might entail not editing them two hours before the 
review.
Richard: Everything would would be easier if we worked on something simpler.
PTW: PTW, comparable.
Richard: I think we're reviewing things too close to editing.
GavinM: Nick, could you clarify?
NickB: About IRC logging?
GavinM: Oh, you mean editing the log?
NickB: The editor, or the review leader, has to spend a considerable length of 
time editing the IRC log to produce an issue log.
PTW: Something would be simpler if everything we worked on were easier
GavinM: I claim it's comparable to the time the scribe spends, and is at a more 
appropriate time.
NickB: (It took me just over an hour for poolams)
GavinM: Incidentally, Nick recently did this editing of the review log.  
Richard: Editing it incrementally as you edit might be better.
GavinM: That was the first time anyone other than me did it.
NickB: No, much worse, because being able to sort and group issues as you edit 
helps a lot.
Richard: Yes, I see.
NickB: (in my experience; for instance I was able to deal with the questions a 
lot faster by having them all together and in a consistent format)
PTW: Could an administrative assistant do this editing?
GavinM: I personally find it preferable to being a scribe.
Richard: I didn't find scribing particularly onerous.
PTW: Should mm hire a drudge?
GavinM: It's been suggested before.
NickB: Maybe if we had a consistent format for issues, and all used it. Given 
that we are all cutting and pasting now, that wouldn't be too hard.
GavinM: We're pretty consistent.
NickB: And it would make the conversion much cheaper (i.e. turn it into an 
emacs macro)
GavinM: The main problem is filtering out non-issues.
PTW: If someone told me the format, I could make my tool conform.  I tried to 
infer it.
[ Discussion of possible issue formats clipped. ]
GavinM: I think this is a matter for the scribe to decide.
Richard: Gavin: You're the scribe.  You decide.
GavinM: I'll be clearer about required format next time.


Richard: I think we're reviewing too soon after implementation is finished.
  Or rather, we're rushing implementation "to get it reviewed".
PTW: and not soon enough before design is?
Richard: ptw: That too.
GavinM: Yes.  That's a side-effect of implementing too soon before release
  and reviewing before release.
  Waterfall.
Richard: But what we really want is to get it discussed, not reviewed.  To get 
some feedback from the group.
  (Perhaps.)
GavinM: Back to proc.rfc, then.
Richard: Or maybe design meetings.
  I think we should have design meetings.
NickB: I think review.impl.c.poolams.2 worked really well, despite happening 
immediately after the doc was finished.
Richard: Work out issues in high-level design, write them up, in order to start 
the design document, RFC it, etc.GavinM: It found a lot of defects, didn't it?
NickB: Right, Brainstorming design documents.
Richard: Well, kind of.
NickB: in a fairly formal setting.
Ricvhard: Another thing is that it would give me a chance to maintain 
conceptual integrity at fairly low cost, and early on.
GavinM: Suggest: Someone produces a procedure for formal design discussion.
Richard: And it could involve Tucker more.
NickB: Control, control, control.
GavinM: Yes.  We could use this Ibid thingie.
Richard: I'd like to have Tucker involved more in design.  He's often right.
GavinM: Any volunteers to produce a process for this?
Richard: I suggest we wing it first, then write down what worked, as a first go.
GavinM: Richard, in that case could you organise the first one?
Richard: OK, but it will be when I return from holiday.
NickB: What shall we design?
  Actually, this might work really well.
Richard: Should we try something hard or do someting easy so that we can try 
out the process?
NickB: Especially if we can use Look@Me to collaborate graphically.
GavinM: Why not do both?
NickB: Something middling, I think.


GavinM: I don't think we make good use of our brainstorm time.
Richard: I'm not sure that's true.  Or perhaps we're starved of design 
conversation.



Number of major issues: 14
Number of minor issues: 41
Number of issues: 88
Major defects remaining: 1.4

Edit manpower: 35


Edit notes:

1. Fixed: 
2. Fixed: Documented as design.mps.poolmrg.trans.no-finish
3. Fixed: 
4. Fixed: 
5. Fixed: 
6. Fixed: 
7. Fixed: Documented as design.mps.poolmrg.trans.free-seg with sketch of 
algorithm to fix
8. Fixed: see also design.mps.poolmrg.trans.no-finish
9. Fixed: 
10. Fixed: in impl.c.message
11. Fixed: Was valid, but removed anyway
12. Edit: design.mps.ring.naming
13. Reject: Can do better than that
14. Reject: An unlikely thing from the calculation
15. Fixed: 
16. Reject: Not needed at all now
17. Reject: Useful sanity check
18. Fixed: 
19. Mail: mail.gavinm.1997-09-10.13-21(0)
20. Edit: impl.h.mpm and other places
21. Reject: It's not clear that many of the different RING_FOR sites would be 
appropriate
22. Fixed: renamed freeNode
23. Edit: Lots of files
24. Fixed: 
25. Fixed: 
26. Fixed: Reorganised code in clearer way
27. Fixed: 
28. Mail: mail.gavinm.1997-09-10.13-21(0)
29. Mail: mail.gavinm.1997-09-10.13-21(0)
30. Mail: mail.gavinm.1997-09-10.13-21(0)
31. Reject: Could only usefully check NULL or SigInvalid
32. Fixed: 
33. Mail: mail.gavinm.1997-09-10.13-21(0)
34. Mail: mail.gavinm.1997-09-10.13-21(0)
35. Fixed: design.mps.poolmrg
36. Fixed: design.mps.poolmrg
37. Reject: finalization is the same as being finalized , which is defined here
38. Fixed: Already done
39. Fixed: Well not now, but see design.mps.poolmrg.future.array
40. Reject: The message interface need to be flexible and extensible
41. Edit: design.mps.poolmrg
42. Edit: design.mps.message
43. Edit: design.mps.poolmrg: Clarified definition
44. Fixed: Already done 
45. Fixed: It grew that way.  They have been reordered
46. Reject: It uses none of these fields; this is implied by the comments
47. Reject: It's clearer now, but without this change
48. Fixed: 
49. Fixed: 
50. Fixed: 
51. Fixed: GuardianInit
52. Fixed: 
53. Fixed: variable renamed and code clarified
54. Fixed: 
55. Mail: mail.gavinm.1997-09-10.13-21(0)
56. Reject: It's not clear what it does as it hasn't been implemented
57. Edit: design.mps.finalize
58. Reject: Not worth it until it's clear there's a requirement
59. Edit: design.mps.finalize
60. Fixed: 
61. Mail: mail.gavinm.1997-09-10.13-21(0)
62. Mail: mail.gavinm.1997-09-10.13-21(0)
63. Fixed: Now RefPart
64. Fixed: 
65. Issue: request.mps.170496
66. Reject: Better now, but was alright
67. Reject: Duplicate of issue 24
68. Reject: Duplicate of issue 22
69. Reject: The link-refPart pair is the guardian
70. Reject: Duplicate of issue 50
71. Fixed: 
72. Reject: Duplicate of issue 48
73. Reject: Duplicate of issue 6
74. Reject: Duplicate of issue 6
75. Reject: Duplicate of issue 6
76. Reject: Duplicate of issue 6
77. Fixed: 
78. Pass: DRJ
79. Fixed: 
80. Reject: Duplicate of issue 52
81. Fixed: 
82. Reject: Duplicate of issue 4
83. Fixed: 
84. Fixed: 
85. Fixed: To an appropriate level
86. Reject: Arguably, but it meets requirements
87. Mail: mail.gavinm.1997-09-10.13-21(0)
88. Reject: Already in proc.review.ko.doc.check



Exit: exit.universal
Exit manpower: 0.4


Exit notes:

Double-checked by Pekka.


Manpowerused: 49.4
Manpowersaved: 140
