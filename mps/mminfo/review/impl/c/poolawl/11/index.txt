                      REVIEW OF IMPL.C.POOLAWL(11)
                        review.impl.c.poolawl.11
                           incomplete review
                           richard 1997-07-22

Rules: rule.impl, rule.universal
Checklists: To be determined
Source: design.mps.poolawl, analysis.mps.poolawl, mail.drj.1997-03-11.12-05
Candidate status: draft

Author: drj
Leader: richard
Editor: drj
Scribe: richard

Entry: entry.universal, entry.impl
Entry manpower: 0.2


Entry notes:

Few comments in this file, but no obvious defects.


Loggingstart: 1997-07-23 15:30 BST

Checkers: Richard (consistency with rest of MPS);NickB (Correctness;Backwards)
Rate: 10 lines/minute
Length: 706

Kickoff start: 1997-07-23 14:05
Kickoff end: 1997-07-23 14:20
Kickoff length: 15

Kickoff notes: Pekka's first review.  Announced that I'd allow some discussion during logging.


ISSUES:

#review: @Richard 
***  #review :End of /NAMES list.
***  Mode is + 
***  Inviting ptw to channel #review
***  Inviting nickb to channel #review
***  Inviting drj to channel #review
***  nickb has left channel nickb
***  nickb (~nickb@trillian.long.harlequin.co.uk) has joined channel #review
***  ptw (~ptw@myteline.harlequin.com) has joined channel #review
***  Inviting Pekka to channel #review
***  unknown reply: 477: LOGGING :Channel doesn't support modes
     nickb: Yow!
     nickb: (are we being logged?)
***  Richard has set the topic on channel #review to Logging meeting
***  drj has left channel drj
***  drj (~drj@spike.long.harlequin.co.uk) has joined channel #review
***  Pekka (pekka@terpsichore.long.harlequin.co.uk) has joined channel #review
   Richard: Could I have your counts and time spent checking please?
       ptw: 51 minutes, M: 2, m: 6, C: 0, q: 4, I: 5
   Richard: I spent 70 minutes checking.  M: 7, m: 21, C: 8, Q: 1, I: 5
       drj: 70 minutes approx, M: 2, m:, 14, q: 1
   Richard: drj?
     nickb: 70 mins, 1M 1C, 1q, 8m, 9I
       drj: s/,//2
       drj: oh sed
     nickb: do we get to talk about dentistry again?
   Richard: No.
       drj: I think rptb was assuming Zed syntax
     Pekka: 70 min, 2 M, 8 m, 4 C, 3 q, 6 I
   Richard: No, that would be E.
     nickb: last week we spent the logging meeting talking about dentistry.
       drj: Past Tense
     nickb: Percival Theobald?
     nickb: All quiet on the logging front
   Richard: Totals: 14M, 58m, 13C, 10Q, 25I
   Richard: Majors first. Nick?
     nickb: 401-412 M should at least check that the dylan format version 
number is correct.
   Richard: Stop.
   Richard: I forgot something.
   Richard: I wanted to invite each of you to put forward any general comments 
you have about this document first.
   Richard: (As an experiment.)
     nickb: Generally not bad; regrettable that there is so much Dylan 
dependency.
   Richard: Just one sentence or two.
   Richard: I didn't find any actual bugs, but plenty of places where corners 
have been cut which will cost us later if we don't sort them out now.
     nickb: Better than a lot of impl.c that we have reviewed in the past.
       drj: Generally, I thought the design followed the implementation too 
closely.  Design on how various things were achieved would be nice.
   Richard: Anyone else?
       ptw: No comment
     Pekka: There aren't a lot of comments in the code; did I expect too much 
based on my limited experience?
   Richard: DRJ is terse
   Richard: OK.  Back to majors.  Nick, please carry on.
     Pekka: terse != silent
     nickb: Do I have to utter my issue again, or can we take it as read?
       drj: in general I was trying to put relevant stuff in design.
   Richard: No, just carry on from the next one.
       drj: of course, problem is design is "out of line".
     nickb: I'm done on Majors. You should know that.
   Richard: Yes, I think that is a problem, DRJ.  Bring it up at brainstorm.
   Richard: Pekka, majors?
     nickb: hope> .
     Pekka: 58 M missing parentheses
   Richard: Hmmm.  Don't think so, but carry on.
       drj: I think so.
   Richard: It's inconsistent with line 54, anyway.
     Pekka: 388 M All these literal constants!
   Richard: Yes.  This is a problem with fmtdy.c as well.
     Pekka: Make that 388-418
       drj: see request.dylan.170338, that'll cancel my defect
   Richard: OK.
   Richard: Tucker, majors?
       ptw: 168 M  Verify that the rank set of the seg matches the buffer?
   Richard: A useful check to have somewhere, I think.
       ptw: 272 M  Efficient enough -- searching all segments from beginning?
       drj: BufferEmpty probably
   Richard: So am I.
       ptw: ./
   Richard: DRJ, Majors?
       drj: y
       drj: 505 M The more Fix methods I write and see, the more I think ptw's
       drj: suggestion of breaking it into parts (is already marked, fix, 
snapout)
       drj: is correct.
       drj: 594-602 M this code is not mentioned in the design.
       drj: ./
   Richard: Perhaps.  I'd be glad to discuss breaking up Fix.  If there is a 
solution whcih doesn't ake the critical path longer.
       drj: (code in Reclaim which skips a buffer)
   Richard: Yes, that was added recently, in response to a Dylan request.  You 
didn't update the design?  (Easily done.)_
       drj: evidently not.  wonder what the approval report said...
   Richard: Ahem.
   Richard: Richard, Majors?
       drj: might not've been approved yet, the code on the trunk only got 
changed yesterday
   Richard: - M AWLGroups aren't destroyed by reclaim, thus memory isn't 
recycled to other pools.  Could be bad for large vectors.  We know that Dylan 
have large vectors.
   Richard: 128 M Does awl->alignShift divide arena alignment?  At least check.
   Richard: 247 M You forgot to unsign the AWLStruct, to prevent accidental 
re-use.
   Richard: 272-282 M Allocation will get slower and slower using this 
algorithm.  Need at least a design for a better solution.  I'm sure this will 
need to be done.
   Richard: 168-195 M AWLGroupAlloc is misnamed.  It doesn't allocate (it 
doesn't change any table).  The design is unclear about whether this is 
intended or not.
   Richard: 362-382 M Will not work with multiple traces.  What happens if the 
group is grey for several traces?  What happens if it is grey for one trace and 
white for another?  At least needs an explanation in the design.  Does the pool 
globally assume a single trace?  If so, it must have a design for an 
alternative that does not.
   Richard: 385-418 M Out of place.  I suggest moving this to fmtdy.c and 
having a static dependency from this code.  Even better, introduce a new format 
method, even if it's just another argument to this pool as a parameter on 
initialization.
   Richard: Nick, are you double-checking these?
   Richard: That's all from me.
   Richard: Does anyone have any new majors?
     nickb: Some of them (as many as I have time)
       ptw: nM I seem to recall reviewing this document before, but not having 
responses to all my issues?  In particular, I'm not sure 3 BT's are needed.
       drj: (I think you are remembering reviewing LO which is similar 
strucurally)
       ptw: Aha.  Well then, my nM should be revised to say "Do we really need 
3 BT's to accomplish this?"
   Richard: OK.  All other issues.  Since time is limited, I suggest people put 
the ones they think are most important first.  Otherwise, any order.
   Richard: Nick.  You first.
     nickb: 386 &c m consistency: Please use the same spelling of 'dependent' 
everywhere (including in design.mps.poolawl).
     nickb: 388-418 m bletch! Can't this go in the format?? Or somewhere 
indirect?
     nickb: 445 q Why not a while() loop?
     nickb: 546 m Should refer to design.mps.weakness or somewhere for this 
choice of splat value
     nickb: 651 m consistency: make this a static
     nickb: 657-673 m clarity: comments to name the fields would be nice
     nickb: 684-693 m format not checked
     nickb: 684-693 m check lastCollected non-negative
     nickb: 703 m could check that the grainsize divides the seg size ? 
       ptw: nnM Can the structural simliarity between AWL and LO be moved to a 
common substrate?
     nickb: 696-705 C if you had the AWL in your hand (e.g. as a field in the 
group) you could check more
     nickb: 700-702 m comment that BTs are not properly checkable and refer to 
the design which justifies this
   Richard: I see.
       drj: Hmm
       drj: (meta comment), rules about transgressions are silly as people 
still whinge about them even when it is made clear that a) they are a 
transgression and b) there are solutions to ameliorate the situation (witness 
line 388 following).
   Richard: One should only point out a transgression as an issue if it is 
insufficiently documented, or felt to be unnecessary.
   Richard: (Or a defect.)
       drj: fair'nuff
     nickb: Still got my improvement suggestions to come.
     nickb: I design.mps.bt? impl.c.bt? Make BTs properly checkable or justify 
why not.
     nickb: I design.mps.poolawl needs general polishing to make 
self-consistent, consistent with the implementation, and well-formatted.
     nickb: I design.mps.poolawl.sig: this is false
     nickb: I design.mps.poolawl.poolstruct: and the rest
     nickb: I design.mps.poolawl.group: document the signature
     nickb: I design.mps.poolawl.fun.reclaim: mention the buffer skip stuff
   Richard: Any more?
     nickb: I design.mps.poolawl.fun.dependent-object: deisng.dylan.container 
is mis-spelled.
     nickb: And I think that's all.
   Richard: OK.  Pekka, your other issues please.
     Pekka: I'm using VIRC, so this is slower.
     Pekka: 26 m field named *struct exposes implementation detail
   Richard: What's VIRC?
     Pekka: 51, 56 m inconsistent naming
     Pekka: 61 m No comment. guide.impl.c.section.comment
     Pekka: A Windows IRC client
     Pekka: 61, 93 m unnatural order
     Pekka: 117, 275 m Level of comments?!  Obvious comments are bad, no 
comments is worse.
     Pekka: 192, 296 m complicated relation not abstracted
     Pekka: 385 m Not usual format.  guide.impl.c.section.comment
     Pekka: 24 C doesn't match design (not a defect because design is 
incomplete)
   Richard: You seem quite fast to me.
     Pekka: 32, 44 C *AWL -- yech!
     Pekka: 41 C inconsistent naming
     Pekka: Cutting and pasting from Emacs
     Pekka: 94 C strange that it takes a Pool, not an AWL
       drj: 275? clarify issue please pekka?
--> ptw  I just hung up on you by mistake.
      *ptw*  We weren't talking anyways
     Pekka: Make that, 272-282 should really have a strategy comment
     Pekka: 233 q So generic PoolInit inits the segment ring, but PoolFinish 
doesn't destroy it?
--> ptw  I'll call again if anyone says anything.  Call back if you want.
      *ptw* call back when you feel it worthwhile
     Pekka: 338 q So what?
       drj: I see
     Pekka: 344 q So what prevents more than one happening?
     Pekka: I Perhaps we shouldn't review an implementation on an incomplete 
design (or even implement)
     Pekka: I No link to req.dylan or mail.drj.1997-03-11.12-05
     Pekka: from the design.mps.poolawl, that is
       drj: er, is the improvement to not have the links, or to put them in?
     Pekka: Putting them in
   Richard: These all seem like good comments.
   Richard: Any more?
     Pekka: I Separate analysis is cumbersome
     Pekka: 3
     Pekka: I Should the implementation record the version of the design that 
it implements?
     Pekka: I The page table is really a segment cache (as well).  Seg->p 
points to the rest.  The terminology should reflect that.
     Pekka: I mpscwal.h should have been reviewed at the same time (formally).
   Richard: Good.
       drj: all good
   Richard: DRJ.  Your other issues, please.
       drj: 116-120 m This code should be common.  somewhere.
       drj: 377-378 q Why do we not call TraceSegGreyen here?
       drj: 22,34 m Sigs not consistent with other pools. (there is no 
consistency in pools at all in fact)
       drj: 126 m strange label
   Richard: 377-378 It won't work.  Let's fix it.
       drj: 183 m extraneous blank line
       drj: 338 m extraneous comment
       drj: 430 m extraneous comment
   Richard: 9999 nm extraneous issue
       drj: I thought you said all in order of importance?  not just the 
important ones
   Richard: I'm not needling you, just making a weak joke.
       ptw: very weak
       drj: 449- m almost all tags in AWLScan are wrong
       drj: 455 elsewhere m use of continue is inconsistent with rest of impl.  
only code written by drj uses continue (!).
   Richard: Too true.
   Richard: continue is goto in disguise.
       drj: hmm too much truth
       drj: oh yes, and we have a goto ban
       ptw: continue is structured
       drj: I forgot
       drj: and there I as trying to write lcear code.
       drj: mublem mumble
   Richard: No, just a goto minimization policy.
       drj: 465 suggest AVER objectEnd > p
   Richard: Anyway, I think this would be clearer without coninue or goto, 
myself.
       drj: 482 m unclear, needs ref to design.
       drj: yes I know, and I think the other way round.  dunno what to do if 
that's the case.
   Richard: 465 Good idea.
       drj: 532m switch/case style not consistent
       drj: 543 m if(marked) then return, avoids a nesting level and may be 
clearer
       drj: 605 m aver j > i
       drj: that's all
   Richard: OK.
   Richard: Tucker, your other issues please.
       ptw:  I  analysis.mps.poolawl -- improve.scan.finished:  should use the 
general barrier mechanism available to all pools.
       ptw: 29 m  actionStruct not documented
       ptw: 30 m  lastCollected not documented
       ptw: 61 q  Convention for naming \"internal\" functions
       ptw: 93 q  Pass generic pool, or class-specific pool to internal 
functions?
       ptw: 100 m  bits -> nGrains, or grains
       ptw: 116 q  Where does size come from ultimately?  Is it possible for it 
to be ridiculously small (e.g., because a small allocation does not fit in a 
buffer)?
       ptw: 118 I  Should client actually be able to make a request that 
_could_ overflow?  I would think there should be a limit on size much further 
out (e.g., at the mps interface) that precludes the need for this check
       ptw: 121 m  SegPref should be a pool attribute, even if defaulted
       ptw: 147 q  Are there explicit counter-requirements on the setting of 
BufferRankSet by the client? I could not find any in the design.  Can they be 
checked?  Do they really belong to the buffer, or should they belong to a pool.
       ptw: 148 I  SegSetP could be more mnemonic
       ptw: 148 m  Should SegSetP preced AVERT at 151?
   Richard: P = Pool's Pointer really.
       ptw: 161 m  failSpaceAlloc0 -> failSpaceAllocGroup
       ptw: 168 I  Internal function convention:  pass space and class-specific 
pool
       ptw: 192 I  index->address and reverse part of table tools?
       ptw: ./
   Richard: Hmmm.  Interesting stuff.
   Richard: My turn.
   Richard: 26-32 m clarity Explain with comment.
   Richard: 38-43 ditto
   Richard: 22,34 m consistency Upcase hex?
   Richard: 32,44 m consistency,clarity Use separate typedef for AWL and 
AWLGroup
   Richard: 47,48 Q Why aren't checks at the front of the file?
   Richard: (I think they're more useful there.)
   Richard: 54 m minimal Extra parens around "pool" unnecessary.
   Richard: 63-68, etc. m clarity Brief comments would be nice.
   Richard: 70-77 C simple Pass AWL, space as parameters
   Richard: 79-80 m clarity Comment obscures use of segGrains.  Suggest moving 
to before line 82.
   Richard: (Double use, that is.)
   Richard: 89, etc. m cons Prefer sizeof(AWLGroupStruct).  There is less 
information in sizeof *foo.
     nickb: Oooh, I think consistency downcase hex.
     nickb: (tum te tum)
   Richard: 61-90 C Check that group contains no objects?  Also, check it's 
unmarked, etc?
       drj: what we need is a C coding style
   Richard: The rest of the code uses uppercase hex.
   Richard: But that's not important right now.
   Richard: Where was I.
   Richard: You're just trying to put me off my stride.
     nickb: I agree, it is not important right now. It's not true either.
       drj: no, a stride is the distance between successive cache lines
     nickb: (counterexamples: epdl, arenacl)
   Richard: design...fun.group.dest I clarity Not clear from design whether 
gruop must be empty.
   Richard: (See previous issue.)
   Richard: 100 m cons Why not "grains" then?
   Richard: 93 m cons Pass AWL round rather than Pool.
   Richard: 118 I Is this checked elsewhere?  Should it be?
   Richard: 85-87 I SpaceFree takes Addr.  SpaceAlloc returns Pointer (void 
*).  Fix.
   Richard: 93 m min Pass RankSet not Buffer.
   Richard: 150,152 m Blank line.
   Richard: 162 C Suggest allocating segment last, as it is most expensive.
   Richard: 171 m clarity Why not "grains" then?
   Richard: 184 m - Spurious blank line.
   Richard: 181 C Pass space as param?
   Richard: 181 m cons Should have AWLPool method to avoid &
       ptw: 162 nC Then allocate it first as it is most likely to fail?
       drj: no it si 183 that is spurious, not 184
   Richard: 185 C Use "n" and "group->grains" and avoid "SegSize" altogether.  
"n <= group->grains && ..."
   Richard: 203-204 m cons False.  Can check Pool.
   Richard: 242 C OTT checking?  Will be checked by AWLGroupDestroy.
   Richard: 294-297 m min Wasteful opposite of AWLGroupAlloc operations.  
Suggest returning i and j.
       ptw: OTT?
     nickb: "over the top"
   Richard: 319 C Suggest pointing buffer->p at group.
   Richard: 327 m clarity Explain when i could be equal to j.
   Richard: general m clarity i,j used instead of baseGrain and limitGrain.  
guide.impl.c.naming.cnc says that i and j are loop variables.
   Richard: 338 C Suggest that they start out set, and are so normally (i.e. 
black)
     nickb: We don't use guide.impl.c.naming.cnc, and if we ever do, I may quit
       drj: calrify "they" in 338 please
   Richard: design....ms.justify I cons Disagree.  I think this is harder to 
get right.
   Richard: Just a mo.
       drj: we do use it for i,j,k,p
       ptw: k,p?
       drj: k 3rd loop index, p pointer
   Richard: s/338/355-356/
       drj: actually we don't use p much these days
   Richard: they = bits in tables
   Richard: 338 m clarity So?
   Richard: tracer I Change contract to allow segment to remain grey after 
scanning, thus removing need for nasty loop in this scanner.
   Richard: 430 m clarity So?
   Richard: And that's all.
   Richard: Sorry about the duplicates.
     nickb: New issues now?
   Richard: Right, does anyone have new issues?
     nickb: 617-648 nM need a real strategy before this goes to customers.
     nickb: 696-705 nm should check that (AWLGroup)SegP(group->seg) == group
     nickb: nI design.mps.poolawl.group.bt and following: should state exactly 
when
     nickb: bits in these tables are set (for instance that scanned and marked
     nickb: bits are only ever set for the first grain of any object).
   Richard: "I'm in charge".  That was Bruce Forsythe's catchphrase.
     nickb: "Didn't he do well?"
   Richard: What do issues mean?
   Richard: All: "Defects!"
       ptw: tracer nI greying in M/S should parallel greying in copying
   Richard: ptw: It's quite close, but not a well supported.  Needs to be fixed 
up for EP anyway, I suspect.
   Richard: Any more?
       drj: changing trace to allow seg to remain grey...
   Richard: I think Nick's issues are good.  Myopic of us not to notice them.
       drj: also removes a loop in AMC when forwarding onto same seg
       ptw: My point is that the seg should not remain gray but re-gray if 
marked
   Richard: ptw: Yes, I agree.  But marking might happen during scan of the 
same seg, so seg would remain grey in that case.
       drj: well, I never got to line 617 guv'
   Richard: Yes.  Where did people get to?
       ptw: Er, I think you want the loop, but the accounting should be a 
global (seg-based) accounting
   Richard: ptw: Agree.
       drj: 616 believe it or not
   Richard: I got to 430.
     nickb: 385 working backwards (after reading the design)
     Pekka: 420
   Richard: OK.  We're clearly not done reviewing this.  We must schedule 
another review for the rest soon.
       ptw: Hm.  All I know is my last issue was at 272
   Richard: That'll do.
   Richard: Any more logging?
       drj: when I was reviewing I noticed I went faster than 10 lines/min on 
"easy" bits and slower than 10 lines/min on "hard" bits
   Richard: proc.review.log.fast nI "brisky" is not an English word
   Richard: OK  End of log at 16:30.



Brainstorm start: 16:30
Brainstorm end: 17:00


BRAINSTORM:

***  Richard has set the topic on channel #review to Brainstorm
   Richard: Anyone want to nominate a major?
       drj: er, there was something I was supposed to bring up at brainstorm 
but I didn't expect to be hre so I've forgotten
     Pekka: Lack of comments
***  sheep has left channel sheep
   Richard: Design/Impl split.  (Same issue, and the one David mentioned)
     nickb: Isn't that your job? I can't remember what the majors were.
       drj: brisky (Shak.) is in Chambers
   Richard: Not English, as I said.
       drj: er, no scrollback so I've forgotten what the Majors are.
     nickb: Ah, that'll be a semi-medieval word, then.
   Richard: I think this issue of design/impl split is important.  I've 
encouraged people to put important decisions and so forth in design.
   Richard: And reviews often say "misplaced design".  But this seems to lead 
to people omitting comments from code.
   Richard: Some duplication doesn't do any harm, imo, because they have to be 
consistent anyway.
       ptw: We need Literate Programming tools
   Richard: In fact, a bit of duplication might help to make things consistent.
     nickb: Any design concerning particular lines of impl should be referenced 
from those lines.
       drj: indeed.  most design is boring.  comments in the code could point 
out the particularly crucial bits
   Richard: nickb: Agree.
       drj: agree
     nickb: Tucker is right, of course, but we have to make do with what we've 
got.
     Pekka: Too many comments are bad too.  Just hint shoujld be enough if 
you've read the design
   Richard: Perhaps we've swung too far towards "design" documents.
     nickb: Better than too far in the other direction IMO
       drj: ptw, I think Literate Programming Tools might be nice, but I'm not 
sure they agree with our Lowest Common Denominator philosophy
   Richard: We're not covering high-level enough stuff in the design, and the 
impl is bare.
       ptw: Do Hope/Eternal have a requirement to support LP?
   Richard: Ask eternal-arch.
       drj: Eternal almost certainly does
       drj: going now
   Richard: Bye
       ptw: bye
     nickb: Will we all still have jobs by the time they've done it, though?
       drj: Bye
       ptw: [must go in 25 minutes]
   Richard: I reckon that, say, impl.c.ld has a reasonable amount of comments 
in it.
   Richard: But there should be another document giving other views of LDs and 
their operation.
       ptw: Java have a crude implementation of LP where comments turn into HTML
     nickb: s/jobs/lives/
     nickb: s/lives/a universe to inhabit/
   Richard: I'm not holding my breath for improved tools.
     nickb: I'll be resident cynic now that DRJ has gone for the bus
       ptw: [saw Contact, speaking of universi.  Quite good]
   Richard: Any more on this issue?
     Pekka: half-and-half is a good rule of thumb, but the comment must be 
informative not obvious
   Richard: Comments must say "why", not "what", is my rule.
       ptw: Could we not have a simple tool that supported something like LP?
   Richard: You can see "what" by reading the code, usually.
   Richard: ptw: Maybe.  I suggest we discuss what it might do in mail, rather 
than here.
       ptw: ./
   Richard: OK.  Another issue is the poor allocation algorithm.
   Richard: (i.e. search the list of segments)
   Richard: What has gone wrong here, and how can it be avoided in future?
   Richard: (DRJ can't comment, sadly.)
       ptw: I think it is all bound up in our segment structure.
   Richard: I have a higher level view.
       ptw: If pools tended to "extend" rather than allocate new segments, this 
would be much less of an issue
     Pekka: Are segmets trying to be too manyy things at once?
       ptw: What do you see from up there?
   Richard: It's too hard to write a good algorithm.  There isn't enough 
support from the MPS.  DRJ was being a bit lazy w.r.t. the requirements, and 
because nothing better was supported, he did the simple thing.
     nickb: There's a general issue here about the fitness of current solutions 
for long-term potential requirements. c.f. PoolMV.
   Richard: This may be because of segment issues, and maybe not.
       ptw: Segments are trying to be a 2-d virtualization of 1-d memory.  But 
we don't have a good implementation yet, it permits fragmentation.
     Pekka: I think richard and ptw ar not very far from each other on this
   Richard: Yes.
   Richard: LO has a similar problem.
       ptw: "
     Pekka: What two dimensions?
       ptw: Which is why I thought I had reviewed this already
     nickb: EPDL, of course, cheats by SegMerging on the quiet.
     nickb: (i.e. noticing that segments are adjacent and using this fact).
   Richard: What's a good default algorithm, without much overhead, that we can 
apply in situations like this?  How can we share it?
     Pekka: Should the arena be doing that?
   Richard: I think that's what ptw is suggesting, to some extent.
   Richard: (No pun intended.)
     Pekka: Then we probably want to protect parts of segments
       ptw: 2-d ptw imagines that if memory were 2-d you could have infinite 
segments on X axis that could grow infinitely in Y direction.
   Richard: Yes.  Big segments means big increments.  However, 100ms is about 
25 pages of scanning at the moment, and we can probably get that up to over 100.
       ptw: Yes, ptw believes the arena/seg substrate should do a better 2-d 
virtualization rather than each pool trying to do it on its own
     nickb: I didn't realize we were scanning a meg a second now. Used to be 
100k a second, ISTR
   Richard: But we must bound scanning somehow in Any case.
       ptw: We started with something like this and it got lost in the "great 
seg structure simplification"
   Richard: I must check my figures.
     nickb: Mine are memory-only, so don't trust them.
   Richard: ptw: We used to partially map segments, and have an "extent" field.
       ptw: Yes, and a "scanned so far" field.
   Richard: Suppose we must bound the segment size to some value based on 
timing constraints.  Perhaps that size is 100 pages.  It's still finite.  How 
does that help?
     nickb: Our current structure would support SegMerge, SegExtend, SegSplit 
without too much trouble. Then it's still up to the pools to use these wisely 
and at the right time, but it's better than what we've got now.
   Richard: The segment extent was never used well, or I wouldn't have removed 
it.
   Richard: It also wouldn't be hard to replace, if we could work out how to 
use it well.
       ptw: There is a tension between scanning and allocating requirements on 
segments.
   Richard: Oh yes.
   Richard: Don't I know it.
       ptw: It may be that a single structure is not the answer.
   Richard: I am thinking about that.
       ptw: In Genera/Minima Segments support allocating, Pages support 
scanning.
   Richard: Perhaps a general discussion on the topic is in order.
   Richard: I will start one.
     Pekka: Both need an contiguous area, other than that
   Richard: There's also Seg/Root commonality to think about.
   Richard: And protection.
       ptw: Seems to already be started.
   Richard: OK, let's move on.
       ptw: ./
   Richard: Any suggestions for next major?
   Richard: Pekka?
       ptw: [T- 10m]
     nickb: I'm not sure there are any more useful ones.
     nickb: Mine was that the code which depends on the Dylan format should 
check the
     nickb: format version number.
   Richard: OK, let's just burn 10 minutes and stop.
       ptw: My only other was my confusion about where rank sets come from or 
belong
   Richard: I think this code should be with the Dylan format code, and that 
would help.
   Richard: Er...
   Richard: OK, rank sets.
       ptw: Can the client really set the rank set in a buffer?
   Richard: Rank sets are copied from buffer to seg on allocation of a seg.  
This allows the pool to have segs of different rank sets allocated in it.
   Richard: Some pools allow APs to be created with different rank sets.
   Richard: AWL allows both RankEXACT and RankWEAK.
   Richard: (Each one allocates in different segments.)
   Richard: AMC used to allowe weak, but we took that out and did AWL instead.
       ptw: Then it is a major problem that the allocation code does not ensure 
a segment with the correct rank set is found?!?!?
   Richard: Because AMC's idea of weak wasn't what Dylan actually wanted.
   Richard: Hey.
            Richard looks at the code again
     nickb: I glanced at that when I was reading the design, and couldn't see 
the code to do it, but didn't get as far as that during my checking.
   Richard: Looks like a bug to me.
     nickb: It's documented in the design, you see. design.mps.poolawl.fun.fill.
   Richard: Yes.  I think this will allocate in the wrong segment.
   Richard: Hmm.  The design is right, as Nick points out, but the impl is 
wrong.
       ptw: I would have associated rank with pool, not buffer, as buffer seems 
more transient.
   Richard: Hmm.  What would pool->rankSet mean?
       ptw: This would also simplify scanning.
     Pekka: I would have assiciated with an object
     nickb: Does this get checked in PoolBufferFill?
       ptw: It would mean that you can only allocate objects of that rank in 
that pool.
       ptw: Pools are supposed to represent cliques -- objects with similar 
attributes -- are they not?
   Richard:     CHECKL(buffer->rankSet == SegRankSet(buffer->seg));
   Richard: impl.c.buffer
   Richard: ptw: Yes, but what about when you want a weak object.  How would 
you express that?
       ptw: I would put it in the weak pool.
     nickb: Do Americans pronounce "clique" as "cleek" or "click"?
       ptw: both
     nickb: Thought so.
   Richard: So you wouldn't have pools which could have more than one rank?
       ptw: "click" preferred, technically, but not often heard
   Richard: How would we prevent this bug in future?
     nickb: Note: "by finding it during review" is not an acceptable answer.
   Richard: I think the test must be poor if it didn't make that assertion fire.
     Pekka: Better stress test
   Richard: Pekka: Agree.
       ptw: Hum.  Actually consulting a recent dictionary, it list "cleek" first
     nickb: Right, better testing. I strongly suspect that rit will find this 
bug.
       ptw: Perhaps we should test that theory?
     nickb: descriptive, not prescriptive....
     nickb: [dictionaries, that is]
   Richard: Sqweeky Weets are the Weets with more Sqweek.  Did you know that 
the Sqweek to Weet ratio of the average packet...
       ptw: I would prevent it in the future by putting ranks on the pool.
   Richard: ptw: And not allowing pools with more than one rank?
       ptw: Yes
     Pekka: Woudn't that just lift the problem into client code?
   Richard: So, how would you implement this whole AWL thing?
     nickb: I guess I would have some generic stress tests for every pool class.
   Richard: And what about objects with more than one rank?
     nickb: (if a pool class provides buffering, it tests that, &c).
   Richard: (Which I intend to allow one day.)
   Richard: e.g. weak slots in objects
   Richard: or interleaved weak tables
     nickb: So how is that going to work with rank on segment?
       ptw: [Not having fully thought it out] Weak action into format, Table 
with weak part in an AMC pool with weak rank.
   Richard: Hmmm.  Tell you what, let's go through it, but not now.  I'll make 
a note and we'll discuss it.
       ptw: I would not allow multi-rank objects.  Clearly they can be 
implemented as multi-objects instead, just as Dylan tables are.
   Richard: That reduces our flexibility somewhat, but might be OK.
       ptw: Yes, as I am now at [T+ 2]
     nickb: Or through finalization.
   Richard: OK.  Bye.
       ptw: bye-bye
     nickb: I think we're about done here.
   Richard: Brainstorm closed.



Exit: exit.universal
