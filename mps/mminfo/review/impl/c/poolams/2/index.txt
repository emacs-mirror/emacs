                      REVIEW OF IMPL.C.POOLAMS(2)
                        review.impl.c.poolams.2
                              draft review
                           gavinm 1997-08-18

Rules: rule.impl
Source: design.mps.poolams
Candidate status: draft

Author: nickb
Leader: gavinm
Editor: nickb
Scribe: gavinm
Approved: 1997-09-04

Entry: entry.universal, entry.impl
Entry manpower: 1


Entry notes:

Too long, try to cover from both ends.
Entry brief because of late arrival.  GavinM 1997-08-18


Loggingstart: 16:06 BST
Loggingend: 16:53
Logginglength: 47
Loggingrate: 2

Checkers: Richard;DRJ;NickB;PTW;RIT;GavinM
Rate: 10 lines
Length: 1024
Actual checking time: 396

Kickoff start: 1997-08-18 14:38 BST (09:38 EDT)

Kickoff notes: Document too long, but try to get at least half-way through.
Need IRC for Logging meeting.
RIT joining us for experience of code review.
Purpose of review is to find major defects.


ISSUES:

GavinM: 4m 6I  68 minutes, up to line 520
PTW: 57 minutes, M: 1, m: 1, C: 1, q: 8, I: 5 back to line 625
RIT: 3M 3m 11q 70minutes, lines 1--624
NickB: 60 minutes, 2M, 6m, up to about line 700
Richard: 75 minutes; 5M, 10m, 8C, 1Q, 1I; lines 742-end
DRJ: 7M 5m 1I no idea how long down to line 691 ish

1. richard M 843,938: check Forgot to check stream.

2.  richard M 837: reclaimed+reclaimed might overflow.  Divide size by
two instead?  (Why not *2 anyway?)  This case is odd in any case.

3. richard M -: Each function needs a general overview
description. e.g. how does AMSReclaim work and why?

4. richard M 808: Need to set mark bits for entire object here to
maintain design.mps.poolams.invariant.black.  Assert black also. (Nick
knows about this)

5. drj M 770: AVERT(Seg, seg)

6. drj M 808: AVER colour

7. drj M 811: AVER p < next

8. drj M 836: 1024*1024 might overflow, should be 1024uL*1024

9. drj M 1015: i << blah might overflow, should be 1uL << blah

10. nickb M 137: check tables against the invariants.

11. rit M 27,39: these two functions should move (as nick says) to the
BT module

12. rit M 608: this line is the same as line 610, which makes me very
suspicious

13. rit M -: design.mps.poolams.invariant.fill will be trouble
later. It says buffers are filled black, but really they should be
filled the same colour as the mutator, which sounds like an
acknowledgement of a defect.

14. ptw M 648: Why are you testing SegWhite here rather than SegGrey?
Why would you scan a segment when it is white?

15. drj M 800: breaks if format->align is smaller than pool->align
which it isn't, but I think this is the only plkace where it's
important.

16. drj nM 600: (and similar in reclaim) could AVER tgat p is not in
buffer is buffer exists.

17. gavinm nI -: should we have a rule about checking previous values
whenever we assign?

18. richard nI -: Since format methods are external interface, should
we have more boilerplate around them?

19. nickb nQ 1009-1019: isn't there anything else we can check?

20. nickb nm 147-153: could add bounds on the enum so values could be
checked.

21. richard m -: style Too wide

22. richard m 1015: correctness What if grainShift is out of range?
The result is undefined.  Perhaps we need ShiftCheck.

23. richard m 962-963: clarity ASCII symbol key unclear

24. richard C -: suggestion Could have a general SegDescribe which
calls seg->pool->class->segDescribe

25. richard C 860: Superfluous?  Checked by BufferCheck.

26. richard m 865: "[]" indicates closed interval.  This one is
clopen.

27. richard C 881-885: Move to before 861?

28. richard m 934-935: Use standard form even at the end, to avoid
editing bugs.  (I've seen one in the past.)

29. richard C 927-931: I'd prefer ==0 and put this at the front of the
loop, with an extra \n at the end.

30. richard m 759-766,etc.: clarity Short comments explaining usage
would be nice.

31. richard I design.mps.poolams.reclaim.buffer: just.  Why?  (Because
we cannot reclaim this area as it is being initialized.)

32. richard m 792: Superfluous blank line.

33. richard m 790,798,800,811: Inconsistent use of p and next.
Suggest always using next?

34. richard C 816: If !anySurvivors and buffer != NULL could perhaps
arrange for buffer to be moved elsewhere (by trapping).  Maybe not.

35. richard C 819: Should perhaps be done by Tracer, since it must
always be done if the segment still exists.

36. richard m 698,etc.: Should we be using U.S. spelling?

37. richard C 720: Much of Fix is common.  Eliminate this switch?

38. richard Q 723: What does the Ref type do for us?

39. richard m 725: Prefer "break".  Avoid lots of returns if possible.

40. richard I 736: Zero should be a constant declared in mpmtypes.h as
RefNONE or similar.

41. richard C 742: This test might make this pool function as a leaf
pool automatically, given a little bit of extra work (i.e. buffers
with empty rank sets).  Could subsume LO.

42. ptw Q design.mps.poolams.invariant.object: I assume the intent is
to avoid the overhead of setting the colors of other grains, so they
can be left \"as is\"?

43. ptw I design.mps.poolams.invariant.object: in debug mode set check
the colors of all grains.

44. ptw Q design.mps.poolams.scans: Copying pools may have many scans
also (e.g., the current copyspace segment as copied objects are added
to it).  The distinction rests on using a hardware/segment-based read
barrier which requires the entire segment be scanned at once vs. the
m/s pool being non-moving and hence not needing a read barrier, does
it not?

45. ptw I design.mps.poolams.scans: The read barrier may still be
useful in finding what areas of the pool are accessed frequently by
the mutator.

46. ptw Q design.mps.poolams.marked.scan.fail: Can the scan also stop
prematurely because of incremental concerns, e.g., if the scan exceeds
its timeslice?

47. ptw Q design.mps.poolams.scan.all: Where is the color of a segment
with respect to traces kept?  Is that in the segment structure,
universal to all segments?

48. ptw Q design.mps.poolams.fix.to-black: This is hoisting the
summary optimization up a level.  Is it really worthwhile to do this,
since the summary optimization will avoid actually scanning any
objects when the segment is scanned later?

49. ptw I design.mps.poolams.reclaim: finish sentence

50. ptw Q design.mps.poolams.no-alloc: This makes me suspect that
PoolAlloc is not the right interface for our framework, that there
should be a 2-phase non-buffered allocation interface that is wrapped
up in adapter code for clients that expect a single-phase interface.

51. ptw Q -: I'm surprised we use floating point in the MPS.  Do we
really need to?

52. ptw I -: What is the purpose of the Hamming encoding of object
states? Wouldn't it be more straightforward and efficient to have 1
2-bit table to encode the four possible states?

53. ptw I -: Should part of the framework be a way for pools to be
asked to give up free segments, rather than the pool freeing segments
eagerly?

54. ptw C 741: I'm leery of this optimization.  It seems premature
given the rest of the code.

55. ptw Q 774: How does group->marked differ from SegGrey?

56. drj I design.mps.poolamc: .reclaim is truncated.

57. drj m 705: swap with 707 for clarity, check args in order

58. drj m 836: 1024*1024 is MAGIC

59. drj m 837: *2 would be clearer

60. drj m 991,992: space/tab problem

61. rit m 99: Add a note that this function only works when size is a
multiple of 1<<grainShift

62. rit m 602: Add space after comma between "group" and "p".

63. rit m 401: use PoolAlignment macro instead of ->alignment?

64. rit Q -: Should there be some general (i.e. not pool specific)
documentation about grains? I was confused for ages looking at lines
99 and 403 until I realised that the grain size is necessarily the
pool's alignment.

65. rit C -: perhaps because I'm not the intended audience, I often
didn't know what was expected of each function, and therefore whether
they were providing it. For example:

66. rit Q 428: Whose responsibility is it to set SegBuffer of the
segment chosen to fill the buffer?

67. rit Q 294--301: these lines are very similar to 325--328. Could we
avoid the duplication?

68. rit Q 265: why is summary not set when rankSet _is_ RankSetEMPTY ?

69. rit Q 253,301: argument to SpaceAlloc has type void**, but
argument to SpaceFree has type Addr. Why not void** and void* or Addr*
and Addr?

70. rit Q 376: (I know nothing about actions) Is it certain that
ActionFinish won't want to look at the segments which have just been
destroyed?

71. rit Q 454--463: How does this code avoid choosing a segment with
inappropriate rank?

72. rit Q 571: I don't understand how this code can work with multiple
traces. It doesn't seem to look at the trace before going ahead and
condemning segments. Yet .one-condemn seems to me to suggest it should
be checking something.

73. rit Q -: I think BTSetRange and BTResRange are badly named. (And
similarly for similar functions.) Res looks too much like Res (the
type) and reminds of "resource", "result", "reserved" and other
MM-like concepts. How about Set/Clear, One/Zero, 1/0 or On/Off ?

74. nickb m 60: add design tag

75. nickb m 134: add design tag

76. nickb m 145: not valid!

77. nickb m 450,452: consistency with line 250

78. nickb m 635,636: comment out of date

79. nickb m 660,&c: add design tag

80. rit Q -: I remember some stuff before about whether BT ranges were
inclusive or exclusive. Just to check that these new functions are
consistent with the existing ones in this respect.

81. drj nQ 449: surely already aligned?  isn't that part of buffer
protocol. Should AVER it rather than making it true.

82. gavinm m 250: Clarity: Needs a comment in justification.

83. gavinm m 303: Checking: Suggest AVER(res != ResOK)

84. gavinm m 320: Clarity: This line is unclear

85. gavinm I 365-374: Should be a Ring iterator for this

86. gavinm I design.mps.poolams: Design is incomplete.

87. gavinm I design.mps.poolams: The significance of the
alloc/mark/scan flags is not defined.

88. gavinm I design.mps.poolams: Should describe transitions between
states, and have references from code for transitions

89. gavinm I -: "set" has too many senses

90. drj nm 320: shouldn't this be in AMSTraceEnd (which doesn't exist)

91. gavinm I -: Group should be a sub-class of Seg

92. ptw I -: group should _be_ a seg

93. PTW -: nI not having an accepted design makes review concentrate on 
nitpicks rather than whether the program does what it should do.

94. drj Nm 647-652&c: scanOnce <=> scanAllObjects, mail.drj.1997-08-28.11-44




Brainstorm start: 17:17
Brainstorm end: 17:59
Brainstorm length: 42


BRAINSTORM:

GavinM: There were 17 issues.
  I'd like to do what we did last time, and present the list, for people to 
select what they think worth discussion.
DRJ: 4 and 7 are same or subsumed or subset or something
NickB: 3,4,12,16
Richard: 2,8,9 are all about arithmetic
RIT: 3, 4, 12 important
Richard: I think these arithmetic things are important because they won't show 
up easily until run-time.
PTW: Gavin, you had I design.pool.ams is incomplete.  I believe that is M, and 
should be the topic of brainstorm.
DRJ: er, 2, 8, 9 are easy to brainstorm
GavinM: Ok.  Lets start with {2,8,9}


> 2. Richard 837  M  reclaimed+reclaimed might overflow.  Divide size by two 
instead?  (Why not *2 anyway?)  This case is odd in any case.
> 8. DRJ 836 M 1024*1024 might overflow, should be 1024uL*1024
> 9. DRJ 1015 M i << blah might overflow, should be 1uL << blah

PTW: - nM not having an accepted design makes review concentrate on nitpicks 
rather than whether the program does what it should do.
NickB: 1024*1024 is a bogus constant which is just in there to make it collect 
for testing. As I say in the design, a real pool would need a real benefit 
computation.
  So it didn't get thought about, because it wasn't important.
DRJ: does that justify it being wrong on 16bit int platforms?
Richard: Nick: That's no the defect.
DRJ: oh I see.
GavinM: Richard,PTW, We'll get to that.
NickB: The *2 thing is again an accident of how it got bunged in.
Richard: Is there something we can do to make sure arithmetic gets done 
correctly?
DRJ: in general one should be very careful when doing arithmetic with literals 
because they are ints and ints have a nasty habit of overflowing.
PTW: There must be a tool that would simply find these potential overflows and 
flag them, or a compiler that will generate trapping arithemetic
DRJ: when using variables we are much safer because they already have the right 
type.
GavinM: We ought to be able to find a lint we can use.
NickB: Ah, the automatic tools conversation.
Richard: Schedule time for lint research.
GavinM: Ah.  The scheduling conversation.
PTW: Has noone written any type-inferencing tool for this language?
DRJ: q: do we every need a literal that is an int? (an int as opposed to a Word 
or a Size or something)
  there is LCLint
Richard: ptw: LCLint, but it seems to be too buggy, ironically.
PTW: Ah, the cynicism conversation.
NickB: The 1 << foo bug is interesting. Do we have IsLog2(x,y)? If so, I should 
have used that.
GavinM: I think we do.
DRJ: no, we don't have IsLog2
NickB: Yes, there are very good tools for  this langauge. You have to pay for 
them.
Richard: Ah, the money conversation.
NickB: [allegedly very good, that is]
DRJ: my point is, where we have int constants there are (or perhaps should be) 
an enum thingy, and every where else the literals should be of some type other 
than int
GavinM: So, suggested actions to prevent this type of defect in future?
PTW: How many person-hours of review time for one of these allegedely very good 
tools?
DRJ: ergo, all numeric literals should have a suffix thingy
Richard: Always cast literals.
DRJ: or cast them which is more ugly but much the same
NickB: David is right, except for 0.
Richard: Superior, imo.
GavinM: Arguably even 0.
  I could be looking for that sort of thing on my brief check
NickB: So what should I have cast 1024 to? Size? Maybe one of them is a Size 
and the other is a Count.
DRJ: casts are superior.  I worry about hiding incorrect type bugs if you use a 
cast
GavinM: ... although it's supposed to be scanning for major defects.
Richard: The thing about always casting them is that you have to think about 
their type.  The suffix thing is OK, but not quite as powerful in that respect.
NickB: I forget, I think it was something like 5000 currency units.
  (which I thought was pretty reasonable)
Richard: (Size)1048576
DRJ: richard, cast is better, in fact it shows up wrong type bugs
NickB: OK.
Richard: (Size)1 << foo etc.
Richard: You didn't like my "always cast constants" rule.  This is one of the 
main justifications.  
[...]


GavinM: PTW and Richard wanted to discuss the lack of design.
Richard: So, Nick, why do you refuse to write the design?
NickB: Because I don't have time.
Richard: Ah, the time conversation.
NickB: We're already somewhat behind on PS for GC.
RIT: But without the design, how did you write the pool?\
DRJ: if you hadn't written the pool, but had written the design instead it 
would have been much better
NickB: With design in my head (and Richard's).
DRJ: becasue we could've reused the design directly without having to back 
infer it from the implementation
NickB: No, it would have been much worse, because the design would have been 
full of bugs.
GavinM: Is that shared memory or distributed design?
NickB: (for instance, it would still have had the .clever-summary stuff in).
Richard: Interesting.  Are you asserting that design is likely to be wrong 
unless implemented?
DRJ: judging from conversations we had last week I don't think it would've had 
as many bugs as AWL
NickB: Definitely, yes, we know that.
  Ah, ambiguity strikes.
Richard: But perhaps implementations are likely to be wrong without design.
DRJ: re the clever stuff I thought that came about through ptw pointing out 
that we did the wrong thing with buffered segs?
Richard: No, it was my fault.
NickB: design without implementation is likely to be wrong, because 
implementation stresses design in ways which are hard without an implementation.
PTW: Yes, when reviewing the "proto design"
DRJ: yes, that's true.
NickB: yes, it's true the other way around too.
  Of course, we all know this, this is what the design/implement iteration 
process ideas are all about.
GavinM: So I guess we're back to the chicken and egg conversation?
NickB: (and why waterfall is wrong)
DRJ: but the point of the effort was pedagogy no?  so is it more helpful to 
have a purportedly correct implmentation with little design or a slightly less 
correct design?
Richard: Mind you, AWL had a design document, and it was quite defective.
PTW: So it needs to be a cycle.  But we weem to always break the cycle once we 
get an implementation.
RIT: Yes, you need to have a design fluid enough to change as you gain 
experience from implementing it. And Richard's head it probably a good place 
for such a design. 
  The problem is, there's no record of what's in your and Richard's head, so 
the reasons for all the design decisions are lost.
GavinM: Richard's head has drawbacks as a design repository.
PTW: No.  No-one's head is a good place for design if we are trying to apply 
process to it.
NickB: But we need to snapshot the design in concrete once we have an 
implementation.
Richard: I agree with Tucker.
NickB: ptw is right.
GavinM: It's more vulnerable to bus wheels than the Information System.
DRJ: after all, the infosys can survive a nuclear attack
NickB: design can live in a head until there's a first implementation.
PTW: If we are brainstorming process, the process should ensure that we don't 
cop out on design just because we have an implementation.
NickB: but after that we need a concrete design.
DRJ: well, I find writing the design first is helpful.  I certainly expect to 
"debug it" during the implementation though
GavinM: We're all agreed about this, but it always drops out in the time 
pressure.
NickB: BTW, for this impl I followed the impl/design process we discussed at a 
previous review.
Richard: Pressure shemessure.  It's just not included in anyones plan.
NickB: (i.e. whenever I find myself thinking [or writing] a design thought, I 
jot it down in the design)
Richard: Nick's estimates for EP are way off.
DRJ: what process was that?  every time you want to write a comment writ it in 
the design?  aha 
PTW: Er, how much time is spent on m, q, etc. reviewing implementation that 
could be better applied to design and review of same?
Richard: And they don't include design time.
NickB: (and tag it and ref it from the impl)
GavinM: Richard, when you stop being manager, will you have more time to tidy 
up design?
  Nick, that's definitely  a good start.
Richard: Gavin: Depends on what my manager wants me to do, doesn't it.
NickB: My estimates for EP are derived from their schedules.
DRJ: Hmm, I'm not sure the problem can be solved merely by planning more time 
for everything.
Richard: nickb: It must be done in X amount of time, so it will be?
DRJ: nickb, I think that gets down a lot of the niggly design points. 
  and very few of the high level ones
NickB: Yep, that's the Harlequin way, and if we don't like it we can fight it 
out with Jo. I'm not in a position to have a fight with Jo.
GavinM: How did the Development Manager ever sign off on that?
PTW: That's how everything works, so one must apply the scarce time resource in 
a way that gets the greatest benfit.
NickB: DRJ: you are right, of course.
Richard: I will be.  He wants to talk to me in person.  I could beat him up.
DRJ: so, to get high level design, write the design before the impl, to get low 
level design, write it during the impl
  and both are necessary of course
NickB: drj: right.
GavinM: DRJ, yes.
PTW: And ration time cycles so that design does not get shriven
NickB: drj: in particular, the high-level design for this, as I had it in my 
head before hand, was full of crap.
DRJ: the more I think about this, the more I think that the low level design is 
the hardest to reconstruct
GavinM: Nick, how would you have gotten on with jotting down high-level notes 
before you started?
DRJ: so it is more important that that part of the design gets written (and 
written during the impl)
NickB: We can write the high-level design now; it's clear from the impl and 
low-level design (although it's not actually derived from those of course).
  GavinM: I could have done it; I'm not sure it would have been useful.
GavINM: Perhaps having shriven design would be useful.  Confess your design and 
gain the absolution of approval.
DRJ: when I have done revised a design in light of the impl the hardest problem 
I have is keeping them synchronised.  it's quite grainy work.
NickB: Thank goodness we're not having the "design doesn't exist" conversation.
DRJ: so I wonder if we should return to ptw's suggestion of using c web
PTW: I was thinking it was a sin to not have a design
NickB: By the way, this document was made harder to review by the fact that it 
was printed in 68 columns.
GavinM: Nick, yes.  That's why jotting down notes is good.
DRJ: for the low level design.  I don't think c web is appropriate for high 
level design, though it might be.
PTW: Mine was printed 2-up
GavinM: Nick, I don't know why that happened.
NickB: Can we find out and try to make it not happen again?
  C-Web is a major process step for us.
GavinM: Yes.  The problem is that I "didn't change anything".
DRJ: gavinm, but C-web might be something we can introduce incrementally.
GavinM: I know little of it.  Can you brief me later, please?
NickB: Can we use C-Web on all our platforms?
DRJ: I know little of it.
  so er what about design?
  do we need a process improvement?
  schedule time for high level design?  always write design notes when writing 
the impl?
  don't slack?
Richard: Yes, but I don't know what it is.
GavinM: Perhaps we could explain high-level ideas to a scribe?
PTW: review design first?
NickB: Always write design notes.
DRJ: didn't work wonders for AWL
RIT: gavin's idea may be a good one. 
GavinM: Design notes are definitely good.  Nick did well there.
DRJ: (reviewing design first, that is, didn't work wonders for AWL)
RIT: because explaining things to someone will probably make them much clearer 
than writing them yourself.
NickB: BTW, a key process improvement for writing this impl would have been 
"have complete reviewed documentation for all module interfaces".
DRJ: yes, design notes are good.
GavinM: design.mps.poolams CN It's good to see so many design notes.
RIT: but yes, Nick's notes were very very helpful.
NickB: [especially the pool class contract]
DRJ: nickb, I agree with that improvement.
Richard: Meta-process improvement.  These process improvements never actually 
get incorporated into process, as far as I can see.
PTW: What about the idea of a buddy system where 1 other person must give 
informal review
GavinM: Nick, yes.  Hopefully Richard will have time to do that soon.
DRJ: lately writely code for the MPS feels like wandering through an interface 
of jelly filled with mines
NickB: Otherwise one either writes a buggy class or gets Richard to kibbitz (I 
did the latter)
RIT: Nick's point about module interfaces is, though I hate to use the word, 
key.
GavinM: Richard, it's hard because a lot of our development process is 
unwritten, but a lot of this does get institutionalized.
RIT: Without them, you can't implement or indeed review the code easily.
DRJ: yes, interfaces and contracts
NickB: kibbitzing helped a lot in writing this impl.
PTW: So you informally had a buddy.  Process improvement: formal buddies
NickB: Right.
Gavin: Agreed.
DRJ: yes, I think a non-richard buddy would've been almost as useful.
PTW: Except Richard must be everybody's buddy
NickB: Given a pool contract document, anybody could have helped.
Gavin: NickB, yes.
RIT: yes indeed.
NickB: Richard's key contribution was understanding the pool contract.
GavinM: Well, if we let Richard take the time to write design, we won't need to 
interrupt him so much.
DRJ: yes, a long time ago (possibly the second time I wrote a pool) I took the 
time out to write the pool class contracts
PTW: Let him write contracts
GavinM: Also, Richard should have more time RSN.
Richard: Everyone's waiting to use up my "more time".
GavinM: DRJ, where is that?
PTW: Process improvement:  buddy approval required for review entry
DRJ: I wrote them up in design.mps.class-interface, which is a bit out of date 
now
NickB: There are several good design documents, but so many bad or nonexistent 
ones that I tend to assume that they don't exist.
GavinM: PTW, interesting suggestion.
Richard: Management must make design happen.
  I have failed in doing that, partly by setting a bad example, I think.
NickB: ptw: I quite like that idea.
Richard: And perhaps I should've been more draconian when we had more time.
DRJ: some of it is still accurate.  some of it is still accurate when one 
substitutes segment for pool
GavinM: Being DARWIN driven doesn't help us write design.
RIT: it could be a condition on release that we won't release anything without 
a design doc.
Richard: rit: Such negative conditions don't help much.  We need to have 
positive measures.
RIT: yes, I suppose that's true.


GavinM: Any other issue we ought to discuss now?
DRJ: what about the merits of the buddy system?
RIT: how to review long documents?
GavinM: How successful were we at reviewing this long document?
RIT: Well, there were a few lines in the middle which I think only 1 person 
looked at? And noone read the whole doc, so if there are bugs in the joins 
between functions, we won't have spotted them.
GavinM: RIT, true.



Number of major issues: 17
Number of minor issues: 28
Number of issues: 93
Major defects remaining: 1

Edit manpower: 17


Edit notes:

     1. Comment: can't check an mps_lib_FILE *.
     2. Fix: divide by 2 instead.
     3. Fix: added lots of comments.
     4. Fix: make it all black; add to design as well.
     5. Fix: added AVERT.
     6. Fix: added AVER.
     7. Fix: added AVER.
     8. Fix: made uL.
     9. Fix: made uL.
    10. Fix: iterate over the grains checking their colour.
    11. Fix: moved to bt.c (along with BTCreate and BTDestroy).
    12. Fix: removed line 610.
    13. Comment: added to trace.c and design.mps.poolams.invariant.alloc
    14. Reject: white segments are scanned when they have started to go grey.
    15. Fix: all alignments are always equal; we now assert and document this.
    16. Fix: AVER added to Iterate.
    17. Raise: request.process.170489
    18. Pass: richard
    19. Mail: mail.nickb.1997-09-02.11-05
    20. Fix: added bounds, check macro, uses of macro.
    21. Fix.
    22. Fix. shift right instead of left.
    23. Fix: made more verbose.
    24. Forget: this is a lot of work just to make description more uniform.
    25. Fix: removed.
    26. Fix. (although [a-b] doesn't indicate any kind of interval).
    27. Reject: tried it that way and it looked worse because of the 
uninitialized variables.
    28. Fix.
    29. Fix.
    30. Fix: added short comments to all non-obvious local declarations.
    31. Raise: request.mps.170491
    32. Fix.
    33. Fix.
    34. Fix: added design.mps.poolams.reclaim.empty.buffer.
    35. Fix: added comment to tracer.
    36. Reject: No; there is no reason to use US spelling in sources.
    37. Fix: added comment to tracer.
    38. Mail: mail.nickb.1997-09-02.14-51
    39. Fix.
    40. Raise: request.mps.170493
    41. Forget: in fact this pool will _now_ work as a leaf pool (with empty 
rank sets).
    42. Mail: mail.nickb.1997-09-02.11-17
    43. Reject: as now explained in the design this is impossible.
    44. Mail: mail.nickb.1997-09-02.11-20
    45. Raise: request.mps.170491
    46. Mail: mail.nickb.1997-09-02.14-46
    47. Mail: mail.nickb.1997-09-02.14-44
    48. Mail: mail.nickb.1997-09-02.14-31
    49. Fix: rewritten.
    50. Mail: mail.nickb.1997-09-02.13-38
    51. Mail: mail.nickb.1997-09-02.13-35
    52. Raise: request.mps.170491
    53. Raise: added note to request.mps.170348
    54. Forget: same as issue 48.
    55. Mail: mail.nickb.1997-09-02.13-29
    56. Fix.
    57. Fix.
    58. Fix: move into config.h.
    59. Fix: divide by two now.
    60. Fix.
    61. Fix.
    62. Fix.
    63. Fix.
    64. Mail: mail.nickb.1997-09-02.13-13
    65. Forget: this wasn't really an issue.
    66. Mail: mail.nickb.1997-09-02.13-05
    67. Mail: mail.nickb.1997-09-02.13-01
    68. Mail: mail.nickb.1997-09-02.12-39
    69. Mail: mail.nickb.1997-09-02.12-33
    70. Mail: mail.nickb.1997-09-02.12-31
    71. Mail: mail.nickb.1997-09-02.12-29
    72. Mail: mail.nickb.1997-09-02.12-26
    73. Raise: request.mps.170492
    74. Fix.
    75. Fix.
    76. Fix.
    77. Fix: this code has gone away now.
    78. Fix: this code has gone away now.
    79. Fix: this code has gone away now.
    80. Mail: mail.nickb.1997-09-02.11-59
    81. Mail: mail.nickb.1997-09-02.11-57
    82. Fix: added comment.
    83. Fix: added.
    84. Fix: wrote design and added design tag.
    85. Raise: escalated to email discussion.
    86. Raise: request.mps.170491
    87. Raise: request.mps.170491
    88. Raise: request.mps.170491
    89. Reject: facetious.
    90. Reject: it works just as well here, and saves a function.
    91. Raise: request.mps.170494
    92. Raise: request.mps.170494
    93. Pass: gavinm 
    94. Fix.




Exit: exit.universal
Exit manpower: 0.5

Manpowerused: 35
Manpowersaved: 170
