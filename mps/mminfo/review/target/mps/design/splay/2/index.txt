        CANONICAL DOCUMENT FOR THE REVIEW OF DESIGN.MPS.SPLAY(2)
                    review.target.mps.design.splay.2
                             incomplete doc
                             drj 1999-03-10

.source: This is a frozen copy of design.mps.splay(2) with added line numbers.  
It is to be reviewed on 1999-03-10.

     1  design.mps.splay(2)  draft doc
     2  
     3  DESIGN OF SPLAY TREES
     4  gavinm; tony, 1998-05-01
     5  
     6  
     7  INTRODUCTION
     8  
     9  .intro: This document explains the design of impl.c.splay, an
    10  implementation of Splay Trees, including its interface and
    11  implementation.
    12  
    13  .readership: This document is intended for any MM developer.
    14  
    15  .source: The primary source for this design is paper.st85(0).  Also, as
    16  CBS is a client, design.mps.cbs.  Also, as PoolMV2 is an (obsolescent?)
    17  indirect client, design.mps.poolmv2.
    18  
    19  
    20  Document History
    21  
    22  .hist.0: Written by GavinM 1998-05-01, made draft 1998-05-27.
    23  
    24  .hist.1: Added client properties.  GavinM 1998-09-09
    25  
    26  .hist.2: Polished for review (chiefly adding a DEFINITIONS section).
    27  drj 1999-03-10
    28  
    29  
    30  OVERVIEW
    31  
    32  .overview: Splay trees are a form of binary tree where each access
    33  brings the accessed element (or the nearest element) to the root of the
    34  tree.  This gives excellent amortised performance, as the splay tree
    35  adapts its shape to usage patterns.  Unused nodes have essentially no
    36  time overhead.  For a cute animation of splay trees, see
    37  <URL:http://langevin.usc.edu/BST/SplayTree-Example.html>.
    38  
    39  
    40  DEFINITIONS
    41  
    42  .def.splay-tree: A "Splay Tree" is a self-adjusting binary tree (as
    43  described in paper.st85(0), paper.sleator96(0)).
    44  
    45  .def.node: A "node" is used in the typical datastructure sense to mean
    46  an element of a tree (see also .type.splay.node).
    47  
    48  .def.key:  A "key" is a value associated with each node; the keys are
    49  ordered by a client provided comparator.  The keys are implemented by
    50  the type "void *" in this implementation.
    51  
    52  .def.comparator: A "comparator" is a function that compares keys to
    53  determine their ordering (see also .type.splay.compare.method).
    54  
    55  .def.client-property: A "client-property" is the value of a function
    56  (which has some restrictions) at each node.  This splay tree
    57  implementation provides support for efficiently maintaining the property
    58  and for finding nodes with particular properties.  See also .prop below.
    59  
    60  
    61  REQUIREMENTS
    62  
    63  .req: These requirements are drawn from those implied by
    64  design.mps.poolmv2, and general inferred MPS requirements.
    65  
    66  .req.fast: Common operations must have low amortized cost.
    67  
    68  .req.order: Must maintain a set ordered by an abstract key and a
    69  comparator.
    70  
    71  .req.add: Must be able to add new members.
    72  
    73  .req.remove: Must be able to remove members.
    74  
    75  .req.locate: Must be able to locate a member, given a key.
    76  
    77  .req.neighbours: Must be able to locate the neighbouring members (in
    78  order) of a non-member, given a key.
    79  
    80  .req.iterate: Must be able to iterate all members in order.  This will
    81  not be a common operation.
    82  
    83  .req.protocol: Must support detection of protocol violations.
    84  
    85  .req.debug: Must support debugging of clients.
    86  
    87  .req.stack: Must do all non-debugging operations with a fixed size
    88  stack.
    89  
    90  .req.adapt: Must adapt to regularities in usage pattern, for better
    91  performance.
    92  
    93  .req.find: Must support rapid finding of the first and last elements to
    94  meet some client property.
    95  
    96  
    97  EXTERNAL TYPES
    98  
    99  .type.splay.tree: SplayTree is the type of the main object at the root
   100  of the splay tree.  It is intended that the SplayTreeStruct can be
   101  embedded in another structure.  No convenience functions are provided
   102  for allocation or deallocation.
   103    typedef struct SplayTreeStruct SplayTreeStruct, *SplayTree;
   104  
   105  .type.splay.node: SplayNode is the type of a node of the splay tree.
   106  Again, it is intended that the SplayNodeStruct can be embedded in
   107  another structure.  No convenience functions are provided for allocation
   108  or deallocation.
   109    typedef struct SplayNodeStruct SplayNodeStruct, *SplayNode;
   110  
   111  .type.compare: [This belongs in design.mps.types.]  The Compare type is
   112  the return value of a tri-state comparison function.  Its value is one
   113  of CompareLESS, CompareEQUAL, and CompareGREATER.  It represents the
   114  valid operator to conjoin the arguments to the comparison function, in
   115  order.
   116  
   117  .type.splay.compare.method: SplayCompareMethod is a pointer to a
   118  function with the following prototype:
   119    Compare compare(void *key, SplayNode node);
   120  The function is required to compare the key (as passed into a function,
   121  see below) with the key the client associates with that splay tree node,
   122  and return the appropriate Compare value.
   123  
   124  .type.splay.node.describe.method: SplayNodeDescribeMethod is a pointer
   125  to a function with the following prototype:
   126    Res nodeDescribe(SplayNode node, mps_lib_FILE *stream)
   127  The function is required to write (via WriteF) a client-oriented
   128  representation of the splay node.  The output should be non-empty,
   129  short, and without return characters.  This is provided for debugging
   130  purposes only.
   131  
   132  .type.splay.test.node.method: SplayTestNodeMethod is a pointer to a
   133  function with the following prototype:
   134    Bool testNode(SplayTree tree, SplayNode node, void *closureP, unsigned
   135  long closureS);
   136  The function is required to determine whether the node itself meets some
   137  client determined property (see .prop).
   138  
   139  .type.splay.test.tree.method: SplayTestTreeMethod is a pointer to a
   140  function with the following prototype:
   141    Bool testTree(SplayTree tree, SplayNode node, void *closureP, unsigned
   142  long closureS);
   143  The function is required to determine whether any of the nodes in the
   144  sub-tree rooted at the given node meet some client determined property
   145  (see .prop).  In particular, it must be a precise (not conservative)
   146  indication of whether the testNode method (see
   147  .type.splay.test.node.method) would return TRUE for any nodes in the
   148  sub-tree. 
   149  
   150  .type.splay.update.node.method: SplayUpdateNodeMethod is a pointer to a
   151  function with the following prototype:
   152    Bool updateNode(SplayTree tree, SplayNode node, SplayNode leftChild,
   153  SplayNode rightChild);
   154  The function is required to update any client datastructures associated
   155  with a node to maintain some client determined property (see .prop)
   156  given that the children of the node have changed.  If the node does not
   157  have one or both children, then NULL will be passed as the relevant
   158  parameter.
   159  
   160  
   161  EXTERNAL FUNCTIONS
   162  
   163  .function.splay.tree.check: This is a check function for the SplayTree
   164  type:
   165    Bool SplayTreeCheck(SplayTree tree);
   166  
   167  .function.splay.node.check: This is a check function for the SplayNode
   168  type:
   169    Bool SplayNodeCheck(SplayNode node);
   170  
   171  .function.splay.tree.init: This function initialises a SplayTree.  It
   172  requires a compare method that defines a total ordering on nodes; the
   173  effect of supplying a compare method that does not implement a total
   174  ordering is undefined.  The updateNode method will be used to keep
   175  client properties up to date when the tree structure changes; it is
   176  optional and may be given as NULL.
   177    void SplayTreeInit(SplayTree tree, SplayCompareMethod compare,
   178  SplayUpdateNodeMethod updateNode);
   179  
   180  .function.splay.tree.finish: This function clears the fields of a
   181  SplayTree.  Note that it does not attempt to finish or deallocate any
   182  associated SplayNode's.
   183    void SplayTreeFinish(SplayTree tree);
   184  
   185  .function.splay.node.init: This function initialises a SplayNode.
   186    void SplayNodeInit(SplayNode node);
   187  
   188  .function.splay.node.finish: This function clears the fields of a
   189  SplayNode.  Note that it does not attempt to finish or deallocate any
   190  referenced SplayNode's.
   191    void SplayNodeFinish(SplayNode node);
   192  
   193  .function.splay.root: This function returns the root node of the tree,
   194  if any.  If the tree is empty, FALSE is returned and nodeReturn is not
   195  changed.  Otherwise, TRUE is returned and nodeReturn is set to the root.
   196   Bool SplayRoot(SplayNode *nodeReturn, SplayTree tree);
   197  
   198  .function.splay.tree.insert: This function is used to insert a new node
   199  into a splay tree.  The supplied key is that key that the client will
   200  associate with this node.  If an attempt is made to insert a node that
   201  compares CompareEQUAL to an existing node in the tree, then ResFAIL will
   202  be returned.
   203    Res SplayTreeInsert(SplayTree tree, SplayNode node, void *key);
   204  
   205  .function.splay.tree.delete: This function is used to delete a node from
   206  a splay tree.  The supplied key is that key that the client associates
   207  with the node.  If the tree does not contain the given node, or the
   208  given node does not compare CompareEQUAL with the given key, then
   209  ResFAIL will be returned, and the node will not be deleted.
   210    Res SplayTreeDelete(SplayTree tree, SplayNode node, void *key);
   211  
   212  .function.splay.tree.search: This function searches the splay tree for a
   213  node that compares CompareEQUAL to the given key.  It returns ResFAIL if
   214  there is no such node in the tree. 
   215    Res SplayTreeSearch(SplayNode *nodeReturn, SplayTree tree, void *key);
   216  
   217  .function.splay.tree.neighbours: This function searches a splay tree for
   218  the two nodes that most closely neighbour the given key.  leftReturn
   219  will be NULL (if the given key compares CompareLESS with all nodes in
   220  the tree) or will compare CompareLESS with the given key.  rightReturn
   221  will be NULL (if the given key compares CompareGREATER with all nodes in
   222  the tree) or will compare CompareGREATER with the given key.  leftReturn
   223  and rightReturn (if non-NULL) will be adjacent in comparision order in
   224  the splay tree.  The function returns ResFAIL if any node in the tree
   225  compares CompareEQUAL with the given key.
   226   Res SplayTreeNeighbours(SplayNode *leftReturn, SplayNode *rightReturn,
   227  SplayTree tree, void *key);
   228  
   229  .function.splay.tree.first: This function splays the tree at the first
   230  node, and returns that node.  The supplied key should compare
   231  CompareLESS with all nodes in the tree.  It will return NULL is the tree
   232  has no nodes.
   233    SplayNode SplayTreeFirst(SplayTree tree, void *zeroKey);
   234  
   235  .function.splay.tree.next: This function receives a node and key and
   236  returns the successor node to that node.  This function is intended for
   237  use in iteration when the received node will be the current root of the
   238  tree, but is robust against being interspersed with other splay
   239  operations (provided the old node still exists).  The supplied key must
   240  compare CompareEQUAL to the supplied node.  Note that use of this
   241  function can unbalance the tree and give poor amortised performance (see
   242  .future.parent).
   243    SplayNode SplayTreeNext(SplayTree tree, SplayNode oldNode, void
   244  *oldKey);
   245  
   246  .function.splay.tree.describe: This function prints (using WriteF) to
   247  the stream a textual representation of the given splay tree, using
   248  nodeDescribe to print client-oriented representations of the nodes.
   249    Res SplayTreeDescribe(SplayTree tree, mps_lib_FILE *stream,
   250  SplayNodeDescribeMethod nodeDescribe);
   251  
   252  .function.splay.find.first: SplayFindFirst finds the first node in the
   253  tree that satisfies some client property (as determined by the testNode
   254  and testTree methods).  closureP and closureS are arbitrary closures
   255  passed to the testNode and testTree methods.  If there is no
   256  satisfactory node, then FALSE is returned.  This function may not be
   257  called if SplayTreeInit was passed a NULL updateNode method.
   258    Bool SplayFindFirst(SplayNode *nodeReturn, SplayTree tree,
   259  SplayTestNodeMethod testNode, SplayTestTreeMethod testTree, void
   260  *closureP, unsigned long closureS);
   261  
   262  .function.splay.find.last: SplayFindLast finds the last node in the tree
   263  that satisfies some client property (as determined by the testNode and
   264  testTree methods).  closureP and closureS are arbitrary closures passed
   265  to the testNode and testTree methods.  If there is no satisfactory node,
   266  then FALSE is returned.  This function may not be called if
   267  SplayTreeInit was passed a NULL updateNode method.
   268    Bool SplayFindFirst(SplayNode *nodeReturn, SplayTree tree,
   269  SplayTestNodeMethod testNode, SplayTestTreeMethod testTree, void
   270  *closureP, unsigned long closureS);
   271  
   272  .function.splay.node.refresh: SplayNodeRefresh must be called whenever
   273  the client property (see .prop) at a node changes.  It will call the
   274  updateNode method on the given node, and any other nodes that may
   275  require update.  The client key for the node should also be supplied.
   276    void SplayNodeRefresh(SplayTree tree, SplayNode node, void *key);
   277  
   278  
   279  CLIENT-DETERMINED PROPERTIES
   280  
   281  .prop: This splay tree implementation provides an additional feature
   282  used to support fast finding.  Each node may be considered to have a
   283  client property that is a function of client attributes at that node,
   284  and the value of that function at the node's children.  The client is
   285  given the opportunity to cache the function value for each node via the
   286  updateNode method.  The splay tree implementation uses the cached values
   287  as part of SplayFindFirst and SplayFindLast via the testNode and
   288  testTree methods.  The client may use the SplayNodeRefresh method to
   289  indicate that the client attributes at a node have changed.
   290  
   291  .prop.callback: The client's updateNode method might look something
   292  like:
   293    ClientUpdateNode(SplayTree tree, SplayNode node,
   294                     SplayNode leftChild, SplayNode rightChild)
   295    {
   296      ClientObject object;
   297      ClientProperty maxProperty;
   298  
   299      object = ClientObjectOfSplayNode(node);
   300      maxProperty = ClientObjectProperty(object);
   301   
   302      if(leftChild != NULL) {
   303        ClientProperty property =
   304          ClientObjectProperty(ClientObjectOfSplayNode(leftChild));
   305        if(property > maxProperty)
   306          maxProperty = property;
   307      }
   308   
   309      if(rightChild != NULL) {
   310        ClientProperty property =
   311          ClientObjectProperty(ClientObjectOfSplayNode(rightChild));
   312        if(property > maxProperty)
   313          maxProperty = property;
   314      }
   315      
   316      ClientObjectSetProperty(object, maxProperty);
   317  
   318      return;
   319    }
   320  
   321  This callback will also be used when creating new splay nodes in the
   322  obvious way.
   323  
   324  .prop.ops: Consider the splay operations (.impl.* for details):
   325  
   326  .prop.ops.rotate: rotate left, rotate right -- We need to update the
   327  value at the original root, and the new root, in that order.
   328  
   329  .prop.ops.link: link left, link right -- These operations are more
   330  troublesome.  We know that the line of right descent from the root of
   331  the left tree and the line of left descent from the root of the right
   332  tree will both need to be updated.  We could update these chains every
   333  time we do a link left or link right, but it would be more efficient to
   334  leave this until the assembly stage.
   335  
   336  .prop.ops.assemble: assemble -- This operation also invalidates the
   337  lines of right and left descent of the left and right trees respectively
   338  which need to be updated (see below).  It also invalidates the root
   339  which must be updated last.
   340  
   341  To correct the chains of the left and right trees without requiring
   342  stack or high complexity, I propose that we use a judicious amount of
   343  pointer reversal, much as I am generally opposed to the technique.
   344  
   345  During the assembly, after the root's children have been transplanted,
   346  we correct the chains of the left and right trees.  For the left tree,
   347  we traverse the right child line, reversing pointers, until we reach the
   348  node that was the last node prior to the transplantation of the root's
   349  children.  Then we update from that node back to the left tree's root,
   350  restoring pointers.  Updating the right tree is the same, mutatis
   351  mutandis.
   352  
   353  
   354  IMPLEMENTATION
   355  
   356  .impl: For more details of how splay trees work, see paper.st85(0).
   357  Here we describe the operations involved.
   358  
   359  
   360  Top-Down Splaying
   361  
   362  .impl.splay: The key to the operation of the splay tree is the function
   363  SplaySplay.  It searches the tree for a node with a given key and
   364  returns whether it suceeded.  In the process, it brings the found node,
   365  or an arbitrary neighbour if not found, to the root of the tree.  This
   366  "bring-to-root" operation is performed top-down during the search, and
   367  it is not the simplest possible bring-to-root operation, but the
   368  resulting tree is well-balanced, and will give good amortised cost for
   369  future operations.
   370    
   371  This "top-down splay" is performed by comparing the middle tree with the
   372  following six cases, and performing the indicated operations, until none
   373  apply.  As a working space, we keep a left tree and a right tree (stored
   374  in the right and left children respectively of a "sides" node to
   375  eliminate some boundary conditions).  The initial condition is that the
   376  middle tree is the entire splay tree, and the left and right trees are
   377  empty.  We also keep pointers to the last node in the left tree, and the
   378  first node in the right tree.  Note that, at all times, the three trees
   379  are each validly ordered, and they form a partition on the ordering
   380  left, middle, right.
   381  
   382  .impl.splay.zig: The "zig" case is where key < root, and either:
   383    - key == root->left; 
   384    - key < root->left && root->left->left == NULL; or
   385    - key > root->left && root->left->right == NULL.
   386  
   387  The operation for the zig case is: link right (see .impl.link.right)
   388  
   389  .impl.splay.zag: The "zag" case is where key > root, and either:
   390    - key == root->right; 
   391    - key < root->right && root->right->left == NULL; or
   392    - key > root->right && root->right->right == NULL.
   393  
   394  The operation for the zag case is: link left (see .impl.link.left)
   395  
   396  .impl.splay.zig.zig: The "zig-zig" case is where key < root && key <
   397  root->left && root->left->left != NULL.  The operation for the zig-zig
   398  case is: rotate right (see .impl.rotate.right); link right (see
   399  .impl.link.right).
   400  
   401  .impl.splay.zig.zag: The "zig-zag" case is where key < root && key >
   402  root->left && root->left->right != NULL.  The operation for the zig-zag
   403  case is: link right (see .impl.link.right); link left (see
   404  .impl.link.left).
   405  
   406  .impl.splay.zag.zig: The "zag-zig" case is where key > root && key <
   407  root->right && root->right->left != NULL.  The operation for the zag-zig
   408  case is: link left (see .impl.link.left); link right (see
   409  .impl.link.right).
   410  
   411  .impl.splay.zag.zag: The "zag-zag" case is where key > root && key >
   412  root->right && root->right->right != NULL.  The operation for the
   413  zag-zag case is: rotate left (see .impl.rotate.left); link left (see
   414  .impl.link.left).
   415  
   416  .impl.rotate.left: The "rotate left" operation involves rotating the
   417  root of the middle tree, its right child, and the left child of the
   418  right child, such that the new root is the original right child, its
   419  left child is the original root, and the right child of the original
   420  root is the left child of the original right child.  This is sometimes
   421  regarded as a rotation of the edge joining the root with its right
   422  child.
   423  
   424  .impl.rotate.right: The "rotate right" operation involves rotating the
   425  root of the middle tree, its left child, and the right child of the left
   426  child, such that the new root is the original left child, its right
   427  child is the original root, and the left child of the original root is
   428  the right child of the original left child.  This is sometimes regarded
   429  as a rotation of the edge joining the root with its left child.
   430  
   431  .impl.link.left: The "link left" operation involves adding the root of
   432  the middle tree as the right child of the last node in the left tree,
   433  and detaching the right child of the middle tree's original root to be
   434  the new root of the middle tree.  The right child added to the left tree
   435  will be its new last node.
   436  
   437  .impl.link.right: The "link right" operation involves adding the root of
   438  the middle tree as the left child of the first node in the right tree,
   439  and detaching the left child of the middle tree's original root to be
   440  the new root of the middle tree.  The left child added to the right tree
   441  will become its new first node.
   442  
   443  .impl.splay.terminal.null: A special terminal case is when root == NULL.
   444  This can only happen at the beginning, and cannot arise from the
   445  operations above.  In this case, the splay operation must return NULL,
   446  and "not found".
   447  
   448  .impl.splay.terminal.found: One typical terminal case is when key ==
   449  root.  In this case, the splay operation is completed, the three trees
   450  are assembled (see .impl.assemble), and "found" is returned.
   451  
   452  .impl.splay.terminal.not-found: The other typical terminal cases are:
   453    - key < root && root->left == NULL; and 
   454    - key > root && root->right == NULL.  
   455  In these cases, the splay operation is completed, the three trees are
   456  assembled (see .impl.assemble), and "not found" is returned.
   457  
   458  .impl.assemble: The "assemble" operation involves the following steps:
   459    - Add the (possibly null) left child of the root of the middle tree as
   460  the right child of the last node in the left tree;
   461    - Replace the left child of the root of the middle tree with the left
   462  tree;
   463    - Add the (possibly null) right child of the root of the middle tree
   464  as the left child of the first node in the right tree;
   465    - Replace the right child of the root of the middle tree with the
   466  right tree.
   467  
   468  
   469  Top-Level Operations
   470  
   471  .impl.insert: SplayTreeInsert: If the tree has no nodes, [how does it
   472  smell?] add the inserted node and we're done; otherwise splay the tree
   473  around the supplied key.  If the splay successfully found a matching
   474  node, return failure.  Otherwise, add the inserted node as a new root,
   475  with the old (newly splayed, but non-matching) root as its left or right
   476  child as appropriate, and the irrespective child of the old root as the
   477  other child of the new root.
   478  
   479  .impl.delete: SplayTreeDelete: Splay the tree around the supplied key.
   480  If the splay did not successfully find a matching node (including the
   481  case where the tree has no nodes), then return failure.  Otherwise, if
   482  the found node (that is, the newly splayed root) has fewer than two
   483  children, replace it (as root), with the non-null child or null.
   484  Otherwise, set the root of the tree to be the left child (arbitrarily)
   485  of the node to be deleted, and splay around the same key.  The new root
   486  will be the last node in the sub-tree and will have a null right child;
   487  this is set to be the right child of the node to be deleted.
   488  
   489  .impl.search: SplayTreeSearch: Splay the node around the supplied key.
   490  If the splay found a matching node, return it; otherwise return failure.
   491  
   492  .impl.neighbours: SplayTreeNeighbours: Splay the node around the
   493  supplied key.  If the splay found a matching node, return failure.
   494  Otherwise, determine whether the (non-matching) found node is the left
   495  or right neighbour of the key (by comparison with the key).  Set the
   496  tree root to be the right or left child of that first neighbour
   497  respectively, and again splay the tree around the supplied key.  The new
   498  root will be the second neighbour, and will have a null left or right
   499  child respectively.  Set this null child to be the first neighbour.
   500  Return the two neighbours.
   501  
   502  .impl.neighbours.note: Note that it would be possible to implement
   503  SplayTreeNeighbours with only one splay, and then a normal binary tree
   504  search for the left or right neighbour of the root.  This would be a
   505  cheaper operation, but would give poorer amortised cost if the call to
   506  SplayTreeNeighbours typically precedes a call to SplayTreeInsert.
   507  
   508  
   509  TESTING
   510  
   511  .test: There is no plan to test splay trees directly.  It is believed
   512  that the testing described in design.mps.cbs.test will be sufficient to
   513  test this implementation.
   514  
   515  
   516  ERROR HANDLING
   517  
   518  .error: This module detects and reports most common classes of protocol
   519  error.  The cases it doesn't handle will result in undefined behaviour
   520  and probably cause an AVER to fire.  These are:
   521  
   522  .error.bad-pointer: Passing an invalid pointer in place of a SplayTree
   523  or SplayNode.
   524  
   525  .error.bad-compare: Initialising a SplayTree with a compare function
   526  that is not a valid compare function, or which doesn't implement a total
   527  ordering on splay nodes.
   528  
   529  .error.bad-describe: Passing an invalid describe method to
   530  SplayTreeDescribe.
   531  
   532  .error.out-of-stack: Stack exhaustion under SplayTreeDescribe.
   533  
   534  
   535  FUTURE
   536  
   537  .future.tree: It would be possible to split the splay tree module into
   538  two: one that implements binary trees; and one that implements splay
   539  trees on top of a binary tree.
   540  
   541  .future.parent: The iterator could be made more efficient (in an
   542  amortized sense) if it didn't splay at each node.  To implement this
   543  (whilst meeting .req.stack) we really need parent pointers from the
   544  nodes.  We could use the (first-child, right-sibling/parent) trick
   545  described in paper.st85 to implement this, at a slight cost to all other
   546  tree operations, and an increase in code complexity.  paper.st85 doesn't
   547  describe how to distinguish the first-child between left-child and
   548  right-child, and the right-sibling/parent between right-sibling and
   549  parent.  One could either use the comparator to make these distinctions,
   550  or steal some bits from the pointers.
   551  

