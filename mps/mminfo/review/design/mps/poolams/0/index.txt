                    REVIEW OF DESIGN.MPS.POOLAMS(0)
                      review.design.mps.poolams.0
                           incomplete review
                           gavinm 1998-04-14

Rules: rule.universal, rule.req
Checklists: All: role.check.source
Pekka: role.check.consistency, role.check.backwards
GavinM: role.check.convention, role.check.backwards
RichardK: role.check.clarity
Tony: role.check.correctness
Source: none applicable
Candidate status: draft

Author: pekka
Leader: gavinm
Editor: pekka
Scribe: gavinm

Entry: entry.universal, entry.design
Entry manpower: .5


Entry notes:

This document has no applicable source documents.  We considered design.mps.buffer, design.mps.collection, design.mps.refset, design.mps.fix, design.mps.scan, design.mps.class-interface, and design.mps.pool, but decided they would not be useful as source documents in review.
We have no proper rules for design.
Review leader is insufficiently trained as usual.
I hate spellchecking tagged documents about code in Notes.
Two major defects found in brief check.
gavinm 1998-04-14


Loggingstart: 14:07
Loggingend: 14:45
Logginglength: 38

Checkers: Pekka;GavinM;RichardK;Tony
Rate: 1/6 page
Length: 5 pages
Actual checking time: 157

Kickoff start: 1998-04-14 14:00 BST (09:00 EDT)


ISSUES:

GavinM: 3M 4m 2C 2q 3I  34 minutes
Pekka: 2 M, 6 m, 1 C, 1 I, 41 min
Tony: 0m 1m 2C 3q 0I  40min
RichardK: 14M  0m  0C  3q  1I  --  42min

[ I'm fed up with writing people's names, so I'm going back to the old style of 
logging where each person gets a section.  Let me know if this is any better or 
worse.  gavinm 1998-04-20 ]

RichardK:
1. M .readership  Which product manager?
2. M .req.format  "be formatted"/"support formatted objects"
3. M .align  What does the term "the format alignment" mean?
4. M .buffer  Add ", satisfying .req.incremental"
5. M .colour.object  Unclear near "in order to colour all the grains".
6. M .colour.object  The implications of only colouring first grain are not 
made clear.
7. M .scan.segment  What does "objects already skipped" mean?
8. M .iteration.buffer  "callers have [to] make sure they take the appropriate 
action" -- clarify or example?
9. M .marked  What is a "group"?
10. M .marked  Perhaps "marked" isn't a good name.  Perhaps "marksChanged"?
11. M .marked.scan.fail  What is "the format scanner"?
12. M .marked.reclaim  Clarify "must be" -- should the flag be put into that 
state, or should the code AVER that it is in that state?
13. M .reclaim.empty.buffer  Clarify "could be" -- is this a hazard, a 
potential future enhancement, or a reassurance that this happening is not a 
problem?
14. M .benefit.repeat Clarify "the lastReclaimed value".  What is this set to?

Pekka: 
15. M .fill.slow It's not just that BufferFill is slow, it's that the whole 
structure of buffers is inefficient for a non-moving pool.  This needs to share 
with MV2 (eventually).
16. M .colour.bits This doesn't work with ambiguous pointers in the middle of 
objects.

GavinM:
17. M .source Should list documents like design.mps.buffer, 
design.mps.collection, design.mps.refset, and design.mps.class-interface even 
if they aren't currently very useful
18. M .req.ambiguous Should specify whether it supports the other ranks.  This 
implies not.
19. M .not-req.grey Should specify how that restriction is enforced

RichardK:
20. MN .marked.scan.fail Clarify "the problem condition" -- this may intersect 
with other issues people raised on this paragraph

RichardK:
21. I proc.review.check(0)  After ".class" there is the word "End", followed by 
more procedure (on my print-out anyway).
  The defect is that "End" outside any tagged paragraph suggests that it marks 
the end of the procedure.  But it doesn't -- there is one further paragraph.
22. q .colour  Does MPS always condemn a whole segment at a time?
23. q .fill  Does using memory to refill a buffer change the flags for that 
memory?  Does it only use uncondemned segments?
24. q .benefit.guess  What does "the pool is condemned" mean?

Pekka:
25. m .one-condemn Uses the old term "mark/scanned tables", should say "colour 
tables".
26. m .stress Should say "impl.c.amsss"
27. m .reclaim.empty.buffer Need to add "after reclaim".
28. m .marked.scan.fail Unclear, should reference some doc of scan failures 
(but I suspect there is none).
29. m .marked.condemn Unnecessary to set the marked flag, it must be 
FALSEalready.
30. C .iteration.buffer Last sentence awkward.
31. m .colour.single Duplicates .one-condemn.

Tony:
32. C .overview There may be a general interest in an efficient M&S pool for 
Dylan as a way of evaluating the benefit of copying
33. C .req.correct I have doubts about the plausibility of an "obviously 
correct" measure
34. q .not-req.grey Shouldn't there be a source document which describes a grey 
mutator?
35. q .no-alloc Couldn't one-phase allocation be simply achieved by using 
buffered allocation inside the arena lock?

GavinM:
36. m .no-alloc Surely it's the fact that it's formatted and exact?
  RichardK: (I don't understand your "m .no-alloc" issue)
  Pekka I disagree with it.
  GavinM: I claim that incrementality and collection are not sufficient to 
imply that we can't have alloc.
    We must have non-ambiguous references as well.
    It's a detail of buffer design.  It's not very important.
37. q .fix.to-black Would it be useful to do this elsewhere?
38. C .colour.bits This seems an odd halfway house between mark/scan and 
white/grey/black
39. C .colour.single The bit tables could be allocated on condemn
40. I .colour.* We could usefully implement the idea of a tri-colour array of 
grains once, centrally, efficiently
  Pekka: What's that an improvement to?
  GavinM: It's not clear.  Some MPM support thingie.
41. m .marked It's not clear what a "scan iteration" is here
42. m .init Could refer to the (placeholder) design.mps.align
43. m .benefit.repeat Surely this is "lastCondemned", or is it set on reclaim 
as well?
44. q .one-condemn Is there any way that object colour could usefully be 
conservatively correct for all active traces (assuming disjoint condemned sets)?
45. I role.check.backwards Should clarify granularity of reversal.
46. IN role.check.backwards Should recommend forwards logging order.
47. I design.mps.buffer Should be completed
  8-)
  Pekka: indeed

Pekka: 
48. I design.mps.action The problem in .benefit.repeat is a general problem 
with actions, and should have a general solution.

GavinM:
49. IN guide.review.class.major Status of clarifications should be clarified

RichardK:
50. IN guide.review.class.major  The term "cost to fix" isn't (I understand) 
what is meant.  What is meant is "accumulated cost of the defect".
51. IN guide.review.class.major  Almost all defects have an "accumulated cost" 
which is higher the later you fix the defect.  Ergo this is not a useful 
categorisation of defects.

GavinM:
52. mN .colour.bits Could mention alloc table again.



Brainstorm start: 15:07
Brainstorm end: 15:46
Brainstorm length: 39


BRAINSTORM:

[Liberties taken with order.  gavinm 1998-04-20]

GavinM: Ok.  There were 20 major issues logged.
  Most of them relate to clarity.
  Why is there so much unclear in a document that's been RFC'd?
  How could we have higher clarity in design documents when they reach review?
RichardK: (Umm, presumably what we want here is responses of the form "Hmm, if 
we'd done X instead of Y, these defets would have been caught earlier" (eg. by 
RFC) ?)
Pekka: Or, even better, avoided altogether
Tony: One interpretation is that many of the reported major issues aren't very 
major
GavinM: What we're trying to do here is to find ways we can change our process 
to prevent defects of the type under discussion from occurring.
Pekka: But they were unclear
GavinM: Irregardless of their classification, they are unclear.
RichardK: English is a hard language to avoid unclaerness in (compared to 
machine languages).
Pekka: So lets write them in German.
GavinM: I think a lot of the unclearness arose from a lack of references to 
documents that should (but mostly don't) define terms.
Tony: I agree with Gavin's comment about references
RichardK: It's a hard problem.  Checking for clarity is a process of two levels 
(I ad-hoc freely...)
  ...1) can you understand it?  2) is there a plausible misunderstanding that 
might confuse someone other than you?
Pekka: I think 2) is a dangerous game.
GavinM: (1) is better as, "it is clear to me?"
RichardK: We should also consider that the unclearness was in part due to the 
inexperience (in MPS design) of the checker (Me!).  Whether this is 'signal' or 
'noise' (how clear do we want it to be to inexperienced MMers?) is a fair 
question.
Pekka: Regarding terms, certain terms should be common language: scan, mark, 
pool, etc., but Gavin is right that a definition should exist somewhere.
GavinM: I think we need to try harder at referring to placeholder documents, as 
well as completing them.
Pekka: Yes
Tony: Some terms aren't common (e.g. group)
Pekka: OTOH, reviewers should be familiar with those documents before the 
review starts (or,
  in the absence of useful docs, the subject matter)
GavinM: Perhaps we should have a general architectural design for what MPS 
documents should exist and be kept up to date, and what they should contain.
Tony: Is it a process goal that few problems turn up at review time?
  If so, then how few?
GavinM: We have a number of rusty design documents I didn't mention earlier, 
like design.mps.fix and design.mps.scan.
Pekka: No, we should have an editor, because that changes very fast.
  editor/librarian
RichardK: (2)] 2) is a dangerous game in that it can be taken too far, looking 
for perverse misunderstandings.  But it is also a vital aspect of clarity.  
Clarity isn't just "it's clear to _me_".
Pekka: 2) that's why we have multiple reviewers
GavinM: Tony, the ultimate goal is that there should be no defects in documents 
reaching review.
  Of course, this is distinct from there being no defects logged.
Tony: If we were successful at that, the review wouldn't have much of a payoff
GavinM: Pekka, could you expand on your editor/librarian suggestion?
Pekka: I think I have
RichardK: (1) and (2)]  My point is that both of these are hard and 
time-consuming for the author to satisfy and verify.
GavinM: Tony, true, but the same would apply to QA.  I don't think we're in any 
danger at the moment.
Tony: Gavin - agreed. But we could make the RFC process more formal at the 
expense of spending more time in that
  I suspect that RFC scrutiny is typically less pedantic
GavinM: We had an RFC of this document.  Why weren't clarity problems resolved 
in that?
Pekka: It's role.librarian plus some of role.architect (because the doc is so 
patchy ATM)>
  The funny thing is, I didn't want an RFC at all, because I didn't think it 
was would be useful.
  Well, it wasn't but for all the wrong reasons.
  So, own up: who read the RFC?
RichardK: I read it.
Tony: I read it
GavinM: DRJ and RIT read it.
Pekka: So...?
GavinM: I think that, outside the context of a formal review, we tend to regard 
conprehension problems as our (the reader's) problem and hence to work harder 
rather than reporting them.
RichardK: reasons why more came out in review than from RFC, for richardk:
  a) what Gavin's just said about comprehension problems.,
  err, that's it.
Pekka: Would it have helped to prepare for the review in some way?
RichardK: b) things I didn't understand in RFC gave response "come back to this 
later" -- things I didn't understand in review gave response "log this a s 
defect now".
  gave response/made me respond
GavinM: SUGGEST: proc.rfc (made-up name) should state that the RFC should state 
the type of comments required.  Further, clarity problems should be high on the 
list.
Pekka: I think the suggestion we came up with the last time was better:
RichardK: It was very easy (emotionally/psychologically) to list clarity 
problems in review, cos there's a clear 'licence' from the author to do so, and 
it's clear that the author has the final say -- the position of how much 
pressure the 'defect report' applies is
  clear: it's not a personal criticism in review, it's almost mechanical.
Tony: I'm not clear why we would want both an RFC and a review if the intention 
is to have identical scrutiny in both
Pekka: Nominate someone to respond, then they'll feel obligated to read it 
thoroughly.
GavinM: SUGGEST: proc.rfc should state that the author should get at least one 
person who has to respond.
Pekka: Tony: Agreed.
RichardK: If I'd come to Pekka in response to his RFC with the list of defects, 
I'd have been worried that it would have seemed pressurising or picky.  A 
review is a licence to be picky, without that pickiness being taken as 
negativeness.
  the list/my very long list
Tony: Gavin - what should an author do if he desn't get a response in RFC?
GavinM: Tony, get someone to undertake to respond.
Tony: By force?
GavinM: Either by request or by management.
Tony: OK
GavinM: OK.  I think we've got something to work with here.
RichardK: In summary (of my view), there is a long list of reasons why review 
brings out things an RFC doesn't.  At least some of these (getting around to 
it, thoroughness) come from the formal, heavyweight nature of review.  It might 
be v. hard to get these
  benefits with a 'cheap' lightweight process.

Tony: If I come up with thought about the process over time, is there a 
procedure for making suggestions later?
GavinM: Tony, e-mail, talking to process manager, creating request in process 
product 

GavinM: We've got a few minutes left.
  Does anyone have any other important issues that we could brainstorm process 
improvements to?
Pekka: How about 16?
> 16. M .colour.bits This doesn't work with ambiguous pointers in the middle of 
objects.
GavinM: OK.  Could you explain that one a little?
  Could ambiguous interior pointers give you an illegal bit combination?
Pekka: Well, if ambiguous fixes set random bits in the interior of an object, 
then the other parts of the program can't just scan the bit tables to find 
interesting objects, they also need to determine whether they bit they found is 
at the beginning of an object (and hence meaningful).
  And ambiguous interior pointers is a global property, not a pool one.
GavinM: How do we find free grains?
Pekka: when?
  There's an alloc bit table.
GavinM: Ah.  Where does the design mention that?
Pekka: .alloc-bit-table
GavinM: mI .colour.bits Could mention alloc table again.
Pekka: Anyway, I wonder if there shouldn't be a standard test for new pools, 
that would try alll the hard things...
GavinM: We ought to sort out the relative merits of alloc/mark/scan, 
alloc/mark/grey, and black/grey/white.
  As bit tables.
Pekka: I was trying to sort that out, but failed, as this issue points out.
GavinM: SUGGEST: Some design document restrict and define possible colour 
representations
Pekka: SUGGEST: this one.
GavinM: Tony, can you take on this task?
Pekka: Also, I suspect the alloc bit table is just the simplest solution, not a 
good solution, as ptw has concluded.
  I want to do it.
RichardK: Gavin, are you saying that choice of representation of 
colour+freeness in bit-tables interacts with behaviour of ambig interior 
pointers?  (If so the reason is over my head, and I'll ponder it off-line)
GavinM: Richard, yes.
  There are five possible grain states: black, white, grey, free, interior.
  These are represented here in the three bit-tables alloc/mark/grey.
Pekka: That's how Nick put it, I decided that wasn't a very useful description.
GavinM: Fixing an ambiguous reference sets mark/grey bits without reference to 
the alloc bit.
  I think.
  Ok.  Pekka, can you write up something generic about this?
  I think we're about out of time, here.
Tony: Gavin - are you suggesting that pools should not be allowed to pick their 
own encodings of colour?
GavinM: Yes.  Or at least not inadvisedly.
RichardK: I think he's sug that it's tricky, given implications of ambig 
interior ptrs.
  tricky => make a separate study/analysis that pool-class implementors can 
refer to.
GavinM: For example, we used to have a mixture of alloc and free tables, with 
the same (but reversed) significance.
  After much confusion, we standardised on alloc tables.
  I'm not sure that this is even documented.
  I'm happy to continue explaining things, but I want to call thisd Process 
Brainstorm to a halt soon.
  Any more process improvement suggestions?
RichardK: Will someone be writing a list of concrete suggestions for making 
RFCs a bit more thororugh?
GavinM: Yes.  Based on this brainstorm.
RichardK: 'kay.
GavinM thinks guide.rfc would be better.

Pekka: We're getting way too much process, and way too little enforcement.
GavinM: Ok.  Done.
  Pekka, true.
RichardK: I would like to know how well this review met Pekka's hopes for it.
GavinM: But there's still process we ought to have but don't.



Number of major issues: 20
Number of minor issues: 5
Number of issues: 52

Edit manpower: 4


Edit notes:

1. Fix: Removed mention of product manager.  Not a major defect.
2. Reject: It's better the way it is.
3. Reject: Not a defect, reviewers should have been familiar with formats.
4. Fix: Added.  Not a major defect.
5. Reject: I don't see a defect.
6. Reject: Looks like a duplicate of 5.
7. Fix: Rephrased.  Not a major defect.
8. Reject: Not a defect.
9. Fix: Changed the paragraph to talk about "segment" instead.  Not a major 
defect.
10. Fix: Changed.  Not a defect.
11. Reject: As 3.
12. Fix: Clarified.  Not a major defect.
13. Reject: It already states everything that can be said about it.
14. Fix: Clarified.  Not a major defect.
15. Fix: Added notes that eventually a technique more suited to non-moving 
pools will be used.
16. Fix: Redesigned the whole thing, see analysis.non-moving-colour.
17. Raise: Made a short list and passed it to Tony (mail.pekka.1998-04-21.13-40
).
18. Reject: Oh, really?
19. Fix: Added .grey-mutator.
20. Reject: It can't be any clearer than that.
21. Reject: It's a subsection heading, orphaned on the wrong page in the 
print-out.
22. Mail: mail.pekka.1998-04-21.13-40.
23. Mail: mail.pekka.1998-04-21.13-40.
24. Mail: mail.pekka.1998-04-21.13-40.
25. Reject: Superfluous.
26. Reject: Not the correct reference.
27. Fix: Added.
28. Fix: Added xref.
29. Fix: Changed it to say it's checked.
30. Fix: Rephrased.
31. Fix: Deleted one-condemn.
32. Forget: Outside the remit.
33. Fix: That was a bit too ambitious.
34. Mail: mail.pekka.1998-04-21.13-40.
35. Mail: mail.pekka.1998-04-21.18-08.
36. Fix: It's actually considerably more complicated.  Improved it a bit, then 
lied that the rest is explained in design.mps.buffer -- it should be.
37. Mail: mail.pekka.1998-04-21.18-08.
38. Forget: So what?
39. Forget: Or they could be allocated elsewhere.
40. Edit: design.mps.poolams.req.colour (sic) Add that to the requirements for 
this design.
41. Fix: Added xref.
42. Reject: Presumably there's some pool-specific reason why.
43. Fix: Same as 14.
44. Mail: mail.pekka.1998-04-21.18-08.
45. Pass: Gavin.
46. Pass: Gavin.
47. Pass: Gavin.
48. Pass: Tony.
49. Pass: Gavin.
50. Reject: Incorrect.
51. Reject: Incorrect.
52. Reject: There's already an xref.



Exit: exit.universal
