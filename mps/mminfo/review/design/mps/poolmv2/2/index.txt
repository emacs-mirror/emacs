                    REVIEW OF DESIGN.MPS.POOLMV2(2)
                      review.design.mps.poolmv2.2
                           incomplete review
                           gavinm 1998-04-22

Rules: rule.universal
Checklists: role.check.*
Source: req.dylan, req.epcore, req.product, paper.vo96, paper.st85
Candidate status: draft

Author: ptw
Leader: gavinm
Editor: ptw
Scribe: gavinm

Entry: entry.universal, entry.design
Entry manpower: 1


Entry notes:

As usual no training.  Spellchecking Notes documents is really tedious.  gavinm 1998-04-22


Loggingstart: 14:57
Loggingend: 16:50
Logginglength: 53

Checkers: Tony (req.dylan;Correctness);RichardK (req.epcore;Backwards;Clarity);Pekka (req.product;Consistency);DRJ (paper.vo96;Backwards;Convention);GavinM (paper.st85;Clarity);PTW (Backwards)
Rate: 1/6 page
Length: 8.5 pages
Actual checking time: 402

Kickoff start: 1998-04-22 14:27 BST Home Hill
Kickoff end: 14:33
Kickoff length: 6

Kickoff notes: Tucker notes that this doesn't cover .fun.debug.


ISSUES:

GavinM: 7M 22m 5q -- 70 minutes -- 100%
PTW: 59 minutes, M: 5, m: 7, C: 0, q: 2, I: 4, 37%
Pekka: 6 M, 8 m, 6 C, 3 q, 70 min, 70%
Tony: 3M, 6m, 0C, 5q, 70min, 100%
DRJ: M 1 m 10 C 2 I 2  53 mins (unfinished).  reading source: 10 mins. reading 
review gumph: 5 mins.  50%
RichardK: 2M, 11m, 3C, 1q, 2I -- 65mins -- 70%

RichardK:
1. M .sol.strategy  There really really ought to be a discussion of how the MPS 
design of requiring objects to be in exactly one segment affects 
fragmentation.  In other words, the effect of segment boundaries on 
fragmentation.  See EPDL, which massively reduces fragmentation by 
circumventing seg-boundary problems (albeit in a brittle way).
2. M .arch.allocation-point  "(this indicates the client has misused the pool": 
this is inconsistent with .attr.range.  This inconsistency should be fixed, so 
we know which one is the real requirement.

PTW:
4. M 393,.arch.dependency rule.universal.risk: What is the schedule for the 
locus mechanism being available?  Does this dependency put the schedule for 
poolmv2 (and the schedule of its expected clients) at risk? Is there a 
fall-back in the exisiting substrate that can be used? (E.g., will seg 
preferences work at all?)
5. M 399,.arch.adapt rule.universal.risk: Given the clients of this pool, 
should we be engaging in experimental policies such as this? How can we 
minimize the risk to the client?
6. M 442,impl.c.poolmv2 rule.universal.risk: Is there design missing for a pool 
interface that supports buffered allocation _and_ freeing?  Can this pool be 
built without buffered freeing?  Will there be a significant cost to adding 
buffered freeing at a later time?  Can this pool support buffered freeing?
7. M 475,impl.c.poolmv2.free.merge.segment rule.universal.risk: This policy 
does not sound well thought out or convicing.  Is it the best we can do?
8. M 483,.impl.c.multiAP If pools are the one, true interface to the MPS, what 
is this \"glue layer\"?  Is this properly part of the pool design, or does it 
belong in the design of the MPS interface, or does it belong in the client 
manual as example code?

Pekka:
9. M .source req.product and other sources are incomplete.
10. M .source Should have used the proposed changes to req.epcore 
(mail.pekka.1998-02-16.15-57 and further proposals).
11. M .sol.mech.reallocate This would turn .fun.suballocate into a critical 
requirement, and break .fun.debug.
12. M .arch.allocation-point This "reuse size" works differently from the 
mechanism described in .anal.policy.  I'm sure this paragraph doesn't mean what 
it says.
13. M .arch.debug This is a major change in the MPS, and an inefficient way to 
provide these services.

Tony:
14. M .sol.strategy.death.birth This is big assumption, of importance to the 
design, & yet unsubstantiated. Suggest quoting research
15. M .sol.mech.allocate.optimize-new This isn't clear. Why acquire the memory 
when in a position to preserve it?
16. M TESTING NYI

DRJ:
17. M .arch.allocation.point unclear what happens if reuse size is small (< 
page size) which presumably can happen if fragmentation pressure is high (see 
.arch.adapt)
18. MN .fun.debug too vague

GavinM:
19. M .attr.adapt Surely this requires it to be adaptive, not adaptable?
20. M .req Doesn't seem to mention the requirement of having a low space 
overhead, or not running out of memory.  This would be required to justify 
.strategy.
21. M .req Doesn't specify requirement implied by .overview that the code 
should be resusable as a substrate (except possibly in .attr.flex)
22. .gavinm.15-21-54: M .req Doesn't mention debugging requirements that must 
be detected by the pool if anywhere, such as double-frees.   DRJ: gavinm, 
please clarify your issue starting "Doesn't mention debugging..." (-3)
  GavinM: It would be impossible (or needlessly expensive) for a client layer 
to detect double frees.
    Hence, were it to be detected, ti should be a service provided by the pool.
  RichardK: pool/MPS, shurely?
  GavinM: _pool_
  PTW: Which source document has that rquirement?
  GavinM: It should be clear whether it is a requirement.
  Pekka: req.product.dc.env.c
  PTW: Anything that is not in the source is clearly not required?
23. M .req Doesn't explain whether the pool would support malloc/free 
requirements like tolerating double-frees.
24. M .sol.policy.size This seems to combine a policy with a mechanism.  Having 
a minimum size is only an approximate measure to prevent "comsuming all of 
memory".  When combined with a vague solution like .sol.policy.size.adapt, it 
really sounds like it's trying to limit the overhead of the deferred use.  I'd 
rather see this related to actual requirements such as space overhead or "not 
running out".  
25. M .impl.c.CBS The outlined facilites don't permit the location of a 
specific neighbour to a freed block, nor do they support the location of the 
neighbour other than the one found.
  (See my recent mail on splay trees)

RichardK:
26. I role.check.*  Note: I abandoned role.check.backwards (I checked with 
Gavin about this).  I can't do backwards in combination with role.check.clarity 
for a document-type that is only required to be clear when read forwards.
27. q .overview  "EP .. other than the PS object pool": colleciton in EPVM is 
very rare -- it would almost be better to thiink of it as a manual pool 
perhaps?  Is there any way the strengths of poolmv2 could be used to benefit 
EPVM?
28. I req.epcore  Where one logical document is split into several physical 
documents (as in req.epcore) if the sub-documents' tags were in alphabetical 
order they would print in a helpful order.
29. m .fun.align  "req.epcore.fun.dl.promise.alignment" -- this tag does not 
exist.
30. I MMIS  I want to search MMIS for partial tags.  It doesn't seem to work: 
".promise.alloc" doesn't find ".dl.promise.alloc: ...".
31. m .fun.reallocate  req.epcore.fun.dl.* does _not_ require realloc.
32. m .fun.thread  req.epcore.fun.dl.* does _not_ require multiple threads.
33. m .fun.thread  "threads of allocation": "thread" is not defined.  It should 
at least be clarified whether they are pre-emptive etc, or whether this is just 
more than one AP.
34. m .attr.performance  "rec.epcore.{run-time,tp}": these tags don't exist.
35. MN  <tags referred to>  It is not right to burden the reader with a big 
tag-hunt.  [The only point of these references is so the tags _do_ get 
looked-up.  So tag look-up must be easy or people won't do it.]
  PTW: That must be an Improvement suggestion?
  RichardK: "I"] no, because it's a defect in the socument, not in the support 
for the document, I assert.
  PTW: I am required to use those tags, that you can't look them up is not a 
defect in the document under review.
  RichardK: Ahh, I should clarify:
  PTW: Please do.
  RichardK: nM <tags referred-to>  Some of these tags are 'almost right'.  It's 
important that they be right.  Otherwise they are very hard (though not 
impossible) to look-up.
    Let's skip this -- you'll see lots of "thjis tag does not exist" minor 
defetcs come by.
36. m .fun.debug  "req.epcore.debug.support": tag doesn't exist.
  PTW: : Ok.  I'm not sure if this is due to typographical error or sloppiness; 
although I believe the former.  It was certainly not my intention to obfuscate.
37. m .fun.suballocate  Not clear why this ability is of any interest.  The 
sources quoted do not seem to support this req (even at "nice").
38. m .sol.strategy.debug  This is good, but not a ".sol.strategy" I think.  
It's an ".impl" matter.
39. m .sol.policy.debug  Clarify what counters and meters are, and how far they 
go to meeting .fun.debug.
40. C .sol.mech  The link from .fun-man-var to .sol.mech.free-list.* is that 
there is a _task_ the pool must perform, namely: coalescing free blocks.  A 
list of tasks like this, would be a useful addition to the design.
41. C .sol.mech  I think some part of this design is generic -- applicable to 
all manual-variable allocation -- and merits a separate analysis document.
  Clarification" "separate" separate from poolmv2 specifically.
  PTW: not if poolmv2 intends to be the one true m-v pool!
42. m .anal.strategy  "(fragmented memory is memory allocated to the program": 
this is a mistake I think.
43. m .anal.policy.reallocate  ".fun.suballocate...doing so will cause the 
freed block to obey .sol.policy.allocate": it is not clear why this is so.  
[.s.p.a talks about objects, not free blocks -- I'm confused]
44. C .arch.overview  One effect of deferred re-use + minimum size 
(.sol.policy.size) is to try to decrease the ratio of effective object sizes -- 
we do our best to encourage the holes to grow till they are as big as a page.  
See mail.richardk.1998-04-16.18-20(0).frag.ratio.

PTW: 
45. I proc.review Include a copy of the role assignments with the review packet
46. I rule.universal.head.time States that the document should be marked with 
its creation time.  Does this really mean date?

Pekka: 
47. I proc.review Large or complex documents should have more reading time 
allocated to them per page.
48. I req.product Doesn't address documentation requirements.
49. C .intro Should be "second-generation" and "drop-in".
50. m .req Tagging and punctuation in this whole section are non-standard (see 
guide.text.tag).
51. m .req All the requirements are subjectless sentences -- it is often useful 
to state exactly which part of the product or software system must satisfy the 
requirement.  Furthermore, in pool class designs it is useful to make the 
distinction between requirements that apply to every pool instance, and 
requirements that can be satisfied by choosing appropriate values for the 
parameters for a set of instances.
52. mN .attr.performance "performance" is a weasel-word, should split into the 
measurable categories.
53. m .not.fun.reallocate.in-place.happy.gavinm.make It's not clear where this 
requirement comes from.  It is not implied by req.product.dc.env.ansi-c because 
the drop-in interface could handle the moving.  In fact, there is something to 
be said for a resizing interface that would guarantee not to move (and I have 
said it in the past).
54. m .attr.reliability req.product asks for more: "rock-solid reliability".
55. C .attr.range This is not an attribute requirement.
56. C .sol.strategy.death.type.size This is a minor tweak that should be 
demoted to a mechanism.  Not sure this strategy/policy/mechanism added much to 
the clarity.
  that is the distinctions didn't do much for me
  DRJ: (a comment which applies to the Wilson paper too IMO)
  Pekka: so file an improvement suggestion for it. ;-)
  PTW: model/controller/view?
  RichardK: I think strategy/policy/mechanism is a Good Split.
  Pekka: I just don't think they are that independent if you only consider one 
or two of eaxh...
57. C .sol.policy Why mention this, if you don't name and distinguish the 
different policies.
58. m .sol.policy.size.fixed This is unjustified.
  PTW: do solutions have to be justified?  aren't they there to be analysed?
  Pekka: Yes, you're right.  I did file a question about the analysis.
59. q .sol.policy.reallocate Why outside?
60. m .sol.mech Tagging and punctuation in this whole section are non-standard 
(see guide.text.tag).
61. q .anal.policy.size Can you explain your reasoning here?
62. C .anal.mech.allocate.optimize-new This is irrelevant because the reference 
in paper.wil95 probably applies to an implementation using brk().  Furthermore, 
this behaviour is not under the control of the pool, but of the arena.
  GavinM: ( Though it's vaguely relevent to MacOs temp space.)
  Pekka: Only if we implement an arena that uses it.  I did toy with the idea 
of a sbrk() arena at one point...
  GavinM: It's relevant to an arena solution we don't intend to use.  I just 
thought I'd mention it while we were waiting.
  PTW: (It's relevant to the segment the arena gives the pool when it is much 
bigger than what is needed to satisfy an allocation request.)
    (But I seem to have failed to convey that point.)
  GavinM: PTW, I see what you mean.
  DRJ: well I thought ptw's point was clear, but that doesn't mean it was.
  Pekka: (You failed to explain you were going to ask for segments that large.)
  PTW: I explain pretty clearly that segments of "reuse size" are always 
requested.
63. C .arch.allocation-point This needs to be broken down into individual 
tagged statements.  Likewise the other paragraphs in this section.
64. q .arch.allocation-point How will you achieve the reclamation of the 
splinters?
65. C .arch.available-block-queue Instead of a HWM decay, it would be better to 
have the arena to ask for the pages back.
66. q .arch.contingency What is "total free space"?
  PTW: (I wondered that too.  One of my lost defects.)

Tony:
67. m .attr.performance "... Clearly there is a missing requirement" It's not 
clear (to me) there's a need for this requirement.
68. m .attr.range The quoted Dylan requirements refer to Dylan objects, and 
hence do not apply to MV2
69. m .sol.policy "hopefully" - are you hoping the design is correct? or that 
it's implemented correctly? or just making a general statement??
70. q .sol.policy.size.fixed I note that page alignment isn't taken into 
account so there's no guarantee of entire pages being free. What's the 
motivation for basing this on page size? 
71. q .sol.mech.allocate.optimize-new Many small blocks won't have short 
lifetimes. Is this a problem? What does small mean anyway?
72. m .anal.policy "where as" -> "whereas"
73. m .anal.policy.reallocate Clumsy first sentence
74. m .anal.policy.size This belief depends on page alignment too, and not just 
size, doesn't it?
75. q .arch.allocation-point This implies clients must either keep separate APs 
per thread or implement their own locking. Are we confident there's no need for 
an MPS-locking mechanism?
76. q .arch.coalescing-block-structure There's no mention about whether 2 
blocks big enough to be on the ABQ can become merged due to coalescing. Can 
this happen? How do the CBS & ABQ communicate?
77. q .impl.c.multiAP What support (if any) will the glue layer provide for 
multiple threads

DRJ:
78. I rule.universal: it should fit on one printed page
79. I ? (guide.text?) large documents should have a tag map of some of the top 
N levels of tag hierarchy to aid navigation.  
  e.g. it's not clear where .sol.policy and .sol.strategy come wrt each other, 
or .arch and .req, say.
80. I template.design (it should exist) there sdhould be a template for design 
documents./
  PTW: I thought I used it?
  DRJ: you may have used the Notes form called design.
  PTW: I did
  GavinM: ... but that's not the same as having a design template
81. m .def.* (it should exist) definitions at front so that they can be easily 
found when (unfamiliar) terms are encountered.
82. m .not.fun.reallocate.in-place.happy.gavinm.make ridiculously long tag
83. m .sol.mech.allocate.optimize-small: this sounds like two separate 
mechanisms or at least one mechanism and a separate assumption
84. mN .not.fun.reallocate.in-place.happy.gavinm.make: inept attempt to satisfy 
req.humor.funny
85. m .sol.mech.allocate.optimize-new use of "preserve" is unclear (does it 
mean "delay reusing"?)
86. m .anal.policy last sentence.  tag with .risk.blah perhaps.
87. m .anal.mech.freelist should have tags beginning with .sol.mech.*
88. mN * rule.universal.tag: There aren't enough tags in this document
89. C .arch.allocation-point sentence beginning "it is intended" surely only 
useful if in addition the reuse size is small compared with total volume of 
allocation at this class size, otherwise will be large space overhead
90. C .arch.available-block-queue last sentencei, it's not clear that the MPM 
has any has any way to support such mechanisms at the moment.
91. m .arch.modular.initial referenced tags should be .sol.mech.*
92. m .impl.c.abq clarity, what is High Water Mark (may be due to 
role.backwards)
93. CN .impl.c.poolmv2.free.merge.segment  this will make more sense when we 
have pages and segments and can free interior pages (or at least I think/hope 
it will).
94. m .impl.c.multiap clarity.  unclear if these APs are in different pools or 
not
95. m TESTING no testing section.  as suggested in (incomplete) rule.design, 
could be separate (presumably incomplete :-) ) document reference from here.

GavinM: 
96. m * Use of "it's" where "its" is appropriate.
97. m .source Could mention paper.st85
98. m .req Could specify non-requirements of being formatted, scannable, and 
collectable
99. m .not.fun.reallocate.in-place.happy.gavin.make Could justify this 
non-requirement on the grounds that such behaviour could be provided in realloc 
wrapper if required for a particular platform, particularly if  
.fun.suballocate is satisfied (see also .sol.policy.reallocate)
  Pekka: Gavin: are you saying n.f.r.i.h.g.m is not a intended as a 
requirement, but a non-requirement?
  GavinM: Pekka, er yes.
  Pekka: Gavin, well I read it in the opposite sense.
100. m .req Could usefully separate the alloc and free requirements in order to 
clairfy the status of sub-free.
  RichardK: Gavin, can youclarify what "sub-free" means?
  GavinM: see .fun.suballocate
101. m * Missing newline before sub-section titles
102. m .req Would benefit from a clear definition of "aligned".
103. m .sol.mech.free-list.* Source references should be in this document, not 
in comments
104. m .sol.mech.free-list.splay-tree Surely this should be "is competetive 
within a small constant factor"?

PTW:
105. NI References are conventionally demarcated with [] which is ambiguous 
with text document comment convention.  How should they be demarcated?

GavinM:
106. m .sol.mech.free-list.bit-map Could usefully use the word "grain" instead 
of block, as using "block" confuses the allocation grains with the allocated 
blocks
107. m .sol.mech.storage.in-band Could useful speculate about the actual 
minumum size
108. m .sol.mech.storage.in-band Should explain how this minimum size 
restriction could satisfy the requirements
109. m .sol.mech.desc.in-band This paragraph should mention whether it is 
talking about in-band data.
110. q .sol.mech.desc.in-band How would we go from an interior pointer to the 
header and footer?
111. m .anal.mech.free-list Could usefully speculate about the overheads of 
these techniques, otherwise this paragraph cannot be verified.
112. q .arch.allocation-point Why two-phase?
113. m .arch.available-block-queue Blocks on the ABQ aren't guaranteed to be 
(or even contain) VM-aligned pages.  The arrangement for returning memory to 
the arena should be better defined.
114. m .arch.available-block-queue I don't understand how this decaying high 
water mark is going to work.
115. m .arch.coalescing-block-structure Does "can simultaneously be" mean that 
it will be?
116. m .arch.dependency Could usefully document these dependencies separately.
117. q .arch.adapt How does the CBS measure fragmentation?
118. m .impl.c.* Tags should be lower-case.
119. q .impl.c.CBS Why do we need to suballocate blocks from the control pool?  
Why not use MFS?
  DRJ: DRJ would like to get rid of MFS

  Pekka: drj: You mean the implementation, not the concept?
  PTW: PTW would use MFS if he felt it was efficient and maintained good 
locality

  DRJ: yes, I mean the implementation.  ATM it's only used as part of baroque 
MC boot process which is overly complicated because MV tries to do too many 
things at once.  Which is one of the things that MV2 addresses
  GavinM: Perhaps we ought to distinguish the boot and control requirements.
120. q .impl.c.CBS Why use Addr,Size (presumably base,size) instead of 
base,limit?
121. m .impl.c.poolmv2.ap.empty Second bullet point could usefully use the term 
"LIFO".,
122. m .impl.c.poolmv2.ap.empty Could usefully clarify whether an attempt will 
be made to coalesce in case two.
123. CN - The glue layer problem can be viewed two ways.  Either we have one 
allocating thingie that can allocate in more than one AP; or we have lots of 
conceptual allocating thingies that can share actual APs for efficiency.

Pekka:
124. mN .impl.c.CBS Tags should be lower-case.
125. mN .impl.c.CBS Suballocating from the control pool is premature 
optimization, or perhaps just putting the improvement effort in the wrong place.
126. mN .impl.c.ABQ If it's fixed size, what happens to non-page-aligned 
splinters that cannot be returned to the arena, when you run out of space in 
the ABQ?

RichardK: 
127. Nm <throughout>  a discussion of, and clear terminology (perhaps "grain" 
vs. "block") for, the uses of segments, blocks and pages within segments, 
sub-blocks, suballocation, and subfreeing, would help clarity.  I ended-up 
rather confused about what was going on with these various divisions.
128. Nm .impl.*  Much (most?) of this seems to be policy.  Policy states, 
exhaustively, what you do when, for all things that affect the observable state 
of the system.  Mechanism and implementation are how you decide to construct 
code that will carry-out the policy.  Perhaps my understanding of the term 
"policy" is divergent?
  Pekka: I think it's just confusing to try to fit a design into such 
categories.
  RichardK: Clarification: That is, given a policy, you should be able to 
produce another allocator whose only observable difference is the time taken to 
perform tasks.
129. NI proc.review  After the process-brainstorm (which discusses the process 
that made the reviewed document), there should be a review-review, that 
discusses how well the review went, and how appropriate it was, and how it 
could be improved.
  (perhaps s/review-review/review-brainstorm/)
  Pekka: I think it's important that reviews are non-judgmental.
  RichardK agrees.

  Pekka: Both ways.

GavinM: 
130. NC Maybe we should have this document explain the use of CBS and ABQ, and 
other design documents explain their designs.

PTW:
[other issues recovered later]
131. I  rule.universal.purpose Should there be an explicit tag for .purpose?
132. I  rule.universal.note How can references, e.g., [paper.wil95] be
distinguished from comments, e.g., [TBD] in a text document.  Or are
references comments?
133. I  proc.review The review leader should print the document to be reviewed
in a standard format with line numbers.  The lack of line numbers makes it
difficult for role.check.backwards to correctly order their issues.
134. q 358 .clear Only the modularity is part of the design, not the actual
building of all possible combinations?
135. m 376 .consistent .arch.segregate.initial.choice: This is a much better
idea than .impl.c.multiAP.  Propogate it there and resolve a major issue.
136. m 412 .clear .arch.contingency: What does the term \"total free space\"
mean?  It is clear you mean to switch to first-fit (emergency) mode at some
point, but not clear how you intend to measure/specify that point.
137. q 412 .consistent .arch.consistency: Do you mean the high water mark on the
CBS to be a run-time configurable parameter of the pool?
138. m 442 .complete impl.c.poolmv2: Should the pool parameters include \"median
size\" so there is some indication of the distribution of sizes between
minimum and maximum?
139. m 455 .complete impl.c.poolmv2.ap.fill: What happens if you cannot get a
block from the arena?
140. m 465 .clear impl.c.poolmv2.free: What does \"the ABQ must be adjusted\"
mean?  Adjusted in what way?  (Perhaps this is referring to the possibility
that returning a block may enable two blocks on the ABQ to be merged?)
141. m 382, 433 .consistent .arch.parameters, .impl.c.ABQ: The term ABQ high
water mark is equivalent to the pool creation parameter \"free reserve\",
is it not?  Why not use one term?  Ditto for other pool parameters
142. m 424, 433 .clear .imple.c.CBS, .impl.c.ABQ: The CBS and ABQ hold segment
resources.  Does destruction of the these structures return those
resources, or is it an error to destroy a non-empty structure?  (I believe
the latter.)



Edit manpower: 52


Edit notes:

1. Fix:

.anal.strategy.risk: The current MPS segment substrate can cause internal 
fragmentation which an individual pool can do nothing about. We expect that 
request.epcore.170193.sugg.loci will be implemented to remove this risk.

2. Reject:

The pool supports .attr.range, but the client will get best performance by 
specifying minimum, typical, and maximum allocation sizes for a particular pool 
and using multiple pools when there is a wide range of sizes.  The statement 
you object to simply points out that if you allocate an object outside the 
range you configured the pool for, your performance will suffer.

3. Comment: There is no issue 3.

4. Fix: see .anal.strategy.risk

5. Fix: document the risk

.arch.adapt.risk: This adaptation is an experimental policy and should not be 
delivered to clients until thoroughly tested.

6. Fix:

.impl.c.poolmv2.future: The implementation should not preclude "buffered free" 
(mail.ptw.1997-12-05.19-07(0), ff.) being added in the future.

7. Fix: document what we'd really like

.impl.c.poolmv2.free.merge.segment.risk: The current segment structure does not 
really support what we would like to do.  Loci should do better: support 
reserving contiguous address space and mapping/unmapping any portion of that 
address space.

.impl.c.poolmv2.free.merge.alternative: Alternatively, if the MPS segment 
substrate permitteg mapping/unmapping of pages, the pool could use very large 
segments and map/unmap pages as needed.

8. Fix:

impl.c.multiap.sample-code: This glue code is not properly part of the pool or 
MPS interface.  It is a layer on top of the MPS interface, intended as sample 
code for unsophisticated clients.  Sophisticated clients will likely want to 
choose among multiple AP's more directly.

9. Fix:

.req.risk: req.product(2) is incomplete.

10. Fix:

.req.risk: req.epcore(16) is known to be obsolete, but the revised document has 
not yet been accepted.

...

.fun.debug: must support debugging erroneous usage by client programs (source: 
req.epcore.{dc.variety, debug.support}, req.product.attr.{mkt.eval, perform}).  
Debugging is permitted to incur additional overhead.

.fun.debug.boundaries: must support checking for accesses outside the 
boundaries of live objects

.fun.debug.log: must support logging of all allocations and deallocations

.fun.debug.enumerate: must support examining all allocated objects

.fun.debug.free: must support detecting incorrect, overlapping, and double 
frees.

...

.sol.strategy.debug: as much of the debugging functionality as possible should 
be implemented as a generally available MPS utility; the pool will provide 
support for debugging that would be expensive or impossible to allocate outside 
the pool

...

.sol.policy.debug: implement a pool debugging interface
.sol.policy.debug.counters: implement debugging counters in the pool that are 
queried with a generic interface
.sol.policy.debug.verify: implement debugging error returns on overlapping frees


11. Reject:

Supporting returning of sub-blocks does not preclude checking for overlapping 
frees.  There can be two different interfaces, one which permits sub-block 
deallocation and one which errs.

12. Reject:

It simply gives more detail.  The policy is only to reuse blocks when the reach 
a minimum size.  The architecture describes what is done in the boundary cases 
of an unusable splinter or an object larger than the minimum reuse size.

13. Reject:

Unless I am sorely mistaken, this is how EP debugging currently works.  What 
would be inefficient is for each pool to duplicate debugging support for 
fenceposts, tags, etc.  Each pool should only contain debugging support 
functions that can only (or only reasonably efficiently) be provided by the 
pool.  There should be a generic interface to these debugging features, and a 
debugging layer that sits on top of all pools (possibly a debugging version of 
AP's) should utilize that interface to provide uniform debugging features 
across all pools.

14. Fix: paper.beck82(0)

15. Reject:

.anal.mech.allocate.optimize-new: Wilson (paper.wil95(1)) reports some benefit 
from "preserving wilderness", that is, when a block of memory must be requested 
from the system to satisfy an allocation, only the minimum amount of that block 
is used, the remainder is preserved (effectively by putting it at the tail of 
the free list). This mechanism may or may not implement .sol.policy.allocate. 
We believe a better mechanism is to choose to preserve or not, based on 
.sol.policy.allocate.

16. Fix:

.test.component: Components .impl.c.splay, .impl.c.cbs, and .impl.c.abq will be 
subjected to individual component tests to verify their functionality.

.test.regression: All tests applied to poolmv (design.mps.poolmv(0)) and 
poolepdl (design.mps.poolepdl(0)) will be applied to poolmv2 to ensure that mv2 
is at least as functional as the pools it is replacing.

.test.qa: Once poolmv2 is integrated into the MPS, the standard MPS QA tests 
will be applied to poolmv2 prior to each release.

.test.customer: Customer acceptance tests will be performed on a per-customer 
basis before release to that customer (cf., proc.release.epcore(2).test) 

17. Fix:

If reuse size is small, or becomes small due to .arch.adapt, all allocations 
will be treated exceptionally (the AP will trip and a last-fit block will be 
chosen on each allocation).  This mode will be within a constant factor in 
overhead of an unbuffered pool.

18. Fix:

.fun.debug: must support debugging erroneous usage by client programs (source: 
req.epcore.{dc.variety, debug.support}, req.product.attr.{mkt.eval, perform}).  
Debugging is permitted to incur additional overhead.

.fun.debug.boundaries: must support checking for accesses outside the 
boundaries of live objects

.fun.debug.log: must support logging of all allocations and deallocations

.fun.debug.enumerate: must support examining all allocated objects

.fun.debug.free: must support detecting incorrect, overlapping, and double 
frees.

19. Fix:

adapable -> adaptive

I would be interested in what your definition of these two adjectives is.  
Clearly you have some fine distinction in mind.

20. Fix:

.attr.performance.time: by inference, the time overhead must be competetive

.attr.performance.space: by inference, the space overhead must be competetive


21. Reject:

That's correct.  There is no such requirement.  

22. Fix:

.req.crit.fun.debug.boundaries: must support checking for accesses outside the 
boundaries of live objects

.req.crit.fun.debug.log: must support logging of all allocations and 
deallocations

.req.crit.fun.debug.enumerate: must support examining all allocated objects

.req.crit.fun.debug.free: must support detecting incorrect, overlapping, and 
double frees.

23. Fix:

.req.fun.tolerant: must support tolerance of erroneous usage (source 
req.product.attr.use.level.1)

24. Reject:

Policy is an implementable decision procedure, hopefully approximating the 
strategy.

25. Fix:

Must support finding left and right neighbors of a failed search for a key. 
Tree nodes must store a value of type Size. Standard checking and description 
should be provided. See design.mps.splay(0) and design.mps.cbs(0).

Improvment suggestion: design.mps.splay(0) should reference your recent mail on 
splay trees.

26. Pass: GavinM

27. Mail: mail.ptw.1998-05-07.19-25(0) 

28. Pass: Pekka

29. Fix:

.req.fun.align: must support aligned allocations to client-specific alignments 
(source: req.epcore.attr(0).align)

30. Pass: RichardK  Try full text search on *promise.alloc

31. Reject:

.dl.promise.free:
  Support truncating a promise to the currently allocated part.
  Essential
  mail.nickb.1997-03-17.15-17

32. Reject:

.dl.multi:
  Manage multiple display lists simultaneously.
  Essential.
  meeting.epcore.1995-08-07.dl.multi

33. Reject:

Thread is a generally accepted CS term.

34. Fix:

req.epcore.attr.run-time, req.epcore.runtime.tp

35. Reject:

There is no conspiracy here.  The ep requirements document being split into 
multiple pieces and typographical error are the source of this problem.  You 
have already suggested an improvement to the former.

36. req.epcore.fun.debug.support

37. Reject:

.dl.free.any:
  Recycle the memory occupied by any individual display list object.
  Essential.
  meeting.epcore.1995-08-07.dl.free, meeting.epcore.1995-11-01.

38. Reject:

Mechanisms are algorithms or data structures used to implement policy.

39. Fix:

.sol.policy.debug.counters: implement debugging counters and meters that count 
or measure interesting statistical data in the pool that are queried with a 
generic interface

40. Reject:

The link is established through strategy and policy as supported by the 
referenced papers.

41. Reject: This is a generic analysis of manual-variable mechanisms.

42. Fix: allocated -> reserved (allocated is ambiguous in this context).

43. Comment: [i.e., the freed block will not be treated specially, it will be 
subject to the normal policy on reuse]

44. Reject: See mail.ptw.1998-04-16.19-34(0) 

45. Pass: GavinM

46. Pass: GavinM

47. Pass: GavinM

48. Pass: GavinM

[req.product.doc does address those requirements, but is not referenced by 
req.product.]

49. Fixed.

50. Fixed.

51. Fix:

Add "The pool class" or "Pool instances" where appropriate. [See 
design.mps.poolmv2(4)]

52. Fix: Already fixed in response to 10.

53. Fix:

.req.not.fun.reallocate.in-place: There is not a requirement that blocks must 
be resized in place (where possible); but it seems like a good idea.

54. Fix:

.req.attr.reliability: The pool class must have "rock-solid reliability". 
(source: req.dylan.attr.rel.mtbf, req.epcore.attr.rel, req.product.attr.rel)

55. Fixed.

56. Fix:

.sol.mech.allocate.segregate.size: use size as a substitute for type

57. Fix: changed to a comment

58. Reject: solutions do not have to be justified

59. Mail: mail.ptw.1998-05-14.20-41(0)

Because decisions about whether to move on reallocate, whether to reserve extra 
on reallocate, etc. should be centralized, not distributed in each pool.  There 
should be a generic pool interface to request adjusting a blocks size in 
support of that.

60. Fixed.

61. Mail: mail.ptw.1998-05-14.20-41(0)

"We believe that this will take advantage of the underlying virtual memory 
system's ability to compact the physical memory footprint of the program by 
discarding free fragments that align with the virtual memory quantum."

In other words I may want to reserve a big chunk of contiguous address space to 
prevent internal fragmentation, but I also may want to unmap the free areas to 
reduce memory footprint.  The O/S only supports these operations on full pages.

62. Reject: the optimization applies to any system where the pool requests 
memory from an arena in a quantum larger than necessary.  Should the leftovers 
be used immediately or not?  Wilson suggests a policy of not.  I propose a 
policy of using the leftovers for objects with similare deathtimes as the first 
object.

63. Fix: I added a boatload of tags [which to my mind do not make the document 
clearer]

64. Fix:

.arch.ap.no-fit.splinter: If the fragment is below a configurable threshold 
(splinter size), it will be left unused (but returned to the CBS so it will be 
reclaimed when adjacent objects are freed); 

65. Fix: 

.arch.abq.return: When the MPS supports it, the pool will be able to return 
free blocks from the ABQ to the arena on demand.

66. Fix: Already fixed in response to ptw.136

67. Reject: a) this is a comment, so cannot cause a defect, see 
guide.text.comment; and b) presumably Dylan would not find the MPS acceptable 
if it delayed maximum pause time before satisfying each allocation?

68. Fixed.  By implication, Dylan will never require objects in a manually 
managed pool?

69. Fixed. This was a comment to myself.

70. Mail: mail.ptw.1998-05-14.21-42(0)

".anal.policy.size: As an initial choice, the quantum of virtual memory is used 
as the size at which to reuse blocks. We believe that this will take advantage 
of the underlying virtual memory system's ability to compact the physical 
memory footprint of the program by discarding free fragments that align with 
the virtual memory quantum."

71. I assume you meant .sol.mech.allocate.optimize-small.

Mail: mail.ptw.1998-05-14.21-42(0)

This is a synopsis of one of the many solutions enumerated by Wilson.  Many 
researchers have noted that small blocks typically have short lifetimes and 
that overall performance is improved if you optimize the management of small 
blocks.  I don't think it is a problem if you spend less time managing a block 
that has a long lifetime too.  Another view of the same issue is that if 
allocation has a fixed cost, small objects will be disproportionately expensive 
to work with.

72. Fixed.

73. Fixed.

74. Reject: See 70.

75. Mail: mail.ptw.1998-05-14.21-42(0)

There is an MPS-locking mechanism, AP's use it so the client does not have to 
interlock with the MPS on every allocation.  I am confident that if a client 
wants to have the overhead of interlocking, they don't need to use AP's.

76. Mail: mail.ptw.1998-05-14.21-42(0)

Yes they can become merged.  See design.mps.cbs(0).

77. Mail: mail.ptw.1998-05-14.21-42(0)

The same support as currently supplied by the MPS.

78. Pass: GavinM

79. Pass: GavinM

80. Pass: GavinM

81. Fix:

[These are the only terms that I could find that I could possibly believe need 
definition.  Most of them were already defined before use, but now the 
definitions are all in one place.]

DEFINITIONS

.def.fragmentation: Fragmented memory is memory reserved to the program but not 
usable by the program because it is non-contiguous (see also, 
glossary.fragmentation ).

.def.cartesian-tree: A cartesian tree is a binary tree ordered by two keys 
(paper.stephenson83(0)).

.def.splay-tree: A splay tree is a self-adjusting binary tree 
(paper.sleator96(0)).

.def.bit-map: A bitmap is a boolean-valued vector (see also, glossary.bitmap ).

.def.refcount: A refcount is a count of the number of users of an object (see 
also, glossary.reference.count ).

.def.in-band: From "in band signalling", when descriptive information about a 
data structure is stored in the data structure itself (see also, 
glossary.in-band.header ).

.def.out-of-band: When descriptive information about a data structure is stored 
separately from the structure itself (see also, glossary.out-of-band.header ).

.def.splinter: A splinter is a fragment of memory that is too small to be 
useful (see also, glossary.splinter )

82. Fix: Already fixed. See 53.

83. Fix:

anal.mech.allocate.optimize-small: Wilson (paper.wil95(1)) notes that small 
blocks typically have short lifetimes and that overall performance is improved 
if you optimize the management of small blocks, e.g., 
sol.mech.allocate.lookup-table for all small blocks.  We believe that 
.sol.mech.allocate.buffer does exactly that.

84. Fix: Author will soft shoe to "Tea for Two" until next comercial break and 
execute head writer at dawn.

85. Fix:

.sol.mech.allocate.optimize-new: When "virgin" memory is acquired from the 
operating system to satisfy a request, try to preserve it (i.e., use only what 
is necessary)

86. Fixed.

87. Fixed.

88. Fix: there are more now.

89. Fix:

.arch.ap.refill: The pool will have a configurable "reuse size" that will be 
the preferred size block used to fill the allocation point. 
.arch.ap.refill-size: The refill size should be chosen to amortize the cost of 
refill over a number of typical allocations, but not so large as to exceed the 
typical object population of the pool.

90. Reject: The sentence is: "When the MPS supports it, the pool will be able 
to return free blocks from the ABQ to the arena on demand."

91. Fixed.

92. Reject: due to role

93. Fix: Already fixed. See 7.

94. Fix:

.impl.c.multiap: The initial implementation will be a glue layer that selects 
among several AP's for allocation according to the predicted deathtime (as 
approximated by size) of the requested allocation. Each AP will be filled from 
a pool instance tuned to the range of object sizes expected to be allocated 
from that AP. [For bonus points provide an interface that creates a batch of 
pools and AP's according to some set of expected object sizes. Eventually 
expand to understand object lifetimes and general lifetime prediction keys.]

95. Fix: Already fixed. See 16.

96. Fixed.

97. Reject: it was not a source used in developing this document.  It is 
mentioned elsewhere in the document.

98. Fix:

.non-req.fun.gc: There is not a requirement that the pool class support 
formatted objects, scanning, or collection objects; but it should not be 
arbitrarily precluded.

99. Fix: Already fixed. See 53.

100. Reject: I disagree.

101. Fixed.

102. Fix:

.def.alignment: Alignment is a constraint on an object's address, typically to 
be a power of 2 (see also, glossary.alignment )

[It seems overly pedantic to have to define in the subject document terms that 
are already defined in the glossary.]

103. Fixed, but see also 105.

104. Fix: (For a complete analysis of the splay tree algorithm time bounds see 
paper.st85(0).)

105. Pass: GavinM

106. Reject: There is no reason that the vector must be indexed by grain.  Any 
fixed -size block works.

107. Reject: Speculation is not useful.

108. Fix: The tree data structures are amenable to being stored in the free 
blocks themselves, minimizing the space overhead of management.

109. Reject: What else would it be talking about?  In-band fluglehorns? 

110. Fix:

.sol.mech.desc.crossing-map: An alternative for untagged architectures is to 
store a "crossing map" which records an encoding of the start of objects and 
then store the descriptive information in-band.

111. Reject: The paragraph can be verified by consulting the referenced 
literature.

112. Mail: mail.ptw.1998-06-23.22-59(0) So as not to preclude an MV2 pool from 
being an exact root for a collected pool.

113. Fix:

.arch.fragmentation.internal: The pool will request large segments from the 
arena to minimize the internal fragmentation due to objects not crossing 
segment boundaries.

.arch.segment.return: arch.abq.return can be guaranteed to be able to return a 
segment by setting reuse size to twice the size of the segments the pool 
requests from the arena.

114. Fix: I have removed this feature as uneccesary.  The pool can be destroyed 
if it is unused.

115. Fix: Don't split infinitive.

116. Fixed.

117. Fix:

.arch.adapt: We believe that an important adaptation to explore is tying the 
reuse size inversely to the fragmentation (as measured in 
.arch.contingency.fragmentation-limit).

118. Fixed.

119. Mail: mail.ptw.1998-06-23.22-59(0) If there are many MV2 pools, using many 
CBS's it would seem excessive to have each CBS have its own MFS pool.

120. Mail: mail.ptw.1998-06-23.22-59(0)  The client requires a table that 
associates Addr and Size.  A number of implementation choices are possible.

Fix: Must support storing and retrieving a value of type Size associated with 
the key.

121. Fix:

.impl.c.poolmv2.ap.empty: An AP empty request will be handled as follows:
o If remaining free is less than min size, return it to the CBS
o If the remaining free is larger than any previous splinter, return that 
splinter to the CBS and save this one for use by a subsequent fill
o Otherwise return the remaining block to the CBS

122. Fix: see 121

123. Reject: I don't know what a thingie is, but AP's are supposed to be 
lightweight so shouldn't need to be shared.

124. Fixed.

125. Fix:

For locality, this storage should be managed as a linked free list of splay 
nodes suballocated from blocks acquired from a pool shared by all CBS's.

126. Reject:  They remain in the CBS.  See .impl.c.poolmv2.free.merge.segment

127. Fix:

.def.block: A block is a contiguous extent of memory.  In this document, block 
is used to mean a contiguous extent of memory managed by the pool for the pool 
client, typically a subset of a segment (compare with .def.segment).

.def.segment: A segment is a contiguous extent of memory.  In this document, 
segment is used to mean a contiguous extent of memory managed by the MPS arena 
(design.mps.arena(1)) and subdivided by the pool to provide blocks (see 
.def.block) to its clients.

.def.subblock: A subblock is a contiguous extent of memory.  In this document, 
subblock is used to mean a contiguous extent of memory manage by the client for 
its own use, typically a subset of a block (compare with .def.block).

128. Reject: That is a fine definition of policy, but there is already a policy 
section to the document.  The .impl section is a detailed description of the 
expected implementation intended to be a halfway point between the policy and 
the actual implementation.

129. Pass: GavinM

130. Fix:  See design.mps.cbs.  The ABQ is not of sufficient complexity to 
warrant a separate design document.

131. Pass: GavinM

132. Pass: GavinM

133. Pass: GavinM

134. Mail: mail.ptw.1998-05-11.19-47(0)  Yes.

135. Fix: Already fixed in response to 8.

136. Fix:

When the free space in the CBS as a percentage of all the memory managed by the 
pool (a measure of fragmentation) reaches that high water mark, the CBS will be 
searched first-fit before going to the arena.

137. Fix:

there will be a pool creation parameter for a high water mark for the CBS

138. Fix:

Creation takes parameters: min size, average size, max size, free reserve, free 
reserve decay rate, cbs fragmentation limit.

139. Fix:

.impl.c.poolmv2.ap.fill: An AP fill request will be handled as follows:
o If the request is larger than max size, attempt to request a segment from the 
arena sufficient to satisfy the request
o Attempt to retrieve a free block from the head of the ABQ (removing it from 
ABQ and CBS if found).
o If contingency mode, attempt to find a block on the CBS, using oldest-fit 
search
o Attempt to request a block of max size from the arena
o Attempt to find a block on the CBS, using oldest-fit search
o Otherwise, fail

140. Fix:

If a merge occurs between two blocks on the ABQ, the ABQ must be adjusted to 
reflect the merge.

141. Fix: [These are external names]

Min, average, and max size are used to calculate the internal reuse size. Free 
reserve and decay rate are used to calculate the ABQ high water mark and decay 
rate.  Fragmentation limit is used to calculate the CBS contingency high water 
mark.

142. Fix:

Must support creation and destruction of an empty tree. [...] Must support 
iterating over the elements of the tree with reasonable efficiency.

Must support creation and destruction of an empty queue.




Exit: exit.design
