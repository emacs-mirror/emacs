                     REVIEW OF DESIGN.MPS.SPLAY(2)
                       review.design.mps.splay.2
                           incomplete review
                             drj 1999-03-10

Rules: rule.universal
Checklists: None
Source: design.mps.cbs, design.mps.poolmv2, paper.st85

Author: tony
Leader: drj
Editor: tony
Scribe: drj

Entry: entry.design
Entry manpower: .5 ish


Entry notes:

Hasn't actually been RFCed but everyone is familiar enough with the broad direction I think.  Review can proceed.


Loggingstart: 1610
Loggingend: 1710
Logginglength: 60
Loggingrate: 2

Checkers: andys;clarity; tony;correctness; pekka;correctness; rit;source; drj;correctness;conventions
Rate: 11 lines
Length: 551 lines
Actual checking time: 255

Kickoff start: 1506
Kickoff end: 1511
Kickoff length: 5

Kickoff notes: See drj's notebook 1999-03-10


ISSUES:

.log.source: This log is edited from the raw IRC log kept in the "IRC logs" 
database: IRC log for #mm-review on Wednesday 10th March 1999 

drj: about 50 mins, 100%, 3M, 33m, 2q, 1C, 0I, 100%
tony: about 50 mins, 100%, 3M, 4m, 0.....
Pekka: 55 min, 50%, 1M, 11m, 2C, 0q, 3I
rit: about 50 mins, 100%, 11M, 15m, 3C, 3q, 0I
andys: about 50 mins, 0M, 12m, 8Q

AndyS:
1. 68 Q Is the set assumed to have a total ordering? If so why not say right up 
front?
2. 77 m Neighbouring isn't defined.
3. 87 Q Should 'fixed' be quantified/qualified in some way?
4. 113 m 'It represents ...', uh? Reword.
5. 127 Q client-oriented -> human readable?
6. 134 Q ClosureP and ClosureS - are these defined elsewhere?
7. 163 Q Shouldn't the contract of 'check' be defined?
8. 181 m What does 'finish' mean, and if it doesn't mean 'finish' why call the 
function '**finish'?
9. 199 m Reword the sentence (e.g. make it active rather than passive).
10. 206 m ditto 199
11. 223 m adjacent to what?
12. 229 Q Should the 'first ' element be called the least element?
13. 254 m ClosureP and ClosureS again.
14. 275 Q should -> must?
15. 321 m sentence is ambiguous.
16. 281 m Things start to go awry from here on in for me... Why not say what 
the additional freature is up front.
17. 324 Q what is the discussion of 'ops' doing here?
18. 360 Q isn't this just a restatement of one of the algorithm's from st85?
19. 366 Q Do we just just believe these assertions?
20. 371 Q Which 'middle tree'?
21. somewhere q Is the implementation meant to be 'thread safe'?

Tony:
22. M 61 Either the intro is wrong, or there should be a requirement that we 
implement a splay tree
23. M 66 What are the common operations?
24. M 171 Design should specify any client restrictions on compare & update 
methods - e.g. avoid using splay interface functions
25. m 87 "with a fixed size stack" -> "with bounded stack usage" (constant 
size, presumably).
26. m 198 should mention that SplayTreeInsert splays the tree. This is not just 
an impl detail. Also for other functions for which this is important.
27. m 231 "is the tree" -> "if the tree"
28. m 365 Elsewhere the design depends on what ends up as the root when the key 
is not found. (see lines 485, 497). It's confusing to say here that it's 
arbitrary.
29. 371 mn untagged paragraph

Pekka:
30. .source M Source documents are incomplete (even the bib entry).
31. .source C It would be nice to have doc links.
32. .def.node & .def.key m Defining common CS terms is unnecessary and 
potentially confusing.
33. .def.key m I wouldn't say keys are implemented by "void *", but rather
_represented_.
34. .def.client-property m Should define it here, by giving the restrictions.
35. .req m Surely the requirements are derived from desing.mps.cbs as well.
36. .req I req.mps is missing.
37. .req.order m Say "totally ordered".
38. .req m The requirement for SplayRoot is missing. (Mea culpa.)
39. .type.compare I This belongs in design.mps.types. (duh)
40. 120 m "as passed into a function" unclear and not useful
41. .impl.splay & others C spell-check!
42. 379 m "with the ordering"
43. 382 m "root" undefined.
44. 382 ff. m Sloppy notation confuses nodes and their keys
45. .impl.insert m This is the less effective variant. Why?
46. 134 qN ClosureP and ClosureS -- why two args?
47. 254 mN They're not closures!
48. .impl.splay nq Does this mean we rule out open-coding and combining
49. .impl.delete nm This is the less effective variant. Why?
50. 54 nm If "first" etc. are defined here "left" and "right" should be as

rit:
51. 9 q Should paper.sleator96 also be a source document?
52. 34 M "This" -- i.e. fact that access bring accessed element to top of stack 
is not itself sufficient to give excellent amortised performance. Author knew 
this, but it's misleading.
53. 42 M remove brackets -- a Splay Tree is not just a self-adjusting binary 
tree, it's _this_ kind of self-adjusting binary tree in particular.
54. 49 m "ordered" -> "totally ordered" (this gets said later)
55. 54 nM define "first", "previous", "next" and "last" elements in terms of 
the comparator. They get used later.
56. 80 M design.mps.poolmv2(4) says iteration must have "reasonable 
efficiency", which doesn't seem to be what's implied here
57. 96 M Must cope with dynamically changing client property too (i.e. client 
calls Splay when it changes).
Whereas the key of a SplayNode is assumed to be fixed, the client property is 
allowed to change.
To cope with this, we have SplayRefresh or whatever it's called, which the 
client calls if the property at a node changes.
58. 147 m meaning of "any" ambiguous
59. 152 M prototype for updateNode has a return type of Bool, but the 
description doesn't give much away about it.
60. 161 M Doesn't say which of these functions are supposed to have low 
amortised cost. All of them?
61. 180 q What is SplayTreeFinish (similarly SplayNodeFinish) for? Doesn't seem 
to serve any purpose. (Andys already said this)
62. 182 q Do we have a convention on how to pluralise function names &c?
63. 218--224 m Amusingly, this desc (from "leftReturn will be NULL..." to 
"...comparison order in the splay tree") does not specify what leftReturn must 
be if rightReturn is NULL, and vice versa.
64. 241 M or maybe m. In some sense, iterating over all the nodes doesn't give 
poor amortised performance, it's just that you have a large working set.
65. 257 q "may not be called if . . ." Why not?
66. 267 q ditto.
67. 281 M The description of client-determined properties is very confusing and 
unclear. Partly problem is wording (e.g. it's a property one minute and a 
function the next). Partly problem is there's no indication of what sort of 
property you might want to use. There's a code example, but no explanatin of 
what it's intended to do.
68. 345 C We can avoid going down the trees and up again if we do the initial 
pointer reversal during the link stage.
69. 357 M Doesn't say which of the several splaying algorithms presented in 
paper.st85 is being used. It is kind of implied by the heading "top-down 
splaying", but in fact what's presented is sleator's top-down splay algorithm 
extended to cope with splaying on keys not present in the tree.
70. 369 m "future operations" -- i.e., specifically future calls to SplaySplay.
71. 371 m Confusing. Should describe left, middle, right trees before beginning 
to talk about them.
72. 379 m I don't understand "form a partition on".
73. 381 m Should explain the extension of sleator's zig, zig-zag terminology.
74. 382 m Should say which tree "root" is the root of (it's the middle one).
75. 396, 403, 408, 413 m A semicolon is used to mean "do this, then this". It's 
not immediately clear.
76. 416--466 M This whole section is incredibly confusing and ambiguous. Mainly 
the problem is it's written out in english. E.g:
a sentence like "the right child of the original root is the left child of the 
original right child" (419).
Actually that's some kind of assignment statement, but you can't tell what "is" 
means because we're describing the tree at two times.
I think there's no benefit from this kind of English description of the 
operations. Pseudo-code would be much much clearer.
Another example: l 449: "the splay operation is completed". Is that a 
description or an instruction?
77. 471--487 m These descriptions would be much clearer if phrased in terms of 
split and join (that's how Sleator and Tarjan present them). Again, pseudo-code 
would be better.
78. 502 C It's also possible to implement SplayTreeNeighbours by simply keeping 
track of both neighbours as you splay. This has almost no cost.
79. 508 M There's no description of how iteration is implemented.
80. 549 C I think it is indeed possible to use the comparator to distinguish 
between right-sibling and parent pointers, but it's not immediately obvious how.
81. nI Allow more time for review logging in future.
82. general nm (related to drj's issue at line 122) Should be some general 
explanation somewhere of decisions about not putting anything except left and 
right children in the SplayNode structure, and leaving it up to the client to 
make sure it can find other information associated with a node.

drj:
83. 50 m discussion of "void *" seems innappropriate here.
84. process nI ensure everyone has really does have access to IRC before
starting logging meeting.
85. 64 M what about PoolClassMVFF?
86. 96 M Why Splay Trees for these requirements?
87. 97 M No model of use.
88. 122 m explain why compare takes a key and a node, rather than two nodes
or two keys.
89. 161 m the interface isn't multithread safe and should say so?
90. process NI how do we lift/describe design from papers such as paper.st85 
without boringly copying it?
91. 165 m reference the checking design, design.mps.check which explains the
existence of the *Check functions.  Also guide.impl.c.adt.  NB checking
design is incomplete.
92. 172 m link compare method to .req.order
93. 176 m yukky candy-machine interface. consider two Init functions or
optargs.
94. 182 m and the implication is?
95. 195 m (and elsewhere) "rootReturn" -> "*rootReturn". (this is C not Algol)
96. 198 m link to .req.add
97. 202 m add "and the node will not be inserted"
98. 205 m link to .req.remove
99. 208 q really? (apparently yes). Is this desirable?
(of deleting node's that aren't in the tree)
100. 212 m link to .req.locate
101. 217 m link to .req.neighbours
102. 218 m *leftReturn
103. 220 m *rightReturn
104. 229,235 m link to .req.iterate
105. 241 Nm actually paper.st85 Theorem 9 says iteration's amortised cost is 
O(n). that's sounds pretty good to me.
106. 246 m link to .req.debug?
107. 252 m clarify "first". throughout I guess.
108. 258 m inconsistent handling of updateNode, testNode, testTree. one is 
passed to the TreeInit function, others are passed to the Find functions.
updateNode is an argument to SplayTreeInit,
why is updateNode an argument to SplayTreeInit and yet testNode and testTree 
are arguments to SplayFindFirst?
109. 262 m explain "last"
110. 252,262 m link to .req.find
111. 321 m bug here? SplayNodeInit doesn't call updateNode so what does this 
sentence mean?
112. 334 m explain what is done and why. There is discussion here, but I can't 
tell what the intent of the design is.
113. 342 m don't "propose", explain what is done and why.
114. 360 C could usefully link to the paper more closely
115. 381 Nm diagrams would help enormously. or perhaps reference the ones in 
the paper.
116. 421 m "sometimes regarded" ... EG in the paper.
the rotates and links (to save a few assignments)?
117. 431 m unclear, especially last sentence
118. 448 m should explain shortcut we do when key == root in initial state.
119. 476 m "irrespective" is unclear and possibly wrong. use "other" or 
"opposite" or whatever.
120. 506 q and does that typically happen?

There was the following discussion:

<rit> pekka, can you clarify:
<rit> where does req for SplayTreeRoot come from?
<Pekka> rit: CBSFindLargest
<rit> Can be done without it, though, by subverting the other interfaces 
slightly!

concerning issue 76:
<Pekka> Working out algorithms in pseudocode shouldn't be necessary, unless you 
intend to write a confusing implementation.
<rit> Well, maybe we should just reference sleator and leave it at that?
<Pekka> rit: Probably, unless we feel we're extending the algorithm too far 
beyond the paper
<rit> pekka: Yes, we could just describe the extensions.




Brainstorm start: about 1729
Brainstorm end: about 1736
Brainstorm length: 7 mins


BRAINSTORM:

Of issue 76.

Trying to describe the detail of an implementation in English is bad.
Perhaps try Pseudo-code.
Or reference the description in the paper.
Or use picutres.


Number of major issues: 18
Number of minor issues: 62
Number of issues: 120

Edit manpower: 30


Edit notes:

1. Mail: mail.tony.1999-04-01.16-21(0); Yes. The document now makes this 
explicit.

2. Fix: 
.def.neighbour: A node N which has key Kn is a "neighbour" of a key K
if either Kn is the first key in the total order which compares
greater than K or if Kn is the last key in the total order which
compares less than K. 

3. Mail: mail.tony.1999-04-01.16-21(0): Yes. Now qualified as follows:
"Must do all non-debugging operations with stack usage bounded by a
constant size." 

4. Fix: Dropped this sentence.

5. Mail: mail.tony.1999-04-01.16-21(0); No. The client provides this method. 
The key
point is that it is client-oriented. Presumably the client also wants
it human readable.

6. Mail: mail.tony.1999-04-01.16-21(0); They weren't. They are collectively the
environment for the method. This is now clearer.

7. Mail: mail.tony.1999-04-01.16-21(0): Yes. Added ref to 
guide.impl.c.adt.method.check

8. Fix: Added ref to guide.impl.c.adt.method.finish

9. Fix: Reworded as follows: "This function is used to insert into a
splay tree a new node which is associated with the supplied key."

10. Fix: Reworded as follows: "This function is used to delete from a
splay tree a node which is associated with the supplied key."

11. Fix: adjacent to each other

12. Mail: mail.tony.1999-04-01.16-21(0); No - 'first' is in common usage in the
document. I think the problem is that it wasn't a defined term. It is
now.

13. Fix: "closureP and closureS are arbitrary values, and are passed
to the testNode and testTree methods which may use the values as
closure environments."

14. Mail: mail.tony.1999-04-01.16-21(0); Yes. (now changed).

15. Fix: "This callback will also be used in the obvious way when
inserting new splay nodes."

16. Fix: Rewrote this bit somewhat.

17. Mail: mail.tony.1999-04-01.16-21(0); Hopefully this is clearer after 
rewording: "The
splay operations must cause client properties for nodes to be updated
in the following circumstances:-"

18. Mail: mail.tony.1999-04-01.16-21(0); yes. This is now said explicitly.

19. Mail: mail.tony.1999-04-01.16-21(0); We believe the source doc 
(paper.st85). I've
added an xref.

20. Mail: mail.tony.1999-04-01.16-21(0); The one mentioned in paper.st85 in the
description of top-down splaying. This is now clearer. See issue 71.

21. Mail: mail.tony.1999-04-01.16-21(0); No. Added paragraph 
.function.no-thread: to
make this clear.

22. Fix: Added ".req.splay: Common operations must balance the tree by splaying 
it, to achieve low amortized cost."

23. Fix: Specify which requirements correspond to common operations.

24. Fix: As for issue 21

25. Fix: "Must do all non-debugging operations with stack usage
bounded by a constant size."

26. Fix: Added "It first splays the tree at the key."

27. Fix:

28. reject: lines 485 & 497 are careful to avoid depending on which
neighbour is brought to the root.

29. Fix:

30. Raise: Noted

31. Mail: mail.tony.1999-04-01.16-21(0); The doc links are there - but weren't 
shown in
the printout used for the review.

32. Reject: The definitions contribute a (small) amount of
context-specific information.

33. Fix: dropped this sentence.

34. Fix: Now define it in an inherently restricted way (at the risk of
hiding some of the gratuitous generality).

35. Fix:

36. Raise: Noted

37. Fix: as issue 1

38. Fix: added .req.root

39. Edit: design.mps.type.compare

40. Fix: deleted

41. ?? what's the issue?

42. Fix:

43. Fix: now defined in .impl.splay.cases

44. Fix: defined notation in .impl.splay.cases

45. reject: The alternative variant is not amenable to top-down
splaying

46. Mail: mail.tony.1999-04-01.16-21(0); Historically this was probably for 
consistency
with other uses of closures (e.g. mps_tramp). The cost for 2 args is
small. The benefit is client flexibility.

47. Fix: Explain that the values form the environment for a closure.

48. Mail: mail.tony.1999-04-01.16-21(0); No - details like that are up to the
implementation.

49. Reject: as issue 45

50. Fix: added .def.left-child & .def.right-child

51. Mail: mail.tony.1999-04-01.16-21(0); Yes. (Now fixed)

52. Fix: "This" -> "The restructuring of the tree caused by the access"

53. Fix: removed brackets

54. Fix: as suggested

55. Fix: Added .def.first & .def.last. "Previous" & "next" are not
used in this context, so this part is rejected.

56. Fix: ".req.iterate: Must be able to iterate over all members in
order with reasonable efficiency. "

57. Fix: Added .req.property.change

58. Fix: "...whether there are any nodes in the sub-tree for which the testNode 
method ... would return TRUE  ..."

59. Fix: This was a typo. Return type is now given as void

60. Fix: see issue 26

61. Mail: mail.tony.1999-04-01.16-21(0); This follows the MPS convention for 
abstract
data types, and is the "destructor" function for splay trees. (see
guide.impl.c.adt.method.finish).

62. Mail: mail.tony.1999-04-01.16-21(0); No. I think it's better to avoid doing
that. I've changed the document accordingly.

63. fix: rewrite in terms of (the new) .def.neighbour

64. Fix: "If many nodes are accessed as a result of multiple uses, the
resultant tree will be generally well balanced. But if the tree was
previously beneficially balanced for a small working set of accesses,
then this local optimization will be lost."

65. Mail: mail.tony.1999-04-01.16-21(0); Because that would be a protcol
violation. Client properties are only supported for trees with
updateNode methods. However, I have changed the design now so that all
trees have updateNode methods, and the splay module exports a trivial
method.

66. Mail: mail.tony.1999-04-01.16-21(0); ditto

67. Fix: rewrote this

68. Comment: Added .future.reverse

69. fix: Added .impl.top-down, which spells this out

70. fix: as suggested

71. Fix: reordered paragraph as suggested

72. Fix: as issue 42

73. Fix: (see .impl.splay.cases)

74. Fix: (see .impl.splay.cases)

75. fix: s/;/followed by

76. fix: Now described via pictures lifted from paper.st85

77. Forget: This would make these descriptions simpler - but it would
also introduce the need to describe split & join. There would be no
overall simplification. I did add a reference to paper.sleator96 which
gives a code implementation which corresponds closely to the
descriptions given here.

78. comment: 

79. fix: add .impl.next

80. forget: This is work for the future - so there's no need to do the
design work now.

81. Raise: assimilate into group psyche

82. Fix: Spelt this out in .type.splay.node

83. Fix: see issue 33

84. Raise: assimilate into group psyche

85. Fix: Mentioned MVFF in .req and .source.

86. Fix: See issue 22

87. Fix: Added a USAGE section with some examples.

88. Fix: Added an explanation

89. Fix: added .function.no-thread

90. Raise: Discuss this in devel meeting?

91. Fix: done

92. Fix: done

93. Fix: clients should now pass SplayTrivUpdateNode instead of NULL.

94. fix: "clients wishing to destroy a non-empty SplayTree must first
explicitly descend the tree and call SplayNodeFinish on each node from
the bottom up." 

95. Fix:

96. Fix:

97. Fix:

98. Fix:

99. Mail: mail.tony.1999-04-01.16-21(0); The design is reasonable, IMO. [ ... ]

100. Fix:

101. Fix:

102. Fix:

103. Fix:

104. Fix:

105. Fix: see issue 64

106. Fix:

107. Fix: As issue 55.

108. Reject: The functions performed by these functions are not
sufficiently closely related that they must be handled
consistently. The updateNode function must be called whenever the tree
is rearranged - so it must be available for all splaying
operations. OTOH, the testTree & testNode functions are simply
predicates. There's no need to make them globally available - and
doing so would reduce client choice.

109. Fix: As issue 55.

110. Fix:

111. Fix: See issue 15

112. Fix:

113. Fix:

114. Fix:

115. Fix: Diagrams now replace the text.

116. Fix: Now dropped. See issue 115

117. Fix: Now dropped. See issue 115

118. Fix:

119. Fix: Used "opposite"

120. Mail: mail.tony.1999-04-01.16-21(0): Yes. The doc now explains this is 
likely to be
common


