              REVIEW OF DESIGN.PRODUCT.SOFT.DROP.MANUAL(0)
                review.design.product.soft.drop.manual.0
                           incomplete review
                           gavinm 1997-10-14

Rules: rule.universal
Source: req.product, design.product.arch
Candidate status: draft

Author: pekka
Leader: gavinm
Editor: pekka
Scribe: gavinm

Entry: entry.universal
Entry manpower: .1


Entry notes:

Source documents unapproved.
Leader untrained.
Minor defects in brief check.
S'OK.
GavinM 1997-10-14


Loggingstart: 15:42
Loggingend: 16:08
Logginglength: 26
Loggingrate: 1.6

Checkers: Pekka;GavinM;Sheep;PTW
Rate: 1/6 page
Length: 5 pages
Actual checking time: 138

Kickoff start: 1997-10-15 14:13 BST (09:00 EDT) Pool Hall
Kickoff end: 14:15
Kickoff length: 2


ISSUES:

PTW: 2M 3m 1C 6q iI, 38 minutes, 100%
Pekka: 7m 2C, 35 minutes, 100%
Sheep: 1M 8q, 30mins, 100%
GavinM: 1M 10m 1q, 35 minutes, 100%

1. PTW .anal.files.configurable.cpp M Is there a danger of name collision if C 
uses binaries containing C++ parts?
  Pekka: Even if we use a suitable prefix?
2. PTW .arch.finish M Why is this issue not discussed in .sol and .anal?
3. Sheep - M is .soft.drop.auto assumes that this is a drop in GC. 
  It's unclear as to what exactly is ment (conflict of clarity)
4. GavinM .anal.extensions M We will fall down severly if we don't implement MM 
extensions people may rely on, such as msize or stackalloc
5. PTW design.product.arch.soft.drop.* I I am unclear as to how the .manual and 
.auto interfaces differ.
6. PTW req.fun.platfrom.* m platfrom -> platform
7. PTW - q Do we have market justification for req.fun.platform?
8. PTW - C  It would be clearer if the solution analysis stated explicitly 
which solution was chosen.
  In your analysis section, you specify some pros and cons, but leave it up to 
the reader to decide which is the best.
  I was suggesting you say:  "Therefore we choose solution X"
  Pekka: What do I use the SOLUTION section for then?
  PTW: The solution section seems to list all the ideas without saying whether 
they are good, bad, or otherwise.
  GavinM: that's what the analysis section is for. 
  PTW: Somewhere the document should say what was chosen to be implemented, no?
  GavinM: Yes.
9. PTW .arch.size m Unclear: does the client of the C interface need the size?
10. PTW arch.init q Have we investigated how other malloc libraries acheive 
initialization?
11. PTW .arch.init m Is there a performance impact from this (first-time flag)?
12. PTW .arch.finish q Can we not override _exit to acheive this?
13. PTW .fun.realloc q I don't understand \"for a NULL pointer argument ... do 
as malloc does\"
14. PTW .fun.free q This is an improvement on the standard, is it not?  How 
does this fit with \"drop in\"?
  Pekka: .fun.free -- imporvement in what sense?
  PTW: The standard says a double-free is undefined, does it not.  You propose 
to signal an error.  This is an improvement.
  Pekka: True. perhaps we shouldn't check.
  PTW: My q is, are we allowed to "improve" in this sense?  (We do want 
performance improvement.)
15. PTW .operator.delete q Do we have to do something to support class-specific 
operator delete(void*, std::size_t)?
16. Sheep so.recursion.ann-turnoff m might this effect the expected behaviour 
of malloc
17. Sheep .anal.file.config.cpp m I'd like to quible with anal.file.config.cpp 
C++ run times tend to be quite big
18. Sheep - C in testing (ok perhaps this is a suggestion ) how about using 
Purify ? 
  or a runtime check for coruption
  You have test.smartheap which sugests ... 
  using another product I'm just chipping in with another.
19. Sheep - m I'm not sure if all versions of all compilers support new[] 
(array new) 
  Pekka: they don't
20. Sheep - m I think we should also have an interface to malloc which is for 
debugging only 
  something like malloc_debug(size,__FILE__, __LINE__) 
  the info passed to the telemetry system
21. Sheep - m I guess the debug version could also do something like filling 
with 0xE3
  And possibly puting on checks in for writing past the end of the object.
22. Sheep m Standard malloc does not assert 
23. Pekka req.product I incomplete
24. Pekka req.product.plan I What is this for?
25. Pekka .test.smartheap m (guide.tag.internal.form) tag must be lower-case
26. Pekka .test.smartheap m typo "6bytes"
27. pekka .test.cpp.systematic m constructors and destructors are not relevant 
for testing this
28. pekka .test.* m no description of platform-specific tests
29. Pekka .fun.set_new_handler m (guide.tag.internal.form) no _'s in tag
30. Pekka .operator.new C formatting
31. pekka .arch.finish C space -> arena
32. Pekka .arch.finish m explain 'backup allocator'
33. Pekka .files.headers m We need a header file to describe the config variable
34. GavinM .sol.telemetry,.sol.recursion,.sol.aa m These aren't solutions, 
they're problems.
35. GavinM .arch.size m Should describe type and range and whether inclusive or 
exclusive
  Pekka: .arch.size -- the type of the size?
  GavinM: Yes.  I know it's size_t, but this is a design point.
  arch.size is talking about the size of the block plus the header size (not 
documented in design).
  This might have been put in a larger size, but hasn't.
36. GavinM .arch.init m Surely we can make this thread-safe on at least some 
platforms?
37. GavinM .fun.realloc m Surely it is both important and easy to support 
non-moving shrink on many platforms?
38. GavinM .macro q How can we get around this with binary compatability?
39. GavinM .test.smartheap m e/crate/create/
40. GavinM .test.smartheap m a/object/s/
41. PTW req.product nI the product requirements should be more explicit about 
what "drop in" means.  Apparently it means only time improvement is allowed.



Brainstorm start: 16:54
Brainstorm end: 17:56
Brainstorm length: 62


BRAINSTORM:

There were 15 major defects.
A: design.product.soft.drop.manual
A1. PTW .anal.files.configurable.cpp M Is there a danger of name collision if C 
uses binaries containing C++ parts?
  Pekka: .anal.files.configurable.ccp -- even if we use a suitable prefix?
A2. PTW .arch.finish M Why is this issue not discussed in .sol and .anal?
A3. Sheep - M is .sfot.drop.auto assumes that this is a drop in  GC. 
  It's unclear as to what exactly is ment (conflict of clarity)
A4. GavinM .anal.extensions M We will fall down severly if we don't implement 
MM extensions people may rely on, such as msize or stackalloc

B: impl.c.mpsmal
B1. Sheep 131 M in free should the code either init or assert inited ? 
  Same for realloc 
B2. Sheep -,79 M Macros in upper and lower case is confusing ...
B3. Sheep 81 M should we have an assert over negative size 
  GavinM: 7.1.6 says size_t is "unsigned integral type" 
  Sheep: If can never be negative then possibly someone might call malloc ( 0 - 
56 ) or something which would turn into a call for a super large object
  Pekka: That's C for you.
  GavinM: We have already had such a bug with Dylan. 
B4. Sheep 191 M precidance assumpition ? 
B5. Sheep 208 M assert not reached ? 
B6. Pekka 161 M mps_res_t is not guaranteed to be boolean, pointless here anyway
B7. GavinM 78 M "8" should be "CHAR_BIT"
B8. GavinM 136,189 M This check relies on a violation of the interface.
  Checking for a double-free by accessing possibly-freed memory, is a bit 
circular.
B9. PTW 193-206 NM either use malloc/free or mps_alloc/mps_free.  Mixing them 
is confusing and may lead future programmers down a garden path.

C: impl.cpp.mpsnew
C1. PTW 18 M iso96a does not appear to explicitly allow replacment of 
set_new_handler
C2. PTW - nM Presumably the file that is shipped externally needs to be 
massaged to hide detail such as Hope, .readership, .sources, etc. and simply 
have a copyright at the top?

Sheep: I think we need to clarify rules for code which is to be external  as 
well as we define things for internal code. 


A2. PTW .arch.finish M Why is this issue not discussed in .sol and .anal?
GavinM: How did thi shappen, Pekka?
PTW: we still don't have a process for holding "design review"
  This is "formal review" not "design review".  The latter should involve the 
group in a room with a blackboard.  Not that I want to travel a whole lot more, 
but I think there should be such a process for our designs (and have said so ad 
nauseum).
GavinM: Richard is looking into running our first one.
  Nag him about it.
  Maybe we should have a problems section in designs.
PTW: Er, is that not the job of the manager?  And process manager?
GavinM: I have assigned Richard to implement it.
Sheep: I agree we should have a problems sections in design
GavinM: Our design template is hopeless, really.
PTW: By the time the design gets to this level, we should be finding only 
type-ohs and other presentation lacunae
GavinM: Suggest: Have someone analyse existing designs and redo design template
Pekka: I think each design needs its own.
GavinM: Maybe.
Sheep: thumbs up to desgin templete idea

GavinM: Designers need help in getting everything down.
Pekka: The current one is good for single-issue designs, like the bit tables, 
but not for large ones that have more structure to them.
PTW: I think there can be a standard presentation format; once you have buy-in 
from the group as to what is to be presented.
GavinM: We used to have design presentations.
  They were good.
PTW: "We"?
Pekka: GavinM: we could have a checklist on the aspects that you have to 
address in  a design
Sheep: Yes design presentations can help a great deal. 
GavinM: You attended my telemetry presentation.
PTW: nods

GavinM: Pekka, yes.  A second suggestion.  
GavinM: Did you use rule.design at all?
Pekka: yes
  And I did an RFC on the design, didn't I?
GavinM: That's more like a checklist than a ruleset for review.
  Yes.
  Some of my points should have been raised in RFC.
  I didn't spend enough time on it.
Sheep: Suggestion - we need to formalise RCF so that every one responds and 
considers them.
GavinM: Yes.  
Pekka: no
PTW: We never implemented the suggestion that _one_ person in the group be 
assigned to respond to RFC's
GavinM: agreed.  That needs action.


B1. Sheep 131 M in free should the code either init or assert inited ? 
  Same for realloc 
GavinM: realloc calls malloc when it needs to be inited.
Pekka: quite
GavinM: But free, I agree.
Sheep: Well I could only imagine some pathelogical cases.
  It's easy to use an  assert to handle the worst ones with no imact on 
performace
PTW: E.g., an erroneous call to free followed by program exit which tries to 
de-initialize?
  I don't see the process issue here
Pekka: I think I had a reason for not checking, but I can't remember...
Sheep: Well the process imporvovment should be we need clear standards for 
external code as well as internal code
Pekka: should have documented it , if there was one.
PTW: Yes:  always write down what didn't work, so it is not tried again
GavinM: We have standards for external headers.
Pekka: Sheep: No, I don't think that had any effect.
Sheep: do we have stanrdards for sample code ?
Pekka: no
GavinM: Not yet.
  So how could we have avoided this init conflict?
  I mean, how can we avoid this sort of problem?
  The problem is that it would only be provoked by a protocol error.
Pekka: Perhaps I thought that it's enough that mps_free would assert, because 
pool would be invalid.
  I note Tucker queried even the double-free check, so it's not clear whether 
this is a defect.
PTW: But the design calls for MPS to be inited by "first use" of the interface
GavinM: We certainly need a clearer checking policy. 
  This should be part of the design.
Pekka: "first allocation", actually
  GavinM: ye
PTW: Ah.  Still, it seems unfortunate to have the initialization policy so 
diffuse
GavinM: rule.design.error says: The design must document error semantics for 
all functions, and behaviour in abnormal conditions.  It must also document any 
special checking/assertion behaviour.
Pekka: It does.
Sheep: It's generally a C problem - how to init some collection of information
PTW: (I think you have the opportunity in a DLL to use the jump-in table to 
ensure that the module is initialized by the first call to the module.)
GavinM: Hmm.
  I think I would have wondered about that, had I gone over the design with 
rule.design in hand.
PTW: Tension between simplicity and efficiency?
Sheep: One of the problems is the cross  platform nature of the code 
  It's hard to do this on all platforms. 
GavinM: Suggest: Have entry.design based on rule.design.
Pekka: It's not cross-platform, it's ANSI.
PTW: Simplicity would have a call to ensure_inited as the first thing in each 
call
Pekka: That's not one of the requirements.
Sheep: Well then things cannot be simpler than ansi 


B3. Sheep 81 M should we have an assert over negative size 
  GavinM: 7.1.6 says size_t is "unsigned integral type" 
  Sheep: If can never be negative then possibly someone might call malloc ( 0 - 
56 ) or something which would turn into a call for a super large object
  Pekka: That's C for you.
  GavinM: We have already had such a bug with Dylan. 
PTW: My reason for making this high-prio:  it gets questioned over and over
  Do we have a policy on being mathematically precise vs. being pragmatic
GavinM: We have no choice but to use size_t.
  size_t must be unsigned.
  I can see no profit in checking that it's non-negative.
PTW: Pragmatics would say that a request to allocate 1/2 your VM space is an 
error
Pekka: You'd just get a compiler warning.
Sheep: then perhaps have an assert on unfesably loarge objects
PTW: Could have a LARGEST_POSSIBLE_OBJECT, configurable in the interface
GavinM: I tend to agree that our client is very highly unlikely to allocate 
more than half of size_t's range.
  Richard says size_t is signed on Suns.
Pekka: not true
GavinM: Unfortunately, we shouldn't really have restrictions that malloc 
doesn't.
PTW: We do intend to _improve_ malloc
  Otherwise what is our selling point?
Pekka: no
PTW: Do we know what level of improvement we allow/want?
  Relates to my other question about improving free
GavinM: Can we decide to half size_t's range?
Sheep: I belive the debug version should permit more warnings 
PTW: We need marketing input to say what improvements are marketable
  I think the range should be explicit in the interface (configurable).
Pekka: There is no requirement to improve malloc.
PTW: There could be optimizations (e.g., the overflow code in calloc) based on 
the setting.
Pekka: There is a requirement to improve memory allocation.
PTW: There is a requirement to give better performance
  How do we define that?  Elapsed time only?
Pekka: It's a drop-in interface, i.e., exactly the same as malloc.
GavinM: A configurable limit gives no advantage on straight drop-in.
PTW: Less errors?  More error detection?
Sheep: Well I think you did the correct thing. Don't try being better than 
malloc 
Pekka: People wanting more than that use AA, or go to level 2
PTW: A configurable limit will detect program errors where the luser 
incorrectly calculates the size of the object to be allocated.
GavinM: Maybe we need a way to deliver warnings.
Pekka: And so does our current code
  It will mps_assert when it fails to allocate that large segment
GavinM: I don't think we can get away with having an assert that restrict's 
malloc's behaviour below size_t by default.
Pekka: ??
GavinM: drop-in means that we work correctly in all cases where malloc would 
work. 
  We are allowed to work in other cases.  We may be allowed to deliver 
warnings. 
PTW: GavinM: your definition does not preclude better error signalling.  And do 
we intend to be compatible with implementations or abstract definitions?  Do we 
know implementations of malloc that will malloc 1/2 VM?


C1. PTW 18 M iso96a does not appear to explicitly allow replacment of 
set_new_handler
PTW: nI the product requirements should be more explicit about what "drop in" 
means.  Apparently it means only time improvement is allowed.
Pekka: And space
  No functional changes.
PTW: Q: Am I right about C1?
  What is the procedure for addressing such issues?
GavinM: PTW, I'm not sure what you mean.
PTW: We need something iso96a does not address (I think).  Do we have a 
representative to ISO or some other way to redress?
Sheep: ptw we are discuyss things here 
PTW: The larger issue is my improvement suggestion to iso96a.  Do we have a 
process for that?
Sheep: Pekka thinks we are going off at a tangent
Pekka: If it's not allowed, then the problem is that I didn't read the standard 
carefully enough.
GavinM: I don't think we know whether this is a defect.
Pekka: I don't see anything that could be done about that, except
  having somebody else review the code, which we just did.
PTW: I note that for new/delete there is _explicit_ permission to override.
  I don't see how you can implement what you need without overriding 
set_new_handler,
GavinM: I can't see a process imporvement here.
PTW: therefore I claim a defect in the standard
  Suggestion: figure out how to report bugs in iso96a
  We are a stakeholder, but they don't know it
GavinM: Ok.  That's something to do.
Pekka: I looked at the standard and I agree with Tucker.
PTW: Hm.  You could do something gross like call set_new_handler, setting it to 
null to get the current new handler and then reset it, all inside your new...
Pekka: ptw: not thread-safe


GavinM: I think review went unusually slowly today.
Pekka: proc.review.entry.draft says that the status of impl.c.* should have 
been draft.
GavinM: Um, true.
PTW: I could press my buttons faster.  I was trying to allow "read time"
GavinM: Logging was a little disjointed and prone to digression,
PTW: Or were you referring to us not finishin review?
GavinM: But our process brainstorm was very chaotic.
Pekka: That's not a problem as long as the one who's logging doesn't get 
distracted.
GavinM: It's very hard to mediate things by IRC.
PTW: Chaotic?  How so?
Pekka: Yes, pretty useless.
  Not about process improvements.
GavinM: Well, the nomination and selection usually goes far more smoothly.
PTW: I think there was confusion due to 3 docs being reviewed
Sheep: Suggest that we have an open phone line to ptw to handle side issues
GavinM: S'true.
  we used to use phone always.
PTW: There were two missing majors from the nominees, which delayed things
Pekka: I think this is better, because it allows async conversations
GavinM: My fault.
PTW: What would have prevented that?
GavinM: I let myself get distracted into conversation when writing up issues, 
and then got rushed.
Sheep: Well it's async but confusing too both phone and IRC might improve 
bandwith
PTW: Suggest:  Label issues A1, etc. on multi-documents
GavinM: The problem with both is that talkin gisn't logged.
  That worked well when we got onto it.
Sheep: Well talking should be for organsiational  and explinations not logging 
stuff
PTW: Suggest: Implement suggestion to tag issue lines in log so they are easier 
to find
GavinM: PTW, there's a lot of stuff siad here in the Pool Hall that should be 
logged and that you should hear.
PTW: We tried the phone one time, and it was mostly dead air.
  "Put in your earplugs, put on your eyeshades, you know where to put the cork"
Sheep: I think that was when I was also using the phone
GavinM: I had a suggestion that review records be by session, not by document.
Pekka: Tagging like "143 m"?
Sheep: WEe had problems takeing turns
PTW: Tagging like ***
Pekka: I thought they were by session.
Sheep: I'm in the pool hall today to help that
GavinM: Pekka, nope.
Pekka: That's why I asked for all three docs to be reviewed at the same time
PTW: There is enough other variability, especially with new issues (hand typed) 
that the scribe can miss them
Pekka: because many issues would affect all of them
GavinM: PTW, the new issues would have been in the log eventually.
  There's quite a lot of intelligence involved in assembling the issue log. 
PTW: Yes, but you presumably had a hard time finding them for brainstorm 
because they are not distinct enough in the log
GavinM: It would be hard for a robotic logger to help more than it hindered.
  PTW, I simply forgot to even check for them.
Sheep: suggest perhaps having look@me running with a view of the document in 
question
PTW: RE: session vs. document  Session would be simpler for me, but I am not 
sure it is right.
GavinM: Finding them wasn't hard.
  Sheep, interesting.
  We had a per-session log once. 
PTW: Finding:  Ok, whatever.  I would find it easier myself if there were ***'s 
or something
Sheep: That way you don't have too keep scrolling up to read document and then 
back to read peoples comments and talk
GavinM: ... for reviewing 40 web documents at one go.
  It took ages to get out of review.
PTW: Looking: I don't have enough screen real estate to IRC and Look 
simultaneously
GavinM: Easier as a checker?
  I mean, we had a per-session review record once.
PTW: Ah 40 web-docs, per session makes sense
Sheep: well much easyer to flick backwards and forwards
GavinM: It was a lot easier for me as editor.
PTW: I lost the track of this train...



Number of major issues: 4
Number of minor issues: 22
Number of issues: 41

Edit manpower: 5


Edit notes:

1. Reject: This is a misunderstanding.  No danger at all.
2. Reject: The headers are forced on the document by the Notes template.  
Sufficient justification for the solution is given in the same paragraph.  (And 
surely this is not a major defect!)
3. Reject: Doesn't even refer to this document.  Handled as an improvement 
suggestion, and passed to Richard.
4. Reject: No, we won't.  The user gets a clear notification (a linking error 
or an assert).  Most programs don't use complex extensions, anyway.  (BTW, 
_msize is a bad example, because it's simple, and the VC library requires it 
anyway, so it will be provided.)
5. Pass: Richard.
6. Fix: Untypoed.
7. Mail: mail.pekka.1997-10-20.19-52(0)
8. Fix: Reorganised the document so that the thinking is clear.  Emphasized the 
solution chosen in .anal.recursion.
9. Reject: The doc clearly specifies what the size is needed for.
10. Mail: mail.pekka.1997-10-20.19-52(0)
11. Reject: Performance impact as compared to what?
12. Mail: mail.pekka.1997-10-20.19-52(0)
13. Mail: mail.pekka.1997-10-20.19-52(0)
14. Mail: mail.pekka.1997-10-20.19-52(0)
15. Mail: mail.pekka.1997-10-21.09-54(0)
16. Reject: sol.recursion.ann-turnoff was not chosen as the solution.
17. Fix: Test it when doing the C++ config.
18. Reject: Not useful for the drop-in interface.
19. Reject: Irrelevant.
20. Reject: covered by the comment in .sol.extensions.  (This suggestion is on 
the list to be considered.)
21. Reject: As 20.
22. Reject: Untrue: it has undefined behaviours.
23. Pass: Gavin.
24. Pass: Gavin.
25. Fix: Lowercased.
26. Fix: Untypoed.
27. Fix: Removed that phrase.
28. Fix: Added a paragraph.
29. Fix: Substituted hyphens.
30. Fix: Improved formatting.
31. Fix: Changed.
32. Reject: Explained in .sol.recursion.backup.
33. Fix: Noted in .files.headers.
34. Reject: The headers are forced on the document by the Notes template.  The 
meaning and the logic is clear.
35. Fix: Documented.
36. Reject: Yes, we could insert platform-specific locking, but as it says, 
it's unlikely to be a problem.
37. Reject: The document already says this will be investigated.
38. Mail: mail.pekka.1997-10-23.13-12(0)
39. Reject: Verbatim quote.
40. Reject: as 39.
41. Reject: There's a clear functional definition in req.product.fun.malloc and 
req.product.attr.use.level.1.partial.



Exit: exit.universal
