                 MPS C INTERFACE: FUNCTION MPS_SAC_FREE
                       symbol.mps.c.mps_sac_free
                              draft symbol
                            pekka 1999-03-04

NAME

mps_sac_free


SUMMARY

This function frees an object using the segregated allocation cache given.


ASSOCIATED PROTOCOLS

Allocation cache


TYPE

void mps_sac_free(mps_sac_t sac, mps_addr_t p, size_t size);


ARGUMENTS

sac                      the segregated allocation cache
p                        a pointer to the block being freed
size                     the size of the block being freed


RETURNED VALUES

None.


RESOURCES

mps.h


DESCRIPTION

This function frees an object using the cache given.  If the cache would become 
too full, some blocks are returned to the associated pool.  size should be the 
size that was specified when the object was allocated (the cache knows what the 
real size of the block is).  The object must have been allocated through a 
segregated allocation cache with the same class structure, attached to the same 
pool.

The client is responsible for synchronising the access to the cache, but if the 
cache decides to access the pool, the MPS will properly synchronize with any 
other threads that might be accessing the same pool.


EXAMPLE

  void *p;
  Foo *foo;

  res = mps_sac_alloc(&p, sac, FooSIZE, is_in_panic);
  if (res != MPS_RES_OK) {
    printf("Failed to alloc foo!\n"); exit(1);
  }
  foo = p;
  /* use foo */
  mps_sac_free(sac, p, FooSIZE);


SEE ALSO

symbol.mps.c.MPS_SAC_FREE, symbol.mps.c.mps_sac_alloc, 
symbol.mps.c.MPS_SAC_ALLOC, symbol.mps.c.mps_sac_t

NOTES

There's also a macro called MPS_SAC_FREE, that does the same thing.  The macro 
is faster, but generates more code and does less checking.

Usually, you'd use the same cache to allocate and deallocate an object.


