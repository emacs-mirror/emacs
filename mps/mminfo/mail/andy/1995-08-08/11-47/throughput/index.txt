                     MM/EP REQUIREMENTS: THROUGHPUT
                 mail.andy.1995-08-08.11-47.throughput
                            temporary quote
                            andy 1995-08-08

Date: Tue, 8 Aug 1995 11:47:51 +0100
To: richard (Richard Brooksby), luke
From: andy (Andy Cave)
Subject: Re: MM/EP requirements: Throughput
Cc: mm

At 12:41 pm 24/7/95 +0100, Richard Brooksby wrote:
>Tucker asks:
>
>> I don't know whether this is QUAL or FUN, but their throughput constraint
>> seems to imply GC must minimize overhead, essentially that it is
>> anti-incremental.  It waits until the last possible moment to collect
>> (hopefully avoiding collection altogether) and when it does collect, it
>> should utilize all the CPU cycles it can to get the job done quickly.  A
>> question I have is if there is a problem when driving an actual output
>> device where your throughput is dependent not just how many jobs you can
>> RIP but also on keeping the device busy?  I assume that the output device
>> may have some limiting bandwidth?  Or is it always the case that the RIP is
>> the limit?

Sorry for the late reply.

Firstly this is just our (EP's) current expectations given our current
design (and previous ideas for doing GC). If you guys can do it
incrementally and it meets our criteria, then I don't mind what you do.
I've been emphasising this a lot and want to continue doing so.

As you say, throughput is dependant on consistently utilizing 100% of all
the machines resources (disk I/O, cpu, fpu, memory, etc...) to produce
pages to be output as fast as possible. In addition, a large number of our
output devices have to be fed data in real time (and can't stop-start).
i.e. if you don't send data to them in real time, they will simply leave a
blank section on the output page/film.

We therefore need to guarantee that a certain amount of CPU time is
periodically given to our output module (to make more data available to the
interupt routines that are typically used). We currently do this using a
tickle mechanism (tickles (in our code) in the coreRIP will periodically
call outside to the output module).

The areas of memory that will be GC'd (PS VM + general memory) vs the areas
of memory that our output module uses, are (currently) independant areas of
memory, and so we wouldn't mind if you GC'd in the coreRIP world as long as
you still tickled the outside world. In addition, if we're outputting,
we've pretty much stopped doing any memory allocation (certainly if the
coreRIP is involved in the output), and so we wouldn't mind delaying any GC
until the output stops.

Basically we probably do want to disable GC's for certain amounts of time,
unless it's guaranteed to be a fast incremental algorithm (or one that just
runs blindingly fast).

To summarise what I see us needing from the MM group:

 GC needs doing for PS-VM.
 Compaction needs doing for coreRIP memory (includes PS-VM).
 Memory allocation needs doing for GUI + coreRIP

We can talk more about this during this weeks meetings about the spec/design.

_andy.

