              DESCRIPTION OF MPS ALLOCATION POINT PROTOCOL
                        protocol.mps.alloc-point
                             incomplete doc
                             lmb 1997-06-10

.issues.sketchy:  This document needs to be filled out considerably.  I 
hesitate to do that before .issues.outdated is resolved.

.issues.syntax: The syntax of the pseudo-code has not yet been checked.][er, 
it's pseudo-code; what syntax?  drj 1998-10-20]


INTRODUCTION

.intro:  This document describes the protocols which can be used in conjuction 
with MPS allocation points.  Currently there are three protocols: 
reserve/commit allocation, stack discipline, allocation patterns.  
Reserve/commit allocation is intended to be used for fast (in particular lock 
free) allocation of formatted objects.  Stack discipline is intended to be used 
both for the fast freeing of object sets which obey a stack-like discipline and 
for declaring object sets to be mostly dead.  Allocation patterns can be used 
to declare particular idoms of object creation and destruction.  They aren't 
described in this document, but should be.  The "ramp" allocation pattern 
(which is a particular pattern) is described in 
protocol.mps.alloc-pattern-ramp(0).


DEFINITIONS

.def.ap: AP.  An abbreviation for Allocation Point.


CREATING AND DESTROYING

.create: An allocation point is created using mps_ap_create or 
mps_ap_create_v.  mps_ap_create takes a variable number of arguments; 
mps_ap_create_v is just the same as mps_ap_create except with the extra 
arguments passed as a single va_list argument.  The extra arguments are 
interpreted by the pool in a pool class dependent way.

.destroy: An allocation point is destroyed with mps_ap_destroy.  You cannot 
destroy an allocation point that is between reserve and commit.  Note that 
before you destroy a pool (mps_pool_destroy), you should destroy all allocation 
points in it.


USING ALLOCATION POINTS

.use: The client has five options about how to use allocation points:

.use.own.as: Write their own allocation point code in assembler 

.use.own.c: Write their own allocation point code in C 

.use.mps.fn: Use MPS functions 

.use.mps.macro: Use MPS macros 

.use.mps.macro-block: Use MPS block macros

.use.tradeoff: The different options tradeoff convenience for control.  
Client's writing their own assembler get to control (within the limits of the 
protocols) the exact code sequence but they may well have to know how certain 
structures get laid out in C and exactly what sequence of operations the 
protocol consists of.

[in practice currently only .use.mp.fn, .use.mps.macro, .use.mps.macro-block 
are supported.  drj 1998-10-27]

[.decision: Need to give figures for deciding which method to use. 
.conditions: Also need to define the environments and conditions under which 
the developer would want to use one of the five options (e.g., if s/he is using 
threads, then s/he'd want to use Option X). Also, some constraints can be 
relaxed, depending on the environment in which the MPS is being used.
.mem-barriers:  On multiprocessor DEC Alpha systems [see arch.al], memory reads 
and writes can get reordered and so appear out of order on another processor 
(aka "Relaxed Memory Ordering" or "Weak Memory Ordering"), so we have "memory 
barriers" (actually we don't have any barriers yet) that ensure that the code 
is executed in the order _we_ specify. Need to fit this in somewhere.]


TYPE

.type: Allocation points are not abstract data types.  There are some opaque 
aspects and some transparent aspects.  Client programs can know the structure 
and directly modify fields, but must obey certain protocols.

.type.structure: Allocation points have a structure of five words -- abstractly 
referred to as Init, Alloc, Limit, FramePointer, Enabled.

.type.structure.protocol: Not all the fields are used by all of the protocols.

.type.structure.detail: Depending on how the client is using APs (see .use 
above) they may or may not need to know about the details of the structue.  If 
the client is using MPS provided macros then they should not need to know 
anything about the structure for example.


ALLOCATION

.alloc: APs are primarily used to allocate objects:

.alloc.kind: There are four kinds of allocation (not all of these are carefully 
thought out or implemented):

.alloc.reserve-commit-loop: Two-phase allocations with loop [sometimes it's 
more helpful to think of this as 3-phase allocation, splitting commit into 
"update init" and "read limit" phases.  drj 1998-06-15]

.alloc.reserve-commit-linear: Two-phase allocations that are always successful

.alloc.one-phase: One-phase allocations -- Reserve and Commit are done at the 
same time (see below).

.alloc.promise: Promises -- you can ask for a certain amount of memory.  This 
type of allocation only deals with Limit (see below). 

.alloc.class-dependent: The pool classes you are using determine which 
allocation protocols you can use; some pool classes require certain allocation 
protocols.

[We may want to include a discussion of "alloc".  We may do all allocations 
using APs.]

.alloc.speed: In general allocation using APs is intended to be fast.  This is 
achieved by:

.alloc.lock-free: By avoiding locking synchronization.

.alloc.inline: By avoiding function calls.



RESERVE/COMMIT

.reserve-commit: This part of the document describes the reserve/commit 
protocol.



Pseudo-code

.reserve-commit.pseudo-code: The pseudo-code for a reserve/commit sequence on 
an allocation point is as follows:

  do { 
    res = mps_reserve(&p, ap, size);
    if(res != RES_OK) {
      do something;
    }
    else init(p);
  } while (!mps_commit (ap, p, size));


.reserve-commit.reserve: If mps_reserve fails, the client program doesn't get 
the memory it needs.  If it succeeds, the memory is allocated in a block whose 
address is "p".

.reserve-commit.client-init: "init" is code that you write.  The memory has to 
be filled in with a correctly formatted object (the interpretation of 
"correctly formatted" will depend on the pool class used).

.reserve-commit.commit: After initialization, you can do the commit.  The pool 
needs to know that the object has been initialized, and the commit informs the 
pool that the object is ready.  If the commit fails, which should be rare (some 
pool classes may be able to guarantee that it never happens), the memory is not 
allocated and you have to start from scratch.  The code returns TRUE if okay, 
FALSE if it fails.


Pool Class Dependencies

.reserve-commit.pool-class.format: The initialization phase of reserve/commit 
depends on the format of the object being allocated.  Some pool classes may not 
be formatted (perhaps the objects have no references or are scanned 
ambiguously).  In this case the reserve and the commit can be done at the same 
time.

.reserve-commit.pool-class.commit: Some pool classes occasionally need to have 
the commit fail; other pool classes may be able to guarantee that commit will 
never fail.  [This should be specified and explained.  We should also assure 
the user that this is for efficiency's sake (i.e., their own good) and will 
happen very rarely.]


Implementation Details

.reserve-commit.details: A chunk of memory is passed to the client application, 
which can allocate it using the protocol.

Doing a reserve increments Alloc (but not past Limit).

.reserve-commit.reserve.code: Reserve:

  T = Alloc + size;
  if(T > Limit || T <= Alloc)           /* overflow check */ 
    res = mps_ap_fill(&p, ap, size)     /* ask MM to give you a */
                                        /* bigger chunk of memory */ 
  else {
    Alloc = T;
    P = Init;
    res = OK;
  }

Then the client initializes the memory, then commits it:

.reserve-commit.commit.code: Commit:

  Alloc = Init;
  if(Limit = 0)
    b = mps_ap_trip(ap, &p, size)   /* calls MM */ 
  else b = TRUE   /* b = boolean result */

.reserve-commit.check.limit: The MPS can poke Limit to 0 whenever necessary in 
order to regain control, so the commit code has to check that the MPS has not 
done this between the reserve phase and the commit phase. Whenever the MM is 
invoked, it can do whatever it needs to, so the client cannot assume that the 
values of any of the AP's fields will stay the same.

Outside of invoking the MM, Alloc and Init will not change unless the client 
application changes them.  However, Limit can change at any point.  The client 
application is not allowed to change Limit; it can change Alloc and Init as 
long as it follows the protocol.

.reserve-commit.atomic: The updates (writes) and reads of Alloc and Init have 
to be atomic with respect to threads.  This means that the client application 
must read the whole field at once (one instruction in machine code).


Macros and Functions

.reserve-commit.c: The reserve/commit protocol is provided through the MPS C 
interface by the functions:

   mps_reserve
   mps_commit 

and macros:

   MPS_RESERVE
   MPS_COMMIT
   MPS_RESERVE_BLOCK

.reserve-commit.c.macro.side-effects: The difference between macros and 
functions is that macros may evaluate their arguments more than once.  For 
example, the macro MPS_RESERVE(&p, ap, size++) expands into code that may 
contain size++ in more than one location, causing the compiler to evaluate it 
more than once.  Therefore, you should not use side effects in macros.

.reserve-commit.macro.warning.l-values: In the block macro 
MPS_RESERVE_BLOCK(res_var, ptr_var, ap, size), the variables have to be 
l-values -- that is, things that values can be assigned to -- because the 
compiler handles variables better than pointers.


STACK DISCIPLINE

.stack: This part of the document describes the stack discipline protocol.

.stack.what: Stack discipline is a means by which object lifetimes can be 
declared to observe a stack-like behaviour.  By stack-like behaviour we mean 
that if a particular object is dead then all objects allocated since that 
object are dead as well (so one can imagine managing the objects using a 
stack).  In fact the protocol can be less strict about the liveness of the 
objects; it can be used to mean that all the objects allocated since a 
particular object are _likely_ to be dead rather than actually are dead.  Which 
of these two interpretations is used depends on the pool class involved.

.stack.frames: All APs have a stack of frames associated with them (if the 
function used in this protocol are not used then it isn't necessary to consider 
this stack of frames).  .stack.frames.inde: The stacks belonging to each AP are 
independent of each other.  .stack.frames.order: The frames in a stack are 
arranged in a partial order with a parent/child relationship (the stack frames 
form a tree).

.stack.frame.what: A frame is used to group a set of objects together.  The 
ordering of frames (see .stack.frames.order) provides a larger grouping.  
.stack.frame.why: The chief purpose of frames is so that a set of objects can 
be declared dead at once (so it provides a kind of mass free interface).

.stack.frame.current: Every AP has a current frame.  .stack.frame.current.top: 
Some pool classes may restrict the current frame to be the (unique) frame with 
no child (see the push operation below, .stack.frame.push), in this case the 
stack frames form a linear order.  .stack.frame.current.any: Other pool classes 
may allow the current frame to be selected from any of the frames in the 
stack.  .stack.frame.alloc: Objects that are allocated in an AP are allocated 
in the current frame.

.stack.frame.init: Initially, when APs are created they have a single frame; it 
is the current frame; this frame cannot be popped (see below).

.stack.frame.push: Stack frames are created and linked into the ordered tree 
with a push operation.  This create a new frame and makes it a child of the 
current frame; the newly created frame becomes the current frame  (Note that as 
observed above, .stack.frame.current.top, if the current frame always has no 
children then a linear ordering of the frames is formed).  The previously 
current frame is still valid and its objects are still alive.

.stack.frame.pop: The pop operation pops the stack back to a specified frame.  
The specified frame and all its descendents (ie its children and all their 
children transitively) become invalid; the objects in those frames are dead.  
If the frames form a linear order then the descendents of a particular frame 
are all the frames pushed since that one.  Actually the meaning associated with 
the objects in the frames is pool class dependent.  Some pool classes will use 
the pop operation to mean that all the denoted objects are dead and their 
storage space may be reclaimed; other pool classes use the pop operation to 
that the denoted objects are mostly dead (they are likely to be good candidates 
for garbage collection).  Consult the pool class documentation for details.


Implementation

.stack.c: The push and pop operations are provided in the MPS C interface in 
the form of the functions:

mps_ap_frame_push
mps_ap_frame_pop

[more documentation on select frame, frame of addr, &c  drj 1998-10-20]


ALIGNMENT

[this really belongs in some other document -- drj 1998-10-20]

.alignment.background: Some processors require that you align accesses to 
memory; others just work better if you do.  For example, a double precision 
floating point number on many architectures must be aligned on a double 
boundary (that is, its address must be a multiple of 8).  Alignments of eight 
bytes mean the last three bits are 0, etc.

.alignment.pool-class: As a consequence of this, every pool has an alignment.  
If the pool alignment is eight bytes, then all allocated objects must be eight 
bytes.  If a six-byte object is allocated, two bytes are wasted.  A pool's 
alignment is should be available to the client through the interface, but is 
not [this is probably a bug -- drj 1998-10-20].  Often this does not matter as 
for many pool classes clients can specify the pool's alignment when creating it 
(but crucially not for Pool Class MV).

.alignment.platform: MPS_PF_ALIGN is a C preprocessor symbol defined in mpstd.h 
which defines the MPS's notion of the platform alignment.  The platform 
alignment is the least common multiple (since we assume all alignments are 
powers of 2 this is the maximum) of all alignments on that platform.  If 
objects are allocated at platform alignment, generally everything is allocated 
with no problems, but a lot of space may be wasted.

.alignment.rounding: If the client application allocates memory using an 
allocation function, the function sorts everything out for it.  If it is using 
reserve and commit, it has to round allocations up to the pool alignment.  
Alloc and Init always need the correct alignment -- if the pool size is four 
bytes, then the size variable must be four bytes.


SUMMARY OF RESTRICTIONS

* You have to initialize memory if you are using formatted pool classes.

* You cannot assume that the values of Alloc and Init will remain the same if 
you invoke the MM.

* You cannot assume that the value of Limit will ever remain the same; you have 
to check it before using it.

* You cannot change the value of Limit yourself.




