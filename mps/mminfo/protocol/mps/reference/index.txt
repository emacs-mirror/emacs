                         REFERENCES IN THE MPS
                         protocol.mps.reference
                             incomplete doc
                             drj 1998-08-27

INTRODUCTION

.intro: References are crucial to (automatic) memory management.  They are the 
means by which objects refer to each other.


CREATION

.create: References are in two ways; by creating objects or roots containing 
references, or by allocating an object (which creates a reference to the object 
allocated).


DESTRUCTION

.destroy: References are not destroyed explicitly; they are destroyed whenever 
objects or roots containing references are destroyed or whever references 
contained in objects or roots are overwritten by the mutator or the memory 
manager (which can only happen in certain restricted circumstances.


TYPES

[See also guide.mps.pool-classes:prop.ref.* and guide.mps.pool-classes
:prop.rank.* which has a more structured explanation of the differences between 
the types of reference  drj 1998-09-02]

.type: There are three types of reference:

.type.exact: Exact references.  These are the usual sort of reference.  The 
value is definitely a reference to an object (compare with Ambiguous Reference 
below) and the client wishes that the reference continue to the refer to the 
object as long as the objects remains alive (compare with Weak Reference 
below).  The MPS is allowed to change the address represented by the reference 
in order that the object being referred to can be moved.

.type.ambig: Ambiguous references.  Bit of a misnomer because it may not 
actually be a reference.  This is a value which may or may not be a reference 
to an object and the memory manager has no way to determine which is the case.  
This presents some interesting implications for the memory manager: chiefly 
that if the representation of an ambiguous reference looks like a genuine 
reference to an object then it must be treated as a reference to the object (so 
will cause the object to be preserved if the ambigous reference is itself 
reachable), but the ambiguous reference cannot be changed (because to do so if 
the value was not a reference would be catastrophic), so the object referred to 
cannot be moved.

.type.weak: Weak references.  A weak reference is a reference to an object 
which does not cause the object to be preserved.  As long as the object remains 
alive the weak reference will refer to it.  But when the object is no longer 
reachable from the root via a chain of exact or ambiguous references then the 
memory manager may replace all weak references to the object with some value 
which is not a reference to the object.  Just as for exact references, the MPS 
is allowed to change the address represented by the reference.

Denotation

.type.denote: Typically in the MPS where an explicit distinction between the 
types of reference is required, the types of reference are denoted using 
Ranks.  There is a rank for each of the types of reference described above.  In 
the MPS C Interface they are mps_rank_ambig() (see symbol.mps.c.mps_rank_ambig) 
for Ambiguous References, mps_rank_exact() (see symbol.mps.c.mps_rank_exact) 
for Exact References, mps_rank_weak() (see symbol.mps.c.mps_rank_weak) for Weak 
References.


REPRESENTATION

.represent.overview: The client can store references in whatever format they 
like as long as:
- All the bits which participate in the representation of a reference in an 
object X reside entirely within the boundaries of the object X [this somewhat 
reasonable - though violated by ScriptWorks - condition is necessary to make 
barriers work simply drj 1998-08-28].
- References are converted to and from void * C pointers whenever communicating 
them through the MPS C interface.


ASSOCIATED PROTOCOLS

Scanning

Fixing

Object Allocation

Tricky issues here.  When is an exact reference valid?  When do they come into 
existence?  What if mps_commit fails, what happens to the "reference" that the 
mutator thought they had?



