                  DESCRIPTION OF THE MPS ROOT PROTOCOL
                           protocol.mps.root
                             incomplete doc
                            pekka 1997-09-22

INTRODUCTION

.intro.doc: This document describes the MPS root protocol.  This is used to 
tell the garbage collector where to start tracing.  The protocol gives the 
client application a high degree of freedom in how organize its static data and 
references between static and dynamic data.

[This document needs some editing for style and consistency.  Pekka 1997-09-22]


OVERVIEW

.over.gc: We'd like garbage collection to keep only live objects and reclaim 
all the dead ones.  However, it is theoretically impossible for the GC to 
determine which objects are live and which are dead.  Instead, the GC 
determines which objects are reachable from _the roots_, and reclaims the 
unreachable ones.  This is quite efficient and can be a very good approximation 
to liveness.

.over.root: Note that it is important the roots contain everything that the 
program can directly refer to, otherwise the GC might recycle an object that 
would be used in the future.  Some GCs, like Boehm's, assume that all static 
data are roots; the MPS allows the programmer to declare which objects are 
roots.  If you're using an automatically managed pool class, then you've got to 
declare roots.

.root.reg: In one sense, the only roots are registers; that is, a program can 
only use values that can be referenced from the registers.

[@@@@ diagram of how all values can be referenced from registers]

.root.reg.prob: This is the logical way of thinking about the problem; however, 
the practice is much more tricky.  For example, it requires complete knowledge 
of the layout of static data.  Another difficulty is that a multi-threaded 
program has multiple sets of registers that the OS kernel keeps track of, and 
that the GC, running as a user program, can't access.

.root.specify: It isn't possible to do this in practice; the client program has 
to tell the GC what the roots are, and to be conservative in determining them.

[@@@@ diagram of practical example]

.root.stack: The MPS assumes nothing about stacks being roots.  The client has 
to create a root from the stack, if necessary.  .root.var: Global variables 
that might refer to automatically managed objects must be declared to the MPS.  
.root.other: There might be other roots, as well.  [In the future, we might 
provide a Boehm layer, which assumes that everything is a root.]


DECLARING ROOTS

.declare: You can declare a root at any time.  Roots may not be declared twice, 
and no two roots may overlap.  You must not declare an object that could get 
GCed to be a root.  Everything in a root is of the same rank (like in an 
object).  Declaring a root creates a root object that the MPS uses to keep 
track of the root.

.modes: Roots have modes that are set when declaring the root; these are 
additional information about the behaviour of the root.

.remove: Roots can be removed at any time by passing the root object to 
mps_root_destroy [C-specific!].  All roots must be destroyed before the arena 
is destroyed.

.valid: If the rank of the root is not ambiguous, the contents of the root have 
to be valid whenever a GC happens, i.e., they have to be references to actual 
objects or null pointers.  If you're using asynchronous GC, this could be right 
after the root is registered, so the root has to be valid when it is registered
.  It's OK for a root to have entries which point to memory not managed by the 
MPS -- they will simply be ignored.

.kind: You can declare roots in four different ways [this section needs to be 
rewritten in a language-independent way, but with xrefs to symbol doc]:

.kind.table: mps_root_create_table & mps_root_create_table_masked declare a 
root that is a vector of pointers somewhere in memory.

.kind.reg: Threads are declared roots using mps_root_create_reg.  
mps_stack_scan_ambig is the only supported scanning function: it will scan 
every word on the stack and in the (integer) registers.  It's OS- and 
architecture-dependent (and possibly compiler-dependent).  MM provide it, 'cos 
it's hard to write and hard to specify an interface for it.

.kind.format: mps_root_create_fmt declares a root that is a block of formatted 
objects.

.kind.general: mps_root_create declares a root that consists of all the 
references indicated by a scanning function that you supply.


NOTES ON OPTIMIZING COMPILERS

.optimizing.problem: Optimizing compilers might optimize stores away, so that 
references that have notionally been stored, in fact only exist in the thread 
state.  Registering the thread will ensure these will be scanned.

.optimizing.no-stack: It's not always necessary to register every thread.  For 
example, in C, if you take the address of a variable then the compiler is 
constrained to keep the variable up to date under certain circumstances.  
However, you have to be _very_ careful.  If you're using incremental GC, then 
the MPS might look at things when the compiler didn't expect, and things will 
go wrong.  When using incremental GC, you almost certainly must declare thread 
state as a root.

.non-incremental: Non-incremental GC will occur during a function call to the 
MM (e.g. on request, or during allocation, etc.).  So C knows to store things 
in addressed variables during those calls, so you can deal with it.

.virtual-machine: For example, a common C virtual machine declares a 
stack-within-stack of roots.  e.g.,


  struct stack_frame {val *next, locals[N];};
  struct stack_frame *sp;


  main()
  {
    ...
    mps_root_create_table(..., &sp);
    ...
  }


  foo(...)
  {
    struct stack_frame frame;
    frame.next = sp;
    sp = &frame;
    /* Do stuff using locals.  A GC can safely happen because sp points
     * at frame, so the compiler must write local values back to the frame
     * before any side-effect can happen.
     */
    sp = frame.next;
  }


This sort of thing is safe, so you can do without scanning the real processor 
state.  You only need the VM state.  This isn't terribly good for ordinary 
programming, but is fine for a virtual machine which is the output of a 
compiler, for example.  In ordinary programming, you'll want to include the 
processor state for convenience.  It helps the compiler optimise, and it's 
necessary for asynchronous MM operation, such as incremental GC.

