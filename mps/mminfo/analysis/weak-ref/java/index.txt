    AN ANALYSIS OF WEAK REFERENCES (AND RELATED ISSUES) IN JAVA 1.2
                         analysis.weak-ref.java
                             incomplete doc
                             drj 1999-02-12

INTRODUCTION

.intro: This document analyses the implications of week references and related 
issues in Java 1.2.  Primarily this relates to the Java class java.lang.ref 
(and its subclasses), the Java class java.lang.ref.ReferenceQueue, and the Java 
finalization mechanism [and also java.util.WeakHashMap drj 1999-02-12].  

.source: This document arises from some discussions which took place in The 
Enchanted Garden on 1999-02-11/1999-02-12 between <drj>, <pekka>, and <tony>.

.readership: This document should be readable by anyone familiar with some MPS 
terminalogy.


OVERVIEW

.overview: The semantics of the Java 1.2 specification are unclear, the 
documentation is poorly worded, and the intention isn't clear.  This is a 
problem because if we are to implement this functionality using the MPS then it 
should at least be clear what we are trying to implement and it would be 
beneficial if the semantics were such that they are easily implementable in the 
MPS framework.

.spec: The relevant specifications are available on the web: <URL: 
http://java.sun.com/products/jdk/1.2/docs/api/overview-summary.html >

.spec.finalize:  The following is a excerpted from <URL: 
http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html#finalize() 
> on 1999-02-12.  It's about the finalize method on the java.lang.Object class.

<QUOTE>

finalize


protected void finalize()
                 throws Throwable


Called by the garbage collector on an object when garbage collection determines 
that there are no more references to the object. A subclass overrides the 
finalize method to dispose of system resources or to perform other cleanup. 

The general contract of finalize is that it is invoked if and when the JavaTM 
virtual machine has determined that there is no longer any means by which this 
object can be accessed by any thread that has not yet died, except as a result 
of an action taken by the finalization of some other object or class which is 
ready to be finalized. The finalize method may take any action, including 
making this object available again to other threads; the usual purpose of 
finalize, however, is to perform cleanup actions before the object is 
irrevocably discarded. For example, the finalize method for an object that 
represents an input/output connection might perform explicit I/O transactions 
to break the connection before the object is permanently discarded. 

The finalize method of class Object performs no special action; it simply 
returns normally. Subclasses of Object may override this definition. 

The Java programming language does not guarantee which thread will invoke the 
finalize method for any given object. It is guaranteed, however, that the 
thread that invokes finalize will not be holding any user-visible 
synchronization locks when finalize is invoked. If an uncaught exception is 
thrown by the finalize method, the exception is ignored and finalization of 
that object terminates. 

After the finalize method has been invoked for an object, no further action is 
taken until the Java virtual machine has again determined that there is no 
longer any means by which this object can be accessed by any thread that has 
not yet died, including possible actions by other objects or classes which are 
ready to be finalized, at which point the object may be discarded. 

The finalize method is never invoked more than once by a Java virtual machine 
for any given object. 

Any exception thrown by the finalize method causes the finalization of this 
object to be halted, but is otherwise ignored.

</QUOTE>

.spec.java.lang.ref: The following is from <URL: 
http://java.sun.com/products/jdk/1.2/docs/api/java/lang/ref/package-summary.html
 >

<QUOTE>

Overview  Package Class Use Tree Deprecated Index Help Java Platform 1.2
 PREV PACKAGE   NEXT PACKAGEFRAMES    NO FRAMES
------------------------------------------------------------------------


Package java.lang.ref 

Provides reference-object classes, which support a limited degree of 
interaction with the garbage collector. 

See: 
          Description 

Class SummaryPhantomReferencePhantom reference objects, which are enqueued 
after the collector determines that their referents may otherwise be 
reclaimed.ReferenceAbstract base class for reference 
objects.ReferenceQueueReference queues, to which registered reference objects 
are appended by the garbage collector after the appropriate reachability 
changes are detected.SoftReferenceSoft reference objects, which are cleared at 
the discretion of the garbage collector in response to memory 
demand.WeakReferenceWeak reference objects, which do not prevent their 
referents from being made finalizable, finalized, and then reclaimed.  



Package java.lang.ref Description 

Provides reference-object classes, which support a limited degree of 
interaction with the garbage collector. A program may use a reference object to 
maintain a reference to some other object in such a way that the latter object 
may still be reclaimed by the collector. A program may also arrange to be 
notified some time after the collector has determined that the reachability of 
a given object has changed. 

Package Specification

A reference object encapsulates a reference to some other object so that the 
reference itself may be examined and manipulated like any other object. Three 
types of reference objects are provided, each weaker than the last: soft, weak, 
and phantom. Each type corresponds to a different level of reachability, as 
defined below. Soft references are for implementing memory-sensitive caches, 
weak references are for implementing canonicalizing mappings that do not 
prevent their keys (or values) from being reclaimed, and phantom references are 
for scheduling pre-mortem cleanup actions in a more flexible way than is 
possible with the Java finalization mechanism. 

Each reference-object type is implemented by a subclass of the abstract base 
Reference class. An instance of one of these subclasses encapsulates a single 
reference to a particular object, called the referent. Every reference object 
provides methods for getting and clearing the reference. Aside from the 
clearing operation reference objects are otherwise immutable, so no set 
operation is provided. A program may further subclass these subclasses, adding 
whatever fields and methods are required for its purposes, or it may use these 
subclasses without change. 

Notification

A program may request to be notified of changes in an object's reachability by 
registering an appropriate reference object with a reference queue at the time 
the reference object is created. Some time after the garbage collector 
determines that the reachability of the referent has changed to the value 
corresponding to the type of the reference, it will add the reference to the 
associated queue. At this point, the reference is considered to be enqueued. 
The program may remove references from a queue either by polling or by blocking 
until a reference becomes available. Reference queues are implemented by the 
ReferenceQueue class. 

The relationship between a registered reference object and its queue is 
one-sided. That is, a queue does not keep track of the references that are 
registered with it. If a registered reference becomes unreachable itself, then 
it will never be enqueued. It is the responsibility of the program using 
reference objects to ensure that the objects remain reachable for as long as 
the program is interested in their referents. 

While some programs will choose to dedicate a thread to removing reference 
objects from one or more queues and processing them, this is by no means 
necessary. A tactic that often works well is to examine a reference queue in 
the course of performing some other fairly-frequent action. For example, a 
hashtable that uses weak references to implement weak keys could poll its 
reference queue each time the table is accessed. This is how the WeakHashMap 
class works. Because the ReferenceQueue.poll method simply checks an internal 
data structure, this check will add little overhead to the hashtable access 
methods. 

Automatically-cleared references

Soft and weak references are automatically cleared by the collector before 
being added to the queues with which they are registered, if any. Therefore 
soft and weak references need not be registered with a queue in order to be 
useful, while phantom references do. An object that is reachable via phantom 
references will remain so until all such references are cleared or themselves 
become unreachable. 

Reachability

Going from strongest to weakest, the different levels of reachability reflect 
the life cycle of an object. They are operationally defined as follows: 

•An object is strongly reachable if it can be reached by some thread without 
traversing any reference objects. A newly-created object is strongly reachable 
by the thread that created it.

•An object is softly reachable if it is not strongly reachable but can be 
reached by traversing a soft reference.

•An object is weakly reachable if it is neither strongly nor softly reachable 
but can be reached by traversing a weak reference. When the weak references to 
a weakly-reachable object are cleared, the object becomes eligible for 
finalization.

•An object is phantom reachable if it is neither strongly, softly, nor weakly 
reachable, it has been finalized, and some phantom reference refers to it.

•Finally, an object is unreachable, and therefore eligible for reclamation, 
when it is not reachable in any of the above ways. 


Since: 

JDK1.2 


------------------------------------------------------------------------
Overview  Package Class Use Tree Deprecated Index Help Java Platform 1.2
 PREV PACKAGE   NEXT PACKAGEFRAMES    NO FRAMES
------------------------------------------------------------------------
Submit a bug or feature Version 1.2 of Java Platform API Specification
Java is a trademark or registered trademark of Sun Microsystems, Inc. in the US 
and other countries.
Copyright 1993-1998 Sun Microsystems, Inc. 901 San Antonio Road,
Palo Alto, California, 94303, U.S.A. All Rights Reserved. 

</QUOTE>

.spec.java.util.weakhashmap: The following is from <URL: 
http://java.sun.com/products/jdk/1.2/docs/api/java/util/WeakHashMap.html >:

<QUOTE>

Overview Package  Class Use Tree Deprecated Index Help Java Platform 1.2
 PREV CLASS   NEXT CLASSFRAMES    NO FRAMESSUMMARY:  INNER | FIELD | CONSTR
 | METHODDETAIL:  FIELD | CONSTR | METHOD
------------------------------------------------------------------------


java.util 
Class WeakHashMap


java.lang.Object
  |
  +--java.util.AbstractMap
        |
        +--java.util.WeakHashMap




------------------------------------------------------------------------


public class WeakHashMap
extends AbstractMap
implements Map


A hashtable-based Map implementation with weak keys. An entry in a WeakHashMap 
will automatically be removed when its key is no longer in ordinary use. More 
precisely, the presence of a mapping for a given key will not prevent the key 
from being discarded by the garbage collector, that is, made finalizable, 
finalized, and then reclaimed. When a key has been discarded its entry is 
effectively removed from the map, so this class behaves somewhat differently 
than other Map implementations. 

</QUOTE>


.problem.final.phantom.useless: The specification of Phantom and finalize are 
in contradiction.  .spec.finalize says "Called by the garbage collector on an 
object when garbage collection determines that there are no more references to 
the object", .spec.java.lang.ref says (in the "Reachability" section) "An 
object is phantom reachable if it is neither strongly, softly, nor weakly 
reachable, it has been finalized, and some phantom reference refers to it.".  
Strictly, the texts aren't in contradiction, but mean that no object directly 
referenced by a phantom object can become finalizable (because there are still 
references to the object) and because it won't be finalized, it will never 
become phantom reachable (hence the phantom reference will never get 
enqueued).  In fact, the object may be unreachable by a strict interpretation, 
see .problem.final.phantom.unreachable (below).

.problem.final.phantom.unreachable: Objects that are registered for 
finalization and also referenced by a phantom reference may be unexpectedly 
unreachable.  Consider an object A that has a finalizer (member of a class with 
a non-trivial finalize() method), has not been finalized, and would otherwise 
be phantom reachable if it had been finalized (ie A is directly referred to by 
a phantom reference, and that phantom reference is reachable (strongly 
reachable say)).  The reachability clause from .spec.java.lang.ref would have 
this object be unreachable.  This is problematic.  The object is unreachable 
("and therefore eligible for reclamation") before it has been finalized and 
while it is still reference by a phantom reference.

.problem.phantom.not: Consider an object A that is only reachable by traversing 
a phantom reference but is not directly referenced by a phantom reference (see 
diagram .problem.phantom.not.diagram below).  Because this object is none of 
strongly-, softly-, or weakly-reachable it must be phantom reachable or 
unreachable.  It can't be phantom reachable because it isn't referenced by a 
phantom reference.  So it must be unreachable.  This is clearly problematic.  
(And also contradicts the statement in the section "Automatically-cleared 
references")

.problem.phantom.not.diagram:
R denotes a root.  P denotes a phantom reference.

.-----.   .-----. P .-----.
|  R  |-->|  C  |-->|  A  |
`-----'   `-----'   `-----'
          Phantom

.problem.queue.live.unclear: There is clearly an implicit reference from a 
java.lang.ref.Reference object to the queue that the reference is registered 
with.  It is unclear what the status of this implicit reference is.  For 
example, if the queue is otherwise unreachable should a reachable 
java.lang.ref.Reference object keep the queue alive?  When a queue's finalizer 
is run what can the programmer expect with regard to java.lang.ref.Reference 
objects registered with the queue?  Should java.lanf.ref.Reference objects 
which become enqueueable (their referent changes its reachability 
appropriately) between the queue becoming finalizable and the queue's finalizer 
being run be found on the queue?

.problem.weakhashmap.when: It isn't clear when the references to keys in a 
WeakHashMap (a java.util.WeakHashMap object) are deleted.  From the opening 
paragraph of .spec.java.util.weakhashmap we might infer that a key that 
references an object is deleted eaxctly when the object is reclaimed; possibly 
not even then.  The name and the comment in the 3rd paragraph of the 
"Notification" section of .spec.java.lang.ref suggest that the keys in a 
WeakHashMap are referred to using java.lang.ref.WeakReference objects; if that 
were the case then the references would be cleared sooner (namely, before the 
referent was finalised).

