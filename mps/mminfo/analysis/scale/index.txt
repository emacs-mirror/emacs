      ANALYSIS OF SCALEABILITY PROBLEM IN MEMORY MANAGEMENT GROUP
                             analysis.scale
                             incomplete doc
                           gavinm 1996-07-02

INTRODUCTION

.intro: The Memory Management Group has survived so far with informal 
processes, and information kept in people's heads; much of this depends on 
Richard.  This system (and Richard) is beginning to fray at the edges and will 
become less efficient as the group grows.  Additionally, as our customer base 
grows, not only must we grow with it, but our processes must grow more 
sophisticated.

.purpose: This document analyses some of the problems currently encountered and 
anticipated and possible solutions.


GOALS

.goal.grow: The group needs to be able to grow in order to:

  .goal.grow.req: - add new requirements.

  .goal.grow.proj: - add new projects.

.goal.global: We must become a global development group.

.goal.risk: We must minimise any risks involved.

DEFINITIONS

.def.productive: Able to perform tasks in a time and to a quality comparable 
(>=75%) with the group average, as judged by the group manager.

.def.induction: The education a new person needs to be a productive group 
member.

REQUIREMENTS

.req: The following requirements are hard to quantify, being maximisations and 
minimisations of various things.  For the purposes of the solution impact 
analysis below,
I have made quantitative estimates; these should not be taken to imply either a 
budget or substantial prior research.

Functional (Benefit)

.req.location: Developers must be productive (see .def.productive) wherever 
they are.

.req.quantity: The group must be productive in proportion to the man-power.  
Personal productivity must not be adversely affected by size of group.   
Developers must not spend too much extra time on communication.  [Need metric!]

Quality (Benefit)

.req.productive: A new person should be productive (see .def.productive) within 
one elapsed month (from the current three months, a reduction of about 50 days).

.req.delay: We must reduce the current expected delay on any release resulting 
from the addition of new people from five days to zero.

.req.induction: Induction (see .def.induction) should cost no more than one 
man-week of effort per person from existing group members (from the current 
three man-weeks, a reduction of 10 man-days).

Resource (Cost)

.req.travel: The travel budget (ref?) may not be exceeded (consider a budget of 
$20k p.a., a one week trip from England to the US costing $1k).

.req.setup: The work involved in implementing the solutions should not take 
more than 50 man-days.

.req.maintain: The work involved in maintaining the solutions should not take 
more than 20 man-days p.a.


SOLUTION IDEAS

.idea.visit: New people could visit an existing location (e.g. Cambridge, UK) 
for their initial training period.

.idea.division: We could make the group's work more divisible, so that people 
can work on independant areas with less knock-on effect (see 
.idea.doc.dependency).  [Is this a requirement?]  Remote developers need 
complete problems which they must solve to "fit in" [define?].

.idea.contingency: We could allow for induction and ongoing costs in our plans.

.idea.plan: We could have more visible and more organised planning so that 
developers know who's supposed to be doing what.

.idea.trainer: We could have a person (or people) designated as a trainer whose 
other tasks are not critical path.

.idea.training: We could have a proper training course composed of 
presentations (see .idea.visit) and special documentation.  New people could 
spend two days in a room with a person who already has core knowledge, using a 
white board, pens and source code printouts.  This should not be too detailed.

.idea.feedback: We could create a procedure for getting feedback from new 
people (and existing people) about how they find induction, and working 
split-site and with large teams.  This could involve survey questions or 
personal discussion.

.idea.test: We could test new people on their acquired understanding of our 
code, principles, etc.  This could be a written exam or an oral test.  
Alternatively, we could set a task and review the result, or we could make them 
a review checker and examine the issues logged (see. idea.review.new).  This 
avoids new people failing to grasp central concepts and jumping in the deep end 
without understanding the framework.

.idea.review.new: We should review the work of new people carefully (e.g. with 
higher sampling rates) and early.  It is important for their confidence that 
they participate in review as a checker  before any work of their own is 
reviewed.

.idea.review.learn: Reviews are a good way for everyone to learn about code and 
code changes.  The number of checkers is limited to about six (Gilb).  We could 
plan review participation carefully.  See .idea.doc.change.

.idea.coarse-change: We could make changes to the trunk coarse enough to be 
communicated clearly.  See .idea.doc.change.

.idea.doc: There are various ways in which documention could be improved; we 
need ot identify key knowledge.

.idea.doc.change: We could make the preparation of a short "change document" 
part of presenting a document for review.  Not only does this document form 
part of the set of product documents, but it is distributed throughout the 
group so that people not involved with the review can be kept up to date with 
changes (see .idea.review.learn).

.idea.doc.glossary: We could create and maintain a glossary (see glossary) 
where key terms and concepts can be gathered.

.idea.doc.process: We could document our process and procedures more with 
justifications.  This would help people do things, understand why things are 
done, and avoid omitting vital steps.

.idea.doc.principle: We could document our principles.

.idea.doc.history: We could document the design history and analytical 
background.

.idea.doc.general: We could document how to use and how we use the various 
tools, e.g. Hope, Spring.

.idea.doc.code: We could have more source code documentation to help people 
make good changes.

.idea.doc.infosys: We could document how to use our Information System, in 
particular how to find information on things.

.idea.doc.system: We could document a system for making good changes.

.idea.doc.dependency: We could create and maintain better documentation of 
dependencies within the code so that new people don't make bad changes which 
cause knock-on effects.

.idea.pre-req: We could enforce pre-requisites for new people such as coding 
competence and self-motivation.  Knowledge of memory management should not be 
necessary.

.idea.mature: We could restrict ourselves to hiring only new people who are 
mature software engineers, with at least two years' experience.  [Not yet 
analysed]

.idea.knowledge:  We could restrict ourselves to hiring only new people who are 
already knowledgeable about memory management.  [Not yet analysed]

.idea.travel: We could have a procedure whereby people travel about a lot.  Or 
Richard could travel about a lot, meeting everyone bi-monthly.  This would 
avoid discouragement and improve exchange of ideas.  It would allow Richard to 
share his vision.

.idea.central: Certain types of work could be co-located (e.g. prototyping, 
rapid development); this should not discourage remote development.

.idea.top-down: We could make sure that people are well-educated before we set 
them loose.

.idea.bottom-up: We could set new people tasks to perform, support by 
documentation, and acknowledge that the tasks will consequently take longer.

.idea.seed: Always take someone on at a location where there is someone with at 
least a year's experience in the MM Group.  (Negative impact on distribution.  
How do we branch out to a new site?)

.idea.limit: Place an upper limit on the number of people who can work on the 
core system in order to limit the rate of change.  (How many people can work on 
the core system?)

.idea.meeting: The group meets up for a weekly meeting, possibly in several 
teams or by telephone.

.idea.report: Everybody writes a weekly report detailing progress, problems and 
future.


IMPACT ANALYSIS

 - SCALE.CWK 


RECOMMENDATIONS

.rec: I have classified the fourteen top recommendations from this analysis 
into three groups.

.rec.primary: The primary recommendations are .idea.contingency, 
.idea.review.learn, and .idea.limit.

.rec.secondary: The secondary recommendations are .idea.review.new and 
.idea.doc.glossary.

.rec.tertiary: The tertiary recommendations are .idea.visit, .idea.plan, 
.idea.trainer, .idea.feedback, .idea.coarse-change, .idea.doc.principle, 
.idea.doc.infosys, .idea.central, and .idea.seed.

.rec.benefit: All benefits are covered.  Note that .req.induction, however, 
doesn't have the recommended factor of two coverage; .idea.bottom-up and 
.idea.division are strong in this requirement, but were rejected because of 
high cost.

.rec.costs: Only .req.setup exceeds the planned costs, but by less than a 
factor of two; this is a one-off cost.  The other two cost requirements are not 
below the recommended factor of two, however, and it might be better to reject 
some of the high cost ideas such as .idea.doc.principle, .idea.trainer, and 
.idea.plan, or seek lower cost alternatives.

.rec.intuition: I was surprised to find .idea.travel and idea.meeting among the 
rejected ideas, both for high cost.  Travel would seem to require a net benefit 
of two man-days per one-week trip; are we modelling this accurately?  Team 
meeting seems beneficial in spreading ideas and solving problems, but they do 
absorb a lot of time, and their benefit drops off with multiple locations.


RISKS

.risk.flexible: There are risks from implementing .idea.contingency and 
.idea.limit in that they constrain our flexibility and responsiveness.  Why 
were these attributes not modelled by our requirements?

.risk.plan: There are risks in leaving planning to a late delivery stage 
because, without planning, there is little confidence in any of our risk 
management.  Why was this not modelled?

.risk.req: Scaleability is a slightly odd concept to judge process improvement 
against.  It seems possible that it may have skewed our requirements.  Compare 
with analysis.process.


COST

.cost: This analysis took GavinM 3 days (approx.) and Richard 1 day (approx.): 
4 man-days

ATTACHMENT
   "SCALE.CWK"

