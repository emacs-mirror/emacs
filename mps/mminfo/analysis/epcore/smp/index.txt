      NOTES ABOUT SW SMP, AND HOW THE MPS WILL BE DEPLOYED INTO IT
                          analysis.epcore.smp
                             incomplete doc
                          richardk 1998-10-07

INTRODUCTION

.intro: This document talks about the nature of SW SMP, and how the MPS will be 
deployed into it.

.def.sw-smp: "SW SMP", or "the SMP rip", is a ScriptWorks product, designed to 
take advantage of an SMP machine.


CONSTRAINTS

.sw-smp.design: The SW SMP-rip design is to have separate processes (each with 
one thread per process).  One process is 'special' -- it performs all 
interpretation.  Other processes are idle until interpretation of the page is 
complete, whereupon they render in parallel (each working on different bands of 
the page).  (The interpreter process may also join in as a renderer at this 
point).

.note.processors: Note that there is no fixed assignment of processes to 
processors.  Indeed, all processes may be running on the same single processor.

.platforms: SMP version of SW are currently available on Windows NT, Irix 6.4 
and possibly Solaris [DTB doesn't know any current OEM that takes Solaris 
though]; mail.dtb.1998-10-06.20-59.  None of these platforms have any 
processor-local memory.

.shmem: The interpreter process and renderer processes communicate using an 
area of shared memory, mapped into the same part of the address-space of all 
processes.  The interpreter creates a display-list (with all the associated 
structures, including images, font-caches[?], halftone-cells, etc.), which the 
renderer processes can later read.  The renderer processes then write into 
'bands' of pagebuffer-device memory, which have been pre-allocated by the 
interpreter process [see .question.render.bands below].

.decompress: In 5.0, SW splits images into blocks while interpreting.  It may 
compress these blocks ("image block compression"), in which case they must be 
uncompressed again during rendering.  The blocks may either be in memory or on 
disk - either way, the renderer needs to be able to create a decompression 
filter, which requires allocation of memory.  (Pre-allocating the filters is 
fine for lzw (although wasteful) but not for ccitt (memory required depends on 
image width).)  The filter code assumes there is an MPS-managed arena it can 
use.

.renderer.mps: So, _new to SW 5.0_, in order to work with image block 
compression, renderer processes need to be able to allocate and free in an MPS 
arena.  (Or the filter code would need re-writing.)  [see 
.question.renderer.pre-alloc below]


DESIGN

.arena.int: The interpreter process will create one arena in memory shared 
between all processes (and so visible to all render processes).  Only the 
interpreter process will make MPS calls in this arena (that is, allocate and 
free, etc.).

.arena.int.client: This will be a client arena.

.arena.int.not-vm: It can't currently be a VM arena because there is no way for 
the client to ask mps_arena_class_vmnz to share the memory with the other 
processes.  (We want to be able to use a VM arena in the future, for the same 
reasons as for non-SMP rips.  See request.epcore.160047 "VM Arenas don't work 
with multi-processing" for more.)

.arena.ren: Each renderer process will create a small arena, in local memory.  
(The interpreter thread will not create a non-shared arena; if it participates 
in rendering it will simply continue to use the big arena it's already got).

.arena.ren.new: Having these arenas is the new part of this design (in 
comparison to 4.5 SMP).  In 4.5, the render threads _do_ have private memory, 
but it is not managed by the MPS, forcing the SMP rip to disable image block 
compression (see .decompress above).

.arena.ren.client: It is not anticipated that fragmentation will be an issue 
for renderer arenas, so EP don't want to use VM arenas.

.arena.ren.size: Small means each renderer might need to allocate around 256 kB.


OUTSTANDING ISSUES

.issue.small: Very small arenas are not a point of parameter-space MM have 
looked at much.  MMQA have done a few tests on very small arenas.
  .issue.small.bugs: There could be new bugs.
  .issue.small.overhead: Overhead could be a problem.  Some MPS measures (such 
as keeping certain housekeeping structures on separate pages) might not be 
appropriate for very small arenas.
  .issue.small.arenavm: mps_arena_class_vm() is not designed to work with 
arenas smaller than 32 pages (which usually works out at 128 kB or 256 
kB)[drj].  mps_arena_class_vmnz() might well work correctly with less than 
this[richardk].

.issue.arena.ren.size: What are the factors influencing choice of arena-size 
for .arena.ren?  How much memory is typical on SMP systems in practice?  If 
these are high-end machines with hundreds of megs of memory, and the number of 
dedicated renderer threads is between one and three, it may be most sensible to 
simply make .arena.ren 512 kB or 1 MB.

.issue.sync: Synchronization issues.  Also worth a bit of think-ahead, to when: 
SW SMP may change to using same-process threads; SW may have more demanding 
code in the renderers; SW may use GC.
  .issue.sync.requests: Could renderer processes allocate/free in the existing 
interpreter-process arena?  Yes but.  MPS supports asynchronous requests within 
one arena, but there is an associated synchronization cost.  (There are also 
currently issues about: MPS requires a way to stop all threads within a process 
during GC because of same-process protection limitations on most OSs and root 
unprotectability; need some work on shields to allow multi-process use.)
  .issue.sync.read-write: If renderer processes use the existing 
interpreter-process arena, but _only_ to read from and write to existing 
(interpreter-allocated) objects, with no allocation/freeing, is that safe?  Not 
during a GC: reading from collected or scanned pools is a no-no.  Do the render 
threads write to PS VM?


QUESTIONS

.question.renderer.pre-alloc: RichardK wonders: How does _non-SMP_ SW currently 
guarantee that there will be enough memory free for filter allocation during 
rendering?  richardk 1998-10-08

.question.render.bands: RichardK asks: Do the bands renderers write into reside 
in the interpreter's arena? or in the shmem but outside the arena?  richardk 
1998-10-07


SOURCES

mail.gavinm.1998-10-06.13-33(0) "Proposed SW memory use in SMP" et seq.
irc.irchost-mm.1998-10-06(0) (ericp, richardk, drj).

