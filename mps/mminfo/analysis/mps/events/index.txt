              ANALYSIS OF EVENTS IN THE MEMORY POOL SYSTEM
                          analysis.mps.events
                               draft doc
                           richard 1995-11-28

INTRODUCTION

.intro: This document analyses the goals and requirements of "events".  It was 
put together in just a few hours, and isn't a well polished.  In particular, I 
don't think the requirements are truly shaken out to the bare minimum, but they 
get the idea across.


The Feedback Model of Use

( - Feedback Model Diagram )

.hist.1: Created November 1995 by Richard.

.hist.2: Richard added new ideas based on discussions with Tucker on 1996-08-16.


GOALS

.goal.measure: Events shall make it easier to improve the MPS by providing a 
means for measuring various aspects of the memory manager.

.goal.debug: Events will reduce the cost of debugging by making it possible to 
see what happened inside the MPS before a problem occurs, so that the 
circumstances leading up to a problem can be understood.  (This is useful 
internally, but especially useful for situations where the actual circumstances 
can't be repeated, such as on external customers' machines after a two-week 
long run.)

.goal.testing.grey-box: Events will reduce the cost and improve the 
effectiveness of testing by making it possible to find out whether a particular 
set of events occurred as expected.  (For example, we could log and check just 
object motion events.  Event log comparison tools can be used.)

.goal.analysis: Events will support the MPS Model of Use [ref?] by sending 
information out to external tools which provide analysis of the behaviour of 
the MM and feedback to its parameters in order to meet particular requirements 
(idea.feedback).

.goal.annotation: Events might become the "universal annotation", providing a 
flexible way of controlling annotations throughout the sources.


REQUIREMENTS


Functional Requirements

.fun.annotate: Provide a means to annotate the source code with "events" which 
record the fact that the PC has passed through.

.fun.classes: Distinguish between different classes of event.  (How many?  
Dynamic?  Extensible?)

.fun.context: Record contextual information with the event.  (How much, what 
type?)

.fun.comm: Communicate with the outside world.
 - networks
 - dumping into file

.fun.record: Record information internally for post-mortem analysis.

.fun.logs: Log different classes (or levels?) of event at different rates.

.fun.recon: Information recorded must allow reconstruction.

.fun.model: Information recorded must allow for modelling.

.fun.comp: Information recorded must allow log comparison for grey-box testing.

.fun.switch: Must be able to switch event annotations on and off selectively.

.fun.compat: Recorded information should be compatible with existing tools. 
[Solution to reduce cost?]

.fun.assert: Support assertion.


Attribute Requirements

.attr.cost: Cost of event logging in delivered code must be very low so that it 
doesn't impact performance too much.


Resource Constraints

.rc.inst: Cost of installation must be low.
  -> Mustn't involve large scale change to MM code.


SOLUTION IDEAS


Interface

.idea.int.mac: The annotations in the code could be macros of the form:

  EVENT(<class>)
  EVENT1(<class>, <p>)
  EVENT2(<class>, <p0>, <p1>)
  etc.

where <class> is an identifier which indicates the class of event 
(.fun.annotate, .fun.classes).

.idea.int.classes: Events will be recorded outside the MPS, and the set of 
classes may live beyond the MPS and span across products and releases.  The set 
should therefore be determined outside the MPS.  Event classes could be 
assigned and recorded using the Information System.  Each one will have an ID, 
and we won't re-use the IDs.  In the source, symbolic names will map the 
identifiers to their ID.  Each class defines the number and types of the 
parameters which form the data giving the event context.

.idea.circular-buffer: Internal logs can be circular buffers with sizes that 
are statically configured.  The buffers could be allocated as part of the 
space, or as part of the static data.  The latter would be less vulnerable but 
would mean that every space shared the same set of buffers.

The information recorded in the buffer would be of the format:

  A     class ID
  A+1   length L
  A+2   data bytes...
  A+L-1 last byte
  A+L   checksum

Maybe all events should include source location information too.  Possible 
implementation:

  typedef struct EventStruct
  {
    EventClass class;
    Addr length;
    union
    {
      EventXStruct X;
      EventYStruct Y;
      ...
    } the;
    Addr checksum;
  } EventStruct;

.idea.compat: Recorded information compatible with existing tools.

.idea.aver: AVER(X) becomes EVENT(Aver, X), where Aver is an event class with a 
single boolean parameter.

.idea.expand: One way to control event annotations is to have EVENT(X, Y) 
expand to EventX(Y), so that EventX can do whatever it wants.  This means 
implementing a potentially large set of EventX functions, though macros could 
map them onto the same function.  (This is similar to drj's early proposal for 
the metering code.)

.idea.out: Arrange the code so that the event writing code is "out of line" of 
the main execution, i.e. so that the branch testing whether event generation is 
switched on is not taken in common case, when events are switched _off_.  This 
could be very tricky to arrange in C without significant complication.

.idea.short: Event encoding should include a "short format" which is just a few 
bytes long, distinguished by the initial bytes, so that really short events can 
be logged in little space and bandwidth.

.idea.sep: Log events of different classes into different buffers.  In 
particular, frequent events should be separated from infrequent, important 
events so that the latter aren't pushed out by the former.

.idea.delta: A short time format, or time delta, can be used on adjacent events 
to save bandwidth.

.idea.bi-directional: It might be worth designing a bi-directional protocol 
which can be expanded to handle debugging and control as well as metering.  
It's probably at least worth developing a protocol which can adapt easily to do 
this.

.idea.header: The event log should start with a header from which the format of 
the log can be derived.  Another way of looking at this is as a protocol set-up 
packet.

.idea.unsolicited: In a protocol it's worth allowing for unsolicited events 
from either party (e.g. "I've just crashed" or "Break") so that higher level 
design doesn't omit this possibility.

ATTACHMENT
   "Feedback Model Diagram"

