               BEHAVIOUR OF MALLOC AND REALLOC EDGE CASES
                            analysis.realloc
                             incomplete doc
                            nickb 1997-03-24

.intro: The ISO C standard (standard.ansic) does not adequately define malloc() 
and realloc(), in particular the "edge cases". Different libraries do different 
things in these cases. Some third-party libraries depend on the behaviour of 
these cases (see mail.johnh.1997-02-26.09-51(0)). In order to provide drop-in 
replacements for malloc(), free() and realloc(), we therefore have to emulate 
OS-specific behaviour. This document exists to identify that behaviour. There's 
some discussion at the end.

.table: This table shows the behaviour linking with the default libraries on 
various platforms.

                malloc(0)       realloc(NULL,0) realloc(p,0)    Notes

Digital 4.0     NULL            NULL            NULL
HP/UX 9.0       new             new             NULL
HP/UX 10.20     new             new             NULL
Irix 4.0.5      new             new             p
Irix 5.3        new             new             new
Irix 6.2        new             new             new
Linux 2.0.28    new             new             p
MacOS 7 CW 9    NULL            NULL            p
MacOS 7 CW 10   NULL            NULL            p               68k and PPC
MacOS 7 CW 10   NULL            NULL            NULL            Also CW 10. 
Strange.
MacOS 7 CW 11   NULL            NULL            NULL
Solaris 2.3     new             new             new
Solaris 2.4     new             new             new
Solaris 2.5     new             new             new
SunOS 4.1.2     new             NULL            p
SunOS 4.1.3     new             NULL            p
SunOS 4.1.4     new             NULL            p
Ultrix 4.4      new             new             p-4
Ultrix 4.5      new             new             p-4
Windows 95      new             new             NULL            MSVC 2 or 4
Windows NT      new             new             NULL            MSVC 2 or 4


.code: The following code attempts to determine the behaviour in these edge 
cases:

#include <stdio.h>
#include <stdlib.h>

main(int argc, char *argv[])
{
  void *p, *q;

  p = malloc(0);
  q = malloc(0);
  if (p == NULL && q == NULL)
    printf("malloc(0) returns a null pointer.\n");
  else if (p == q)
    printf("malloc(0) returns the same non-null pointer twice: 0x%08x.\n", p);
  else if (p == NULL || q == NULL)
    printf("malloc(0) sometimes returns a null pointer and sometimes not: "
           "0x%08x 0x%08x.\n", p, q);
  else
    printf("malloc(0) returns a new non-null pointer each time: "
           "0x%08x 0x%08x.\n", p, q);

  p = realloc(NULL, 0);
  q = realloc(NULL, 0);
  if (p == NULL && q == NULL)
    printf("realloc(NULL,0) returns a null pointer.\n");
  else if (p == q)
    printf("realloc(NULL,0) returns the same non-null pointer twice: "
           "0x%08x.\n", p);
  else if (p == NULL || q == NULL)
    printf("realloc(NULL,0) sometimes returns a null pointer and sometimes "
           "not: 0x%08x 0x%08x.\n", p, q);
  else
    printf("realloc(NULL,0) returns a new non-null pointer each time: "
           "0x%08x 0x%08x.\n", p , q);

  p = malloc(10);
  if (p == NULL)
    printf("malloc(10) returned a null pointer; can't investigate 
realloc(p,0).\n");
  else {
    q = realloc(p,0); /* frees p */
    if (q == NULL)
      printf("realloc(p,0) returns a null pointer.\n");
    else if (p == q)
      printf("realloc(p,0) returns p.\n");
    else
      printf("realloc(p,0) returns neither p nor a null pointer: "
             "0x%08x -> 0x%08x.\n", p, q);
  }
  return 0;
}

.case: There are at least three edge-cases:
.case.malloc: malloc(0)
.case.realloc.zero: realloc(p,0), where p has been allocated.
.case.realloc.null: realloc(NULL,0).
.case.other: calloc() gives three more edge cases, with one or both arguments 
zero, but I believe always does the same as malloc(0) in these cases.

.std.The standard says (7.10.3):

.std.zero: If the size of the space requested is zero, the behaviour is 
implementation-defined; the value returned shall be either a null pointer or a 
unique pointer.
.std.malloc: The malloc function returns either a null pointer or a pointer to 
the allocated space.
.std.realloc.null: If ptr is a null pointer, the realloc function behaves like 
the malloc function for the specified size.
.std.realloc.zero: If size is zero and ptr is not a null pointer, the object it 
points to is freed.
.std.realloc.return: The realloc function returns either a null pointer or a 
pointer to the possibly moved allocated space.

.clear: These statements are rather unclear, especially .std.zero, and the 
combination of .std.realloc.zero and .std.realloc.return.

.clear.malloc: It is at least clear that malloc(0) should either return a null 
pointer or a fresh pointer. The standard permits it to vary between these two 
behaviours, but that seems unlikely in practice.
.clear.realloc.null: It is also clear that realloc(NULL,0) should be the same 
as malloc(0).
.clear.realloc.zero: I think that realloc(p,0) must return a null pointer, as 
there is no "possibly moved allocated space".


.impl: Many implementations fail to conform to the standard in at least one of 
these cases.

.impl.common.malloc: The most common behaviour for malloc(0) is to behave as 
malloc(1), and return a fresh pointer. This conforms.
.impl.common.realloc.null: The most common behaviour for realloc(NULL,0) is to 
behave as malloc(1), returning a fresh pointer. This conforms, if malloc(0) 
does the same.
.impl.common.realloc.zero: The most common behaviour for realloc(p,0) is to 
return p. This does not conform (see .clear.realloc.zero).


