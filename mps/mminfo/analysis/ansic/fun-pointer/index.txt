                 USING FUNCTION POINTERS IN STANDARD C
                       analysis.ansic.fun-pointer
                               draft doc
                            nickb 1996-10-21

Foreword

.scope: This is a description of the use of function pointers in ISO Standard C 
(standard.ansic).

.readership: This is intended to be readable by any interested Harlequin 
employee.

.ref: References are to the standard.

.disc: Use this description at your own risk. Let the standard be your guide.

Body

.constraint: "Breaks a constraint" has a specific meaning in the context of 
Standard C:  A conforming implementation shall produce at least one diagnostic 
message for every translation unit that breaks a constraint (3.6, 5.1.1.3), 
even if the behaviour is also explicitly undefined or implementation defined 
(5.1.1.3, TC1).

.pointers: ISO C distinguishes two classes of pointer type: pointers to 
functions and pointers to objects (and pointers to incomplete types, which are 
really pointers to objects about which not everything is known). See 6.1.2.5. 
For the sake of brevity, I'll call these "function pointers" and "object 
pointers".

.void: void* is an object pointer type (6.1.2.5).

.null.constant: A constant expression with the value 0, or such an expression 
cast to void*, is a _null pointer constant_. (6.2.2.3). NULL is a null pointer 
constant (7.1.6).

.null.pointer: If a null pointer constant is assigned to or compared for 
equality against a pointer, it is converted to the pointer type. Such a pointer 
is a _null pointer_. (6.2.2.3)

.null.compare: A null pointer is unequal to a pointer to any object or function 
(6.2.2.3).

.null.convert: Two null pointers converted through sequences of pointer casts 
are equal (6.2.2.3).

.convert: Assignment between an object pointer and a function pointer breaks a 
constraint (6.3.16.1).

.cast: Casting between an object pointer and a function pointer is undefined 
(6.3.4).

.change: A function pointer may be converted to another function pointer type 
and back again without change. (6.3.4).

.arith: Arithmetic on function pointers breaks a constraint (6.3.6, for 
example).

.compare: Relational operations on function pointers breaks a constraint 
(6.3.8).

.apply: On application of a function pointer, if the function type is not 
compatible with the type of the expression pointed to, the behaviour is 
undefined. (6.3.2.2 and 6.3.4).

.equal: Equality on function pointers is defined: "If two pointers to function 
types are both null pointers or both point to the same function, they compare 
equal. If two pointers to function types compare equal, either both are null 
pointers or both point to the same function." (6.3.9).

