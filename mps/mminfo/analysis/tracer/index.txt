                       TRACING A REFERENCE GRAPH
                            analysis.tracer
                             incomplete doc
                            pekka 1998-01-28

INTRODUCTION

.intro: This document presents tracing as an abstract algorithm on a reference 
graph.  It tries to establish the basic concepts that can be used to describe 
tracing algorithms and give them firm definitions.


History

.hist.0: Written by Pekka P. Pirinen in December 1997 as necessary background 
for analysing barriers, and subsequently slightly edited for clarity.  The 
presentation of the five phases is based on Richard's old design.mps.tracer(0), 
and the diagrams have been copied from that document.


THE PURPOSE OF TRACING

.purpose.reachable: Basically, the tracer is concerned with discovering those 
nodes that are reachable from some root.

.purpose.references: In some cases, we need to discover not just the reachable 
nodes, but all references to them as well (for example because we want to move 
some nodes).  This sets more stringent requirements on the tracer.  .thorough: 
We call this "thorough" tracing.


ROOTS AND THE CONDEMNED SET

.root.state: In practice, we're usually interested in determining reachability 
from the program's state (as an approximation of liveness) and then recycling 
the unreachable nodes.  So the root is the program's state, or the mutator's 
state to be precise, since the collector's state is not relevant to liveness 
(but this is no deep insight, it's only because we choose to divide the program 
into mutator and collector just so, see analysis.async-gc.divide).

.condemned-set: We usually restrict our attention to some set of nodes where we 
expect to find lots of unreachable nodes.  We call that "the condemned set", 
assume that everything else is reachable, and determine what part of the 
condemned set is reachable.  We try to arrange matters so that this is a good 
approximation of reachability from the root, but the techniques used are 
outside the scope of this document.

.root.temporary: Note that everything outside the condemned set could be said 
to be part of the root, since the tracer is not concerned with the reachability 
or liveness of these objects, only with that of objects which are reachable 
from them.  However, this gets confusing, so we won't use that terminology.

.root.mps: Note that in the MPS, we allow the client to register arbitrary 
"roots", which will be part of the root of any trace thereafter.  This can be 
regarded as an optimization, so that the tracer doesn't have to find static 
data by scanning the program code or some other tedious method.


THE TRI-COLOUR ABSTRACTION

.tri-colour: We will describe tracing in terms of "the tri-colour 
abstraction".  The nodes are partitioned into three sets:

.colour.black: Black means that the node has been noted reachable by the 
tracer, and the tracer is finished with it and need not visit it again.

.colour.grey: Grey means that the node has been noted reachable, but it must 
still be visited by the tracer in order to process its children.

.colour.white: White means that the node has been condemned, but not visited.

.mutator-colour: By analogy, we also say that the mutator is grey, if its state 
has not yet been processed by the tracer, and that the mutator is black if its 
state has been processed by the tracer and does not need to be examined again.

.termination: A trace terminates when there are no grey nodes left and the 
mutator is black.  At this point all reachable nodes are black and all 
remaining white nodes are unreachable (but the converses don't necessarily hold 
after incremental traces).

.no-revert: Note that the definitions imply that an object can never revert to 
white during a trace, once it has been coloured grey or black.

.tri-colour.use: The partition defines the limits on the order of traversal: 
the tracer must always choose one of the grey nodes to process next.  It can 
also be used to define an invariant that a concurrently running mutator must 
preserve in order not to break the collector; Such invariants can be guaranteed 
by using various barriers.  However, this document does not explore 
incremental/concurrent collection, since that subject is important enough and 
complex enough to merit an analysis of its own, see analysis.async-gc.


FIVE-PHASE TRACING

.phase.section: This section describes the tracing process step by step, in 
terms of the abstract idea of a reference graph and a tri-colour partition 
which is refined in order to perform the trace.

.phases.five: A trace proceeds through five phases: Condemn, Grey Mutator, 
Flip, Black Mutator, and Reclaim.  Except for the Flip phase, the tracer can 
run concurrently with the mutator.  The invariants and the mutator's 
consistency can be guaranteed by using various barriers, see 
analysis.incrementality for details.

.phase.before: Initially, the heap consists of some nodes whose connectivity 
has not yet been discovered.

.fig.init: The initial graph before tracing.


.phase.condemn: In the Condemn phase, the condemned set is identified.  This is 
typically the set we want to attempt to recycle.  We colour the nodes in the 
condemned set white.  All other nodes are conservatively coloured grey because 
they might refer to the condemned nodes.

.fig.condemn: The condemned set is identified.


.phase.condemn.refine: The partition is refined using any additional stored 
knowledge (typically remembered sets), making some of the grey nodes black.  
The aim is to reduce the grey set to minimum size, since the amount of work the 
tracer has to do is roughly proportional to the size of the grey set.

.fig.condemn.refine: The grey set is refined.
[@@@@]

.phase.grey-mutator: In the Grey Mutator phase, the Tracer can make progress by 
scanning a grey node for references to white nodes and colouring them grey.  
When all the references in a node are non-white it can be coloured black, 
preserving the tri-colour invariant.

.fig.grey-mutator: Grey nodes are blackened by scanning.


.phase.flip: At some point, the mutator's state must be processed.  In the Flip 
phase, the mutator is suspended (all threads are suspended) so that its state 
can be atomically scanned for references to white nodes, colouring them grey.

.fig.flip: The mutator is blackened by scanning.


.phase.black-mutator: In the Black Mutator phase, the Tracer can make progress 
by scanning grey nodes for references to white nodes and colouring them grey.  
The important difference between the Grey Mutator phase and the Black Mutator 
phase is that the barriers must work differently.  See analysis.async-gc for details.

.fig.black-mutator.1: Grey nodes are blackened by scanning.


.fig.black-mutator.2: More grey nodes are blackened.
.fig.black-mutator.3: More grey nodes are blackened.


.fig.end: No grey nodes remain, so reclaim starts.
.phase.reclaim: The Reclaim phase starts when there are no grey nodes left.  
Now we know that all the remaining white nodes are dead and can reclaim that 
space.  In some algorithms, this is a lengthy operation, requiring another pass 
over the memory.

.fig.trace.reclaim: Remaining white nodes are dead.


