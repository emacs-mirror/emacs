                         STATE-MACHINE SCANNERS
                             idea.statescan
                               draft idea
                           richard 1995-07-28

MM.IDEA.STATESCAN: State-machine scanners

To: mm-dylan
From: richard (Richard Brooksby)
Subject: Re: The Tracer as a state machine
Date: Fri, 23 Sep 1994 15:50:49 +0100

The machine has two registers, S and I.  S is the `scan pointer' and I is
the `instruction pointer'.  The machine repeatedly fetches instructions
from I, decodes, and executes them.  Scanning stops when S reaches or
exceeds a bound which is a parameter of the scan routine.

An important feature that distinguishes the scanning machine from the other
schems and gives it it's flexibility and efficiency is that it does not
care where it is within an object.  It is therefore `context free' and does
not need to retain much state.  The scanning code is considerably
simplified (and therefore sped up) by this.

In general, it is advisable to make the instruction encodings simple,
because that will lead to a very tight implementation of the scanner.
However, they are essentially arbitary, and can be easily redefined
according to the sitation.  For example, if DylanWorks requires a change in
tagging scheme it is minimal effort to update the scanning machine.


INITIAL DYLANWORKS SCANNER

The scanner for the initial DylanWorks memory manager will have seven
instructions:

MNEMONIC      ACTION                          OPCODE

FIX1          fix(S), ++S, ++I                PPPPPPPPPPPPPPPPPPPPPPPPPPPPP000
SKIP1         ++S, ++I                        IIIIIIIIIIIIIIIIIIIIIIIIIIIIII01
SKIP1         ++S, ++I                        IIIIIIIIIIIIIIIIIIIIIIIIIIIIII10
FIXR  L       fix(S..S+L-1), S+=L, I=S        LLLLLLLLLLLLLLLLLLLLLLLL00000111
SKIPR L       S+=L, I=S                       LLLLLLLLLLLLLLLLLLLLLLLL00000011
JUMP  C       fix(S), ++S, I=C+N              CCCCCCCCCCCCCCCCCCCCCCCCCCCCC100
PAT   L, B    fix(S..S+L-1) as B, S+=L, ++I   BBBBBBBBBBBBBBBBBBBBBBBBLLLLL011
PATR  L, B    fix(S..S+L-1) as B, S+=L, I=S   BBBBBBBBBBBBBBBBBBBBBBBBLLLLL111

The FIX1 and SKIP1 instructions correspond directly to the current DW
encoding of pointers, integers, and characters.  Tony objected to this
because it introduces a dependency between this specification and the DW
encoding.  I would point out that there is minimal effort required to
change the encoding of the operations.  The scheme requires only three tags
out of eight, and these three could easily be changed.  If they can't
easily be changed then the implementation is poor.  This dependency is
therefore not dangerous, and shouldn't be avoided for the sake of
principle.

It is up to DW how to use this encoding.  We will measure their usage and
adjust our implementation accordingly.

Anyway, this scheme can effectively be forced to be scheme 2 (from the
summary) where all information is forced into the class.  It will almost
certainly be used in that way by DW initially, and possibly always.  This
does not, IMO, invalidate the schema as a useful and portable method.


EXAMPLES

Object with three pointer slots

    0  <class>
    1  pointer slot 0
    2  pointer slot 1
    3  pointer slot 2

Object with mixed slots

    0  <class> | 0b100          class+N  abcdeXX..XX00101111
    1  a
    2  b
    3  c
    4  d
    5  e

Alternative object with mixed slots

    0  <class>
    1  0abcdeXX..XX00101111
    2  a
    3  b
    4  c
    5  d
    6  e

Large object with mixed slots

    0  <class> | 0b100          class+N  ab....pqr11000011
    1  a                             +1  stuvXX..XX0100111
    2  b
     :
   22  p
   23  q
   24  r
   25  s
   26  t
   27  u
   28  v

Alternative representation

    0  <class>
    1  00ab.......p11000011
    2  0qrstuvXX..XX0100111
    3  a
    4  b
     :
   30  v

Another representation

    0  <class>
    1  0ab....pqr11000111
    2  a
    3  b
     :
   24  q
   25  0rstuvXX..XX0100111
   26  r
   27  s
   28  t
   29  u
   30  v

An object containing a vector of raw values

    0  <class>
    1  4<<8 | 0b00000011
    2  raw[0]
    3  raw[1]
    4  raw[2]
    5  raw[3]

Alternatively

    0  <class> | 0b100          class+N  1
    1  4                             +1  4<<8 | 0b00000011
    2  raw[0]
    3  raw[1]
    4  raw[2]
    5  raw[3]

A stretchy vector of fixable values

    0  <class>
    1  01XX..XX0010111
    2  T
    3  L<<8 | 0b00000111
    4  pointer[0]
    5  pointer[1]
     :
  L+3  pointer[L-1]
  L+4  (T-L)<<8 | 0b00000011
  L+5  junk
     :
  T+3  junk

More examples on request.  If you're not sure how a particular object can
be encoded, ask, and I'll provide an example.

