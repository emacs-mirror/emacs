                      SHIELD PROTOCOL FOR BARRIERS
                              idea.shield
                               draft doc
                           richard 1995-11-29

X-Sender: richard@mailhost.cam.harlequin.co.uk
Mime-Version: 1.0
Date: Thu, 14 Sep 1995 16:19:03 +0100
To: ptw, drj
From: richard (Richard Brooksby)
Subject: Protection/suspension protocol
Cc: mm

Dsm and I have been thinking about protection today.  Dsm came up with an
abstraction which can be used in the collector and implemented in various
ways to have different effects, ranging form a non-incremental collector to
one which is quite clever about calling the system only when necessary to
protect and deprotect memory.

Please read through these notes and see if you agree that the protocol
actually works, and provides the right abstraction.  If it does, then we
have a very useful tool for porting and experimenting with different
protection schemes.

The protocol is expressed in terms of two arrays of flags and two global
flags.  These are not actually arrays, but they behave enough like them to
make them a useful metaphor:
  P[page] "protect"
  S       "suspend"
  A[page] "access"
  PR      "protect atomic root"

Some invariants on these are:
  1. if PR then threads are suspended
  2. if P[page] and page is not hardware protected then threads are suspended
  3. if not PR and all P clear then threads are not suspended
  4. if A[page] then page is not hardware protected for the collector
  5. if not S then all A clear
  6. if not A[page] then collector must not access page

Invariant 1 ensures that we can scan roots atomically.  Invariant 2 makes
sure that the mutator can't access a page if P[page] is true.  Invariant 3
makes sure that the collector can allow the mutator to run.  Invariant 4 is
so that the collector can access the memory.  Invariant 5 forces the
collector to declare the region where it needs to access some memory, and
allows the optimisation of thread suspension.  Invariant 6 allows the
protocol implementation to protect pages at various different times.

This is how the protocol could be used.

To access a page, the mutator must check the P array, which contains the
protection flag.  If the flag is set, it must call the fault handler.  In
the implementation, this is done for us by the OS, of course.

  MutatorAccess(page)
  {
    if(P[page]) { Fault(page); AVER(!P[page]); }
    Access(addr);
  }

At the beginning of a collection we need to scan some roots atomically, and
protect all the gray objects so that the mutator can't get at them.
Standard stuff.

  Flip
  {
    PR = TRUE;
    scan roots;
    for all gray { P[gray] = TRUE; }
    PR = FALSE;
  }

This is the periodic work we do to advance the collection.  The collector
has to gain access to memory in order to scan it, and the mutator has to be
stopped if we can't have exclusive access.  The S and A flags let us do
this.

  Periodic
  {
    S = TRUE;
    for some gray stuff
      A[gray] = TRUE;
      scan(gray);
      A[gray] = FALSE;
      P[gray] = FALSE;
    S := FALSE;
  }

If a fault occurs, we have to scan a particular page.  This is essentially
the same as above.

  Fault(page)
  {
    S = TRUE;
    A[page] = TRUE;
    scan(page);
    A[page] = FALSE;
    P[page] = FALSE;
    S := FALSE;
  }

Here are example meanings we can ascribe to the operations of setting and
clearing the flags.

Most naive example (non-incremental):
  setting P or PR = stop mutator
  clearing P = start mutator if all P false otherwise do some more work
  everything else does nothing

Quite naive:
  setting PR = suspend threads
  clearing PR = resume threads
  setting P = protect memory
  setting S = suspend threads, unprotect all memory for which P is true
  setting A = nothing
  clearing A = nothing
  clearing S = reprotect memory for which P is true, resume threads
  clearing P = unprotect memory

Still quite naive implementation:
  setting PR = suspend threads
  clearing PR = resume threads
  setting P = protect memory
  setting S = suspend threads
  setting A = unprotect memory
  clearing A = protect memory
  clearing S = resume threads
  clearing P = unprotect memory

Pretty good:
  setting PR = suspend threads
  clearing PR = resume threads
  setting P = protect memory
  setting S = do nothing
  setting A =
    if(!b) suspend threads;
    unprotect, and record page;
    b:=true;
  clearing A = nothing
  clearing S =
    reprotect recorded pages;
    resume threads;
  clearing P = unprotect memory

If we have separate protection maps for threads (we can dream):
  setting PR = suspend threads
  clearing PR = resume threads
  setting P = protect memory for mutator
  clearing P = unprotect memory for mutator
  everything else does nothing

