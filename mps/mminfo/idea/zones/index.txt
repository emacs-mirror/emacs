                                 ZONES
                               idea.zones
                               draft idea
                           richard 1995-07-28

SUMMARY

Partition managed memory in order to provide a very fast approximation
to subsets thereof.  This can be used to determine quickly whether a
reference is "interesting" and needs fixing, or to record other
approximations to sets of objects.


DESCRIPTION

This diagram shows managed memory (the "Arena") divided into four
contiguous Zones, numbered 0 to 3.

       .----------------.
     3 |                |
       |                |       Set of Zones {1, 2} is represented by 0110.
       |                |
       |                |       Set of Segments {A, B} is approximated by
       |----------------|       0110 (there may be more than one per Zone).
     2 |  .----.        |
       |  | P  | Seg A  |       Set of objects {P, Q, R} approximated by
       |  |  Q |        |       pattern 0110.
       |  `----'        |
       |----------------|
     1 |     .----.     |
       | Seg | R  |     |
       |   B |    |     |
       |     `----'     |
       |----------------|
     0 | Seg C .----.   |
       |       |  S |   |
       |       | T  |   |
       |       `----'   |
       `----------------'

The Arena is aligned so that all addresses in Zone N are of the binary
form PPPPZZSSSSSSSSSSSSSS where PPPP is a prefix determined by the
base address of the Arena, ZZ is the Zone number of the pointer, and
SSSS is a suffix which indicates the offset within a Zone.

A set of Zones can be represented by a bit pattern with bit N set if
Zone N is in the set.  Given a pointer, it is very fast to see whether
the pointer is to a Zone which is in the set.  Usually, there will be
W Zones (one per bit in the machine word) so that a Zone set can be
represented in a single word or register.

A collector can arrange so that the subgraph it is collecting is in
one zone and the objects it is not interested in are in other zones.
The generic fixup function can inline a test which checks the zone of
the reference before attempting to fix it up, and can therefore avoid
a function call for most pointers which are not interesting.


JUSTIFICATION

- performance


ADDITIONAL INFORMATION

From: richard (Richard Brooksby)
To: ptw (P. Tucker Withington)
Cc: mm-discussion
Subject: Fast tests for interesting pointers
Date: Tue, 20 Sep 1994 12:09:55 +0100

I have been analysing the problem of determining whether a pointer is
`interesting' (to from-space) quickly.  Firsly, my observations:

 - the test must fail quickly, particularly for small integers
 - the test must be accurate if there are likely to be adjacent segments
with many pointers between

I'm sure we could determine the optimal accuracy of the test given a
frequency analysis of the pointers, but we're more likely to be constrained
by hardware restrictions.

The `zone' test used by Genera uses five bits of information from the
address word to index a single word bit-vector (32 bits).  There's no
particular reason that these bits should be at the top of the word,
although they should be contiguous within the address, because we don't
have a hardware implementation of Intercal's SELECT operation
(unfortunately).

If our managed arena is between, say, 0x10000000 and 0x10100000 then we
actually want to test that the top 11 bits match, and then index the bit
vector using the next five, giving us 32 divisions of our arena.  Better
still, if we arrange to seperate the pools into different zones within the
arena as far as possible we can narrow it down further.  All the segments
of a particular pool might be between 0x10110000 and 0x10120000.

To implement this, we need several to know the number of bits at the top to
match (N), and what to match them with (M).

  t := ptr & mask
  t = area?                test for alignment and pointing into arena
  jump out if not
  t := ptr >> shift
  test (zonemask >> (t&0x1F)) & 1
  jump out if unset
  Exact test follows.

If EAX=ptr, ECX=mask, EDX=area, ESI=shift, and EDI=zonemask, it might go
(optimistically) something like this:

  MOV   EAX, EBX        Save the pointer value
  AND   EAX, ECX        Mask out the significant address and alignment bits
  CMP   EAX, EDX        Compare to see if the pointer goes somewhere interesting
  JNE   out
  SHR   EBX, ESI        Shift the interesting bits to the bottom of the pointer
  BT    EDI, EBX        Test the bit in the zone old mask (operand is mod 32!)
  JNC   out
  Exact test follows.

I would argue that since we probably won't use the whole address space
testing the top bits it probably wasteful, and we should look further down
the word.

It's worth considering whether we'll ever need to deal with more than one
contiguious segment at once.  From my previous mail:

  t = p - base
  test t >= limit-base
  jump if true

which might be

  SUB   EAX, EBX
  CMP   EAX, ECX
  JGE   out

is hard to beat for speed and register usage.  It is also exact.

Of course, we could partially evaluate these tests on the fly(!)

