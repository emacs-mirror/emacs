                     GENERIC ALLOCATION INTERFACES
                          idea.interface.alloc
                               draft idea
                           richard 1995-07-28

X-Sender: richard@mailhost.cam.harlequin.co.uk
Mime-Version: 1.0
Date: Fri, 28 Jul 1995 09:41:40 +0100
To: mm
From: richard (Richard Brooksby)
Subject: Generic allocation interfaces

Looking through the allocation buffer code and AMC code with dsm, it struck
me that there must be some underlying generic allocation interface.  I
started thinking about how we might unify the client allocation interface,
the internal allocators needed for spans, generations, etc., and the
segment allocation interface.

This message contains some half-baked ideas for generic allocation
interfaces.  I invite your comments.

Here is a generic allocator interface which returns the traditional handle
on an object of type "void *", rather like malloc.

> typedef struct AllocatorStruct *Allocator;
>
> extern Error Allocate(Addr *baseReturn, Allocator alloc, Addr size);
> extern void Free(Allocator alloc, Addr base, Addr size);
> extern Addr GrainSize(Allocator alloc);
> extern unsigned GrainShift(Allocator alloc);
> extern Bool BaseOfAddr(Addr *baseReturn, Allocator alloc, Addr addr);

(BaseOfAddr returns the base address of the allocated block containing addr.)

Of course, this is very similar to both the pool and allocation buffer
interfaces.  How might we implement the segment allocation in these terms?


> typedef struct ArenaStruct *Arena;
>
> extern Error ArenaAllocate(Addr *baseReturn, Arena arena, Addr size);
> extern void  ArenaFree(Arena arena, Addr base, Addr size);
> extern Addr ArenaGrainSize(Arena arena);
> extern unsigned ArenaGrainShift(Arena arena);
> extern Bool ArenaBaseOfAddr(Addr *baseReturn, Arena arena, Addr addr);

[NOTE: GrainSize(a) == 1<<GrainShift(a]

A segment is now simply a region of memory allocated using ArenaAllocate, a
specialization of the generic allocate above.  The address map becomes a
mapping from an address to the base address of the allocated segment.

This is sufficient, but unsatisfactory.  Where would we keep information
about, say, the owing pool of a segment?  The only place for it would be in
the segment itself, because that is the placed mapped to by the BaseOfAddr
method.

Consider also how this interface might apply to cards.  We want to allocate
cards in much the same way as anything else, except that their granularity
is about the size of a page.  But the thing about cards is that we want to
store other information about them.  The only place to store that under
this interface is on the card itself, which does harm to our virtual memory
performance.

So perhaps there is a better generic interface:

> typedef struct BlockStruct *Block;
> typedef struct BlockStruct
> {
>   Allocator alloc;
>   Addr base;
>   Addr limit;
> } BlockStruct;
>
> extern Error Allocate(Block block, Allocator alloc, Addr size);
> extern void  Free(Block block);
> extern Addr GrainSize(Allocator alloc);
> extern unsigned GrainShift(Allocator alloc);
> extern Bool BlockOfAddr(Block *blockReturn, Allocator alloc, Addr addr);

In this scheme, the handle on the object is not a "void *", but a block
descriptor delimits the allocated memory.  This gives us a great deal more
flexibility.  For example:
  - the allocator can return rounded base and limit values
  - the block might be relocatable
  - the descriptor can be used as the "name" of the block.

Mostly, though, it solves the problem of how to associate data with the
allocated block.  We can use our "subclassing" mechanism to get at a parent
structure which owns the block:

> typedef struct FooStruct
> {
>   int foo;
>   int bar;
>   BlockStruct block;
>   int wibble;
> } FooStruct, *Foo;
>
> if(BlockOfAddr(&exampleBlock, alloc, addr)) {
>   foo = PARENT(Foo, block, exampleBlock);
>   etc.
> }

We already do this with segments to get "spans", but perhaps we could do
something similar with pages to get "cards", so CardOfAddr would be the
equivalent of looking up the card table entry from an address.

Er, that's about it really, except to say that if we find such an interface
useful internally, then we ought to provide it to our clients as well.

