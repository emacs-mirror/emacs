                           ANALYSIS OF PURIFY
                         rival.purify.analysis2
                               draft doc
                             drj 1995-11-24

Who should use it?

The intended market for Purify is (I guess) application developers.  It seems 
that is supposed to be used during the latter stages of development, when you 
have a product that stands a fair chance of running with no "obvious" bugs.  It 
is intended to discover memory usage errors; these include scribbling of the 
end of arrays, leaking allocated memory, attempting to free memory not 
allocated (freeing twice).

What is it like to use?

It is trivial to use, just put the word "purify" before your linker command, 
running the resultant program then invokes a purify "listener".  All the errors 
that purify detects are logged in the listener.  Each type of error has a cute 
3 letter code (FUM for Freeing Unallocated Memory, FMW for Free Memory Write, 
etc).  It works by tagging the heap with 2 extra bits (an allocated bit and an 
initialised bit), allocated heap blocks have "safety zones" around them, freed 
heap blocks are kept on a reserve list in order to detect memory references to 
them.  It finds all types of errors that you could reasonably expect to find 
using this method.  Stack frames have "safety zones" around them, but objects 
in the frame do not (which means it can only detect references of the end of a 
stack allocated array if they go beyond the stack frame as well).
My experience.  The listener (or viewer as they call it) runs like a dog, but 
then I'm not surprised as all serious X applications seem to.  The trivial test 
programs I ran through came up with no susprises, only minor annoyances 
(realloc(0,1) gives a PAR message, which is a warning, and it does note that 
this is valid under strict ANSI).  I tried purifiying two real programs:  rc - 
a shell - running its supplied test suite, and awk running a date format 
conversion script of my own devising on a small (10 line) file.  The results 
are slightly hard to interpret, mostly because I wasn't intimately familiar 
with the code.  There were memory leaks reported (not very large ones); I 
suspect that they were in fact pseudo-leaks.  To expand, purify is fascist and 
regards memory as leaked if it is not reachable upon exit.  If the only 
pointers to memory are automatic variables in main, and main returns (the 
variables going out of scope), then purify will report the memory as leaked 
even though you are just about to exit (usually).  It is possible to get round 
this by modifying the program to call "purify_new_leaks" just before returning 
from main.

Hacky internals

SPARC details.  Purify uses the global registers, some of which are designated 
in the Architecture Manual as "reserved for the application".  As far as I can 
tell, they simply rely on the C compiler not using these global registers.  All 
stores and loads are translated so that they indirect through a single global 
register (%g3 as it happens).  Another global register points to a jump table 
(for the type of operation) and the tag table.  A few other registers are used 
for miscellaneous (unknown) purposes.

Can we use it?

Hard.  Purify intercepts calls to malloc.  There are ways of using purify if 
you have a custom allocator, but they all boil down to modifying the custom 
allocator so that it calls malloc.  This is fine if your custom allocator acts 
essentially like malloc, but we do tricks with zones which would not be 
possible if we had to call malloc.

Conclusion

Pure have done a very complete job with Purify.  It's a tool that helps you 
debug your programs memory errors without changing your source code, it can 
therefore be deployed with existing software.  Pretty much the only serious 
thing it lacks is telling you _when_ memory was leaked, though you can get some 
idea by (as they suggest) stepping the program in a debugger and calling 
purify_new_leaks frequently.  I can think of a few ways of telling when memory 
was leaked (making write operations more expensive) and I don't see why they 
can't, so I wouldn't be surprised if a future version had an option to do 
this.  I don't believe there is much scope for improvement in this niche.  
There is, as Tucker points out in his earlier analysis 
(rival.purify.analysis.1), scope for different products.  There is little to be 
gained by deployment purify within the MM group.

