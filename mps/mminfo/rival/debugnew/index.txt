                          METROWERKS DEBUGNEW
                             rival.debugnew
                               draft doc
                           richard 1995-08-02

Documentation for DebugNew.cp
=============================

Date:    March 4, 1994
Author:  Dan Podwall

Introduction
````````````
 The DebugNew package provides a debugging layer over the standard operators
 new and delete. It can help to diagnose common errors associated with
 dynamically allocated memory.
 
 It provides the following services:

 - Zaps newly allocated and free blocks with bad values to detect uses
   of uninitialized or deallocated memory.
 
 - Addresses of blocks to be freed are checked to see if they are within
   the application heap.

 - Tags allocated blocks to detect double freeing, freeing unknown
   blocks, and overwriting past the end of a block.
 
 - A counter is incremented on allocations and decremented on frees.
   A warning is generated if there are more frees than allocs. You
   can inspect the counter as a crude check to see if any memory has
   leaked.
 
 - Tracks the current number of bytes allocated via operator new
   and the maximum number of bytes ever allocated. Useful for
   tuning memory management and determining a good size memory
   pool to pre-allocate at program startup.
 
 - Optionally tracks memory allocations and can report memory leaks.
   The source file and line is tracked for each allocation, and
   the list of allocated blocks can be dumped to a text file. Full use
   of this feature requires using the macro NEW instead of new in your
   source code. 
    
Using DebugNew, basic level
```````````````````````````
 To get the basic level of checking, all you need to do is add it your project.
 First, go to the "Access Paths" panel of the preferences dialog and add the
 "*DebugNew source" folder to the additional paths list. In 68K projects, you
 must use CPlusPlusDebug.lib, and add DebugNew.cp to your project. In PowerPC
 projects, just add DebugNew.cp to your project. You will get some linker
 warnings because DebugNew is overriding some runtime library routines.
 
 Doing this gives you all the above features except for full leak checking.
 
Enabling memory leak checking
`````````````````````````````
 To enable full leak checking, you must include DebugNew.h in every source
 file you want checked, or just make sure your project prefix includes it.
 Insert the line "#define DEBUG_NEW 2" either in your prefix, or add it
 to the DebugNew.h header.
    
 Every non-array usage of global operator new must be changed to use the macro
 NEW. For example, change:
 
  MyObject* obj = new MyObject;
 
 to:
 
    MyObject* obj = NEW MyObject;
    
 When leak checking is enabled, NEW expands to new(__FILE__,__LINE__). This
 is an overloaded form of operator new. When leak checking is disabled,
 NEW simply expands to new. Again, when leak checking is off, this
 expands to the normal operator new, so you can leave this in your
 final code and there is absolutely no overhead.
 
 If leak checking is enabled and the standard new is called, the block is
 still tracked, but the leak report will be missing source file and line
 information for that block. So, you could enable leak checking without
 using NEW. However, the information you get won't be useful enough to
 warrant the overhead.
 
 The NEW macro can't be used when allocating C++ arrays, since you can't
 provide a custom operator new for arrays. Support for tracking array
 allocations may be added in a future release (support was pulled because
 of a change in the runtime implementation of arrays). For now, leaked
 array allocations will appear in the leaks report, but without file and line
 information.
   
 Nothing special needs to be done when freeing objects. Just use the normal
 operator delete.

 Since the leak report uses stdio to write a text file, you must include
 the ANSI C library in your project. If you are not using C++ streams,
 just include the C version of the library. If you are using streams,
 then you need the C++ version of ANSI.
 
Disabling DebugNew
``````````````````
 If you are using the basic level of checking, and don't use the NEW macro,
 just replace DebugNew.cp/CPlusPlusNoNew.lib with CPlusPlus.lib. Or, you
 can just put "#define DEBUG_NEW 0" in your prefix. The result is the same.
 
 If you are using NEW, you must continue to include DebugNew.h in your source.
 Just put "#define DEBUG_NEW 0" in your prefix or at the top of DebugNew.h.
 
Error Reporting
```````````````
 Errors are reported in two ways. When a validation check occurs at runtime,
 an error handler routine is called. The default routine just issues a
DebugStr()
 call with a diagnostic message. If you prefer different behavior, you can
 provide your own error handler by calling DebugNewSetErrorHandler(). 
Validation
 errors occur when operator delete is called, or when your code calls
 DebugNewValidatePtr() or DebugNewValidateAllBlocks().
 
 Memory leaks are reported via the file "leaks.log". This file is written to the
 application's directory whenever DebugNewReportLeaks() is called. One possible
 approach is to call it as the last statement in main(), before your application
 exits.
 
Limitations
```````````
 - By default, DebugNew only works for the global operator new. However,
   if your class-specific operator new calls the global operator new, then
   those allocations will be tracked.

 - DebugNew does not attempt to do anything when an allocation fails.
   That is what set_new_handler() is for.

Overhead
````````
Both the basic checking and memory leak checking add overhead to your
program. You
generally would only enable it for internal testing.

Basic checking adds 12 bytes to each allocated block, and slows down each
new/delete
only slightly.

Leak checking increases the per block overhead to 24 bytes. There is also
the overhead of finding and removing each block from a linked list when
it is deleted. The memory and time hit will be noticable on moderate to
large programs. Leak testing should generally only be enabled periodically to
clean up leaks, and then turned off again.

