                         MICROQUILL'S SMARTHEAP
                            rival.smartheap
                               draft doc
                           richard 1995-08-17

.overview: SmartHeap (MicroQuill) is a heap manager that replaces that supplied 
by the C/C++ compiler vendors.  The main selling point is that SmartHeap is 
three times faster, especially when memory is tight and swapping occurs, when 
it is claimed to be up to 100 times faster.  SmartHeap also offers a "debug 
mode" in which it can detect simple misuses of memory, and memory leaks.  
SmartHeap has a limited ability to support multiple memory "pools", and has two 
allocation policies.  These contribute to its efficiency.  Notably, SmartHeap 
does _not_ offer any tools to assist with tuning performance.  The run-time 
part of SmartHeap ships with the developer's application, royalty-free.  
SmartHeap is available on Windows NT, Windows 95, Windows 16-bit, DOS, OS/2 
Warp, Mac, Digital UNIX, Tru64 UNIX, HP-UX, AIX, IRIX, UnixWare, Solaris, and 
SunOS 4.

.web: <URL:http://www.microquill.com/prod_sh/index_sh.htm>

.simpson:

Thanks for your interest in SmartHeap.  This following is an 
ASCII text version of our technical brochure. While ASCII works
well for email, it is limiting with regard to formatting and 
non-text (graphic) output.  This is especially noticeable in our 
benchmark graphs where we have only provide the Windows benchmark 
in this document.  For best results reading this document use the DOS 
command 
     edit filename. 

If you included your address with your email, we will be 
mailing a printed (and formatted) version of this document to you 
along with other supporting materials. If you would like to receive 
reprints of review articles, printed price lists, additional
benchmark graphs or answers to specific questions, or any of 
this information in Word for Windows or Postscript binary format,
please contact MicroQuill at 800 441 7822 or 206 525 8218, or at 
devtools@microquill.win.net.  

Thanks again for your interest, I look forward to hearing from you 
soon. 

Regards, 

Mike Simpson
MicroQuill

       Here's What Users Are Saying About SmartHeap v.2.0...
  
   "Here's another essential [tool] that is virtually 
   unnoticeable once you've added it, yet it saves you 
   and your customers time.  In debugging mode SmartHeap 
   performs every form of error checking that I know of 
   (and I did write a book on this).  The allocation 
   routines in SmartHeap are faster than those in the 
   Visual C++ run-time library.  And SmartHeap really 
   shines as your app's memory gets swapped to disk.  
   What I like about SmartHeap is that you can add the 
   code...and then forget that it's there until it 
   points out a bug to you.  Or when a user compliments 
   you on how fast your app is."
                                   David Theilen
                                   Microsoft System Journal
                                   March, 1994

   "This is my first testimonial in four years; rarely do 
   I run across a programming tool that so completely 
   solves a problem that I cannot imagine how we could 
   have done without it.  After looking at these bugs, 
   I am certain that they would have blown up during Beta, 
   would have been impossible to reproduce, and would have 
   caused an extremely painful delay in our product release.  
   My deepest gratitude goes to everyone involved with 
   producing and supporting SmartHeap for playing such a 
   key role in our success.  Without SmartHeap, we would 
   have missed this Mother of all drop-deadlines."
                                   Warren Stringer
                                   TestDrive Corporation
                                   November 2, 1993

   "Relinking with SmartHeap v.2.0 improved the overall 
   performance of Lucid 3-D for Windows by 67%--and many 
   operations are literally 40-50 times faster.  SmartHeap 
   is an exceptionally well designed product."
                                   Robert Duffy
                                   Lucid Corp.
                                   November 2, 1993

   "Why did we buy SmartHeap?? Because it provides an 
   exceptionally fast, thread-safe, error-detecting 
   malloc/new library that supports all the platforms on 
   which we want to ship, including Windows and UNIX.  
   We tested SmartHeap on advanced RDBMS cases which 
   required over 3 million calls to malloc--and the last 
   malloc was just as fast as the first.  If your code is 
   malloc or new intensive, you can't afford not to use 
   SmartHeap." 
                                   Larry Stilwell
                                   Sextant Corp.
                                   March 29, 1994

   "We were faced with a heap corruption problem that 
   had to be solved that day.  Just by linking in 
   SmartHeap we found that the 3rd party code we were 
   using incremented the pointer to an allocated block 
   and we were calling free with an invalid pointer!  We 
   had planned to just use SmartHeap for debugging, but 
   liked it so much we ship it with the retail version."
                                   Mark Bowers
                                   Cypress Software Inc.
                                   March 28, 1994

   "The library you sent me has proven to be rock-solid 
   and blazingly fast.  Damn good work!"
                                   Todd Williams
                                   Mobil R&D
                                   November 11, 1993

   "SmartHeap v.2.0's capability to detect memory overwrites 
   and leakage have been a big benefit.  It plugs in easily 
   and performs like a champ when swapping virtual memory 
   where other suballocators degrade significantly.  If you're 
   writing a serious application you MUST use SmartHeap for 
   memory management."
                                   Mike Griffin 
                                   MECA Software, Inc.
                                   October 19, 1993

   "Sometimes a big file in our Windows product "Timing Designer" 
   would read in 8.5-9 seconds, but after you used the application 
   for awhile it would go up to 50...60...70 seconds.  After we 
   linked with SmartHeap, the read time stabilized at 8 seconds, 
   no variation whatsoever.  Then, by tuning the app with a couple 
   of fixed size heaps, I was able to shave off another 1.3 seconds.  
   I think its great!"
                                   Mike Meredith
                                   Chronology Corp.
                                   August 27, 1993

   "By merely relinking with SmartHeap and changing our .mak 
   file in our OS/2 2.x application, we got an instant 50% 
   overall performance improvement."
                                   Dave Middleton
                                   Trilogy
                                   March 25, 1994

   "Sure, you could probably roll your own memory manager 
   for Windows.  But, SmartHeap offers a *fast*, robust, and 
   most importantly, *fully debugged* memory manager for a 
   fraction of the time, effort, and money."
                                   Steven Antoch
                                   Arcland
                                   March 22, 1994

   "We've been shipping with SmartHeap for over 18 months--and 
   we have not found or even heard about a single bug. That's 
   reliability!"
                                   Rick Williamson 
                                   FarPointe Technologies
                                   November 4, 1993

   "Even when not in low memory conditions, we found that for 
   test cases that involved large numbers of small objects, 
   the performance of the application with SmartHeap v.2.0 was 
   MUCH better.  We are pleased with the choice of SmartHeap 
   and have adopted it as our default heap manager."
                                   Ken Burgett
                                   Xerox Group Communications
                                   September 13, 1993

   "TrackRecord used to thrash due to the design of the 
   compiler-supplied allocator.  We plugged in SmartHeap and 
   the problem was solved!  TrackRecord now shines in all 
   memory situations.  I highly recommend it!"
                                   David Nanian
                                   Underware, Inc.
                                   October 29, 1993


All trademarks and tradenames used herein are the property of 
their respective owners.  SmartHeap is a trademark of MicroQuill 
Software Publishing, Inc.(c) 1993 MicroQuill Software Publishing, Inc.



Overview:
=========
Industry leaders at WordPerfect, Lotus, Sybase, Hewlett Packard, 
Symantec, Microsoft, Informix, Knowledgeware, Intersolv, Xerox, 
Traveling Software, and many others know memory management can 
impact an application's performance and reliability more than 
any other factor.  They rely on SmartHeap for this critical 
facility.  Why?  Because SmartHeap is the fastest, most portable, 
and most reliable allocator; plus, it includes complete heap 
error detection facilities.

  Speed
  -----
   In C and C++ applications running on virtual memory systems, 
   malloc and operator new impact performance more than any other 
   factor.  SmartHeap's proprietary algorithms deliver unparalleled 
   malloc/new performance in Windows, UNIX (Sun, HP, etc.), OS/2, NT, 
   Extended DOS and Macintosh.  Benchmarks show that SmartHeap is 3X-
   100X faster.  You can achieve even better results by using 
   SmartHeap's malloc/new to automatically route small allocations
   below a parameterized threshold to an extremely fast fixed-size 
   allocator.  SmartHeap also provides multiple memory pools to 
   improve locality and further eliminate fragmentation.
   
  Error Detection
  ---------------
   SmartHeap does not stop with blazingly fast performance.  It 
   also provides the most complete heap error detection available.  
   Memory bugs are typically the most insidious, spurious and 
   damaging bugs an application faces.  Because SmartHeap controls 
   and manages the heap, it can detect bugs other add-on 
   debugging tools miss.  In addition to better detection, SmartHeap
   uses its knowledge of the heap to provide unsurpassed detail 
   about each error's cause.  Bugs SmartHeap detects include: 
   leakage, memory overwrites, double-freeing, wild pointers, 
   invalid parameters, out of memory, references to previously freed
   memory, etc. 

  Portability 
  -----------
   In addition to outstanding speed and complete error detection, 
   today's memory manager must be easily portable.  SmartHeap 
   ships as a binary linkable library for DOS, Windows, NT, Mac, 
   OS/2, UNIX, etc.  Each version provides an identical API, but 
   is specifically optimized for that particular environment. 
   Finally, SmartHeap's malloc and new are strictly ANSI compliant,
   so you do not have to code to a proprietary API to realize 
   SmartHeap's benefits. 


  Reliability
  -----------
   Finally, because SmartHeap is a runtime library product, it 
   must deliver absolutely bullet-proof reliability.  To ensure 
   the ultimate in error-free operation, we built a certification 
   tester which calls each of the SmartHeap API's hundreds of 
   thousands of times.  This tester actually includes more lines 
   of code than SmartHeap and was designed to comprehensively 
   test all possible conditions SmartHeap might face, thus 
   proving that all the bugs are out. 

The bottom line.... SmartHeap is guaranteed faster, more reliable, 
more portable, and more complete in its heap error detection than 
ANY memory manager you are using -- or your money back. 

Performance
===========
Today's applications, especially those written in C++, tend to 
be more memory intensive than ever before.  It is not uncommon 
for an app to allocate hundreds of thousands, or even millions, 
of small blocks.  This intensive memory management activity 
typically fragments the heap and overwhelms most allocators.  
In fact, many commercial allocators (including those for
Extended DOS, Windows, NT, Mac and even UNIX) "hit the wall"
when attemting to manage even modestly large heaps.

Application performance degrades further when the heap cannot 
be located entirely in physical memory.  While virtual memory 
provides a larger address space, calls to malloc or free in a 
virtual memory heap are expensive due to disk hits.  Because 
disk hits are tremendously slow (20,000X slower) relative to
calls to physical memory addresses, it is not uncommon for an
app to run up to 10X slower in virtual memory.

SmartHeap was designed to perform well in physical memory and in 
situations when total allocations exceed currently available 
physical memory, so its performance doesn't degrade even as heap 
sizes grow very, very large (see benchmarks on following pages). 
Several innovation design characteristics drive this performance:

*    SmartHeap is smarter than other mallocs and operators new.  
     Like most other allocators, it goes directly to the operating 
     system for large blocks of memory and then sub-allocates.  
     However, SmartHeap maintains an ancillary index which tracks 
     the largest free block in each heap's pages.  When allocating,
     SmartHeap searches this index and touches on the page(s)
     where it knows the allocation will succeed. So, rather than 
     searching randomly through the entire heap of tens of 
     thousands of small free blocks, Smartheap goes directly 
     to a page with sufficient space, and then searches among (at 
     most) hundreds of free blocks in that page. 

     While this smart index improves performance in physical 
     memory, it maximizes benefits when the heap resides on disk.  
     Traditional allocators often generate many needless (and 
     expensive) page faults by swapping in pages only to find 
     that they don't a free block large enough.  (With such 
     allocators, it is not uncommon for a single call to malloc to 
     generate 100 or more page faults before finding an 
     appropriately large free block.)  SmartHeap avoids this 
     needless swapping by going directly to a page where it knows 
     the allocation will succeed, producing performance 
     improvements of 100X+. 

*    De-allocation (free/delete) is also extremely fast because 
     SmartHeap maintains special bits in the block headers that 
     indicate whether adjacent blocks are free.  With each 
     free/delete, SmartHeap checks this header information and 
     coalesces adjacent free blocks where possible.  This technique
     is faster and more efficient than either a free list traversal
     or maintaining a doubly-linked list of free blocks. 

*    SmartHeap's malloc is more intelligent in that it can 
     allocate both fixed and variable-size blocks. You merely 
     set a parameter below which the allocation is routed to a 
     fixed-size allocator and above which it goes to a 
     variable-size allocator. You get the benefits of an 
     extremely fast fixed-size allocator for small allocations
     and the efficiency of a variable-size allocator for 
     large requests, without any code changes. You just call
     the regular new or malloc.

*    For those that need a handle-based allocator, SmartHeap 
     implements double-indirection handles.  The memory is 
     moveable so fragmentation is eliminated, but you can access 
     the memory very efficiently by de-referencing the handle 
     as a pointer, thereby  eliminating a performance degrading
     functional call.  This is the best of both worlds (speed
     and space) and was previously available only on the 
     Macintosh.

*    With SmartHeap 2.0,  overhead per allocation is quite 
     small, ranging from 0-2 bytes for fixed-size allocations 
     to 2-8 bytes (depending on the platform) for variable-size 
     allocations.  SmartHeap incurs  16-32 bytes (depending 
     on the platform) of overhead for each 4-64K "page" it
     manages.  Plus, SmartHeap aligns its pages exactly with 
     the pages managed by the operating system to avoid 
     unnecessary swapping. 
                           

Benchmarks: Blazingly Fast Performance
======================================

How Important is Malloc/Free Speed?
-----------------------------------
Consider a typical application which spends 40% of its total execution
time managing memory and takes 10 minutes to run.  The table below 
shows the impact of a faster memory management library on this 
application.  

  SPEEDUP TO         TIME IN          TOTAL APP         % SPEEDUP
  malloc/new        malloc/new          TIME             TO APP
  ----------        ----------        ---------         ---------   
 no change (1X)     4 minutes        10 minutes             0%
    1.5X           3.6 minutes       9.6 minutes            4%
     2X             2 minutes         8 minutes            20%
     4X             1 minutes         7 minutes            30%
     10X           .4 minutes        6.4 minutes           36%
    100X          .04 minutes       6.04 minutes         39.6%

Note that even a 4X improvement in malloc can result in a 30% 
overall application performance improvement -- and remember that 
SmartHeap is generally a minimum of 4X faster than other commercial 
allocators and requires just a relink to implement.  

Why Apps "Hit The Wall"
-----------------------
Operating on a 4MB, 33 MHz 386, running Enhanced Mode Windows 3.1, 
we timed a single call to malloc in an empty heap.  This call took 
110-116 microseconds each for Microsoft, Borland, and 
SmartHeap -- all very fast.  Then we generated 49,999 random calls 
to malloc, realloc, and free, using blocks varying randomly between 
8-100 bytes.  We again measured the average time for a single 
call to malloc.  The time required for the 50,000th call to malloc?  
6.1 seconds (or 36,000X slower) for Microsoft;  9.6 seconds (or 
87,000X slower) for Borland; and just .08 seconds for SmartHeap.

Benchmark Descriptions:
-----------------------
The benchmark below compares SmartHeap to the major compiler 
malloc libraries on a Windows based '486.  The benchmarks are 
designed to model a C or C++ application in a "steady state" of 
randomly calling both malloc and free, or new and delete.  Note: 
Applications which initially allocate all of their memory and do 
little or no subsequent allocation will not see substantial 
performance improvements because traditional malloc implementations 
are fast when allocating into a totally empty heap.

The benchmarks measure the time required to call malloc, realloc, 
and free a predefined number times using blocks varying randomly 
in size between 8 and 100 bytes.  All benchmarks show allocations 
initially in physical memory, and progress to environments where 
allocations exceed currently available physical memory.  

In the graphs, the SmartHeap result is represented with a value 
of "1."  The other allocator's results are shown as multiples of 
SmartHeap result.  The actual elapsed times are shown below  
each bar and the quantity of memory allocated is listed below 
each test case.  Note that in all cases, SmartHeap's standard malloc 
is faster, and in cases where allocations exceed currently 
available physical memory, SmartHeap is often more than 100X faster. 

Because benchmark graphs don't lend themselves to ASCII text 
representation, we have only included the Windows graph in this 
text file.  However, we have graphs for all of the platforms we 
support including benchmark graphs demonstrating the outstanding 
performance improvement using multiple memory pools.  We would be 
happy to fax or mail them to you.  Please call MicroQuill at 
800 441 7822 if you would like to see benchmarks for another platform.  


                    SmartHeap 2.0 for Windows                           

Test was performed on a                        XXXBXXX Borland: off 
4 MB, 33 mhz '486 SX                 B            B    the scale, 
running Windows 3.1                  B            B    68X slower 
                                     B          M B    than SmartHeap.
SmartHeap: S                         B          M B
Microsoft: M                       M B          M B
Borland:   B                       M B          M B
                                   M B          M B
Time, expressed as a multiple      M B          M B
of the SmartHeap result.           M B          M B
SmartHeap = 1. Actual elapsed      M B          M B
times listed below.                M B          M B
                                   M B          M B
        B            B             M B          M B
        B            B             M B          M B
        B            B             M B          M B
      M B          M B             M B          M B
      M B          M B             M B          M B
    S M B        S M B           S M B        S M B
 15000 calls   25000 calls    45000 calls   60000 calls 
  (791 KB)      (1.1 MB)       (2.3 MB)     (3.06 MB)
SH 2.5 sec       6 sec          132 sec       636 sec
MS   8 sec      21 sec         1830 sec     10745 sec
BD  15 sec      41 sec         2398 sec     43296 sec


Portability
===========
SmartHeap provides portability to a broad set of platforms from a 
single, ANSI C compliant source code base.  Compilers from 
Microsoft, Borland, IBM, Watcom, Metaware, SUN, HP, 
Symantec/Zortech, and others are supported.  

Platform-specific binary versions ready to be quickly and easily 
linked directly into an application are available for DOS, 
Extended DOS, Macintosh, Windows, NT/Win32s, OS/2, Unixware, 
SunOS, Sun Solaris, IBM AIX, HP-UX, SGI, etc.  Source code 
licenses are also available for all of these platforms and 
include the necessary .mak files for that specific platform.  

To maximize performance and efficiency, we isolated all platform 
dependencies into a single module of SmartHeap.  This module is 
carefully tuned for each platform using manifest constants to 
control such architecture-sensitive variables as alignment, 
system page size, pointer size and integer size.  The following 
examples illustrate how SmartHeap is carefully tuned for 
each platform:

*   The 16-bit X86 version of SmartHeap uses near pointers 
    internally on intra-segment references to minimize 
    segment loads; this difference is abstracted out of 
    32-bit versions where there is only one pointer size.

*   The RISC version keeps all data strictly 4-byte aligned, 
    while the X86 versions keep infrequently referenced 
    data 2-byte aligned to save space.

*   SmartHeap implements different policies of global heap 
    management depending on the operating system's memory 
    architecture -- e.g. segmented (16-bit DOS and Windows), 
    flat sparse (OS/2 and NT), and flat contiguous (UNIX 
    and Phar Lap 386).

*   On operating systems that run in 16-bit X86 protected 
    mode (extended DOS and 16-bit Windows), SmartHeap 
    minimizes selector consumption to ensure that selectors 
    are not exhausted while there is still available memory.

*   For virtual memory operating systems, SmartHeap always 
    allocates from the operating system in an appropriate 
    multiple of the system page size, and sub-allocates 
    on pages that are exactly aligned with the underlying 
    system pages.  This ensures that the heap itself 
    requires a minimal working set and reduces page swapping.

*   Native error checking is possible in addition to the 
    portable error checking -- for example parameter 
    validation is more reliable since memory addresses are 
    validated.  For some platforms (currently Windows 3.x, 
    NT, OS/2, and Extended DOS), native I/O is provided 
    so that error messages are displayed graphically or 
    integrated with native debugging tools.  Users can 
    integrate SmartHeap with other debuggers platforms 
    not mentioned above.

*   For those Operating Systems which provide multi-threading, 
    (NT, OS/2 2.x, HP-UX, Solaris 2.x) SmartHeap is fully 
    thread-reentrant.  

It is relatively straight-forward to compile SmartHeap on 
platforms and operating systems for which MicroQuill has not 
yet provided integration.  Please contact MicroQuill for 
pricing and support details.

Debugging and Error Detection Features
======================================

In addition to incredible runtime performance, SmartHeap provides 
the most complete heap error detection available.  Because 
SmartHeap "owns" the heap, it not only detects more errors, but 
provides greater detail about each error than that provided by 
other "add-on" memory debuggers.  

As SmartHeap's debugging version allocates each block, it keeps 
track of the following information:

*   The SmartHeap API that created the object (e.g. MemallocPtr 
    or malloc).

*   The filename, line number, and pass count where the object 
    was allocated.  This information allows you to set a 
    breakpoint at the nth pass over the line at the exact 
    allocation spot -- both lexically and in time -- where the 
    allocation occurs.  It also enables you to track any 
    SmartHeap allocated object from its creation and follow that 
    object's life in the debugger to the point where an error 
    occurs.  Many memory error detection facilities will report 
    the file and line where errors are detected and/or where 
    objects were allocated to help track down memory overwrites 
    or leaks,  but in many situations, this information is of 
    little use because control passes through the given file/line 
    for many different reasons.  This is why SmartHeap records 
    and reports a pass count as well as a file and line.  

*   An allocation count that uniquely identifies it from all 
    other allocations in that process.

*   A checkpoint -- the group in the pool identifying the 
    context of its allocation.

*   The actual requested size and any flags used in creation 
    of the object -- so that the exact parameter to the 
    allocation call can be reported at any time in the future.

*   A checksum used if the block is marked as read-only.

The SmartHeap debug library provides three levels of error 
detection thoroughness, from simple to very exhaustive.  
dbgMemSafetyLevel controls how much time SmartHeap spends 
performing error checking.  The three "safety levels" are:  

*   MEM_SAFETY_SOME, the lowest level, performs only checks 
    that are O(c), such as validating parameters and checking 
    guards for overwrites;

*   MEM_SAFETY_FULL, the default, performs additional O(n) 
    checks such as scanning free-lists to detect double-freeing.

*   MEM_SAFETY_DEBUG checks the entire heap on every SmartHeap 
    entry-point--making it O(n2).

When an error is detected, the following information is reported:

*   The API/file/line/pass count of the call that detected 
    the error.

*   The creation API/file/line/pass count, checkpoint, and 
    allocation count of the object that was corrupted, if 
    applicable.

*   The API/file/line/pass count where the object was last 
    known to be "OK" (e.g. not overwritten).

*   The memory address where the corruption was detected, 
    and if the address is valid, a hex and character memory dump 
    of the contents of the corrupted location.

Errors are reported by any combination of the following (user 
can specify which):

*   A prompt to the user interface (message box or 
    command-line prompt depending on the platform), where user 
    can abort/retry/ignore.

*   Output to debugging console (secondary monitor or debugger 
    log window).

*   Output to log file that is closed after each error to 
    ensure no information is lost if the application crashes.

*   User-defined error handler that takes control of I/O 
    and handling.

*   User-defined tracing of entry/exit of all SmartHeap APIs.

SmartHeap 2.0 detects the following errors:

*   Overwrites before or after an allocated block.  
    SmartHeap detects an overwrite one byte beyond requested 
    size, even if the block's actual size is larger than 
    requested.  Users can set the size and value of "guards" 
    that are placed before and after every allocation, 
    including fixed-size allocations 

*   Overwrites over any internal heap data structures.

*   Leakage.  A complete leakage reporting facility is 
    present.  Users can group or "checkpoint" allocations 
    and find and report all blocks not freed in one or 
    more groups.

*   Invalid parameters.

*   Out of memory.

*   Double freeing, writes, or references to previously 
    freed memory.  The option exists to defer freeing memory 
    so that double freeing is guaranteed to be caught.  
    Normally, free blocks are recycled at the next allocation, 
    so writing to a previously freed block often overwrites 
    data in another part of an application where the block 
    is now in use again.

*   References to non-shared memory owned by a different task.

*   Writes into free memory.  Free blocks are always filled 
    with a unique pattern; SmartHeap thus detects a write 
    into any byte of any free block.

*   Exceeding pool size ceiling established by 
    MemPoolSetCeiling.  This function allows an application 
    to constrain its own memory resource consumption.

*   Overwrites over handle table.

*   Invalid flags or buffer parameters.

*   Modifying a block marked as "read-only."  Individual 
    blocks can be marked as read-only, and modifying the 
    contents is detected along with other overwrites.

*   Freeing/reallocing a block marked as "nofree" or 
    "norealloc."  A block that should not be freed during 
    some stretch of a program can be marked as such, and 
    SmartHeap will report as an error any attempt to 
    free/realloc the block.

For an example of error detection and reporting, see attached 
sample program and output "TESTDBG.C" and "TESTDBG.OUT"

TESTDBG.C
=========
Simple test case for debug version of SmartHeap v.2.0
(Error Output Follows)
  1 
  2 
  3 
  4 
  5 /* Note: the SmartHeap header file must be included _after_ any files that
  6  * declare malloc et al
  7  */
  8 #include "smrtheap.h"
  9 #include "shmalloc.h"
 10 
 11 #ifndef MEM_DEBUG
 12 #error shtestd.c must be compiled with MEM_DEBUG defined
 13 #endif
 14 
 15 #define TRUE 1
 16 #define FALSE 0
 17 
 18
 19 
 20 int main()
 21 {
 22     MEM_POOL pool;
 23     unsigned char *buf;
 24     int i;
 25     unsigned char c;
 26 
 27     dbgMemSetSafetyLevel(MEM_SAFETY_DEBUG);
 28     dbgMemSetDefaultErrorOutput(DBGMEM_OUTPUT_PROMPT | DBGMEM_OUTPUT_CONSOLE
 29             | DBGMEM_OUTPUT_FILE, "shtestd.out");
 30 
 31     pool = MemPoolInit(0);
 32     dbgMemPoolSetCheckFrequency(pool, 1);
 33     dbgMemPoolDeferFreeing(pool, TRUE);
 34     dbgMemPoolSetCheckpoint(pool, 1);
 35 
 36     buf = MemallocPtr(pool, 3, 0);  /* this allocation never freed 
(leakage) */
 37 
 38     /* invalid buffer */
 39     MemPoolInfo(pool, NULL, NULL);
 40 
 41     /* invalid pointer parameter */
 42     MemFreePtr((void *)ULONG_MAX);
 43 
 44     /* underwrite */
 45     c = buf[-1];
 46     buf[-1] = 'x';
 47     MemCheckPtr(pool, buf);
 48     buf[-1] = c;
 49 
 50     /* overwrite */
 51     buf = MemallocPtr(pool, 3, 0);  /* more leakage */
 52     c = buf[3];
 53     buf[3] = 'z';
 54     MemCheckPtr(pool, buf);
 55     buf[3] = c;
 56 
 57     dbgMemPoolSetCheckpoint(pool, 2);
 58     
 59     /* write into read-only block */
 60     buf = MemallocPtr(pool, 10, MEM_ZEROINIT);  /* more leakage */
 61     *buf = 'a';
 62     MemCheckPtr(pool, buf);
 63     dbgMemProtectPtr(buf, DBGMEM_PTR_READONLY);
 64     *buf = 'b';
 65     MemCheckPtr(pool, buf);
 66     *buf = 'a';
 67     dbgMemProtectPtr(buf, DBGMEM_PTR_NOFREE | DBGMEM_PTR_NOREALLOC);
 68     free(buf);
 69     realloc(buf, 44);
 70 
 71     /* double free */
 72     buf = malloc(1);
 73     dbgMemPoolDeferFreeing(MemDefaultPool, TRUE);
 74     dbgMemPoolSetCheckFrequency(MemDefaultPool, 1);
 75     for (i = 0;  i < 3;  i++)
 76             MemFreePtr(buf);
 77 
 78     /* write into free block */
 79     c = *buf;
 80     *buf = 'a';
 81     calloc(1, 3);
 82     *buf = c;
 83 
 84     dbgMemReportLeakage(pool, 1, 2);
 85
 86     return 1;
 87 }

SmartHeap Error Output from SHTESTD.C
=====================================

MEM_BAD_BUFFER: Invalid buffer parameter.
    Error detected in: MemPoolInfo(01DF:0000, 0000:0000, 0000:0000)
        at line 39 of file shtestd.c, pass #1
    Parameter is NULL pointer.

MEM_BAD_POINTER: Invalid memory pointer parameter.
    Error detected in: MemFreePtr(FFFF:FFFF)
        at line 42 of file shtestd.c, pass #1
    Error at or near address FFFF:FFFF which contains:
        <illegal address>

MEM_UNDERWRITE: Memory before beginning of allocated block overwritten.
    Error detected in: MemCheckPtr(01DF:0000, 01E7:7FF0)
        at line 47 of file shtestd.c, pass #1
    Object created by: MemallocPtr(01DF:0000, 3, 0x0)
        at line 36 of file shtestd.c, pass #1
        checkpoint 1, alloc #1
    Error at or near address 01E7:7FEF which contains:
        78 EB EB EB FC FC FC FC-FC 03 00 14 00 14 00 00   x...............
    Pool last verified in: MemPoolInfo
        at line 39 of file shtestd.c, pass #1

MEM_OVERWRITE: Memory after end of allocated block overwritten.
    Error detected in: MemCheckPtr(01DF:0000, 01E7:7FC8)
        at line 54 of file shtestd.c, pass #1
    Object created by: MemallocPtr(01DF:0000, 3, 0x0)
        at line 51 of file shtestd.c, pass #1
        checkpoint 1, alloc #2
    Error at or near address 01E7:7FCB which contains:
        7A FC FC FC FC 2B 00 00-00 01 00 03 00 00 00 01   z....+..........
    Pool last verified in: MemallocPtr
        at line 51 of file shtestd.c, pass #1

MEM_READONLY_MODIFIED: Memory block marked as read-only was written to.
    Error detected in: MemCheckPtr(01DF:0000, 01E7:7F98)
        at line 65 of file shtestd.c, pass #1
    Object created by: MemallocPtr(01DF:0000, 10, 0x0)
        at line 60 of file shtestd.c, pass #1
        checkpoint 2, alloc #3
    Error at or near address 01E7:7F98 which contains:
        62 00 00 00 00 00 00 00-00 00 FC FC FC FC FC FC   b...............
    Pool last verified in: dbgMemProtectPtr
        at line 63 of file shtestd.c, pass #1

MEM_NOFREE: Attempt to free memory block marked as no-free.
    Error detected in: free(01E7:7F98)
        at line 68 of file shtestd.c, pass #1
    Object created by: MemallocPtr(01DF:0000, 10, 0x0)
        at line 60 of file shtestd.c, pass #1
        checkpoint 2, alloc #3
    Error at or near address 01E7:7F98 which contains:
        61 00 00 00 00 00 00 00-00 00 FC FC FC FC FC FC   a...............

MEM_NOREALLOC: Attempt to realloc memory block marked as no-realloc.
    Error detected in: realloc(01E7:7F98, 44)
        at line 69 of file shtestd.c, pass #1
    Object created by: MemallocPtr(01DF:0000, 10, 0x0)
        at line 60 of file shtestd.c, pass #1
        checkpoint 2, alloc #3
    Error at or near address 01E7:7F98 which contains:
        61 00 00 00 00 00 00 00-00 00 FC FC FC FC FC FC   a...............
 
MEM_DOUBLE_FREE: Free memory block referenced.
    Error detected in: MemFreePtr(01F7:7FF0)
        at line 76 of file shtestd.c, pass #2
    Object created by: malloc(1)
        at line 72 of file shtestd.c, pass #1
        checkpoint 1, alloc #4
    Error at or near address 01F7:7FF0 which contains:
        DD DD DD DD DD DD DD DD-03 00 14 00 14 00 00 00   ................

MEM_DOUBLE_FREE: Free memory block referenced.
    Error detected in: MemFreePtr(01F7:7FF0)
        at line 76 of file shtestd.c, pass #3
    Object created by: malloc(1)
        at line 72 of file shtestd.c, pass #1
        checkpoint 1, alloc #4
    Error at or near address 01F7:7FF0 which contains:
        DD DD DD DD DD DD DD DD-03 00 14 00 14 00 00 00   ................

MEM_FREE_BLOCK_WRITE: Free memory block was written to.
    Error detected in: calloc(3, 0)
        at line 81 of file shtestd.c, pass #1
    Object created by: malloc(1)
        at line 72 of file shtestd.c, pass #1
        checkpoint 1, alloc #4
    Error at or near address 01F7:7FF0 which contains:
        61 DD DD DD DD DD DD DD-03 00 14 00 14 00 00 00   a...............
    Pool last verified in: MemFreePtr
        at line 76 of file shtestd.c, pass #1

MEM_LEAKAGE: Memory block has not been freed.
    Error detected in: dbgMemReportLeakage(01DF:0000, 1, 2)
        at line 84 of file shtestd.c, pass #1
    Object created by: MemallocPtr(01DF:0000, 10, 0x0)
        at line 60 of file shtestd.c, pass #1
        checkpoint 2, alloc #3
    Error at or near address 01E7:7F98 which contains:
        61 00 00 00 00 00 00 00-00 00 FC FC FC FC FC FC   a...............

MEM_LEAKAGE: Memory block has not been freed.
    Error detected in: dbgMemReportLeakage(01DF:0000, 1, 2)
        at line 84 of file shtestd.c, pass #1
    Object created by: MemallocPtr(01DF:0000, 3, 0x0)
        at line 51 of file shtestd.c, pass #1
        checkpoint 1, alloc #2
    Error at or near address 01E7:7FC8 which contains:
        EB EB EB FC FC FC FC FC-2B 00 00 00 01 00 03 00   ........+.......

MEM_LEAKAGE: Memory block has not been freed.
    Error detected in: dbgMemReportLeakage(01DF:0000, 1, 2)
        at line 84 of file shtestd.c, pass #1
    Object created by: MemallocPtr(01DF:0000, 3, 0x0)
        at line 36 of file shtestd.c, pass #1
        checkpoint 1, alloc #1
    Error at or near address 01E7:7FF0 which contains:
        EB EB EB FC FC FC FC FC-03 00 14 00 14 00 00 00   ................


Summary of SmartHeap 2.0 Functions
==================================
Task Registration
-----------------
MemRegisterTask      Registers current task or process with SmartHeap.
MemUnregisterTask    Unregisters the current task or process from 
                     SmartHeap Memory Pools
MemPoolInit          Allocates and initializes a memory pool to store 
                     variable-sized and/or fixed-size blocks.
MemPoolInitFS        Allocates and initializes a memory pool, and 
                     pre-allocates specified count of fixed-size blocks.
MemPoolFree          Returns all memory in a memory pool to the 
                     operating system in one fast operation.
MemPoolSetPageSize   Establishes the size of pages within which 
                     SmartHeap sub-allocates.
MemPoolSetBlkSizeFS  Establishes the threshold below which allocation 
                     requests are routed to the fixed-size memory 
                     manager -- allows small blocks to be allocated 
                     very quickly.
MemPoolSetFloor      Establishes the minimum size to which SmartHeap 
                     will ever shrink the pool.
MemPoolSetCeiling    Establishes the maximum size of a memory pool -- 
                     SmartHeap won't allow the pool to consume more 
                     system memory than the ceiling.
MemPoolPreAllocate   Reserves the specified number of bytes for 
                     future allocations from the memory pool.
MemPoolShrink        Packs and defragments the handle based memory in 
                     the pool, returning memory not currently in use 
                     to the operating system.
MemPoolCount         Returns the net count of allocations from a 
                     memory pool.
MemPoolSize          Returns the total number of bytes of memory 
                     allocated within a memory pool.
MemPoolInfo          Obtains information about a memory pool.
MemPoolFirst         Begins enumeration of all SmartHeap memory pools.
MemPoolNext          Continues enumeration of all SmartHeap memory 
                     pools.
MemPoolCheck         Checks each entry in a memory pool for 
                     consistency.
MemPoolWalk          Traverses a memory pool, returning information 
                     about each entry in turn.
ANSI Standard C API
-------------------
malloc               Allocates a block of uninitialized memory.
calloc               Allocates a block of memory, initializing its 
                     contents to zero.
realloc              Changes the size of a memory block.
free                 Frees a block.

C++ API
-------
new type             Allocates a memory block in C++ from the 
                     default memory pool.
new (pool) type      Allocates a memory block in C++ from a 
                     specified memory pool.
delete               Frees a memory block allocated with new.

Default Memory Pool
-------------------
MemInitDefaultPool   Initialize memory pool used for malloc and new 
                     (occurs automatically on first call to malloc 
                     or new).
MemFreeDefaultPool   Frees malloc/new memory pool.
 
Fixed-Size API
--------------
MemAllocFS           Allocates a fixed-size memory block from a 
                     memory pool.
MemFreeFS            Frees a memory block allocated by MemAllocFS.

Pointer-Based API
-----------------
MemAllocPtr          Allocates a memory block, returning a pointer.
MemReAllocPtr        Changes the size of a memory block, possibly 
                     moving the block.
MemFreePtr           Frees a memory block.
MemSizePtr           Returns the size of a memory block.
MemCheckPtr          Validates a pointer.

Handle-Based API (for moveable allocations)
-------------------------------------------
MemAlloc             Allocates a memory block, returning a handle.
MemReAlloc           Changes the size of a memory block allocated 
                     with MemAlloc.
MemFree              Frees a memory block allocated by MemAlloc.
MemLock              Increments the lock count of a memory block 
                     on the moveable heap, preventing its movement.
MemUnlock            Decrements a block's lock count if previously 
                     locked with MemLock; block can move if lock 
                     count is zero.
MemFix               Increments a block's fix count, moving the 
                     block to the fixed heap to avoid fragmenting 
                     the moveable heap.
MemUnfix             Decrements a block's fix count, moving it 
                     back to moveable heap if fix count is zero.
MEM_REFERENCE        Macro that dereferences memory identified by 
                     given handle without locking handle -- 
                     implemented as simple double-indirection in 
                     non-debug SmartHeap.
MemHandle            Retrieves the handle of the memory block at 
                     the specified address (returned by MemLock 
                     or MemFix).
MemIsMoveable        Determines whether block is on fixed or 
                     moveable heap.
MemLockCount         Retrieves lock or fix count of a memory block.
MemSize              Returns the size of a memory block.

Error Handling
--------------
MemDefaultErrorHandler  The default error-handling function that 
                        is in effect if you don't implement your 
                        own.
MemSetErrorHandler      Establishes or changes the memory error-
                        handling callback function for the 
                        current task.
Miscellaneous
-------------
MemVersion              Returns SmartHeap version number.

Debugging (functions present only in debug version of SmartHeap)
----------------------------------------------------------------
dbgMemSetSafetyLevel            Establishes or changes the level 
                                of error checking for the current 
                                task or process.
dbgMemSetGuardSize              Establishes the number of guard 
                                bytes to pad before and after each 
                                allocation to detect overwrites.
dbgMemSetGuardFill              Establishes the character with 
                                which to fill guard bytes.
dbgMemSetFreeFill               Establishes the character with which 
                                to fill free blocks.
dbgMemSetInUseFill              Establishes the character with 
                                which to fill allocated blocks.
dbgMemSetCheckpoint             Establishes the context for 
                                allocations -- useful for tracking 
                                down overwrites and leakage.
dbgMemPoolSetCheckFrequency     Establishes how frequently the 
                                memory pool should be checked 
                                for overwrites.
dbgMemPoolDeferFreeing          Causes free blocks to be marked 
                                free rather than actually freed in 
                                order to detect double freeing or 
                                writes into free blocks.
dbgMemPoolFreeDeferred          Frees any blocks that were freed 
                                when "defer freeing" was in effect.
dbgMemProtectPtr                Marks a memory block as read-only, 
                                no-free, and/or no-realloc.  Any 
                                attempt to modify, free, or realloc 
                                (respectively) the block will be 
                                reported as an error.
dbgMemFormatErrorInfo           Formats to a string an error 
                                record reported to a SmartHeap error 
                                handler.
dbgMemFormatCall                Formats to a string an API reported 
                                to a SmartHeap error handler.
dbgMemSetDefaultErrorOutput     Establishes the output destination 
                                for the default SmartHeap error 
                                reporting mechanism (errors can be 
                                directed to any combination of 
                                interactive prompt, file, or debugging 
                                console).
dbgMemSetEntryHndler            Establishes a hook that is called at 
                                each SmartHeap entry-point.
dbgMemSetExitHandler            Establishes a hook that is called at 
                                each SmartHeap exit-point.
dbgMemReportLeakage             Reports blocks that have not been 
                                freed between the specified checkpoints.

SmartHeap Reliability Confirmation Test Suites: 
===============================================
A SmartHeap release is sent out only after running the tester for 
several days --making millions of calls without a single glitch.

Completely error-free operation is at best an unrealistic goal for 
most software products.  Yet for a memory manager, rock solid 
reliability is critical.  It is hard enough tracking down memory 
bugs in your own application -- but bugs in a memory allocator 
are even more spurious and insidious.   These bugs cost companies 
dearly in terms of programming time, technical support time, 
damaged reputation, update costs, etc. 

Beta tests and an extensive suite of carefully considered test 
cases are valuable.  However, given the number of permutations 
of inputs and outputs that any program has, especially a memory 
manager, this approach will cover only a small fraction of the 
scenarios the program might encounter in actual use.  

Because reliability is so important for a memory manager, we 
developed an automated testing procedure to really prove that 
all the bugs are out. It goes far beyond traditional software 
testing techniques by actually calling each of the SmartHeap 
APIs hundreds of thousands of times with random parameter 
values.  In fact, we won't even implement a new function 
into the SmartHeap library unless we know in advance that we 
can verify its reliability through comprehensive testing 
procedures.

The automated tester is a very sophisticated program.  It 
checks low-memory conditions, passes both valid and invalid 
parameter values (both randomly generated) to each SmartHeap 
API, and intentionally double-frees and overwrites previously 
allocated blocks.  It allocates one-byte and multi-megabyte 
blocks, and all sizes in between.  In fact, the tester is 
substantially more code than SmartHeap.  

The test program validates the results and side-effects of 
every call, and scans each allocated block to be certain that 
memory is never stepped on when it shouldn't be.  It checks 
that errors (e.g. invalid parameters) are reported when they 
should be and that no errors are reported when they shouldn't 
be.

Each time the automated tester is run, it outputs a detailed 
log of the results.  If any problems are detected, we hold up 
the release until they are fixed, then run the whole process 
again.  A SmartHeap release is sent out only after running the 
tester for several days -- millions of calls -- without a glitch.

Not even large development teams can afford to do this level 
of testing to ensure their in-house memory manager is robust 
and reliable.  That's why so many companies, including some 
very big names, have converted to SmartHeap.


SmartHeap Success Story #1: Debugging:
======================================
SmartHeap helps meet the "Mother of all drop-deadlines"

November 2, 1993

This is my first testimonial in four years; rarely do I run 
across a programming tool that so completely solves a problem 
that I cannot imagine how we could have done without it. 

TestDrive was faced with a formidable task: we MUST deliver 
200,000 CD-ROMs to insert into a national magazine, we had less 
than a month  for testing, we could NOT deliver a day late, 
and the software had to work!  Without SmartHeap, we would have 
missed this Mother of all drop-deadlines.

Prior to going to Beta, SmartHeap detected over a dozen 
unique memory bugs, which were not detected by Nu Mega's 
Bounds Checker.  Two of these bugs were insidious memory 
overwrites, which showed no symptoms on our development 
machines.  After looking at these bugs, I am certain that 
they would have blown up during Beta, would have been impossible 
to reproduce, and would have caused an extremely painful delay 
in our product release.  

My deepest gratitude goes to everyone involved with producing 
and supporting SmartHeap, for playing such a key role in our 
success. 

Sincerely, 

Warren Stringer, 
VP of R & D
TestDrive Corporation


SmartHeap Success Story #2: Performance 
=======================================
SmartHeap Overcomes Thrashing Problem

October 12, 1993

Dear MicroQuill,

This is just a short note to inform you of our experiences 
with using SmartHeap v.2.0.

First, some background.  Our Windows application can use a 
very large amount of Windows heap space, based entirely on 
the content and quantity of the user's data.  It is not 
unusual for the app to use 2MB of space for code and 15-20MB 
for data.

When we started performance testing, we discovered that the 
application seemed to enter a thrashing condition when large 
amounts of user data was allocated.  In fact, the onset of 
thrashing was very sudden, somewhat akin to running into a 
wall.  By setting breakpoints and stepping, we found that 
most of the thrashing was associated with a call to new() or 
malloc().  We found in one case that 130 page-out page-in 
swaps occurred for each malloc() call!  Clearly, we had a 
problem with the heap manager.  The standard heap, as 
documented in C textbooks, uses a linked list to hold free 
memory segments.  In our case, the traversal of this free 
list was causing many non-present pages to be touched, 
resulting in substantial performance degradation.

We heard about the 2.0 version of SmartHeap, which takes 
into account the paging nature of Enhanced Mode Windows, 
and decided to try it on our problem.

For a first pass, we chose to use SmartHeap almost 
completely transparently, as a direct replacement for the 
Microsoft C runtime heap manager.  We did set the variable 
'MemDefaultPoolBlockSizeFS' to 32, since we have a 
substantial number of small objects of size<32 bytes, and 
figured that we could benefit from the fixed size pool 
and the SmartHeap ability to automatically allocate the 
small blocks out of that pool.

The results were very encouraging.  We found that we no 
longer suddenly 'hit the wall' in low memory conditions, 
but that the slowdown due to paging was much more gradual.  
Even when not in low memory situations, we found that for 
test cases that involved large numbers of small objects, the 
performance of the application with SmartHeap was  MUCH 
better.  This indicates that the performance advantage of 
fixed-size allocation is substantial.

We are pleased with the choice of SmartHeap and have adopted 
it as our default heap manager.

Regards,
 
Ken Burgett
Xerox Group Communications


SmartHeap Success Story #3: Handle Performance on the Mac
=========================================================
The following is the text of an Applelink email posting made 
by Todd Williams of Mobil R&D in November, 1993, after 
implementing SmartHeap for the Mac.  

This is a followup to a previous posting of mine which 
generated a good bit of interest.   At the end of September 
I posted the following problem:
Memory Masters,
I've got a C++ application that uses lots of little objects 
(all handle-based) to do its deed.  It will often have 10's 
of thousands of handles allocated at a given instant.  
The problem is that as the number of allocated handles 
increases, the performance of the application decreases, 
even if only a few handles are in active use.  This 
performance degradation can be seen as taking longer and 
longer to do a task as more memory gets allocated.  Even 
tasks which don't allocate any additional memory begin to 
slow down (such as screen redraws and the like).  When the 
handles are freed, or their number reduced significantly, 
performance improves again.  I guess what I'm saying is 
that the performance degrades in proportion to the number 
of handles I have allocated (even though there is plenty 
of free memory) rather than in relation to the number in 
active use.  I appear to be overtaxing the Memory Manager's 
ability to keep up with all the handles.  This is 
understandable since the Memory Manager was written at 
a time when hundreds of handles was the norm, but 
nevertheless I need a clever way around the handicap if 
at all possible.

MoreMasters is not being called repeatedly, and thus 
causing the slowdown, because I allocate plenty of master 
pointers at the bottom of my heap on startup.  That's 
about it.  Any ideas or hacks to try?

Any help or comments is appreciated,

todd e. williams, Mobil R & D

ps.  no, i can't significantly reduce the number of 
handles i use due to the nature of the application.

This response generated knowledgable replies from several 
people.  I would like to thank Francois Grieu (FRA0003), 
Dick Startz (TSP.STARTZ), and Andy Kohler (KOHLER.A) for 
their insights and suggestions.  Unfortunately, I was 
already doing all of the "good" things they mentioned 
(with the exception of writing my own memory manager or 
using subheaps); so I thought I was out of luck without 
a significant amount of work.  It turns out that the Mac 
Memory manager was just not designed to handle the kind 
of load I was requiring.  Then I got a break from Larry 
Cynkin (PLS) (thanks Larry!).  He suggested that I try 
a cross-platform memory management library called 
SmartHeap from MicroQuill.  He had never used it, but 
saw an ad for it someplace.  I decided I didn't have a 
lot to lose so I bought a copy for evaluation since 
they have a handle-based memory allocator (and a 
pointer-based one too) that is a superset of the Mac's.

Here's the summary of what I found out.  It works
beautifully.  It's SEVERAL times faster than the Mac's 
memory calls, it doesn't slow down as more handles 
are allocated, and it comes with a debug library 
that finds pesky problems like pointer overwrites, 
double-frees, and memory leaks.  SmartHeap is worth 
the money for either the debugging capabilities or 
the speed increase.  The fact that you get both 
makes it a real deal.  Oh yeah, both their sales and 
tech support people are first-rate; you don't have to 
go through a series of mindless drones to get to someone 
that knows something.  That was refreshing  The only 
downside, of course, is that you have to replace all 
your memory allocation calls with theirs, which may 
be a significant amount of work, depending on how 
localized your calls are.  Since I'm using C++, I 
managed to rewrite operator new for HandleObject and 
a memory allocation class I was already using, 
recompile, relink, and go.  The entire changeover 
took me way less than a day.  Your mileage will vary.

That's the jist of it.  I just felt that there were 
enough people out there with the problems I was 
having to justify a posting of the possible solution.

DISCLAIMER:  These opionions are strictly my own 
and may or may not be shared by my employer(s) or 
the Queen of England.  I am not affiliated with 
MicroQuill in anyway and am receiving no remuneration 
for this posting.  Blah Blah Blah...
I hope this helps somebody,
todd e. williams, Mobil R & D

            SmartHeap Version 2.0 Pricelist

SmartHeap is sold in binary format for specific operating 
system platforms (as a statically linkable library or .dll, 
or both).  Each binary is optimized to take full advantage 
of processor specific, operating system specific, and 
compiler specific features while maintaining identical 
API's and functionality across all platforms.  

The SmartHeap binary license allows single user access to 
the SmartHeap API's and error detection facilities on a 
single computer.  For those organizations requiring 
multi-user access to a single OS version of SmartHeap, 
multi-unit discounts are listed below.  Site licenses are 
also available for those customers wishing to acquire 
multiple versions of SmartHeap to support their 
development efforts on multiple platforms.  Please call 
MicroQuill for information on these discounts. In most 
cases, there are no royalties necessary when shipping 
the SmartHeap allocators in your application.  Please 
see the reverse side of this price sheet for details. 

Platform-specific SmartHeap source code is available 
as an optional upgrade to a binary user license.  
Source code licenses do not constitute user licenses 
of their own, and as such, are sold only in conjunction 
with a SmartHeap binary license.   
        
  Version          Binary Price   2-5 units   > 5 units  Optional Additional   
                    Single Unit  Each Binary Each Binary    Source Code** 
DOS (Real Mode)       $465          $395        $345            $795
16 bit Extended DOS    465           395         345             795
32 bit Extended DOS    695           595         495             795
Windows 3.x            465           395         345             795
NT/Win32s/Chicago      695           595         495             995
OS/2                   695           595         495             995
Macintosh              695           595         495             995
UnixWare               695           595         495             995
SunOS/Solaris          995           795         695            1495
SGI Irix               995           795         695            1495
IBM RS6000 AIX         995           795         695            1495
HP-UX                  995           795         695            1495
** requires a binary license for that platform. 

*   Binary licenses include: royalty-free runtime library 
    distribution, 300+ page manual, technical support access 
    via phone, fax, email, and BBS, and 60 day Money Back Guarantee. 
*   The prices listed above are in US$, and do not include 
    shipping charges.  Domestic US per-unit shipping charges via 
    UPS are: $8, 3 day; $10, 2 day; $20, Overnight.  Please call for 
    International shipping charges. 
*   Canadian customers subject to the Revenue Canada circular 
    number 77-16R3 withholding tax must add 11% to the software 
    prices listed above. 
*   Upgrades of SmartHeap 1.52 or earlier binary and source code 
    licenses to SmartHeap 2.0 are available.  Please call 
    MicroQuill for details. 
*   To order SmartHeap or an upgrade, please phone, fax or 
    email your P.O. or credit card information to MicroQuill 
    at the information listed below. 

               SmartHeap Licensing: Question and Answer
                       (Please read carefully)
Because SmartHeap is a library product, many customers have 
called us with questions about multiple users, distribution 
arrangements, royalties, etc.  To help clarify our licensing 
terms, we have summarized the "legal-eze" of the SmartHeap 
contract into a few bullet points which we hope will answer 
your licensing questions. 

Q.  How is SmartHeap licensed?
A.  SmartHeap is licensed on a per-user basis.  A SmartHeap 
    binary license includes single-user access to the SmartHeap 
    header files and/or library files for a single developer 
    on a particular machine.  This applies even if the 
    header or library file name(s) have been changed.  If multiple 
    developers within your organization are accessing the 
    SmartHeap header or library file, each one needs a SmartHeap 
    license. 
Q.  Is there a network version? How can I arrange for more 
    than one developer to use SmartHeap?  
A.  SmartHeap is not available for networks.  For organizations 
    requiring multiple copies of SmartHeap, MicroQuill has 
    provided multi-copy purchase discounts.  The multi-unit prices 
    are listed on the attached price list.  
Q.  Is SmartHeap source code available?
A.  Yes.  Source code licenses will continue to be sold in 
    conjunction with or as an upgrade to the binary-user 
    license.  However, source licenses do not constitute a 
    user license themselves, so source code is only sold 
    with an associated binary license.  All source versions 
    of SmartHeap v.2.0 include the necessary make-files for 
    convenient compiling for that specific hardware and 
    compiler combination.  
Q.  Can I distribute the SmartHeap libraries in my application?  
    What about royalties?
A.  The SmartHeap v.2.0 DLLs and object code linked into 
    your executables is available for royalty-free 
    distribution when incorporated in applications sold 
    directly to end-users.  The Debug SmartHeap DLLs and 
    object code may not be distributed.  If the application you 
    produce is a library, development tool or any type of 
    program wherein the SmartHeap object code or DLL is 
    redistributed by your customers, the standard SmartHeap 
    license does not apply.  In such redistribution cases, 
    please contact MicroQuill for the necessary redistribution 
    license. The redistribution license does not require 
    royalties, but does involve a small licensing fee. 
    
As always, if you have any questions or need additional 
clarification, please be sure to call us.  

      MicroQuill * 4900 25th Ave NE #206 * Seattle, WA 98105
     CIS: 70751,2443 * Internet: devtools@microquill.win.net
          phone: (206) 525-8218 * fax: (206) 525-8309


