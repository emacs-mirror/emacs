            A GUIDE TO MPS POOL CLASSES AND THEIR PROPERTIES
                       doc.mps.guide.pool-classes
                               draft doc
                             rit 1998-07-01

.purpose: This document is intended to enable you to answer questions like: 
"Does MV move objects around?" and "Does AMCZ support interior references?", 
and also to allow you to pick the right pool classes to use in your programs.  
It addresses the functional differences between pool classes, without dealing 
with questions of performance.  It also defines some terminology for properties 
of references, objects and pools, which may be useful in discussing memory 
management and the MPS in particular.

.readership: Any MM developer or user within Harlequin.

.structure: First we state some properties that references, objects and pools 
might have.  There follows a big table of pool classes and their properties.

.convention.definitions: Words and phrases being defined appear in double 
quotation marks.

.caveat: In some cases, there is no appropriate documentation of the behaviour 
of pool classes.  Therefore it is not always possible to distinguish between 
behaviour which was specified for a pool class and behaviour which is present 
but was not intended to be part of the specification.

.hist.0: rit wrote version 0 based on his understanding of the MPS pool classes 
at the time.
.hist.1: updated following comments from drj and pekka. rit 1998-08-24
.hist.2: added table column for MVFF pool class. rit 1998-10-14


PROPERTIES OF REFERENCES

These properties apply to references in non-leaf objects (.prop.obj.non-leaf), 
and to references in roots. I have arranged them in pairs; exactly one of the 
properties in each pair applies to any reference.

.prop.ref.containment: An object or root is said to "contain" a reference if 
scanning the object or root causes that reference to be fixed.

.prop.ref.real: A "real reference" is one that points to an object.
.prop.ref.ambiguous: An "ambiguous reference" is one that may be interpreted 
either as a reference to an object, or as other data.

.prop.ref.strong: A "strong reference" keeps the object it refers to alive 
(unless it is explicitly discarded for some other reason).
.prop.ref.weak: A "weak reference does" not keep the object it refers to alive. 
If the object is discarded, the reference will be splatted. "splatting" is 
removing the reference; in the mps, by changing it to NULL. Note that there may 
be various different kinds of weak references, depending on their interaction 
with finalisation -- see .prop.rank.weak below.

.prop.ref.fixed: A "fixed reference" may not be updated by the collector, 
except by splatting if the reference is weak (.prop.ref.weak).
.prop.ref.moving: A "moving reference" may be updated by the collector. This 
means the collector has the opportunity to move the object referred to.

.prop.ref.immutable: An "immutable reference" is one the client guarantees not 
to change.
.prop.ref.mutable: A "mutable reference" is one the client may change when it 
likes.

.implications.prop.ref: Because it would be dangerous for the collector to 
change something which wasn't really a reference, ambiguous references 
(.prop.ref.ambiguous) must be both fixed (.prop.ref.fixed) and strong 
(.prop.ref.strong).


RANKS

At present, the mps understands only the following types of reference, known as 
ranks:

.prop.rank.exact: References of rank mps_rank_exact are real, strong and moving 
(.prop.ref.{real, strong, moving}).
.prop.rank.ambiguous: References of rank mps_rank_ambiguous are ambiguous, 
strong and fixed (.prop.ref.{ambiguous, strong, fixed}).
.prop.rank.weak: References of rank mps_rank_weak are real, weak and moving 
(.prop.ref.{real, weak, moving}). This rank is "weak-after-final", i.e. a weak 
reference to an object which would have died but was registered for 
finalisation, will not be splatted until the object subsequently dies.

For references in roots, the client may specify whether they are mutable 
(.prop.ref.mutable) or immutable (.prop.ref.immutable).

All references in objects are mutable (.prop.ref.mutable), but subject to the 
constraint that the reference will not change without the client writing to the 
object/root that contains it. This is because write-barriers are used to 
maintain remembered sets. The EPVM pool class is an exception to this rule: see 
.prop.pool.remote-references below.

Note to developers: mps_rank_final is not usable by mps clients, so I haven't 
mentioned it. Except for just now, that is.


PROPERTIES OF OBJECTS

.prop.obj.leaf: A "leaf object" is one that does not (and can not) contain 
references.
.prop.obj.non-leaf: A "non-leaf object" is one that may contain references.

.prop.obj.collected: A "collected object" is one that may be automatically 
discarded when the collector determines it is no longer needed.
.prop.obj.manual: A "manually-managed" object is one that should be discarded 
when the client explicitly says so. Any object allocated by the MPS can be 
discarded by calling mps_pool_destroy, but we don't consider an object to have 
.prop.obj.manual unless there is some more specific way of discarding it. (Note 
that .obj.collect and .obj.manual are _not_ mutually exclusive.)

.prop.obj.base-ref: An object "supports base references only" if only a 
reference to the base of the object is considered to be a reference to the 
object.
.prop.obj.internal-ref: An object "supports internal references" if a reference 
to any byte within the object is considered to be a reference to the object.

.prop.obj.no-protect: An "unprotectable object" is one that the collector 
promises not to place a read or write barrier on.
.prop.obj.protect: A "protectable object" is one that the collector may place a 
read or write barrier on.

.prop.obj.no-move: A "non-movable object" is one that the collector will not 
move.
.prop.obj.move: A "movable object" is one that the collector may move.

.prop.obj.finalize: A "finalizable object" is one that the client may later 
register for finalisation. [At present, this applies only to collected objects 
(.prop.obj.collected.)]

.prop.obj.formatted: At the moment, objects are formatted if and only if they 
have either of .prop.obj.scanned or .prop.obj.collected. This is a coincidence, 
and indeed the possibility of an unformatted but collected pool has been raised 
(see mail.tony.1998-06-30.17-20(0)).


POOL AND POOL CLASS PROPERTIES

Allocation and freeing
.prop.pool.alloc: A pool "with alloc" supports an interface for allocating 
individual objects (mps_alloc in the MPS).
.prop.pool.free: A pool "with free" supports an interface for discarding 
individual objects.
.prop.pool.buffered-alloc: A "buffered pool" supports allocation using 
allocation points.
.prop.pool.save-restore: A "save-restore pool" supports "save" and "restore" 
operations for allocating and discarding nested sets of objects.

Collection
.prop.pool.collection.auto: An "automatically-collected pool" is one where 
garbage collection is under the control of the collector, which decides when 
collection should take place and performs it automatically and incrementally.
.prop.pool.collection.demand: A "demand-collected pool" is one where garbage 
collection takes place when the client explicitly requests it.

.question.combine.prop.pool.collection: How well can the two of these be 
combined in the same mps? Consequences for read and write barriers? This is an 
important question, considering the differences between product.dylan and 
product.epcore.

.question.prop.pool.collection.incremental: Should there be a separate pool 
property for being incrementally collected? At the moment, all MPS-originated 
collection is incremental and all client-requested collection is 
non-incremental, irrespective of the pools involved, but perhaps this might 
become a pool property in the future.

Size and alignment
.prop.pool.alignment.fixed: A "fixed-alignment pool class" has a fixed object 
alignment.
.prop.pool.alignment.config: A "configurable-alignment pool" class allows the 
client to specify alignment for each pool.
.prop.pool.alignment.variable: A "variable-alignment pool class" allows the 
client to specify alignment for each object.
.prop.pool.size.fixed: A "fixed-size pool class" has a fixed object size.
.prop.pool.size.config: A "configurable-size pool class" allows the client to 
specify an object size for each pool.
.prop.pool.size.variable: A "variable-size pool class" allows the client to 
specify a size for each object.

Special Powers
.prop.pool.assoc-object: Each object in an "associated-object pool" can specify 
an associated object which the mutator guarantees will be accessible during 
scanning of the first object. (Applies to the AWL pool class, where is it used 
to help Dylan manage weak hash tables.)
.prop.pool.remote-references: The references contained in an object in a 
"remote-references pool" need not be stored directly in the object itself. 
Therefore, the collector may not rely on write-barriers to detect changing 
references. (Applies to the EPVM pool class, where it is used to help support 
the ScriptWorks object format.)
.prop.pool.ambiguous.not-supported: If a pool "does not support ambiguous 
references", then ambiguous references which could otherwise be interpreted as 
references to objects in that pool will not be so interpreted. i.e. they will 
be ignored, and will not keep objects alive. (Applies to the EPVM pool class.)


GENERAL ISSUES

.issue.endian: Properties like "whether ref must be to base of object" can 
perhaps be specified both as properties of a reference _from_ a specific 
reference and _to_ a specific object. For example: AMC doesn't allow weak 
references out of it. EPVM doesn't allow ambiguous references into it. (Why 
this is, I have no idea.) For most types of properties, the MPS design has made 
a choice: either it's a property at the _from_ end or at the _to_ end. (E.g., 
base/middle is at the _to_ end, rank is (usually) at the _from_ end. Format, of 
course, is always at the _from_ end.)


A TABLE OF POOL CLASSES AND THEIR PROPERTIES

.table.pool-classes: In the following table, a "yes" for an object property 
means (unless otherwise indicated) that that property holds for _all_ objects 
in the pool. A "yes" for a rank means that the pool allows objects containing 
references of that rank. Gaps in the table indicate properties that aren't 
applicable: for example is it silly to ask whether a pool which doesn't have 
.prop.obj.scanned has .prop.rank.weak.


Name of pool class:            AMC    AMCZ   AWL    LO     EPVM   MV     MV2    
EPDL/R MVFF

.prop.pool.alloc               no     no     no     no     no     yes    no     
yes    yes
.prop.pool.free                no     no     no     no     no     yes    yes    
yes    yes
.prop.pool.buffered-alloc      yes    yes    yes    yes    yes    no     yes    
no     no
.prop.pool.save-restore        no     no     no     no     yes    no     no     
no     no

.prop.obj.collected            yes    yes    yes    yes    yes    no     no     
no     no
.prop.obj.manual               no     no     no     no     yes(1) yes    yes    
yes    yes
.prop.pool.collection          auto   auto   auto   auto   manual

.prop.obj.non-leaf             yes    no     yes    no     (2)    no     no     
no     no
.prop.rank.exact               yes           yes           yes
.prop.rank.ambiguous           no            no            no
.prop.rank.weak                no            yes           no

.prop.obj.base-ref             yes    yes    yes    yes    yes(2)
.prop.obj.internal-ref         no     no     no     no     yes(2)
.prop.obj.protect              yes    no     yes    no     no     no     no     
no     no
.prop.obj.move                 yes    yes    no     no     no     no     no     
no     no

.prop.obj.finalize             yes    yes    yes    yes    no(3)  no     no     
no     no

.prop.obj.formatted            yes    yes    yes    yes    yes    no     no     
no     no

.prop.pool.size                var    var    var    var    8      var    var    
var    var
.prop.pool.alignment           config config config config 8      (4)    (4)    
config config(5)

.prop.pool.assoc-object        no            yes           no
.prop.pool.remote-references   no            no            yes
.prop.pool.ambiguous-          no     no     no     no     yes
 not-supported


Notes:

(1) because EPVM pools are save-restore pools (.prop.pool.save-restore).

(2) EPVM pools can allocate two distinct types of object: one type is non-leaf 
and supports base-references only (.prop.obj.non-leaf, .prop.obj.base-ref). The 
other is leaf and supports internal-references (.prop.obj.leaf, 
.prop.obj.internal-ref).

(3) Finalisation of EPVM objects may be a future requirement for ScriptWorks, 
so this might change.

(4) MV and MV2 alignment is platform dependent.

(5) MVFF pools may not have alignment less than MPS_PF_ALIGN (which should be 
the "platform alignment").


