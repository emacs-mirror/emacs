                     STACK ALLOCATION USING THE MPS
                       doc.mps.guide.stack-alloc
                             incomplete doc
                             drj 1998-10-23

INTRODUCTION

.intro: This document describes how to perform stack allocation using the MPS 
and what the options are.

.readership: Readership: Any MPS user.


OVERVIEW

.overview: The MPS provides a means by which clients can declare that objects 
can be efficiently managed using stack-allocation (the stack protocol on APs, 
see protocol.mps.alloc-point.stack); the MPS also provides policies (pool 
classes) which when used with such declarations will manage objects as 
efficiently (or very nearly so) as stack allocation; the MPS also provides 
policies which honour the declarations but do not take advantage of them to 
manage the objects any more efficiently.  The MPS does not preclude the client 
from using the usual control or thread stacks for stack allocating objects.

.options: So if the client wishes to use stack allocation they have three 
options:

.option.client: Clients can stack allocate objects themselves, perhaps using 
the control stack.
.option.mps.fit: Clients can specify that the objects be managed using a pool 
which is designed to be used for efficient stack allocation.
.option.mps.nofit: Clients can specify that the objects be managed using a pool 
which is not designed to be used for efficient stack allocation.

.option.mps.notfit.why: The reasons for providing pool classes which are not 
designed to be used for efficient stack allocation are:
.option.mps.notfit.why.debug: We can provide pool classes which debug the 
client's use of the protocol to ensure that the client isn't cheating and help 
them find out how if they are.
.option.mps.notfit.why.interchange: The interchangeability of pool classes is 
increased.  The client can mix and match pool classes to see which gives the 
best overall performance or use a substitute pool class to work around problems 
in another.


STACK ALLOCATION

.broad: Clients wanting to use the MPS for stack allocation will need to do the 
following:

- Select a pool class to use.
- instantiate a pool, APs, object formats, and so on.
- allocate objects in the pool according to the stack protocol (see 
protocol.mps.alloc-point.stack).

.select.issues: The issues involved in selecting the pool are:
- can the allocation point stack protocol be used with the class?
- are the objects managed efficiently.

Currently all pool classes which provided allocation via allocation points 
understand the allocation point stack protocol.  However, only Pool Class SNC 
will manage objects allocated using the stack protocol in a particuarly 
efficient way; the other pool classes essentially ignore the stack protocol - 
it will not affect they way they manage objects.


EXAMPLE

Using Pool Class SNC would be something like this:

/* Having create an arena, threads, roots, etc. */
/* Instantiate a pool and an AP. */
res = dylan_fmt(&format, arena);
if(res != MPS_RES_OK) abort();
res = mps_pool_create(&pool, arena, mps_class_snc(), format); /* Note 
mps_class_snc takes one extra argument which is a format */
if(res != MPS_RES_OK) abort();
res = mps_ap_create(&ap, pool, mps_rank_exact());
if(res != MPS_RES_OK) abort();
/* ... */

/* calls f in a stack frame so that all f's allocation (in the supplied ap) can 
be */
/* freed when it returns */
mps_res_t with_stack_extent(mps_ap_t ap, (void *f)(mps_ap_t, void *), void *c)
{
  mps_frame_t frame;

  res = mps_ap_frame_push(&frame, ap);
  if(res != MPS_RES_OK) return res;
  f(ap, c);
  res = mps_ap_frame_pop(ap, frame);
  if(res != MPS_RES_OK) return res;
  return MPS_RES_OK;
}

