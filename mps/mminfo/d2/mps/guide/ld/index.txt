              USING THE MPS LOCATION DEPENDENCY INTERFACE
                            doc.mps.guide.ld
                               draft doc
                             drj 1996-10-15

INTRODUCTION

The MPS's location dependency interface is a means by which clients of the MPS 
can depend on the location of objects (i.e., the "bit-pattern" of a pointer to 
an object) in the presence of a moving memory manager (where the location of 
objects may change and the client will need to recognize and correctly deal 
with such cases).

The interface is intended to support (amongst other things) hash-tables and 
that will be used as a running example.  In addition to which a complete 
hash-table example in C is available [in another document].


TERMINOLOGY

A "location dependency" is the name given to an object of type mps_ld_s.  A 
location dependency encapsulates what dependencies have been made on objects 
and when.  It can be used (as detailed below) to determine whether any of the 
objects whose location has been depended on have been moved by the memory 
manager.

To "depend" on the location of an object is to perform a computation whose 
result depends on the particular representation (i.e., the "bit-pattern") of a 
pointer to the object.  An example of this is practically any sort of hash on 
the pointer to an object (such as treating the pointer as an integer and taking 
it modulo 257).  It is possible to depend on the location of more than one 
object.

A dependency has been made "stale" if the object whose location was depended on 
has moved since the dependency was made.  If this is the case, then 
computations that depend on the location of an object may give different 
results.  A location dependency has been made "stale" if any of the objects 
whose location has been depended on have moved since the respective dependency 
was made.


C INTERFACE

The C interface is in the file mps.h.  Two types are needed: mps_ld_s (a 
structure type) and mps_ld_t (a pointer to the structure type mps_ld_s).  The 
key type is mps_ld_t; mps_ld_s, the structure type, is provided merely so that 
clients can inline into their own structures.  The interface comprises four 
functions: mps_ld_reset, mps_ld_add, mps_ld_merge, and mps_ld_isstale.


PROTOCOL


Creation

The only way for clients to create location dependencies is for clients to 
provide space for the structure.  It is envisaged that this will typically be 
inlined in some larger structure (for example, in a hash table design, each 
hash table might have a location dependency structure inlined at the 
"beginning" of it).


Reset

Before the first use, the location dependency must be reset using the function 
mps_ld_reset.  Note that this means that it is not possible for clients to 
statically create a reset location dependency.


Depend

Before the location of an object is depended on (for example, hashed) the 
pointer should be added to a location dependency using the function 
mps_ld_add.  This location dependency can then be used in some lookup operation 
(see below) to determine if the object has moved.  Many dependencies can be 
added to the same location dependency.

It is also possible to merge two location dependencies by calling mps_ld_merge, 
which adds all of the pointers from one dependency into another.


Use

When dependencies on the location of objects are used (during a hash-table 
lookup for example), the computation is carried out and the result used in the 
usual way (the pointer is hashed and indexed into the table for example).  At 
this point one of three situations can occur:  1) everything is successful (for 
example, the object was found in the hash-table at the indicated place); 2) the 
location of these objects has not been depended on before (for example, this 
key has never been added to the hash-table); 3) the location of these objects 
has been depended on before, but the one or more of the objects has moved and 
the dependency has been made stale.

cases 2 and 3 can be distinguished with a call to mps_ld_isstale, but only 
partially.  A call to mps_ld_isstale can positively identify case 2, it will 
return 0 (so, in the hash-table example, the key should be added to the table, 
or the lookup failed).  When mps_ld_isstale returns non-zero (indicating case 
3) then the computation should be performed using an algorithm that doesn't 
depend on the location of any objects, and in addition, the dependencies made 
on the locations of objects represented by the location dependency should be 
remade by resetting the location dependency and performing the computations 
again (for example, in a hash-table lookup, the location dependency associated 
with the table should be reset and the table rehashed; the key should be looked 
up using a search after or during the rehash).  Note that mps_ld_isstale only 
guarantees to return 0 for a freshly reset location dependency, in all other 
cases it may return non-zero, hence the requirement that it be possible to 
perform the computation without depending on the location of any objects 
(linear search in the hash-table example).


Redepend

It is permissible at any time to reset the location dependency and recompute 
all the dependencies made on the locations of objects.  This should probably be 
done whenever mps_ld_isstale returns non-zero.


EXAMPLES

These are simple examples given in a pseudo-code for a hash-table.

get key table
  i = hash(key)
  if (key, val) member of table[i]
    return (true, val)
  else if mps_ld_isstale(table.ld, arena)
    rehash(table)
    if (key, val) linear-lookup table
      return (true, val)
  return (false, unit)

add key val table
  mps_ld_add(table.ld, arena, key)
  i = hash(key)
  table[i] cons= (key, val)

rehash table
  mps_ld_reset(table.ld, arena)
  // some sort of cunning in-place rehash

new table
  mps_ld_reset(table.id)


PERFORMANCE

mps_ld_add is intended to be a fast operation.  mps_ld_isstale is intended to 
be a fast operation.  mps_ld_reset is inexpensive, but not intended to be very 
fast.  To be more precise, the following are what one could expect from a good 
implementation; every function has a function call overhead as well, but this 
can be removed by using a macro if the requirements justify this.  This section 
takes the philosophy that memory-cycles are much more expensive than ALU 
operations.

mps_ld_add performs one read memory-cycle and one write memory-cycle to the 
same location; it performs a few ALU operations.

mps_ld_merge performs a few ALU operations, four reads, and two writes to the 
destination ld.

mps_ld_isstale performs up to 4 read memory-cycles; it performs a few ALU 
operations.

mps_ld_reset claims a lock.


Thread safety

In general, the functions are all thread-safe with respect to operations on 
different location dependencies.  That means that it is not necessary for 
threads to interlock if they are performing operations on different location 
dependencies.  The descriptions of the individual functions details their 
thread-safety attributes in other circumstances.


REFERENCE


Types

  typedef struct mps_ld_s {
    mps_word_t w0, w1;
  } mps_ld_s;

The type mps_ld_s is an "opaque structure" type.  The intent is that clients 
can inline the structure (because its size is known) but not access it other 
than through the methods provided.

  typedef struct mps_ld_s *mps_ld_t

The type mps_ld_t is an abstract type.  Objects of type mps_ld_t are pointers 
to objects of type mps_ld_s.


Functions


  void mps_ld_add(mps_ld_t mps_ld, mps_arena_t mps_arena, mps_addr_t addr)

The dependency on the object at location addr is added to the location 
dependency mps_ld.  Until a call to mps_ld_reset(mps_ld, arena) calls to 
mps_ld_isstale(mps_ld, mps_arena, addr) will return a non-zero value if the 
object has moved.

It is possible to add the same address more than once.  mps_ld_add can accept 
any address, including things not in this arena.

mps_ld_add is not thread-safe with respect to mps_ld_add operations, and is not 
thread-safe with respect to mps_ld_reset, but it is thread-safe with respect to 
mps_ld_isstale operations (although this is possibly not useful).  This means 
that calls to mps_ld_add from different threads must interlock if they are 
using the same location dependency (the practical upshot is that there should 
be a lock associated with each location dependency).

mps_ld_add does not allocate.


  void mps_ld_merge(mps_ld_t mps_ld_dest, mps_arena_t mps_arena, mps_ld_t 
mps_ld_source)

The location dependency mps_ld_source is merged into mps_ld_dest.  The effect 
of this is to add all the pointers added to the source to the destination.  
mps_ld_merge has the same thread-safety properties as mps_ld_add.


  mps_bool_t mps_ld_isstale(mps_ld_t mps_ld, mps_arena_t mps_arena, mps_addr_t 
addr)

The location dependency is examined to determine whether any of the 
dependencies encapsulated in it have been made stale.  If any of the 
dependencies encapsulated in the location dependency are stale (i.e., objects 
whose location has been depended on have moved) then mps_ld_isstale will return 
a non-zero value.  If there have been no calls to mps_ld_add on mps_ld since 
the last call to mps_ld_reset, then mps_ld_isstale will return 0.  
mps_ld_isstale may return any value in other circumstances (but will strive to 
return zero if the objects encapsulated in the location dependency have not 
moved).  mps_ld_isstale is thread-safe with respect to itself and with respect 
to mps_ld_add, but not with respect to mps_ld_reset.


  void mps_ld_reset(mps_ld_t mps_ld, mps_arena_t mps_arena)

Resets the location dependency.  After the call, mps_ld encapsulates no 
dependencies.  After the call to mps_ld_reset and prior to any call to 
mps_ld_add (on the same location dependency), mps_ld_isstale on this location 
dependency will return 0 for all addresses.  mps_ld_reset is not thread-safe 
with respect to any other mps_ld function.

