                         GUIDELINES FOR DESIGN
                              guide.design
                             incomplete doc
                           richard 1997-02-18

INTRODUCTION

.intro: This document contains guidelines for the design process of the Memory 
Management Group.  It explains the purpose of design, and derives guidelines 
about te form and content of design documents.  It also serves as background 
rationale for design rules.

.readership: Any Harlequin software developer, but MM developers in particular.


Document History

.hist.0: Richard Brooksby <richard> drafted the document in response to the 
process brainstorm of review.design.mps.poolmrg.2.

.hist.1: Richard Brooksby <richard> updated the draft in response to comments 
from MM developers, mainly Gavin Matthews <gavinm>.  See 
mail.gavinm.1997-02-19.12-54 and mail.gavinm.1997-02-20.14-42.


THE DEFINITION OF DESIGN

.def: Design is the _justification_ of the implementation.  Design bridges the 
gap between implementation and requirements.  Design demonstrates that the 
implementation meets the requirements, by showing how the former is _derived 
from_ the latter (see .fig.just).

.fig.just: A simple view of how design justifies implementation.


 - Justification Diagram 


THE PURPOSE OF DESIGN


Quality

.goal.quality: Design ensures the quality of implementation.  Design should 
_proove_ that the implementation meets requirements, by justifying the 
implementation in terms of the requirements.


Adaptability

.goal.adapt: Design reduces the cost of change.  When requirements change it is 
important to be able to assess the consequences and execute a change to the 
design and implementation rapidly and accurately.  Design provides the 
connection between the requirements and the implementation necessary to do 
this, by linking the implementation back to the requirements and the 
requirements forward to the implementation.


Maintainability

.goal.maint: Defects are commonly injected into code when it is changed, not 
when it is first written.  Assuming the design is correct, this happens because 
the person changing the code hasn't understood the design, which justifies 
_why_ the implementation is like it is.  By looking at the design it is 
possible to see the nature of the problem that needs to be fixed -- whether it 
is an omission, or a misunderstanding, or a defect in coding.


Communication

.goal.comm: Design allows the whole system to be understood by all members of 
the group.  Group members can delve into the details to an appropriate level 
for their work.  Not everyone can know every line of code.  Design is an 
abstraction of implementation.


NOTES


Self-contained Design

Review of the design should check that the design proves that the 
implementation meets requirements (.goal.quality).  A good design should be 
easily reviewed, even by people who are not familiar with the system into which 
the design fits.  This means that the design must be self-contained, to some 
extent.

It should not be necessary for the reader to work out (prove to himself) that 
the implementation of the design meets requirements.  It should be evident from 
the design itself (.goal.quality).  In other words, they shouldn't have to work 
out how good the design is -- the design should prove how good it is.  The 
design should state its goals and requirements, then go on to describe a 
solution which satisfies them.  The design must explain the solution, of 
course, but it should also argue and explain how the solution meets the 
requirements -- that is justification.  The review can check that this 
justification exists and is sound.


Justification

Justification is sometimes hard to construct.  One method is to look at each 
statement about the design -- at each decision made -- and ask "why?".  If the 
answer is obvious given some requirements, then just refer to those 
requirements.  Otherwise you need to explain how the decision relates to the 
requirements.  There should never be a decision which doesn't refer to the 
requirements somehow.

Justification can be difficult.  There might be a requirement for a module to 
provide a service of some kind.  Elsewhere in the design document there's a 
description of a data structure with some fields.  The fields need to be 
designed, but how does it relate to the requirement?  Usually this is difficult 
because there is a missing level of design, and it is solved by adding a 
justified overview of the processes or data structures in the module, and then 
justifying the field in the structure as part of that.  This problem often 
occurs when constructing the design after the implementation.  There seems to 
be an unbridgable gap between the requirements and the code.  (Of course, this 
could be because the code is wrong, but you should find out when you try to 
justify it.)

Let's imagine a module which is supposed to handle sets of objects.  The 
requirement is for set-like behaviour.  The implementation does it using linked 
lists.  How can the "link" field in the linked list be justified?  The answer 
is that there should be an explanation of why linked lists are a suitable 
implementation of the requirement for sets, and then it is a simple matter to 
explain why there's a "link" field.


Design in the Development Process

The development process is roughly like this:

  1. Determine client requirements.  These are often modifications to 
requirements on a previous release of the software -- in other words, an 
incremental change.

  2. Analyse requrements.  We think about the requirements and propose 
solutions, usually with some rough outline design which allows us to assess, 
with reasonable confidence, which solution is best.  "Best", of course, means 
of highest quality: meeting the requirements most closely.  Often, this stage 
reveals problems with the requirements specified.  More information is often 
needed about what the client wants in order to make a decision, or a 
requirement is found to be unclear or ambiguous.  This is a very good thing, as 
a mistake in the requirements can be very costly to fix.

  3. Design the solution.  The chosen solution is designed in detail.  This can 
lead to further requirements problems being revealed, and also to mistakes in 
the analysis.  Sometimes we switch designs because we were mistaken about 
requirements.  (This happened recently with keyword arguments.)  Still, better 
that than implement and ship something which isn't right.  The design should be 
put through formal technical review, which will determine whether it correctly 
describes an implementation that meets the requirements.

  4. Implement the solution.  The implementation is coded from the design, and 
tested, stepped through, reviewed, etc.  There are a lot of overheads of 
implementation which make it much more efficient to find problems during the 
design phase.

Early design improves productivity by reducing the amount of backtracking 
necessary to fix problems.  This said, even experienced engineers need to 
understand their abstractions in detail in order to be confident of using them, 
and will often descend into detail or even prototyping in order to do so (see 
book.humphrey97 section 17.4).  However, the engineer should strive to build up 
experience which makes it possible to re-use knowledge in future design without 
needing to re-implement.


Communication

  I am more convinced than ever. Conceptual integrity is central to
  product quality.  Having a system architect is the most important single 
  step toward conceptual integrity...  After teaching a software 
  engineering laboratory more than 20 times, I came to insist that student 
  teams as small as four people choose a manager, and a separate 
  architect. 
    -- Fred Brooks, The Mythical Man-Month (20th Anniversary Edition), 1995 

Having an architect isn't enough.  If the architect is to maintain conceptual 
integrity the design must be communicated to him.  The group as a whole also 
maintains conceptual integrity by agreeing on general design principles.  To 
some extent, the architect is just the keeper of the group's concepts.

Design allows the system to be understood by all members of the group at some 
level.  Group members can delve into the details to an appropriate level for 
their work.  Not everyone can know every line of code.  Design is an 
abstraction of implementation.


Designs and User Guides

You shouldn't read the design details of a module in order to use it.  The 
interface section should be clearly identified within the design document, or 
be in a separate document.  This is the part that someone designing a client 
module should read.  Make sure it doesn't contain stuff which you wouldn't want 
another module depending on.

The interface of a module is closely tied to the requirements.  It's a good 
idea to work on the interface part first.

Gavin's insight: It should be possible to design an interface and show that any 
implementation of it would meet requirements, then demonstrate that the 
implementation meets the interface.  In some sense, the interface is a layer 
between the two.


Linking Implementation

Design must link the implementation to the requirements (.goal.adapt).  Each 
part of the implementation (code) should refer (using comments) to tags in the 
design document which explain and justify it.  There shouldn't be much need to 
explain the implementation _in_ the implementation, except for a few 
clarifications concerning how the design has been mapped into code.


- Maintainability.  Defects are commonly injected when code is changed, not 
when it is first written.  My theory is that this is because the person 
changing the code hasn't understood the design, which justifies _why_ the 
implementation is like it is.  By looking at the design it is possible to see 
the nature of the problem that needs to be fixed -- whether it is an omission, 
or a misunderstanding, or a defect in coding.

- Adaptability.  When requirements change it is important to be able to know 
the consequences and execute a change to the design and implementation rapidly 
and accurately.  Design provides the connexion between the requirements and the 
implementation necessary to do this, by linking the implementation back to the 
requirements.

- Design must document alternatives and possibilities in order to anticipate 
maintenance, adaptation, and avoid regression.

- Omission is a chief cause of defects in design.  Structured design can help 
by forcing the designer to consider all the issues.  The structure and rules of 
the design must be built up from experience in order to avoid repeating defects.

- All decisions which affect whether the implementation meets its requirements 
must be recorded in the design document.  (Comments in the implementation may 
refer to the design.)  Only decisions which do not affect meeting requirements 
may be recorded solely in comments.

- Intellectual property.  The existence of design documents can establish prior 
art when there is a dispute about intellectual property.

- States, processes, interfaces, data, resources, dependencies, etc.

- When writing design, imagine that you have to pass it on to someone else to 
implement.  (That someone else might well be you in a few months time when 
you've forgotten all the details.)  Are you confident that they'll implement 
something which will meet requirements?

- Think of peverse ways of implementing the design.  Are there any which don't 
meet requirements?  Elimintate them by improving the design.

- Design review should yield general rules which can be applied to future 
design to avoid repeating defects.  For example, the implementation of Pool 
Class MRG revealed a bad interaction between the Shield and the pool when using 
in-band headers.

- Design documents should highlight risks and hazards.  In what way is the 
design fragile?  What sort of changes could be catastrophic?  Imagine that 
someone inexperienced has to come along and change your beautiful 
implementation.  What would you tell them?

- Beware of post-hoc design.  Once you know all about the implementation it's 
hard to write down a suitable abstraction.  Use your own discovery of the 
implementation to guide the design.  Keep notes.  Write down what you had to 
decide.

- [Search for "design AND document" in mail archives.]


Form of Design

- Name things.
- Use diagrams.
- Cross-reference to make changing the design easy.


Content of Design

- Statement of purpose.
- Overview of basic principles.
- Modules, dependencies, data, resources, processes, functions, interfaces, 
types, data structures, types, constants, variables.
- Issues.
- Risks.
- Improvements not implemented.
- TEST CASE DESIGN


Procedures Supported by Design

- Initial development.
- Change in requirements.
- Fixing defects.


Rules

- Design must be "reviewable" in that review of design will find defects.
- It must be possible to read the design and implement it without further 
clarification, except from other documents referenced, recursively.  (This 
could be all documents, though.)
- Any "correct" implementation of the design must meet requirements.
- Requirements must be stated or referenced.
- Design decisions must be stated, tagged, and justified in terms of 
requirements.  (Need to explain what "justified" means.)
- All declarations must be covered.
- All declarations must refer back to the design.
- It must be clear where requirements are exceeded rather than just met.
- Provide estimates and actual LOC for implementation?
- Warn the implementor/modified/user about things.
- Source documents must be listed.
- Cover all test cases.  Need to ensure that implementation meets requirements 
with some degree of confidence, which we should try to work out.
- All declarations must be documented.
- Requirements must be complete.
- Structure of the document must be clear.  Provide contents.
- References to implementation are encouraged (maybe not).

ATTACHMENT
   "Justification Diagram"

