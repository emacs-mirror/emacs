                      GUIDE TO WRITING MMQA TESTS
                           guide.test.writing
                               draft doc
                             rit 1999-06-24

INTRODUCTION

.purpose: This document describes how to write tests that can be run with the 
MMQA harness.

.background: It's assumed you know how to use the MMQA harness. If not, see 
guide.mmqa.

.readership: Anyone in MM or MMQA.


Document history

.hist.0: rit started on a first draft.
.hist.1: First version. Applied to harness version 3.3. It's not very detailed, 
but it's a start. rit 1999-08-04


TEST FILES

.file: Each test is typically a single file, though it may make use of 
functions provided in test libraries or read input from other files.

.header: A test file must contain a test header which tells the harness how to 
run the test, and how to decide whether it passed or failed. The start and end 
of the test header are indicated by the strings "TEST_HEADER" and "END_HEADER". 
If the test includes an output specification, this is indicated by the string 
"OUTPUT_SPEC" occuring within the header. Both the test header proper (i.e. the 
part before "OUTPUT_SPEC") and the output specification consist of a series of 
items, separated by line breaks (semicolons may also be used to separate 
items). A "\" at the end of a line will swallow up the following line break, 
and "\;" may be used to include a semicolon in an item.

For example:

.header.example:
   TEST_HEADER
    id = $HopeName: MMQA_test_function!482.c(trunk.2) $
    harness = 3.1
    summary = should not display angry warthog (request.mps.123456)
    language = c; link = testlib.o rankfmt.o
    parameters = ITERATIONS=64 DEPTH BIGSIZE=(1024*1024*3)
   OUTPUT_SPEC
    completed = yes
    size1 > 1024
   END_HEADER


.header.item: Each item consists of a name, a relation, and a value. Whitespace 
is ignored before and after each of these. In addition, any number of non-word 
characters are ignore at the start of an item, to allow you to embed the test 
header in a series of comments.

.header.item.name: A name is a string of 1 or more word characters, i.e. 
letters, digits and blah (underscore).

.header.item.relation: For the test header proper, the relation must always be 
"=". For the output specification, the relation must be one of "=", "=~", "<=", 
">=", "<", ">" and "P=". These relations have the following semantics:-
"="   check that test output value is this string
"=~" check that test output value matches this pattern (using PERL regexp 
syntax) 
"<=" check test output value is numerically less or equal to this value
">=" check test output value is numerically greater or equal to this value
"<"  check test output value is numerically less than this value
">"  check test output value is numerically greater than this value
"P=" (Pathname equals) check that the test output value pathname matches this 
value. All name components in the value will be checked (but the output 
pathname may have additional leading compnents). Any of the normal pathname 
component separators are acceptable ("/", "\", ":") .

.header.item.value: The value is any (non-empty) sequence of characters. (But 
note that whitespace at the beginning or end of it will be stripped.)



TEST HEADER ITEMS

.item.id: This should be set to the hope name of the test file, if it has one. 
Compulsory.

.item.summary: This should be a one-line description of the test. Compulsory.

.item.language: Currently, only two languages are supported, "english" and "c". 
If your test is a c-programme, you must set this to "c" as in the example 
above. Compulsory.

.item.link: A space-separated list of test libraries the test should be linked 
with. They should be written as if on a unix platform, i.e. with ".o" at the 
end. (The harness will do whatever conversion is necessary on platforms with 
different naming conventions, such as Windows NT.) Compulsory for tests written 
in c.

.item.parameters: The names of the test's parameters, possibly with default 
values. Optional, default is no parameters.

.item.harness: The minimum harness version this test requires to run. To be 
safe, set it to whatever version of the harness you use when you write the test 
("qa options" shows you the harness version). Recommended.

.item.stdin: The name of a file (from DATA_DIR) to use as the default standard 
input for this test. Optional, defaults to standard input.

.output_spec: Items in the output specification can have any names you choose, 
and either numerical or string values. If no output specification is given, the 
harness assumed the requirement is "completed = yes".



TEST OUTPUT

.output: This section applies only to tests with "language = c".

.output.stdout: When the test is run, it should produce output on stdout.

.output.comment: Empty lines of output, or lines beginning with "%", are 
comments and will be ignored by the test harness.

.output.result: Output lines beginning with "!" are results. Each such line 
should be of the form "!<name>=<value>". If there are multiple output lines 
with the same <name>, the harness considers only the last one.

.output.other: Do not write tests that produce output lines other than comments 
and results. The behavour of the test harness when it encounters such ouput 
lines is undefined. In most situations, however, the harness will report an 
error in the output, and give up.

.output.stderr: Lines written to stderr are currently also treated as output, 
but you shouldn't rely on this.


JUDGEMENT

.judgement: The harness will deem a test to have been passed iff all the 
conditions specified in the output specification are true, after the name of 
each item in the output specification has been replaced by the value for that 
name in the test resuts. If a condition is false, or there is no result 
corresponding to a name in the specified output, then the test has been failed.


TEST EXAMPLE

.example: Here's an example of a test written in C, with some 
discussion/explanation below:

 1  /*
 2  TEST_HEADER
 3   id = $HopeName: MMQA_test_function!173.c(trunk.1) $
 4   harness = 3.0
 5   summary = Get the last page in a chunk into the hysteresis fund
 6   language = c
 7   link = testlib.o
 8   parameters = CHUNK_SIZE=(1024*1024) OBJ_FROM=(1024*1024*2) \
 9                OBJ_TO=(1024*1024*3)
10  OUTPUT_SPEC
11   completed = yes
12  END_HEADER
13  */
14
15  /* This test was written to provoke the assertion in
16     request.epcore.160256 (Assertion failure while purging the
17     hysteresis fund.)
18
19     drj suggested that the assertion would be provoked if we
20     arranged for an arena chunk to have less than one whole
21     page description on the last page occupied by the page table,
22     arranged for the page corresponding to this page description
23     to be in the hysteresis fund, and then purged the fund.
24
25     This test attempts to cause this situation by creating an arena
26     with a small chunk size, allocating an object that's bigger
27     than the chunk size (hence causing a new chunk to be created),
28     freeing it, then destroying the arena again. We repeat with
29     different object sizes, until (we hope) eventually there is
30     only a partial page descriptor in the last page occupied by
31     the page table.
32 
33     We use an EPDR pool to increase the chance of the object covering
34     the last page (but it's a VM arena so we can't be sure what zones
35     will be used). Of course, the test is sensitive to the algorithm
36     by which the arena decides how big to make the new chunk.
37  */
38  
39  #include "testlib.h"
40  #include "mpsavm.h"
41  #include "mpscepdl.h"
42 
43  mps_arena_t arena;
44  mps_thr_t thread;
45  mps_root_t root;
46 
47  static void test(void)static void test(void)
48  {
49   mps_pool_t pool;
50   mps_addr_t a;
51   size_t objsize;
52 
53   for (objsize = OBJ_FROM; objsize < OBJ_TO; objsize += 4096) {
54 
55    report("objsize", "%d", objsize);
56 
57    die(mps_arena_create(&arena, mps_arena_class_vm(), (size_t) CHUNK_SIZE),
58     "create arena with 1MB chunk size");
59    die(mps_thread_reg(&thread, arena), "register thread");
60    die(mps_pool_create(&pool, arena, mps_class_epdr(), 65536, 32, 8),
61     "create EPDR pool");
62 
63    mps_arena_spare_commit_limit_set(arena, (size_t) OBJ_TO);
64 
65    die(mps_alloc(&a, pool, objsize), "alloc");
66    mps_free(pool, a, objsize);
67 
68    mps_pool_destroy(pool);
69    mps_thread_dereg(thread);
70    mps_arena_destroy(arena);
71    comment("Ok");
72   }
73  }
74 
75  int main(void)
76  {
77   easy_tramp(test);
78   pass();
79   return 0;
80  }


.example.testlib.h: The harness provides many useful functions in a test 
library. To use them, you should #include "testlib.h" [39] and link with 
testlib.o [7]. (Numbers in square brackets are line numbers in the example 
above.) To see the prototypes for these functions, look in 
"mmqa/test/testlib/testlib.h".

.example.no-mps.h: If you #include "testlib.h" [39] there is no need to 
#include "mps.h" also.

.example.main: The test must provide a function "main" [75]. It's not important 
what it returns [79]; in particular, the value returned does not indicate 
success or failure of the test.

.example.easy_tramp: Do not use mps_tramp: instead use the "easy_tramp" 
function [77] in the test library whenever you want to use mps (which 
presumably you do). It takes (a pointer to) a function to call, and has no 
return value; the function called should have no parameters and no return value 
[47]. easy_tramp will:
  (1) call mps_tramp if appropriate (i.e. unless PRODUCT=epcore),
  (2) if the platform is windows NT, install a structured exception handler to 
catch access violations and report them in a format the test harness 
understands,
  (3) install an mps assertion handler, that will report MPS assertions in a 
format the test harness understands.

.example.pass: The function "pass" [78] reports the result "completed=yes", 
which is the default specified output (in this example, it's explicitly 
specified). There is also a function "fail" which reports "completed=no".

.example.report: To report other results, use "report" [55]. It takes the name 
of the result, a printf-style format string for the value, and other parameters 
depending on the format string. Do not use a value which includes a newline.

.example.comment: To output comments, use "comment" [71]. It takes a 
printf-style format string and possibly other parameters depending on the 
format string.

.example.die: Calling "die(<result>, <string>)" [57, 59, 60, 65] will check if 
<result> is MPS_RES_OK. If it is, the test will continue. If is isn't, a 
comment will be output consisting of <string> and a textual representation of 
<result>, the results "error=true" and "errtext=<string>: <result>" will be 
reported, and the test will be aborted. Use "die" whenever you make a call 
which ought to succeed, as a convenient way to check that it does. Related 
functions: "cdie" is identical except it always outputs a comment. "adie" is 
identical except it always reports an error and aborts.

.example.parameters: Test parameters are used within the body of the test just 
as if they had been #defined to their values. [53, 57, 63]. (Of course, that is 
exactly how they are implemented.)



OTHER POSSIBLY USEFUL FUNCTIONS

.testlib.adie: identical to "die" (see .example.die above) except it treats all 
result codes as errors.

.testlib.cdie: identical to "die" (see .example.die above) except is always 
displays a comment.

.testlib.error: The function "error" takes a prinf-style format string and 
corresponding other parameters, reports an error ("error=true", 
"errtext=<string>") and aborts.

.testlib.asserts: The function "asserts" takes an integer, a printf-style 
format string and corresponding further parameters. If the integer is non-zero 
it returns, otherwise it calls error as above.

.testlib.random: A call to "ranint(x)" (unsigned long x) returns a random 
natural number (including 0) less than x. A call to "ranrange(min, max)" (both 
unsigned long) returns a random integer x with min <= x < max. Both these 
functions are deterministic, and will give the same results each time a test is 
run.


INTERFACE VERSIONS

.prefix.mps: The test harness thinks that all symbols beginning "mps" or "MPS" 
or "_mps" or "_MPS" are reserved by the mps. Therefore none of the symbols 
defined in the test libraries begin this way, and neither must any symbols you 
define in the test.

.check.symbols: Before running a test, the harness (since version 3.3) will 
check that it doesn't mention any symbols which are known not to be defined in 
MPS header files. If such symbols are mentioned, the harness will give up 
without trying to compile the test, and report the missing symbols in the test 
results.

.check.symbols.except: Exception to the above: the harness knows how to emulate 
certain symbols when they are not defined in the MPS header files of the 
release you're testing. Thus you can safely use, for example, 
mps_spare_commit_limit, in your tests (it will return zero in early releases of 
MPS). You probably won't want to do this though.



