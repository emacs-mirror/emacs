               GUIDE TO USING MACROS IN C IMPLEMENTATIONS
                           guide.impl.c.macro
                            incomplete guide
                           gavinm 1998-04-28

INTRODUCTION

.intro: This document describes the MM Group conventions for use of macros in 
internal C implementations.

.readership: This document is for any MM developer.


GUIDELINES


General

.length: Macro names must never exceed 40 characters in length.  Ideally this 
would be 31, from the minimum number of significant characters in a macro name 
specified in ISO 9899:1990 subclause 5.2.4.1.


Method-Style Macros

.method: A method-style macro is one that is entirely interchangeable with a 
function implementation (but see .method.proc for an exception).

.method.name: Method-style macros are named as for methods (see 
guide.impl.c.naming.macro.method).

.method.eval: A particular consequence of .method is that each argument should 
be evaluated precisely once.  [Need to say somewhere else that method arguments 
(meaning arguments to methods that might be implemented either as a macro or as 
a function) should be side-effect free.]

.method.proc: An exception to .method is that procedural methods (methods whose 
functional implementation would return void) may be either expressions of type 
void, or statement blocks.  Such blocks must absorb a semi-colon, typically by 
using BEGIN and END.  [Need to say somewhere else that invocations of 
procedural methods must not assume they are expressions.  This isn't so 
important because abuse is certain to cause compilation errors when the 
implementation is a macro that expands to a statement block.]  [It could only 
happen in a "," expression or a (pointless) cast to void anyway.  drj 
1998-10-30]

.method.context: A consequence of .method is that method-style macros should be 
consistently an expression or a block regardless of context.  For example, 
blocks containing an "if" statement must not absorb a following "else", and 
comma expressions must be bracketed.  

.method.arg: A consequence of .method is that method-style macros should be 
guarded against the syntax of their argument expressions.  Uses of the 
parameters should always be parenthesised, except where they are used directly 
as an argument of a function or a method-style macro.  This avoids all sorts of 
problems with unexpected operator precedence and with unusual or surprising 
token sequences inside the macro arguments.

.method.getter.rvalue: A consequence of .method is that "getter" method-style 
macros (meaning access methods for structure members) should not be lvalues; 
that is, you should not be able to change the accessed value by assigning to 
the getter method.  Use (the macro) RVALUE to ensure this.

[Additional exceptions to .method that are obvious, but ought to be said, are 
that you can't take a function pointer, you can #undef the macro, and funny 
things happen when the argument is a macro the expansion of which contains a 
comma.]


Constant-Style Macros

.constant: A constant-style macro is one that is entirely interchangeable with 
a constant value.

.constant.name: Constant-style macros are named as constants (see 
guide.impl.c.naming.macro.const).

.constant.type: Constant-style macros should always be explicitly cast to the 
appropriate type (even where this is not strictly necessary).  This ensures 
that the meaning of it when used in code is as unambiguous as possible.  It 
also means that surprising conversions to different types are reduced and 
dangerous ones are potentially diagnosed.  .constant.type.example.bad: Consider:

#define FooControlLowBitsMask 0xff
extern Word FooControl;

We can reset all but the bottom 8 bits of FooControl with "FooControl &= 
FooControlLowBitsMask".  You might think we could reset the bottom 8 bits with 
"FooControl &= ~FooControlLowBitsMask".  Unfortunately this goes wrong because 
the expression "~FooControlLowBitsMask" is performed using the int type; on 
platforms where int is strictly shorter than Word then this isn't what you 
wanted.  The original #define should be: "#define FooControlLowBitsMask 
((Word)0xff)".


Magic Macros

.magic: A magic macro is any macro that is neither method-style nor 
constant-style.  Typically such macros may use or set local variables, use 
context-sensitive macros (such as __FILE__ and __LINE__), vary control flow 
(with "break" or "return" statements), be neither an expression nor a 
statement, take a type as an argument, or perform token pasting.

.magic.name: Magic macros are named in underscore joined upper case (see 
guide.impl.c.naming.macro.special).

.magic.context: Unless specifically required, magic macros should be as unmagic 
as possible.  In particular, they should be guarded against their context and 
arguments in the same way as method-style and constant-style macros are.

.magic.avoid: Magic macros should be avoided, if possible.

