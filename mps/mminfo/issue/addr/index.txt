                    THE PURPOSE OF ADDR ISN'T CLEAR
                               issue.addr
                       obsolete complete defect 
                           richard 1995-08-17

Urgency: 3 - useful
Importance: 4 - relevant
Discoverer: richard
Discovery date: 17/08/95 11:48:58
Locaction: pervasive


DESCRIPTION:

The "Addr" type is really the "word" or "address" type of the processor 
architecture.  What is it intended to be used for?  The code uses it as a 
general unsigned integer which is "big enough" to do various things, including 
sizes, differences between pointers, addresses (of course), loop indexes, etc.

ROOT CAUSE:



SUGGESTIONS:

The purpose of Addr should be thought out, written down, and implemented.  
Possibly we should add other aliases for things like sizes, differences, etc. 
so that the intention of code is clearer.

PROCESS SUGGESTIONS:



Resolver: richard
Resolution: X-Sender: richard@mailhost.cam.harlequin.co.uk
Mime-Version: 1.0
Date: Fri, 8 Sep 1995 11:39:34 +0100
To: mm
From: richard (Richard Brooksby)
Subject: Breaking down addr
Cc: nickb

"Addr" means "unsigned integer large enough to hold a pointer".  Both
Tucker and dsm have observed that it is too overloaded in our code, and
should be broken down into other types with more semantic content.

Searching through the code, I've found the following uses of Addr:

  - address
  - reference
  - size
  - offset (i.e. difference of addresses)
  - alignment (power of two)
  - count of bytes allocated/free
  - ordinal loop index
  - reference signature implementation (bitset of zones)

I think we should go through these and work out what to do in each case.
Here are my comments and suggestions.  Please give let me know what you
think.

Address

A C-like external client (such as the RIP, perhaps) is going to want to
talk to us in terms of void * and size_t.  Internally, we want to
differentiate addresses of objects we manage from our own use of void * as
a generic pointer.  However, it would be good to be able to go directly
from one to the other without the need for an extra level of function call
and cast.

We can achieve this in C by making Addr (when used as an address) an alias
for void *.  This can be done for any platform on which we are managing the
address space addressable by void *, which is all of them at present.  I
therefore suggest that we use the type "Addr" for addresses and typedef
this to void * in our platform-specific header.

Reference

A reference is subtly different from an address.  Our implementation pretty
much assumes that a reference is an address.  Generic fix, for example,
uses the reference as an address in order to do the zone check and look up
the pool which owns the referent.  Our current and projected clients are
also unlikely to want a hard distinction between the two.

Logically, however, they are quite different, and it would be a good thing
if we could tell when we were making the assumption that they were the
same, by converting one to the other explicitly.  This would involve no
actual code overhead if they are aliases for the same type.

I suggest we have a type "Ref" which is an alias for "Addr".  References
will be the currency of fix instructions, and of allocations.

Size

As I mentioned, a C-like client is going to want to talk in terms of
size_t.  This is a problem on SunOS, where size_t is a signed integer
(strange but true).  Is a size always as big as a pointer?  Dsm pointed out
that we might want to manage a 32-bit region of a 64-bit address space, and
so none of our objects would ever be larger than 4Gb though our pointers
would be larger.  This is a good reason for having a logical Size type,
imo.

Offset

Is an offset any different from a size?  A size is the difference between
two addresses: the limit and the base address of an area.  An offset is
also a difference, but perhaps it could be larger.  I'm not sure, and would
welcome suggestions.

Dsm points out that offset_t (as defined by ANSI) is pretty useless, as it
is not guaranteed to be any particular size.  If could be a signed char.

Alignment

An alignment is a power of two used for rounding.  I think it's probably
worth distinguishing this from a size.

Counts

Addr is used in places to count total numbers of bytes.  There are two
uses: the total in existence at any one time, and a total over time.  The
former cannot exceed the size of the managed memory, so a Size is adequate.
The latter can easily overflow an integer that can hold any address -- in
fact it is unbounded over time.  (Nick, how does MLWorks count?)  Do we
need some sort of large integer arithmetic for accounting and statistics?

Ordinal Loop Index

Addr is used in places to count N things, where N is size/size.  Is it a
size?  Should this have its own type?

RefSig Implementation

Reference signatures are bitsets whose size is chosen from the size of the
registers on the machine, so that the zone check is fast.  We should choose
a type for this, because it's not really related to Addr at all.

---

To: richard (Richard Brooksby)
Cc: mm
Subject: Re: Breaking down addr 
Date: Fri, 08 Sep 1995 11:55:43 +0100
From: Nick Barnes <nickb>

richard> Counts
richard> 
richard> Addr is used in places to count total numbers of bytes.  There are two
richard> uses: the total in existence at any one time, and a total over time.  
The
richard> former cannot exceed the size of the managed memory, so a Size is 
adequate.
richard> The latter can easily overflow an integer that can hold any address -- 
in
richard> fact it is unbounded over time.  (Nick, how does MLWorks count?)  Do we
richard> need some sort of large integer arithmetic for accounting and 
statistics?

When writing the MLWorks space profiler I came up against this
problem. It's a pain to use a larger type, because of the overhead
(almost all counts are small), but casing on a union or using bignums
is even worse. I settled on this code:

MLW> /* struct large is substituted for size_t where we want more than 32
MLW>  * bits. It allows 52 bits (this number chosen to make conversion into
MLW>  * ML values, which use megabyte/byte pairs, easy). */
MLW> 
MLW> struct large {
MLW>   unsigned long high;      /* top 32 bits */
MLW>   unsigned long low;       /* bottom 20 bits */
MLW> };
MLW> 
MLW> #define HIGH12(x)  ((x)>>20)
MLW> #define LOW20(x)   (((x)<<12)>>12)
MLW> 
MLW> #define inc_large(large,increment)                                 \
MLW> do {                                                                       
\
MLW>   unsigned long l = (large).low+(increment);                               
\
MLW>   (large).high += HIGH12(l);                                               
\
MLW>   (large).low = LOW20(l);                                          \
MLW> } while(0)
MLW> 
MLW> #define add_large(large1,large2,large3)                                    
\
MLW> do {                                                                       
\
MLW>   unsigned long l = (large1).low+(large2).low;                             
\
MLW>   (large3).high = (large1).high + (large2).high + HIGH12(l);               
\
MLW>   (large3).low = LOW20(l);                                         \
MLW> } while(0)
MLW> 
MLW> #define zero_large(large)  do { (large).low = (large).high = 0 } while (0)
MLW> #define large_zero_p(large)        (((large).low == 0) && ((large).high == 
0))
MLW> #define double_large(large) (((double)(large).high)*1048576.0+(large).low)

(double_large() is used when printing profiler reports directly from
C).

Nick

---

To: richard (Richard Brooksby)
Cc: mm
Subject: Re: Breaking down addr 
Date: Fri, 08 Sep 1995 12:19:45 +0100
From: Nick Barnes <nickb>

> I suggest we have a type "Ref" which is an alias for "Addr".  References
> will be the currency of fix instructions, and of allocations.

macros for converting references to and from addresses?

> Size

A size is a number (of bytes). Yes, it should be logically separate
from an address. A size is a (non-negative, bounded) integer, an
address is a pointer.

> Counts

A count is a non-negative unbounded integer, and thus distinct from a
size. See my earlier mail.

> Ordinal Loop Index
> 
> Addr is used in places to count N things, where N is size/size.  Is it a
> size?  Should this have its own type?

IMO this is a size (i.e. a non-negative integer bounded by - at most -
the size of the memory you are managing).

> RefSig Implementation
> 
> Reference signatures are bitsets whose size is chosen from the size of the
> registers on the machine, so that the zone check is fast.  We should choose
> a type for this, because it's not really related to Addr at all.

This is another bounded integer (signedness irrelevant). I agree, this
should be another typedef.

Nick B

---

From: David Moore <dsm>
Date: Fri, 8 Sep 95 13:45:35 BST
To: richard
Subject: Re:  Breaking down addr
Cc: mm, nickb

> Address
> 
> A C-like external client (such as the RIP, perhaps) is going to want to
> talk to us in terms of void * and size_t.  Internally, we want to
> differentiate addresses of objects we manage from our own use of void * as
> a generic pointer.  However, it would be good to be able to go directly
> from one to the other without the need for an extra level of function call
> and cast.
> 
> We can achieve this in C by making Addr (when used as an address) an alias
> for void *.  This can be done for any platform on which we are managing the
> address space addressable by void *, which is all of them at present.  I
> therefore suggest that we use the type "Addr" for addresses and typedef
> this to void * in our platform-specific header.

I think that it would be nice to be able to provide a 32-bit
implementation of the MPS on an alpha.  Eg. by using the -taso option
to the C compiler on OSF, which ensures the programs segments lie
below 2^31.  We may wish to have shorter than natural pointers as well
as shorter than natural sizes.

Also be careful about what happens when we add to an address.  I would
be happy if we created macros to do all such operations explicitly.
If we rely on C to have appropriate types such that "+" and "=" etc do
the thing we mean then that somewhat restricts our flexibility.  This
as you say about explicit conversion for references will involve no 
actual code overhead.

Another reason for defining such operations explicitly is that we
only check them all at once by putting them in the same place.
I think this is hard because for example in ANSI C:

UType a,b; /* where UType is _some_ unsigned type 
              then the expression */
(a+b) /* will not neccessarily be of type UType and maybe signed or
         unsigned depending on the type of UType
         and the relative sizes of char, short and int */

> Reference
> [..]
> Size
> [..]
I agree.

> 
> Offset
> 
> Is an offset any different from a size?  A size is the difference between
> two addresses: the limit and the base address of an area.  An offset is
> also a difference, but perhaps it could be larger.  I'm not sure, and would
> welcome suggestions.
> 
> Dsm points out that offset_t (as defined by ANSI) is pretty useless, as it
s/offset/ptrdiff/
> is not guaranteed to be any particular size.  If could be a signed char.

I would use the unsigned (alias of the) Size type (or whatever type is
big enough) to take the difference between two addresses.  My gripe is
that although the result may be signed conceptually, using a signed
type of the same size doesn't work because the range is not big
enough.  As you know (a<b) and (a-b<0) are very different things.  To
do such comparisons you have to be careful.  By using unsigned types
this forces us to get them right, rather than sweeping the problem
under the carpet.

Another reason is that ANSI C defines subtraction and addition over the
entire domain for unsigned types but not for signed types.

> Alignment
> 
> An alignment is a power of two used for rounding.  I think it's probably
> worth distinguishing this from a size.

If you abstract this properly then we should have the choice of
implementing this by storing 2^n as we do now, or storing n.

> Counts
> 
> Addr is used in places to count total numbers of bytes.  There are two
> uses: the total in existence at any one time, and a total over time.  The
> former cannot exceed the size of the managed memory, so a Size is adequate.
> The latter can easily overflow an integer that can hold any address -- in
> fact it is unbounded over time.  (Nick, how does MLWorks count?)  Do we
> need some sort of large integer arithmetic for accounting and statistics?

Every instance of a count should be of a type that is sufficiently
large.  It would be a mistake (that you have not made) to think that
you can just define a Count type and be done with it.  You have to
reason about every occurrance.  It will usually turn out that Size is
logically the right type to use.  There are naming conventions to
exhibit the use of a variable.  Or perhaps using types is right and
we should have types Addendum, Subtrahend, Minuend etc.  I think not.

> Ordinal Loop Index
> 
> Addr is used in places to count N things, where N is size/size.  Is it a
> size?  Should this have its own type?

No.  Same as for Count.

> RefSig Implementation
> [..]
I agree

---

From: David Moore <dsm>
Date: Fri, 8 Sep 95 14:01:12 BST
To: nickb, richard
Subject: Re: Breaking down addr
Cc: mm

Counting large values

We don't have to worry about fitting into ML values conveniently:

typedef struct {unsigned h,l;} Unsigned;

Unsigned Inc(Unsigned s, unsigned t)
{
  Unsigned d;
  d.l = s.l + t;
  d.h = s.h + (d.l<t);
  return d;
}

Unsigned Add(Unsigned s, Unsigned t)
{
  Unsigned d;
  d.l = s.l + t.l;
  d.h = s.h + t.h + (d.l<t.l);
  return d;
}

etc.

This structure passing may not compile efficiently.

---

To: David Moore <dsm>
Cc: richard, mm
Subject: Re: Breaking down addr 
Date: Fri, 08 Sep 1995 14:34:13 +0100
From: Nick Barnes <nickb>

> UType a,b; /* where UType is _some_ unsigned type 
>             then the expression */
> (a+b) /* will not neccessarily be of type UType and maybe signed or
>          unsigned depending on the type of UType
>          and the relative sizes of char, short and int */

According to my reading, if UType == unsigned long, a+b is of type UType.

Nick B

---

From: David Moore <dsm>
Date: Fri, 8 Sep 95 14:48:05 BST
To: nickb
Subject: Re: Breaking down addr
Cc: mm, richard

> From nickb Fri Sep  8 14:34:23 1995
> 
> > UType a,b; /* where UType is _some_ unsigned type 
> >           then the expression */
> > (a+b) /* will not neccessarily be of type UType and maybe signed or
> >          unsigned depending on the type of UType
> >          and the relative sizes of char, short and int */
> 
> According to my reading, if UType == unsigned long, a+b is of type UType.
>
> Nick B

Agreed.  It is also true if UType == unsigned int.  My point is that
you can't expect this to be the case for the other sizes.  Imagine we
decided that Size only needed to be an unsigned short for some platform
or particular instance of the MPS, then things might stop working if we
were not careful.

---

X-Sender: ptw@mailhost.harlequin.com
Mime-Version: 1.0
X-Header-Sticker: Honk if you love GC's
X-Attribution: (name withheld by request)
Date: Fri, 8 Sep 1995 10:22:27 -0400
To: richard (Richard Brooksby)
From: ptw (P. Tucker Withington)
Subject: Re: Breaking down addr
Cc: mm, nickb

Input from others seems to have this well covered.  I will only add the
following historical notes:

In Genera, it was useful to have:

  Reference - a pointer that pointed to managed memory, one the GC must trace
  Address - a pointer that points to any memory, one the GC must _not_ trace
    (More of an issue in Genera, because traceability was hardware enforced,
     so when the GC was manipulating old-space addresses it had to cast from
     Reference to Address to avoid traps)
  Offset - (signed) difference between References or Addresses
    (Used, e.g., to update a forwarded object)
  Size - (unsigned) difference between Refernces or Addresses
    (Used, e.g., to iterate over the slots of an object)
  Fixnum, 2-word Bignum - (signed) counters, accumulators, etc.
    (In Minima, we actually had 3 integer types: Fixnum, Midnum, and Bignum.
     Midnums were 64-bit signed integers, with the sign stored in the CDR-code
     field.  By storing the sign separately, the math was simplified.  Genera
     used 2-word bignums, rather than invent a new type, but had hand-crafted
     math operations that did modular math rather than consing bigger numbers
     on overflow)
  Bitvectors - 1-word and arrays of integers

In earlier versions of Genera, some of these types were not separated out.
E.g., address, fixnum, and offset.  A number of bugs that could have been
caught by the compiler went unnoticed because of this.  E.g., adding
addresses, adding and address and an integer.

Note that Genera is a word-based machine.  RISC architectures are trending
that way.  As part of this discussion, you might want to consider what unit
size, offset, and count are in.  E.g., a count of allocated storage might
be kept in words to extend it's lifetime before overflow.

Counters were pre-determined to either be fixnum or midnum, by static
analysis of their plausible range.  Accumulators that accumulated deviation
required 64*32 multiply (and 64-bit integer square root on output).
Counter overflow was ignored (wrapped).  We all dreamed for the day a
system would stay up so long a counter would actually wrap...



