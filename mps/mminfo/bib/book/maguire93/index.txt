                           WRITING SOLID CODE
                             Steve Maguire
                       Microsoft Press, 01/01/93
                           ISBN 1-55615-551-4

                             book.maguire93
                                 draft
                           richard 1995-07-31


ABSTRACT:

Writing Solid Code provides practical approaches to the prevention
and automatic detection of bugs.  Throughout, Steve Maguire draws
candidly on the history of applicatino development at Microsoft for
cases in point -- both good and bad -- and shows you how to use proven
programming techniques to produce solid code.

REVIEWS:

0. Introduction

Hungarian Notation: a simplified version is used. For more information,
see 'Meta-Programming: A Software Production Method', Charles Simonyo
(Stanford University 1977, Xerox PARC 1977). 

The idea is to (as much as possible) avoid introducing bugs. 

1. A Hypothetical Compiler

The best way to eliminate bugs is to find them as early and as easily
as possible. Look for ways to catch them automatically, such as compiler
warnings, lint, prototypes, and unit tests. 

Compilers often have optional checking for dangerous idioms
(e.g. 'if (x = y)'). Enable them. Turn on every warning unless you have
an excellent reason not to do so.

Use prototypes, with accurate types. Use lint and similar tools to
catch bugs that the compiler might miss. If you have unit tests, use them.

2. Assert Yourself

Maintain both ship and debug versions of your program. Debug code should be
code which is _additional_ to ship code (which should execute in the debug
version).

Use assertions to validate function arguments. Remove undefined behaviour
from your code, or use assertions to catch uses of it. Document assertions.
Either remove implicit assumptions, or assert that they are valid. Assertions
are for illegal conditions, not exceptional ones. Use assertions to detect
'impossible' conditions. Use assertions to reveal bugs hidden by defensive
programming. Adding assertions will probably dramatically increase bug counts.
This is a _good_ thing, but people should be warned of it. Assertions are 
forever. 

Use a second algorithm to validate your results. Use startup checks for tables
&c, rather than waiting for bugs to happen. 

3. Fortify Your Subsystems

How are programmers likely to misuse subsystems? Add assertions and validation
checks. Consider at the design stage how to add checks. 

Eliminate random behaviour; force reproducibility (e.g. make malloc fill with
a useful value). Destroy your garbage memory or other objects (make free zap
objects on deallocation). If something happens rarely, force it to happen often
(e.g. force realloc to move blocks). Design your tests carefully; nothing
should be arbitrary (e.g. fill values).

Use #ifdef for debug-only local variables. 

Keep records of information to help with debugging and allow stronger error
checks. Create thorough subsystems checks and use them often. 

Implement transparent integrity checks, that work whether or not the programmer
is aware of them; don't make the programmer work to check for integrity.

You don't ship the debug version, so don't worry about speed and size. 

4. Step Through Your Code

Be confident about your code. Step through it with a debugger when it is new.
Step through each code path. Don't make sweeping changes (unless you can avoid
it): they are liable to be buggy and are less likely to be thoroughly checked.
Focus on dataflow as you step. Consider turning off optimizations for a
stepping version. Step through critical sections at the instruction level. 

5. Candy-Machine Interfaces

Write interfaces to your subsystems that are hard to misuse. Make it hard to
ignore error conditions (i.e. don't return 'error values' but take arguments
call-by-reference and return a good/bad flag). Always look for flaws in
interfaces (e.g. Resize should return a flag, because otherwise the user will
just go ptr = Resize(ptr,...), and kill ptr with NULL if the resize fails).
Don't write multipurpose functions, resolved to do _something_ useful whatever
the arguments (e.g. realloc can substitute for free and for malloc). Write
separate functions and validate arguments (see chapter 2). Write functions that
cannot fail given valid inputs (i.e. all invalid inputs must be asserted).
Avoid boolean arguments that select between two different behaviours (use named
constants). Write comments and documentation that emphasize the requirements
and hazards; give usage examples in comments if it is at all unclear.

6. Risky Business

Use well-defined data-types. -32768 is not necessarily a valid int in C. Chars
are sometimes signed and sometimes unsigned. Always ask whether variables and
expressions can overflow. Implement designs as closely as possible; 'kinda close
is kinda buggy'. Implement 'the task' of a function just once if possible; 
design
your data structures and algorithms with this in mind. Get rid of extraneous 
'if'
statements. Terse code is not (necessarily) efficient code. Handle special cases
just once. Avoid risky language idioms (e.g. pointers that don't point to 
anything,
comparisons with zero, bitshifts to multiply/divide. Don't go all out for
efficiency unless it makes sense to do so (i.e. don't overestimate the cost of 
any
particular piece of code). Don't needlessly mix operator types; if you must, use
parentheses. If you have to look up the precedence, it isn't obvious; use 
parentheses.
Isolate error handling; lift common code. 

7. Treacheries of the Trade

Don't reference memory that you don't own or that you have freed. Don't play 
fast
and loose to get efficiency. Don't use output memory as workspace, or return
pointers to your statics or to globals. Don't write parasitic functions (that
depend on the implementation of their callees). Don't abuse your programming
language (by using legal tricks that are difficult to read, that violate the
'spirit' of the language, that might become illegal in later standards). Write
code for the average programmer to maintain. WRITE 'BORING' CODE (i.e. simple &
elegant).

8. The Rest is Attitude

Bugs don't 'just go away'. Find out _why_ it went away. Don't fix bugs later,
fix them now. Fix the cause, not the symtom. Don't clean up the code unless the
clean-up is critical to success. Don't implement nonstrategic features. There 
are
no free features. Don't allow unnecessary flexibility. Don't "try" solutions:
find (research) a genuine solution and then use it. Write and test in small 
chunks.
Always test, even if that means a slip. Programmers are responsible for testing
their code from the _inside_. Don't blame testers for finding bugs. There are no
silly bugs.




