                INCREMENTAL COLLECTION OF MATURE OBJECTS
                     Richard Hudson and Eliot Moss
                       Springer-Verlag, 01/09/92
                  LNCS #637  International Workshop on
      Memory Management, St. Malo, France, Sept. 1992, pp. 388-403
           ftp://ftp.cs.umass.edu/pub/osl/papers/iwmm92.ps.Z

                               paper.hm92
                               incomplete
                            tony 1998-12-10


ABSTRACT:

We present a garbage collection algorithm that extends generational scavenging 
to collect large older generations (mature objects) non-disruptively.  The 
algorithm's approach is to process bounded-size pieces of mature object space 
at each collection; the subtleties lie in guaranteeing that it eventually 
collects any and all garbage.  The algorithm does not assume any special 
hardware or operating system support, e.g., for forwarding pointers or 
protection traps.  The algorithm copies objects, so it naturally supports 
compaction and reclustering.

REVIEWS:

Here's a quick overview of the algorithm. The details are all in
the paper - which is not long or a difficult read. It's also worth
looking at http://www.daimi.aau.dk/~beta/Papers/Train/train.html from
which I have condensed this overview. 

The Train Algorithm achieves its incrementality by dividing mature
object space into a number of fixed-sized blocks and collecting one
block at each invocation. The key contribution of the algorithm lies
in showing how all garbage (even cyclic structures larger than the
size of an individual block) can be recognized and reclaimed while
only processing a single block at a time. To achieve this, the
algorithm arranges the blocks into disjoint sets. The blocks are
referred to as cars, and to the set of blocks to which a car belongs as
its train.

Cars belong to exactly one train and are ordered within that
train. The trains, in turn, are ordered. This imposes a global
lexicographic ordering on the blocks in mature object space.

Each invocation of the Train Algorithm processes the lowest numbered
car of the lowest numbered train in the system. Its space is reclaimed
as follows.

First, a check is made to see whether there are any references into
the train to which the car being collected belongs. If not, then the
entire train contains only garbage and all its cars are reclaimed
immediately. (This is the part of the algorithm which enables large
cyclic garbage structures to be recognized and reclaimed, even if they
are too big to fit into a single car.)

Otherwise, all objects residing in the car being collected referenced
from outside the train are evacuated as follows. Objects referenced
from other trains are moved to those trains; objects referenced from
outside mature object space are moved to any train except the one
being collected. If a receiving train runs full, a new car is simply
created and hooked onto its end. Then, in typical copy collector
style, evacuated objects are scanned for pointers into the car being
collected, moving the objects thus found into the train from which
they are now referenced, and so on.

Objects promoted from younger generations may be stored in any train
except the one currently being collected, or new train(s)  may be
created to hold them.

With the transitive closure of all externally referenced objects
having been evacuated, the only live objects in the car being
processed are those referenced (exclusively) from cars further down
the train being collected. Such objects are evacuated to the last car
of the train, as are the objects they reference, etc.

At this point, none of the objects remaining in the car being
collected are referenced from the outside and are therefore
garbage. Thus, the space occupied by the car is reclaimed and the
collection is finished.

Here's how we can be sure that arbitrary cyclic data structures can be
collected when they become garbage: Given a garbage structure
contained in mature object space, denote the trains holding it the set
of "garbage trains". The structure of this set will not be changed by
the mutator because garbage objects are per definition unreachable and
therefore immutable. The collector, on the other hand, will cause the
set of garbage trains to shrink over time. As each garbage train is
processed, the objects residing there are either recognized as garbage
and reclaimed or evacuated to higher numbered garbage trains holding
references to them. When processing reaches the highest numbered
garbage train, the garbage structure will therefore have been
collapsed and will be reclaimed.



ATTACHMENT
   "iwmm92.ps"

