 COMBINING CARD MARKING WITH REMEMBERED SETS: HOW TO SAVE SCANNING TIME
       Alain Azagury;Elliot K. Kolodner;Erez Petrank;Zvi Yehudai
                             ACM, 01/10/98
                           ISMM'98 pp.10--19
 http://www.acm.org/pubs/citations/proceedings/plan/286860/p10-azagury/

                              paper.akpy98
                                 draft
                            pekka 1999-12-03


ABSTRACT:

We consider the combination of card marking with remembered sets for 
generational garbage collection as suggested by Hosking and Moss.  When more 
than two generations are used, a naive implementation may cause excessive and 
wasteful scanning of the cards and thus increase the collection time.  We offer 
a simple data structure and a corresponding algorithm to keep track of which 
cards need be scanned for which generation.  We then extend these ideas for the 
Train Algorithm of Hudson and Moss.  Here, the solution is more involved, and 
allows tracking of which card should be scanned for which car-collection in the 
train.

REVIEWS:

This technique is very similar to our zones and refsets, based on work by 
Hosking and Moss.  Cards are like pages, a simple write barrier notes dirty 
cards.  Remembered sets are deferred and calculated as needed by scanning dirty 
cards.  Remembered sets are more accurate but more costly than refsets, because 
they record the locations of all references, not just an estimate.

One clever bit of their algorithm is to minimize the work required to 
recalculate remembered sets when a card is dirtied.  The card mark is used to 
record the highest generation for which the remembered set is accurate, and the 
remembered set is only recalculated for generations that are collected.

They also use the train algorithm for mature objects.  For train, they 
implement a remembered set per car (cars contain many cards).  For a new car, 
the remembered set can be calculated from the remembered sets of the objects 
moved to it.  For an old car, only cards that have been modified since its 
remembered set was updated can affect its remembered set.

To take advantage of this observation, they implement something like a GC 
dependency:  remembered sets store the gc-number of their last update, cards 
store the gc-number of their modification.  A card modified before a remembered 
set was updated cannot affect the remembered set.

They have an interesting idea for the location dependency:  rather than having 
a max value, when their dependency-space is about to overflow, they "compress" 
it.  E.g., use integers 1-255 as gc-numbers, when they need 256, they find all 
gc-numbers, divide them by 4 and use 64 instead.

Questions revealed that they have not verified experimentally that their 
techniques are beneficial.

ptw 1998-11-06



