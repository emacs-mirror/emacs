                MACHINE-INDEPENDENT SUPPORT FOR GARBAGE
   COLLECTION, DEBUGGING, EXCEPTION HANDLING, AND CONCURRENCY (DRAFT)
                    Simon Peyton Jones;Norman Ramsey
                                07/08/98
           http://www.cs.virginia.edu/~nr/pubs/c--rtia4.ps.gz
        http://www.cs.virginia.edu/~nr/pubs/c--rti-abstract.html
                  (for other formats and abstract etc)

                              paper.pjr98
                               incomplete
                             drj 1999-02-26


ABSTRACT:

For a compiler writer, generating good machine code for a variety of platforms 
is hard work. One might try to reuse a retargetable code generator from another 
compiler, but code generators are complex and difficult to use, and they limit 
one's choice of implementation language. One might try to use C as a portable 
assembly language, but C limits the compiler writer's flexibility and the 
performance of the resulting code. The wide use of C, despite these drawbacks, 
argues for a portable assembly language. 

C-- is a new language designed expressly as a portable assembly language. 
C-- eliminates some of the performance problems associated with C, but in its 
originally-proposed form it does not provide adequate support for garbage 
collection, exception handling, and debugging. The problem is that neither the 
high-level compiler nor the C-- compiler has all of the information needed to 
support these run-time features. This paper proposes a three-part solution: new 
language constructs for C--, run-time support for C--, and restrictions on 
optimization of C-- programs. 

The new C-- language constructs enable a high-level compiler to associate 
initialized data with spans of C-- source ranges and to specify ``alternate 
continuations'' for calls to procedures that might raise exceptions. The 
run-time support is an interface (specified in C) that the garbage collector, 
exception mechanism, and debugger can use to get access to both high-level and 
low-level information, provided that the C-- program is suspended at a safe 
point. High- and low-level information is coordinated by means of the C-- spans 
and a common numbering for variables. Finally, the C-- optimizer operates under 
the constraints that the debugger or garbage collector can change the values of 
local variables while execution is suspended, and that a procedure call with 
alternate continuations can return to more than one location. 

This three-part solution also provides adequate support for concurrency, so the 
paper illustrates the problem and the proposed solution with examples from 
garbage collection, exception handling, debugging, and threads. The paper also 
includes a model of the dataflow behavior of C-- calls. 

A number of open problems remain. The most serious have to do with apparent 
redundancies among spans and safe points, and with the interaction of debugging 
support with optimization. 

This paper is very much work in progress. We are not yet satisfied with the 
solutions we've come up with. Perhaps you can help improve it. 

REVIEWS:

.review.drj: [from mail.drj.1999-02-26.something]

Review of

Machine-Independent Support for Garbage Collection, Debugging, Exception
Handling, and Concurrency (Draft)
by
Simon Peyton Jones, Norman Ramsey

See paper.jr1998 in the MM InfoSys for full bibliographic details.  See
http://www.cs.virginia.edu/~nr/pubs/c--rti-abstract.html for abstract
and downloads.

I had a quick browse through this paper today.  It might be interesting
to see how far they get with this work.

Aims: portable assembly language that can be targeted by multiple
languages/compilers.  Consists of the new C-- language, and a run-time
interface (RTI) provided by C-- implementations (expressed in C).  The RTI
provides support for "high-level runtime services": garbage collection,
exception handling, debugging, concurrency.

Only provides minimal support for general pre-emption of threads, IE
suspending a thread at arbitrary PC locations and inspecting its state.
There only real solution to this problem is a means to roll a thread
forward to its next "safe point" (ExecuteToNextSafePoint).

The interface to stack scanning (for garbage collection for example) is
sufficient, but not very efficient (which is to say it would be hard to
make it efficient).  The RTI provides a means for the compiler to
associate arbitrary with a PC and a key (EG descriptor blocks describing
the run-time type of variables) and an interface to retrieve the
associated blocks.  FindVar gets the value of a specified variable in
an activation record.  For a GC to scan the stack at least 2 function
calls per activation record and 1 function call per variable are
required.

Other readers may find the material on exceptions and debugging more
interesting.

Since <tony> mentioned it I'll point out that Chapter 7, "Discussion and
related work", doesn't mention ANDF.


Specific comments

4.3.3 para 4 (beginning "Make sure that")

There are issues with locks and deadlocks here.  ExecuteToNextSafePoint
mustn't claim any additional locks, so there must be a safe point before
every claim attempt.


ATTACHMENT
   "c--rtia4_ps.gz"

