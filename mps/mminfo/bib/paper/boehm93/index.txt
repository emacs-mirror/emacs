            SPACE EFFICIENT CONSERVATIVE GARBAGE COLLECTION
                             Hans-J. Boehm
                             ACM, 01/06/93
             Proceedings of the ACM SIGPLAN '91 Conference
           on Programming Language Design and Implementation,
                   SIGPLAN Notices 28, 6, pp 197-206
           ftp://parcftp.xerox.com/pub/gc/papers/pldi93.ps.Z

                             paper.boehm93
                                 draft
                             drj 1996-11-27


ABSTRACT:

We call a garbage collector conservative if it has only partial information 
about the location of pointers, and is thus forced to treat arbitrary bit 
patterns as though they might be pointers, in at least some cases.  We show 
that some very inexpensive, but previously unused techniques can have dramatic 
impact on the effectiveness of conservative garbage collectors in reclaiming 
memory.  Our most significant observation is that static data that appears to 
point to the heap should not result in misidentified reference to the heap.  
The garbage collector has enough information to allocate around such 
references.  We also observe that programming style has a significantly impact 
on the amount of spuriously retained storage, typically even if the collector 
is not terribly conservative.  Some fairly common C and C++ programming styles 
significantly decrease the effectiveness of any garbage collector.  These 
observations suffice to explain some of the different assessments of 
conservative collection that have appeared in the literature.

REVIEWS:

drj:

The paper is essentially a list of techniques for reducing the space
overheads incurred with a conservative garbage collector.  The garbage
collector (most) discussed is completely conservative; it scans the heap
conservatively, and assumes all static data in all libraries are roots.
Some of the techniques will not apply to a less conservative collector
(such as our DylanWorks collector).  The stack clearing technique may be
worth investigating when RISC platforms become important for us.


Blacklisting

The static data (roots) are scanned and any areas that appear to be
referenced are "blacklisted" and not used for subsequent allocation.
The technique aims to solve problems of excess retention caused by bogus
references from static data.  The amount of excess retention varied
considerably from operating system to operating system, but the
technique was universally efficacious.  This technique will be less
useful if one can avoid scanning static data (as we do by requiring
manual root registration).

Stack Clearing

Sparse stack layouts (eg. SPARC) can have locations that are rarely
written.  A consequence of this is that variables that were once dead
(ie above the stack pointer) can become alive again by subsequent pushes
(if they fit into the "holes" of a new stack frame).  Boehm claims this
is a "significant effect".  He goes on to note that a lot of the
variables that become alive again in the manner described are the
collector's variables (and has a hand wavy argument that claims the
clients stack frames will all be mostly regular and reuse the same
slots, whereas the infrequently executed collector is likely to use
different slots).  This is solved by writing extra code in the collector
to clean the stack as it returns.  An additional technique that can be
used is to note when the stack is exceptionally small (compared to the
largest encountered stack) and clear the area above the stack pointer
when this is so.  The problem will be much less on an architecture where
the stack frames are more dense, such as Intel.

Objects and the consequences of misidentification

There is some discussion of the benefits and drawbacks of different
shapes of object with regard to retention caused by accidental or bogus
references (eg., a bogus reference to a complete graph will retain the
whole graph; a bogus reference to a tree will retain an object whose
size is of the same order as the diameter of the tree).  In particular
he mentions the problem of using inline list cells to put an object on
more than one list; this greatly increases the connectivity of an
object (and is a "common C and C++ programming style").


ATTACHMENT
   "PLDI93.PS"

