                 BARRIER METHODS FOR GARBAGE COLLECTION
                             Benjamin Zorn
              University of Colorado at Boulder, 01/11/90
                     Technical Report CU-CS-494-90
    ftp://ftp.cs.colorado.edu/pub/techreports/zorn/CU-CS-494-90.ps.Z

                              paper.zorn90
                                 draft
                             dsm 1995-07-28


ABSTRACT:

Garbage collection algorithms have been enhanced in recent years with
two methods: generation-based collection and Baker incremental copying
collection.  Generation-based collection requires special actions
during certain store operations to implement the "write barrier."
Incremental collection requires special actions on certain load
operations to implement the "read barrier."  This paper evaluates the
performance of different implementations of the read and write
barriers and reaches several important conclusions.  First, the
inlining of barrier checks results in surprisingly low overheads, both
for the write barrier (2%-6%) and the read barrier (< 20%).  Contrary
to previous belief, these results suggest that a Baker-style read
barrier can be implemented efficiently without hardware support.
Second, the use of operating system traps to implement garbage
collection methods results in extremely high overheads because the
cost of trap handling is so high.  Since this large overhead is
completely unnecessary, operating system memory protection traps
should be reimplemented to be as fast as possible.  Finally, the
performance of these approaches on several machine architectures is
compared to show that the results are generally applicable.

REVIEWS:

SUMMARY

The overheads of write and read barrier methods were compared under
the execution of four programs in KCL using two different GC
algorithms.  One algorithm required a write barrier, the other a read
barrier.  The measurement was done using MARS (Memory Allocation and
Reference Simulator).

The write barrier was used to record intergenerational pointers in
a generational scheme.
The results for write barrier:
  hardware generation trap
    0.3% time overhead
  software semi-inlined test on every non-initialising pointer store
    2-6% time overhead
    20-30% code space overhead
  protection faults
    decreasing overhead with more memory allocated between collections
    worse than software if <2000k allocated between collections

The read barrier was used to implement "Baker-style" incremental
collection.  The test is simple, we only want to know if a loaded
pointer is in a given range.
The results for read barrier:
  hardware
    negligible time overhead
  software inlined test
    10-20% time overhead
    100% code space overhead
  protection faults
    fromspace objects copied when referenced
    EQ operation modified and more expensive
    ~100% time overhead

Zorn comments that protection fault handling is not implemented with a
view to speed in many operating systems.  Operating systems take on the
order of 10,000 cycles to handle a protection fault.  This makes using
fault handling much worse than using a software barrier.


COMMENTS

The results suggest that the cost of using protection faults to handle
write barriers is alarmingly high.  The modifications made to the
incremental algorithm to make it work using fault handling break the
invariant that the program cannot see unfixed pointers.  This causes
the EQ operation to be more expensive, because the program can copy a
pointer before it is fixed.

However it is possible to use fault handling without breaking the
invariant.  To maintain the invariant a page must be scanned before it
is unprotected, otherwise the program can access fixed but unscanned
objects which may contain unfixed pointers.


ATTACHMENTS
   "Zorn90.ps"
   "Zorn90.pdf"

