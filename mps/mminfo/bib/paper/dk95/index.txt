DEBUGGING STORAGE MANAGEMENT PROBLEMS IN GARBAGE COLLECTED ENVIRONMENTS
                      David L. Detlefs;Bill Kalsow
 First USENIX Conference on Object-Oriented Technoloy (COOTS), 01/06/95
  http://www.research.digital.com/SRC/modula-3/papers/debugging-GC.ps

                               paper.dk95
                                 draft
                             drj 1997-02-11


ABSTRACT:

Garbage collection does not solve all storage management problems; programs 
allocate too much garbage, requiring excess collection, and may retain too much 
storage, causing heaps to grow too large. This paper discusses these problems, 
and presents tools implemented in the SRC Modula-3 system that help solve them. 

REVIEWS:

drj: The paper present four simple tools:

  A allocation profiler that simply displays all objects allocated by type 
(either in bytes or objects, and either since the dawn of time or a rate).

  A heap profiler that displays object or byte counts of objects of each type 
present in the heap.

  A root weighting tool that reports how much heap is reachable from each root, 
and from certain collections of roots (eg, all the globabl variable of a single 
module).

  A mechanism for asserting that an object is unreachable (and if it isn't, 
printing out a path to the object).

Only the first tool is graphical (it displays a dynamically updated bar chart 
in a window).  Only the first tool is live.  The other tools produce text 
reports, typically when a certain runtime function is called.

The root weighting tool works by performing a full GC essentially.  Also, I'm 
not sure that what is measures is useful.  It would perhaps be more useful to 
work out by how much the heap would shrink if a particul root or set of roots 
were NILed out.

The tools they present are very crude, but are clearly useful to the community 
using them (the root reporting mechanism is particularly low-level for 
example).  They were able to debug a couple of problems using the tools.  The 
first was an excessive allocation problem because they were using a hash-table 
to implement a referentially transparent set.  The second was a storage leak 
involving a stack ADT that didn't NIL out unused portions of the stack.  A 
third was a hash-consing type thing, where they discovered that the hash-table 
used to do the hash-consing was hanging on to all the objects; bizarrely, they 
didn't solve the problem by using weak-tables, even though Modula-3 appears to 
have weak-references.

ATTACHMENT
   "DEBUGG~1.PS"

