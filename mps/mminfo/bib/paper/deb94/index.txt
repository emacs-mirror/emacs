             DON'T STOP THE BIBOP: FLEXIBLE, AND EFFICIENT
           STORAGE MANAGEMENT FOR DYNAMICALLY-TYPED LANGUAGES
                R. Kent Dybvig;David Eby;Carl Bruggeman
       Indiana University, Computer Science Department, 01/03/94
                                 TR 400
          ftp://ftp.cs.indiana.edu/pub/techreports/TR400.ps.Z

                              paper.deb94
                                 draft
                             drj 1996-09-27


ABSTRACT:

This paper describes a storage management system that is flexible and 
efficient.  The representation of run-time tags yields fast allocation, type 
testing, and field extraction, and the memory model reduces virtual memory 
paging during garbage collection.  The storage management system coexists 
gracefully with other languages' run-time systems, facilitating the use of 
multiple languages within a single program.  No special support from the 
operating system or virtual memory manager is required beyond the ability to 
obtain additional memory on demand.  The
system incorporates a generational garbage collector with a tunable number of 
dynamically-resizable generations.  The collector handles large objects 
efficiently, supports collection of incrementally-compiled code, supports weak 
pairs, and allows stacks to contain nonpointer data.  The system's hybrid type 
representation employs typed pointers and typed objects for tagging individual 
objects, and BIBOP typing for classifying objects according to coarser-grained 
type characteristics mostly of concern only to the collector.  A segmented 
memory model is used, but segmentation is handled transparently outside of the 
collector so that nearly all types of objects are allocated inline from a 
single linear allocation area using a single allocation pointer.  The storage 
management system has been implemented and is in use as part of a 
high-performance production implementation of Scheme.

REVIEWS:

Describes the MM for Chez Scheme: a system quite similar to Dylan (MPS), or LW: 
a generational GC with multiple adjustable generations, allocation buffers, and 
type tags in pointers and objects.  Language-level type information is not 
stored BIBOP-fashion, so all they mean by that is they store some MM 
information for each equally-sized segment.  They call this "metatype" info, 
but that's overstretching the meaning.

Allocating different types in the same buffer and separating them at first 
promote is good idea for getting by with a single buffer.

They also propose a guard page at the end of the buffer.  The MLWorks 
experience shows that this can be competitive, if the ratio of object size to 
buffer size is large enough.

Code objects work the same way as in LWW.

ATTACHMENT
   "TR400.PS"

