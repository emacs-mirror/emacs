                      THE GC INTERFACE IN THE EVM
                      Derek White;Alex Garthwaite
                Sun Microsystems Laboratories, 01/12/98
                              SML TR-98-67
  http://www.sunlabs.com/research/java-topics/pubs/98-gc-interface.ps
  http://www.sunlabs.com/research/java-topics/pubs/98-gc-interface.pdf
         http://www.sunlabs.com/techrep/1998/smli_tr-98-67.pdf

                              paper.wg1998
                               incomplete
                             drj 1999-03-25


ABSTRACT:

This document describes how to write a garbage collector (GC) for the ExactVM.  
It assumes that the reader has a good understanding of garbage collection 
issues and some familiarity with the Java™ language.

The ExactVM is part of a research project at Sun Labs.  The interfaces 
described in this document are under development and are guaranteed to change.  
In fact, the purpose of this document is to solicit feedback to improve the 
interfaces described herein.  As a result, specific product plans should not be 
based on this document; everything is expected to change.

EVM, the Java virtual machine known previously as ExactVM, is embedded in Sun’s 
Java 2 SDK Production Release for Solaris™, available at 
http://www.sun.com/solaris/java/.

REVIEWS:

This is really just an internal document dressed up with a little explanation.  
It describes the interface between the GC and "the memory system" that stands 
between the GC and the rest of the EVM.  It looks like they have split the old 
JVM memory management code (gc.c) so that the GC part would contain only the 
collection strategy and its implementation.  This leaves major MM features like 
weakness, initial placement, and caching outside GC (and sometimes spread all 
over the EVM, no doubt).  There's been very little attempt to generalize any of 
the new interfaces.

Even heap expansion is requested by the memory system, but a GC implementation 
could ignore the requests and implement its own policy.

Synchronization must use safe points and locks.  This makes it impossible to 
use page protection for barriers.  It's hard to reuse the locking code for an 
incremental GC.

Some parts of the class structures (e.g., NearClass) are manually managed, with 
class marking done by the memory system.  The paper says class unloading can 
only happen during full GC, but there doesn't seem to be any overriding reason 
for this, since the GC could track pointers to classes from each generation 
(they never change, so no write-barrier is required).

The paper specifies that JVM weak roots are weaker than phantom.  I suppose 
that includes JNI weak roots.

pekka 1999-08-18

ATTACHMENTS
   "98-gc-in.pdf"
   "98-gc-in.ps"

