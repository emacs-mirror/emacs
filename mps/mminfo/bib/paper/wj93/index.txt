                REAL-TIME NON-COPYING GARBAGE COLLECTION
                    Paul R. Wilson;Mark S. Johnstone
                             ACM, 01/01/93
  1993 ACM OOPSLA Workshop on Memory Management and Garbage Collection
              ftp://ftp.cs.utexas.edu/pub/garbage/cache.ps

                               paper.wj93
                                 draft
                             drj 1997-03-06


ABSTRACT:

[This is the Overview, not the Abstract]

Real-time garbage collection is not popular, despite its obvious attractiveness 
for many applications.  This is largely due to the perceived cost and 
disruptiveness of garbage collection in general and incremental garbage 
collection in particular.  Most existing "real-time" garbage collectors are not 
in fact usefully real-time, largely due to the use of a read barrier to trigger 
incremental copying of data structures being traversed by the running 
application.  (The read barrier consists of extra instructions accompanying 
each pointer use, which ensure that the running program will never see 
inconsistencies due to encountering partially-copied data structures.)  This 
may slow down running applications unpredictably, even though individual 
increments of garbage collection work are small and bounded.

We have developed a hard real-time garbage collector for C++ which uses a write 
barrier, only coordinating collection work with modifications of pointers in 
data structures, making coordination costs cheaper and more predictable.  We 
combine this write barrier approach with implicit noncopying reclamation, which 
has most of the advantages of copying collection (notably the avoidance of the 
sweep phase required by mark-sweep collectors, and the touching of garbage 
objects when reclaiming their space).

Because a non-copying collector cannot compact live data, fragmentation is a 
potential problem in our system.  We believe that the problem is not as severe 
as it appears at first glance, however, and that for most programs, usable 
worst-case space bounds can be ensured.  For other programs, it may also be 
feasible to rely on an occasional compacting collection with some degradation 
of real-time guarantees.

This implementation strategy is well suited to stock hardware and operating 
systems.  Because the write barrier records the same information as the write 
barrier for a generational scheme, our collector can easily be made 
generational to provide excellent average-case efficiency while preserving hard 
real-time response.  We also believe that our collector is easier to 
parallelize than copying collectors.

REVIEWS:

This is a Baker treadmill with a write-barrier (a smart-pointer implementation 
of analysis.async-gc.barrier.steele or .dijkstra, they don't say which) and 
segregated allocation.  Sounds quite promising.  There's a good analysis of 
barrier techniques in section 3.  They say (section 7) they are going to extend 
it into a "heirarchical" collector, "with fast small-scale collections nested 
within slow large-scale collections"!
        -- pekka 1998-05-14

ATTACHMENT
   "WILSON~1.PS"

