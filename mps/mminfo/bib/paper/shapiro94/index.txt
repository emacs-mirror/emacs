                  LARCHANT-RDOSS: A DISTRIBUTED SHARED
              PERSISTENT MEMORY AND ITS GARBAGE COLLECTOR
                      Marc Shapiro;Paulo Ferreira
                      INRIA Rocquencourt, 01/11/94
INRIA Rapport de Recherche no. 2399; Cornell Computer Science TR94-1466
http://cs-tr.cs.cornell.edu/Dienst/Repository/2.0/Body/ncstrl.cornell%2fTR94-1466/postscript
[http://cs-tr.cs.cornell.edu/Server/TR/CORNELLCS:TR94-1466/Body?format=postscript]

                            paper.shapiro94
                                 draft
                             drj 1995-08-23


ABSTRACT:

Larchant-RDOSS is a distributed shared memory that persists on reliable
storage across process lifetimes. Memory management is automatic:
including consistent caching of data and of locks, collecting objects
unreachable from the persistent root, writing reachable objects to
disk, and reducing store fragmentation. Memory management is based on a
novel garbage collection algorithm, that approximates a global trace by
a series of local traces, with no induced I/O or locking traffic, and
no synchronization between the collector and the application processes.
This results in a simple programming model, and expected minimal added
application latency. The algorithm is designed for the most unfavorable
environment (uncontrolled programming language, reference by pointers,
distributed system, non-coherent shared memory) and should work well
also in more favorable settings.

REVIEWS:

This is clear and well presented; a broad overview from the general 
architecture to details of graph tracing is given.  Clients communicate with 
the persistent store via special API calls (in particular, one to bind a 
pointer, and another to commit changes).  Objects in the store are cached 
locally at a site.  The garbage collector communicates solely with the local 
caches, uses optimistic locking, and traces a subset of the graph only.  A 
cluster is the unit of collection and holds some objects, an in-pointer set, 
and a set of out pointers.  Any changes that a gc makes are communicated to the 
rest of the store at the end of the cycle.  A simple investigation of the race 
conditions is given.

I think this has some good ideas for how to solve this sort of problem.  Not 
immediately applicable to our work.

ATTACHMENT
   "SHAPIR~1.PS"

