                ON ADDING GARBAGE COLLECTION AND RUNTIME
   TYPES TO A STRONGLY-TYPED, STATICALLY-CHECKED, CONCURRENT LANGUAGE
                              Paul Rovner
                      Xerox Corporation, 01/07/85
                                CSL-84-7
                     mailto:Library.Parc@xerox.com

                             paper.rovner85
                                 draft
                             drj 1996-10-29


ABSTRACT:

Enough is known now about garbage collection, runtime types, strong-typing, 
static-checking and concurrency that it is possible to explore what happens 
when they are combined in a real programming system.
Storage Management is one of a few central issues through which one can get a 
good view of the design of an entire system.  Tensions between ease of 
integration and the need for protection; between generality, simplicity, 
flexibility, extensibility and efficiency are all manifest when assumptions and 
attitudes about managing store are studied.  And deep understanding follows 
best from the analysis of systems that people use to get real work done.
This paper is not for those who seek arguments pro or con about the need for 
these feature in programming systems; such issues are for other papers.  This 
one assumes these feature to be good and describes how they combine and 
interact in Cedar, a programming language and environment designed to help 
programmers build moderate-sized experimental systems for moderate numbers of 
people to test and use.

REVIEWS:

drj:

This paper is about the changes required in the runtime system to change
a Mesa based system into a Cedar based one (Cedar is a more dynamic
variant of Mesa which is itself an "industrial strength Pascal").

The "collector" is a reference counting scheme with no counting
performed for references on the activation stacks.  The reclamation
step in the reference counter runs asynchronously.  Infrequently,
manually run, mark-and-sweep GC for reclaiming cycles.

Perhaps the most important point of the paper is the conclusion that
"Time spent by programmers to solve storage management related problems
has decreased from an estimated 40% in Mesa to an estimated 5% in
Cedar" (section 7.2).  Unfortunately, there is no further reference or study 
cited.


Comparisons and Contrasts

They note the need to synchronize between mutator initializations of
freshly allocated objects and the tracer.  They solve this by tagging
(with a header word) all allocations and filling allocated memory with
0's (similar to paper.ael88).  This further strengthens my belief that
2-phase allocation is a valuable secret.

Allocation uses a small array of free lists of common sizes (to cope
with most common allocations), a general allocator for medium sizes
(which they note is not really very good), and a special large-object
allocator.

Critical allocation and reclamation (GC) operations are microcoded
(it all runs on Dorado workstations) with slower out-of-line cases (and
have microcoded trapping lock operations).

They use conservative necessary tests.  There are two tests used, both
relating to stack scanning (each test uses a different form).
The first is detecting references on the stack.  Each word on the stack
is looked up in an "allocated pages" bitmap and anything that points to
an allocated page is hashed into a "Found On Stack" table.  The hash and
the subsequent use of it relates to the other use of a conservative
necessary test.  The hashing scheme is closed, but the a table entry
stores the bitwise OR of all addresses hashing to the same value.
During reclaim a list of objects reputedly with zero reference counts
is processed.  The address of each object is looked up in the Found On
Stack table, and the hashed value found there is compared to the
address of the object using a bitwise AND (subset) test.  The object is
not reclaimed if it may be referenced from the stack.

The system has finalization.  Each type for which finalization is
required has an associated queue.  When an object is fount to be
suitable for finalization it is added to the queue; if the queue is
full, then the object is left (and the collector will attempt to add it
on the next cycle).





