           VMALLOC: A GENERAL AND EFFICIENT MEMORY ALLOCATOR
                                Phong Vo
              AT&T Bell Laboratories (now AT&T Research), 

                               paper.vo96
                                 draft
                             drj 1996-04-11


ABSTRACT:

On C/Unix systems, the malloc interface is standard for dynamic memory 
allocation.  Despite its popularity, malloc's shortcomings frequently cause 
programmers to code around it.  The new library Vmalloc generalizes malloc to 
give programmers more control over memory allocation. Vmalloc introduces the 
idea of organizing memory into separate regions, each with a discipline to get 
raw memory and a method to manage allocation.  Applications can write their own 
disciplines to manipulate arbitrary type of memory or just to better organize 
memory in a region by creating new regions out of its memory.  The provided set 
of allocation methods include general purpose allocations, fast special cases 
and aids for memory debugging or profiling.  A compatible malloc interface 
enables current applications to select allocation methods using environment 
variables so they can tune for performance or perform other tasks such as 
profiling memory usage, generating traces of allocation calls or debugging 
memory errors.  A performance study comparing Vmalloc and currently popular 
malloc implementations shows that Vmalloc is competitive to the best of these 
allocators.  Applications can gain further performance improvement by using the 
right mixture of regions with different Vmalloc methods.

REVIEWS:

drj:

Summary

Vo has developed a reasonably efficient framework for selecting and
implementing different malloc/free style policies with a good
(late-binding) interface.  No attempt is made to address wider issues.

Detail

My overall impression of the paper is that it's another "look my malloc
is better than yours".  The programs studied are typical C programs (ie
small and short-lived in my opinion).  He makes an effort to compare
against a gc (the Boehm--Weiser collector), but misses the point of gc
and abuses it (by not using gc in one case and putting all blocks on a
doubly linked list in another).  His measurement strategy essentially
forced him to abuse the gc in this way (see below).

Vo uses a framework of "regions", "disciplines", and "methods".  A
region is a parameter to various mm operations.  A region has
associated with it a discipline (which specifies how raw memory should
be obtained), and a method (which specifies the policy for managing the
memory in the region).

There's a loose correspondence between Vo's discipline and MM's
arena (but note that disciplines are selectable on a per-region basis),
and also between Vo's methods and MM's poolclasses.

The framework makes it easy to write malloc / free style policies, and
to some extent will allow the exploitation of (for example) shared or
compressed memory.  It makes no effort to address any other memory
management issues (such as persistant store or GC).

Vo's measurement strategy is to generate allocate/free traces from the
programs and then run these through a simulator.  He claims that using
direct program execution makes time measurements tricky due to other
work done.  I claim that you can't measure the locality effects of the
policies and you can't copmare against gc unless you use direct program
execution.

Random interesting things:

Has a "last" policy which ignores all frees except a free of the last
block allocated and allocates linearly through memory (which does well
for some applications).

Can watch for a particular block being allocated (useful for corrupted
blocks / double frees).

Debugging is selected at application start-up; no relinking makes it
extremely quick and easy to use.



ATTACHMENT
   "VMALLOC.PS"

