        REAL-TIME CONCURRENT COLLECTION ON STOCK MULTIPROCESSORS
                   Andrew Appel;John R. Ellis;Kai Li
                                01/07/88
        ACM PLDI 88, SIGPLAN Notices 23, 7 (July 88), pp. 11-20
                 [Where did you get this from Richard?]

                              paper.ael88
                                 draft
                             dsm 1995-08-25


ABSTRACT:

We've designed and implemented a copying garbage-collection algorithm that is 
efficient, real-time, concurrent, runs on commercial uniprocessors and 
shared-memory multiprocessors, and requires no change to compilers.  The 
algorithm uses standard virtual-memory hardware to detect references to "from 
space" objects and to synchronize the collector and mutator threads.  We've 
implemented and measured a prototype running on SRC's 5-processor Firefly.  It 
will be straightforward to merge our techniques with generational collection.  
An incremental, non-concurrent version could be implemented easily on many 
versions of Unix.

REVIEWS:

dsm: I believe the algorithm used in this paper describes how we intend to 
implement incremental scanning.  I quote Wilson below who describes the 
algorithm well.

Extract from paper.wil88 (section 3.4.4):

Appel, Ellis and Li's concurrent incremental collector [ael88] uses virtual 
memory primitives to implement a pagewise black-only read barrier.  Rather than 
detecting the first reference to any grey object (in tospace), entire pages of 
unscanned data in tospace are access-protected, so that the virtual memory 
system will implicitly perform read barrier checks as part of the normal 
functioning of the virtual memory hardware.  When the mutator accesses a 
protected page, a special trap handler immediately scans the whole page, fixing 
up all the pointers (i.e., blackening all of the objects in the page); 
referents in fromspace are relocated to tospace (i.e. greyed) and 
access-protected.  This avoids the need for continual software checks to 
implement the read barrier, and in the usual case is more efficient.  (If the 
operating system's trap handling is slow, however, it may not be worth it.)  
Despite reliance on operating system support, this technique is relatively 
portable because most modern operating systems provide the neccessary support.

Unfortunately this scheme fails to provide meaningful real-time guarantees in 
the general case [wm89,ns90, wj93].  (It does support concurrent collection, 
however, and can greatly reduce the cost of the read barrier.)  In the worst 
case, each pointer traversal may cause the scanning of a page of tospace until 
the whole garbage collection is complete.*

* [footnote] Johnson has improved on this scheme by incorporating lazier 
copying of objects to tospace [joh92]; this is essentially an application of 
Nilsen's lazy copying technique [nil88] to the Appel-Ellis-Li collector.  This 
decreases the maximum latency, but in the (very unlikely) worst case a page may 
still be scanned at each pointer traversal until a whole garbage collection has 
been done 'the hard way'.


dsm: I have not seen this paper or Johnson's, but I imagine that we could 
reduce worst case pause times, by noticing that we are in a bad case, and 
switching off forwarding for some pages.  Touched pages would still need to be 
scanned, but this could limit the work to fixing pointers to already forwarded 
objects, at the expense of not reclaiming any more memory on this collection.

In order to do the scanning efficiently and in parallel with the mutator, they 
modified the kernel allowing scanning of a page protected from the mutator.  We 
are unlikely to be able to do this and will have to instead suspend all threads 
while this scanning take place.

Locks were used to protect allocation pointers.  They use a two-stage 
allocation to avoid lock contention;  allocating chunks using the locks, and 
then allocating objects without a lock from the per thread chunk.  Our buffer 
idea is similar (idea.buffers), but guarantees that objects are well formed 
before scanning.  I guess that they avoid this problem because they start with 
zero filled memory and the mutator guarantees the mutations performed to create 
an object keep it well formed in the scanners eyes.  We could offer this 
facility (of non-failing Commit) in return for such a guarantee.  Thinking 
about this we could guarantee Commit by ambiguously scanning half allocated 
buffers.



ATTACHMENT
   "rtcgc.ps"

