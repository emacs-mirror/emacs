      C9X DRAFT: "WORKING DRAFT, 1997-11-21, WG14/N794 J11/97-158"
                                  ISO
                             ISO, 21/11/97
                          WG14/N794 J11/97-158
           http://www.dkuug.dk/JTC1/SC22/open/n2620/n2620.ps
           http://www.dkuug.dk/JTC1/SC22/open/n2620/n2620.pdf
           http://www.dkuug.dk/JTC1/SC22/open/n2620/n2620.txt
                                    

                             paper.iso1997
                               incomplete
                             drj 1998-04-24


ABSTRACT:

(Cover sheet to be provided by ISO Secretariat.)

This International Standard specifies the form and establishes the 
interpretation of programs expressed in the programming language C. Its purpose 
is to promote portability, reliability, maintainability, and efficient 
execution of C language programs on a variety of computing systems.

Clauses are included that detail the C language itself and the contents of the 
C language execution library. Annexes summarize aspects of both of them, and 
enumerate factors that influence the portability of C programs.

Although this International Standard is intended to guide knowledgeable C 
language programmers as well as implementors of C language translation systems, 
the document itself is not designed to serve as a tutorial.

REVIEWS:

This is a DRAFT, SUBJECT TO CHANGE.

.drj:

Review of the C9X Working Draft, 1997-11-21, WG14/N794 J11/97-158.
Clauses 1-6.


Clauses 1-6 cover definitions, evnironments, limits, and the language.
Clause 7 covers the library.  I haven't bothered looking at clause 7 yet.

I say clause a lot when I mean sub-clause.  Watch me care.

This review mostly concentrates on the differences between the existing
C standard, and the Working Draft.


Relating to the language C:


Types

New integer type long long (clause 6.1.2.5 para 3) and friends,
guaranteed to be 64-bits wide (clause 5.2.4.2.1).  long long integer
constants (clause 6.1.3.2).

New complex number type (clause 6.1.2.5 para 10).

Implementation defined extended integer types (clause 6.1.2.5 para 3).

New concept of "real types" (union of integer and real floating types)
(clause 6.1.2.5 para 19)

New concept of "type-domain" (a partition of the arithmetic types)
(clause 6.1.2.5 para 21)

bool types (through a header file) (apparently, I haven't checked).  

more integer type reflection (through a header file) (apparently, I
haven't checked).

Single element array at end of structure hack sanctioned and cleaned up
slightly (clause 6.5.2.1 para 15).

New concept of "effective type", which is a bit like defining an
object's type by how it is used at runtime (a malloc hack?) (clause 6.3
para 6).

Variable size array types (see array declarators below).

New concept of a "variably modified" type (clause 6.5.5 para 3).

There is some mess with objects of variably modified type and control
flow (clause 6.1.2.4): switch (clause 6.6.4.2) and goto (clause
6.6.6.1).


Arithmetic

Some ways of performing arithmetic using &, [], and * are now
sanctioned (clause 6.3.3.2 para 3).  In particular &a[b] is defined to
be a+b (subject to constraints).

a/b for integers defined to truncate the fractional part (aka round
towards zero) (clause 6.3.5 para 6).  Hence a%b shares sign with a (a
disaster IMO).

Wording for pointer arithmetic is changed, but confusingly so.  I'm not
sure that any new semantics are admitted.  (clause 6.3.6 para 8).

New concept of floating point expressions being "contracted" that is,
evaluated to a greater precision than that implied by the abstract
machine (e.g. using internal 80-bit floating point registers for
temporaries may result in greater precision on float operations)
(clause 6.3 para 8).  There is a facility for turning this off (a great
relief to fortran programmers no doubt).

IEC 559 is blessed (NaNs inifinities, etc, clause 5.2.4.2.2 para 3) and
is normative (clause 2).


Misc

Unicode (ISO 10646 is normative) (clause 5.2.1 paras 4 and 5 describes a way to
specify universal characters) acceptable in identifers (clause 6.1.2),
character constants (clause 6.1.3.4), and string literals (clause
6.1.4).

Larger minimum limits throughout (clause 5.2.4.1 and friends).
Including dropping 6 character monocase external linkage restriction.

(A clarification that) UCHAR_MAX+1 is defined to be equal to 2 raised
to the power CHAR_BIT (clause 5.2.4.2.1).

New line-comment syntax a la C++ / BCPL: "//" introduces a comment
until the end of the line (clause 6.1.9).

New keywords: complex imaginary inline restrict (clause 6.1.1).
Complex and imaginary only reserved when certain header files are
included (yugh!).

New qualifier "restrict" (clause 6.1.2.5 para 25) (clause 6.5.3) ("formal
definition in": clause 6.5.3.1).  Loosely restrict asserts that this
pointer is unique in referencing the objects that it does.

New __func__ identifier (clause 6.1.2.7) which is a constant string
declaration containing the name of the function.  Semantics defined by
clause 6.3.1.1.

New clause on representations, makes explicit the "all objects are a
bag of bytes" model (clause 6.1.2.8 ff).  As part of this clarifies
padding (clause 6.1.2.8.1 para 4) and introduces a notion of invalid
representations for objects of a certain type, called "trap
representations" (clause 6.2.8.1 para 3).  This is an excellent change
and greatly clarifies the underlying model for C.

Hexadecimal floating constants (!) (clause 6.1.3.1) (using P for
expressing binary exponent part).

New operators: <: :> %: %:%: (clause 6.1.5), these are "alternative
spellings" for [ ] { } # ## respectively (for silly european languages
I presume) (clause 6.1.5).

New concept of "integer conversion rank" presumably to clarify the
explanation of integer conversion and to accommodate extended integer
type (clause 6.2.1.1).  Broadly ranks define an ordering on the integer
types.

Integer conversion ranks are used to define the semantics of the "usual
arithmetic conversions" (clause 6.2.1.7) which are now a bit saner to
understand.

Pointer conversion semantics are slightly stronger particularly wrt to
converting back and forth between types (clause 6.2.2.3).

void * and char * defined to be compatible across function calls even
for K&R type function declarations (clause 6.3.2.2 para 5).

Signed/unsigned defined to be compatible across function calls even for
K&R type function declations (clause 6.3.2.2 para 5).  These make
explicit what was implicit in a footnote in C89.

New postfix operators (clause 6.3.2) for creating compound literals
(clause 6.3.2.5) which specify literal structures and arrays.  Only
compound literals outside function bodies need be constant.

Integers cast to pointer types are now acceptable as address constants
(clause 6.4 para 9).


Declarations

Final comma permitted in enumeration specifiers (e.g enum foobar {foo,
bar,};) (clause 6.5.2.2), and in initializer lists (clause 6.5.8).

Declarations are now permitted to be interleaved with statements in a
block (clause 6.6.2).

An incomplete enum type declaration (ie "enum thing" on its own with no
list) is now only legal after a complete declaration (irrelevant since
you shouldn't be using enum types) (clause 6.5.2.3 para 2).

Incomplete struct, union, and enum type declarations made when a
previous declaration of the same tag is visible declare the same type
and not a new incomplete type (clause 6.5.2.3 para 8).  Puts the mind
of those of us that worried that a later incomplete declaration of a
structure declared a new (incompatible) type at rest.

New function specifier inline (clause 6.5.4).  This asserts various
features of a function being declared and defined that make it amenable
for inlining.

Array declarators can now have non-constant integers specifying the
size, and also * (clause 6.5.5.2).  * is only legal in declarations
with function prototype scope (I think) (clause 6.5.5.2 para 3).
Array declarators with non-constant sizes declare variable length array
types.

Makes explicit that storage class specifiers for parameters are ignored
unless declaration is for a function definition (clause 6.5.5.3 para
9) (which as far as I could see was always implicit through a "type
compatibility" calculus hack).

New concept of (and syntax for) designated initializers (clause 6.5.8),
to designate initialization of specific array elements or
structure/union members.  Cool.

Declaration permitted in initialization part of for statement (clause
6.6.5).  Yay!

Declaration specifiers part of function declaration must be specified
(clause 6.7.1).  In other words, you can't leave off the "int" if a
function returns int.  Similarly in K&R style declaration lists in
function definitions, all identifers must be declared, implicit
declaration to int is not allowed (clause 6.7.1 para 6).


Macrology

Macros can have variable number of arguments, specified with ... in the
obvious way (clause 6.8).  Macro varargs are expanded using __VA_ARGS__
in the macro replacement list (clause 6.8.3 para 5).

New concept of "placemarker token" to cope with token pasting (using
##) macros that expand to nothing.

Some of the #pragma is reserved for Standard C.  #pragma STDC blah has
defined effects for some values of blah (clause 6.8.6).  And the
#pragma STDC name space is reserved (clause 6.9.5).

New conditionally defined macros (for feature spotting).  The copy of
draft appears to be corrupt here (clause 6.8.8).  __STDC_IEC_559__ and
__STDC_IEC_559_COMPLEX__.

New _Pragma unary operator (clause 6.8.9) so that macros can expand
into pragma directives.  How pragmatic.


Meta factoids relating to the standard itself:

Clause 3.17 defines "recommended practice" (though there is only one
instance of this in clauses 1 - 6).

universal-characters in identifiers appear to have semantics restricted
by an Annex (clause 6.1.2 para 2), but Annexes are not normative (as
specified in the introduction) (is this a bug in the standard? how can
the behaviour be defined by reference to a non-normative document?).

Paragraphs within clauses are numbered (or is this a feature of the
draft alone?).


ATTACHMENT
   "n2620.pdf"

