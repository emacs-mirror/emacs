              LECTURE NOTES ON THE STATUS OF IEEE STANDARD
                754 FOR BINARY FLOATING-POINT ARITHMETIC
                             Prof. W. Kahan
       University of California Berkeley CA 94720-1776, 17/08/95
      http://http.cs.berkeley.edu/~wkahan/ieee754status/ieee754.ps

                             paper.kahan95
                                 draft
                           richard 1995-08-24


ABSTRACT:

Twenty years ago anarchy threatened floating-point arithmetic. Over a dozen 
commercially significant arithmetics boasted diverse wordsizes, precisions, 
rounding procedures and over/underflow behaviors, and more were in the works. 
“Portable” software intended to reconcile that numerical diversity had become 
unbearably costly to develop.

Ten years ago, when IEEE 754 became official, major microprocessor 
manufacturers had already adopted it despite the challenge it posed to 
implementors. With unprecedented altruism, hardware designers rose to its 
challenge in the belief that they would ease and encourage a vast burgeoning of 
numerical software. They did succeed to a considerable extent. Anyway, rounding 
anomalies that preoccupied all of us in the 1970s afflict only CRAYs now.

Now atrophy threatens features of IEEE 754 caught in a vicious circle: Those 
features lack support in programming languages and compilers, so those features 
are mishandled and/or practically unusable, so those features are little known 
and less in demand, and so those features lack support in programming languages 
and compilers.

To help break that circle, those features are discussed in these notes...

REVIEWS:

Date: Wed, 23 Aug 95 15:12:49 BST
From: Dave Berry <daveb>
Subject: Summary of Kahan's paper on IEEE
To: mlworkers
Cc: hackers


        Notes on Kahan's lecture notes (work in progress) on IEEE 754.

        (http://http.cs.berkeley.edu/~wkahan/ieee754status/ieee754.ps)
                        (abel.cam:~daveb/ieee754.ps)


32-bit floats are required.  64-bit floats are ubiquitous.  (p.2)

The PowerPC chip uses a "Fused" multiply-accumulate operation.  This can
be used in a non-conformant manner.  E.g. if compilers use this operation
to implement (a*b = c*d) in two instructions instead of three, it may 
produce the wrong result due to rounding errors.  Kahan suggests the
use of redundant parentheses to control when this instruction may be used,
and/or a compiler directive to say whether a Fused MAC is permitted/banned/
required.  (p.5)

Kahan suggests that an environment log the source code lines where exceptions
are raised (presumably using the handlers for the exceptions).  This tells
users where the exception happens, and keeping to a maximum of one log entry
per source line avoids huge log files. (p.6)

Microsoft's C and C++ compilers mis-use the sticky bit, preventing programs
from checking whether exceptions occurred. (p.7)

NaN's prevent certain optimisations (e.g. x = x may return false).  Pages 8 & 9
discuss various optimisations and exceptional cases.

Some machines violate IEEE 754 by flushing underflow to zero.  Kahan mentions
DEC Alphas as a particular example.  It's not clear what to do here; perhaps
the environment should provide a machine-specific way of controlling behaviour
when necessary.

Kahan says that it should be possible to set rounding mode dynamically.
(I would like to know why this is important).  The DEC Alpha violates
this requirement.  Kahan's notes aren't totally clear here.

Kahan suggests that languages should provide the following exception
handlers:
        PAUSE, ABORT, PRE_EMPT, DEFAULT, SUBST, EXP_COUNT, ABSENT
and the following exceptions:
        INEXACT, UNDERFLOW, DIVIDE_BY_ZERO, OVERFLOW, INTEGER, INVALID
with the following sub-cases for INVALID:
        ZERO_DIV_ZERO, INF_DIV_INF, INF_SUB_INF, ZERO_MUL_INF,
        FUNC_DOMAIN, SIGNALLING_NAN (and NIL_POINTER, RANGE_ERROR).
Kahan uses 5 character identifiers in an attempt to make the names independent
of the language.  This seems silly to me, so I've used longer identifiers.
These exception handlers have supposedly been sufficient for virtually all
applications.  (PRE_EMPT is language-specific, and we could ignore it in
SML.  ABSENT indicates that the host machine doesn't support the particular
exception; we could use an option type instead.)

Kahan also suggests the following mode types:
        RoundDirection = ToNEAR | ToZERO | ToPOS | ToNEG
        RoundPrecision = ToSINGLE | ToDOUBLE | ToEXTENDED

C. Farnum's 1988 paper discusses how to handle mixed precision arithmetic,
and might be worth looking at.

---

X-Sender: ptw@mailhost.harlequin.com
Mime-Version: 1.0
X-Header-Sticker: Honk if you love GC's
Date: Wed, 23 Aug 1995 16:40:38 -0400
To: Dave Berry <daveb>
From: ptw (P. Tucker Withington)
Subject: Re: Summary of Kahan's paper on IEEE
Cc: mlworkers, hackers

   From: Dave Berry
   Date: 8/23/95 10:12 AM

   Kahan says that it should be possible to set rounding mode dynamically.
   (I would like to know why this is important).  The DEC Alpha violates
   this requirement.  Kahan's notes aren't totally clear here.

So the same code can be used with different modes rather than replicating
the code?  Consider a library shared by programs operating in different
modes.

Actually, I don't think the Alpha does violate this principle.  The Alpha
has variants on all FP instructions to support either static or dynamic
rounding.  It is up to the compiler writer to emit the correct
instructions.  The only "bug" in the architecture from my viewpoint is that
you cannot support both simultaneously easily, because the instructions are
not orthogonal (the dynamic mode instruction is also the
round-to-plus-infinity static mode instruction, by using the default
setting).  The work-around is to play with signs and use
round-to-minus-infinity, if you want static mode code that will not be
subverted by changing the mode bits in the FPU.


ATTACHMENTS
   "ieee754.ps"
   "ieee754.pdf"

