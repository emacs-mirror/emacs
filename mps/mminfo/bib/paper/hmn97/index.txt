       THE MEASURED COST OF COPYING GARBAGE COLLECTION MECHANISMS
          Michael W. Hicks;Jonathan T. Moore;Scott M. Nettles
                         ACM SIGPLAN, 11/06/97
           Proceedings of the 1997 ACM SIGPLAN International
          Conference on Functional Programming, pages 292-305
         http://www.cis.upenn.edu/~jonm/papers/icfp97-abs.html

                              paper.hmn97
                                 draft
                           gavinm 1997-09-29


ABSTRACT:

We examine the costs and benefits of a variety of copying garbage collection 
(GC) mechanisms across multiple architectures and programming languages.  Our 
study covers both low-level object representation and copying issues as well as 
the mechanisms needed to support more advanced techniques such as generational 
collection, large object spaces, and type-segregated areas.

Our experiments are made possible by a novel performance analysis tool, Oscar.  
Oscar allows us to capture snapshots of programming language heaps that may 
then be used to replay garbage collections.  The replay program is 
self-contained and written in C, which makes it easy to port to other 
architectures and to analyze with standard performance analysis tools.  
Furthermore, it is possible to study additional programming languages simply by 
instrumenting existing implementations to capture heap snapshots.

In general, we found that careful implementation of GC mechanisms can have a 
significant benefit. For a simple collector, we measured improvements of as 
much as 95%.  We then found that while the addition of advanced features can 
have a sizeable overhead (up to 15%), the net benefit is quite positive, 
resulting in additional gains of up to 42%.  We also found that results varied 
depending upon the platform and language. Machine characteristics such as cache 
arrangements, instruction set (RISC/CISC), and register pool were important.  
For different languages, average object size seemed to be most important.

The results of our experiments demonstrate the usefulness of a tool like Oscar 
for studying GC performance.  Without much overhead, we can easily identify 
areas where programming language implementors could collaborate with GC 
implementors to improve GC performance.

REVIEWS:

  The authors are studying the effect of various GC techniques by taking 
(representations of) actual heaps and collecting them using their own collector 
included in the replay program.  This is not a sound approach: while a 
realistic model of actual object distributions is required for a meaningful 
evaluation, a dozen heaps captured from actual programs could fall far short of 
this.  The authors do not discuss the issue of representativeness of their heap 
snapshots.  Furthermore, the measurements will, strictly speaking, only apply 
to the Oscar GC implementation, so it is inappropriate to make general claims 
on this basis about the benefits of the techniques investigated.  Such claims 
might be proven by a careful analysis based on object distribution models 
derived from measurements of actual heaps.
  Even so, actual measurements of successful improvements are useful, because 
they are proofs-of-concept: at least under some circumstances, this technique 
is useful.  Negative results are less meaningful.  Also, this method is 
undoubtedly useful for tuning a given GC implementation (assuming it can be 
incorporated into a replay program).
  There are no surprises in results: only some curiosities that could probably 
be explained by the idiosyncrasies of the Oscar implementation.
  -- Pekka 1998-02-03

ATTACHMENT
   "icfp97.ps"

