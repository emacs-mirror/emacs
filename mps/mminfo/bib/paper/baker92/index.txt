 CONS SHOULD NOT CONS ITS ARGUMENTS, OR, A LAZY ALLOC IS A SMART ALLOC
                             Henry G. Baker
                                    
           ftp://ftp.netcom.com/pub/hb/hbaker/LazyAlloc.html

                             paper.baker92
                                 draft
                           richard 1996-07-17


ABSTRACT:

"Lazy allocation" is a model for allocating objects on the execution stack of a 
high-level language which does not create dangling references.  Our model 
provides safe transportation into the heap for objects that may survive the 
deallocation of the surrounding stack frame.  Space for objects that do not 
survive the deallocation of the surrounding stack frame is reclaimed without 
additional effort when the stack is popped.  Lazy allocation thus performs a 
first-level garbage collection, and if the language supports garbage collection 
of the heap, then our model can reduce the amortized cost of allocation in such 
a heap by filtering out the short-lived objects that can be more efficiently 
managed in LIFO order.  A run-time mechanism called "result expectation" 
further filters out unneeded results from functions called only for their 
effects.  In a shared-memory multi-processor environment, this filtering 
reduces contention for the allocation and management of global memory.

Our model performs simple local operations, and is therefore suitable for an 
interpreter or a hardware implementation.  Its overheads for functional data 
are associated only with _assignments_, making lazy allocation attractive for 
"mostly functional" programming styles.  Many existing stack allocation 
optimizations can be seen as instances of this generic model, in which some 
portion of these local operations have been optimized away through static 
analysis techniques.

Important applications of our model include the efficient allocation of 
temporary data structures that are passed as arguments to anonymous procedures 
which may or may not use these data structures in a stack-like fashion.  The 
most important of these objects are functional arguments (funargs), which 
require some run-time allocation to preserve the local environment. Since a 
funarg is sometimes returned as a first-class value, its lifetime can survive 
the stack frame in which it was created.  Arguments which are evaluated in a 
lazy fashion (Scheme "delays" or "suspensions") are similarly handled.  
Variable-length argument "lists" themselves can be allocated in this fashion, 
allowing these objects to become "first-class".  Finally, lazy allocation 
correctly handles the allocation of a Scheme control stack, allowing Scheme 
continuations to become first-class values.

ATTACHMENTS
   "LazyAlloc.pdf"
   "LazyAlloc.ps"

