            MEASURED COST OF CONSERVATIVE GARBAGE COLLECTION
                             Benjamin Zorn
              University of Colorado at Boulder, 01/04/92
                     Technical Report CU-CS-573-92
    ftp://ftp.cs.colorado.edu/pub/techreports/zorn/CU-CS-573-92.ps.Z

                              paper.zorn92
                                 draft
                             drj 1995-07-28


ABSTRACT:

Because dynamic memory management is an important part of a large
class of computer programs, high-performance algorithms for dynamic
memory management have been, and will continue to be, of considerable
interest.  Experience indicates that for many programs, dynamic
storage allocation is so important that programmers feel compelled to
write and use their own domain-specific allocators to avoid the
overhead of system libraries.  Conservative garbage collection has
been suggested as an important algorithm for dynamic storage
management in C programs.  In this paper, I evaluate the costs of
different dynamic storage management algorithms, including
domain-specific allocators; widely-used general-purpose allocators;
and a publicly available conservative garbage collection algorithm.
Surprisingly, I find that programmer enhancements often have little
effect on program performance.  I also find that the true cost of
conservative garbage collection is not the CPU overhead, but the
memory system overhead of the algorithm.  I conclude that conservative
garbage collection is a promising alternative to explicit storage
management and that the performance of conservative collection is
likely to be improved in the future.  C programmers should now
seriously consider using conservative garbage collection instead of
malloc/free in programs they write.

REVIEWS:

[I think I wrote the following review, but it was a long time ago.  drj 
1998-12-17]

It compares the execution of 6 programs (the same ones used in his
CustoMalloc paper) when run with 4 different malloc/free algorithms
(SunOS cartesian tree, BSD buddy, GNU malloc, Knuth first fit) and
also with the Boehm--Weiser collector (version 1.6!).  The effect of
using domain specific custom-built allocators is also measured.  An
interesting statistic that he gives is that 40% os development time is
spent implementing memory management procedures and finding bugs
related to explicit storage reclamation.

The conclusions are:
- that MM overhead varies greatly between algorithms
- that conservative GC is not significantly more of a time overhead than
malloc/free
- that conservative GC uses significantly more memory than malloc/free
(2 to 3 times more)
- that conservative GC destroys locality of reference
- custom-built domain specific allocators usually gave only a marginal
improvement, often better improvement could be gained my simply using a
different off the shelf allocator.  Some domain specific allocators
pessimised the MM overhead.

I expect that with a generational collector, the space overhead and the
locality of reference could be improved.

ATTACHMENT
   "Zorn92.ps"

