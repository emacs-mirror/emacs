              RECURSIVE FUNCTIONS OF SYMBOLIC EXPRESSIONS
                    AND THEIR COMPUTATION BY MACHINE
                              J. McCarthy
                             CACM, 03/04/60
                [A LaTeX'ed version with 1995 footnotes
    can be found at] http://www-formal.stanford.edu/jmc/recursive.ps
                          [and recursive.dvi]

                            paper.mccarthy60
                               incomplete
                           gavinm 1996-09-30


ABSTRACT:

[opening paragraph:] 

A programming system called LISP (for LISt Processor) has been developed for 
the IBM 704 computer by the Artificial Intelligence group at M.I.T.  The system 
was designed to facilitate experiments with a proposed system called the Advice 
Taker, whereby a machine could be instructed to handle declarative as well as 
imperative sentences and could exhibit "common sense" in carrying out its 
instructions. The original proposal [1] for the Advice Taker was made in 
November 1958. The main requirement was a programming system for manipulating 
expressions representing formalized declarative and imperative sentences so 
that the Advice Taker could make deductions.

REVIEWS:

This brief paper describing the first LISP is highly recommended to any reader. 
It is of particular interest to memory management for two reasons: it is the 
first journal paper to describe either garbage collection or an activation 
stack.

Various earlier versions of this paper were written for MIT progress reports 
before publication in CACM in April 1960 (as part of an Artificial Intelligence 
issue). Garbage collection first appeared in an April 1959 version. Apparently 
it was first implemented in the summer of 1959 by S. Russell and D. Edwards. 
For more information, see "The Influence of the Designer on the Design -- J. 
McCarthy and LISP", by Herbert Stoyan, University of Erlangen, which can be 
found at <URL: http://www8.informatik.uni-erlangen.de/html/lisp/mcc91.html>.

Section 4 of the paper describes the implementation of the LISP system, and has 
this subsection (4c) on the "Free-Storage List", clearly describing a 
(non-incremental) mark-sweep GC:

   At any given time only a part of the memory reserved for list
   structures will actually be in use for storing S-expressions. The
   remaining registers (in our system the number, initially, is
   approximately 15,000) are arranged in a single list called the
   free-storage list. A certain register, FREE, in the program contains
   the location of the first register in this list. When a word is
   required to form some additional list structure, the first word on the
   free-storage list is taken and the number in register FREE is changed
   to become the location of the second word on the free-storage list. No
   provision need be made for the user to program the return of registers
   to the free-storage list.
   
   This return takes place automatically, approximately as follows (it is
   necessary to give a simplified description of this process in this
   report): There is a fixed set of base registers on the program which
   contains the locations of list structures that are accessible to the
   program. Of course, because list structures branch, an arbitrary
   numberof registers may be involved. Each register that is accessible
   to the program is accessible because it can be reached from one or
   more of the base registers by a chain of car and cdr operations. When
   the contents of a base register are changed, it may happen that the
   register to which the base register formerly pointed cannot be reached
   by a car-cdr chain from any base register. Such a register may be
   considered abandoned by the program because its contents can no longer
   be found by any possible program; hence its contents are no longer of
   interest, and so we would like to have it back on the free-storage
   list. This comes about in the following way.
   
   Nothing happens until the program runs out of free storage. When a
   free register is wanted, and there is none left on the free-storage
   list, a reclamation* cycle starts.
   
   First, the program finds all registers accessible from the base
   registers and makes their signs negative. This is accomplished by
   starting from each of the base registers and changing the sign of
   every register that can be reached from it by a car-cdr chain. If the
   program encounters a register in this process which already has a
   negative sign, it assumes that this register has already been reached.
   
   After all of the accessible registers have had their signs changed,
   the program goes through the area of memory reserved for the storage
   of list structures and puts all the registers whose signs were not
   changed in the previous step back on the free-storage list, and makes
   the signs of accessible registers positive again.
   
   This process, because it is entirely automatic, is more convenient for
   the programmer than a system in which he has to keep track of and
   erase unwanted lists. Its efficiency depends on not coming close to
   exhausting the available memory with accessible lists. This is because
   the reclamation process takes several seconds to execute, and
   therefore must result in the addition of at least several thousand
   registers to the free-storage list if the program is not to spend most
   of its time in reclamation.
   
(*) There is a footnote here, presumably added in 1995: 
   
   We already called this process "garbage collection", but I guess I
   chickened out of using it in the paper -- or else the Research
   Laboratory of Electronics grammar ladies wouldn't let me.

Subsecton 4e ("Representation of S-functions by Programs") also has this 
description of an activation stack (called "the public push-down list"):

   In general (we shall discuss an exception), the routine for a
   recursive function uses itself as a subroutine. For example, the
   program for subst[x;y;z] uses itself as a subroutine to evaluate the
   result of substituting into the subexpressions car[z] and cdr[z].
   While susbst[x;y;cdr[z]] is being evaluated, the result of the
   previous evaluation of subst[x;y;car[z]] must be saved in a temporary
   storage register. However, subst may need the same register for
   evaluating subst[x;y;cdr[z]]. This possible conflict is resolved by
   the SAVE and UNSAVE routines that use the public push-down list. The
   SAVE routine is entered at the beginning of the routine for the
   recursive function with a request to save a given set of consecutive
   registers. A block of registers called the public push-down list is
   reserved for this purpose. The SAVE routine has an index that tells it
   how many registers in the push-down list are already in use. It moves
   the contents of the registers which are to be saved to the first
   unused registers in the push-down list, advances the index of the
   list, and returns to the program from which control came. This program
   may then freely use those registers for temporary storage. Before the
   routine exits it uses UNSAVE, which restores the contents of the
   temporary registers from the push-down list and moves back the index
   of this list. The result of these conventions is described, in
   programming terminology, by saying that the recursive subroutine is
   transparent to the temporary storage registers.

See also a page from McCarthy's 1958 memo in which this was first described: - 
memo4.gif 

Further minor points of relevance to memory management:

- This LISP system did not permit circular data structures, although the 
garbage collector could have dealt with them. This is also discussed in section 
4 of the paper.

- The "cons cell" as the unit of storage for LISP is at least partly motivated 
as follows:

"Registers can be put back on the free-storage list when they are no longer 
needed. Even one register returned to the list is of value, but if expressions 
are stored linearly, it is difficult to make use of blocks of registers of odd 
sizes that may become available" (section 4a). i.e. it prevents fragmentation.


ATTACHMENTS
   "recursive.ps"
   "memo4.gif"

