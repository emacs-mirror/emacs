           A CUSTOMISABLE MEMORY MANAGEMENT FRAMEWORK FOR C++
              Giuseppe Attardi;Tito Flagella;Pietro Iglio
             Software -- Practice and Experience, 01/11/98
                           28(11), 1143-1183
           ftp://ftp.di.unipi.it/pub/Papers/attardi/SPE.ps.gz

                              paper.afi98
                                 draft
                            pekka 1999-06-02


ABSTRACT:

Automatic garbage collection relieves programmers from the burden of managing 
memory themselves and several techniques have been developed that make garbage 
collection feasible in many situations, including real time applications or 
within traditional programming languages. However optimal performance cannot 
always be achieved by a uniform general purpose solution.  Sometimes an 
algorithm exhibits a predictable pattern of memory usage that could be better 
handled specifically, delaying as much as possible the intervention of the 
general purpose collector.  This leads to the requirement for algorithm 
specific customisation of the collector strategies.  We present a dynamic 
memory management framework which can be customised to the needs of an 
algorithm, while preserving the convenience of automatic collection in the 
normal case.  The Customisable Memory Manager (CMM) organises memory in 
multiple heaps.  Each heap is an instance of a C++ class which abstracts and 
encapsulates a particular storage discipline.  The default heap for collectable 
objects uses the technique of mostly copying garbage collection, providing good 
performance and memory compaction.  Customisation of the collector is achieved 
exploiting object orientation by defining specialised versions of the collector 
methods for each heap class.  The object oriented interface to the collector 
enables coexistence and coordination among the various collectors as well as 
integration with traditional code unaware of garbage collection.  The CMM is 
implemented in C++ without any special support in the language or the 
compiler.  The techniques used in the CMM are general enough to be applicable 
also to other languages.  The performance of the CMM is analysed and compared 
to other conservative collectors for C/C++ in various configurations.

REVIEWS:

This is the nearest thing in the literature to MPS' cooperating pools, but CMM 
heaps only cooperate in finding pointers (tracing), not in actual collections.  
Partly this is in order to keep CMM simple (it's supposed to be portable C++), 
but mostly they just missed seeing how close they are to having all the pieces 
needed: Their Traverse methods match our Scan methods; they just need some 
protocol for heaps to condemn in cooperation.

Addressing their reasons for not doing multiple collections (bottom of p.9):

1. the order of operations is relevant: the mostly-copying collector requires 
that all roots be scanned before it can start the promotion phase [I guess they 
mean "end the promotion phase"].

That some roots are in (one of) the heap(s) need not be a problem, as long as 
you are aware of it [I guess that's the problem they're thinking of].

2. a single global traversal would require collectors to be aware of each other 
or to implement a schema to transfer control among each other.

This is where they don't realize their Traverse is all they need.  Plus the 
trivial Condemn and Reclaim i/f -- or is this really rocket science?

3. certain heaps are designed to perform a partial collection limited to their 
areas: [...]

It's true that the strategies of different heaps might not mesh very well, so 
this is where a protocol to cooperate in a global strategy is needed.  However, 
this is the right direction; MM is a global issue.  There could be a worse 
conflict now _because_ the several heaps do not cooperate.

Also, remembered sets (which CMM doesn't support) can limit collection quite 
effectively.

4. each collector maintains bookkeeping information: [...]

It's true that condemning more might consume more working memory.  If the 
collector is like that, then it should take this into account when planning its 
strategy (start early enough, decline to start if there's not enough memory, 
preallocate, etc.).

They do have a comment on the bottom of page 11: "Even if one could envision 
collections being done concurrently on all heaps, we have not investigated this 
aspect."  I.e., they reserve judgement on the possibility.

Their new distinction of "opaque" and "transparent" heaps is similar to our 
"unformatted" and "formatted".  They simply use opaque heaps as ambiguous roots 
(or that's what they say on p.11 -- actually, it seems each heap can decide in 
its collect method whether to do that).

Something's wrong about their objection to registering pointers passed to 
external libraries (p.11, para 3) -- surely you have to do this anyway, to pin 
them.  I guess they assume scanning the uncollected heap and the stack 
ambiguously will find all such pointers, even for OS routines.

They seem to _equate_ "root" and "ambiguous pointer" (top of p.11).  Pointers 
from uncondemned heaps can be considered roots, to be sure, but why would they 
always be ambiguous?  Figure 3 (copied from the old paper) seems to suggest 
roots could be allocated in the copy-collected heap, hence in a formatted 
object -- apparently such roots would still be scanned ambigously.

Note that pointers from uncondemned transparent heaps are not "roots" (part of 
the initial grey set).  This architecture puts them in the curious position of 
insisting that all the live objects in each heap are reachable from that heap's 
roots.  Surely roots are global!  However, if their condemned sets are 
typically small, they might well be in the position to say that only a few 
roots are relevant.  This does seem to give them an edge over Boehm on their 
chosen benchmark, the Buchberger algorithm.  The MPS has to rely on remembered 
sets cutting down the gray set, which might be hard in a conservative GC.

Possibly this architecture arose because they started with one collected heap + 
manual ("uncollected") heap and haven't reconsidered the case of multiple 
collected heaps.

The CMM comes with a mostly-copying and a mark-sweep collector plus a 
manually-managed heap -- a good selection.

Performance results are provided, unlike the earlier paper, and they look OK.  
The CMM-TM configuration is so closely matched to the application that it's not 
useful to gauge the quality of CMM, but table 6 provides a fair comparison 
between CMM and the Boehm-Wieser collector: CMM is slightly worse.

It's worth noting that stopping the Boehm collector from recognizing interior 
pointers (NIP) speeded it up and made it use much less memory: at least some 
applications have a lot of bogus pointers.

pekka 1999-06-03


ATTACHMENT
   "SPE.ps"

