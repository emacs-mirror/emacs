               LAG, DRAG, VOID AND USE -- HEAP PROFILING
               AND SPACE-EFFICIENT COMPILATION REVISITED
                      Niklas Rojemo;Colin Runciman
                             ACM, 01/05/96
    ICFP'96, ACM SIGPLAN Notices 31:6, ISBN 0-89791-770-7, pp. 34-41
         ftp://ftp.cs.chalmers.se/pub/users/rojemo/icfp96.ps.gz

                               paper.rr96
                                 draft
                            nickb 1996-08-01


ABSTRACT:

The context for this paper is functional computation by graph reduction. Our 
overall aim is more efficient use of memory. The specific topic is the 
detection of dormant cells in the live graph -- those retained in heap memory 
though not actually playing a useful role in computation. We describe a 
profiler that can identify heap consumption by such 'useless' cells. Unlike 
heap profilers based on traversals of the live heap, this profiler works by 
examining cells _post-mortem_. The new profiler has revealed a surprisingly 
large proportion of 'useless' cells, even in some programs that previously 
seemed space-efficient such as the bootstrapping Haskell compiler "nhc".

REVIEWS:

nickb:
Runciman strikes again. They divide the life of an object as follows: 'lag': 
after creation, before use; 'use': after first use, before last use; and 
'drag': after last use, before "destruction" (i.e. disconnection from the 
graph). Objects which are _never_ used are 'void' from creation to destruction. 
They add slots to each object to record use timestamps, and extend their heap 
profiler (which draws _great_ graphs, and which Runciman has described at 
length elsewhere) to analyse these slots and divide heap use into these four 
categories.

Before using the output to direct optimisation, the already-much-tweaked 
Haskell compiler has only 12% of its heap classified as 'use' (space x time). 
As in Runciman's previous work, the profiler output is then used to direct hand 
tweaking of code. By the end of the paper, 12% has become 32%, maximum heap 
space has nearly halved, a space x time measure of the heap has halved.

It's specialized to the graph reduction model, but the terminology is useful, 
the ideas could be generalized, and the graphs are a reminder of how pleasing 
and powerful graphical tools can be.

drj:
This paper exemplifies what benefits are to be gained from having the
right graphical tools available.  The division of cells into "lag",
"drag", "void", and "use" turns out to be really useful, and I suspect
would be equally useful for strict languages.

The graphics themselves do not instantly improve the performance of the
application, R&R clearly make use of their knowledge of how Haskell is
executed.  This is an important point to bear in mind; the graphics can
tell you where space and time is being wasted, but you have to look at
the code and think to find out why and how to improve the situation.

Skeptical as I am about lazy languages even I concur with their remark:
 "A fundamental question is if at all these problems are due to the use
  of a lazy language.  [...]  By using heap profiles on a lazy language
  we find problems with lazy languages.  Using it on a strict language
  we would find problems with strict languages too."

Good paper.

--drj--

ATTACHMENT
   "icfp96.ps"

