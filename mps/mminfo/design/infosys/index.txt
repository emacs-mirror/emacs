                  THE DESIGN OF THE INFORMATION SYSTEM
                             design.infosys
                           incomplete design
                           richard 1995-09-01


INTRODUCTION:

This document describes the top-level design of the MM Information System

.readership: This document is intended for any employee of Harlequin working 
with or interested in the MM Group Information System.


OVERVIEW:

The MM Information System consists of all the information collected by the MM 
Group.  It spans several Spring databases (principally MM 
Information[Notes4-specific link]), and Hope.


REQUIREMENTS:

.goal: The goals of the information system are:
  .goal.auto: To let us work autonomously;
  .goal.cons: To let us work consistently;
  .goal.exp: To let us learn from experience;
  .goal.goal: To let us direct our activity towards achieving our goals.

.req: The Information system must:
  .req.share: Enable information to be shared easily;
  .req.record: Enable information to be recorded easily;
  .req.indep: Be independent of its implementation;
  .req.find: Enable information to be found easily;
  .req.just: Allow the representation of justification.


ARCHITECTURE:

.arch: The Information System contains documents.  

.arch.tag: Each document has a tag (see guide.tag).  Tags are hierarchial, and 
indicate what sort of object the document represents.  They identify any 
document umambiguously (.req.find) and enable it to be referred to 
(.req.just).  Notes doclinks are used, but are secondary to tags.

.arch.key: Each document also has keywords (see design.infosys.keywords) either 
explicitly (in MM Information) or implicitly.  

.arch.where: Most information is stores in MM Information in Spring, or in 
Hope.  Either of these can be accessed anywhere (Spring can even be used on 
laptops) (.req.share, .req.record).

.arch.light: Creating or commenting on a document is lightweight.  Documents 
can be created as placeholders, and left temporary or incomplete.  Mail is 
imported into MM Information.  (.req.record).

.arch.text: Documents don't rely on implementation features for semantics, and 
are mainly text (see guide.text) (.req.indep).


IMPLEMENTATION:

.impl: More details of the design of the information system can be found in:
  - design.infosys.keywords: Keywords used on InfoSys documents
  - guide.bib: Guide to reviewing external publications
  - guide.tag: Guide to global tagging
  - guide.text: Guide to the format of text documents
  - overview.infosys: Overview of the Information System
  - proc.bib: Procedure for creating Bibliography Entries
  - process.infosys.statuses: Process of document statuses


TEXT:

[Rough notes; needs organization -- GavinM]`

X-Sender: richard@mailhost.cam.harlequin.co.uk
Mime-Version: 1.0
Date: Wed, 9 Aug 1995 11:19:15 +0100
To: mm
From: richard (Richard Brooksby)
Subject: About the Information System
Cc: mm-doc

It's about time I wrote down something about what I think the Memory
Management Information System is for, what it does, and what I want it to
do.

(A minor point: the Information System is designed to be independent of its
implementation.  At the moment, I've implemented it in a Lotus Notes
database called "Memory Management Information"
(PROJECTS/MEMMAN/MMINFO2.NSF), but it's supposed to portable.)

The final purpose of the Information System is (naturally enough) to help
us achieve our project and personal goals.  (Listen to this
management-speak!  Tsk!)  It should do this by helping us meet our
requirements and be more productive.  If it fails to do this, we'll do
something else.

To do this, I'd like the system to perform several functions.
  1. sharing and recording information,
  2. planning, managing work, and recording issues,
  2. managing processes,
  3. continuously improving processes to make the project more mature,
  4. measuring its own effectiveness and the effectiveness of processes.

Most importantly, the system is for sharing and recording information
(requirements, ideas, designs, meeting records, procedures, guides, papers,
etc.).  We identified the need for this some time ago, and that resulted in
my working on various bits of "documentation" with the aim of making it
possible to work more autonomously without sacrificing consistency.  I have
produced a number of outlines for documentation, and am gradually expanding
these and filling in more information.  I hope to accelerate this when Bob
Matthews arrives.

Having experimented with Microsoft Project, Mac Project, and various other
tools, I've come to the conclusion that we can best plan by a simple and
lightweight system of setting objectives and breaking them down
hierarchically.  The Information System can support this by recording the
objectives and allowing them to be viewed in various ways.  Since the
system is shared, the objectives are visible to everyone, so the whole plan
is always available.  With other systems, the plan has always been a file
on my Mac disk, and not much use to anyone else.  Also, the plan was put
together every so often, then "died" as the work progressed.  The plan in
the Information System will stay alive, because we can use it to manage our
day-to-day objectives in the same way as the longer term goals.

The system can be used to semi-automate various processes, the most
important of which is review, since it is review which checks and measures
the other processes.  The Information System can help by making the review
process as effective as possible while reducing the burden of carrying it
out.  There are quite a lot of things to bear in mind when reviewing, and a
lot of good experience and tips are mentioned in various sources, not the
least of which is Gilb93.  If these are written down in a convenient form
then we can get on with carrying out effective review with the minimum of
fuss.

In fact, the same is true of any process.  If we have good experience with
requirements analysis, idea generation, design, coding, or whatever, we
should share and use it, and improve it over time.  The written procedures,
rules, checklists, and guidelines should record all of our best experience,
and are therefore a means of bringing us all up to a really high standard
of working.  These documents should help and not hinder us in our work.  If
we find things that are hindering us, we change them.  If we think of new
things which would help, we add them.  Over time, the system will mature to
fit our needs.

Finally, the system should measure its own effectiveness in order to assist
in working out what is helping and what is hindering.  To this end, I
intend to include various metrics, such as the time spent checking a
document, the number of issues found, etc.  This will accelerate the pace
at which the system matures to help us.

I've put in a lot of extra hours getting it set up so that we can get
started with the system without perturbing the project too much.  I'd like
us to give it a good chance.  It should be in the nature of the system that
it becomes obvious when it is wasting time.  If it doesn't work out, I'll
drop it, but first, let's really try and make it into what we need.

I'll follow up with a message describing the specific details of what I've
built and how that is supposed to achieve all this.  This message will
become a general introduction to the system, which I will put somewhere.

                                     -*-

X-Sender: richard@mailhost.cam.harlequin.co.uk
Mime-Version: 1.0
Date: Wed, 9 Aug 1995 12:34:09 +0100
To: mm
From: richard (Richard Brooksby)
Subject: About the Information System 2: Implementation details
Cc: mm-doc

This mail follows on from "About the Information System", in which I
described the general purpose of the system.  Here, I attempt to describe
the details of how the system works.  This mail will be modified to form
documentation for the system which will be stored in the system itself
somewhere.


TAGS AND THINGS

The system stores stores "things".  All entities relevant to the project
can be entered into the system as things, with some standard information
about them.  A thing might be a design document, requirement, person,
procedure, meeting, defect, objective, or whatever.  A thing is represented
by a "document", and the form of the document is determined by the type of
thing.

Each thing is identified by a unique "tag", such as "book.gilb93" or
"design.general.process.collection".  The exact method of choosing a tag
depends on the type of the thing being tagged.  A document may contain
bindings of further tags.

Tagging provides a way of referring to things in the project.  For example,
an implementation may be derived form a particular bit of design, and meet
a certain requirement.  Its production may have been guided by a particular
style guide, and it may have followed a certain template.  The code may
also follow rules.  All these things are tagged, so recording them in the
implementation is easy.

Tagging things gives an ordered way of describing all things of importance
to the project, and of referring to them unambiguously.  When discussing
some topic in mail, for example, one can justify an idea or suggestion
simply by quoting the tags of the requirements it attempts to satisfy.


PORTABILITY

Documents stored in the system are formatted as much like plain text files
as possible.  We should resist the temptation to use the fancy features of
the implementation.  This maintains portability of the system and and the
information it contains.  We may have to change the implementation, and the
disruption to the project should be kept to a minimum.  It should be
possible to perform a simple transformation from, say, the Lotus Notes
implementation to a set of files on a FAT file system.

Having said that, we can use features of the implementation to help us
organize the information in the system.  For example, Notes will give us
ways of viewing the contents of the system.  It is also OK to use
implementation specific formatting, but only if the document doesn't lose
meaning or usefulness when stripped of that formatting.


COMMON INFORMATION

All things have certain bits of information stored.  These are Tag,
Revision, Status, Type, Title, Creator, and CreationTime.

  Tag: The unique hierarchical identifier for the thing.  Tags should be made
       up of the characters A-Z, a-z, 0-9, and hyphen, with elements separated
       by dots (periods).  The case of characters in a tag is not significant.
       Tags will be canonically stored as lower case.  Each document type will
       define how to choose the tag for that document.
         In general, the tag is the name of the object that is tagged, and it
       is therefore a "noun phrase" in some sense.  For example, a bibliography
       entry for a book is tagged "book.xxxyy" and not "bib.xxxyy".

  Revision: A revision number for the thing.  When the thing is modified, the
            revision number should be increased by one.  A tag may be qualified
            with a revision number (e.g. "process.rights(3)") to indicate which
            particular version of the thing is meant.  Usually, revisions are
            increased when an "accepted" (reviewed) document is modified.  The
            new revision becomes "draft" until it is reviewed.

  Status: This is the stage of processing of the thing, indicating its progress
          within the project.  New things are "incomplete", but can become
          "draft" when the creator things they are complete.  Draft
          documents can be submitted for review, and their status changes as
          they pass through the review process.  Finally, they become
          "accepted", indicating that they have been checked and can be
          relied upon.

  Type: The generic type is "thing", since all things are "things".  Each
        document type has a "form" which determines the information stored
        in the thing and how it is formatted.  Things of type "thing" have the
        most general document form -- free text.  Where approrpriate, there
        are more specific forms for other types which attempt to make the
        information more regular and assist its processing.  For example,
        bibliography entries are in a particular format, and include author
        information.  The Lotus Notes implementation implements forms directly,
        but they are basically plain text templates.

  Title: The title is a short description of the thing in English.  The tag
         should be enough information for the initiated to figure out what
         something is.  The title should provide enough information for the
         uninitiated, for example, a visitor from another project looking at
         the system.

  Creator: The creator is the person (or people) who created the thing. If the
           thing is being copied from elsewhere (for example, a pre-existing
           document or mail message) then it should be the person who created
           the information in the first place.  When a document is revised,
           the person or people who revise it become the creators of a new
           revision of that document.

  CreationTime: The time at which the thing was created.  Usually this is the
                thing is entered into the system.  If it's being copied from
                elsewhere, try to use the original date that the information
                was created.  When a document is revised, a new revision is
                created, and therefore the creation time is the time of the
                revision.

The common fields are always written at the top of a document in a
particular way, as shown below.
---
<Tag>(<Revision>)  <status> <type>
<blank line>
                          <Upper case title>
                    <Creator>, <Creation date (ISO)>
<blank line>
<blank line>
---
For example:
---
paper.wil95(1)  draft bib

        DYNAMIC STORAGE ALLOCATION: A SURVEY AND CRITICAL REVIEW
                      Richard Brooksby, 1995-08-03


---


TYPES OF THING

Each thing has a type, and each type has a form which defines what
information should be present for that thing, and how it should be
formatted.

The set of types is by no means complete.  I expect us to develop new types
and modify old ones as appropriate.  Here is a list of types that are
defined at the moment.  Most stuff in the system is currently of type
"thing" because we have so few types defined.  This is not necessarily a
problem.

Each type should have:
  - a description of purpose,
  - procedures for producing documents of that type,
  - how to tag documents of that type,
  - rules and guidelines applying to the content.

Thing -- thing

Type "thing" is the most general type.  The form is simply the common
information header described above, plus a text document.  This type is
used where there is not a more specific type defined.  The presence of
documents of type "thing" in the system indicates that perhaps there should
be some more types defined.

Since thing is the catch-all type, there is no defined scheme for tagging.
When a thing is created because there is no appropriate form in a
particular area of the system, use the scheme for the things around it.
For example, information which supplements a bibliography entry could be
tagged "book.gilb93.appendix".  Choose a tag which describes the _thing_
itself, and is therefore a noun.

Bibliography Entry -- bib

A bibliography entry records information about a publication.  The form
includes standard publication details, and also space for a copy of the
abstract, and reviews and comments.

Tags for bibiography entries are derived from the type of publication, the
authors names, and the publication date.  A paper by Paul Wilson published
in 1995 is tagged "paper.wil95".  A book by Tom Gilb published in 1989 is
tagged "book.gilb89".

Planning Objective -- obj

An objective is the end result of a task, and might be described as a
milestone.  Objectives are phrased in terms of end results, not activities.
For example, "Complete implementation of allocation buffers" is an
objective, whereas "Work on allocation buffers" is not.

The objective form describes who is responsible for the objective, and when
it is due to be completed.  There is also space for notes.  [In future, it
will contain other information -- richard]

Tags for objectives are determined hierarchically to fit in to the project
plan.  The form of the tag is "obj.<area>.<type>.<deliv>.<task>.<task>...",
where:
  area: of the project such as "dylan", "ep", or "general",
  type: of requirement, such as "soft" for software or "support" for support,
  deliv: is the deliverable name, e.g. "alloc", "debug", "incr",
  task: hierarchically named task tags.
[This is all a bit vague -- Richard]

Functional Requirement -- fun

A functional requirement is a description of some functionality that the
project must provide.  This could be software functionality, such as
garbage collection, or group functionality, such as support.  Functional
requirements are determined by negotiation with clients.

It is very important the the functional requirements are traceable.  We
must know where they come from, and what their status is.  We also need to
analyse them to determine unambiguously what they mean.  Each requirement
should also have an analysis of its consequences.  The fun form includes
fields to assist with this.

Functional requirements are tagged "req.<client>.fun.<type>.<name>....", where:
  client: is who we are supplying, such as "dylan", "ep",
  type: sort of requirement, e.g. "soft", "support",
  name: er, there's not much of a scheme for these yet.

Attribute Requirement -- attr

An attribute requirement is a description of a constraint on the
functionality that we must provide.  A constraint might be on resources, or
a requirement for certain qualities in the product.  All attribute
requirements are stated on measurable scales, with methods for testing
satisfaction.  Attribute requirements are determined by negotiation with
our clients.

Like functional requirements, attributes must be traceable, and they must
be analysed.  The attr form has fields to help this.

Attribute requiremens are tagged "req.<client>.attr.<name>...", where:
  client: is who we are supplying, such as "dylan" or "ep",
  name: is a hierarchical name derived from the appendices of book.gilb89.
[I really ought to write that up properly -- Richard]

[More later -- Richard]
---
X-Sender: richard@mailhost.long.harlequin.co.uk
Mime-Version: 1.0
Date: Thu, 30 Jan 1997 14:28:46 +0000
To: gavinm
From: Richard Brooksby <richard>
Subject: The MM Information System: Introduction

Gavin,

I'd like you to (intelligently) merge this document with overview.infosys.
You could also tag the result if it has little overhead.

> X-Sender: richard@mailhost.long.harlequin.co.uk
> Mime-Version: 1.0
> Date: Fri, 30 Aug 1996 12:14:32 +0100
> To: mlworkers
> From: Richard Brooksby <richard>
> Subject: The MM Information System: Introduction
> Cc: mm
> Status:
>
> This is a copy of the notes I made for the talk about the information
> system used by the Memory Management Group.
>
> The Information System is a simple document management system used by the
> MM Group.  It is not perfect, and does not solve all problems, but it is
> practical and lightweight and a hell of a lot better than nothing.
>
> It is _not_ a Notes database.  Notes is used to store many of the
> documents, but so it Hope.  The Information System is an abstract things,
> which happens to be implemented in Notes.  It was created before Notes was
> in common use.
>
> The Information System is designed primarily to ensure that all the
> activities of the group are directed towards achieving the group's goals.
> This ties in with various goal-driven project management techniques which I
> will describe.  The main way in which the structure of the system supports
> the project is by _justification_.
>
>
>            goals <-- req <-- arch/plan <-- design <-- impl
>
> The requirements document is linked to the goals, and justified in terms of
> them.  The architecture and plans are linked to the requirements, and
> describe how they are met.  The designs must describe parts which make up
> the architecture.  The implementation must be justified in terms of design.
> (Of course, there are often links which skip stages.)  In this way, the
> quality of the implementation is helped by making sure it supports the
> goals.
>
> [Example here.]
>
> This may seem a little OTT.  An important concept here is
> "appropriateness".  Whenever a "formal" process is applied it is very
> important to continuously assess how well that process itself is
> contributing to the goals.  Formality must be applied to an appropriate
> extent.  Implementations are often knocked together before designs.
> Procedures are often bypassed.  The important thing is to take decisions in
> an informed way, knowing that what you are doing is justified.  This can
> only be done if there is enough information to make an informed decision.
>
> Many of the things I describe are "ideals".  We don't always apply all the
> structures and techniques I describe to their full extent, but we do try to
> apply them to an appropriate extent.  It's important to admit that, because
> you can never practically achieve the ideal.  That doesn't mean it's not
> worth having as a model for what you actually do.
>
> The Information System implements the justification links between documents
> by "tagging".  Tagging is a way of assigning a name to every piece of
> information.  Usually this means each paragraph of documentation, since
> each paragraph usually describes a concept or decision.
>
> Each document has a tag, which is always written at the top-left corner.
> Every document also has a "revision number", "status" and a "type".  The
> status indicates whether the document is complete, temporary, draft, or
> approved.  There is also a document title, creator, and creation date.
> These are less important.
>
>
>             .------------------------------------.
>             | foo.bar(2)  draft  doc             |
>             |                                    |
>             |           FOO BAR AND BAZ          |
>             |           richard, 1996-08-30      |
>             |                                    |
>
> The tag is the "name" of the document.  It can be used elsewhere in the
> information system to reference this document, by simply stating it, e.g.
> foo.bar.  If it's important which revision is referenced, the revision
> number is appended, e.g. foo.bar(1).
>
> Within the document, tags can be declared using a special type of heading.
> Usually tags are used to name particular statements, like this:
>
>             |                                    |
>             | .baz: The third meta-syntactic     |
>             | variable is "baz" (see book.hd92). |
>             |                                    |
>
> This statement is called foo.bar.baz (or foo.bar(2).baz if it's important
> which revision).
>
> That's it, really.  There are quite a few subtle points to do with how to
> use tags effectively, but there's not much more to know about their
> _implementation_.
>
> Implementation (i.e. code) is treated as a set of documents.  For example,
> revision 1.12 the file pool.c in the MM sources is tagged impl.c.pool(12).
>
> The document type indicates the purpose and content of the document, in
> broad terms.  It also tells you which rules the document is supposed to
> obey, so that it can be reviewed.
>


