                     THE DESIGN OF THE BUILD SYSTEM
                            design.buildsys
                           incomplete design
                           richard 1995-08-25


INTRODUCTION:

This document will describe the design of the build system.


OVERVIEW:

see design.buildsys.unix for the design of the unix build system.


TEXT:

Both drj and dsm have mentioned that they spend too long mucking around with 
HOPE compounds, changing directories, and editing makefiles for different 
target platforms.  This has a lot to do with the way I set up the build system 
and divided the sources into "products".  Originally, I expected us to store a 
lot more information under HOPE, but now this looks less likely, and we're 
probably only going to keep the sources in it.  This means we can reform and 
simplify the structure of the sources to make them easier to handle.  I should 
produce a design document for the build system and analyse the requirements a 
bit more carefully.  The build system will also need to support various tests.

---

OLD BUILD SYSTEM DOCUMENTATION

INTRODUCTION

This document describes the way Memory Management Project sources are
compiled into targets.


AIMS

.goals:

 1. Products should be easy to port across operating systems,
    architectures, and development environments.
 2. The build system should not consume much developer time.

The first aim implies that the build system must use only standard
tools that will be available on all conceivable target platforms.
Experience of development environments on the Macintosh (Metrowerks
Codewarrior) and Windows NT (Visual C++) indicates that we cannot
assume much sophistication in the use of file structure by development
environments.  The best that we can hope for is the ability to combine
a fixed list of source files, libraries, and predefined preprocessor
symbols into a single target.

The second aim implies that we don't spend time trying to develop a
set of tools to support anything more complicated than the simple
build function described above.  The effort in constructing and
maintaining a portable system of this kind is considerable.  Such
efforts have failed in EP.



OVERVIEW


The Build Function

The build system assumes only a simple `build function' which can be
defined this:

  target = build([source0, source1, ...],
                 [lib0, lib1, ...],
                 [def0, def1, ...])

The function takes a set of sources, possibly in several languages,
and compiles them with a set of preprocessor definitions predefined,
combining the result with a set of libraries to form a target.
Separate compilation and linkage can be seen as a memoization of this
function, and is not necessary for the build system to function.


File Structure

Each product consists of a single directory (corresponding to a HOPE
compound) containing all the sources for the whole family of targets.
The names of sources must be unique in the first eight characters in
order to conform to FAT filesystem naming restrictions.  The extension
may be up to three characters and directly indicates the source
language.

Valid extension are:
  c     ANSI C
  h     ANSI C header


Target Descriptions

The file targets.tdl contains a list of possible targets and the
parameters to specify to the build function in order to obtain them.
What exactly this entails depends on the development environment being
used.

In Visual C++, for example, one needs to create a project file, add
the list of sources and libraries to it, and define the preprocessor
symbols via the Project Options dialog.

On Unix the target description can be translated into a single command
line, although a Makefile is preferable to reduce unnecessary
recompilation.

For example:

  debugging target, Linux, 386, GCC:
    sources: arenma.c assert.c deque.c pool.c poolint.c poolmv.c segma.c
    libs:
    defines: DEBUG, OS_LINUX, ARCH_386, BUILD_GCC

becomes a Makefile something like

CC = gcc
CFLAGS = -ansi -pedantic -Wall -DDEBUG -DOS_SUNOS -DARCH_SPARC -DBUILD_GCC
OBJS = arenma.o assert.o deque.o pool.o poolint.o poolmv.c segma.o

libmmdw.a: $(OBJS)
        ar r libmmdw.a $(OBJS)


Modules and Naming

The product consists of a set of modules which may vary from target to
target.  Each module has an identifier which is unique within that
product.  The primary interface of the module is defined in a C header
file with the same name as the module.  Where the module interface
varies from target to target, this header may select one of a set of
target-specific headers by testing a target parameter (see below) such
as the target operating system or architecture.  The target specific
headers should begin with the same prefix (either the module id or a
shortened version of it) and be suffixed with one or more target
parameter codes.

Each module has one or more implementations which may be in any
language supported by the relevant build environment.  The primary
implementation of a module is written in ANSI C in a source file with
the same name as the module.  The names of other implementations
should begin with the same prefix (as for headers, the module id or a
shortened version of it) and be suffixed with on or more target
parameter codes (defined below).  In particular, the names of assembly
language sources must include the target parameter code for the
relevant architecture.


Target Parameters

Every build should have at least three preprocessor symbols predefined
describing the target operating system, architecture, and the build
environment.  Only one symbol from each category may be defined.

There follows a glossary of valid preprocessor symbols and target
parameter codes for use in filenames and other tight spaces.

Operating System

OS_NT           NT      Windows NT
OS_MAC          MA      Macintosh System 7
OS_LINUX        LI      Linux
OS_SUNOS        SU      SunOS 4

Architecture

ARCH_386        86      Intel i386, i486, or Pentium
ARCH_68K        68      Motorola 68000 family
ARCH_SPARC      SP      SPARC family

Build environment

BUILD_MVC       MV      Microsoft Visual C++
BUILD_METROWERKS MW     Metrowerks Codewarrior
BUILD_GCC       GC      GNU GCC


