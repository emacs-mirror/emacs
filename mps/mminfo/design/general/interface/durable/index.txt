                      DESIGNING DURABLE INTERFACES
                    design.general.interface.durable
                           incomplete design
                           richard 1996-08-01

INTRODUCTION


Scope

.scope: This document describes the issues involved in designing, implementing, 
and maintaining interfaces between client code and libraries which are durable, 
i.e. robust against change.  It proposes some solutions.


Readership

.readership: Any software engineer.


History

.hist.0: Created 1996-08-01 by Richard Brooksby <richard> as a result of 
discussions with Richard Kistruck <richardk> and David Jones <drj>.


GOALS

.goal: The goal of a durable interface is to provide a connection between 
client code and a library which allows either of them to change without 
breaking their compatibility.  In particular, it should not be necessary to 
recompile the client code in order for it to work with a new version of a 
library.  One should be able to link them together.  This is convenient for the 
developer, and essential for upgrading in the field.


REQUIREMENTS

.req.fun.req: The interface must not prevent either the client code or the 
library from meeting their requirements in any working combination.

.req.fun.recompile: The client code shouldn't need to be recompiled to use a 
new version of the library.

.req.fun.detect: Both the library and the client code should be able to detect 
when there is an incompatibility in order to deal with it properly.

.attr.???: Library development shouldn't be hindered by the presence of the 
interface.

.attr.???: As many working combinations as possible should be permitted.


DISCUSSION

There are three apsects to the interface between the client and the library: 
binary interface, protocols, and source interface.

The binary interface consists of linkage (external symbol names), types 
(especially structure layout), and calling conventions.  It is determined by 
the interface source code (header files) in combination with the compiler and 
platform.

The protocols are the semantics expected by the client, i.e. how the library 
behaves.  They are determined by the design of the library (as reflected in the 
user documentation) and the design and source code of the client.

The source interface consists of type names (especially structure field names), 
macro definitions, and constants, and is determined by the interface source 
code (header files).

A durable interface must consider all three of these levels.  Compatibility in 
the binary interface ("binary compatibility") is of no use to the client 
without protocol compatibility, because the operations performed by the library 
will not be what the client expects.


Changes

- Changing the name of a type affects only source interface compatibility.

- Changing the name of a constant or macro affects only source interface 
compatibility.

- Changing the value of constant or macro affects binary compatibility.  It may 
also affect protocol compatibility if:
  - the way in which the macro is used changes (e.g. parameters change);
  - the protocol depends on the value of the constant (e.g. a repeat count or 
limitation);

- Changing the name of a function

[We need to systematically consider the affect of changing each of the 
following:

Function Prototypes
  Name
  Return Type
  Parameter Types
  Parameter Names
  Parameter Position
Global Data
  Name
  Type (incl. size)
  Initializers?
Types
  Structures
    Typedef Name
    Tag
    Field Name
    Field Position
  Unions
    Typedef Name
    Tag
    Field Name
  "Unboxed"
  Arrays (with implicit constants)
Macros
  Constants (incl. enums?)
  Function-like
    Use of Public Protocol
    Use of Secret Protocol
  Syntactic
    Legal Context
    Use of local variables
    Dependency on other macros
    Dependency on free variables
Dependencies
  On other headers
  On predefined symbols
  On language features

-- richard]


SOLUTION IDEAS


Version Numbering

The compiled client code has two expectations: binary interface and protocols.  
The binary interface was determined when the client was compiled against the 
interface source code.  The protocols were determined when the client code was 
designed and implemented.  Neither can be changed if we are to satisfy 
.req.fun.recompile.

In order to meet .req.fun.detect, the binary interface and protocol 
expectations must be communicated to the library.  Version numbers can be used 
to identify these expectations.  For example, the client can say that it wants 
binary interface version 4 or 5, and is expecting protocol version 2.  The 
library can oblige or throw an error.

Since the binary interface is determined by the interface source code, its 
version number can be encoded there as a constant which gets compiled into the 
client (e.g., a "#define" constant).  However, the protocol is an expectation 
of the _design_ of the client, and must be encoded in the client by the client 
programmer in order to detect changes in protocol which don't cause changes in 
the binary interface.


Verifying Binary Compatibility

Compile the new library with its new interface.  Compile the old client, but 
with the _old_ interface.  Check that they work together.


Version Negotiation

The client and the library need to negotiate in order to determine whether they 
can work together, and possibly modify their behaviour accordingly 
(.req.fun.detect).  To do this there needs to be one function which is 
guaranteed to be present in all versions of the library which permits the 
negotiation, something like this:

  mps_bool_t mps_ver(mps_ver_t *actual_o, mps_ver_t oldest, mps_ver_t newest);

The client code calls this function before any others.  The "oldest" and 
"newest" parameters are the oldest and newest versions of the interface which 
the client can cope with.  The function returns Boolean true if the library can 
provide an interface in the range, and passes the actual version it intends to 
provide back in "*actual_o".



For example, if the client code can deal with interface versions 2 to 4, and 
the library can provide interface versions 3 to 9, then the library can return 
true and store 4 in *actual_o to indicate that it is going to provide version 4 
of the interface.  The client can adjust its behaviour accordingly.  Of course, 
the library _could_ provide an older version than it had to -- in this case 
version 3 -- but it seems unlikely that this would be desirable.

If there are no versions in common the library can return false and the client 
must deal with this in some way.  Most probably it will report an error and 
exit.


Providing Old Interfaces

The library can provide older versions of the interface to the client, in order 
to allow as many working combinations as possible (.attr.???).  A solution is 
to provide interface layers which provide the older interface and do the 
necessary conversion work to translate to the new.  There may be translations 
to do at any of the three levels:

  binary translation: change of linkage, structure, or type;
  protocol translation: change of meaning (could be complex);
  source translation: e.g. change of macro.

Binary compatibility can made trivial if only upwardly compatible changes are 
made to the binary interface and protocols.  An upwardly compatible change is 
defined as one which doesn't affect the existing stuff, so the new library will 
simply work with the old client.  Examples of such changes are: defining extra 
functions, defining new types, adding new fields to unions, adding new values 
to enumerations, etc.  This is a very common technique.

[More to say here -- richard]

