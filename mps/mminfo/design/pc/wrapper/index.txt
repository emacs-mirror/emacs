                         THE WRAPPER POOLCLASS
                           design.pc.wrapper
                            temporary design
                             drj 1996-04-23


INTRODUCTION:

The wrapper supports the collection of Dylan Format wrappers.  "Wrapper Pool" 
is a misnomer because any reasonable design can probably support other things 
as well.


OVERVIEW:

Wrappers cannot be managed along with ordinary dylan objects (in the AMC pool 
for example) because the Dylan Scanner needs to examine wrappers in order to 
scan objects.  The system as a whole is simplified if this can be done without 
having to worry about the wrappers being on protected pages.  Hence the need to 
have them managed in a separate pool (but not necessarily a separate class).


REQUIREMENTS:

.req.scan.annotate: any memory that the scanner needs to access in order to 
scan an object must be unprotected prior to commencing the scan.
.req.dylan.grey: whilst there are grey dylan objects and we are in the 
collector, all wrappers must be unprotected.
.req.wrapper.grey: grey wrappers still need to be scanned as wrappers contain 
references (the "user" (class) pointer at the moment, possibly more in 
future).  Grey wrappers must be protected (under a read barrier scheme) 
whenever the mutator is not suspended.  

wrappers-unprotected <= in-space && (\E grey dylan-objects)
gray-wrappers-protected <= out-space
Corollary: Assuming that there are always grey dylan objects (which isn't 
unreasonable), either there must be no grey wrappers when returning to the 
mutator, _or_ all wrappers must be unprotected on entering the collector.

.req.slow-motion: Wrappers are used in the DylanWorks runtime as keys in 
generic function dispatch hash-tables.  If these tables need to be rehashed a 
lot then it is likely to significantly degrade performance.  Wrappers should be 
moved as little as possible.
.req.few: It is unlikely that there will be more than about 1000 wrappers 
allocated in such a pool.


ANALYSIS:

.anal.seg.vulnerable: .idea.seg.vulnerable introduces a concept into the mpm 
that other pools will conceivably find useful.  The alternative 
(.idea.fix.scan) fails to capitalize on generalizing the concept, but may turn 
out to be faster.
.anal.separate-refs: This is esoteric, but potentially the most flexible 
solution.  The tracable slots of the wrappers can be protected in arbitrary 
fashion, the untracable portions cannot be protected, the scanner needs only to 
look at the tracable part.  Changing the format of the wrappers enatails 
changes to the DylanWorks runtime (not necessarily cheap), changing the format 
in this way (ie making objects discontiguous) entails further work in the 
allocation and format interface to cope with the concept (or perhaps not, 
perhaps it can be done by considering the wrapper actually as two objects).
.anal.slow-motion: dsm points out that if you rarely condemn wrappers then they 
will rarely move.  Hence using a non-moving policy may not be necessary (see 
also .idea.amc.hijack).
.anal.fix.scan: fix would need to create another ScanState to do the recursive 
scanning, and then appropriately update the pages refsets.

.anal.lo-unify: The optimization of lo not scanning the objects is 
significant.  It means that the pool doesn't need to locate the object 
boundaries until reclaim, at which point all the possible fixes have been made; 
ie the fixes have been maximally batched.  Modifications needed to make it 
scanning (which is essentially the difference between lo and wrap):
locate object boundaries when called on to scan a segment (or scan entire 
segment).  There are now two options: remember the object boundaries, or throw 
them away.

.anal.ms.bound-fill: this means that every object that is allocated gets 
skipped exactly once (assuming that subsequent scans used the remembered object 
boundaries to locate grey objects).


IDEAS:

.idea.seg.vulnerable:  associate a "vulnerability" with each segment.  A 
segment is vulnerable iff it cannot be protected.  The tracer will use this 
information to expedite the scanning of vulnerable segments that are grey 
before leaving the space.
.idea.vulnerable.prop: Vulnerability is just another "property".
.idea.fix.scan:  make this pool's fix immediately scan the relevant object.
.idea.mark-sweep: implement a mark and sweep pool (.req.slow-motion).
.idea.condemn-rare: don't condemn it very often (.req.few).
.idea.lo-unify: lo is a mark-and-sweep pool (.idea.mark-sweep).  It is possible 
that work and code could be shared.
.idea.amc.hijack: if idea.seg.vulnerable is used then a possible solution is to 
simply instantiate an AMC pool and use an appropriate buffer to allocate 
wrappers. (Possible performance penalties due to motion).
.idea.separate-refs: modify the wrappers' container format so that the 
reference slots (ie, the "user" pointer) are stored on a separate page from the 
rest of the wrapper (but obviously the location needs to be derived in some 
manner - eg w + 4096 (not very space efficient), or w & ~(8*4096-1) + 
((w&(8*4096-1))/32) (ie goto to first page in block of eight, and map words in 
that page to octo-words in the other 7) assuming octo-word aligned wrappers)
.idea.ms.bound-scan:  In a Mark-and-Sweep collector the scanner could remember 
the object boundaries then it wouldn't need to recompute them on every scan.  
How many times does a page get scanned on average?
.idea.ms.no-buffer: In a Mark-and-Sweep collector always go out-of-line for 
buffered allocation.  That way we can more easily deduce object boundaries.
.idea.ms.bound-fill:  Could skip the segment to find object boundaries when it 
"fills".


IMPLEMENTATION:

following changes need to be made:
wrap: new wrapper pool class.  Initially steal code from lo.  add scanning.  
allocation of vulnerable segments.  extra table for grey bits.
segments (mpmst.h arena*.c): need to add vulnerable flag
tracer: trace.c needs to be ensure grey vulnerable segments are scanned before 
returning to mutator
(or is this somehwere in SpacePoll? / ProtSync)

