                  DEPTH LAYOUT VIEW OF MEMORY WITH THE
                 LAYOUT BY DEPTH FROM A SELECTED POINT
                     design.product.tool.dpthlayout
                           incomplete design
                            sheep 1997-06-11


INTRODUCTION:

This document is intended as a way of thinking about possible ways that the 
tool might present information. The drawings are intended to be indicative of 
how the view might look in a window


OVERVIEW:

This is used to inspect an object in order to discover what child objects are 
being kept unnesserally. This could be used to understand if an object or 
collection of objects are being kept unnesserally and are candidates for the 
use of weak pointers. See the Dylan summary  for more information about this. 

Alternatively this view could be used to inspect memory layout with a view to 
bringing near by objects to together in the data cache.

The horizontal axis is depth too or from the selected pointer and the vertical 
axis is the location in memory space (the address).

.function. 
 
*Perminantly* transmitting data representing the relation of each object to 
another would be very expensive in terms of telemetry. To handle this a new 
event is proposed, the 'depth' event.  In the source the user places a function 
such as 

     mm_depthFromThisPointer( void *p , const char "Comment string"); 

The memory toolbox responds by generating a burst of telemetry representing the 
layout of all the objects point to that pointer (up too root objects) and all 
the child objects which are pointed to by that object. Glassbox (the tool) 
responds to the telemetry burst  by creating a new view ( the depth layout 
view). 

Each bar represents an object, the position on the vertical axis represents 
position in memory ( like the Pianokey/Ramview ) .  The height of the bar 
represents the size of the object.  the width of the bar is a constant, Each 
bar is aligned to a vertical axis, this axis represents depth from the source 
pointer. The source pointer is normally in the centre with the box. The left 
most bar is a most likely a root object. The right most bar is the child which 
is at greatest depth from the pointer. 

Backward pointers (lines) might have a separate representation for example a 
thin blue line.

.interaction. 

Selected a bar will display known information about the object ( allocation 
point, type, possibly lifetime). 

double  clicking would attempt to open the source file in the principle editor 
or the debugger.

Scrolling would be nessasry for deep systems or wide systems.

.Options.
 
When a child or root object is selected it might be nice to show how that 
object is connected to others in memory - this might be in blue lines to 
differentiate them from the original lines.

Compact - this keeps the order but lays the objects with out size or positional 
information, useful if there are a very large number of objects to inspect. 
There might be some convention for vector type / list  type objects - long 
lists would create very deep and therefore long charts. 







TESTING:

One way of testing these diagrams is to ask your self if the function of the 
chart was immediately obvious after looking at the diagram ? Could you think of 
a use for the view might you find this view useful. If you think of ways of 
improving the chart and adding more elements too it them again it might be more 
useful than one you cannot think of adding to.



TEXT:

Items in *likethis* are incorectly spelt but with out a spellchecking 
suggestion.

