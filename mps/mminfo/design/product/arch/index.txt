           DESIGN OF THE HARLEQUIN MEMORY MANAGEMENT PRODUCT
                          design.product.arch
                             incomplete doc
                           richard 1997-04-13

INTRODUCTION

.intro: This document is the top-level design of the Harlequin Memory 
Management Product.

.no-req: This design has not been systematically checked against product 
requirements, because requirements have not been generated for the product.  
Until this is done there is no guarantee that the product will succeed, beyond 
the intuition and experience of the designer.


Document History

.hist.0: First draft written by Richard Brooksby on 1997-04-13 from a 
hand-written summary presented to the Memory Management Group at 
meeting.general.1997-04-08, and also using analysis.product(0), 
design.product.doc.arch(0), and overview.mps.usage(0).

.hist.1: Richard Brooksby imported outline into Notes on 1997-04-14, added 
diagrams, and sections on the Manual Drop-in Interface (.soft.drop.manual), 
Automatic Drop-in Interface (.soft.drop.auto), and Convenience Interface 
(.soft.conv).

.hist.2: Richard Brooksby added sections about @@@@


DEFINITIONS

.def.product: The Harlequin Memory Management Product is referred to as "the 
Product" in this document, pending assignment of a name.

.def.mm: The Memory Manager, or MM, is that part of the software which forms 
part of the client's application, i.e. the interfaces, Memory Pool Manager, and 
Pool Classes.


SUMMARY

.summary: The Product is a tool which enables the developer to control the 
management of memory in his application in order to improve it.  The Product is 
very flexible, and so can help the developer meet a wide range of requirements, 
but is primarily targetted at optimizing performance (in both time and space), 
and at reducing the cost of development and maintenance of the application.

.summary.blurb: This is quoted from Richard's draft introductory blurb:

  - The product is a software component which will help you to deliver better 
software with less effort.

  - The product is a memory manager which works behind the scenes to help your 
application make more effective use of its memory resources, giving higher 
performance and eliminating whole classes of memory-related errors.

  - The product is designed to give you an advantage whether you spend a single 
day with it or devote more time to using its sophisticated features to tune 
your application.  

  - The product should provide a return on your investment at every stage.

  - Use the product in your application and you will deliver higher quality 
software sooner.

.summary.quote:
  "The product is a set of documentation along with some software which
   implements it." -- Richard Brooksby, after Arthur Norman.


PRODUCT OVERVIEW

.over: This is a brief overview of the parts of the Product.  The parts are 
covered in detail in the following sections.

  .over.soft: Software: libraries, tools, source code, examples

  .over.doc: Documentation:
    user guide, library reference, pool class catalog, tool reference,
    installation guide, reference card, book: "Programming Efficiently
    with Garbage Collection" (see project.book).

  .over.mkt: Marketing:
    Multimedia presentation, utility demos, detailed examples, downloadable
    demos, CD-ROM demo, goodies.

  .over.supp: Support:
    on-line solutions database, product evolution database.

  .over.mfg: Manufacture:
    printed manuals, CD-ROM media, box, goodies, etc.

  .over.comp: Relationship to competetive products:
    complementing Purify, competing with SmartHeap, etc.


LEVELS OF USE

.level: The purpose of levels of use is to ensure that the client benefits from 
depening levels of involvement with the product.  The idea is to guarantee 
return on invested effort at each level of sophistication, so that a user can 
gain benefit from the system in one afternoon, one week, one month, or one 
year.  Each client will be operating in different circumstances, and will trade 
off different amounts of effort invested in using the product against the 
benefits gained.  The levels are therefore arranged by increasing amounts of 
effort.

.level.1: Drop-in and Evaluation.  This is the critical level of use.  The 
client has just obtained the product for evaluation, either by purchasing it, 
downloading it, or obtaining a demo version.  The client might not even be a 
developer, but a development manager or journalist.  The product must 
demonstrate tangible benefit within just a few hours of installation.

.level.2: Using Pool Classes.

.level.3: Measurement and Optimization.

.level.4: Consultancy and custom software.

.level.source: Levels are an implementation of the "levels of use" solution 
described in analysis.product.sol.levels.


DOCUMENTATION

.doc: For full details of the documentation see design.product.doc.arch.


Quick Start / Installation Guide / Release Notes

.doc.start: From design.product.doc.arch(0).doc-set.installation: "This 
document ... will detail the media and contents of the release and the hardware 
and software requirements; it will also explain how to extract and install the 
MM Product, how to configure the environment and test the installation, if 
applicable, and how to address any licensing issues, if applicable."


Release Notes

.doc.relnotes: From design.product.doc.arch(0).doc-set.relnotes: "This document 
will ... contain any last-minute information on the software or documentation, 
as well as any quality issues that the Quartet may specify for inclusion."


User Guide

.doc.guide: From design.product.doc.arch(0).doc-set.user-guide: "This document 
will explain how to obtain ROI at various levels of time investment; how to use 
the MM Product, especially combinations of protocols; and how to deal with 
problems encountered while using the MM Product."


Reference Manuals

.doc.ref: One or two reference manuals are produced, covering the libraries and 
tools.  .doc.ref.libs: From design.product.doc.arch(0).doc-set.ref-man: "This 
document will contain complete reference material for the MM Product's 
concepts, protocols, and symbols."  .doc.ref.tools: From 
design.product.doc.arch(0).doc-set.tool-ref: "This document will contain 
complete reference material for the MM Product's graphical tool."


Pool Class Catalog

.doc.cat: From design.product.doc.arch(0).doc-set.cat: "This document will 
contain complete descriptions of all pool classes, including tables of features 
by use level."


Book

.doc.book: The Memory Management Group's Book Project (project.book) is to 
produce a book with a working title of "Programming Effectively with Garbage 
Collection".  This book is designed to be a useful enhancement of the Product, 
though it is not limited to it.  The book is included in the product.


On-line Documentation

.doc.on-line: On-line versions of all documentation are available on the 
distribution media in HTML, PDF, and plain text formats.


SOFTWARE


Description

.soft.desc: The software divides into two categories: the Memory Manager (MM) 
and the Tools.

.soft.desc.mm: The MM is the software which ships with the client program and 
forms part of the application.  .soft.desc.mm.parts: The MM consists of the 
Memory Pool Manager (MPM), Pool Classes, and Interfaces, described below (see 
.fig.mps).  .soft.desc.mm.form: The MM is in the form of a number of linkable 
libraries, in the format apropriate for the target platform.

.fig.mps: How the client interfaces to the Memory Pool Manager and Pool Classes.


 - design.product.arch.fig.mps 

.soft.desc.tools: The Tools are programs which enable the developer to adjust 
the client program's use of the MM in order to meet the application's 
requirements (see .fig.tools).  .soft.desc.tools.form: The Tools will be in the 
form of programs designed for convenient use by developers: command-line 
programs, and tools with graphical display where appropriate.

.fig.feedback: How the developer makes use of the Analysis Tool to improve the 
application.


 - design.product.arch.fig.feedbac 


Graphical Measurement and Analysis Tool

.soft.gmat: The Graphical Measurement and Analysis Tool (GMAT) is a program 
which collects information emitted by the Memory Manager and provides decoding, 
display, storage, export, and analysis of the data.  The purpose of the tool is 
to provide information to the developer so that he can adjusting the client 
program's use of the Memory Manager in order to meet the application's 
requirements.  The GMAT must provide information which allows the developer to 
understand and correct the causes of undesirable performance.

.soft.gmat.source: The GMAT is an implementation of the "analysis by feedback" 
solution described in analysis.product.sol.feedback.


Allocation Analyzer

.soft.aa: The Allocation Analyzer is a tool which analyzes measurements emitted 
by the MPS, looking for common patterns of allocation, and suggesting changes 
which can be made to the client program in order to improve it.  .soft.aa.fun: 
Its main function is to emit the source code for an interface to the MPS which, 
when compiled with the client application source, will improve performance by 
handling the client's specilized allocation patterns efficiently (based on 
"CustoMalloc" by Grunwald and Zorn, see paper.grun92).

.soft.aa.type: The Allocation Analyzer is intended to give an almost guaranteed 
improvement application performance at usage levels 1 (see .level.1), in order 
to ensure acceptance of the product.  It must therefore be simple, quick, and 
easy to use, with a simple user interface, possibly even just a command-line.  
.soft.aa.gmat: It's quite possible the functionality of the Allocation Analyzer 
will be duplicated in the measurement and analysis tool (.soft.gmat), or even 
just be a special mode of that tool.

.soft.aa.source: The Allocation Analyzer is an implementation of the "size 
class analysis" solution described in analysis.product.sol.sca and of the 
"analysis by feedback" solution described in analysis.product.sol.feedback.


Manual Drop-in Interface

.soft.drop.manual: The Manual Drop-in Interface is an implementation of the 
standard memory allocator of the client language in terms of the Flexible 
Interface (.soft.if.flex).  In other words, a "malloc replacement" for C and a 
"new/delete replacement" for C++.  The interface is "manual" because it 
implements a manual memory management policy (without GC).  Compare with 
.soft.drop.auto.

.soft.drop.manual.just: This interface exists in order to meet req.product.fun.malloc, 
req.product.fun.new, and req.product.fun.man.man.  To some extent, the 
existence of a drop-in interface also meets req.product.attr.mkt.impact and is 
necessary for req.product.attr.mkt.eval.*.

.fig.drop.manual: How the Manual Drop-in Interface fits between the client and 
the Flexible Interface.

 - design.product.arch.fig.drop.ma 

.soft.drop.manual.goal: The purpose of the interface is to allow the developer 
to deploy the MPS in his application quickly and easily, without any need for 
source code modification (.level.1).  He can then proceed to deeper levels of 
involvement (.level) incrementally, if necessary.  Thus, the interface 
contributes to req.product.attr.mkt.impact ("desk impact") and 
req.product.attr.mkt.eval.

.soft.drop.manual.source: The source code of the Manual Drop-in Interface is 
shipped with the product (.soft.source.drop.manual):

  .soft.drop.manual.source.trans: to make the transition from .level.1 to 
.level.2 and beyond as easy as possible, and

  .soft.drop.manual.source.doc: to provide additional documentation of the MPS 
C Interface (.soft.if.flex).


Automatic Drop-in Interface

.soft.drop.auto: The Automatic Drop-in Interface is an implementation of the 
standard memory allocator of the client language in terms of the Flexible 
Interface (.soft.if.flex).  In other words, a "malloc replacement" for C and a 
"new/delete replacement" for C++.  The interface is "automatic" because it 
implements an automatic memory management policy (garbage collector).

.soft.drop.auto.just: This interface exists in order to meet 
req.product.fun.malloc, req.product.fun.new, and req.product.fun.man.auto.  To 
some extent, the existence of a drop-in interface also meets 
req.product.attr.mkt.impact and is necessary for req.product.attr.mkt.eval.*.

.fig.drop.auto: How the Automatic Drop-in Interface fits between the client and 
the Flexible Interface.

 - design.product.arch.fig.drop.au 

.soft.drop.auto.purpose: The purpose of this interface is to provide garbage 
collection for C and C++ with minimum integration effort.  It may well be 
possible to make do this without modification to his code.  Thus, the interface 
contributes to req.product.attr.mkt.impact ("desk impact") and 
req.product.attr.mkt.eval.

.soft.drop.auto.comp: This puts the Product in competition with Hans Boehm's GC 
and Geodesic's Great Circle (analysis.product.comp.prod.gc).

.soft.drop.auto.quote:
  "The most loudly proclaimed fundamental weakness of C++ these days is 
  the absence of automatic garbage collection." -- Bjarne Stroustrup, the
  inventor of C++, Letter to C++ standards committee, May 27, 1996 


Convenience Interface

.soft.conv: The Convenience Interface is a simpified interface to the MM which 
sits between the client and the Flexible Interface (.soft.if.flex).

.fig.conv: How the Convenience Interface fits between the client and the 
Flexible Interface.

 - design.product.arch.fig.conv 

.soft.conv.goal: The purpose of the Convenience Interface is to provide the 
developer with a simplified interface to the MM, to make use of the MM an 
easier step from one of the drop-in interfaces (.soft.if.drop.manual, 
.soft.if.drop.auto).  .soft.conv.flex: The Convenience Interface is less 
flexible than the full Flexible Interface, but requires fewer modifications to 
the application source code.

.soft.conv.mixed: Use of the Convenience Interface can be mixed with use of the 
Flexible Interface (with caution) and can therefore support multiple memory 
management policies (req.product.fun.man.mixed).

.soft.conv.source: The source code of the Convenience Interface is shipped with 
the Product (see .soft.source.conv) for the same reasons as the Manual Drop-in 
Source is shipped -- see .soft.drop.manual.source.  .soft.conv.example: In some 
ways, the Convenience Interface can be seen a set of examples of typical use of 
the Flexible Interface.


Flexible Interface

.soft.if.flex: The Flexible Interface is the full interface to the MPM, 
offering full functionality and the ability to mix and match memory management 
policies (req.product.fun.man.mixed).

.soft.if.flex.features: Key features of the Flexible Interface are:

  .soft.if.flex.pools: Multiple co-operating instantiations of memory pools 
with a variety of manual or automatic management policies.

  .soft.if.flex.arenas: Multiple instantiations of the memory manager.

  .soft.if.flex.alloc: Fast in-line allocation protocols.

  .soft.if.flex.check: Strong consistency checking with control over assertion 
failure action.

[What about control over strategic behaviour of the policies?  richard 
1997-06-06]

.soft.if.flex.just: This interface exists in order to support .soft.drop.man 
and soft.drop.auto, and to meet req.product.fun.man.mixed.  It also meets 
req.product.attr.flex.


Memory Pool Manager Libraries

.soft.lib.mpm:


Pool Class Libraries

.soft.lib.class:

  - manual variable (MV)
  - manual fixed (MF)
  - manual allocate-only (MA)
  - automatic conservative (AC)
  - automatic mostly copying (AMC)
  - automatic leaf only (ALO)
  - nugatory (N)

[Stacks?  AF?]


Library Varieties

.soft.var:

  - optimized for release (variety.ro)
  - full development (variety.df)


Library Platforms

.soft.pf:

  - Windows 95, Intel
  - Windows NT, Intel and DEC Alpha
  - SunOS, SPARC
  - Silicon Graphics, MIPS
  - OSF/1, DEC Alpha
  - HP/UX, Snake?
  - Not Macintosh


Plinth Interface

.soft.if.plinth:

.fig.plinth: How the Plinth interfaces the Memory Manager to the operating 
system.

 - design.product.arch.fig.plinth 


Source Code

.soft.source:

  - ANSI based plinth
  - Win32 based plinth
  - convenience interface
  - manual drop-in interface
  - parts of the conservative collector
  - examples (see documentation)


MARKETING

.mkt:


Multimedia Presentation

.mkt.pres:


Utility Demonstrations

.mkt.util:


Detailed Examples

.mkt.eg:


Downloadable Demos and Demo CD-ROM

.mkt.demo:


Goodies

.mkt.goodies: Baseball cap, T-shirt, mouse mat, etc.  Very useful for developer 
buy-in and loyalty.  (See CodeWarrior's "Geekwear" catalog.)


COMPETITION

.comp: This section describes how the product is designed in relation to 
competetive products such as Purify, SmartHeap, etc.

[Need to write about how we will complement Purify 
(req.product.fun.mkt.purify.*) and compete with SmartHeap 
(req.product.fun.mkt.smart-heap.*) and Great Circle 
(req.product.fun.mkt.great-circle.*).  richard 1997-06-04]

ATTACHMENTS
   "design.product.arch.fig.conv"
   "design.product.arch.fig.drop.au"
   "design.product.arch.fig.drop.ma"
   "design.product.arch.fig.feedbac"
   "design.product.arch.fig.mps"
   "design.product.arch.fig.plinth"

