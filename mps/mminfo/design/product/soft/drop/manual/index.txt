                 DESIGN OF THE MANUAL DROP-IN INTERFACE
                    design.product.soft.drop.manual
                              draft design
                       Pekka P Pirinen 1997-06-30


INTRODUCTION:

This is the design for the Manual Drop-in Interface (a part of the Harlequin 
Memory Management Product).

.readership: MM developers and the product manager.


Document History

.hist.0: First draft written by Pekka P. Pirinen 1997-06-30, only covering the 
ANSI-compatible version of the interface, based on design.product.arch(2), 
req.product(2), and standard.ansic.  Amended for C++ and various other things 
1997-07-09, based on book.stroustrup91.  Amended 1997-08-18 to reflect the 
latest version of C++, based on paper.iso96a.


OVERVIEW:

The drop-in interface replaces the standard C/C++ interfaces to memory 
management with code that uses the MPS.  It is intended as the first and 
easiest level of using the product.  The role of the interface within the 
product is described in design.product.arch.soft.drop.manual.* and 
design.product.arch.fig.drop.manual.


REQUIREMENTS:

.req.attr.drop-in: req.product.fun.malloc implies that users must be able to 
use the interface without any modification to their C source code.

.req.fun.ansi-c: req.product.dc.env.ansi-c and req.product.attr.use.level.1 
imply that we must provide an implementation of the interface whose behaviour 
satisfies the ANSI standard.

.req.fun.platform.c: req.product.dc.env.c and req.product.dc.plat.* imply that 
we must provide an implementation of the interface whose behaviour matches the 
C library for each supported platform.

.req.fun.platform.cpp: req.product.dc.env.cpp and req.product.dc.plat.* imply 
that we must provide an interface whose behaviour matches the C++ library for 
each supported platform.

.req.fun.source: The interface is supplied to customers in source as well as 
object form (design.product.arch.soft.drop.manual.source) as an example of how 
to use the MPS.

.req.fun.separate: req.product.attr.use.level.1.partial implies that the user 
must be able to install the interface without recompiling the whole application.

.req.attr.performance: req.product.attr.mkt.eval requires that our code is 
faster than the C library malloc.  req.product.attr.perform.benchmarks.* [@@@@ 
This needs to be worked out.  Pekka 1997-08-18]

.req.fun.aa: design.product.arch.soft.aa describes an Allocation Analyser, 
which performs CustomAlloc-style tuning on the allocator.


ARCHITECTURE:

.files.configuration: .sol.files.configurable, with the .c file for each 
platform defining the function mps_malloc_behaviour() to return a value 
describing the behaviour of that platform.  This function will be called once, 
during initialisation.  .files.headers: One header file to describe the 
configuration interface, but nothing for the allocation interface, the standard 
headers (stdlib.h e.a.) must be used for that.

.files.linking: Instructions will be provided for linking on each platform, in 
order to ensure that the interface will override the system-supplied functions 
(note that libraries can re-export imports).  The user is advised to verify 
success by linking with a debugging variety and looking at the debugging 
output.  .files.linking.justify: .req.attr.drop-in and 
req.product.attr.use.level.1.

.arch.size: The C interface needs to keep track of the size of each block in 
order to deallocate it (mps_free).  The size will be stored in a header in 
front of the block allocated, in a size_t field.

.arch.init: MPS initialisation happens on the first allocation (the global 
variable storing the initialisation state is not thread-safe, but it's unlikely 
that multiple threads could start before the first allocation).

.arch.finish: The arena and the pool created for the interface will not be 
destroyed, contrary to our own recommendations, because it is impossible to do 
so safely without the co-operation of the C library.  The documentation will 
explain this (actually, the backup allocator would make it safe, but that's not 
what the user needs to know).


ANALYSIS:

[This section intentionally left blank.  Pekka]


IDEAS:

Pool Class

.sol.pool-class.mv: The interface shall be implemented using the MV pool class, 
with the parameters 65536, 32, and 65536.

.anal.pool-class.mv: That's the closest match to standard C behaviour 
(req.product.fun.malloc).  [This needs to be re-examined later, especially to 
support .req.fun.aa.  Pekka 1997-06-30]


Telemetry

.sol.telemetry: We need to do something to make event logging work reliably, 
see mail.pekka.1997-07-04.15-34.  design.mps.telemetry.req.pm guarantees that 
the event log will be flushed.


Recursion

.sol.recursion: We need to do something to cope with malloc being called 
recursively without going into an infinite loop, see 
mail.pekka.1997-07-06.16-37.  Note that this could really happen through any 
call to the C library or by a signal handler calling malloc, but is likeliest 
to happen in the file calls (used by the logging functions).

.sol.recursion.kick-start: When initializing, turn event logging off, and 
output a banner into the log, flush the log, and hope that this did all the 
allocation that C I/O library needed for the event log.  The banner could have 
some useful information in it.

.sol.recursion.fail.malloc: malloc checks for being called recursively, and 
fails if that happens.

.sol.recursion.fail.mps_alloc: mps_alloc checks for being called recursively, 
and fails if that happens.

.sol.recursion.fail.telemetry: The telemetry interfaces check for being called 
recursively, and don't output anything if that happens.

.sol.recursion.double-buffering: While the event log is being flushed to disk, 
new output is stored in a second buffer, not the one that's being written.  If 
that one becomes full before the first one has been written, just discard the 
overflow.  This could be extended to N buffers used in rotation, but that's 
overkill.

.sol.recursion.ann-turnoff: malloc checks for being called recursively, and 
turns off telemetry if that happens.  If this doesn't stop the recursion, fail 
the allocation request.

.sol.recursion.backup: If mps_alloc is called recursively, it uses a separate 
backup allocator which is guaranteed not to call malloc (see 
request.product.170453).

.anal.recursion: .sol.recursion.kick-start and the other solutions 
concentrating on telemetry rely on implementation details of the C library.  
Not good.  .sol.recursion.fail.malloc is nice, because it solves the problem 
created by the drop-in interface in the drop-in interface.  However, failure to 
allocate inside the C library could just result in the program aborting or some 
other unwanted consequence.  The same applies to 
.sol.recursion.fail.mps_alloc.  .sol.recursion.backup will be useful for other 
things as well, and doesn't need all the new interface that solutions 
concentrating on event logging do, so that's what we'll do.


File Organization

.sol.files: .req.fun.separate, .req.fun.platform, and guide.impl.c.pp.ifdef 
imply that users will install the interface and choose among the different 
behaviours implemented by selecting a set of files to link with their 
application.

.sol.files.separate: We provide one file that satisfies .req.fun.ansi-c, and 
one for each platform that satisfies .req.fun.platform.c.  Likewise for C++, 
one file that implements standard new and delete, plus one for each platform 
that satisfies .req.fun.platfrom.cpp.

.sol.files.configurable: We provide a core file which implements ANSI C 
functionality plus variations thereof and is parameterizable, and one file per 
platform which identifies the point in the parameterized behaviour that should 
be used, and also implements any platform-specific extensions.  For C++, 
another core file plus a file per platform.

.anal.files.separate: Too much code duplication.  .anal.files.separate.cpp: 
Even though there isn't a requirement for a "standard" C++ interface, and we 
know of no current compiler that would support one, it's a good starting point.

.anal.files.configurable: Although we'll deliver it as dynamically 
configurable, it could easily be converted to compile-time configurable, by 
turning the behaviour variable into a constant.  .anal.files.configurable.cpp: 
The platform files could be shared between C and C++, because we can use 
__cplusplus to guard any C++-specific parts.  If we supply binaries, they would 
always contain the C++ parts, so we have to verify the overhead from this is 
not too large.


Platform-specific Extensions

.sol.extensions: Implement platform-specific interfaces to memory allocation, 
where it's simple, make sure the user will notice if the application tries to 
call the missing ones, preferably at compile time. [The exact list extensions 
for each platform needs to be decided on.  Pekka 1997-08-18]

.anal.extensions: I interpret req.product.plat.* as saying we want to implement 
malloc, free, calloc, and realloc, not every fancy debugging feature or complex 
optimization setting.  It doesn't make any sense for us to expend effort to 
duplicate other people's designs.  We'd rather offer the same features through 
MPS interfaces (req.product.attr.adapta.target), and provide documentation to 
guide users to them (req.product.attr.use.level.2or3).  Notifying the user 
about the attempted uses of such extensions will prevent mishaps, and can 
easily be suppressed by the users, since we provide source code.


The Allocation Analyser

.sol.aa: [The tool will have code to analyse the event logs, but we still need 
to figure out how to feed that back into the allocator.  Pekka 1997-08-18]



IMPLEMENTATION:

.fun.malloc: For an allocation of size 0, return NULL in the ANSI version; for 
other platforms, match the behaviour of the native malloc as described in 
analysis.realloc(0).  Other behaviour as required by the standard.

.fun.free: Double free invokes assert (not mps_assert).  Otherwise like 
mps_free.

.fun.calloc: Care must be taken in checking the multiplication and returning 
NULL on overflow.  Otherwise like malloc.

.fun.realloc: Unless the size is unchanged, we will always allocate a new block 
and copy.  [Extending the MPS interface to support changing the size of an 
allocated block will be investigated.  Pekka 1997-06-30]  For an allocation of 
size 0 (meaning free the block), return NULL in the ANSI version; for other 
platforms, match the behaviour of the native realloc as described in 
analysis.realloc(0).  Freeing behaviour like free.  For a NULL ptr argument, in 
the ANSI version do as malloc does with the same size argument; for other 
platforms, match the behaviour of the native realloc.  Other behaviour as 
required by the standard -- note that this means that if the allocation fails, 
realloc will return NULL.

.macro: On each platform, check whether malloc, free, calloc or realloc are 
macros, and if so, write instructions for getting around this.

.operator.new: First attempts to allocate the requested storage using malloc.  
If the attempt is successful, return a pointer to the allocated storage.  
Otherwise, if the stored new handler pointer is null, throw an exception or, in 
the nothrow version, return 0.  Otherwise, call the designated handler; if it 
returns, try again.  On some platforms, new never throws an exception, and on 
others (such as platform.w3i3mv), the failure behaviour can be controlled in 
detail.  .operator.new.array: operator new[] will work exactly like operator 
new.

.fun.set-new-handler: (set_new_handler) Set the new handler to be the argument, 
and return the old value.

.operator.delete: Just delegate to free.  Note that this means that no 
exceptions are ever thrown.  .operator.new.array: operator delete[] will work 
exactly like operator delete.


TESTING:

.test.ansi-c.systematic: To test .req.attr.drop-in and .req.fun.ansi-c, there 
will be a test that calls all the ANSI C interfaces, with a range of different 
arguments to get complete path and boundary case coverage.  For partial testing 
of .req.fun.platform.c, this test will be run for all sufficiently 
ANSI-compliant platforms as well.

.test.cpp.systematic: To test .req.attr.drop-in and .req.fun.platform.cpp, 
there will be a test that creates a number of objects and arrays, in all the 
different ways that C++ offers.

.test.platform: Platform-specific extensions will be tested as well.

.test.sample-application: To test .req.attr.drop-in and .req.fun.separate, we 
will choose a number of sample applications, link the interface in, and 
stress-test the application [How to find suitable test cases?  What would 
constitute success?].  perl, ghostscript, and gnumake are used in 
paper.grun92(1), and we already have copies.

.test.smartheap: To test req.product.attr.perform.benchmarks.SmartHeap, try to 
duplicate MicroQuill's tests for SmartHeap and compare.  The Windows tests are 
described thus: "This benchmark test program randomly calls operators new and 
delete (in a ratio of 3:1) to crate object that randomly vary in size from 8 to 
128 bytes until the heap reaches the specified size.  The program then deletes 
all the objects."  They also note that it makes a lot of difference if the 
program gets larger than the available RAM and "goes virtual".  Unix tests are 
the same, except the maximum size is 100 bytes.


TEXT:

.external: Because of .req.fun.source, the implementation will not be written 
following MPS rules and conventions, only generic C ones.

