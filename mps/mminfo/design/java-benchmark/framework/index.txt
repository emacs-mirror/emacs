               THE DESIGN OF THE JAVA-BENCHMARK FRAMEWORK
                    design.java-benchmark.framework
                           incomplete design
                             lth 1998-09-15


INTRODUCTION:

This is the design for the common framework for the Java benchmark suite.

.readership: MM group members.

.source: analysis.java-benchmark(1), design.java-benchmark.arch(3).


OVERVIEW:

The purpose of the framework is to reduce the amount of code that needs to be 
implemented for each benchmark, and also to allow the benchmarks to be 
implemented independently of whether they are run as applets or applications 
and whether implementation-specific measurement functionality is present or 
not.


REQUIREMENTS:

Critical requirements

.req.program-type: The benchmark programs must be able to run both as applets 
and stand-alone programs.

.req.input: The framework must provide a mechanism whereby the benchmark can 
read and parse parameters.

.req.output: The framework must provide a mechanism whereby the benchmark can 
print system identification, results, and other messages.

.req.gc: The framework must provide a mechanism whereby the benchmark can force 
a garbage collection (if it is possible to force a GC in the implementation).

.req.use-object: The framework must provide a mechanism whereby synthetic 
benchmarks can minimize the likelihood of a compiler optimizing away an 
allocation.

.req.library: The framework must serve as a repository for common but 
incidental utility functions (not specified in this design).

.req.gui-independent: The framework must allow benchmark programs to be 
implemented without having to know whether they are running as applets or 
stand-alone applications.

.req.solo: The framework must allow benchmarks to be run on systems that may 
not be connected to a network or may not have the ability to run a WWW server.

.req.portable: The framework must be able to run on all Java systems.

.req.adaptable: The framework must allow nonportable or implementation-specific 
measuring mechanisms to be used when and if appropriate, and with a minimum of 
hassle; in particular, without requiring any change to the benchmark programs.  

.req.adaptable.detection: The presence or absence of implementation-specific 
code must be detectable at run-time.

.req.measure: The framework must provide mechanisms whereby total heap space, 
heap space in use, and running time can be measured.


ARCHITECTURE:

Program structure

.arch.structure: Each benchmark is split into two parts: a core and drivers.  
There is one core, and one driver program for each run-time environment 
(applet, standalone).

.arch.output-interface: There is an interface Messenger that provides 
implementation-independent methods for simple program output; see .arch.output.

.arch.util-classes: There are two utility classes, IntBox and BoolBox, which 
are mutable objects that hold an int and a boolean respectively.

.arch.core: Each benchmark core subclasses the framework class JavaBenchmark 
and implements two public methods.
.arch.core.constructor: The core class must have a benchmark-specific 
constructor; the constructor must accept a Messenger and benchmark-specific 
parameters, and call JavaBenchmark's constructor; see .arch.framework.init.  
.arch.core.running: The core class must override the run() method; see 
.arch.framework.run.

.arch.standalone: Each standalone driver subclasses the framework class 
BenchmarkDriver and implements the standard Java main method.  

.arch.standalone.running: If the class of the benchmark core is C, then the 
driver must call C.run().

.arch.standalone.methods: Class BenchmarkDriver provides several convenience 
methods and variables.  Assume D is an instance of BenchmarkDriver.

.arch.standalone.messenger: The variable D.theMessenger holds an instance of a 
class that implements the Messenger interface.

.arch.standalone.fail: D.fail( msg ) prints the message and terminates the 
program.

.arch.standalone.int-arg: D.parse_arg( argv, i, arg, val ) returns true if 
argv[i] is equal to the string arg and argv[i+1] can be interpreted as an 
integer; the integer value is stored in the IntBox object val.

.arch.standalone.bool-arg: D.parse_arg( argv, i, arg, val ) returns true if 
argv[i] is equal to the string arg; a true value is stored in the BoolBox 
object val.

.arch.applet: Each applet driver subclasses the framework class BenchmarkApplet 
and implements the abstract method run().

.arch.applet.running: If the applet driver class is C and the benchmark core 
class is D, then C.run() must call D.run().

.arch.applet.methods: BenchmarkApplet provides two methods. Assume A is an 
instance of BenchmarkApplet.

.arch.applet.parameter: A.get_scaling_parameter() returns the benchmark 
parameter from an input box in the applet viewer or browser.

.arch.applet.needs-parameter: A.needs_parameter() is called by the 
BenchmarkApplet implementation to determine if a parameter input box should be 
presented to the user; normally, it returns true.  The applet driver may 
override this to return false if the benchmark in question takes no parameters.


Framework structure

.arch.framework.common-core: All benchmark core classes subclass the framework 
class JavaBenchmark.  Assume J is an instance of JavaBenchmark.  

.arch.framework.init: J.JavaBenchmark( revision, tag, messenger ) initializes 
the framework.  Revision is an integer.  Tag is a string. Messenger is an 
implementation of the Messenger interface.

.arch.framework.run: J.run() is an abstract class that will be called to start 
the benchmark.


Input and output

.arch.output: For the output structure, there is an interface Messenger that 
exports two methods.

.arch.output.msg: void msg( String ) prints the string and a newline on the 
output medium.

.arch.output.done: void done() performs cleanup actions.

.arch.output.standalone: The class StringMessenger implements Messenger and 
prints its output on standard output.

.arch.output.applet: The class TextAreaMessenger implements Messenger and 
prints its output on a scrollable text area (java.awt.TextArea) in the applet 
viewer or browser window.

.arch.input.standalone: Standalone programs read parameter values from the 
command line; this is particularly reasonable because the notion of "command 
line" is built-in to Java, and Java systems on operating systems that do not 
have a command line sometimes provide a mechanism whereby a command line can be 
entered anyway.

.arch.input.applet: Applets read parameter values from an input box in the 
applet viewer or browser.


Measurements

.arch.framework.measurements: Instances of the Measurements class provide 
measurement services (currently only for elapsed time).  Assume M is an 
instance of Measurements.

.arch.framework.measurements.start: M.start() resets and starts the timer.
.arch.framework.measurements.stop: M.stop() stops the timer.
.arch.framework.measurements.restart: M.restart() restarts the timer  without 
resetting it.

.arch.framework.results: Instances of the Result class hold measurement 
results.  If R is an instance of Result, then the field R.time holds a time 
measurement (in milliseconds), and the fields R.used and R.total hold space 
measurements (in bytes).

.arch.framework.results.array: Class JavaBenchmark provides a utility function 
that creates a two-dimensional array of Result instances (with all fields set 
to 0).  Assume J is an instance of JavaBenchmark.

.arch.framework.results.array.init: J.initialize_results( a, b ), where a and b 
are positive ints, will return a new a-by-b array of Result instances.

.arch.framework.measurements: Class JavaBenchmark has methods that measure 
current resource consumption. Assume J is an instance of JavaBenchmark.

.arch.framework.measurements.total-mem: J.totalMemory() returns the Java 
system's total memory available.

.arch.framework.measurements.total-vm: If implementation-specific measurement 
code is installed, then J.totalVirtualMemory() returns the process's virtual 
memory size; otherwise, -1 is returned.

.arch.framework.measurements.free-mem: J.freeMemory() returns the Java systems' 
free memory available.

.arch.framework.measurements.used-mem: J.usedMemory() returns the amount of 
memory used by the Java heap.


Reporting

.arch.framework.reporting: Assume J is an instance of JavaBenchmark.

.arch.framework.reporting.value: If s is a String and t is of a type T from the 
set { bool, int, long, double, String }, then J.report( s, t ) prints a line 
containing s, whitespace, and t.

.arch.framework.reporting.no-value: If s is a String, then J.report( s ) prints 
a lint containing s.

.arch.framework.reporting.all-results: If ss is an array of Strings, and rs is 
is a two-dimensional array of Results, and the length of ss is equal to the 
number of rows in rs, then J.report( ss, rs ) prints one line for each field of 
the Result for each row of rs, with the tag taken from ss and the array of 
values taken from rs.

.arch.framework.reporting.some-results: If ss is an array of Strings, and rs is 
is a two-dimensional array of Results, and the length of ss is equal to the 
number of rows in rs, and bits is a bitstring constructed from the 
JavaBenchmark.RES_* values (see .arch.token.*), then J.report( ss, rs, bits ) 
prints one line for each field of the Result selected by bits, for each row of 
rs, with the tag taken from ss and the array of values taken from rs.

.arch.framework.reporting.inf: If s is a string, then J.inform( s ) prints s 
with a ".inf" tag.

.arch.framework.reporting.failure: If s is a string, then J.notifyFailure( s ) 
prints s with a ".fail" tag.

.arch.framework.reporting.done: If l is a long int representing a measured heap 
size, then J.done() prints a line with the .done tag and overall run-time 
measurement, and J.done( l ) prints a line with the .done tag, overall run-time 
measurement, and l as the value of the peak-heap field of that line.


Constants and tokens

.arch.token.rep-time: The bit string JavaBenchmark.REP_TIME requests reporting 
of the time field of the Result structure, in applicable methods.

.arch.token.rep-heap: The bit string JavaBenchmark.REP_HEAP requests reporting 
of the memory usage fields of the Result structure, in applicable methods.

.arch.token.rep-all: The bit string JavaBenchmark.REP_ALL requests reporting of 
all fields of the Result structure, in applicable methods.

.arch.token.no-value: The integer JavaBenchmark.NO_VALUE is a value that is not 
a valid parameter value; it may be used to signal the absence of a parameter.


Adaptability

.arch.adapt: Adaptability is provided in the form of an interface called 
Probe.  The methods in the interface provide access to non-standard measurement 
functionality.  The methods exported by Probe are left unspecified for the time 
being.


Miscellaneous

.arch.framework.optimization-avoidance: If J is an instance of JavaBenchmark 
and o is any Object reference, then J.useObject( o ) manipulates the object 
reference in such a way that the compiler may not optimize away the computation.

.arch.framework.gc: If J is an instance of JavaBenchmark, then J.forceGC( x ) 
attempts to force a full garbage collection; if x is true, then memory 
statistics are printed before and after the garbage collection.




ANALYSIS:

.anal.conditional-compilation: Generally, it's possible to use an external 
preprocessor with Java to effect conditional compilation.
.anal.conditional-compilation.disadvantages: There are several disadvantages to 
this approach.  First, a common preprocessor cannot be assumed to be available 
everywhere, and so must be written.  Second, it may not be possible on all Java 
development systems to run the preprocessor automatically before every 
compilation, so it may have to be run manually.
.anal.conditional-compilation.unsuitable: Conditional compilation does not seem 
to be a suitable option for a "portable" benchmark suite.

.anal.input.standalone: Command line input and input from standard input are 
flexible and convenient but is not a part of the standard user interface on all 
platforms; for example, the Apple Macintosh UI does not have a command line.  
File input is less flexible and convenient as well as more portable; however, 
the file to read input from must be encoded in the Java program somehow, and 
file names and path names are not portable.  Dialog box input is not portable 
at all as it requires a GUI.

.anal.input.applet: A GUI can be assumed to exist for applets, so dialog box 
input and parameter input areas appear to be equally convenient to use.

.anal.output: Using a Messenger interface as suggested in .sol.output is a 
reasonable and general solution and has no disadvantages for the simple output 
demands of the benchmark suite.

.anal.effect: The "effect" that a computation has is subtle.  In the case of 
object allocation and garbage collection, if the allocated object has a 
finalizer that has an effect, then allocating the object has an effect.  (Ditto 
for the constructor).  This illustrates that it is hard for the compiler to 
establish whether an allocation can be optimized away.

.anal.use-object.assign: Storing an object reference in a variable in a loop 
does not prevent the optimizer from removing the assignment if it discovers 
that the value is dead.  Gratuitous code introduced to "use" the variable may 
also be optimized away.

.anal.use-object.volatile: The JLS appears to guarantee that the compiler 
cannot optimize away an assignment to a volatile variable (8.3.1.4, "... 
guarantees that accessed to the shared values [...] occur exactly as many 
times, and in exactly the same order, ad they appear to occur during execution 
of the program text by each thread."; hence storing a newly allocated object in 
a volatile variable would appear to force the allocation to happen.

.anal.use-object.method: If the compiler can be dissuaded from discovering the 
particular method body that will be executed when a method is called, then it 
won't be able to optimize it away.  A compiler that does not have a global view 
of the program and does not perform interclass optimization can be easily 
fooled; a compiler with a global view is less easily fooled.

.anal.use-object.interface: Hiding several object implementations behind a 
common interface, and pseudo-randomly selecting the object to use in any 
particular case, would require the compiler to analyze all possible 
implementations of the interface.

.anal.gc: The suggested mechanism may not work if System.gc has no effect, or 
if it only collects the youngest generation in a multi-generation collector, or 
if it starts an incremental gc but returns before the gc completes.  The 
GC-invoking code can use an implementation-dependent method when available.

.anal.portable: In principle, portability can be achieved by writing the 
framework in "pure" Java.  In practice, Java is a language that is still 
evolving, and not all Java systems support all Java versions, so a completely 
portable implementation may be impossible (features are not merely added, but 
also removed from the language and the libraries).

.anal.measure: If implemented using only portable code, the measurement 
functionality proposed in .sol.measure is straightforward.  Ideally the 
measurement code would use implementation-dependent functionality if it's 
available; this will require the measurement code to detect the presence of the 
implementation-dependent code, and use it.

.anal.adaptable: The main problem with hiding implementation-dependent 
functionality between an implementation-independent interface is that the 
interface may not always be expressive enough for the client. However, for the 
applications we are considering -- measuring resource consumption in 
system-dependent ways -- this problem is probably not important.

.anal.adaptable.detection: Detecting the presence of individual 
implementation-dependent methods rather than the presence of the method suite 
as a whole might be necessary at some point because not all resource 
consumption measurements make sense on all operating systems.



IDEAS:

.sol.program-type: Program-type specific code can be isolated by breaking each 
benchmark into two components: a stub that implements type-specific 
functionality and a core that implements the benchmark proper.  An alternative 
is to introduce use of a preprocessor and use conditional compilation; this 
requires a two-stage compilation process.

.sol.output: Most output in the framework and all output in the benchmark 
programs can be made independent of the program type by providing an output 
interface, and implementing the interface differently for different program 
types.  Alternatively, a preprocessor and conditional compilation can be used.

.sol.input.standalone: Parameter input for standalone programs can be read from 
a file, from standard input, from the command line arguments, or from a dialog 
box (on GUI-based systems).

.sol.input.applet: Parameter input for an applet can be read from a dialog box 
or from an input area in the applet viewer or browser.

.sol.gc: The method System.gc invokes the garbage collector.  However, there 
are no guarantees that it will run a "full" collection, nor is there any 
guarantee that eg finalizers will be run following collection. One possible 
solution is to run finalizers (using System.runFinalizers), run the garbage 
collector, and idling (letting a low-priority GC thread run), iterating until 
the amount of memory in use is no longer decreasing.

.sol.use-object: The compiler can be dissuaded from optimizing away an object 
allocation by using the object reference in some hard-to-optimize manner 
(essentially doing anything that cannot be proved not to affect the result of 
the computation). 
.sol.use-object.assign: The object reference can be stored in a variable whose 
value may be used before the
variable is updated again.  
.sol.use-object.method: The object reference can be passed to a public nonfinal 
method; since method selection is dynamic, the compiler will have a hard time 
determining the method body that is executed.  
.sol.use-object.interface: The object reference can be passed to a method in 
some object about which nothing is known except its interface.

.sol.library: The most natural mechanism for the library is to use a class that 
can be subclassed by the benchmark core as a repository for utility functions.  
An alternative is to use a preprocessor and include the utility functions 
directly in each benchmark.

.sol.portable: Portability can be achieved by writing the framework in "pure" 
Java.  It can also be achieved in a more limited sense by using a preprocessor 
and conditional compilation.

.sol.measure: The framework can provide utility functions that perform the 
necessary measurements.  Heap usage can be measured by a single call; time can 
be measured using a start/stop timer functionality.  It will be useful if 
multiple timers can run at the same time.

.sol.adaptable: Adaptability can be achieved by defining an adaptation 
interface for implementation-defined code, along with a placeholder (dummy) 
implementation that can be used everywhere.  Alternative implementations of the 
interface can then be provided on an as-needed basis for various Java systems.  
Adaptability can also be achieved using conditional compilation.

.sol.adaptable.detection: The presence or absence of implementation-defined 
code can be detected by providing a method as part of the interface to 
implementation-dependent code.  The method can be designed to test the presence 
of the entire method suite or of individual methods in the suite.



TEXT:

.ack: Acknowledgement: The architecture is based on PTW's benchmark 
architecture.

