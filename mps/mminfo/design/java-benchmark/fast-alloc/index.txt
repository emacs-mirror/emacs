               THE DESIGN OF THE FASTALLOC JAVA BENCHMARK
                    design.java-benchmark.fast-alloc
                           incomplete design
                             lth 1998-09-15


INTRODUCTION:

This is the design for the FastAlloc Java benchmark, which is a synthetic 
benchmark that measures the performance of allocation and garbage collection 
during rapid allocation of small short-lived objects.

.readership: MM group members.

.source: analysis.java-benchmark(1), design.java-benchmark.arch(3), 
design.java-benchmark.framework(0).


OVERVIEW:

The FastAlloc benchmark is a synthetic benchmark that allocates many small, 
short-lived objects and attempts to measure the performance of allocation and 
garbage collection.

.ballast: Allocation is performed both in the presence of "ballast" data 
structures of various shapes, and in the absence of any ballast.

.lifetimes: The allocated objects are small and short-lived because, 
empirically, most objects are small and short-lived.


REQUIREMENTS:

Critical Requirements

.req.volume: The benchmark must allocate many objects.

.req.lifetime: The allocated objects must be short-lived because the purpose of 
the benchmark is to test the collector's behavior when collecting many young 
objects.

.req.hard.gc: The benchmark must present a challenge to the garbage collector.  

.req.hard.compiler: The benchmark should be written in such a way that it's not 
possible (or at least very hard) for a compiler that performs no optimization 
at run-time to avoid allocations.

.req.repeatable: The results should be repeatable if the benchmark is run 
repeatedly under similar conditions.

.req.scaleable: The program must be scaleable in the sense that its workload 
can be increased and decreased, cf analysis.java-benchmark.req.scaleable.

.req.measure: The program must measure the time and peak heap size for each 
experiment.


Essential Requirements

.req.no-other-work: The benchmark should spend as little time as possible on 
tasks unrelated to allocation and garbage collection.


ARCHITECTURE:

.arch: The architecture is implied by design.java-benchmark.framework.


ANALYSIS:

.anal.object-type: A single object type is unrealistic -- real programs have a 
mix of object sizes -- but probably close enough.  It's not clear that a small 
number of types would make much difference

.anal.object-size: The object should be small, because most objects allocated 
in real programs are small (Java is unlikely to be different from other 
languages).  A few data fields should be sufficient.

.anal.ballast.builtin: The Java libraries themselves are not sufficient ballast 
(200K or less on most implementations) and may anyway be placed in 
non-collected spaces on some systems.  

.anal.ballast.constructed: Constructed ballast of different types allows the 
garbage collector to be exercised in several different ways.  For example, a 
garbage collector that manages large and small objects differently may exhibit 
different performance characteristics when presented with large-object and 
small-object ballast strucures.

.anal.shape: The following shapes cover at least some of the space.

.anal.shape.small-nonleaf: A linked list of small objects (with links in the 
nodes themselves) is an example of a large data structure with both scannable 
and unscannable fields that a collector probably will not handle specially.

.anal.shape.medium-nonleaf: An array of arrays of Objects is an example of a 
large non-leaf data structure that the collector probably will not handle 
specially unless the arrays are fairly large; all the arrays must be scanned 
during collection.

.anal.shape.medium-mixed: An array of arrays of int is an example of a large 
data structure with both scannable and unscannable fields that a collector 
probably will not handle specially unless the arrays are fairly large.  The 
top-level array must be scanned during collection, but the second-level arrays 
need not.

.anal.shape.large-nonleaf: An array of Objects is an example of a large 
non-leaf data structure that a collector may handle specially by not copying it.

.anal.shape.large-leaf: An array of ints is an example of a large leaf data 
structure that a collector may handle specially by neither copying nor scanning 
it.

.anal.repeatability: Running each experiment several iterations allows 
"startup" iterations to be identified and discarded; if the time for each 
iteration is reported, then statistical analyses can be performed on them.  

.anal.mixing: All iterations of an experiment can be run sequentially, or the 
experiment iterations can be interleaved.  The former seems vastly preferrable 
since, again, it allows "startup" iterations to be identified and discarded.

.anal.warmup: It seems sufficient to run each experiment once before any 
measurements are taken.

.anal.gc-before: Hard to say what's right here.  My initial assumption is that 
it's OK (and desirable) to GC before every experiment.

.anal.scaleability: Providing scaling parameters for the allocation volume and 
the amount of ballast seems to be sufficient; it would be possible to have a 
parameter for the number of iterations, but that number should be set fairly 
high by default and is therefore less interesting.

.anal.experiments: The analysis suggests multiple experiments: an experiment 
with no ballast, and other experiments with different kinds of ballast.



IDEAS:

.sol.object-type: The objects allocated can all be of the same type, or some 
fixed number of types can be used and types to be allocated can be chosen in a 
fixed or pseudo-randomized pattern.

.sol.object-size: The objects should not be very large, since that makes the 
program too unrealistic: a large object doesn't usually die right away because 
it's first used for something, and we want short lifetimes.

.sol.ballast: To exercise the garbage collector (see .req.hard.gc), there 
should be long-lived data that the collector must deal with when collecting the 
dead, short-lived objects.  
.sol.ballast.builtin: The Java libraries can be used as ballast.  
.sol.ballast.constructed: The ballast can be explicitly constructed data 
structures; this scheme allows various controlled shapes of ballast to be used.
.sol.ballast.shapes: Shapes of ballast include linked list, tree, array, nested 
arrays, in pointer-containing and (sometimes)
non-pointer-containing forms.  
.sol.ballast.volume: In particular, using explicitly constructed ballast allows 
the amount of ballast to be controlled (cf .rec.scaleable).

.sol.compiler-optimizations: The framework provides functionality for avoiding 
compiler optimizations; this should be used.  This goes for both ballast and 
short-lived objects.

.sol.repeatability: Achieve repeatability by running each experiment several 
times (multiple iterations), or by running each experiment for a longer time.

.sol.mixing: All iterations of an experiment can be run sequentially, or the 
experiment iterations can be interleaved.

.sol.warmup: Experiments may be more repeatable if a "warmup" run is performed 
by executing each experiment once before measurements are taken.  The warmup 
runs can be performed before any measurement is taken, or immediately before 
each cluster of iterations (if applicable).

.sol.gc-before: Repeatability may be improved by attempting to force a GC 
before each experiment.  (Then again, doing so may unnecessarily perturb the 
garbage collector.)

.sol.scaleability: Scaleability can be implemented by allowing scaling 
parameters for the length of the run (expressed as the length of each 
iteration) and for amount of ballast.  The length of an iteration is most 
easily expressed as the volume of allocation or number of objects to allocate 
(not equivalent if multiple object types are allocated).

.sol.measure.peak-heap: The heap usage can be measured by sampling the value of 
totalMemory() at regular intervals.


IMPLEMENTATION:

.impl: Since the basic operation is to allocate some objects in the presence of 
no or some ballast, the allocation loop and its book-keeping can be factored 
out, and dedicated per-experiment procedures can setup the ballast and call the 
allocation loop.

