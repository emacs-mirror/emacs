                    THE DESIGN OF THE MPS SPACE TYPE
                            design.mps.space
                              obsolete doc
                           richard 1996-10-30

STATICS

.static: There is no higher-level data structure than a space, so in order
to support several spaces, we have to have some static data in impl.c.space. See
impl.c.space.static.

.static.init: All the static data items are initialized when the first space is 
created.

.static.serial: spaceSerial is a static Serial, containing the serial number of 
the next Space to be created. The serial of any existing space is less than 
this.

.static.ring: spaceRing is the sentinel of the ring of spaces.

.static.ring.init: spaceRingInit is a bool showing whether the ring of 
spaces has been initialized. There is a difficult-to-avoid race condition if 
two threads both attempt to create 'the first' space at the same time.

.static.ring.lock: spaceRingLock is a lock for the ring of spaces. It has to be 
locked  when traversing the ring, to prevent spaces being added or removed.

.static.check: The statics are checked each time any space is checked.

 
TRACES

.trace: space->trace[ti] is valid if and only if
TraceSetIsMember(space->busyTraces,ti).

.trace.create: Since the space created by SpaceCreate has
space->busyTraces = TraceSetEMPTY, none of the traces are meaningful.

.trace.invalid: Invalid traces have signature SigInvalid, which can be checked.


CONTROL POOL


.pool: Each space has a "control pool", space->controlPoolStruct,
which is used for allocating MPS control data structures (using
SpaceAlloc()).

.pool.init: The control pool is initialized by a call to PoolInit()
during SpaceCreate().

.pool.ready: All the other fields in the space are made checkable
before calling PoolInit(), so PoolInit can call SpaceCheck(space). The
pool itself is, of course, not checkable, so we have a field
space->poolReady, which is false until after the return from PoolInit.
SpaceCheck only checks the pool if(poolReady).


POLLING


.poll: There are three fields of a space used for polling: pollThreshold, 
insidePoll, and actionInterval.

.poll.when: SpacePoll is called "often" by other MM code (for
instance, on buffer fill or allocation). It is the entry point for
doing tracing work. If the size of the arena exceeds pollThreshold, and
we're not already doing some tracing work (i.e. insidePoll is not set), it 
calls TracePoll on all busy traces.

.poll.inc: Each trace has a field indicating the maximum increment
in arena size before it would next like to be polled. SpacePoll takes
the minimum of these increments, the actionInterval, and SPACE_POLL_MAX, and 
sets pollThreshold accordingly (using the post-poll arena size).

.poll.interval: The actionInterval field is always SPACE_POLL_MAX at present. 
This may change.


LOCKS


.lock.ring: SpaceAccess is called when we fault on a barrier. The
first thing it does is claim the lock on the space ring. This waits
until we get the lock. If the lock is held by someone who is stopped
on the barrier fault, this will busy-wait forever.

.lock.space: After the space ring lock is claimed, SpaceEnter is
called on one or more spaces (until the correct space is identified or
we run out of spaces). This claims the lock for that space. If the
lock is held by someone who is stopped, this will busy-wait forever.

.lock.avoid: These two problems are avoided as follows:

.lock.avoid.mps: Firstly we require the MPS not to fault (i.e. when
any of these locks are held by a thread, that thread does not fault).

.lock.avoid.thread: Secondly, we require that in a multi-threaded
system, memory fault handlers do not suspend threads (although the
faulting thread will, of course, wait for the fault handler to
finish).


ARENA

.arena: The arenaStruct and zoneShift fields in the space are the 
responsibility of
the arena implementation, and are initialized by ArenaCreate().


LOCATION DEPENDENCY

.ld: Location dependencies use fields in the space to maintain a history of
summaries of moved objects, and to keep a notion of time, so that the staleness
of location dependency can be determined. This design documentation belongs 
there, really.

.ld.epoch: space->epoch is the "current epoch". This is the number of 'flips' 
of traces in the space since the space was created. From the mutator's point of 
view locations chanage atomically at flip.

.ld.history: space->history is an array of SPACE_LD_LENGTH RefSets. These are 
the summaries of moved objects since the last SPACE_LD_LENGTH epochs. If e is 
one of these recent epochs, space->history[e % SPACE_LD_LENGTH] is a summary of 
(the original locations of) objects moved since epoch e.

.ld.prehistory: space->prehistory is a RefSet summarizing the original 
locations of all objects ever moved. When considering whether a really old 
location dependency is stale, it is compared with this summary.


MISC

.root-ring: The space holds a member of a ring of roots in the space.  It holds 
an incremental  serial which is the serial of the next root.



