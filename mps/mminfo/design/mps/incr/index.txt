        THE DESIGN OF THE MEMORY POOL SYSTEM INCREMENTAL SCHEME
                            design.mps.incr
                           incomplete design
                           richard 1995-08-04


TEXT:

State:

  F = forwarding map -- maps old object location to new
  M = marked set     -- objects live and defined in F
  G = gray set       -- objects remaining to scan
  C = condemned set  -- objects in "old space".  C-M are recycled at reclaim.

1. Choose g from G (scheduler)
2. Scan (g, C)
   Fix references in g
     preserve object
       maybe allocate new space for it and move it there
       maybe add object to F
     add object to M (mark it)
     add object to G (so that it gets scanned)

Fixing an object preserve its colour with respect to other collections, or 
change it conservatively (from black to grey).

What about allocation?

Dom(F) is a subset of C and M is a subset of C, therefore storing F and M can 
be a responsibility of the pool which is managing C (the objects being 
collected).  This is useful, as it is that policy which is running the 
collection.

G, however, starts out as the set of "all" objects not in C.  All objects which 
may be scanned must implement a part of G somehow.

Pools could implement the grey set as an ADT.

  PoolFoo =
    sig
      type GreySet
      val Create  : Pool -> GreySet
      val IsEmpty : GreySet -> bool
      val Scan    : GreySet -> GreySet
    end;

A fix from another collection must not remove items from the grey set.  It may 
add items, but should avoid doing so.  How might we guarantee termination?  One 
way is to increase priority of collection as it approaches its deadline.  
Eventually it will lock out other collections and empty its grey set.

On flip, a collection creates a GreySet containing all sets for its roots and 
ground set.  This will result in some protection.  Does the protection come 
throug the grey set interface?

The grey set can be stored according to the pool class storing the objects it 
contains.  One way to avoid dynamic allocation of these sets is to limit the 
total number of concurrent collections (grey sets) and associate this narrow 
bit-array with the objects.  Eight would probably do.

Odd events to worry about:

  - allocating objects
  - declaring roots
  - mutation
  - destroying pools
  - creating pools
  - destroying Space itself!
  - fixing the object being scanned.



