           THE DESIGN OF THE MPS KEYWORD ARGUMENT CONVENTION
                           design.mps.keyargs
                               draft doc
                           richard 1997-02-07

INTRODUCTION

.intro: This document is the design for a keyword argument convention and 
mechanism for use in the Harlequin Memory Pool System (MPS).

.readership: This document is intended for MPS developers.

.bg: Keyargs were first seriously proposed at meeting.general.1997-02-05.

Document History

.hist.0: Richard Brooksby <richard> drafted the first version of this design in 
response to meeting.general.1997-02-05.  Circulated for comment in 
mail.richard.1997-02-11.??-??.

.hist.1: Richard Brooksby <richard> updated the document in response to 
comments (mail.?) and a meeting with Nick Barnes <nickb> 
(meeting.general.1997-02-12).


DEFINITIONS

.def.keyargs: The word "keyargs" shall denote the concept of keyword arguments, 
by analogy with "varargs".

.def.keyarg: A "keyarg" is a keyword argument, along with its arguments.

.def.key: A "key" is a macro expanding to a constant used to uniquely identify 
a keyarg kind.

.def.keyarg-list: A "keyarg list" is the list of keyword arguments.

.def.keyarg-fun: A "keyarg function" is a function that takes keyargs.


REQUIREMENTS


Optional Arguments

.req.opt: Multiple optional arguments.  [In order to support preferencing, 
mainly, but also to allow thing like "alignment" to be specified on pool 
creation.]

.req.args: Up to 4 arguments on each keyword.  [This requirement comes from a 
poll of some MM developers.]

.req.arg.types: Be able to pass either integers or pointers.

.req.varargs: Still permit ordinary varargs.


Durability

(See also design.general.durable.)

.req.arg.add: It must be possible to add new arguments to existing functions 
without breaking the interface to old clients.

.req.arg.remove: It must be possible to remove arguments from existing 
functions without breaking the interface to old clients.  [Perhaps we can only 
impact it minimally?]

.req.compat.up: New versions of functions must be able to support callers using 
old arguments.  (Upwardly binary compatible.)  [Same as .req.arg.add?]

.req.compat.down: Old versions of functions must be fail safe when presented 
with callers using arguments from a newer interface.  (Downwardly binary 
compatible as far as safety.)

.req.future: Must not preclude future argument passing conventions.


RATIONALE

.rat.durable: See mail.andys.1997-02-11.??-?? on the topic of why keyword 
arguments make interfaces more robust against change.  See also 
design.general.interface.durable.

.rat.prefs: We mostly need this mechanism where we have a large number of 
optional "preferences" to express.  We could have a long list of mandatory 
arguments with default values, but this would be very unwieldy and error 
prone.  The external MPS interface should be reasonably robust, so I think the 
run-time cost is worth paying in most places.  .rat.perf: Where we have 
performance critical protocols, such as reserve/commit, we won't have keyargs.  
They're most likely to crop up on pool creation.

.alt.struct: An alternative mechanism was proposed and developed for MM/EPCore 
by Nick Barnes <nickb>.  This mechanism used structure passing.  For each 
function needing preferences, an opaque structure was defined containing fields 
expressing those preferences.  The client requested a structure containing the 
defaults, and could override them using methods defined on the preference 
structure.  The completed structure was then passed to the function.  It was 
then destroyed.  This mechanism meets most of the requirements, but requires an 
unacceptable amount of code to use and implement.  Keyword arguments are a more 
concise solution with a slightly larger run-time overhead.  [Quantify?]

.rat.client: The keyarg method also has a low cost in terms of client lines of 
code.  It is easier to use a keyarg function than a function taking structures 
stuffed with optional arguments.  This is important because the MPS interface 
must be easy to convert to.  In particular, calling a function with no optional 
arguments using keyargs simply means specifying KeyEND, whereas with structure 
passing it is still necessary to create and initialize a structure containing 
default values.  [Perhaps passing NULL could count?]


KEYARG FUNCTION USAGE


Usage Synopsis

.usage.synopsis: A function accepting keyargs takes its ordinary arguments 
first, followed by a number of keyargs terminated by the keyarg "KeyEND", 
followed by a number of varargs.  ANSI C limits the maximum number of arguments 
to be 31 (see standard.ansic section 5.2.4.1) though most implementations 
support more.

  foo(<arg0>, <arg1>, ..., <arg[args-1]>,
      <key0>, <key0 arg0>, <key0 arg1>, ..., <key0 arg[key0args-1]>,
      <key1>, <key1 arg0>, <key1 arg1>, ..., <key1 arg[key1args-1]>,
      ...
      KeyEND,
      <vararg0>, <vararg1>, ..., <vararg[varargs-1]>)

.usage.types: Key arguments must be of type long int, unsigned long int, 
pointer to object, or pointer to function, depending on the key.  It may be 
necessary to insert casts, as for varargs.


Usage Examples

.usage.example.empty: This example shows a call to a function which takes two 
ordinary arguments and a keyarg list.  The keyarg list is empty, and terminated 
with KeyEND.

  foo(bar, baz, KeyEND);

.usage.example.mixed: This example shows a call to the same function, but with 
two keyargs, KeySPONG with two pointer arguments, and KeyWIBBLE with none.

  foo(bar, baz,
      KeySPONG, (void *)spong_arg1, (void *)spong_arg2,
      KeyWIBBLE,
      KeyEND);

.usage.example.varargs: This example shows how keyargs and varargs can be 
combined.  The format function takes a printf-style format string, keyargs, and 
varargs with the things to be formatted.  Note the cast (.usage.types).

  format("Hello: %d %s\n",
         KeySTYLE, (unsigned long)(FmtStyleBOLD | FmtStyleITALIC), KeyEND,
         number, string);


KEYARG FUNCTION DEFINITION


Declaring a Keyargs Function

.fun.dec: Keyargs are implemented on top of varargs, so the function prototype 
and declaration simply have an elipsis.  For example:

  Res Foo(int x, int y, ...);


Parsing the Keyarg List

.fun.parse: Here is a piece of code illustrating how to parse the keyarg list 
of a function Foo which accepts a single keyarg with key KeyFOOD, itself taking 
two pointer arguments.

  Res Foo(Spong spong, Wibble wibble, ...)
  {
    va_list args;                        /* varargs cursor */
    Key key;                             /* current key */
    Bool food = FALSE;                   /* was KeyFOOD specified? */
    FoodMaker foodMaker;                 /* argument 0 to KeyFOOD */
    FoodBits foodBits;                   /* argument 1 to KeyFOOD */

    AVERT(Spong, spong);
    AVERT(Wibble, wibble);

    va_start(args, wibble);              /* boilerplate ... */

    for(;;) {
      key = va_arg(args, Key);
      if(key == KeyEND) break;
      
      switch(key) {                      /* ... end of boilerplate */
        case KeyFOOD:                    /* handle KeyFOOD */
        food = TRUE;
        /* The next two lines disappear at compile time. */
        /* They check consistency between this code and the definition */
        /* of the KeyFOOD constant. */
        AVER(KeyArgs(key) == 2);
        AVER(KeyArgType(key) == KeyArgPOINTER);
        foodMaker = (FoodMaker)va_arg(args, Pointer);
        AVERT(FoodMaker, foodMaker);    /* always validate args */
        foodBits = (FoodBits)va_arg(args, Pointer);
        AVERT(FoodBits, foodBits);
        break;

        /* handle unrecognized keys */
        default:                        /* boilerplate... */
        res = KeySkip(key, args);
        if(res != ResOK) return res;
      }
    }                                   /* ...end of boilerplate */

    /* deal with any varargs here */

    va_end(args);

    /* get on with the function here */
  }

.fun.parse.boiler: There is quite a lot of boilerplate here.  There are a 
number of alternative methods involving keyarg list parsing functions, tables 
of keys, and the like, but they aren't much better.  The method above should be 
used until something better can be devised, since it is the most flexible.

.fun.parse.fail: The behaviour of the function should be the same when it 
receives either a malformed key, a key it doesn't recognize, or a non-ignorable 
key which it doesn't handle.  The function should generate an assertion 
failure, and return ResKEY if the assertion returns or assertions aren't 
enabled.  This behaviour is implemented by KeySkip.  [Clarify what "doesn't 
recognize" means.]


KEY DEFINITION


The Form of Keys

.key.macro: A key is a macro that expands to a 32-bit constant of type Key.

.key.uint: Key is defined to be unsigned long (impl.h.mpmtypes.key) which is 
guaranteed to be at least 32-bits wide (standard.ansic section 5.2.4.2.1).

.key.bits: The key constant is divided into bit-fields as follows:

   bit  | name    | description
========|=========|====================================
   0-15 | unique  | unique constant
  16-19 | args    | number of arguments
  20    | opt     | "optional" flag
  21-22 | type    | argument type
  23    | -       | reserved for future use, use zero
  24-32 | ver     | version = 0xCE

.key.ver: The version code serves two purposes: consistency checking and binary 
compatibility.  It is unlikely that a random value will have the correct 
version code, so the function can do reasonably well at making sure that the 
keyarg list is well formed.  If a new key format is introduced, old code can 
reject it, and new code can maintain backward compatibility with the old 
format.  In this version of the design, the ver field should always be 0xCE.  
This value can be spotted in hex dumps and resembles the word "key".

.key.opt: The "opt" flag means that if the key isn't recognized then it can be 
ignored.  If new keys are introduced which express mere preferences, and an old 
version of the code sees one, it can ignore it.  Of course, this might have 
performance penalties, but it shouldn't affect functionality.  If code sees a 
key it doesn't recognize which has the "opt" flag clear then it must fail; see 
.fun.parse.fail.

.key.args: The "args" field indicates the number of arguments which follow the 
key.  This is useful as a consistency check, but also allows the arguments to 
be skipped when the keyarg is optional and isn't recognized.  The args field 
may range from 0 to 15 (.req.args).

.key.type: The "type" field specifies the broad type of the arguments which 
follow the key.  It is one of the following set of enumeration constants 
defined in impl.h.mpmtypes:

  0  KeyArgLONG      long, unsigned long
  1  KeyArgPOINTER   pointer to object, _must_ be void *
  2  KeyArgFUNCTION  pointer to function, such as void (*)(void)
  3  -               reserved for future use [long double, probably].

.key.unique: The unique number disambiguates the key.  No two keys share the 
same unique constant.  No two keys have the same value.  The same unique 
constant it not reused with different values of the other fields.

.key.reserved: The reserved bits are reserved for future expansion and should 
be set to zero in all keys with version 0xCE.


Declaring a Key

.key.dec: Keys are declared as macro constants in impl.h.mpmtypes.

.key.dec.naming: Keys should be named according to 
guide.impl.c.naming.macro.const.

.key.dec.example: For example:

  #define KeyFOOD    ((Key)0xCE32F00D)

In this example

  CE   is the version (.key.ver)
  3    is  opt=1 indicating that food is ignorable (.key.opt)
       and type=1 indicating that the arguments are pointers to objects
  2    is the number of arguments after KeyFOOD (.key.args)
  F00D is the unique number, chosen to resemble "FOOD" (.key.unique)


TO DO

Naming of Keys in the MPS C interface?  MPS_KEY_FOOD, mps_key_t, etc.

Specify the value of KeyEND.

Quantify .alt.struct.

Are keys unique to functions?

> > .key.type: The "type" field specifies the broad type of the arguments which
> > follow the key.  It is one of:
> >
> >   0  KeyArgLONG      long, unsigned long
> >   1  KeyArgPOINTER   pointer to object, _must_ be void *
> >   2  KeyArgFUNCTION  pointer to function, such as void (*)(void)
> >   3  -               reserved for future use [long double, probably].
> 
> It's not clear to me that this meets .req.arg.types.

I will clarify the compromise.

> Must all the
> arguments for one key be of the same type?

No, but they must be in the same "broad type" class.  I will make this clearer.

> Are key arguments allowed to be positional?

Yes.  I will make this explicit.

keyargs
- Document keyarg parsing failure cases: missing END, wrong number of args, 
unrecognized compulsory key, new key, irrelevant key, etc.
- Change "robust" to "tolerant".
- Rationale: Keywords are drawn from a persistent, indefinite set of "names".  
Each name is associated with meaning by the function.  Because the set is 
indefinite the set of meanings assigned to names is flexible.
- Issues involved in deploying keyargs
- Key arguments are positional.  Keyargs are not.
- Analysis of alternatives with approximate costings.
- Dynamic vs. static typechecking: rely on signatures, "But in order to be 
confident that dynamic type safety compensates for
a loss in static type safety, you need good test suite coverage." -- Nick
- Client source code lines vs. MM source code lines.  Usable interface.
- Client code only specifies what it requires, and no more.

---

  a type declaration   1
  a structure declaration  2 + args
  default structure initializer         4 + args
  default structure prototype           1
  prototypes for arg updaters           args
  impls of arg updaters                 4 * args
  check methods for structure           4 + args
  init and destroy prototypes           2
  init and destroy impls                10 + 2 * args
                                        ==============
  TOTAL                                 24 + 9 * args

If the function is exported to the client (i.e. in the MPS Interface) then
you can add another 6 + 2 * args.

With the keyword method we need about:

  key decls                             < args (they can be shared)
  keyarg list parser                    15 + 6 * args
                                        ================
  TOTAL                                 < 15 + 7 * args

Again, if the function is exported, then double the number of key decls,
because they must appear in the interface.  Many can be shared, so this is
another <args.

