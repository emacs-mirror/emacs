              DESIGN OF THE ARENA TRACT ITERATION PROTOCOL
                      design.mps.arena.tract-iter
                             incomplete doc
                            tony 1999-04-16

INTRODUCTION

.readership: Any MPS developer.

.intro: This is the design of the Arena Tract Iteration Protocol.  The protocol 
allows other modules in the MPS to iterate over the tracts in an Arena, or all 
the tracts in a block owned by a pool.


DOCUMENT HISTORY

.hist.0: Mercilessly globally-replaced from design.mps.arena.seg-iterto 
document the separation of segments and tracts.  tony 1999-04-16


REQUIREMENTS

.req.arena: Must be able to iterate over all tracts in an arena in address 
order. This is required to support segment iteration. See 
design.mps.arena.seg-iter.

.req.contig: Must be able to iterate efficiently over all tracts in a 
contiguous region of memory, in address order. This is required to implement 
the segment module; see design.mps.seg. This is also required by pools which 
use some alternative to segments to represent contiguous memory, such as the 
reservoir; see design.mps.reservoir.

.req.complete: A tract that is alive at the beginning of the iteration and 
remains alive until the end of the iteration must be iterated over at least 
once during the iteration.

.req.once: During an iteration each tract is iterated over at most one time.

.req.tract-create: In the case where tracts are created during the iteration it 
is not defined whether newly created tracts are iterated over or not.

.req.tract-destroy: In the case where tracts are destroyed during the iteration 
then they will not be iterated over after they have been destroyed.

.req.addr-order: The tracts are iterated over in order of their base address. 
I.e. the base addresses of the tracts iterated over form a monotonically 
increasing sequence.


INTERFACE

.if.first: TractFirst starts iteration over all tracts in an arena (.req.arena).

Bool TractFirst(Tract *tractReturn, Arena arena);

If there are no tracts in the arena then this function returns FALSE and does 
not update *tractReturn.  Otherwise it returns TRUE and updates *tractReturn 
with the tract that has the least base address.

.if.next: TractNext continues iteration over all tracts in an arena 
(.req.arena).

Bool TractNext(Tract *tractReturn, Arena arena, Addr addr);

If there are no tracts whose base address is (strictly) bigger than addr then 
this function returns FALSE and does not update *tractReturn.  Otherwise it 
returns TRUE and updates *tractReturn with the tract which of all the tracts 
whose base address is bigger than addr has the least base address (i.e. the 
"next" tract in address order). Parameter addr must be (or must once have been) 
the base address of a tract. Hence it must be aligned to the arena alignment.

.if.contig-base: TractOfBaseAddr finds the first tract in a contiguous region 
of memory (.req.contig).

Tract TractOfBaseAddr(Arena arena, Addr addr);

Returns the tract for which the base address is addr. This tract must be 
allocated to some pool. Parameter addr must be the base address of this tract.

.if.next-contig: TractNextContig continues iteration over contiguous tracts in 
a region of memory (.req.contig).

Tract TractNextContig(Arena arena, Tract tract);

Returns the tract which follows the specified tract in address order. The 
returned tract will be contiguous with the specified tract. The behaviour is 
undefined unless both tracts are allocated by the same pool.

.if.macro.tract-for: TRACT_FOR is a convenience macro which iterates over all 
tracts in a block, using TractOfBaseAddr and TractNextContig. (.req.block)

TRACT_FOR(tract, addr, arena, base, limit) {
   body
}

"tract" and "addr" are variables defined by the caller; they will be updated 
during iteration to correspond to each tract and its base address. "arena", 
"base" and "limit" are expressions of type Arena, Addr & Addr respectively. 
"base" and "limit" give the range of the block, and must be aligned to the 
arena alignment. "arena" and "limit" may be evaluated multiple times. On exit 
from the iteration, the variable "addr" should be equal to "limit". Callers 
might choose to check this.

.if.macro.tract-tract-for: TRACT_TRACT_FOR is a convenience macro which 
iterates over all tracts in a block, where the initial tract is already 
available. It's slightly more efficient than TRACT_FOR in this case. It uses 
TractNextContig, but not TractOfBaseAddr. (.req.block)

TRACT_TRACT_FOR(tract, addr, arena, firstTract, limit) {
   body
}

"tract" and "addr" are variables defined by the caller; they will be updated 
during iteration to correspond to each tract and its base address. "arena", 
"firstTract" and "limit" are expressions of type Arena, Tract & Addr 
respectively. "tract" indicates the start of the block, and "limit" gives the 
limit (which must be aligned to the arena alignment). "arena" and "limit" may 
be evaluated multiple times. On exit from the iteration, the variable "addr" 
should be equal to "limit". Callers might choose to check this.

IMPLEMENTATION

.impl.class: TractFirst, TractNext, TractOfBaseAddr and TractNextContig are 
generic functions, the implementation is handled by the classes.


USAGE

.usage.typical.arena:

void SpongTracts(Arena arena)
{
  Tract tract;
  Addr base;

  if(TractFirst(&tract, arena)) {
    do {
      base = TractBase(arena, tract);
      Spong(tract);  /* Spong may destroy tract */
    } while(TractNext(&tract, arena, base));
  }
}

.usage.typical.block:

void FrobTractsInBlock(Arena arena, Addr base, Addr limit)
{
  Tract tract;
  Addr addr;

  TRACT_FOR(tract, addr, arena, base, limit) {
    Frob(tract, addr);  /* Frob may destroy tract - but it's not likely */
  }
  AVER(addr == limit); /* make sure we iterated OK */
}



