                    THE DESIGN OF THE ARENA MANAGER
                        design.mps.arena.ancient
                            obsolete design
                           richard 1995-08-25


INTRODUCTION:

This document describes the detailed design of the Arena Manager part of the 
Memory Pool System.


OVERVIEW:

The Arena Manager provides memory to all other parts of the MPS in the form of 
"segments" using the virtual mapping interface (design.mps.vm) to the operating 
system.

The Arena Manager also provides some special services on these segments in 
order to facilitate garbage collection:

  - A very fast approximation to sets of segments allows the generic fix 
function (design.mps.fix) to eliminate segments which are not in the condemned 
set (.req.set).

  - A fast translation from addresses to a pointer allows it to quickly 
eliminate others, and get to the pool-specific fix function (.req.trans).

Specific pool classes will need to layer their own data structures on top of 
segments.  A second translation from address to pointer allows them to quickly 
map to them from addresses (.req.trans).

In future the Arena Manager will also provide barrier/protection methods on 
segments.


REQUIREMENTS:

[Where do these come from?  Need to identify and document the sources of 
requirements so that they are traceable to client requirements.  Most of these 
come from the architectural design (design.mps.architecture) or the fix 
function design (design.mps.fix). -- richard 1995-08-28]

Segment Management

.req.fun.seg.alloc: The Arena Manager must provide allocation of segments.   
.req.fun.seg.free: It must also provide freeing of previously allocated 
segments.

.req.attr.seg.contig: Segments are contiguous areas of populated memory.

.req.attr.seg.size.min: The Arena Manager must support management of segments 
down to the size of the grain provided by the virtual mapping interface.

.req.attr.seg.size.max: It must also support management of segments up to ????

.req.attr.seg.align.min: The alignment of segments shall not be less that the 
ALIGNMOD of the architecture.

.req.attr.seg.grain.max: The granularity of allocation shall not be more than 
the grain size provided by the virtual mapping interface.

Address Translation

.req.fun.trans: The Arena Manager must provide a translation from any address 
to one of two pointers previously associated with an allocated segment, if the 
address lies within that allocated segment, or indicate that the address lies 
outside any segment otherwise.
.req.attr.trans.time: The translation shall take no more than ????

Arena Partition

.req.fun.set: The Arena Manager must provide a method for approximating sets of 
segments.  .req.fun.set.time: The determination of membership shall take no 
more than ???? [something very small indeed]

Constraints

.req.attr.space.overhead: Space overhead constraint?
.req.attr.time.overhead: Time overhead constraint?


ARCHITECTURE:

Interfaces

The Arena Manager exhibits a single interface, arena.h.

  type Arena
  type Seg
  type RefSig

  val ArenaCreate       : Size -> Arena or Error
  val ArenaDestroy      : Arena -> void

  val ArenaGrain        : Arena -> Size
  val ArenaGrainShift   : Arena -> unsigned

  val SegAlloc          : Arena * Size -> Seg
  val SegAllocHere      : Arena * Size * RefSig -> Seg
  val SegAllocThere     : Arena * Size * RefSig -> Seg
  val SegFree           : Arena * Seg -> void
  val SegBase           : Arena * Seg -> Address (* base of segment *)
  val SegLimit          : Arena * Seg -> Address (* limit of segment *)
  val SegSize           : Arena * Seg -> Size    (* limit - base *)
  val SegSetPool        : Arena * Seg * Pointer -> void
  val SegPool           : Arena * Seg -> Pointer (* initially NULL *)
  val SegSetParent      : Arena * Seg * Pointer -> void
  val SegParent         : Arena * Seg -> Pointer (* initially NULL *)

  val RefSigEmpty       : Arena -> RegSig
  val RefSigAdd         : Arena * RefSig * Addr -> RefSig
  val RefSigUnion       : Arena * RefSig * RefSig -> RefSig
  val RefSigIsMember    : Arena * RefSig * Addr -> Bool

  val SegRefSig         : Arena * Seg -> RefSig
  val ArenaAddrToSeg    : Arena * Addr -> Seg or False
  val ArenaAddrToPool   : Arena * Addr -> Pointer or False
  val ArenaAddrToParent : Arena * Addr -> Pointer or False

  val ArenaRead         : Arena * Addr -> void
  val ArenaWrite        : Arena * Addr -> void
  val SegReadProtect    : Arena * Seg * ProcessNumber -> void
  val SegWriteProtect   : Arena * Seg * ProcessNumber -> void
  val SegReadUnprotect  : Arena * Seg * ProcessNumber -> void
  val SegWriteUnprotect : Arena * Seg * ProcessNumber -> void
  val SegReadHandle     : Arena * ProcessNumber * Handler -> Handler
  val SegWriteHandle    : Arena * ProcessNumber * Handler -> Handler

Data Structures

  type Arena = {base    : Address,
                limit   : Address,
                free    : array [0..ADDRWIDTH-1] of Index,
                table   : array [0..] of Entry}

  datatype Entry = {first         : Bool,
                    allocated     : Bool,
                    pool          : Pointer,
                    parent        : Pointer,
                    firstOrLength : Index}

Function

  ArenaCreate: Create and initialize an arena.
    - Round up the size of address space to manage so that zones are strongly 
aligned.
    - Reserve address space from the virtual mapping module.
    - Calculate the number of grains needed to store the table.
    - Commit memory to the first grain, plus enough to store the table.
    - Create and initialize the table in the second grain upwards.
    - Create and initialize the arena descriptor structure in at the beginning
      of the first grain.

  ArenaDestroy: Finish off and destroy an arena, releasing resources.

  SegAllocHere: Allocate a segment with a particular reference signature.
    - For each zone in the reference signature:
      - Look along the free chain for that zone and allocate a segment if a 
large
        enough area is found.  Split the area if necessary.
      - Intialize the table entry with the segment details.  Set the pool and
        parent pointers to NULL initially.

  SegAllocThere: Allocate a segment without a particular reference signature.
    - Invert the reference signature and call SegAllocHere.

  SegAlloc: Allocate a segment anywhere.
    - Call SegAllocHere with the universal reference signature.

  SegFree: Free a segment.
    - Work out which zone the segment is in.
    - Look along the free chain for that zone to find the appropriate place for
      the segment.
    - Update the table entry to free the segment, and add it to the chain, 
coalescing
      it with the previous and/or next free segment if possible.

  ArenaRead: Prepare to read an address in the arena.
    - Assert that the address is in a segment.
    - If the segment has any read barrier bits set, call the read handlers
      corresponding to those bits, and check that they clear their barriers.

  ArenaWrite: Prepare to write an address in the arena.
    - As for read.

Processes

There are no processes in the Arena Manager, though conceivable there could be 
some sort of compacting/coalescing process running in the background.

Dependencies

The Arena Manager depends on the Virtual Mapping Module.

Resources




IDEAS:

.idea.grain: Set the arena granularity to the grain provided by the virtual 
mapping module.

.idea.mem: Get a single large contiguous address area from the virtual mapping 
interface and divide that up.

.idea.table: Maintain a table with one entry per grain in order to provide fast 
mapping (shift and add) between addresses and table entries.

.idea.table.figure:
  

.idea.map: Store the pointers (.req.fun.trans) in the table directly for every 
grain.

.idea.zones: Partition the managed address space into zones (see idea.zones) 
and provide the set approximation as a reference signature.

.idea.first-fit: Use a simple first-fit allocation policy for segments within 
each zone (.idea.zones).  Store the freelist in the table (.idea.table).

.idea.base: Store information about each contiguous area (allocated of free) in 
the table entry (.idea.table) corresponding to the base address of the area.

.idea.shadow: Use the table (.idea.table) as a "shadow" of the operating 
system's page table.  Keep information such as last access, protection, etc. in 
this table, since we can't get at this information otherwise.

.idea.barrier: Use the table (.idea.table) to implement the software barrier.  
Each segment can have a read and/or write barrier placed on it by each 
process.  (.idea.barrier.bits: Store a bit-pattern which remembers which 
process protected what.)  This will give a fast translation from a 
barrier-protected address to the barrier handler via the process table.

.idea.demand-table: For a 1Gb managed address space with a 4Kb page size, the 
table will have 256K-entries.  At (say) four words per entry, this is 4Mb of 
table.  Although this is only an 0.4%, the table shouldn't be preallocated or 
initially it is an infinite overhead, and with 1Mb active, it is a 300% 
overhead!  The address space for the table should be reserved, but the pages 
for it mapped and unmapped on demand.  By storing the table in a segment, the 
status of the table's pages can be determined by looking at it's own entries in 
itself, and thus the translation lookup (.req.fun.trans) is slowed to two 
lookups rather than one.

.idea.pool: Make the Arena Manager a pool class.  Arena intialization becomes 
pool creation.  Segment allocation becomes PoolAlloc.  Other operations become 
class-specific operations on the "arena pool".


IMPLEMENTATION:

.impl.table.structure: had to decide what to put in the table entries; this is 
basically as outlined above.  See TableEntryStruct in impl.c.poolar for the 
tedious details.

.impl.freelist.format: the freelist is a doubly linked list stored in the 
table.  The links at either end of the list are 0.

.impl.free.policy: a freed segment is chained onto the front of the list.

.impl.alloc.policy: the free list is searched from the beginning coalescing 
adjacent segments as they are found.  The first segment suitable is used, and 
chopped up appropriately.

.impl.coalesce.diagram:
This is a diagram to help explain what happens during a coalesce (allocP does 
this):


.impl.boot: Booting occurs when SpaceCreate is called.  SpaceCreate calls 
ArenaBoot in order to create some memory to put the space structure in.  
SpaceCreate should be the only function that calls ArenaBoot.  ArenaBoot works 
by creating a VM object and mapping enough memory to store the space structure 
in, and returns.  SpaceCreate fills in the space structure, and then calls 
ArenaInit to initialise the arena structure (which is contained in the space 
structure).  ArenaInit fills in the arena structure.  The arena needs to keep 
hold of certain values from the activation of ArenaBoot to the activation of 
ArenaInit (the VM object it creates for example), this is done by ArenaBoot 
passing back cookies, which are passed to ArenaInit.


TEXT:

Redesign the arena manager interface using the scheme for interfaces to memory 
managers.  The interface must include support for the barrier mechanism 
(address maps to chain of handlers?).  Design an implementation which will 
support the new AMC pool design, which will use more and smaller segments, and 
also require barriers on those segments.  The implementation should obtain 
protection services from the virtual mapping module for the system (vm*.c), if 
present.  The virtual mapping module interface will also require design.

Hardware barriers will require support from the Arena Manager, which
provides our OS abstractions.  The arena interface must be extended to
include "protection" in the abstract, for both the hard and soft barriers.

I would also like to move the arena interface towards a "generic allocation
interface" (idea.interface.alloc) which is similar to the general MM
interface (see below) in the hope that one day we can actually make them
the same, and provide arena-like services to our clients, as well as to
ourselves.

  requirements
    from
      AMC pool
      barrier
      fault handling
    to
      virtual mapping
  solution ideas
    shadow page-table
  generalized interface
  data structures
  implementation

Existing data structure





ATTACHMENT:

   "ARCOAL.CWK"


