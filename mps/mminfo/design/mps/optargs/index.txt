           THE DESIGN OF THE MPS OPTIONAL ARGUMENT CONVENTION
                           design.mps.optargs
                               draft doc
                           richard 1997-02-07

INTRODUCTION

.intro: This document is the design for a optional argument convention and 
mechanism for use in the Harlequin Memory Pool System (MPS).

.readership: This document is intended for MPS developers.

.bg: Optional arguments were first seriously discussed at 
meeting.general.1997-02-05.

Document History

.hist.0: Richard Brooksby <richard> drafted the first version of this design in 
response to comments on design.mps.keyargs.  Keyword arguments were deemed to 
be unsafe for client code, and likely to cause defects which would be hard to 
find.  Therefore, the convention described here was designed.  This document 
was based on design.mps.keyargs(1).


DEFINITIONS

.def.optargs: The word "optargs" shall denote the concept of optional 
arguments, by analogy with "varargs".

.def.optarg: A "optarg" is an optional argument.

.def.optarg-struct: An "optarg struct" is a structure containing a set of 
optional arguments.

.def.optarg-fun: A "optarg function" is a function that takes optargs.


REQUIREMENTS


Optional Arguments

.req.opt: Multiple optional arguments.  [In order to support preferencing, 
mainly, but also to allow thing like "alignment" to be specified on pool 
creation.]

.req.arg.types: Be able to pass either integers or pointers.

.req.varargs: Still permit ordinary varargs.


Durability

(See also design.general.durable.)

.req.arg.add: It must be possible to add new arguments to existing functions 
without breaking the interface to old clients.

.req.arg.remove: It must be possible to remove arguments from existing 
functions without breaking the interface to old clients.  [Perhaps we can only 
impact it minimally?]

.req.compat.up: New versions of functions must be able to support callers using 
old arguments.  (Upwardly binary compatible.)  [Same as .req.arg.add?]

.req.compat.down: Old versions of functions must be fail safe when presented 
with callers using arguments from a newer interface.  (Downwardly binary 
compatible as far as safety.)

.req.future: Must not preclude future argument passing conventions.


RATIONALE


OPTARG FUNCTION USAGE


Usage Synopsis

.usage.synopsis: A function accepting optargs takes its ordinary arguments 
first, followed by an argument which is a pointer to an optarg structure, 
followed by a number of varargs.

  FooBarOptStruct fooBarOptStruct;

  fooBarOptInit(&fooBarOptStruct);

  OptSet<key0args>(fooBarOptStruct, FooBar, <key0>, <key0arg0>, <key0arg1>, 
..., <key0arg[key0args-1]>);
  OptSet<key1args>(fooBarOptStruct, FooBar, <key1>, <key1arg0>, <key1arg1>, 
..., <key1arg[key1args-1]>);
  ...

  FooBar(<arg0>, <arg1>, ..., <arg[args-1]>,
         &fooBarOptStruct,
         <vararg0>, <vararg1>, ..., <vararg[varargs-1]>)



Usage Examples

.usage.example.empty: This example shows a call to a function which takes two 
ordinary arguments and an optarg pointer.  NULL indicates that no options are 
specified.

  FooBar(bar, baz, NULL);

.usage.example.mixed: This example shows a call to the same function, but with 
two keyargs, KeySPONG with two pointer arguments, and KeyWIBBLE with none.

  FooBarOptStruct opt;
  FooBarOptInit(&opt);
  OptSet2(opt, FooBar, spong, spong_arg1, spong_arg2);
  OptSet0(opt, FooBar, wibble);
  FooBar(bar, baz, &opt);

[Multiple usage example?]


OPTARG FUNCTION DEFINITION


Declaring the Opt Structure

.str.dec:

  typedef struct FooBarOptStruct *FooBarOpt;
  typedef struct FooBarOptStruct {
    ????
  } FooBarOptStruct;
  #define FooBarOpt_x (1uL << 2)

[Talk about how the name of the structure is derived.]


Parsing the Keyarg List

.fun.parse: Here is a piece of code illustrating how to parse the keyarg list 
of a function Foo which accepts a single keyarg with key KeyFOOD, itself taking 
two pointer arguments.

  Res Foo(Spong spong, Wibble wibble, ...)
  {
    va_list args;                        /* varargs cursor */
    Key key;                             /* current key */
    Bool food = FALSE;                   /* was KeyFOOD specified? */
    FoodMaker foodMaker;                 /* argument 0 to KeyFOOD */
    FoodBits foodBits;                   /* argument 1 to KeyFOOD */

    AVERT(Spong, spong);
    AVERT(Wibble, wibble);

    va_start(args, wibble);              /* boilerplate ... */

    for(;;) {
      key = va_arg(args, Key);
      if(key == KeyEND) break;
      
      switch(key) {                      /* ... end of boilerplate */
        case KeyFOOD:                    /* handle KeyFOOD */
        food = TRUE;
        /* The next two lines disappear at compile time. */
        /* They check consistency between this code and the definition */
        /* of the KeyFOOD constant. */
        AVER(KeyArgs(key) == 2);
        AVER(KeyArgType(key) == KeyArgPOINTER);
        foodMaker = (FoodMaker)va_arg(args, Pointer);
        AVERT(FoodMaker, foodMaker);    /* always validate args */
        foodBits = (FoodBits)va_arg(args, Pointer);
        AVERT(FoodBits, foodBits);
        break;

        /* handle unrecognized keys */
        default:                        /* boilerplate... */
        res = KeySkip(key, args);
        if(res != ResOK) return res;
      }
    }                                   /* ...end of boilerplate */

    /* deal with any varargs here */

    va_end(args);

    /* get on with the function here */
  }

.fun.parse.boiler: There is quite a lot of boilerplate here.  There are a 
number of alternative methods involving keyarg list parsing functions, tables 
of keys, and the like, but they aren't much better.  The method above should be 
used until something better can be devised, since it is the most flexible.

.fun.parse.fail: The behaviour of the function should be the same when it 
receives either a malformed key, a key it doesn't recognize, or a non-ignorable 
key which it doesn't handle.  The function should generate an assertion 
failure, and return ResKEY if the assertion returns or assertions aren't 
enabled.  This behaviour is implemented by KeySkip.  [Clarify what "doesn't 
recognize" means.]


KEY DEFINITION


The Form of Keys

.key.macro: A key is a macro that expands to a 32-bit constant of type Key.

.key.uint: Key is defined to be unsigned long (impl.h.mpmtypes.key) which is 
guaranteed to be at least 32-bits wide (standard.ansic section 5.2.4.2.1).

.key.bits: The key constant is divided into bit-fields as follows:

   bit  | name    | description
========|=========|====================================
   0-15 | unique  | unique constant
  16-19 | args    | number of arguments
  20    | opt     | "optional" flag
  21-22 | type    | argument type
  23    | -       | reserved for future use, use zero
  24-32 | ver     | version = 0xCE

.key.ver: The version code serves two purposes: consistency checking and binary 
compatibility.  It is unlikely that a random value will have the correct 
version code, so the function can do reasonably well at making sure that the 
keyarg list is well formed.  If a new key format is introduced, old code can 
reject it, and new code can maintain backward compatibility with the old 
format.  In this version of the design, the ver field should always be 0xCE.  
This value can be spotted in hex dumps and resembles the word "key".

.key.opt: The "opt" flag means that if the key isn't recognized then it can be 
ignored.  If new keys are introduced which express mere preferences, and an old 
version of the code sees one, it can ignore it.  Of course, this might have 
performance penalties, but it shouldn't affect functionality.  If code sees a 
key it doesn't recognize which has the "opt" flag clear then it must fail; see 
.fun.parse.fail.

.key.args: The "args" field indicates the number of arguments which follow the 
key.  This is useful as a consistency check, but also allows the arguments to 
be skipped when the keyarg is optional and isn't recognized.  The args field 
may range from 0 to 15 (.req.args).

.key.type: The "type" field specifies the broad type of the arguments which 
follow the key.  It is one of the following set of enumeration constants 
defined in impl.h.mpmtypes:

  0  KeyArgLONG      long, unsigned long
  1  KeyArgPOINTER   pointer to object, _must_ be void *
  2  KeyArgFUNCTION  pointer to function, such as void (*)(void)
  3  -               reserved for future use [long double, probably].

.key.unique: The unique number disambiguates the key.  No two keys share the 
same unique constant.  No two keys have the same value.  The same unique 
constant it not reused with different values of the other fields.

.key.reserved: The reserved bits are reserved for future expansion and should 
be set to zero in all keys with version 0xCE.


Declaring a Key

.key.dec: Keys are declared as macro constants in impl.h.mpmtypes.

.key.dec.naming: Keys should be named according to 
guide.impl.c.naming.macro.const.

.key.dec.example: For example:

  #define KeyFOOD    ((Key)0xCE32F00D)

In this example

  CE   is the version (.key.ver)
  3    is  opt=1 indicating that food is ignorable (.key.opt)
       and type=1 indicating that the arguments are pointers to objects
  2    is the number of arguments after KeyFOOD (.key.args)
  F00D is the unique number, chosen to resemble "FOOD" (.key.unique)


TO DO

Naming of Keys in the MPS C interface?  MPS_KEY_FOOD, mps_key_t, etc.

Specify the value of KeyEND.

Quantify .alt.struct.

Are keys unique to functions?

> > .key.type: The "type" field specifies the broad type of the arguments which
> > follow the key.  It is one of:
> >
> >   0  KeyArgLONG      long, unsigned long
> >   1  KeyArgPOINTER   pointer to object, _must_ be void *
> >   2  KeyArgFUNCTION  pointer to function, such as void (*)(void)
> >   3  -               reserved for future use [long double, probably].
> 
> It's not clear to me that this meets .req.arg.types.

I will clarify the compromise.

> Must all the
> arguments for one key be of the same type?

No, but they must be in the same "broad type" class.  I will make this clearer.

> Are key arguments allowed to be positional?

Yes.  I will make this explicit.

