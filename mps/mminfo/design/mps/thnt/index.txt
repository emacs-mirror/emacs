                        DESIGN OF THREADS ON NT
                            design.mps.thnt
                           incomplete design
                           gavinm 1997-04-22


INTRODUCTION:

[Placeholder]


TEXT:

To: mm
Subject: issue.general.impl.nt.thread-state
Date: Wed, 23 Aug 1995 10:32:16 +0100
From: Nick Barnes <nickb>

> ptw:
> Where are a threads registers stored on Wintel?  Do we need to peek into
> some thread/kernel structure to scan, or can we prove that all the
> registers of relevance to user mode are actually stored in the stack?

Would you believe "in the thread context". see GetThreadContext() and
SetThreadContext(). See WinNT.h for the contents of the context
structure. You can get and set various parts of the context
independently (e.g. I don't suppose you'll be very interested in the
contents of the debug registers).

Nick B

---

To: David Moore <dsm>
Cc: mm
Subject: Re: issue.general.impl.nt.thread-state 
Date: Wed, 23 Aug 1995 11:19:19 +0100
From: Nick Barnes <nickb>

> Shouldn't this be issue.general.impl.win32.thread-state?  We need to
> work with Windows95 as well.  It would be preferable to use the Win32
> API where possible.  However, I don't think it provides this facility.

Well, someone with a Win95 machine will have to look through their
header files. This is from the Win32 section of the Win32 SDK doc, so
I assume it's Win32:
--------------------------------------------------------------------
The GetThreadContext function retrieves the context of the specified
thread.

BOOL GetThreadContext(
    HANDLE  hThread,    // handle of thread with context  
    LPCONTEXT  lpContext        // address of context structure 
   );   

Parameters

hThread : Identifies an open handle of a thread whose context is to be
retrieved. The handle must have THREAD_GET_CONTEXT access to the
thread.

lpContext : Points to the address of a CONTEXT structure that receives
the appropriate context of the specified thread. The value of the
ContextFlags member of this structure specifies which portions of a
thread's context are retrieved. The CONTEXT structure is highly
computer specific; two versions of the structure currently exist, one
version for x86 processors and another for MIPS processors.

Return Value

If the function succeeds, the return value is TRUE.
If the function fails, the return value is FALSE. To get extended
  error information, call GetLastError.

Remarks

GetThreadContext is used to retrieve the context of the specified
thread. The function allows a selective context to be retrieved based
on the value of the ContextFlags member of the CONTEXT structure. The
thread handle identified by the hThread parameter is typically being
debugged, but the function can also operate when it is not being
debugged.

See Also CONTEXT, SetThreadContext 
--------------------------------------------------------------------
Under NT, we have this from winnt.h, if _X86_ is defined:
--------------------------------------------------------------------
//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_i386    0x00010000    // this assumes that i386 and
#define CONTEXT_i486    0x00010000    // i486 have identical context records

#define CONTEXT_CONTROL         (CONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, 
FLAGS, BP
#define CONTEXT_INTEGER         (CONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, 
SI, DI
#define CONTEXT_SEGMENTS        (CONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define CONTEXT_FLOATING_POINT  (CONTEXT_i386 | 0x00000008L) // 387 state
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_i386 | 0x00000010L) // DB 0-3,6,7

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_INTEGER |\
                      CONTEXT_SEGMENTS)

#endif

typedef struct _FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[SIZE_OF_80387_REGISTERS];
    DWORD   Cr0NpxState;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;

} CONTEXT;

typedef CONTEXT *PCONTEXT;
--------------------------------------------------------------------




