   THE DESIGN OF THE ELECTRONIC PUBLISHING VIRTUAL MEMORY POOL CLASS
                          design.mps.poolepvm
                              draft design
                            nickb 1997-09-12


INTRODUCTION:

This is the design for managing PostScript VM and, particularly, of the EPVM 
pool class.

.readership: MM developers and the product manager.

.source: req.epcore(16), book.psrm2.


Document History

.hist.0: First draft written by Nick Barnes 1997-09-12 [apparently without 
adequate public discussion].  Reorganised and amended by Pekka P. Pirinen 
1997-12-01 based on a review of the requirements and some implementation 
experience.

.hist.1: Edited by Pekka on the basis of review.design.mps.poolepvm.0 and the 
ensuing discussion.

.hist.2: Factor in the protection problems.  pekka 1999-09-24


OVERVIEW:

This document describes the design of the EPVM pool class and related 
functionality intended to support PostScript VM with garbage collection.  The 
EPVM pool is a mark-sweep pool derived from AMS (design.mps.poolams).  It also 
supports PostScript's stack-oriented deallocation protocol (save and restore).

.organisation: This design does not explicitly analyse every decision and some 
decisions depend on others.  Unfortunately, this document type makes the 
organisation seem a bit arbitrary.


REQUIREMENTS:

.req.alloc: Support allocation (req.epcore.fun.ps.alloc).

.req.save: Support PS save (req.epcore.fun.ps.restore).

.req.restore: Support PS restore (req.epcore.fun.ps.restore).

.req.restore.check: Check whether a reference is to an object above a given 
save level.

.req.save.list: Save/restore are implemented by a software write barrier that 
stores the old value of the slot on "the save list".  The save lists are roots.

.req.size: Report current size for vmstatus PS operator
  (req.epcore.fun.ps.gc.op):

[PS operators are described as:
   <argument>* <operator name> <result>*
If there are no arguments or results, this is indicated by '-'.  For example, 
vmstatus has no arguments and returns three results.]

   - vmstatus level used maximum
        level = current savelevel,
        used = bytes in use, ("only meaningful after a GC")
        maximum = maximum bytes available (may be meaningless on OS platforms)

.req.align: At least 8 byte alignment (req.epcore.attr.align).

.req.gc: GC (req.epcore.fun.ps.gc).

.req.gc.disable: Enable and disable GC of local/global memory for
  vmreclaim PS operator (req.epcore.fun.ps.gc.op):

  -2 vmreclaim - : disable GC
  -1 vmreclaim - : disable local GC
   0 vmreclaim - : enable GC
   1 vmreclaim - : do local GC
   2 vmreclaim - : do GC

.req.gc.trigger: Trigger GC, for setvmthreshold and vmreclaim PS operators 
(req.epcore.fun.ps.gc.op):

   n setvmthreshold - : allocation threshold; -1 => default, >max => max

  The threshold is the inverse of the GC enthusiasm; the GC runs every
  <threshold> bytes of allocation.  There are user parameters equivalent
  to setvmthreshold and vmreclaim applied to nonpositive arguments.  We
  don't have to support exactly the same semantics, especially
  wrt. the threshold.

.req.tickle: req.epcore.attr.tickle says we have to call a certain RIP function 
at least 30 times a second.  [This is not their real requirement; it might be 
easier is we got that as a formal requirement.  Pekka 1998-01-09]  This 
function doesn't allocate from the MPS or access PS memory [verify that].

.req.dict: Support PostScript language dictionaries, implemented by the client 
as pointer hash tables (req.epcore.fun.ps.gc.hash).  [The client (Andy) is 
thinking of changing to a constant hashing function.]

.req.dict.iter: Support iteration over dictionaries (req.epcore.fun.ps.gc.iter).

.req.attr.alloc: Allocation needs to be very fast.

.req.attr.save: Save and restore need to be fairly fast.

.req.attr.gc: GC can be slow but must not be terribly slow.

.req.attr.size.typ: Typical PSVM sizes are 100-500k 
(req.epcore.attr.ps.job.typ).

.req.attr.size.surprise: Surprise PSVM jobs might reach 16M 
(req.epcore.attr.ps.job.surprise).

.req.attr.size.max: PSVM jobs might reach the size of the arena 
(req.epcore.attr.ps.job.max).

.req.format.obj: PS "objects" are represented as 64-bit blocks.  The first 32 
bits contain the object type, length, and tag bits.  For "simple" (boxed) 
objects, the second 32 bits contain "the value" (the data bits).  For 
"composite" (non-boxed) objects, the second word is a pointer to the value.  
.req.format.obj.terminology: This unusual terminology is from book.psrm2.3.3.1 
-- blame Adobe.  (Note that "value" doesn't have anything to do with PS 
evaluation.)  To avoid confusion, we will always say "PS object" when we mean 
that, and use "object" is its usual generic MM sense.

.req.format.array: A PS array's value is a headerless vector of PS objects that 
is the contents of the array.  Note that the length is stored in the first word 
of the PS array object, not in the value.

.req.format.string: A PS string's value is a headerless vector of 8-bit 
characters.

.req.format.structures: There are also various other types of composite 
objects.  Their values are arbitrary C structures, sometimes containing PS 
objects or pointers to further structures.

.req.format.obj.no-header: Note that all the objects are completely headerless; 
it is not possible to discern the length of an object encountered while 
scanning; this information is only kept with the pointers to that object.  
[This is really a most inconvenient format, and it's unfortunate we had to 
accept this requirement.]  .req.format.obj.subvector: Substrings and subarrays 
are represented simply by another PS object that points to the same value 
vector, possibly into its interior.

.req.finish: File, dictionary and name objects need a cleanup when they're 
deallocated.  [Perhaps just some weak pointers?  Pekka 1998-01-09]

.req.counter.single-thread: SW is essentially single-threaded, so we set a 
counter-requirement that they access MPS from one thread only.

.req.prot: In the prototype of the pool, we have to support the exact same 
interface and memory layout as the old code.  Once we have confidence in the 
technology, we can think about improvements.

.req.prot.mmi: The current core RIP memory manager interface covers PS VM like 
this [this is a literal copy from the header file impl.h.mm]:

> extern mm_pool_t mm_pool_ps_local;      /* PostScript local VM */
> extern mm_pool_t mm_pool_ps_global;     /* PostScript global VM */
> 
> /* allocating PostScript strings and objects. The sizes are both in bytes */
> extern mm_addr_t mm_ps_alloc_obj(mm_pool_t pool, mm_size_t size);
> extern mm_addr_t mm_ps_alloc_string(mm_pool_t pool, mm_size_t size);
> 
> /* Saving and Restoring. PSVM pools support a notion of "current save   */
> /* level". Every object is allocated "at" the current save level.       */
> /* mm_ps_save increments the save level on the local pool (and on the   */
> /* global pool if the old level is MAXGLOBALSAVELEVEL or below).        */
> /* mm_ps_restore restores to a lower level, freeing all objects         */
> /* allocated above that level.                                          */
> 
> /* mm_ps_save(slevel) performs a save in PSVM. slevel is the save       */
> /* level _after_ the save.                                              */
> 
> extern void mm_ps_save(mm_size_t level);
> 
> /* mm_ps_restore(slevel) notifies the MM of a restore. slevel is the    */
> /* save level to which we are restoring.                                */
> 
> extern void mm_ps_restore(mm_size_t level);
> 
> /* mm_ps_check (level, what) checks that 'what' does not point into     */
> /* PSVM allocated at a save level higher than 'level'. Returns          */
> /* MM_SUCCESS if it does not (this includes pointers which are not to   */
> /* PSVM at all, and NULL pointers).                                     */
> 
> extern mm_result_t mm_ps_check(mm_size_t level, mm_addr_t what);
> 
> #define MINSAVELEVEL   0
> #define MAXSAVELEVELS 32
> #define MAXGLOBALSAVELEVEL      1
 
.req.prot.obj-string: mm_ps_alloc_obj is used to allocate PS objects and 
vectors of PS objects only.  mm_ps_alloc_string is used for everything else: 
strings and bitmaps and random structures hanging off various interpreter data 
structures (some of these count as roots).



ARCHITECTURE:

.arch.mark-sweep: Use a non-moving pool to avoid doing any special work (in the 
RIP) to support dictionaries and iterators.  This effectively means 
"mark/sweep".  Develop based on a generic mark/sweep pool (impl.c.poolams, see 
design.mps.poolams).

.arch.local: Separate local and global memory as separate pools.  This fits 
closely with the way the existing memory manager works, and allows a natural 
progression to having many separate VM pools (as required for Display 
PostScript, for instance).

.arch.save: .sol.save.segments.  .arch.save.head: The head of the ring of 
segments for each save level is kept in an array hanging off the pool 
descriptor.  .arch.save.head.flex: The size of this array can be specified by 
the glue code at pool creation time.  This avoids hard-wiring this sort of 
stuff into the MPS, and maximizes the future flexibility of the system.

.arch.buffer: Use buffered allocation to make allocation go fast.

.arch.buffer.save.current: There are only ever buffers on segments for the 
current save level.  Save and restore each detach buffers.  BufferFill 
allocates from segments belonging to the current save level.  This means we 
don't have to worry about buffers putting objects into segments belonging to 
the 'wrong' save level.

.arch.obj-string: Support mm_ps_alloc_string by allocating the strings and 
structures in segments with an empty rank set.  This is much simpler than, for 
instance, having a separate pool class (or pool) for strings.  The glue code 
can just use separate APs for mm_ps_alloc_string and mm_ps_alloc_obj.  
.arch.obj-string.fix: The fix method turns grains in string segments directly 
from white to black.

.arch.grain: Since strings and arrays are headerless and divisible, we keep 
track of each grain (initially 8 bytes) separately, so we can reclaim some 
grains out of a vector, even if a subvector is still live.

.arch.format: We need a format for a scanning method.  However, we don't need 
any other methods on the format.  We can use it for the alignment.

.arch.struct.pretend: The scanning method will implement .sol.struct.pretend.

.arch.final: Support file and name clean-up actions by using finalization.

.arch.tickle: .sol.tickle.glue and .sol.tickle.glue.message.  The trace rate 
[or other control] is set by the client as a global preference: mps_set_pref 
@@@@.

.arch.trigger.glue: We'll do .sol.trigger.glue, because it's simplest.

.arch.segment.size: As per request.epcore.160134.sol.dual-size ("EPVM segments 
get interleaved with temp pool segments") and mail.gavinm.1998-09-10.16-48(0) 
("EPVM Design Brainstorm").  When a new segment is required its size is 
determined from the size of the object currently being requested and a couple 
of other things.  In general the object size requested is rounded up to some 
alignment to determine the segment size.  If this segment is the first object 
or first string segment at this save level then an alignment of ArenaAlign (ie 
page size) is used.  Otherwise (a subsequent segment) an instantiation specific 
alignment (which is itself aligned to ArenaAlign), called the "subsequent 
segment alignment",  is used.  The subsequent segment alignment defaults to 
64Kb.  And may be client configurable; who knows.



ANALYSIS:

.anal.simple: Start with the simplest workable design and improve it as 
necessary to meet performance requirements.

.anal.simple.save.pool: .sol.save.pool would mean having the client code talk 
about lots of pools, and it would have to condemn bunches of pools together &c.

.anal.fix: We pick .sol.fix.iterate, as it means we don't have to change the 
MPS interface just to support this fixing method.

.anal.struct.root: It's not clear how .sol.struct.root could find all these 
dynamically created structures, in order to scan them as roots.  Some of them 
are on global linked lists, but not all.

.anal.struct.pretend: .sol.struct.pretend does lead to problems with protection 
(see .protection.format).  However, we don't necessarily need protection.

.anal.tickle.park: .sol.tickle.park would complete any other traces which 
happen to be running, which we would not want.  Callbacks are tricky.

.anal.tickle.glue: Without protection .sol.tickle.glue is a terrible hack.

.anal.tickle.glue.predicate: .sol.tickle.glue.predicate requires new interface, 
unlike .sol.tickle.glue.message.  Giving clients a handle on the trace creates 
a liability, since they would have to finish it or get left with an invalid 
pointer.

.anal.trigger.action: For .sol.trigger.action, we'd need an interface to 
communicate changes in the threshold to the MPS.  .anal.trigger.action.gc: 
.sol.trigger.action.gc would require some additional glue to work with any of 
sol.tickle.*.  .anal.trigger.glue: PS requires a separate threshold for each 
execution context; this would be easiest to do in the glue.


IDEAS:

.sol.save.pool: Keep a separate pool for each save level, but this would mean 
having the client code talk about lots of pools, and it would have to condemn 
bunches of pools together &c.

.sol.save.segments: Have each segment at a single save level.  This way save 
level is not per-object, so we keep less accounting information, and restore 
just throws away a bunch of segments.

.sol.fix: Since we can't infer the size of a block locally, but only by 
inspecting the reference, we can either:

.sol.fix.iterate: (a) make the format scan method apply 'fix' to the address of 
every grain in the value or other referred block (e.g., when scanning a grain 
which points to an array, apply fix to the address of each grain in the array), 
or

.sol.fix.method: (b) add a 'fix this range' function which the format scan 
method can call.

.sol.struct.root: Structures allocated through the string interface that 
contain references, will be handled as roots (in particular, save lists).

.sol.struct.pretend: Structures allocated through the string interface are 
scanned when the PS object that they are a part of is scanned.  We effectively 
pretend that they are colocated with the PS object.

.sol.tickle.park: The collection is started by calling 
mps_epvm_start_collection() and then the arena is parked to finish it.  The MPS 
takes the tickle function as a callback that it calls at intervals during the 
collection.

.sol.tickle.glue: The glue code tickles the RIP between increments.  The glue 
code calls mps_pool_start_collection(epvm_pool) followed by a loop containing a 
tickle and a call to mps_work() which advances the collection.  
.sol.tickle.glue.message: When the collection is finished, a message is 
posted.  .sol.tickle.glue.predicate: To tell when the collection is finished, 
the glue code calls mps_trace_is_finished() on the mps_trace_t object returned 
by mps_epvm_start_collection.

.sol.trigger.action: Implement setvmthreshold (.req.gc.trigger) by using an 
action.  .sol.trigger.action.gc: The action starts a GC.  
.sol.trigger.action.message: The action just posts a message.

.sol.trigger.glue: Implement setvmthreshold by counting in the glue.

.sol.restore: The save lists could be handled cleverly, in order to collect 
more effectively, see mail.nickb.1997-09-18.16-33(0).  .sol.restore.root: We 
could just mark them as roots.  .sol.restore.last: We could do them last, 
fixing directly to black.  This could be done using the reference rank proposed 
in mail.pekka.1997-09-23.11-28(0), possibly doing the restores eagerly as Pekka 
proposes.  .sol.restore.dealloc: We could omit fixing the pointer to the old 
slot.  This would cause the slot to possibly get reclaimed, but the restore 
could reallocate it in the same place (MPS needs to restore its alloc status).  
.sol.restore.flip: We could unwind the save lists level by level, swapping all 
the elements back into their original places, and mark from the other roots on 
each level.



IMPLEMENTATION:

.low.ams: Most low-level design decisions are inherited from poolams, see 
design.mps.poolams.

.low.macro: Isolate all mucking about with bits in bit-tables into a set of 
macros near the head of the source file.  This way it doesn't obscure the code 
and the mapping from bits to state can be changed readily (e.g., for 
performance reasons).

.low.iterate: Keep the iterator model from impl.c.poolams (see 
design.mps.poolams.iter), as it still simplifies the code, despite the fact 
that we no longer have to call the format skip method.  However, the object 
functions and the iterator itself are now considerably simpler than in ams (the 
object function becomes a grain function).

.low.iterate.inline: If this turns out to be bad for performance, we can always 
inline the iterators.  In particular, inlining the iterator into the reclaim 
method might simplify it into a couple of BT calls.

.low.check: To support req.restore.check, it is sufficient to provide a method 
to tell whether a pointer is to an EPVM pool and if so which pool and at what 
save level.  This is efficient (SegOfAddr) and should be of more general use in 
debugging pointers.

.low.buffer: The BufferInit method takes an extra argument to indicate whether 
it's an object or a string buffer (see .arch.obj-string).  The mps_ap_create 
interface has to be changed to pass the optional arguments through.

.low.align: As SW can create interior pointers into strings 
(.req.format.obj.subvector), we can't expect pointers to string segments to be 
aligned in EPVMFix and mps_epvm_check.

.low.trace.scan.noaver: EPVMScanObject is called on every grain in the 
segment.  The argument in design.mps.trace.fix.noaver applies, and we will omit 
any AVERs in it.

.low.segment.align.subsequent: The subsequent segment alignment is stored in 
the EPVM instance structure.  It is stored such that it is aligned to 
ArenaAlign().

.low.segment.size: The mechanism for determining the size of the segment to 
allocate is implemented in the EPVMSegSizePolicy function.  This function 
overrides the corresponding method from PoolClassAMS.


TEXT:

.protection: SW is currently not using any protection.  We use it for 
incremental GC and segment summaries.  There is no requirement to do 
incremental GC (provided the tickling requirement doesn't amount to that), and 
there are probably very few scannable objects outside the condemned set that 
don't refer to it (just the global pool, when GCing local pool), so summaries 
are unlikely to be very productive.  .protection.hack: To actually prevent 
problems from incorrect summaries, we hack the segment module to make all 
non-empty summaries universal.

.protection.format: With the current data format, the PS objects are subject to 
being copied, and hence there is no canonical location for the reference 
summaries from the values.  This design appears to make it impossible for any 
protection mechanism to keep summaries incrementally accurate.  To succeed at 
that, we must allow for the following scenario:
1. a PS object which references a value is copied somewhere outside of MPS 
(e.g., a stack, that is registered as a root).
2. A new reference is written into the value object by indirecting through the 
new copy of the PS object.
3. The new copy of the PS object is destroyed (e.g., by popping the stack).
We must persuade the core group to change to a saner data format.

.software-barrier: Since PS is an interpreter, it would seem an ideal candidate 
for a software barrier implementation, if, in the future, we should need 
barriers.  There is a lot of legacy code that would need to be updated, but 
DP&P have been fairly systematic, so it's not impossible.

.mark-compact: Since this is a high-residency and high-fragmentation 
application, a mark-compact GC could be the ideal solution.  We'd have to do 
that extra work that we decided to avoid in .arch.mark-sweep.


TRANSGRESSIONS

.trans.arch.obj-string: Note that there _are_ pointers in the string segments, 
so making the rank set empty (.arch.obj-string) is a lie.  We get away with 
this, because the scanner pretends the pointers are elsewhere 
(.arch.struct.pretend), the tracer and the fix method never make string 
segments grey (.arch.obj-string.fix), and we don't use barriers.  Those are the 
only current users of the rank set information, but we should pressure the core 
group to fix this anomaly (they need to split mm_ps_alloc_string into two 
interfaces and revise the structures to make them scannable), so we won't break 
SW with some future change.

