             THE DESIGN OF THE MEMORY POOL SYSTEM SCHEDULER
                          design.mps.scheduler
                           incomplete design
                           richard 1995-08-25


INTRODUCTION:

The document describes the design of the part of the Memory Pool System which 
performs scheduling of work.

This document is incomplete.  Do not rely on its tags!  (See 
status.incomplete.)


OVERVIEW:

The scheduler is a part of the MPM which takes a specified amount of CPU time 
and spends it in order to advance the collection processes in the system.


REQUIREMENTS:

.req.fun:
.req.attr:


IDEAS:

Measuring Time

.idea.time.soft: Since we can't rely on hardware clocks, use an abstract 
software notion of CPU time to measure progress and make decisions. 
.idea.time.soft.scanned: A simple software measurement that would be easy to 
implement would be the number of words scanned.  .idea.time.soft.copied: 
Something similar which might more accurately reflect the work done would be 
the number of words copied on fixup.  .idea.time.soft.inst: These measures may 
turn out to be an accurate enough measurement to meet our requirements, but if 
not we may want to instrument code in more detail (idea.instrument).

.idea.time.hard: On platforms which support it, we could use hardware timing 
(cycle clocks) in order to make better scheduling decisions.  The DEC Alpha has 
something like this.

Development Strategy

.idea.dev.incr: The scheduler should be quite simple at first.  We can start by 
scheduling a single collection process, and move on to multiple collections 
later.

Concurrency

.idea.conc: On a multiprocessor or multithreaded machine there are 
opportunities for more sophisticated scheduling.  For example, we might be able 
to schedule a single collection's scanning work on two processors at once.

Data Structures

process table
  process object
    id
    owner pool
    fault handler
    state
      stage of collection
        flip
        trace
          scan part of gray set
          copy object incrementally
        reclaim
      gray set
    timing constraints
      due to finish by
    experience
      progress control

A process object contains the current state of a collection, and is analogous 
to a process in a kernel (idea.collect).  Our collectors will be state 
machines, so the design of their state is quite important.  Most of the time, 
the object will "contain" the gray set, but sometimes it might contain the 
state of other stages such as reclaim, forwarding, or whatever.

The scheduler can globally limit the number of processes, and assign each 
process an id which is an integer -- actually the index into the process 
table.  This allows the gray set (tag?) to be stored adjacent to the objects 
without the need for dynamic management.  It also allows the barrier mechanism 
(tag?) to remember a set of processes in a simple bit vector.  For the latter 
reason we should allow no more than ADDRWIDTH processes so that the bit vector 
can be stored in a single word.

Decision Making

The decision to schedule a process should be based on a cost-benefit analysis.  
We should investigate real-time scheduling algorithms which plan ahead in order 
to make sure that work gets done on time (see paper.henrick94?).  We should 
also look at RCLE's progress control (rival.rcle).  Scheduling may also be the 
only way of ensuring termination if there are multiple collections which are 
perturbing each others' gray sets.


