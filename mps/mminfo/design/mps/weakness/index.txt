                  DESIGN OF THE MPS WEAKNESS MECHANISM
                          design.mps.weakness
                           incomplete design
                             drj 1996-04-10


INTRODUCTION:

Weakness in the mps


OVERVIEW:

.terminology:
weak reference - a weak reference will faithfully refer to objects in the same 
manner as an exact reference as long as that object is reachable from the roots 
via a chain of stronger (ie, exact and ambiguous) references.  At any time that 
this condition does not hold then the weak reference may be replaced with some 
other (user controlled) value.  All weak references to a given object are 
replaced atomically with respect to the mutator.  As long as the object is 
reachable (via a chain of any rank of references) its storage will not be 
reclaimed.
weak objects - objects that contain weak references.  Note that this is _not_ 
the same as an object that is weakly referred to.
(to) weaken (a reference) - replace a weak reference with a value that is not a 
reference to the object originally referred to.
splat - to weaken a reference


REQUIREMENTS:

req.dylan.fun.soft.lib.weak
I refine that here to
.req.object.weak: weak objects.
.req.object.weak.alloc: Allocate weak objects.
.req.object.weak.manage: weak objects should be managed in the same way as 
"exact" objects (I made this one up - drj, the intention is that weakness and 
management policy are different concepts, you could have weak objects allocated 
in a traced but manually managed pool)


ARCHITECTURE:

Associate a rank with every segment.  The ScanState holds the current rank for 
each trace; the tracer can select segments to scan accordingly.  This will 
allow (cooperating) pools to have weak objects stored in weak segments.

Extend Buffers so that buffers can be created that allocate objects of a given 
rank (objects whose references are of a given rank). In particular we will want 
a buffer that allocates weak objects

In order to manage weak objects pools will need to do:
 nothing, weak objects will be managed just like ordinary (scannable) objects.
In order to have weak objects scanners will need to:
 adjust ss->weakSplat before calling Fix and restore it afterwards.
In order to properly implement weak references, any pool that manages objects 
that will be weakly referred to will need to:
 Properly fix weak pointers to Old objects during a Weak Fix (use the 
ss->weakSplat value).
All pools that understand the Fix protocol will need to:
 Do something with weak fix (it's possible to for a pool to implement weak fix 
as exact fix for a "null" implementation)

The design centres around the ss->weakSplat field.  This is the communication 
channel between the object format (which is responsible for ensuring that weak 
references are weakened to some sensible value) and the pool's fix method 
(which is responsible for determining when a weak reference should be 
splatted).  This isn't particularly nice, the points in favour are:

The pools fix method has to do something to recognize a weak fix anyway.  The 
pool needs to determine whether the reference should be splatted.  For safety 
reasons the pool should splat the reference.  It's relatively easy for the pool 
to splat it with some variable value (such as ss->weakSplat).

The alternative of returning via Fix some parameter that indicates if a 
reference should be replaced with the splat value means that extra baggage gets 
carried around by all fixes.

Against:

Scanners have to update the ss->weakSplat field (and restore it when they are 
done).  This is quite a tedious interface from that viewpoint.

Scanners can do evil things by adjusting ss->weakSplat and then not restoring 
the old value.


ANALYSIS:

.lemma.scan:  any pool that has scannable objects automatically acquires the 
ability to have weak objects (since weakness is a property that is implemented 
by the fixer and the fixer is called by the scanner).  The only issue is 
whether the format can do anything sensible with a weak reference that has been 
deleted.  We can finesse this by assuming that all scanning formats can do 
something sensible with a deleted weak reference (by default I expect the 
reference to be replaced by C NULL which ought to be common parlance for a 
"non-reference").

.anal.fix: this requires that the class specific fix method (pcBLAHFix 
typically) will need to know the IsOld status of the object.  This isn't too 
much of a burden (but does restrict some implementations) and is more or less 
necessary for implementing weakness and finalization.  A pool can meaningfully 
have (other pools') weak references to its objects exactly when it can 
accurately return the IsOld status in the fix.  Note that a pool can always 
claim that an object wasn't old when fixed (thereby meaning that weak 
references to the object will never be deleted).

Formats need to interpret the value returned by fix.  typically it will require 
no interpretation if the format is using C style pointers.  However, it is 
likely that weakened pointers will require special attention (to accord with 
type constraints for example).  So it might be worthwhile having some special 
mechanism to handle the case where a pointer has been weakened.

For example format could modify a field in the ss_t (ss->weak_splat) and the 
pool could use this instead of NULL.  Format would need to restore the old 
value of ss->weak_splat when it was done.  I think this solution is not very 
modular and error prone (eg what happens when format forgets to restore old 
ss->weak_splat value?).  Could provide a trampoline like interface to make 
restoration of the old value automagical.

Or... could have extra parameter to Fix (the weak_splat parameter).  This would 
get copied around a lot and not used very much.

I get the feeling that the problem is that scanning weakly is (usually) 
significantly different than scanning exactly.

.anal.final.serendipity: this is trivial to do I think.

.anal.pool.segment: the options are:
1) rank is associated with pool
2) rank is associated with segment
The second option allows the tracer to proceed more intelligently (it can avoid 
scanning weak segs exactly for eg) and is more in keeping with the philosophy 
of the new tracer design.  It's finer grained than (1), lighter-weight, and 
additionally allows pools to have (for example) ambiguous objects (since the 
tracer can now find all ambiguous pointers at flip time).
The first option increases the number of pools in use (which could well mean 
more inter-pool fixing), and seems to me to be slightly too heavyweight.

.anal.buffer:  This could be done in a general way by having BufferCreateRanked 
or adding the extra parameter to BufferCreate (I slightly prefer the former 
approach).  Automagically allows any (scanned) pool to manage weak objects.

.anal.fix:  When an a reference to an object is fixed, the object must's rank 
must not change.  For a copying collector, this will involve having a 
forwarding buffer for each rank that the pool expects to have objects of



IDEAS:

.idea.segment: weakness on an individual segment level
.idea.buffer: need to have some way of requesting a buffer for allocating weak 
objects.
.idea.pool: weakness on entire pools
.idea.pool-create: have some way of requesting a weak pool
.idea.seg-rank: associate a reference rank with every segment
.idea.fix: weak fix needs to communicate the IsOld status of the object
.idea.final.serendipity: final fix also needs to communicate the IsOld status 
of the object; weak and final could use a unified mechanism



IMPLEMENTATION:

In fact, weak references are fixed to zero if they refer to objects which are 
going to die.


TEXT:

see also design.amc.weakness
.issue.dwformat.wrapper: when create Dylan object with weak references _all_ 
references will be weak, _including_ the wrapper pointer.  It is vital that the 
wrapper is not reclaimed (whilst there exist objects that are referring to the 
wrapper via their wrapper field).

