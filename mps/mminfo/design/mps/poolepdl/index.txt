                   DESIGN OF THE EP DISPLAY LIST POOL
                          design.mps.poolepdl
                           incomplete design
                            nickb 1997-03-12


INTRODUCTION:

This design is for a pool class for EPcore display lists.

.readership: MPS developers only.

.source: req.epcore.


Document History

.hist.0: Nick put his notes here.  Pekka moved some stuff from the 
implementation, added boilerplate and tags.


OVERVIEW:

This pool class was implemented in response to request.epcore.170193, which 
arose because the existing PoolMV had bad fragmentation behaviour when used for 
display lists.  This is an interim solution; long-term solutions might include 
refining PoolMV to have less fragmentation. See 
design.mps.poolepdl.design.not.mv.


REQUIREMENTS:

.req: requirements are inherited from req.epcore, especially
  req.epcore.attr.footprint,
  req.epcore.fun.dl.alloc,
  req.epcore.fun.dl.free,
  req.epcore.fun.dl.free.mass,
  req.epcore.fun.dl.free.any,
  req.epcore.fun.dl.multi,
  req.epcore.attr.dl.obj.min,
  req.epcore.attr.dl.obj.typ,
  req.epcore.attr.dl.obj.max.

.req.frag: Have less fragmentation than PoolMV, in the presence of shrinking 
objects.  See also request.epcore.170193.


TEXT:

.purpose: Need a specialized pool here because MV has bad fragmentation.  We 
need the ability to allocate objects over segment boundaries, to avoid 
fragmentation on those boundaries.  We also need to return unused segments to 
the arena.

.design.basic: The basic design is to keep the free list as a linked list of 
descriptors in address order.  The descriptors are allocated from a separate 
MFS pool, for locality when scanning the list.  We don't want to extend this 
"block pool" very often, as extending control pools can lead to fragmentation 
at the segment level.

Single free blocks can span several segments.  Adding a new segment shares code 
with freeing an object (scanning the free list and adding/extending/merging 
blocks), but isn't  identical because we don't want to free segments when 
adding a new segment.

.issue.eager: We return a segment to the arena whenever it becomes possible 
(during EPDLFree).  If there were a mechanism for the arena to ask us to return 
segments, we could use that.  Such a mechanism should go along with some sort 
of segment splitting function, so that free blocks which are large but which do 
not include a whole segment can still be returned to the arena.  Alternatively, 
we could scan the free list "every so often" looking for segments to free.

.design.segSize: When adding a segment, we use extendBy as the segment size 
unless the object won't fit, in which case we use the object size (in both 
cases we align up).

.design.segFail: If allocating a segment fails, we try again with a segment 
size just large enough for the object we're allocating.  This is in response to 
request.mps.170186.

.design.blockExtend: We don't want to extend the block pool too often, nor have 
it reserve large segments unnecessarily.  See request.mps.170108. EPDL pools 
have low fragmentation almost all of the time; when partial paints happen, 
almost all of the objects are freed.  If we assume that this happens in random 
order, we get (total objects/4) number of free blocks at the peak.  This is an 
overestimate because actually objects are not freed in random order; there is a 
strong but unknown relationship between allocation order and freeing order.  So 
for the time being we set the block pool's extendBy to be 64 blocks (large 
enough for a reasonable free list); when we have integrated with ScriptWorks 
and tested, we can measure the maximum freeList length and correct this 
computation.  See request.epcore.170204

.design.not.mv: We could have just refined the MV pool so that it met the DL 
requirements.  However, DLs have a lot of specific behaviour (e.g. promised 
allocation, which usually truncates, frees are rare but bunched, allocate a lot 
and then kill the pool, &c); although this implementation isn't highly 
specialized, having a separate pool class allows us to specialize as much as 
necessary to meet performance requirements.  Such specialization may be 
detrimental to the use of this pool class for a general-purpose pool.  In other 
words, having a new pool class means we can concentrate on quickly solving the 
problem at hand without having to consider other possible uses.  [I think this 
was a bad decision.  It means that most improvements need to applied in two 
places (since there's no code sharing).  The implementation of EPDL tends to be 
too SW-specific, meaning inflexible, if the requirements change, or are 
discovered to be inaccurate.  We should design general solutions, even if we 
don't implement all of it immediately -- that's what we did with the MPS.  
Pekka 1998-01-15]

.allocation: Allocation is by first fit.  Free blocks have a 'size' slot to 
make scanning for a fit go fast (this is probably premature optimization).

Space can be 'lost', just as in MV, if allocating a new block descriptor 
fails.  We record the amount of space lost.

We record total pool size, free size, lost size, and free list length.  The 
last two are for debugging purposes.  'free size' and 'total pool size' are 
there so we can implement mps_epdl_free_size and mps_epdl_size, which are 
needed by the RIP.

We require that SegNext proceeds in address order, in order that we can 
identify segments to return to the arena when an object is freed.  We could 
avoid this dependency by using seg->p to link a pool's segments together in 
address order.

.issue.space-enter: MPS interface extensions should do SpaceEnter() and 
SpaceLeave(), but don't at the moment because the relevant config stuff hasn't 
been done on this branch.  Doesn't really apply to class structure return 
functions (e.g. mps_class_epdl()).

.issue.segRing: The trunk now has a segment ring for each pool.  When we have 
merged into the trunk, this can be used to iterate over segments in a pool.  In 
the meantime, we have to use SegFirst/SegNext.

.segpref.promise: EPDL allocates upwards within a segment and explicitly sets 
SegPrefLow and assumes other pools will be SegPrefHigh, because a promise is 
always truncated from the high end, so you want free space above it to put the 
next promise in, and possibly need a new segment _above_ the current one as 
well.

 .arg: This class adds the following arguments to PoolCreate.  These are 
inherited from PoolMV, and are probably not the most sensible for EPDL use.

.arg.extendBy:

   Size extendBy

 extendBy is the default number of bytes reserved by the pool at a time.  A 
large size will make allocation faster but have a higher resource overhead.  A 
typical value might be 65536.

.arg.avgSize:

   Size avgSize

 avgSize is an estimate of the average size of an allocation, and is used to 
choose the size of internal tables.  An accurate estimate will improve the 
efficiency of the pool.  A low estimate will make the pool less space 
efficient.  A high estimate will make the pool less time efficient.  A typical 
value might be 32.  avgSize must not be less than extendBy.

.arg.align:

   Size align

 align is the alignment of allocations from this pool.  A typical value might 
be 8.  align cannot be 0 or larger than the arena alignment.

.lastfree: There's a small hack to improve freeing speed when the freelist is 
long.  It relies on locality of frees.  .lastfree.update: The lastFree field 
points to the freelist block preceeding the last free (as we can get hold of 
that cheaply).  If the block lastFree is pointing to is removed from the 
freelist, it is updated to point to the next block.  (This code could be 
improved a bit, by keeping track of the previous block.)  .lastfree.add: When 
new areas are added to the freelist, we check if they're situtated after the 
block pointed to by lastFree, and if so, start our search from that point.


