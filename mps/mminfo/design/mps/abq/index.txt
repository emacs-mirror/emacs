                         AVAILABLE BLOCK QUEUE
                             design.mps.abq
                              draft design
                             ptw 1998-06-29


INTRODUCTION:

This is the design of a queue data substrate used by impl.c.poolmv2.

.readership: MM developers

.source: design.mps.poolmv2(4)

.hist.0: Draft created 1998-06-29 by P. T. Withington


OVERVIEW:

The MV2 pool delays the reuse of coalesced blocks to permit further 
coalescing.  It uses a queue to hold these blocks, so that the oldest block is 
reused first.  There is a limit on the number of such blocks -- excess blocks 
are returned to the arena.  The queue is called the Available Block Queue 
(ABQ).  This document is the design for that queue.  It is a simple, 
fixed-sized, first-in first-out queue.


REQUIREMENTS:

The source of all requirements is design.mps.poolmv2(4).

.req.fixed: It must be possible to have a queue of fixed size.

.req.fifo: It must be possible to store and retrieve items first-in, first-out.

.req.empty: It must be possible to determine when the queue is empty.

.req.full: It must be possible to determine when the queue is full.

.req.delete.random: It must be possible to remove any item from the queue.

.req.reference: It must be possible for the queue items to be referenced both 
by the queue and another structure (in particular, the Coalescing Block 
Structure (CBS), cf. design.mps.cbs(0)), simultaneously.

.req.information: It should be possible to determine the number of elements in 
the queue, for statistical purposes.


ARCHITECTURE:

.arch.abq:  We chose to implement the vector solution.  .arch.abq.struct:  The 
abq structure consists of a size field, an in index, an out index, and a vector 
of items.  .arch.abq.struct.in: The in index identifies the next empty slot in 
the vector where a new item can be stored in the queue.  .arch.abq.struct.out:  
The out index identifies the next full slot in the vector where an item can be 
retrieved from the queue.  .arch.abq.emtpy:  An empty queue is signified by the 
in index and the out index being equal.  .arch.abq.full:  A full queue is 
signified by the in index being 1 less than the out index.  .arch.index.modular
: Index arithmetic is modular, using the vector size as a modulus.  
.arch.vector.size:  The vector is allocated at creation time to be large enough 
to hold one more than the required number of elements.  
.arch.vector.size.rationale:  The additional element serves to distinguish a 
full queue from an empty queue.  .arch.abq.delete:  A random item is deleted 
from the queue by searching the queue linearly and moving all elements beyond 
the one to be deleted forward.  .arch.abq.item:  Items are stored in the queue 
by reference to satisfy .req.reference.


ANALYSIS:

.anal.list:  The list solution is more general than is needed.  It permits a 
variable-length queue which is unnecessary.

.anal.vector:  The vector solution has slightly more overhead in satisfying 
.req.delete.random because all items following the deleted one must be moved.


IDEAS:

.sol.list: Create the queue from list nodes that have forward, backward, and 
item slots.

.sol.vector: Create the queue from a vector of items with in and out indices.


IMPLEMENTATION:

ABQs are implemented in the C language by the files MMSrc!abq.h and MMSrc!abq.c.


TYPES

.impl.h.abq: ABQ is the abstract data type (guide.impl.c.adt(0)) represented by 
a reference to an ABQStruct.

.impl.h.abq.struct: ABQStruct is the structure of an ABQ.  It consists of a 
Count (1 more than the number of items the queue can hold, see 
.arch.vector.size.rationale), an in and out Index, and a vector of CBSBlock.  
Four meters are provided for counting the number of push, pop, peek, and delete 
operations on the ABQ.  A signature field completes the structure.


PUBLIC METHODS

.impl.c.abq.init: ABQInit takes as arguments an Arena (to allocate in), an ABQ 
(to initialize), and a Count (of the number of items the abq will hold).  It 
allocates the vector to hold the queue elements and initializes the abq to be 
empty.  It returns a Res indicating whether the initialization succeeded.

.impl.c.abq.check: ABQCheck takes as an argument an ABQ and validates it.  It 
returns a Bool, TRUE if the ABQ is valid.  It will signal an assertion failure 
if the ABQ is not valid.  [This bizarre interface appears to be the contract of 
check methods.]

.impl.c.abq.finish: ABQFinish takes as arguments an Arena (to free to) and an 
ABQ (to finish).  It frees the vector allocated b .impl.c.abqinit and 
invalidates the ABQ.  It does not return a value.

.impl.c.abq.push: ABQPush takes as arguments an ABQ and a CBSBlock and returns 
a Res.  If there is room in the queue, the CBSBlock will be added at the tail.  
A return value of ResOK indicates that this is the case.

.impl.c.abq.pop: ABQPop takes as arguments an ABQ and a return CBSBlock 
reference.  It returns a Res.  If there is a CBSBlock in the queue, the one at 
the head is removed and stored at the return CBSBlock reference.  A return 
value of ResOK indicates that this is the case.

.impl.c.abq.peek: ABQPeek has an identical interface to .impl.c.abq.pop but 
does not remove the CBSBlock from the queue.

.impl.c.abq.delete: ABQDelete takes as arguments an ABQ and a CBSBlock and 
returns a Res.  It searches the queue for the CBSBlock and removes it if 
found.  A return value of ResOK indicates that this is the case.

.impl.c.abq.describe: ABQDescribe takes as arguments an ABQ and an 
mps_lib_FILE.  It outputs a textual description of the state of the ABQ to the 
mps_lib_FILE  It returns a value of ResOK if it is able to do so.

.impl.c.abq.isempty: ABQIsEmpty takes as an argument an ABQ and returns a 
Bool.  It returns TRUE if the ABQ is empty.

.impl.c.abq.isfull: ABQIsFull takes as an argument an ABQ and returns a Bool.  
It returns TRUE if the ABQ is full.

.impl.c.abq.length: ABQLength takes as an argument an ABQ and returns a Count.  
The return value is the number of items currently in the queue.


PRIVATE METHODS

.impl.c.abq.vectorsize: ABQVectorSize takes as an argument a Count and returns 
a Size.  The result Size is the number of bytes of storage required to hold 
Count queue items.

.impl.c.abq.nextindex: ABQNextIndex takes as an argument an ABQ and an Index 
and returns an Index.  The result Index is the next Index modulo the size of 
the queue.



TESTING:

A test for the ABQ implementation in the C language is in the file 
MMSrc!abqtest.c.  The test creates an ABQ and randomly exercises the push, pop, 
and delete methods by creating dummy annotated CBSBlocks and ensuring the 
blocks popped and deleted are as expected.


TEXT:

This design could easily be generalized to support fixed-length queues for 
other clients.

