              THE DESIGN OF DIAGNOSTIC MEASUREMENTS IN MPS
                           design.mps.metrics
                              draft design
                           gavinm 1998-03-16


INTRODUCTION:

The documents describes what measurements we are collecting about collections 
and other aspects of the system.

.readership: MM developers.


Document History

.hist.0: GavinM started it in March 98, and wrote initial requirements and 
proposed solutions.

.hist.1: Pekka added to it in November 98.  Folded in PTW's 
design.mps.meter(0).  Continued work in February 99, determining the 
architecture and expanding the list of quantities.


OVERVIEW:

This design provides diagnostic measurements for the MPS.  Basically, objects 
and events are counted, sizes of memory blocks are totaled, and the data is 
emitted in telemetry events.

.overview.telemetry: There's always the option of emitting an event for each 
object/event/block of interest, but this is frequently too slow and produces 
too much information.  Instead, this design provides ways to accumulate the 
information and emit a summary of it at suitable intervals.  [better 
integration with telemetry?]

.overview.fields: Mostly, we add diagnostic fields to various objects, to count 
events or objects.  These are updated during the execution, and at some points, 
typically at the end of a trace or a run, their values are emitted in an event.

.overview.meters: For investigating distributions that can be characterized by 
simple statistical means, we provide meters, that collect statistical info.


REQUIREMENTS:

.req.perturb: We must be able to gather measurements without perturbing 
collection policy.

.req.cheap: We must be able to gather measurements without slowing applications 
more than is necessary.  [This interacts with design.mps.variety.  pekka 
1998-11-24]

.req.independent: We must be able to gather measurements without co-operation 
from the application.

.req.output: The measurements should be emitted in some convenient way.

.req.cost: We must be able to determine the cost of a collection with 
reasonable accuracy.

.req.benefit: We should be able to determine the immediate benefit of a 
collection.

.req.decision: The measurements emitted must include the ones that are used in 
the various decisions that the MPS takes, such as data used in benefit 
calculations of collection actions.

.req.modelling: The measurements emitted should include everything mentioned in 
analysis.modelling-kit(0).trace.quantities, within reason.

.req.statistics: We need to gauge distributions of varying quantities, by at 
least count, mean and standard deviation.

.req.count: We also need to count things, like allocations, but not to really 
large quantities.

.req.time: Optionally, it would be nice to get timing measurements, on 
platforms where it is cheap to read the clock.


ARCHITECTURE:

.arch.event.init: Embedded structures, like meters, will have Init events that 
contain the owner.  The type of the owner can vary so it's handled as void *, 
and the event parser needs to find the right type.

.arch.event.value: There's an event to output the contents of a meter.  

.arch.config: The use of diagnostics is controlled by the DIAGNOSTICS flag from 
config.h.

.arch.macrology: STATISTIC_DECL to declare diagnostic fields (for the moment, 
keep the fields in all varieties so that allocation patterns don't change).  
STATISTIC to wrap updates of diagnostic fields, and STATISTIC_WRITE to insert 
diagnostic fields in Describe methods (compile away in some varieties).

.arch.finish: Finish methods emit the values of all diagnostic fields before 
destroying the data.  In addition, events can be explicitly emitted wherever 
it's useful.

.arch.meters: Meters accumulate count and sum, for calculating the mean.  Also, 
sum of squares for deviation, and min and max.  Meters basically measure sizes, 
so totals are doubles, and min and max are Sizes.  For now, we assume this is 
suitable for measuring counts, such as free-list lengths, as well (ATM, Count 
is the same size as Size).


ANALYSIS:

.anal.numerical:  Unfortunately for meters, the on-line method of computing the 
standard deviation is numerically unstable.  Higher moments are more unstable, 
so are not accumulated at all.  To calculate average deviation, skewness and 
kurtosis, telemetry should be used to emit the entire population for off-line 
analysis.


Selection of Quantities

.anal.quantities: It is not possible to accurately predict what quantities we 
might be need to measure in the future.  Nor is it necessary to list them here, 
other than as a proof of concept, or to analyze difficulties.

.anal.age.gen-pool: Any propagation of age ranges per generation would quickly 
spread until it reached the limits set by the promotion policy (and beyond if 
there are nailed objects).  In the worst case, this would be the interval from 
the last collection out of a generation to last promotion into a generation or 
allocation in it.  The limits of the promotion policy can be determined 
directly, so we don't see any great benefit in measuring age ranges at this 
granularity.  Other characterizations of age would be hopelessly nebulous at 
this granularity.

.anal.age.seg-page: We might get some benefit from analyzing this afterwards, 
but it would be little different in cost from tracking each object.  The latter 
could be done already, from the allocation and fix events, were it not 
prohibitively expensive for any reasonable size of test.

.anal.trace: Most of the GC-related quantities mentioned in the solution ideas 
are already being counted, just not emitted.


IDEAS:

.sol.telemetry: Emit events at start and end of collection for collection 
statistics.  Emit events when finishing data structures.

.sol.statistic: Use a macro (call it STATISTIC) to wrap all the code that is 
for diagnostic purposes only.  This can then compile away in varieties where 
statistics are not wanted.

.sol.meter: Meters gather simple statistical information on some random 
variable.  
Meters accumulate 0th - 2nd moments of the population on-line rather than 
emitting the population for off-line analysis.  These moments are used to 
compute the mean and standard deviation of the population.


Quantities to Measure

.sol.current: Initially measure at least the stuff that's already in 
TraceStruct.  Use STATISTIC for anything not needed by something else (like the 
trace rate calculation).

.sol.age.gen-pool: Some characterization of the age of objects in a generation 
or pool could be maintained, say as a range and mean.

.sol.age.seg: As .sol.age.gen-pool, but for segments.  Would need to be 
reported partially and continually, and calculated properly afterwards.

.sol.condemned: The size of the condemned set can be calculated and reported at 
the start, together with whatever characterization of its age was available.

.sol.reclaim: The amount of memory reclaimed can be calculated during reclaim 
and reported at the end, possibly with some characterization of its age.

.sol.foundation: The size of the foundation can be calculated and reported at 
the start, possibly with some characterization of its age.

.sol.scan: The amount of memory scanned can be calculated on the way through, 
and reported at the end.  Likewise, copied and nailed objects, both count and 
size.  Objects preserved by non-moving collectors should be counted separately 
from either copied or nailed.

.sol.fault: Faults handled by the MPS should be counted.

.sol.analysis: Look at the cost of refsets by counting segments scanned 
pointlessly (or almost so).  This can be done by looking at 
ss->whiteSegRefCount for segments with summary=RefSetUNIV.

.sol.grey: Track grey list length and size.  Measure maximums for each trace.  
Protection cost is counted in .sol.scan and .sol.fault.


IMPLEMENTATION:

.code: MMsrc!meter.h, MMsrc!meter.c for meters.  STATISTIC and STATISTIC_WRITE 
defined in mpm.h, STATISTIC_DECL in mpmtypes.h.

.fix.epdl: Make EPDL use STATISTIC for its diagnostics too.

