                DESIGN OF PREFERENCES SYSTEM IN THE MPS
                            design.mps.pref
                           incomplete design
                            nickb 1996-11-21


TEXT:

The requirements for preferences are flexibility, binary compatibility
in the MPS interface (as more preferences become available, and/or old
ones cease to have meaning), and simplicity.

If we need to express preferences about an object type Foo, then there
is an object type FooPref. We have

 Res FooPrefCreate (FooPref *, Space);
 void FooPrefDestroy (FooPref);
 Res FooPrefExpress (FooPref, FooPrefKind, void*);

where FooPrefKind is an integral type taking values from an enum, and
the void * is used to convey any additional information,

and FooCreate now takes an additional argument:

 Res FooCreate(Foo *, FooPref /* , ... */);

Here's a simple example:

 FooPref fp; /* preferences for a Foo */
 Foo f; /* the Foo we're going to create */

 res = FooPrefCreate(space,&fp); /* make a preference record */
 /* check res */

 /* want this foo to be near the one we've already created, bar */
 res = FooPrefExpress(fp, FooPrefNear, (void*)bar);
 /* check res */

 /* also want this foo to prefer wibbles of size WibSize */
 size = WibSize;
 res = FooPrefExpress(fp, FooPrefSize, (void*)&size);
 /* check res */

 /* also want this foo to have Qux behaviour */
 res = FooPrefExpress(fp, FooPrefQux, NULL);
 /* check res */

 res = FooCreate(&f, fp);
 /* check res */

 FooPrefDestroy(fp);
 /* assuming we only use it once; more likely the "owner" of
  * this Foo will want to make many with the same preference */

FooPrefExpress(f,kind,p) is basically switch(kind); some of the
branches take information from p, according to the kind. At the
moment, the default returns ResOK, rather than ResUNIMPL, because that
seems to me to be more sensible (again, binary compatibility, blah).

Unlike other abstract types in the MPS, NULL is a valid FooPref, defined to 
have the same effect as a FooPref which has never had FooPrefExpress applied to 
it. This design choice has the following pros and cons:

+ when one has no preferences, one wastes less time and space
  expressing that fact.
+ bootstrapping is simpler (where would PoolPrefCreate allocate the
  PoolPref for the space control MV Pool?)

- some regularity is lost in the code: FooPrefs are the only (?)
  abstract types for which NULL is a valid value. This is probably a
  dangerous practice.



