             THE DESIGN OF THE MEMORY POOL SYSTEM INTERFACE
                          design.mps.interface
                           incomplete design
                           richard 1995-11-23

INTRODUCTION


Scope

This is the design document for the "Memory Pool System Interface" (MPS 
Interface), the interface between the Memory Pool Manager (MPM) and the client 
code.


Purpose

The primary purpose of the document is to justify the design of the interface 
in terms of requirements, and not to act as user documentation.   User 
documentation should be derived from this document, however.

Actually, this has turned out more descriptive than I wanted, and should be 
split into user documentation and design documentation at some point.


Background

- client requirements [link?]
- the relationship between the MPS, MPM, and the client [link to architecture?].
- interface coding conventions [link?]


Readership

The document is intended for use within the Memory Management Project as part 
of the justification of the product from the requirements.


Document History

- Created 1995-11-21 by Richard Brooksby.


OVERVIEW


Spaces

An object of type "Space" represents the state of the entire MPS.  Creating a 
space starts a "session" with the MPS, and destroying it ends the session.  
During a session the client can create pools and use them to manage memory.

It is possible for the client to create more than one space at once, or one 
after the other.  This is not usually useful, and in general we expect the 
client to create a space at initialization and destroy it on exit.

Spaces do not interact with each other.  Actions performed on one space do not 
affect any other, except in that one may use up global system resources such as 
backing store and deny them to another.


Pools and Pool Classes

A "pool" is a collection of memory "blocks" managed using a particular memory 
management policy.  Blocks are allocated from the pool, and some policies also 
support explicit deallocation.  While a block exists, the memory it occupies is 
managed by the pool using a policy determined by the pool's "class".

Many pools can be created in one space.  The policies for the pools are 
designed to co-exist and will co-operate.  This allows a client to allocate 
sets of blocks for objects using the most appropriate policy or set of policies 
for those objects.

An object of type "PoolClass" represents a memory management policy.  Each pool 
class has different behaviour and is suitable for different purposes.  The 
documentation for the class will indicate which requirements it is intended to 
meet.  The class of a pool, and therefore the policy used to manage its blocks, 
is determined when the pool is created.  In object-oriented terms, pool 
creation is the instantiation of a pool class.

The interface to pools includes a number of "generic methods" which can be 
applied to any pool.  For example, allocating a block (PoolAlloc) is a generic 
method.  The exact semantics of a generic method when applied to a pool are 
determined by the pool's class (so allocation may not mean the same thing for 
all pools) but pool classes are designed so that the semantics are sufficiently 
similar to make many pools interchangeable.  It is this design which allows the 
client programmer to experiment with different pools without major alteration 
of the client code.

A pool class may extend the set of generic methods with class-specific methods 
which may only be applied to pools of that class.


Buffers

Buffers provide a means for a pool to provide fast in-line allocation methods 
to the client.  A buffer is essentially a contiguous chunk of memory which the 
client can allocate itself, provided it follows certain protocol restrictions.

The most important feature of buffered allocation is that it requires no 
explicit synchronization between the MPS and the client (locking, semaphores, 
etc.), provided the architecture has atomic update of words.

Many buffers can be created for allocation in a single pool.  Where the client 
consists of more than one concurrent thread, each thread can use its own buffer 
and allocation can therefore take place without the need for synchronisation 
between threads.

Buffers support a two-phase allocation protocol, which means that pools which 
manage formatted objects can know when a block has been initialized.


Roots

Roots are objects which tell the MPS where to start tracing the graph of the 
client's live objects.  The live objects are the transitive closure by 
reference from the roots.

Each root is a closure for a function which locates and fixes a set of 
references.  The function is called the "root scanning function" and operates 
under special restrictions, as it is called as part of the memory management 
process.


Formats

An object of type "Format" is an object format, and contains information which 
allows a pool to manipulate the objects in the memory blocks it is managing by 
providing information about their layout.  For example, a garbage-collecting 
pool which manages objects which contain references must know how to find the 
references within an object in order to trace the live objects.  The client 
must provide the methods required by the pool, and provide them to the pool in 
a Format object when the pool is created.

The functions provided by the client must operate under special restrictions, 
as they are called as part of memory management processes.

Not all pools require all methods to be provided.  The documentation for the 
pool class will provide more information.

Pools which manage objects by manipulating them via an object format are known 
as "formatted pools".


Location Dependency

The location dependency protocol provides a means for client code to rely on 
the address of objects in situations where the pool might move it.  The most 
common use of this is to implement "pointer hash tables" in garbage-collected 
pools which use object relocation.  If the address of an object is used as part 
of the hashing function, and the object is moved, it may no longer appear in 
the correct bucket and the table must be rehashed.  Location dependency 
minimizes the cost of detecting and correcting this situation.

The location dependency interface has not yet been defined.


Thread Registration

When using certain classes of pool, the MPS must ensure that it has exclusive 
access to memory (for example, when using an incremental garbage collector 
which relocates objects).  To support this, the client must register any 
threads which might access the memory in a space with that space.

Under Win32, it is also necessary for each thread which might access the memory 
in a space to wrap up that access in a Structured Exception Handler 
[reference?], because Win32 provides no means to handle exceptions outside of 
dynamic context.

The thread registration interface has not yet been defined.


Memory Access

Some pool classes use memory protection to provide transparent incremental 
memory management by delaying operations until the client access the memory 
they would affect.  Effectively, this gives the MPS the opportunity to make the 
"load" and "store" operations of the processor part of the MPS Interface.

Of course, the MPS attempts to reduce the number of protection exceptions to a 
minimum, as they reduce the performance of the client.

The MPS Interface includes the "SpaceLoad" and "SpaceStore" methods.  When a 
thread accesses memory which is protected, the fault handling mechanism is used 
to pass control to SpaceLoad or SpaceStore.


GENERAL CONVENTIONS


Opaque Abtract Data Types

Most types exported from the MPS are implemented as opaque abstract data types 
(guide.impl.c.adt).

This prevents access to the MPS structures by client code and thereby avoids 
defects.  [referenfce to quality requirement?]


Macros

Some methods exported from the MPS are implemented as macros.  The macro 
methods behave in all respects as functions, except that their parameters may 
be evaluated more than once.  Where methods are implemented as macros, they are 
backed up by function implementations with the same identifier (see 
guide.impl.c.???).  Undefining them with "#undef" or referring to their 
identifiers in parenthesis will allow access to the function versions (see 
standard.ansic.???).

Macro methods improve the performance of the client.  [but are they really 
necessary?  reference to performance requirement?]


Return Parameters

Methods which need to pass both an error code and one or more results back to 
the caller return  the error code as their result and store the results in 
values pointed to by "return parameters" (guide.impl.c.???).  The identifier of 
a return parameter is always suffixed by "Return" and is always of pointer 
type.  The value pointed to is only ever updated if the method was successful.

This style is used to prevent mistakes in the use of the interface, and thereby 
avoid defects (book.maguire93).  [reference to quality requirement?]


Error Codes

Methods which may "fail" for some reason return an error code as their main 
result.  Error codes are of type "int".  Code zero represents "success" and 
indicates that no error occurred and the method completed successfully.

Error codes are defined as identifiers with the prefix "Err" which expand to 
constant expressions of type "int".  The meaning of each error with respect to 
a particular method is documented with that method.


PROTOCOLS


General Object Creation and Destruction

Instances of a particular ADT are created using a "create" method, the name of 
which is formed by suffixing "Create" to the type name (for example, 
"SpaceCreate").  They are destroyed by calling the "destroy" method, which are 
suffixed by "Destroy" (for example, "SpaceDestroy").

The create method is passed a return parameter which is used to pass back the 
object created, which is generally a pointer to an opaque structure.  Its 
return value is an error code.  The rest of the parameters are specific to the 
ADT.

If the create method succeeds, the object returned is valid for use until it is 
destroyed.

If the create method fails, an error occured which is indicated by the error 
code [documented in the Reference section below?] and the object is not valid 
for use, or for passing to the destroy method.  The client could attempt to 
diagnose the problem from the error code and recover, take evasive action and 
try again, or fail itself.

The destroy method is passed the object, and always succeeds.  After 
destruction, the object is no longer valid, and must not be used in any way.  A 
future create method may return a new object which would compare equal to a 
previously destroyed object (i.e. re-use the object's memory).

Examples

  int e;
  Space space;
  e = SpaceCreate(&space);
  if(e)  <error handling code>
  <code which uses the space>
  SpaceDestroy(space);


Space Creation and Destruction

Description

Creating a space starts a "session" with the MPS.  A space must be created in 
order to create pools, which manage memory blocks.

Every session is independent and there is no interaction between spaces (except 
through use of resources).  A space is a handle on the state of the session, 
including all the system resources allocated to pools within that space.

Destroying a space ends a session, and frees all resources allocated to that 
space.  All pools, roots, formats, etc. which have been created in the space 
must have been individually destroyed before destroying the space itself.

[What about registering the single thread in a single-threaded environment?]

Restrictions

The MPS is designed to expect the client to create a single space for its 
entire run.  However, it will also cope with small numbers of spaces (less than 
10) provided that system resources are available.

Examples

  int e;
  Space space;
  e = SpaceCreate(&space);
  if(e) <error handling code>
  <code which uses the space>
  SpaceDestroy(space);


Pool Creation and Destruction

Description

Creating a pool instantiates a pool class in a space.  Pools must be created in 
order to allocate memory blocks to store objects, since they define the policy 
which will be applied to the memory.

Once the pool has been created, blocks can be allocated from it using the 
"PoolAlloc" method, or by creating a buffer and allocating from it.  Some pool 
classes will not support both of these interfaces.  The documentation for the 
pool class should specify which to use.

Destroying a pool implicitly frees all memory blocks which have been allocated 
from that pool using "PoolAlloc", and frees all resources allocated to the pool.

Restrictions

The MPS is designed to deal with multiple pools simultaneously, including 
multiple instances of the same pool class.  For most applications we anticipate 
less than 100 pools in a space.

Examples

  int e;
  Pool pool;
  e = PoolCreate(&pool, PoolClassMFS(), space, ...);
  if(e) <error handling code>
  <code which uses the pool>
  PoolDestroy(pool);


Allocating and Freeing Blocks

Description

Allocation is a generic method on pools.  Each pool class may impose different 
detailed semantics on allocation, and on the memory blocks allocated from the 
pool.  Consult the pool class documentation for details.  However, most pool 
classes are designed to be similar enough that they are interchangeable, and 
therefore follow this broad description.

Allocation locates a block of memory which is not currently in use by the 
client, and makes it available to the client for storing data or an object.

Once allocated, the client has the right to modify the memory in the block for 
it own purposes.  (Formatted pool classes may restrict the modifications that 
can be made in order to maintain a consistent object representation in the 
block).

In the case of a manually-managed pool, the memory remains "allocated" until 
the client frees it.

In an automatically-managed pool, the memory may be freed (reclaimed and 
recycled) by the MPS at any time if it can prove that the client cannot reach 
the object from the roots.

Freeing the block removes the right of the client to access or modify it, and 
any data it contained must be considered as destroyed.

After freeing a block, a future allocation from any pool may return a block 
whose base address compares equal with it.

Restrictions

The MPS is designed to cope with very large numbers of memory blocks allocated 
from pools.  The number of blocks which may be allocated is essentially 
unbounded.  Bear in mind that each pool class is designed to cope with 
different situations efficiently.

Not all pool classes support allocation through this interface, as it does not 
allow synchronization of initialization of a formatted object.

In a threaded environment allocation by this protocol involves taking a lock, 
and other threads using the same space (or at least the same pool) may be 
delayed if they are also allocating.  In some environments, taking a lock 
involves a system call, so this interface may be considerably less efficient 
than the buffered allocation protocol.

Examples

  int e;
  void *p;
  e = PoolAlloc(&p, pool, sizeof(struct foo));
  if(e) ...
  ...
  PoolFree(pool, p, sizeof(struct foo));


Buffer Creation and Destruction

Description

Creating a buffer creates an optimized communication channel between a pool and 
the client which allows the client to perform fast in-line allocation while 
providing for the synchronization of initialization of formatted objects.

Once the buffer is created, the client may allocate memory from it using the 
buffered allocation protocol [see below?].

Destroying the buffer destroys the communication channel, but does _not_ free 
any blocks which have been allocated from it.  It does, however, allow the pool 
to re-use any memory remaining in the buffer and free resources allocated to it.

Restrictions

The MPS is designed to cope with an allocation buffer for each thread in the 
client.  Consult system documentation for the upper bounds.

Each allocation buffer locks down a certain amount of memory resources.  
Creating many buffers may prevent the pool from making good use of memory.  Be 
sure to destroy buffers when they are no longer required, especially on thread 
exit.

Not all pool classes support allocation buffers.

Examples

  int e;
  Buffer buffer;
  e = BufferCreate(&buffer, pool);
  if(e) ...
  ...
  BufferDestroy(buffer);


Allocating from a Buffer

Description of High Level

An allocation buffer is an interface to a pool which provides very fast 
allocation, and defers the need for synchronization in a multi-threaded 
environment.

Allocation locates a block of memory which is not currently in use by the 
client, and makes it available to the client for storing data or an object.

Buffered allocation is done in two phases, known as "reserve" and "commit", in 
order to allow the pool to synchronize with both the allocation of a block and 
the initialization of the object stored in it.  The reserve operation allocates 
the block, and the commit operation notifies the pool that is has been 
initialized and contains an object in a valid format.

[This two-phase approach is only required for formatted pools.  Efficient 
buffer allocation may be useful for other pools.  If the requirement arises, we 
must provide a single-phase protocol. -- richard 1995-11-24]

Once reserved, the client has the right to modify the memory in the block in 
order to initialize objects in the block into valid format for the pool.  Once 
the objects are initialized the block must be committed in order for the pool 
to start managing the objects, and before further allocation can take place in 
the buffer.

Under certain conditions, some pools may cause the commit operation to fail.  
(See the documentation for the pool.)  Failure to commit indicates that the 
whole allocation failed and must be restarted.  The MPS is designed to make 
these events as rare as possible.

Once allocated, the block obeys the same protocol as a block allocated under 
the "Allocation and Freeing" protocol above.

Description of Low Level

An allocation buffer is an area of memory which is pre-allocated from a pool, 
plus a buffer descriptor, which contains, inter alia, four pointers: base, 
init, alloc, and limit.  Base points to the base address of the area, limit to 
the last address plus one.  Init points to the first uninitialized address in 
the buffer, and alloc points to the first unallocated address.



Access to these pointers is restricted in order to allow synchronization 
between the pool and the client.  The client may only write to init and alloc, 
but in a restricted and atomic way detailed below. The pool may read the 
contents of the buffer descriptor at _any_ time.  During calls to the 
"BufferFill" or "BufferTrip" methods, the pool may update any or all of the 
fields in the buffer descriptor.  The pool may update the limit at _any_ time.

Only one thread may use a buffer at once, unless the client places a mutual 
exclusion around the buffer access in the usual way.  In such cases it is 
usually better to create one buffer for each thread.

Here is a pseudo-C description of the reserve operation on a buffer.  This code 
may be in-lined into the client, provided that the same (or equivalent) tests 
are performed and the update of the buffer pointers is atomic.

  Reserve(void **pReturn, Buffer buffer, size_t size)
    next = buffer->alloc + size;
    if(next > buffer->alloc && next <= buffer->limit) {
      buffer->alloc = next;               /* ATOMIC UPDATE */
      *pReturn = buffer->init;
      e = ErrSUCCESS;
    } else
      e = BufferFill(pReturn, buffer, size);

This is a pseudo-C description of the commit operation.  This code may be 
in-lined into the client, provided that the order of the update of init and 
test of the limit is preserved.  [What about the memory barrier on the ALPHA?]

  Commit(Buffer buffer, void *p, size_t size)
    buffer->init = buffer->alloc;         /* ATOMIC UPDATE */
    if(buffer->limit == 0)
      b = BufferTrip(buffer, p, size);
    else
      b = TRUE;

Restrictions

Examples

  void *p;
  do {
    int e;
    e = BufferReserve(&p, buffer, sizeof(struct foo));
    if(e) ...
    initialize(p);
  } while(!BufferCommit(buffer, p, sizeof(struct foo));


Root Creation and Destruction

Description

Creating a root informs the MPS of the existence of a set of references to 
objects allocated in automatically-managed pools which must be considered 
"live".  Objects that are referenced directly or indirectly from a root will 
not be automatically reclaimed.

A root is created out of a "scanning function" which is responsible for 
locating the references and applying a "fix method" to them.

While a root exists in a space, the MPS may call the scanning function at any 
time.  The scanning function must operate under certain restrictions [ah, but 
what are they?].

Destroying a root removes the set of references from consideration by the MPS.  
The scanning function will not be called once the root is destroyed.

Examples

  int e;
  Root root;
  e = RootCreate(&root, space, RefRankAMBIG,
                 RootModeATOMIC | RootModeMUTABLE,
                 scanStack, stackDescs, 3);
  if(e) ...
  ...
  RootDestroy(root);


Root Scanning and Restrictions


Format Creation and Destruction


Format Methods and Restrictions


Location Dependency


Thread Registration


REFERENCE

Buffer
BufferCommit
BufferCreate
BufferDestroy
BufferReserve
ErrIO
ErrLIMIT
ErrRESMEM
ErrRESOURCE
ErrSUCCESS
ErrUNIMPL
Format
FormatCreate
FormatDestroy
Pool
PoolAlloc
PoolClass
PoolCreate
PoolCreate
PoolDestroy
PoolDestroy
PoolFree
RefRank
RefRankAMBIG
RefRankEXACT
RefRankFINAL
RefRankWEAK
RootCreate
RootCreateTable
RootDestroy
RootMode
RootModeATOMIC
RootModeFIXABLE
RootModeMUTABLE
Space
SpaceCreate
SpaceDestroy

