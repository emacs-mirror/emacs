From: David Thomas Eger <eger@cc.gatech.edu>
Subject: Re: Suspending Thread & Resuming Thread Repost!!!
Date: Fri, 13 Aug 1999 13:08:58 -0400
To: Raymond Lau <rlau@csc.com>
Newsgroups: comp.programming.threads

This is a multi-part message in MIME format.
--------------6A2344DB6B627FFAE364BB4B
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

I wrote David Butenhof this morning about just that program, and here is
his reply:

- David Eger

-------------------------------------------

Date: Fri, 13 Aug 1999 09:14:36 -0400
From: Dave Butenhof <David.Butenhof@compaq.com>
To: David Thomas Eger <eger@cc.gatech.edu>
Subject: Re: Thread suspension example


David Thomas Eger wrote:

> I was wondering about your program "susp.c" in "Programming with POSIX
> Threads, specifically the suspend_signal_handler.  How do we know that
> the signal handler couldn't be interrupted between:
>
>     sentinel = 1;
>
> and
>
>     sigsuspend (&signal_set);
>
> That is, what if the timeslice ends after sentinel = 1; and the program
> continues to a point where it tells the thread to resume, only the thread

> isn't waiting for the signal yet, because it hasn't executed sigsuspend()

> yet?  If we only send resume once, we're sort of stuck, aren't we?

Yes, but it really doesn't have anything to do with timeslicing; for
example, on an SMP, both threads could be running simultanteously.

I've known for a long time that the susp.c program had bugs. (As I said in
the footnote, it wasn't written by me. Unfortunately, since I chose to
publish it, I can't exactly say that absolves me of responsibility for the
errors. Oh well. ;-) )

Anyway, one particularly major error is that the signal handler for SIGUSR1

is set up incorrectly. The race can be resolved by setting sa_mask to block

both SIGUSR1 and SIGUSR2 until the sigsuspend call unblocks SIGUSR2. In
practice, this doesn't happen easily or often. The susp.c program was being

developed as a sample to show our Java team how to do Java's suspend/resume

(especially for garbage collection). It was intended to be just a quick
sample to get them started. I was just finishing the book. I wasn't very
happy with the completely artificial and useless pthread_kill example
program I'd written, and I knew many people would be interested in
asynchronous suspend/resume (however bad an idea that may be!), so I
decided
to switch to susp.c. It "seemed to work" in initial testing, and I didn't
have the time to try to completely rewrite it. (Though there were several
aspects I'd have liked to change, including using semaphores for a more
reliable suspend synchronization mechanism.) Of course, the more something
like that is used, the more the seams start splitting open, and it wasn't
long before Java's attempts to actually use the mechanism started showing
errors.

On and off, I've been working on a bunch of corrections for the next
printing. (And I'd like to find time to start on a second edition, but
that's another story.) I've been fixing some of the examples, and I did a
substantial amount of work on susp.c. What I have now is a fixed but only
partly "cleaned up" version to fix the worst of the problems without too
much change. I'll include the new code as an attachment.

By the way, if you've got a version of the book earlier than the 3rd
printing, you might want to take a look at the Errata list. I really need
to
find time to figure out who to talk to about posting it on the awl web
site,
but, right now, you can find it at
http://members.aol.com/drbutenhof/Errata.html.


/---------------------------[ Dave Butenhof ]--------------------------\
| Compaq Computer Corporation                David.Butenhof@compaq.com |
| 110 Spit Brook Rd ZKO2-3/Q18       http://members.aol.com/drbutenhof |
| Nashua NH 03062-2698  http://www.awl.com/cseng/titles/0-201-63392-2/ |
\-----------------[ Better Living Through Concurrency ]----------------/


<<< susp.c was attached >>>


8<-------------------------------------------------------

From: Dave Butenhof <David.Butenhof@compaq.com>
Subject: Re: Problem with Suspend & Resume Thread Example
Date: Mon, 16 Aug 1999 13:31:16 -0400
To: Raymond Lau <rlau@csc.com>
Newsgroups: comp.programming.threads

Raymond Lau wrote:

> Mr. Butenhof has provided a cleaner version of the
> susp.c in which functions for suspending and resume
> a thread is defined.   Please see reference below.
>
> I compiled his updated example and it run fined.  But
> it find his solution troublesome.  If anyone can clarify
> that for me, I would be appreciated.
>
> 1) The suspend_init_routine() is initialized by pthread_once()
>      which is inside thr_suspend() and thr_continue().
>      In his example, thr_suspend() and thr_contine() are called
>     by the main thread.  But since the worker threads are already
>     created.  I am not sure whether their signal masks would be
>     updated accordingly?

The pthread_once() routine doesn't change any thread's signal mask. It
defines signal actions for two signals (SIGUSR1 as "suspend" and SIGUSR2 as
"resume"). The fixed code (unlike the original) assigns a non-default
signal mask to the signal action. That means, when the SIGUSR1 signal is
delivered to the thread, SIGUSR2 and SIGUSR1 will both be masked. (The
default is to mask only the signal being delivered, SIGUSR1, which resulted
in the race where the SIGUSR2 might be sent after the suspend handler had
"acknowledged" the suspend by setting the volatile variable but before it
called sigsuspend.)

Any SIGUSR1 delivered prior to the init routine wouldn't have the proper
mask. But then, it would have to be a SIGUSR1 from some other source, since
the signal action is set at the same time.

> 2)  Can a thread can thr_suspend() in order to suspend itself?
>       If it can and it's the first one to call thr_suspend() or
>       thr_continue().  With the signal masks of other threads
>       be updated accordingly?

Again, this doesn't matter. There's no attempt to modify the signal mask of
any thread. (Except indirectly through the normal kernel mechanism for
signal delivery.)

> 3) Seems to me that after a specific thread is suspended and
>     resumed, suspending it again would not work.

Why? If you're worried about the signal mask, don't. Returning from the
signal action routine will cause the kernel to restore the thread's
previous signal mask. (Unblocking both SIGUSR1 and SIGUSR2.)

As I said, this is a "work in progress", from one brief session when I
found some time to fix the worst of the known problems. I hadn't really
intended the current code to go any further than my working directory.
Since this issue came up, I decided I might as well -- I believe it's "no
worse than" the original, and it does fix several serious problems. If you
do see any real errors in the new code, of course, please let me know.

/---------------------------[ Dave Butenhof ]--------------------------\
| Compaq Computer Corporation                David.Butenhof@compaq.com |
| 110 Spit Brook Rd ZKO2-3/Q18       http://members.aol.com/drbutenhof |
| Nashua NH 03062-2698  http://www.awl.com/cseng/titles/0-201-63392-2/ |
\-----------------[ Better Living Through Concurrency ]----------------/



