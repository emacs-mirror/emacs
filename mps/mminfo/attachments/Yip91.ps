%!PS-Adobe
%%Title: thesis.mss
%%DocumentFonts: (atend)
%%Creator: G. May Yip,Yip Unit,,,6172259778 and Scribe 7(1700)
%%CreationDate: 24 May 1991 11:38
%%Pages: (atend)
%%EndComments
% PostScript Prelude for Scribe.
/BS {/SV save def 0.0 792.0 translate .01 -.01 scale} bind def
/ES {showpage SV restore} bind def
/SC {setrgbcolor} bind def
/FMTX matrix def
/RDF {WFT SLT 0.0 eq 
  {SSZ 0.0 0.0 SSZ neg 0.0 0.0 FMTX astore}
  {SSZ 0.0 SLT neg sin SLT cos div SSZ mul SSZ neg 0.0 0.0 FMTX astore}
  ifelse makefont setfont} bind def
/SLT 0.0 def
/SI { /SLT exch cvr def RDF} bind def
/WFT /Courier findfont def
/SF { /WFT exch findfont def RDF} bind def
/SSZ 1000.0 def
/SS { /SSZ exch 100.0 mul def RDF} bind def
/AF { /WFT exch findfont def /SSZ exch 100.0 mul def RDF} bind def
/MT /moveto load def
/XM {currentpoint exch pop moveto} bind def
/UL {gsave newpath moveto dup 2.0 div 0.0 exch rmoveto
   setlinewidth 0.0 rlineto stroke grestore} bind def
/LH {gsave newpath moveto setlinewidth
   0.0 rlineto
   gsave stroke grestore} bind def
/LV {gsave newpath moveto setlinewidth
   0.0 exch rlineto
   gsave stroke grestore} bind def
/BX {gsave newpath moveto setlinewidth
   exch
   dup 0.0 rlineto
   exch 0.0 exch neg rlineto
   neg 0.0 rlineto
   closepath
   gsave stroke grestore} bind def
/BX1 {grestore} bind def
/BX2 {setlinewidth 1 setgray stroke grestore} bind def
/PB {/PV save def newpath translate
    100.0 -100.0 scale pop /showpage {} def} bind def
/PE {PV restore} bind def
/GB {/PV save def newpath translate rotate
    div dup scale 100.0 -100.0 scale /showpage {} def} bind def
/GE {PV restore} bind def
/FB {dict dup /FontMapDict exch def begin} bind def
/FM {cvn exch cvn exch def} bind def
/FE {end /original-findfont /findfont load def  /findfont
   {dup FontMapDict exch known{FontMapDict exch get} if
   original-findfont} def} bind def
/BC {gsave moveto dup 0 exch rlineto exch 0 rlineto neg 0 exch rlineto closepath clip} bind def
/EC /grestore load def
/SH /show load def
/MX {exch show 0.0 rmoveto} bind def
/W {0 32 4 -1 roll widthshow} bind def
/WX {0 32 5 -1 roll widthshow 0.0 rmoveto} bind def
/RC {100.0 -100.0 scale
612.0 0.0 translate
-90.0 rotate
.01 -.01 scale} bind def
/URC {100.0 -100.0 scale
90.0 rotate
-612.0 0.0 translate
.01 -.01 scale} bind def
/RCC {100.0 -100.0 scale
0.0 -792.0 translate 90.0 rotate
.01 -.01 scale} bind def
/URCC {100.0 -100.0 scale
-90.0 rotate 0.0 792.0 translate
.01 -.01 scale} bind def
%%EndProlog

%%Page: 0 1
BS
0 SI
10 /Times-Roman AF
27378 4286 MT
(J U N E  1 9 9 1)SH
40 /Times-Bold AF
14400 12400 MT
(WRL)SH
14400 16120 MT
(Research Report 91/8)SH
/Times-Roman SF
14400 33344 MT
(Incremental,)SH
14400 37164 MT
(Generational)SH
14400 40984 MT
(Mostly-Copying)SH
14400 44804 MT
(Garbage Collection)SH
14400 48624 MT
(in Uncooperative)SH
14400 52444 MT
(Environments)SH
18 /Times-Italic AF
14400 60418 MT
(G. May Yip)SH
1 SS 
7 9000 72007 PB 
%%BeginDocument: //usr/local/lib/ps/wrlnpage.psh
%!                      % magic number--identifies it as a PS file
% this is the WRL Note cover blurb for WRL Notes that are formatted with a
% binding margin for doublesided printing.

50 dict begin
-18 0 translate
/verylight 0.95 def
/lightgray 0.8 def
/darkgray  0.1 def
/inch {72 mul} def
 /gstring (g) def
/logo {gsave % create a 1 unit high digital logo
  /Helvetica-Bold findfont [.6 0 0 .75 0 0] makefont setfont
   -3.425 2 div 0 translate
  /box {
    newpath
    0 0 moveto
    .425 0 lineto
    0 1 rlineto
    0 1 lineto
    closepath darkgray setgray fill
    word exch 1 getinterval
    1 setgray
    dup stringwidth pop .425 exch sub 2 div .225 moveto
    dup gstring eq {0 .05 rmoveto} if
    show
    } def
  /boxstr {gsave
    /word exch def
    0 1 word length 1 sub {box .5 0 translate} for
    grestore} def

  (digital) boxstr
  grestore} def
-72 -72 translate
gsave 95 26 translate 22 dup scale logo grestore
141 34 moveto
/Times-Bold findfont [11.2 0 0 12 0 0] makefont setfont
(Western Research Laboratory  ) show
/Times-Roman findfont [11.2 0 0 12 0 0] makefont setfont
( 250 University Avenue  ) show
( Palo Alto, California 94301 USA) show

/plock {transform 0.5 add cvi exch 0.5 add cvi exch itransform} bind def
/mt {plock moveto} bind def
/lt {plock lineto} bind def
0.25 setlinewidth
139  24 mt 558  24 lt stroke
139  50 mt 558  50 lt stroke
 31  24 mt  31 738 lt 582 738 lt 582 24 lt stroke 
139 604 mt 558 604 lt stroke
139 714 mt 558 714 lt stroke
1 setlinewidth
133 133 mt 133 488 lt stroke
% currentscreen 3 -1 roll 2 div 3 1 roll setscreen
12 setlinewidth 0.5 setgray
 55  66 moveto 558  66 lineto stroke
 55 588 moveto 558 588 lineto stroke
end 

%%EndDocument
 PE ES
%%Page: 0 2
BS
0 SI
11 /Times-Roman AF
10200 7955 MT
(The Western Research Laboratory \050WRL\051 is)
107 W( a computer systems research group that)106 W
9000 9151 MT
(was founded)
94 W( by Digital Equipment Corporation in 1982. Our focus is computer science)95 W
9000 10347 MT
(research relevant to the design and application of high performance scientific computers.)46 W
9000 11543 MT
(We test our ideas)
89 W( by designing, building, and using real systems. The systems we build)90 W
9000 12739 MT
(are research prototypes; they are not intended to become products.)SH
10200 14912 MT
(There is)
32 W( a second research laboratory located in Palo Alto, the Systems Research Cen-)31 W
9000 16108 MT
(ter \050SRC\051. Other Digital research groups are located)
125 W( in Paris \050PRL\051 and in Cambridge,)126 W
9000 17304 MT
(Massachusetts \050CRL\051.)SH
10200 19477 MT
(Our research is directed towards mainstream high-performance computer systems. Our)18 W
9000 20673 MT
(prototypes are intended to)
53 W( foreshadow the future computing environments used by many)54 W
9000 21869 MT
(Digital customers. The)
77 W( long-term goal of WRL is to aid and accelerate the development)76 W
9000 23065 MT
(of high-performance uni- and)
126 W( multi-processors. The research projects within WRL will)127 W
9000 24261 MT
(address various aspects of high-performance computing.)SH
10200 26434 MT
(We believe that significant advances in computer systems do not come from)
5 W( any single)4 W
9000 27630 MT
(technological advance. Technologies, both hardware and software,)
79 W( do not all advance at)80 W
9000 28826 MT
(the same pace. System design is the art of composing systems which use)
119 W( each level of)118 W
9000 30022 MT
(technology in an appropriate balance.)
151 W( A major advance in overall system performance)152 W
9000 31218 MT
(will require reexamination of all aspects of the system.)SH
10200 33391 MT
(We do work in the design, fabrication and packaging of)
1 W( hardware; language processing)SH
9000 34587 MT
(and scaling issues)
173 W( in system software design; and the exploration of new applications)174 W
9000 35783 MT
(areas that are opening up with the advent of higher performance systems.)
58 W( Researchers at)57 W
9000 36979 MT
(WRL cooperate closely and move freely among the various levels of system design.)
29 W( This)30 W
9000 38175 MT
(allows us to explore a wide range of tradeoffs to meet system goals.)SH
10200 40126 MT
(We publish the results of our work in a)
222 W( variety of journals, conferences, research)221 W
9000 41322 MT
(reports, and technical notes.  This)
156 W( document is a research report. Research reports are)157 W
9000 42518 MT
(normally accounts of completed)
33 W( research and may include material from earlier technical)32 W
9000 43714 MT
(notes. We)
577 W( use technical notes for rapid distribution of technical material; usually)
151 W( this)152 W
9000 44910 MT
(represents research in progress.)SH
10200 46861 MT
(Research reports and technical)
154 W( notes may be ordered from us.  You may mail your)153 W
9000 48057 MT
(order to:)SH
11200 49709 MT
(Technical Report Distribution)SH
11200 50905 MT
(DEC Western Research Laboratory, WRL-2)SH
11200 52101 MT
(250 University Avenue)SH
11200 53297 MT
(Palo Alto, California 94301)
SH( USA)550 W
9000 54949 MT
(Reports and notes may)
203 W( also be ordered by electronic mail. Use one of the following)204 W
9000 56145 MT
(addresses:)SH
12600 58537 MT
(Digital E-net:)SH
/Courier SF
27000 XM
(DECWRL::WRL-TECHREPORTS)SH
/Times-Roman SF
12600 60929 MT
(Internet:)SH
/Courier SF
27000 XM
(WRL-Techreports@decwrl.dec.com)SH
/Times-Roman SF
12600 63321 MT
(UUCP:)SH
/Courier SF
27000 XM
(decwrl!wrl-techreports)SH
/Times-Roman SF
9000 65073 MT
(To obtain more details)
136 W( on ordering by electronic mail, send a message to one of these)135 W
9000 66269 MT
(addresses with the word ``)101 W
/Courier SF
(help)SH
/Times-Roman SF
('' in the Subject line; you will receive detailed instruc-)101 W
9000 67465 MT
(tions.)SH
ES
%%Page: 1 3
BS
0 SI
20 /Times-Bold AF
13929 19340 MT
(Incremental, Generational Mostly-Copying)SH
23011 21652 MT
(Garbage Collection in)SH
19873 23964 MT
(Uncooperative Environments)SH
16 SS 
28377 30012 MT
(G. May Yip)SH
14 SS 
29036 35644 MT
(June , 1991)SH
/Times-Roman SF
17983 58720 MT
(Copyright)SH
/Symbol SF
24011 XM
(\323)SH
/Times-Roman SF
25817 XM
(1991, Digital Equipment Corporation)SH
1 SS 
7 9000 72007 PB 
%%BeginDocument: //usr/local/lib/ps/wrltpage.psh
%!                      % magic number--identifies it as a PS file
50 dict begin
/verylight 0.95 def
/lightgray 0.8 def
/darkgray  0.1 def
/inch {72 mul} def
 /gstring (g) def
/logo {gsave % create a 1 unit high digital logo
  /Helvetica-Bold findfont [.6 0 0 .75 0 0] makefont setfont
   -3.425 2 div 0 translate
  /box {
    newpath
    0 0 moveto
    .425 0 lineto
    0 1 rlineto
    0 1 lineto
    closepath darkgray setgray fill
    word exch 1 getinterval
    1 setgray
    dup stringwidth pop .425 exch sub 2 div .225 moveto
    dup gstring eq {0 .05 rmoveto} if
    show
    } def

  /boxstr {gsave
    /word exch def
    0 1 word length 1 sub {box .5 0 translate} for
    grestore} def

  (digital) boxstr
  grestore} def
0.0 inch -0.33 inch translate
gsave 22 dup scale logo grestore
0.7 inch 0.1 inch moveto

/Times-Bold findfont 12 scalefont setfont
(Western Research Laboratory  ) show
/Times-Roman findfont 12 scalefont setfont
( 250 University Avenue  ) show
( Palo Alto, California 94301 USA) show
end 

%%EndDocument
 PE ES
%%Page: i 4
BS
0 SI
10 /Times-Roman AF
32261 75600 MT
(i)SH
ES

%%Page: 1 1
BS
0 SI
16 /Times-Bold AF
10868 8272 MT
(INCREMENTAL, GENERATIONAL MOSTLY-COPYING)SH
21977 10648 MT
(GARBAGE COLLECTION)SH
16623 13024 MT
(IN UNCOOPERATIVE ENVIRONMENTS)SH
12 /Times-Roman AF
31044 15053 MT
(by)SH
28761 17345 MT
(G. May Yip)SH
22893 19528 MT
(B.S. Computer Science, MIT \0501990\051)SH
21926 20814 MT
(B.S. Electrical Engineering, MIT \0501990\051)SH
17032 24472 MT
(SUBMITTED TO THE DEPARTMENT OF ELECTRICAL)SH
16599 26844 MT
(ENGINEERING AND COMPUTER SCIENCE IN PARTIAL)SH
17898 29216 MT
(FULFILLMENT OF THE REQUIREMENTS FOR THE)SH
28362 31588 MT
(DEGREE OF)SH
9317 33697 MT
(MASTER OF SCIENCE IN ELECTRICAL ENGINEERING AND COMPUTER SCIENCE)SH
29528 36206 MT
(AT THE)SH
18165 38715 MT
(MASSACHUSETTS INSTITUTE OF TECHNOLOGY)SH
29194 41224 MT
(May 1991)SH
18985 43796 MT
(Copyright)SH
/Symbol SF
24153 XM
(\323)SH
/Times-Roman SF
25401 XM
(G. May Yip, 1991.  All rights reserved.)SH
16176 45082 MT
(The author hereby grants to MIT permission to reproduce and to)SH
19773 46368 MT
(distribute copies of this thesis in whole or in part.)SH
9288 51428 MT
(Signature of Author)SH
34811 50 19189 51628 UL
24798 52714 MT
(Department of Electrical Engineering and Computer Science)SH
47300 54000 MT
(May 10, 1991)SH
9288 56828 MT
(Certified by)SH
38644 50 15356 57028 UL
45701 58114 MT
(David K. Gifford)SH
42798 59400 MT
(Faculty Thesis Advisor)SH
9288 62228 MT
(Certified by)SH
38644 50 15356 62428 UL
46897 63514 MT
(Joel F. Bartlett)SH
41000 64800 MT
(VI-A Company Supervisor)SH
9288 67628 MT
(Accepted by)SH
38380 50 15620 67828 UL
46231 68914 MT
(Arthur C. Smith)SH
35197 70200 MT
(Chairman, Graduate Thesis Committee)SH
ES
%%Page: 2 2
BS
0 SI
16 /Times-Bold AF
10868 10648 MT
(INCREMENTAL, GENERATIONAL MOSTLY-COPYING)SH
21977 13024 MT
(GARBAGE COLLECTION)SH
16623 15400 MT
(IN UNCOOPERATIVE ENVIRONMENTS)SH
12 /Times-Roman AF
31044 17972 MT
(by)SH
28761 20544 MT
(G. May Yip)SH
12924 23939 MT
(Submitted to the Department of Electrical Engineering and Computer Science)SH
13074 25225 MT
(on May 10, 1991 in Partial Fulfillment of the Requirements for the Degree of)SH
15576 26511 MT
(Master of Science in Electrical Engineering and Computer Science)SH
14 /Times-Bold AF
29039 32335 MT
(Abstract)SH
12 SS 
9288 34571 MT
(The thesis of this project is)
324 W( that incremental collection can be done feasibly and)323 W
9288 35857 MT
(efficiently in an architecture and)
318 W( compiler independent manner.  The design and)319 W
9288 37143 MT
(implementation of)
160 W( an incremental, generational mostly-copying garbage collector for)159 W
9288 38429 MT
(C++ is presented.  The collector achieves, simultaneously, real-time performance)
24 W( \050from)25 W
9288 39715 MT
(incremental collection\051, low total garbage collection delay \050from)
676 W( generational)675 W
9288 41001 MT
(collection\051, and the ability)
130 W( to function without hardware and compiler support \050from)131 W
9288 42287 MT
(mostly-copying collection\051.)SH
9288 44859 MT
(The incremental collector runs on commercially-available uniprocessors,)
175 W( such as the)174 W
9288 46145 MT
(DECStation 3100, without any special hardware)
470 W( support.  It uses U)471 W
10 SS 
(NIX)SH
12 SS 
('s user)471 W
9288 47431 MT
(controllable page protection facility)
132 W( \050)131 W
/Courier SF
(mprotect)SH
/Times-Bold SF
(\051 to synchronize between the scanner)131 W
9288 48717 MT
(\050of the collector\051)
183 W( and the mutator \050of the application program\051.  Its implementation)184 W
9288 50003 MT
(does not require any modification to the C++ compiler.)
337 W( The)
972 W( maximum garbage)336 W
9288 51289 MT
(collection pause is well)
556 W( within the 100-millisecond limit imposed by real-time)557 W
9288 52575 MT
(applications executing on)
131 W( interactive workstations.  Compared to its non-incremental)130 W
9288 53861 MT
(version, the total execution time of the incremental collector is not adversely affected.)SH
/Times-Roman SF
9288 60942 MT
(Faculty Thesis Advisor:)SH
23088 XM
(David K. Gifford)SH
9288 62228 MT
(Title:)SH
23088 XM
(Professor of Electrical Engineering and Computer Science)SH
9288 63514 MT
(VI-A Company Supervisor:)SH
23088 XM
(Joel F. Bartlett)SH
9288 64800 MT
(Title:)SH
23088 XM
(Computer Research Scientist, Digital Equipment Corporation)SH
ES
%%Page: 3 3
BS
0 SI
14 /Times-Bold AF
28416 11947 MT
(Dedication)SH
12 /Times-Roman AF
9288 16370 MT
(To Mom and Dad, who are always loving)
67 W( and supportive.  Not words alone can adequately)68 W
9288 17656 MT
(express the kind of appreciation and love I have for you.)SH
10 SS 
31061 75600 MT
(-3-)SH
ES
%%Page: 4 4
BS
0 SI
14 /Times-Bold AF
26433 11947 MT
(Acknowledgment)SH
12 /Times-Roman AF
9288 16370 MT
(My company supervisor, Joel)
137 W( Bartlett, has been very helpful to me during my three VI-A)136 W
9288 17656 MT
(internship assignments at DEC Western Research Laboratory.)
361 W( Bartlett)
1024 W( is not just an)362 W
9288 18942 MT
(excellent boss, giving me advice and support whenever I)
170 W( need guidance, but he is also a)169 W
9288 20228 MT
(terrific friend.  I have never had a boss)
59 W( who would fix my bike and listen to my complaints)60 W
9288 21514 MT
(about landlord/tenant problems.  He is the kind of boss who is not just)
38 W( concerned with work)37 W
9288 22800 MT
(performance, but is also concerned with)
164 W( other aspects of a summer intern's life.  Bartlett)165 W
9288 24086 MT
(debugged early drafts of this thesis and gave me useful feedback which improved the)293 W
9288 25372 MT
(presentation of the final version significantly.)SH
9288 27944 MT
(I would like)
213 W( to thank my faculty thesis advisor, David Gifford, who has been an active)214 W
9288 29230 MT
(advisor even though he was at MIT, and I)
51 W( was doing my thesis project some three thousand)50 W
9288 30516 MT
(miles away.  He read my e-mail messages carefully and provided)
224 W( me with questions to)225 W
9288 31802 MT
(further investigate.  Gifford helped improve the presentation of this thesis.  Thank)
60 W( you very)59 W
9288 33088 MT
(much.)SH
9288 35660 MT
(I would also like to thank all my friends who)
152 W( have helped preserve my sanity during my)153 W
9288 36946 MT
(MIT days.  They are the ones with whom I've spent most of)
140 W( my nocturnal days -- eating)139 W
9288 38232 MT
(Wing-It, doing problem sets, or talking)
233 W( about personal problems.  I can't imagine what)234 W
9288 39518 MT
(campus life would be like without them.)SH
10 SS 
31061 75600 MT
(-4-)SH
ES
%%Page: 5 5
BS
0 SI
14 /Times-Bold AF
26316 11947 MT
(Table of Contents)SH
12 SS 
9288 16351 MT
(Abstract)SH
53400 XM
(2)SH
9288 17883 MT
(Dedication)SH
53400 XM
(3)SH
9288 19415 MT
(Acknowledgment)SH
53400 XM
(4)SH
9288 20947 MT
(Table of Contents)SH
53400 XM
(5)SH
9288 22479 MT
(List of Tables)SH
53400 XM
(7)SH
9288 24011 MT
(List of Figures)SH
53400 XM
(8)SH
9288 26071 MT
(1. Introduction and Related Work)SH
53400 XM
(9)SH
/Times-Roman SF
11088 27622 MT
(1.1 Mostly-Copying Collection)SH
52800 XM
(10)SH
11088 28824 MT
(1.2 Generational Collection)SH
52800 XM
(12)SH
11088 30026 MT
(1.3 Incremental Collection)SH
52800 XM
(13)SH
/Times-Bold SF
9288 32086 MT
(2. Bartlett's Generational Mostly-Copying Collector)SH
52800 XM
(16)SH
/Times-Roman SF
11088 33637 MT
(2.1 Programming Interface in C++)SH
52800 XM
(16)SH
11088 34839 MT
(2.2 Summary of Bartlett's Collection Algorithm)SH
52800 XM
(18)SH
13488 36041 MT
(2.2.1 Spaces)SH
52800 XM
(19)SH
13488 37243 MT
(2.2.2 Allocation)SH
52800 XM
(20)SH
13488 38445 MT
(2.2.3 Collection)SH
52800 XM
(21)SH
/Times-Bold SF
9288 40505 MT
(3. Incremental, Generational Mostly-Copying Collection)SH
52800 XM
(25)SH
/Times-Roman SF
11088 42056 MT
(3.1 The Big Picture)SH
52800 XM
(25)SH
11088 43258 MT
(3.2 An Incremental, Generational Mostly-Copying Collector)SH
52800 XM
(28)SH
13488 44460 MT
(3.2.1 Special Considerations)SH
52800 XM
(28)SH
15888 45662 MT
(3.2.1.1 Space Numbers)SH
52800 XM
(28)SH
15888 46864 MT
(3.2.1.2 Heap Size and Heap Page Size)SH
52800 XM
(29)SH
15888 48066 MT
(3.2.1.3 Allocation)SH
52800 XM
(30)SH
15888 49268 MT
(3.2.1.4 Miscellaneous Bookkeeping)SH
52800 XM
(30)SH
13488 50470 MT
(3.2.2 Before GC)SH
52800 XM
(31)SH
13488 51672 MT
(3.2.3 Start GC)SH
52800 XM
(31)SH
15888 52874 MT
(3.2.3.1 Protecting Objects)SH
52800 XM
(32)SH
15888 54076 MT
(3.2.3.2 Forward Region)SH
52800 XM
(33)SH
13488 55278 MT
(3.2.4 During GC)SH
52800 XM
(35)SH
15888 56480 MT
(3.2.4.1 Page Fault Trap)SH
52800 XM
(35)SH
15888 57682 MT
(3.2.4.2 Scanning Objects)SH
52800 XM
(35)SH
15888 58884 MT
(3.2.4.3 Application Allocation)SH
52800 XM
(40)SH
15888 60086 MT
(3.2.4.4 Collector Allocation)SH
52800 XM
(40)SH
13488 61288 MT
(3.2.5 End GC)SH
52800 XM
(43)SH
13488 62490 MT
(3.2.6 Heap Page State Transitions)SH
52800 XM
(43)SH
/Times-Bold SF
9288 64550 MT
(4. Experimental Results)SH
52800 XM
(47)SH
/Times-Roman SF
11088 66101 MT
(4.1 Hardware and Compiler Independence)SH
52800 XM
(47)SH
11088 67303 MT
(4.2 Benchmark Measurements)SH
52800 XM
(48)SH
11088 68505 MT
(4.3 Real-Time Performance)SH
52800 XM
(51)SH
11088 69707 MT
(4.4 Soundness of Generational Collection)SH
52800 XM
(55)SH
/Times-Bold SF
9288 71767 MT
(5. Summary and Future Work)SH
52800 XM
(57)SH
10 /Times-Roman AF
31061 75600 MT
(-5-)SH
ES
%%Page: 6 6
BS
0 SI
12 /Times-Roman AF
11088 10399 MT
(5.1 Summary)SH
52800 XM
(57)SH
11088 11601 MT
(5.2 Future Work)SH
52800 XM
(58)SH
/Times-Bold SF
9288 13661 MT
(Appendix A. Sample C++ program using garbage collection)SH
52800 XM
(60)SH
9288 15721 MT
(Appendix B. Source code for the Incremental Garbage Collector)SH
52800 XM
(62)SH
/Times-Roman SF
11088 17272 MT
(B.1 Header file for C++ version 1.2)SH
52800 XM
(62)SH
11088 18474 MT
(B.2 Header file for C++ version 2.0)SH
52800 XM
(67)SH
11088 19676 MT
(B.3 Program file for the incremental collector)SH
52800 XM
(72)SH
10 SS 
31061 75600 MT
(-6-)SH
ES
%%Page: 7 7
BS
0 SI
14 /Times-Bold AF
27560 11947 MT
(List of Tables)SH
12 SS 
11088 16370 MT
(Table 4-I:)SH
/Times-Roman SF
17089 XM
(Comparative Measurements of Benchmark Programs)SH
52500 XM
(4.2)SH
/Times-Bold SF
11088 17572 MT
(Table 4-II:)SH
/Times-Roman SF
17556 XM
(Overhead of page fault trap,)SH
/Courier SF
31355 XM
(mprotect)SH
/Times-Roman SF
37415 XM
(and scanning)SH
52500 XM
(4.3)SH
10 SS 
31061 75600 MT
(-7-)SH
ES
%%Page: 8 8
BS
0 SI
14 /Times-Bold AF
27288 11947 MT
(List of Figures)SH
12 SS 
11088 16370 MT
(Figure 1-1:)SH
/Times-Roman SF
17688 XM
(Bartlett's Mostly-Copying Collector)SH
52500 XM
(1.1)SH
/Times-Bold SF
11088 17572 MT
(Figure 1-2:)SH
/Times-Roman SF
17688 XM
(Appel, Ellis and Li's Incremental Collector)SH
52500 XM
(1.3)SH
/Times-Bold SF
11088 18774 MT
(Figure 2-1:)SH
/Times-Roman SF
17688 XM
(C++ definition for the)SH
/Courier SF
28578 XM
(word)SH
/Times-Roman SF
31758 XM
(object class)SH
52500 XM
(2.1)SH
/Times-Bold SF
11088 19976 MT
(Figure 2-2:)SH
/Times-Roman SF
17688 XM
(Scanning objects)SH
51600 XM
(2.2.3)SH
/Times-Bold SF
11088 21178 MT
(Figure 2-3:)SH
/Times-Roman SF
17688 XM
(Scanning objects - II)SH
51600 XM
(2.2.3)SH
/Times-Bold SF
11088 22380 MT
(Figure 2-4:)SH
/Times-Roman SF
17688 XM
(Scanning objects - III)SH
51600 XM
(2.2.3)SH
/Times-Bold SF
11088 23582 MT
(Figure 2-5:)SH
/Times-Roman SF
17688 XM
(Scanning objects - IV)SH
51600 XM
(2.2.3)SH
/Times-Bold SF
11088 24784 MT
(Figure 3-1:)SH
/Times-Roman SF
17688 XM
(Incremental, Generational, Mostly-Copying Collection)SH
52500 XM
(3.1)SH
/Times-Bold SF
11088 25986 MT
(Figure 3-2:)SH
/Times-Roman SF
17688 XM
(Objects and Physical Page Clusters)SH
51000 XM
(3.2.3.1)SH
/Times-Bold SF
11088 27188 MT
(Figure 3-3:)SH
/Times-Roman SF
17688 XM
(Determining physical page cluster)SH
51000 XM
(3.2.3.1)SH
/Times-Bold SF
11088 28390 MT
(Figure 3-4:)SH
/Times-Roman SF
17688 XM
(Scanning object A)SH
51000 XM
(3.2.4.2)SH
/Times-Bold SF
11088 29592 MT
(Figure 3-5:)SH
/Times-Roman SF
17688 XM
(Scanning object A - II)SH
51000 XM
(3.2.4.2)SH
/Times-Bold SF
11088 30794 MT
(Figure 3-6:)SH
/Times-Roman SF
17688 XM
(Scanning object A - III)SH
51000 XM
(3.2.4.2)SH
/Times-Bold SF
11088 31996 MT
(Figure 3-7:)SH
/Times-Roman SF
17688 XM
(Scanning strategy for unstable objects)SH
51000 XM
(3.2.4.2)SH
/Times-Bold SF
11088 33198 MT
(Figure 3-8:)SH
/Times-Roman SF
17688 XM
(Scanning a linked list)SH
51000 XM
(3.2.4.4)SH
/Times-Bold SF
11088 34400 MT
(Figure 3-9:)SH
/Times-Roman SF
17688 XM
(Heap page state table)SH
51600 XM
(3.2.6)SH
/Times-Bold SF
11088 35602 MT
(Figure 3-10:)SH
/Times-Roman SF
18288 XM
(Heap page state transitions diagram)SH
51600 XM
(3.2.6)SH
/Times-Bold SF
11088 36804 MT
(Figure 4-1:)SH
/Times-Roman SF
17688 XM
(Time profile of)502 W
/Courier SF
26829 XM
(bipsctrl)SH
/Times-Roman SF
33391 XM
(running with the non-incremental)502 W
52500 XM
(4.3)SH
14088 38006 MT
(collector)SH
/Times-Bold SF
11088 39208 MT
(Figure 4-2:)SH
/Times-Roman SF
17688 XM
(Time profile of)SH
/Courier SF
25323 XM
(bipsctrl)SH
/Times-Roman SF
31383 XM
(running with the incremental collector)SH
52500 XM
(4.3)SH
10 SS 
31061 75600 MT
(-8-)SH
ES
%%Page: 9 9
BS
0 SI
14 /Times-Bold AF
28630 11947 MT
(Chapter 1)SH
22136 14560 MT
(Introduction and Related Work)SH
12 /Times-Roman AF
12288 18983 MT
(Garbage collection \050GC\051 refers to the memory allocation and recycling)
144 W( mechanisms)145 W
9288 20703 MT
(for the application program's data memory area.)
44 W( GC)
387 W( has always been associated with high-)43 W
9288 22423 MT
(level, symbolic-processing languages such as Lisp and Scheme, where)
340 W( the concept of)341 W
9288 24143 MT
(automatic storage management for objects of indefinite extent is embedded in the)
56 W( language.)55 W
9288 25863 MT
(However, in)
79 W( other high-level languages, garbage collection has not gained wide acceptance)80 W
9288 27583 MT
(because the extra bookkeeping)
255 W( needed often imposes a significant performance penalty.)254 W
9288 29303 MT
(Traditional garbage collection schemes, like mark-and-sweep)
45 W( and stop-and-copy, lengthen a)46 W
9288 31023 MT
(program's total execution time and adversely affect its interactive performance.)SH
12288 34635 MT
(Although copying and generational collection algorithms)
505 W( applied to high-level)504 W
9288 36355 MT
(languages are hardly new ideas)
86 W( [Fenichel&Yochelson)
SH( 69])
86 W( [Moon)
SH( 84],)
86 W( garbage collection in)87 W
9288 38075 MT
(C++ seems to be an odd idea on first sight.  In C++, contrary to)
202 W( Lisp and Scheme, the)201 W
9288 39795 MT
(storage for)
104 W( objects of indefinite extent must be explicitly managed.  But the importance of)105 W
9288 41515 MT
(garbage collection in C++ is)
8 W( increasing, because as programs become more complicated, GC)7 W
9288 43235 MT
(can help alleviate the complexity in storage management.)
288 W( Efficient)
878 W( garbage collection)289 W
9288 44955 MT
(techniques present an attractive)
9 W( alternative to the usual low-level, ad hoc approach to storage)8 W
9288 46675 MT
(management, where object deallocation is explicitly managed.)
52 W( Indeed,)
405 W( advances in garbage)53 W
9288 48395 MT
(collection technology have made possible the advent of efficient)
93 W( collectors that do not rely)92 W
9288 50115 MT
(on special purpose hardware or compiler support.)SH
12288 53727 MT
(Garbage collectors that)
50 W( can operate on various architectures and system environments)51 W
9288 55447 MT
(contribute substantially to the language system's portability and interoperability.  One)340 W
9288 57167 MT
(example is Xerox)
84 W( PARC's Portable Common Runtime)
85 W( [Weiser)
SH( 89].  It is a portable, multi-)85 W
9288 58887 MT
(lingual programming environment where the support for threads and garbage collection)
140 W( is)139 W
9288 60607 MT
(provided for all languages and is built in as part of the Common Runtime,)
125 W( rather than the)126 W
9288 62327 MT
(individual language runtimes.)
380 W( PCR's)
1058 W( collector is a parallel and non-copying storage)379 W
9288 64047 MT
(manager that must be used as part of)
29 W( the runtime package.  Although PCR is portable across)30 W
9288 65767 MT
(many operating systems, it does have a fair amount of CPU specific code.  My objective)
65 W( in)64 W
9288 67487 MT
(this project, however, is to build a collector that can)
326 W( run in existing environments; a)327 W
9288 69207 MT
(standalone, incremental, and copying collector that can be used with any C++ compiler the)81 W
9288 70927 MT
(programmer desires.)SH
10 SS 
31061 75600 MT
(-9-)SH
ES
%%Page: 10 10
BS
0 SI
12 /Times-Roman AF
12288 10399 MT
(This thesis work is based on the work done at)
303 W( Digital Equipment Corporation's)304 W
9288 12119 MT
(Systems Research Center and Digital Equipment Corporation's Western)
316 W( Research Lab.)315 W
9288 13839 MT
(Appel, Ellis and)
244 W( Li)
245 W( [Appel)
SH( et al. 88] demonstrate that incremental garbage collection is)245 W
9288 15559 MT
(feasible using standard)
174 W( virtual memory page protections, without a tagged architecture or)173 W
9288 17279 MT
(additional hardware support.  To detect pointers to from-space objects, a)
242 W( medium grain)243 W
9288 18999 MT
(synchronization is established between the collector and the mutator at the virtual memory)103 W
9288 20719 MT
(level. Bartlett)
1174 W( invented mostly-copying collection, which makes substantial)
437 W( memory)438 W
9288 22439 MT
(compaction possible without having to know the)
32 W( actual set of root pointers at the start of the)31 W
9288 24159 MT
(collection [Bartlett)
SH( 88].  The result)
220 W( is that a mostly-copying collector can perform in an)221 W
9288 25879 MT
(environment where)
165 W( stack and register allocation disciplines are not known.  Additionally,)164 W
9288 27599 MT
(Bartlett has incorporated generational collection into his)
133 W( mostly-copying collector)
134 W( [Bartlett)SH
9288 29319 MT
(89], and has shown that his strategy works well in systems running Scheme, C, and C++.)SH
12288 32931 MT
(Detlefs has already)
279 W( attempted to combine Appel et al.'s and Bartlett's ideas into)278 W
9288 34651 MT
(building a concurrent collector for C++)
171 W( [Detlefs)
SH( 90].  However, Detlefs's collector)
171 W( is not)172 W
9288 36371 MT
(generational and not very portable.  It requires modifications to be)
323 W( made to the C++)322 W
9288 38091 MT
(compiler and requires MACH.  My thesis is)
109 W( that incremental, generational mostly-copying)110 W
9288 39811 MT
(collection can)
338 W( be done efficiently in a compiler and architecture independent manner,)337 W
9288 41531 MT
(without any modification made to)
244 W( the underlying operating system.  By combining and)245 W
9288 43251 MT
(expanding on ideas employed in previous work, I have built such a collector.)SH
/Times-Bold SF
9288 47655 MT
(1.1 Mostly-Copying Collection)SH
/Times-Roman SF
12288 51358 MT
(Bartlett's mostly-copying collector is)
212 W( a compacting, conservative collector that has)211 W
9288 53078 MT
(knowledge about the heap structure but does not need)
267 W( compiler support.)268 W
/Times-Italic SF
47666 XM
(Conservative)SH
/Times-Roman SF
9288 54798 MT
(means that the)
1 W( collector must assume that any value on the stack or in the registers that could)SH
9288 56518 MT
(be a pointer)
62 W( is a pointer.  While this may retain objects that could otherwise be collected, it)63 W
9288 58238 MT
(has the advantage)
117 W( that the collector does not need to know everything about the stack and)116 W
9288 59958 MT
(registers.)SH
/Times-Italic SF
14846 XM
(Compacting)SH
/Times-Roman SF
21308 XM
(means that objects that can be)
295 W( safely relocated are moved into)296 W
9288 61678 MT
(contiguous spaces.  There are two benefits)
40 W( of compacting collection: \0501\051 heap fragmentation)39 W
9288 63398 MT
(can be controlled, so that the working set of physical pages occupied by the program)
67 W( in the)68 W
9288 65118 MT
(virtual space is reduced, therefore lowering the overhead for virtual memory paging;)
29 W( and \0502\051)28 W
9288 66838 MT
(compacting collector's execution time is proportional to the)
111 W( amount of space retained, and)112 W
9288 68558 MT
(not proportional to the heap size.)SH
10 SS 
30811 75600 MT
(-10-)SH
ES
%%Page: 11 11
BS
0 SI
12 SS 
9 10 0 3924 59832 GB 
%%BeginDocument: bartlett.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Times-Roman Times-Bold Helvetica-Oblique
%%%Pages: 1
%%BoundingBox: 117 296 496 541
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 126 96 ] concat
%I
66 266 91 340 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 134 96 ] concat
%I
104 266 132 382 Rect
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.33962 0 0 1 67.6981 96 ] concat
%I
49 266 154 266 Line
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.10213 0 0 1.13397 87.2085 117.062 ] concat
%I
184 216 418 424 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 242 356 ] concat
%I
[
(Stack)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 182 356 ] concat
%I
[
(Registers)
] Text
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 109 143 ] concat
%I
315 454 315 220 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 142 ] concat
%I
228 454 228 222 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 151 142 ] concat
%I
228 454 228 222 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 139 ] concat
%I
184 414 317 414 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 93 ] concat
%I
184 414 317 414 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 43 ] concat
%I
184 414 317 414 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 -4 ] concat
%I
184 414 317 414 Line
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.5 SetP
%I t
[ 1 0 0 1 107 143 ] concat
%I
184 411 228 454 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.5 SetP
%I t
[ 1 0 0 1 107 143 ] concat
%I
184 314 228 364 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.5 SetP
%I t
[ 1 0 0 1 107 143 ] concat
%I
229 267 272 314 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 143 ] concat
%I
281 419 309 445 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 141 ] concat
%I
281 230 309 258 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 192 193 ] concat
%I
281 230 309 258 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 228 245 ] concat
%I
281 230 309 258 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
1 SetP
%I t
[ 1 0 0 1 63 190 ] concat
%I
281 230 309 258 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
1 SetP
%I t
[ 1 0 0 1 17 331 ] concat
%I
281 230 309 258 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
1 SetP
%I t
[ 1 0 0 1 18 239 ] concat
%I
281 230 309 258 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 308 580 ] concat
%I
[
(A)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 308 489 ] concat
%I
[
(C)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 353 439 ] concat
%I
[
(D)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 397 391 ] concat
%I
[
(E)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 397 580 ] concat
%I
[
(B)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-o-*-140-*
/Helvetica-Oblique 14 SetF
%I t
[ 1 0 0 1 517 494 ] concat
%I
[
(B')
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-o-*-140-*
/Helvetica-Oblique 14 SetF
%I t
[ 1 0 0 1 480 443 ] concat
%I
[
(E')
] Text
End

Begin %I BSpl
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 143 ] concat
%I 3
310 435
416 434
415 362
3 BSpl
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 107 143 ] concat
%I
415 363 415 355 Line
End

Begin %I BSpl
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 143 ] concat
%I 3
310 240
385 240
383 281
3 BSpl
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 107 140 ] concat
%I
383 280 383 287 Line
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 107 143 ] concat
%I 3
252 276
252 244
281 243
3 BSpl
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 107 143 ] concat
%I 2
220 432
282 432
2 BSpl
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 107 143 ] concat
%I 4
220 424
266 421
297 348
402 346
4 BSpl
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
1 SetP
%I t
[ 1 0 0 1 109 142 ] concat
%I
260 446 246 424 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
1 SetP
%I t
[ 1 0 0 1 109 144 ] concat
%I
243 447 263 421 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.75 SetP
%I t
[ 1 0 0 1 108 140 ] concat
%I
265 263 246 242 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.75 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
246 260 268 239 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 143 ] concat
%I
268 291 367 291 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1.02564 0 0 1.02564 311.974 356.897 ] concat
%I
[
(Current-space)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1.02564 0 0 1.02564 452.41 356.897 ] concat
%I
[
(Next-space)
] Text
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1.02564 0 0 1.02564 99.4872 128.205 ] concat
%I
253 317 253 309 Line
End

Begin %I BSpl
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.02564 0 0 1.02564 99.4872 134.359 ] concat
%I 3
223 341
253 341
253 313
3 BSpl
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 39 96 ] concat
%I
104 266 132 382 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 143 356 ] concat
%I
[
(Static )
(Area)
] Text
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 3
98 259
177 252
237 293
3 BSpl
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 4
146 290
100 321
126 374
193 341
4 BSpl
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 4
51 247
44 375
133 431
192 436
4 BSpl
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
19757 34508 MT
(Figure 1-1:)SH
/Times-Roman SF
26057 XM
(Bartlett's Mostly-Copying Collector)SH
12288 40475 MT
(As shown)
229 W( in figure 1-1, Bartlett's collector is based upon an old-space/new-space)228 W
9288 42195 MT
(approach. The)
385 W( heap is divided uniformly into a number of pages \050called heap pages\051 whose)43 W
9288 43915 MT
(size is)
327 W( independent of the actual physical page size of the underlying paging system.)326 W
/Times-Italic SF
9288 45635 MT
(Current-space)SH
/Times-Roman SF
16867 XM
(and)SH
/Times-Italic SF
19245 XM
(next-space)SH
/Times-Roman SF
25024 XM
(are conceptual counterparts of)346 W
/Times-Italic SF
41208 XM
(from-space)SH
/Times-Roman SF
47254 XM
(and)SH
/Times-Italic SF
49633 XM
(to-space)SH
/Times-Roman SF
(,)SH
9288 47355 MT
(respectively, of the classical stop-and-copy collector.)
9 W( Note)
317 W( however, that the spaces here are)8 W
9288 49075 MT
(not necessarily contiguous regions in)
33 W( memory.  There is a special space identifier associated)34 W
9288 50795 MT
(with each heap page to indicate the space it is)
186 W( in.  In the simplest term, mostly-copying)185 W
9288 52515 MT
(collection proceeds as follows.  First, the collector ``guesses'' which)
192 W( heap pages contain)193 W
9288 54235 MT
(objects that may be referenced from pointers in the processor stack, registers and)
316 W( the)315 W
9288 55955 MT
(application program's)
245 W( static area.  These pages are)246 W
/Times-Italic SF
35823 XM
(promoted)SH
/Times-Roman SF
40969 XM
(to the next-space.  In the)246 W
9288 57675 MT
(figure, this)
68 W( refers to the pages containing objects A, C and D. Promoting a page means that)67 W
9288 59395 MT
(the special space identifier of)
106 W( the page is flagged such that the page will be retained when)107 W
9288 61115 MT
(the collection is)
164 W( over.  The objects that point to A, C and D are called)163 W
/Times-Italic SF
45502 XM
(ambiguous roots)163 W
/Times-Roman SF
(,)SH
9288 62835 MT
(because not necessarily all of them are actually real pointers, but they contain the root)248 W
9288 64555 MT
(objects through which all accessible objects can be traced.  Because of this uncertainty,)216 W
9288 66275 MT
(ambiguous roots cannot be changed.  It)
58 W( is important that the heap pages pointed to by these)59 W
9288 67995 MT
(ambiguous roots be ``locked,'' so the objects on these pages can be retained.)SH
12288 71607 MT
(Once the initial promoted objects have)
398 W( been identified, the collector)397 W
/Times-Italic SF
49169 XM
(scans)SH
/Times-Roman SF
52533 XM
(the)SH
10 SS 
30811 75600 MT
(-11-)SH
ES
%%Page: 12 12
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(ambiguous root)
184 W( objects and)185 W
/Times-Italic SF
23563 XM
(forwards)SH
/Times-Roman SF
28383 XM
(all objects referenced from these roots into a more)185 W
9288 12119 MT
(compact area in next-space.)
149 W( Scanning)
596 W( refers to the process by which internal pointers \050if)148 W
9288 13839 MT
(any\051 of an object are)
350 W( examined; and forwarding refers to the copying of the objects)351 W
9288 15559 MT
(referenced by these)
158 W( internal pointers into next-space.  The forward pointers of the copied)157 W
9288 17279 MT
(objects are updated in the object being scanned.  As the)
280 W( figure illustrates, object B is)281 W
9288 18999 MT
(therefore copied into B', and the old pointer in A which pointed)
71 W( to B is updated to point to)70 W
9288 20719 MT
(B' instead.)
117 W( The)
536 W( same is also true for object E pointed to by object D. On the other hand,)118 W
9288 22439 MT
(although D is referenced by object C, D is not forwarded because)
70 W( the heap page containing)69 W
9288 24159 MT
(D is already)
33 W( a promoted page.  Scanning continues until all promoted and forwarded objects)34 W
9288 25879 MT
(have been scanned.  GC is then complete.)SH
12288 29491 MT
(In contrast with a)
561 W( conservative mark-and-sweep collector, which also makes)560 W
9288 31211 MT
(``guesses'' on stack and)
222 W( register pointers but leaves all retained storage fragmented, the)223 W
9288 32931 MT
(mostly-copying collector is able to compact most of the heap because)226 W
/Times-Italic SF
45480 XM
(it has knowledge)226 W
9288 34651 MT
(about the heap structure.)181 W
/Times-Roman SF
22862 XM
(By configuring the heap into a set of pages, the collector can)182 W
9288 36371 MT
(preserve pointers in the root set whose values cannot be changed during a collection by)203 W
9288 38091 MT
(simply promoting their corresponding page.  It)
28 W( is then possible to compact other objects that)29 W
9288 39811 MT
(are not in the root set.)SH
/Times-Bold SF
9288 44215 MT
(1.2 Generational Collection)SH
/Times-Roman SF
12288 47918 MT
(Bartlett has also incorporated)
580 W( generational collection into his mostly-copying)579 W
9288 49638 MT
(collector. Generational)
614 W( collection works on the basis that newly created objects have the)157 W
9288 51358 MT
(highest probability to be destroyed soon, while old objects that)
106 W( have survived collection\050s\051)105 W
9288 53078 MT
(have a tendency to remain around for a longer time.)
22 W( Such)
346 W( observation is in line with the life)23 W
9288 54798 MT
(times of \050i\051 subroutine local variables, which are created when the)
96 W( subroutine is called and)95 W
9288 56518 MT
(are immediately)
297 W( abandoned as soon as the subroutine exits; and \050ii\051 entries in a large)298 W
9288 58238 MT
(database, which are generally long-living objects.)SH
12288 61850 MT
(Generational collection improves efficiency because repeated copying)
314 W( of retained)313 W
9288 63570 MT
(objects is avoided.  Bartlett's)
39 W( generational collector differentiates objects as either ``young'')40 W
9288 65290 MT
(or ``old.''  Each time garbage collection is invoked)
39 W( only pages containing young objects are)38 W
9288 67010 MT
(collected. Old)
420 W( objects are retained)
60 W( and they are not scanned unless they have been mutated)61 W
9288 68730 MT
(\050or the collector thinks that they have been mutated\051 since)
83 W( the last time they were scanned.)82 W
9288 70450 MT
(Old objects are not collected until more than a certain portion of the heap is allocated.)SH
10 SS 
30811 75600 MT
(-12-)SH
ES
%%Page: 13 13
BS
0 SI
12 /Times-Roman AF
12288 10399 MT
(The mostly-copying algorithm facilitates generational)
7 W( collection as the space identifier)8 W
9288 12119 MT
(of each heap page can be used to approximate the age of the object.)
62 W( In)
423 W( the current version,)61 W
9288 13839 MT
(an even page space identifier)
305 W( represents an ``old'' page, and an odd one represents a)306 W
9288 15559 MT
(``young'' page.  According to)
313 W( [Bartlett)
SH( 89], when running with a)
313 W( generational mostly-)312 W
9288 17279 MT
(copying collector, smaller)
238 W( programs that do not use garbage collection run a bit slower)239 W
9288 18999 MT
(because of the overhead needed to keep track of mutated old objects,)
301 W( but large batch)300 W
9288 20719 MT
(programs such as the Scheme compiler run faster, and interactive programs have)
195 W( shorter)196 W
9288 22439 MT
(pauses during collection.  Generational collection is)
221 W( worthwhile whenever the additional)220 W
9288 24159 MT
(time needed to manage)
31 W( the remembered set -- the set of ``old'' pages that have references to)32 W
9288 25879 MT
(new pages -- can be offset by the reduction in garbage collection time.)SH
/Times-Bold SF
9288 30283 MT
(1.3 Incremental Collection)SH
/Times-Roman SF
12288 33986 MT
(Traditionally, incremental collection is implemented)
249 W( on a tagged architecture with)248 W
9288 35706 MT
(special hardware support, e.g. Symbolics Lisp Machines.)
257 W( For)
815 W( conventional incremental)258 W
9288 37426 MT
(stop-and-copy collection,)
55 W( every pointer fetched from memory is examined to see if it points)54 W
9288 39146 MT
(to a from-space object.  If so, then just as in the case of a)
159 W( non-incremental collector, the)160 W
9288 40866 MT
(from-space object is copied to to-space and the pointer which points to the object's old)217 W
9288 42586 MT
(location is updated.)
318 W( This)
938 W( hardware approach implements a fine grain synchronization)319 W
9288 44306 MT
(between the mutator and the collector.)SH
12288 47918 MT
(Appel, Ellis and Li have a different)
428 W( approach to incrementalize stop-and-copy)427 W
9288 49638 MT
(collection. Using)
416 W( the standard virtual)
58 W( memory page protection mechanism, a medium grain)59 W
9288 51358 MT
(synchronization is achieved:)
1 W( a virtual)SH
/Times-Italic SF
27527 XM
(page)SH
/Times-Roman SF
30160 XM
(in to-space is not scanned until an)SH
/Times-Italic SF
46730 XM
(object)SH
/Times-Roman SF
49964 XM
(within it)SH
9288 53078 MT
(is referenced.  Their strategy is based upon the following invariants:)SH
/Symbol SF
11436 56330 MT
(\267)SH
/Times-Roman SF
12288 XM
(At all times, newly-allocated objects contain to-space pointers only.)SH
/Symbol SF
11436 58359 MT
(\267)SH
/Times-Roman SF
12288 XM
(At all times, user application accesses objects via to-space pointers only.)SH
/Symbol SF
11436 60388 MT
(\267)SH
/Times-Roman SF
12288 XM
(During collection, scanned objects contain to-space pointers only.)SH
/Symbol SF
11436 62417 MT
(\267)SH
/Times-Roman SF
12288 XM
(During collection, unscanned objects contain both from-space and)
326 W( to-space)327 W
12288 63703 MT
(pointers.)SH
12288 67315 MT
(Figure 1-2 illustrates the basic framework.  When garbage)
109 W( collection is initiated, the)108 W
9288 69035 MT
(root set is identified and the objects pointed to)
107 W( by the root set are copied to to-space.  But)108 W
9288 70755 MT
(these forwarded root objects in to-space may still have references)
24 W( to from-space objects, and)23 W
10 SS 
30811 75600 MT
(-13-)SH
ES
%%Page: 14 14
BS
0 SI
12 SS 
8 10 0 6588 58536 GB 
%%BeginDocument: ellis.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Helvetica Times-Roman Courier Times-Bold
%%%Pages: 1
%%BoundingBox: 119 208 495 592
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 83 174 ] concat
%I
172 381 365 381 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 84 -19 ] concat
%I
172 381 365 381 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 83 174 ] concat
%I
366 381 366 189 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 83 174 ] concat
%I
172 380 172 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 79 174 ] concat
%I
202 379 202 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 109 175 ] concat
%I
202 379 202 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 138 175 ] concat
%I
202 379 202 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 165 175 ] concat
%I
202 379 202 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 193 175 ] concat
%I
202 379 202 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 221 175 ] concat
%I
202 379 202 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 83 167 ] concat
%I
173 351 367 351 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 82 88 ] concat
%I
173 351 367 351 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 81 126 ] concat
%I
173 351 367 351 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 83 50 ] concat
%I
173 351 367 351 Line
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.25 SetP
%I t
[ 1 0 0 1 84 174 ] concat
%I
259 306 281 341 Rect
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 103 146 ] concat
%I
74 311 35 24 Elli
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 106 137 ] concat
%I
106 322 148 322 Line
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 106 144 ] concat
%I
105 306 148 306 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 158 463 ] concat
%I
[
(C P U)
] Text
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 105 141 ] concat
%I
345 323 369 323 Line
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 105 142 ] concat
%I
344 311 370 311 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 102 148 ] concat
%I
373 347 373 281 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 158 148 ] concat
%I
373 347 373 281 Line
End

Begin %I BSpl
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 106 149 ] concat
%I 3
369 345
397 328
425 344
3 BSpl
End

Begin %I BSpl
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 106 85 ] concat
%I 3
369 345
397 328
425 344
3 BSpl
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 309 354 ] concat
%I
[
(Main Memory)
] Text
End

Begin %I BSpl
%I b 13107
2 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 106 142 ] concat
%I 6
62 338
92 356
54 373
90 395
50 418
118 442
6 BSpl
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 87 80 ] concat
%I
138 503 148 507 Line
End

Begin %I Rect
%I b 65535
1 1 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.14569 0 0 0.917449 88.6357 178.818 ] concat
%I
51 446 201 519 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 173 646 ] concat
%I
[
(Page Trap Thread)
] Text
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
246 377 182 445 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
159 443 234 362 Line
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 0.814815 415 -20.815 ] concat
%I
49 501 11 13 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
1 SetP
%I t
[ 1 0 0 0.814815 225 145.185 ] concat
%I
49 501 11 13 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 0.814815 270 166.185 ] concat
%I
49 501 11 13 Elli
End

Begin %I Poly
%I b 65535
1 1 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.1192 0 0 0.957927 101.967 -192.188 ] concat
%I 4
51 446
51 519
201 519
201 446
4 Poly
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 185 294 ] concat
%I
[
(Scanner Thread)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 186 257 ] concat
%I
[
(in to-space continually.)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 185 275 ] concat
%I
[
(Scans unscanned pages)
] Text
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 107 125 ] concat
%I
112 187 122 181 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 142 546 ] concat
%I
[
(forked)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 139 532 ] concat
%I
[
(kernel)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 146 520 ] concat
%I
[
(call)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 143 397 ] concat
%I
[
(forked)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 141 383 ] concat
%I
[
(kernel)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 148 369 ] concat
%I
[
(call)
] Text
End

Begin %I BSpl
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 143 ] concat
%I 4
87 291
146 189
323 175
322 175
4 BSpl
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 110 143 ] concat
%I
320 175 330 173 Line
End

Begin %I Rect
%I b 65535
1 1 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.13907 0 0 0.917449 293.046 -162.182 ] concat
%I
51 446 201 519 Rect
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 107 143 ] concat
%I
393 173 260 347 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 107 143 ] concat
%I
244 335 366 175 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 205 377 ] concat
%I
[
(user)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 202 366 ] concat
%I
[
(process)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 377 306 ] concat
%I
[
(Mutator )
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-120-*
/Helvetica 12 SetF
%I t
[ 1 0 0 1 379 291 ] concat
%I
[
(. . .)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-120-*
/Helvetica 12 SetF
%I t
[ 1 0 0 1 379 265 ] concat
%I
[
(. . .)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-120-*
/Helvetica 12 SetF
%I t
[ 1 0 0 1 433 305 ] concat
%I
[
(\(user's prog.\))
] Text
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
1 SetP
%I t
[ 1 0 0 0.814815 326 14.185 ] concat
%I
49 501 11 13 Elli
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 461 394 ] concat
%I
[
(1)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 316 580 ] concat
%I
[
(2)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 271 560 ] concat
%I
[
(3)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 372 428 ] concat
%I
[
(4)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 481 393 ] concat
%I
[
(accesses a)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 480 382 ] concat
%I
[
(page that)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 475 370 ] concat
%I
[
(has not been)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 335 588 ] concat
%I
[
(unscanned page )
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 259 541 ] concat
%I
[
(page trap)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 282 529 ] concat
%I
[
(done.)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 423 588 ] concat
%I
[
(not)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 336 576 ] concat
%I
[
(accessible - page trap.)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 485 359 ] concat
%I
[
(scanned.)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 335 411 ] concat
%I
[
(page access)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 361 398 ] concat
%I
[
(granted)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 163 626 ] concat
%I
[
(Scans one unscanned page)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-medium-r-*-100-*
/Courier 10 SetF
%I t
[ 1 0 0 1 162 611 ] concat
%I
[
(in to-space on demand.)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-120-*
/Helvetica 12 SetF
%I t
[ 1 0 0 1 378 274 ] concat
%I
[
(b = p.val + q.val;)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 487 463 ] concat
%I
[
(DISK)
] Text
End

Begin %I BSpl
%I b 13107
2 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 106 142 ] concat
%I 6
69 290
30 273
83 238
39 208
115 169
115 170
6 BSpl
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
18092 45069 MT
(Figure 1-2:)SH
/Times-Roman SF
24392 XM
(Appel, Ellis and Li's Incremental Collector)SH
9288 49533 MT
(therefore must be scanned.)
94 W( Garbage)
490 W( collection is incrementalized by protecting unscanned)95 W
9288 51253 MT
(pages in user mode.  With incremental collection, an unscanned page in to-space can then)
14 W( be)13 W
9288 52973 MT
(scanned when the mutator tries)
33 W( to access an object in it, by triggering a pre-established page)34 W
9288 54693 MT
(trap thread running in kernel mode.  After the page trap handler has scanned the page,)
107 W( the)106 W
9288 56413 MT
(access mode of that page is adjusted so that execution of the mutator can proceed normally.)SH
12288 60025 MT
(Appel et al. used this strategy to build a concurrent, real-time)
69 W( collector on the Firefly)70 W
9288 61745 MT
(multiprocessor workstations.  They added two kernel calls and)
34 W( use facilities particular to the)33 W
10 SS 
47619 63084 MT
(1)SH
12 SS 
9288 63465 MT
(Taos operating system.  Taos extends Digital)
5 W( Equipment Corporation's U)6 W
10 SS 
(LTRIX)SH
12 SS 
48425 XM
(with virtual)6 W
9288 65185 MT
(memory primitives, threads, and cheap synchronization [Thacker&Stewart 87].)SH
10800 50 9288 69990 UL
8 SS 
10288 71655 MT
(1)SH
10 SS 
10688 72000 MT
(U)SH
8 SS 
(LTRIX)SH
10 SS 
14016 XM
(is a trademark of Digital Equipment Corporation.)SH
30811 75600 MT
(-14-)SH
ES
%%Page: 15 15
BS
0 SI
12 /Times-Roman AF
12288 10399 MT
(The work presented in this thesis)
48 W( experiments with the application of this incremental)47 W
9288 12119 MT
(collection strategy on the mostly-copying algorithm to)
19 W( build a real-time garbage collector on)20 W
9288 13839 MT
(sequential workstations such as the DECStation 3100, running standard U)SH
10 SS 
(LTRIX)SH
12 SS 
(.)SH
10 SS 
30811 75600 MT
(-15-)SH
ES
%%Page: 16 16
BS
0 SI
14 /Times-Bold AF
28630 11947 MT
(Chapter 2)SH
16771 14560 MT
(Bartlett's Generational Mostly-Copying Collector)SH
12 SS 
9288 18964 MT
(2.1 Programming Interface in C++)SH
/Times-Roman SF
12288 22667 MT
(In languages such)
413 W( as Scheme and Lisp, which have their own native garbage)412 W
9288 24387 MT
(collectors in the language system, objects with indeterminate extent are allocated)
18 W( in the heap)19 W
9288 26107 MT
(and are garbage collected.)
251 W( In)
801 W( C++ there is no garbage collection facility native to the)250 W
9288 27827 MT
(language system, and objects)
83 W( with indeterminate lifetime are given storage space by means)84 W
9288 29547 MT
(of a general-purpose memory block allocation facility.  Explicit storage)
240 W( management of)239 W
9288 31267 MT
(these objects is necessary.)SH
12288 34879 MT
(C++ is an object-oriented)
41 W( superset of C. It allows the application to define new object)42 W
9288 36599 MT
(classes and provides compile time type checking)
81 W( for the classes.  For each object class, the)80 W
9288 38319 MT
(application supplies a constructor, a destructor, and creates other class operations.  The)245 W
9288 40039 MT
(constructor specifies how new objects are initialized.)
221 W( It)
741 W( is called when a new object is)220 W
9288 41759 MT
(allocated. Class)
1146 W( operations are procedures)
423 W( which clients of the object class use to)424 W
9288 43479 MT
(manipulate objects.  The destructor is called automatically when the object)
110 W( is going out of)109 W
9288 45199 MT
(scope. Inside)
620 W( the destructor the application can free the memory occupied by the)
160 W( object.)161 W
9288 46919 MT
(With Bartlett's generational mostly-copying garbage collector added)
232 W( to the C++ system,)231 W
9288 48639 MT
(application programmers)
380 W( can decide which C++ classes are allocated on the garbage)381 W
9288 50359 MT
(collected heap, and)
154 W( which are not.  And for the garbage collected classes, the application)153 W
9288 52079 MT
(does not need to provide a destructor.)SH
12288 55691 MT
(Bartlett's collector is added to the language system like any other library)
72 W( because the)73 W
9288 57411 MT
(collector is a self-contained module requiring no cooperation from the compiler.  The)306 W
9288 59131 MT
(application calls routines provided by the garbage collector by linking)
125 W( with the collector's)126 W
9288 60851 MT
(library at compile)
30 W( time.  This level of compiler independence allows the collector to be used)29 W
9288 62571 MT
(with different C++ compilers.)SH
12288 66183 MT
(Figure 2-1 shows an example of how a garbage collected)
18 W( C++ object class is declared.)19 W
9288 67903 MT
(Only object classes)
184 W( with the special statement)183 W
/Courier SF
32876 XM
(GCCLASS)SH
/Times-Roman SF
38399 XM
(appearing in the class structure)183 W
9288 69623 MT
(declaration are)
66 W( garbage collected.  In the example,)67 W
/Courier SF
34290 XM
(GCCLASS)SH
/Times-Roman SF
39697 XM
(informs the garbage collector)67 W
9288 71343 MT
(that the type)303 W
/Courier SF
16432 XM
(word)SH
/Times-Roman SF
19914 XM
(is garbage collected and has a ``pointer-finding'' callback method)302 W
10 SS 
30811 75600 MT
(-16-)SH
ES
%%Page: 17 17
BS
0 SI
10 /Courier AF
14088 12059 MT
(struct word {)600 W
18888 13256 MT
(word* lesser;)SH
18888 14453 MT
(word* greater;)SH
18888 15650 MT
(int count;)1200 W
18888 16847 MT
(char symbol[)
600 W( 1 ];)SH
18888 18044 MT
(word\050 char* chars \051;)SH
18888 19241 MT
(GCCLASS\050 word \051;)SH
14088 20438 MT
(};)SH
14088 22832 MT
(word::word\050 char* chars \051)SH
14088 24029 MT
({)SH
18888 25226 MT
(GCALLOCV\050 word, sizeof\050 word \051+strlen\050 chars \051 \051;)SH
18888 26423 MT
(lesser = NULL;)SH
18888 27620 MT
(greater = NULL;)SH
18888 28817 MT
(count = 1;)SH
18888 30014 MT
(strcpy\050 symbol, chars \051;)SH
14088 31211 MT
(})SH
14088 33605 MT
(void word::GCPointers\050)
600 W( \051  {)SH
18888 34802 MT
(gcpointer\050 lesser \051;)SH
18888 35999 MT
(gcpointer\050 greater \051;)SH
14088 37196 MT
(})SH
12 /Times-Bold AF
18675 40808 MT
(Figure 2-1:)SH
/Times-Roman SF
24975 XM
(C++ definition for the)SH
/Courier SF
35865 XM
(word)SH
/Times-Roman SF
39045 XM
(object class)SH
/Courier SF
9288 45272 MT
(word::GCPointers)SH
/Times-Roman SF
(. When)
908 W( the collector is scanning an object, it must be able)
304 W( to)305 W
9288 46992 MT
(identify internal pointers of the object.  In this case, the)
253 W( internal pointers of)252 W
/Courier SF
49102 XM
(word)SH
/Times-Roman SF
52534 XM
(are)SH
/Courier SF
9288 48712 MT
(word* lesser)44 W
/Times-Roman SF
18316 XM
(and)SH
/Courier SF
20393 XM
(word* greater)44 W
/Times-Roman SF
(. In)
390 W( the)45 W
/Courier SF
33944 XM
(word::GCPointers)SH
/Times-Roman SF
45809 XM
(callback, there is)45 W
9288 50432 MT
(a)SH
/Courier SF
10213 XM
(gcpointer)SH
/Times-Roman SF
17085 XM
(statement for)
92 W( each internal pointer.  During scanning, the garbage collector)91 W
9288 52152 MT
(has an efficient way to)
400 W( call the)401 W
/Courier SF
27059 XM
(GCPointers)SH
/Times-Roman SF
34960 XM
(method of the object being scanned)401 W
9288 53872 MT
(\050described in the last paragraph of section 2.2.2, page 20\051.)
98 W( Then)
495 W( each of the)97 W
/Courier SF
47520 XM
(gcpointer)SH
/Times-Roman SF
9288 55592 MT
(statements of the method passes an internal pointer of the object to the)
54 W( collector, so that)55 W
/Times-Italic SF
52533 XM
(the)SH
9288 57312 MT
(object referenced by that internal pointer)194 W
/Times-Roman SF
30590 XM
(can be forwarded.  If an object class)
194 W( does not)193 W
9288 59032 MT
(contain any internal pointer, the)SH
/Courier SF
24891 XM
(GCPointers)SH
/Times-Roman SF
32391 XM
(method is an empty procedure.)SH
12288 62644 MT
(Inside the constructor)64 W
/Courier SF
23182 XM
(word::word)SH
/Times-Roman SF
(,)SH
/Courier SF
31046 XM
(GCALLOCV)SH
/Times-Roman SF
37170 XM
(is responsible for space allocation.)65 W
9288 64364 MT
(The arguments of)106 W
/Courier SF
18373 XM
(GCALLOCV)SH
/Times-Roman SF
24539 XM
(are the class name)
106 W( and the number of bytes the class object)105 W
9288 66084 MT
(occupies, respectively.)137 W
/Courier SF
21200 XM
(GCALLOCV)SH
/Times-Roman SF
27397 XM
(is designed for)
137 W( the allocation of variable-size objects;)138 W
9288 67804 MT
(for an object class)485 W
/Courier SF
20229 XM
(t)SH
/Times-Roman SF
21734 XM
(whose size is known)
485 W( at compile time, a simpler statement,)484 W
/Courier SF
9288 69524 MT
(GCALLOC\050t\051)SH
/Times-Roman SF
(, is used instead of)SH
/Courier SF
25690 XM
(GCALLOCV\050t,sizeof\050t\051\051)SH
/Times-Roman SF
(.)SH
10 SS 
30811 75600 MT
(-17-)SH
ES
%%Page: 18 18
BS
0 SI
12 /Times-Roman AF
12288 10399 MT
(C++ supports class inheritance; it)
69 W( is possible that a collectible class is a subclass of a)70 W
9288 12119 MT
(collectible superclass, or a non-collectible subclass has)
213 W( a collectible superclass, and vice)212 W
9288 13839 MT
(versa. To)
332 W( ensure that)
16 W( the pointer-finding method is consistent and able to find all pointers to)17 W
9288 15559 MT
(garbage collected objects, the application programmer must adhere to the following rules:)SH
11688 18674 MT
(1.)SH
12888 XM
(For class)195 W
/Courier SF
17879 XM
(C:P {})195 W
/Times-Roman SF
(,)SH
/Courier SF
23189 XM
(C::GCPointers)SH
/Times-Roman SF
33043 XM
(must contain)194 W
/Courier SF
39900 XM
(P::GCPointers\050\051)SH
/Times-Roman SF
(.)SH
12888 19960 MT
(That is, for a class)104 W
/Courier SF
22476 XM
(C)SH
/Times-Roman SF
23600 XM
(that is derived from a)
104 W( super class)105 W
/Courier SF
40434 XM
(P)SH
/Times-Roman SF
(, the pointer-finding)105 W
12888 21246 MT
(method of)36 W
/Courier SF
18161 XM
(C)SH
/Times-Roman SF
19217 XM
(must contain the call to)36 W
/Courier SF
30901 XM
(P::GCPointers\050\051)SH
/Times-Roman SF
(, which is class)36 W
/Courier SF
49413 XM
(P)SH
/Times-Roman SF
('s)SH
12888 22532 MT
(pointer-finding method.)SH
11688 24561 MT
(2.)SH
12888 XM
(For class)194 W
/Courier SF
17877 XM
(C{X x;})194 W
/Times-Roman SF
(,)SH
/Courier SF
23906 XM
(C::GCPointers)SH
/Times-Roman SF
33761 XM
(must contain)195 W
/Courier SF
40620 XM
(x.GCPointers\050\051)SH
/Times-Roman SF
(.)SH
12888 25847 MT
(That is, for a class)45 W
/Courier SF
22181 XM
(C)SH
/Times-Roman SF
23246 XM
(which contains an object)45 W
/Courier SF
35626 XM
(x)SH
/Times-Roman SF
36690 XM
(of the garbage collected class)44 W
/Courier SF
12888 27133 MT
(X)SH
/Times-Roman SF
(,)SH
/Courier SF
15721 XM
(C)SH
/Times-Roman SF
('s pointer-finding method must include the statement)1514 W
/Courier SF
12888 28419 MT
(x.GCPointers\050\051)SH
/Times-Roman SF
(, which is the call to invoke the pointer-finding method)
26 W( of)25 W
12888 29705 MT
(object)SH
/Courier SF
16122 XM
(x)SH
/Times-Roman SF
(.)SH
11688 31734 MT
(3.)SH
12888 XM
(For class)297 W
/Courier SF
18083 XM
(C{X* x;})297 W
/Times-Roman SF
(,)SH
/Courier SF
25037 XM
(C::GCPointers)SH
/Times-Roman SF
34995 XM
(must contain)298 W
/Courier SF
42060 XM
(gcpointer\050x\051)SH
/Times-Roman SF
(.)SH
12888 33020 MT
(That is, for a class)136 W
/Courier SF
22636 XM
(C)SH
/Times-Roman SF
23792 XM
(which contains a pointer)136 W
/Courier SF
36403 XM
(x)SH
/Times-Roman SF
37558 XM
(to an object of the garbage)135 W
12888 34306 MT
(collected class)369 W
/Courier SF
20895 XM
(X)SH
/Times-Roman SF
(,)SH
/Courier SF
22585 XM
(C)SH
/Times-Roman SF
('s pointer-finding method must contain the statement)370 W
/Courier SF
12888 35592 MT
(gcpointer\050x\051)SH
/Times-Roman SF
(, which informs the garbage collector about the)
82 W( existence of)81 W
12888 36878 MT
(this internal pointer.)SH
12288 40490 MT
(If a subclass does not)
73 W( have any internal pointers, then the)74 W
/Courier SF
40835 XM
(GCCLASS)SH
/Times-Roman SF
46249 XM
(statement in the)74 W
9288 42210 MT
(declaration of)
226 W( the subclass can be omitted and the)225 W
/Courier SF
35484 XM
(GCPointer)SH
/Times-Roman SF
42489 XM
(callback method is not)225 W
9288 43930 MT
(necessary.)SH
/Times-Bold SF
9288 48334 MT
(2.2 Summary of Bartlett's Collection Algorithm)SH
/Times-Roman SF
12288 52037 MT
(Bartlett's generational mostly-copying)
595 W( collector is a compacting, conservative)596 W
9288 53757 MT
(collector. The)
438 W( heap is divided into a number of)
69 W( heap pages, each of which is)68 W
/Courier SF
47520 XM
(PAGEBYTES)SH
/Times-Roman SF
9288 55477 MT
(bytes in size.)156 W
/Courier SF
16747 XM
(PAGEBYTES)SH
/Times-Roman SF
23683 XM
(is an adjustable parameter independent of the)
156 W( hardware page)157 W
9288 57197 MT
(size. The)
350 W( collector conservatively)
25 W( treats all words in the processor stack and registers which)24 W
9288 58917 MT
(could be pointers into the heap as root)
71 W( pointers.  Heap pages which are referenced by these)72 W
/Times-Italic SF
9288 60637 MT
(ambiguous roots)168 W
/Times-Roman SF
17959 XM
(are retained.  Their contents are left intact because the ambiguous roots)167 W
9288 62357 MT
(may reference their locations in the future.  Other objects in the heap that are not)
38 W( referenced)39 W
9288 64077 MT
(directly by the roots can be compacted, much like the)
220 W( way of a classical stop-and-copy)219 W
9288 65797 MT
(collector.)SH
12288 69409 MT
(Bartlett's collector uses a dual age group approach for generational)
414 W( collection.)415 W
9288 71129 MT
(Newly-allocated objects are)
32 W( considered ``young'' while objects which have survived at least)31 W
10 SS 
30811 75600 MT
(-18-)SH
ES
%%Page: 19 19
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(one collection are ``old.''  Old objects are stable and not collected.  During each)
56 W( collection,)57 W
9288 12119 MT
(stable objects \050which constitutes the)
96 W( stable set\051 that have been mutated to reference young,)95 W
9288 13839 MT
(unstable objects have to be scanned, so that the unstable objects can be forwarded and made)34 W
9288 15559 MT
(stable. The)
410 W( set of stable objects which the collector needs to)
55 W( scan is called the)54 W
/Times-Italic SF
48002 XM
(remembered)SH
9288 17279 MT
(set)SH
/Times-Roman SF
(. For)
540 W( ease of implementation, the remembered set in Bartlett's collector is equal to)
120 W( the)121 W
9288 18999 MT
(stable set, so no)
96 W( additional bookkeeping is necessary to remember the stable objects which)95 W
9288 20719 MT
(have been mutated.  Stable objects are retained at)
191 W( each collection, until the set of stable)192 W
9288 22439 MT
(objects occupy a certain fraction of the heap.  Then a total collection is initiated to)
14 W( collect all)13 W
9288 24159 MT
(objects regardless of age.)SH
/Times-Bold SF
9288 27843 MT
(2.2.1 Spaces)SH
/Times-Roman SF
12288 30826 MT
(The classical)
173 W( stop-and-copy collector divides the heap into two contiguous regions,)174 W
9288 32546 MT
(from-space and to-space.  Objects are allocated in from-space)
32 W( until it is exhausted.  Garbage)31 W
9288 34266 MT
(collection is started, and objects that are salvageable are copied to)
385 W( to-space.  When)386 W
9288 35986 MT
(collection is over, the two)
81 W( spaces swap roles.  Bartlett's collector divides the heap into two)80 W
9288 37706 MT
(spaces also: current-space and next-space.  They are analogous to from-space and)
76 W( to-space,)77 W
9288 39426 MT
(respectively, of)
190 W( the classical algorithm; but Bartlett's spaces are not contiguous.  Rather,)189 W
9288 41146 MT
(each heap page has an associated space)
11 W( identifier to indicate the space it is in.  There are two)12 W
9288 42866 MT
(variable that the collector maintains,)304 W
/Courier SF
28613 XM
(curr_space)SH
/Times-Roman SF
36417 XM
(and)SH
/Courier SF
38754 XM
(next_space)SH
/Times-Roman SF
(, to denote two)304 W
9288 44586 MT
(important space identifiers.  The following explains the partition of the spaces:)SH
/Symbol SF
11436 47838 MT
(\267)SH
/Times-Italic SF
12288 XM
(current-space)SH
/Times-Roman SF
19325 XM
(-- space where the application allocates heap pages.  Heap pages)71 W
12288 49124 MT
(in current-space have their space identifiers equal to)SH
/Courier SF
37624 XM
(curr_space)SH
/Times-Roman SF
(.)SH
/Symbol SF
11436 51153 MT
(\267)SH
/Times-Italic SF
12288 XM
(next-space)SH
/Times-Roman SF
17756 XM
(-- space where retained heap pages)
35 W( are found during collection.  The)34 W
12288 52439 MT
(collector retains)
121 W( heap pages referenced by the ambiguous roots by setting \050i.e.)122 W
12288 53725 MT
(promoting\051 the space)
241 W( identifiers of those pages to be)240 W
/Courier SF
39888 XM
(next_space)SH
/Times-Roman SF
(. Heap)780 W
12288 55011 MT
(pages allocated to hold forwarded objects also have their space identifiers)
37 W( equal)38 W
12288 56297 MT
(to)SH
/Courier SF
13522 XM
(next_space)SH
/Times-Roman SF
(.)SH
12288 59909 MT
(Normally)SH
/Courier SF
17234 XM
(curr_space)SH
/Times-Roman SF
24779 XM
(and)SH
/Courier SF
26857 XM
(next_space)SH
/Times-Roman SF
34402 XM
(are equal when garbage collection is not)44 W
9288 61629 MT
(going on.  Initially,)SH
/Courier SF
18825 XM
(curr_space)SH
/Times-Roman SF
26325 XM
(and)SH
/Courier SF
28358 XM
(next_space)SH
/Times-Roman SF
35859 XM
(are set to 3.  When garbage collection)1 W
9288 63349 MT
(is initiated,)53 W
/Courier SF
15031 XM
(next_space)SH
/Times-Roman SF
22584 XM
(is incremented by 1, to become an even number.  When garbage)53 W
9288 65069 MT
(collection ends,)31 W
/Courier SF
17185 XM
(curr_space)SH
/Times-Roman SF
24716 XM
(is incremented by 2 \050i.e. it remains odd\051, and)31 W
/Courier SF
46800 XM
(next_space)SH
/Times-Roman SF
9288 66789 MT
(is reset to be equal to)SH
/Courier SF
19757 XM
(curr_space)SH
/Times-Roman SF
(.)SH
12288 70401 MT
(The heap pages promoted)
221 W( into next-space as well as those allocated in next-space)220 W
10 SS 
30811 75600 MT
(-19-)SH
ES
%%Page: 20 20
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(during collection always have even identifiers, while heap pages allocated)
17 W( by the application)18 W
9288 12119 MT
(in current-space always have odd identifiers.  Generational collection takes)
12 W( advantage of this)11 W
9288 13839 MT
(fact and treats heap pages with even identifiers as the stable set.)SH
/Times-Bold SF
9288 17523 MT
(2.2.2 Allocation)SH
/Times-Roman SF
12288 20506 MT
(Allocation in the mostly-copying collector is a two-part process: \050i\051 allocate a free)192 W
9288 22226 MT
(heap page, and then \050ii\051 allocate space from it.  A new heap)
25 W( page allocated in step \050i\051 always)24 W
9288 23946 MT
(has its)
53 W( space identifier set to)54 W
/Courier SF
23482 XM
(next_space)SH
/Times-Roman SF
31036 XM
(\050recall that)54 W
/Courier SF
36612 XM
(curr_space == next_space)54 W
/Times-Roman SF
9288 25666 MT
(when garbage collection in not going on\051.  The variable)95 W
/Courier SF
37206 XM
(freewords)SH
/Times-Roman SF
44081 XM
(holds the number)
95 W( of)94 W
9288 27386 MT
(remaining allocatable words in the)
22 W( current free page.  If the remaining)23 W
/Courier SF
43530 XM
(freewords)SH
/Times-Roman SF
50333 XM
(number)SH
9288 29106 MT
(of words is insufficient for an allocation request,)
92 W( then the trailing space on the current free)91 W
9288 30826 MT
(page is discarded and left unused. Another heap page is allocated, and)45 W
/Courier SF
43762 XM
(freewords)SH
/Times-Roman SF
50587 XM
(is reset)45 W
9288 32546 MT
(to reflect the status of this new free page.)SH
12288 36158 MT
(Each heap page has a type)
18 W( identifier associated with it.  When a heap page is allocated)17 W
9288 37878 MT
(to hold objects smaller than one heap page in size, its type)
69 W( identifier is set to)70 W
/Courier SF
47307 XM
(OBJECT)SH
/Times-Roman SF
(. To)440 W
9288 39598 MT
(accommodate a large object, more than one heap page has to be allocated.  The)
40 W( first of such)39 W
9288 41318 MT
(heap pages)
102 W( is of type)103 W
/Courier SF
20169 XM
(OBJECT)SH
/Times-Roman SF
(, while the remaining one\050s\051 are of type)103 W
/Courier SF
44548 XM
(CONTINUED)SH
/Times-Roman SF
(. The)506 W
9288 43038 MT
(trailing space \050if any\051)
167 W( on the last)166 W
/Courier SF
26290 XM
(CONTINUED)SH
/Times-Roman SF
33236 XM
(page is not used for another object.  It is)166 W
9288 44758 MT
(simply left unused.)SH
12288 48370 MT
(The mostly-copying collector can function)
738 W( without hardware and compiler)739 W
9288 50090 MT
(cooperation because it)
281 W( has perfect knowledge about the heap and the objects inside it.)280 W
9288 51810 MT
(Besides knowing the space and type identifiers of the heap pages, the collector needs)
191 W( to)192 W
9288 53530 MT
(know specific)
73 W( information about each object.  This is achieved by allocating a header word)72 W
9288 55250 MT
(at the start of each object.  The header)
75 W( word contains information about the object size and)76 W
9288 56970 MT
(an index into an array of)56 W
/Courier SF
21691 XM
(GCPointers)SH
/Times-Roman SF
29247 XM
(callback routines.  Using this index the collector)
56 W( is)55 W
9288 58690 MT
(able to access the)
133 W( appropriate)134 W
/Courier SF
24389 XM
(GCPointers)SH
/Times-Roman SF
32023 XM
(routine for the object type, and it is through)134 W
9288 60410 MT
(this)SH
/Courier SF
11359 XM
(GCPointers)SH
/Times-Roman SF
18895 XM
(method that the internal pointers \050if any\051 of an object can be located)
36 W( and)35 W
9288 62130 MT
(examined.)SH
10 SS 
30811 75600 MT
(-20-)SH
ES
%%Page: 21 21
BS
0 SI
12 /Times-Bold AF
9288 10380 MT
(2.2.3 Collection)SH
/Times-Roman SF
12288 13363 MT
(The collector maintains the variable)78 W
/Courier SF
30248 XM
(allocatedpages)SH
/Times-Roman SF
40706 XM
(so that it knows)
78 W( how many)79 W
9288 15083 MT
(heap pages have been allocated.  Every time the collector enters the allocation routine, it)160 W
9288 16803 MT
(checks the condition:)SH
/Courier SF
12888 18523 MT
(allocatedpages >= heappages/2 && curr_space == next_space)SH
10 /Times-Roman AF
44286 19862 MT
(2)SH
12 SS 
9288 20243 MT
(which when true, means that at least half of the heap is already allocated)15 W
45101 XM
(and that collection)15 W
9288 21963 MT
(has not been triggered yet.  In this situation the collector enters)
25 W( garbage collection mode and)24 W
9288 23683 MT
(attempts to recycle memory before getting to the allocation routine.)SH
12288 27295 MT
(Garbage collection starts with the following assignment:)SH
/Courier SF
12888 29015 MT
(next_space = curr_space+1;)SH
/Times-Roman SF
9288 30735 MT
(GC then)
174 W( proceeds with examining the stack, registers and static areas, looking for words)175 W
9288 32455 MT
(which can be interpreted as pointers into current-space heap pages.  These words are referred)1 W
9288 34175 MT
(to as the ambiguous root pointers.  The current-space heap)
24 W( pages which the ambiguous roots)25 W
9288 35895 MT
(reference are promoted by changing their space identifiers to)24 W
/Courier SF
39006 XM
(next_space)SH
/Times-Roman SF
(. The)
348 W( page)
24 W( type)23 W
9288 37615 MT
(identifier allows large objects to be)
33 W( recognized.  When an ambiguous root points into one of)34 W
9288 39335 MT
(the)SH
/Courier SF
11170 XM
(CONTINUED)SH
/Times-Roman SF
18065 XM
(heap pages, all the heap pages which together make up the whole object)114 W
9288 41055 MT
(must be promoted.  When such an ambiguous root into an arbitrary)147 W
/Courier SF
43557 XM
(CONTINUED)SH
/Times-Roman SF
50485 XM
(page is)148 W
9288 42775 MT
(encountered, it is easy to ``search)
244 W( backward'' to the beginning of the object by simply)243 W
9288 44495 MT
(checking the type identifier of the page\050s\051)
92 W( preceding the)93 W
/Courier SF
37288 XM
(CONTINUED)SH
/Times-Roman SF
44161 XM
(page until a page of)93 W
9288 46215 MT
(type)SH
/Courier SF
11846 XM
(OBJECT)SH
/Times-Roman SF
16657 XM
(is discovered.  After the leading)191 W
/Courier SF
33438 XM
(OBJECT)SH
/Times-Roman SF
38249 XM
(page is found,)
191 W( the header word)190 W
9288 47935 MT
(gives the size of the)
179 W( object and the corresponding number of pages are promoted.  If an)180 W
9288 49655 MT
(ambiguous root references a stable heap)
322 W( page \050one with an even space identifier\051, no)321 W
9288 51375 MT
(promoting is necessary.)SH
12288 54987 MT
(After the stack and registers)
18 W( are searched and promoting is done, the garbage collector)19 W
9288 56707 MT
(sweeps across the set of stable and)
70 W( promoted heap pages and scans the objects inside them.)69 W
9288 58427 MT
(Scanning is)
146 W( done using a breadth-first discipline.  Referring to figure 2-2, object A is the)147 W
9288 60147 MT
(first object to be scanned, and it contains pointers referencing objects B and)
45 W( C. Assume that)44 W
9288 61867 MT
(all objects are in current-space before collection begins, and object A is)
105 W( promoted to next-)106 W
9288 63587 MT
(space during collection.  Scanning A discovers internal pointers to B and)
334 W( C \050via the)333 W
/Courier SF
9288 65307 MT
(GCPointers)SH
/Times-Roman SF
16844 XM
(method\051, and causes B and C to be forwarded, to)
56 W( B' and C' respectively, on)57 W
9288 67027 MT
(another heap page allocated in next-space \050see figure 2-3\051.  As)
45 W( B and C are forwarded, their)44 W
10800 50 9288 69990 UL
8 SS 
10288 71655 MT
(2)SH
10 /Courier AF
10688 72000 MT
(heappages)SH
/Times-Roman SF
16338 XM
(is the total number of heap pages in the heap.)SH
30811 75600 MT
(-21-)SH
ES
%%Page: 22 22
BS
0 SI
12 SS 
1 1 0 4284 72216 GB 
%%BeginDocument: scan_objs.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Times-Bold Times-Roman
%%%Pages: 1
%%BoundingBox: 169 373 398 607
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 96 171 ] concat
%I
175 404 19 19 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 124 249 ] concat
%I
175 404 19 19 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 149 199 ] concat
%I
175 404 19 19 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 142 122 ] concat
%I
175 404 19 19 Elli
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 295 660 ] concat
%I
[
(A)
] Text
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 105 141 ] concat
%I 2
184 496
164 451
2 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 141 ] concat
%I 2
203 496
214 480
2 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 2
202 452
182 442
2 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 2
217 442
212 405
2 MLine
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 104 144 ] concat
%I
98 485 288 485 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 105 66 ] concat
%I
98 485 288 485 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 267 581 ] concat
%I
[
(B)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 320 609 ] concat
%I
[
(C)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 312 532 ] concat
%I
[
(D)
] Text
End

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 -20 8 ] concat

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 214 457 ] concat
%I
[
(Scanning A causes B and C to be forwarded.)
(Scanning C causes D to be forwarded \(assuming )
(that B is already forwarded\).)
()
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 212 485 ] concat
%I
[
(The dotted lines show the ``levels'' of)
(the data structure.)
] Text
End

End %I eop

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
24410 36668 MT
(Figure 2-2:)SH
/Times-Roman SF
30710 XM
(Scanning objects)SH
1 1 0 4284 102949 GB 
%%BeginDocument: scan_objs_2.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Times-Bold Times-Roman
%%%Pages: 1
%%BoundingBox: 149 400 407 607
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 96 171 ] concat
%I
175 404 19 19 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 124 249 ] concat
%I
175 404 19 19 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 149 199 ] concat
%I
175 404 19 19 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 142 122 ] concat
%I
175 404 19 19 Elli
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 295 660 ] concat
%I
[
(A)
] Text
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 105 141 ] concat
%I 2
184 496
164 451
2 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 141 ] concat
%I 2
203 496
214 480
2 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 2
202 452
182 442
2 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 2
217 442
212 405
2 MLine
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 267 581 ] concat
%I
[
(B)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 320 609 ] concat
%I
[
(C)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 312 532 ] concat
%I
[
(D)
] Text
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 39 170 ] concat
%I
175 404 19 19 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 206 202 ] concat
%I
175 404 19 19 Elli
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 210 579 ] concat
%I
[
(B')
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 376 611 ] concat
%I
[
(C')
] Text
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
213 509 268 479 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
176 506 110 451 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
146 433 126 433 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
238 461 256 461 Line
End

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 114 202 ] concat

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
86 296 97 285 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
97 298 86 283 Line
End

End %I eop

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 82 182 ] concat

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
86 296 97 285 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
97 298 86 283 Line
End

End %I eop

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
268 447 222 399 Line
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 6
276 445
276 392
254 339
184 337
166 373
166 415
6 BSpl
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 169 459 ] concat
%I
[
(Scanning A forwards B and C to B' and C', respectively.)
] Text
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
23510 67401 MT
(Figure 2-3:)SH
/Times-Roman SF
29810 XM
(Scanning objects - II)SH
9288 71865 MT
(header words are replaced with the forward pointers to)
175 W( the location where the forwarded)176 W
10 SS 
30811 75600 MT
(-22-)SH
ES
%%Page: 23 23
BS
0 SI
12 SS 
1 1 0 4284 72216 GB 
%%BeginDocument: scan_objs_3.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Times-Bold Times-Roman
%%%Pages: 1
%%BoundingBox: 172 380 405 607
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 96 171 ] concat
%I
175 404 19 19 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 124 249 ] concat
%I
175 404 19 19 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 149 199 ] concat
%I
175 404 19 19 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 142 122 ] concat
%I
175 404 19 19 Elli
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 295 660 ] concat
%I
[
(A)
] Text
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 2
202 452
182 442
2 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 2
217 442
212 405
2 MLine
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 267 581 ] concat
%I
[
(B)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 320 609 ] concat
%I
[
(C)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 312 532 ] concat
%I
[
(D)
] Text
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 39 170 ] concat
%I
175 404 19 19 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 206 202 ] concat
%I
175 404 19 19 Elli
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 210 579 ] concat
%I
[
(B')
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 376 611 ] concat
%I
[
(C')
] Text
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
213 509 268 479 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
176 506 110 451 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
268 447 222 399 Line
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 6
276 445
276 392
254 339
184 337
166 373
166 415
6 BSpl
End

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 102 54 ] concat

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
86 296 97 285 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
97 298 86 283 Line
End

End %I eop

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 7
284 448
287 396
275 340
232 316
155 316
109 362
108 413
7 BSpl
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 253 123 ] concat
%I
175 404 19 19 Elli
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
290 454 319 404 Line
End

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 157 132 ] concat

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
86 296 97 285 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
97 298 86 283 Line
End

End %I eop

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 422 532 ] concat
%I
[
(D')
] Text
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
230 384 304 384 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 245 437 ] concat
%I
[
(Scanning C' forwards D to D'.)
] Text
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
23310 39548 MT
(Figure 2-4:)SH
/Times-Roman SF
29610 XM
(Scanning objects - III)SH
1 1 0 4284 105829 GB 
%%BeginDocument: scan_objs_4.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Times-Bold
%%%Pages: 1
%%BoundingBox: 172 454 405 607
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 124 249 ] concat
%I
175 404 19 19 Elli
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 295 660 ] concat
%I
[
(A)
] Text
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 39 170 ] concat
%I
175 404 19 19 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 206 202 ] concat
%I
175 404 19 19 Elli
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 210 579 ] concat
%I
[
(B')
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 376 611 ] concat
%I
[
(C')
] Text
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
213 509 268 479 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
176 506 110 451 Line
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 253 123 ] concat
%I
175 404 19 19 Elli
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
290 454 319 404 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 422 532 ] concat
%I
[
(D')
] Text
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
256 459 126 435 Line
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
23277 63801 MT
(Figure 2-5:)SH
/Times-Roman SF
29577 XM
(Scanning objects - IV)SH
9288 68265 MT
(objects B' and C', respectively, are found.  The flag bit of B's and)
12 W( C's header words are also)11 W
9288 69985 MT
(set to indicate that these objects have been forwarded.  The references to B and C)
77 W( found in)78 W
9288 71705 MT
(A's internal pointers are changed to reference B' and C' instead.)
26 W( Scanning)
350 W( of A is complete)25 W
10 SS 
30811 75600 MT
(-23-)SH
ES
%%Page: 24 24
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(after B and)
277 W( C are copied to B' and C'.  Since B' and C' are in next-space, they are)278 W
9288 12119 MT
(considered promoted objects and must be scanned.  When B' is scanned, it)
103 W( does not cause)102 W
9288 13839 MT
(any forwarding because it does not contain any internal)
89 W( pointers.  When C' is scanned, the)90 W
9288 15559 MT
(collector attempts to forward B and D \050see figure 2-4\051.)
12 W( The)
323 W( flag bit in B's header shows that)11 W
9288 17279 MT
(B has already been forwarded and)
SH( therefore it is not forwarded again.  The internal pointer in)1 W
9288 18999 MT
(C is set to the value of B's forward pointer found in its header word.  Afterwards, object D)
4 W( is)3 W
9288 20719 MT
(forwarded the normal way -- assuming that it has not been)
160 W( already forwarded by another)161 W
9288 22439 MT
(object in the heap.  Figure 2-5 shows that as a result of scanning A, objects B,)
64 W( C and D are)63 W
9288 24159 MT
(copied to B', C' and D', respectively, in next-space.)SH
12288 27771 MT
(The collector does not attempt to forward objects)
62 W( that span more than one heap page.)63 W
9288 29491 MT
(In the above example, objects B, C and D are assumed to be less than one heap page)
27 W( in size.)26 W
9288 31211 MT
(For larger objects, the collector simply promotes all their heap pages to next-space, thereby)67 W
9288 32931 MT
(saving the effort)
180 W( of having to find contiguous free heap pages to accommodate the large)179 W
9288 34651 MT
(object and copying it.)SH
12288 38263 MT
(During scanning, if a reference to a)
131 W( stable object is discovered, nothing needs to be)132 W
9288 39983 MT
(done. Stable)
410 W( objects do not need to be forwarded or promoted because they are)
55 W( retained by)54 W
9288 41703 MT
(the collector.  With generational collection, heap pages in the)
108 W( remembered set are scanned)109 W
9288 43423 MT
(also, in the same way that promoted heap pages are scanned.)SH
12288 47035 MT
(Garbage collection)
125 W( is over when all the next-space and stable heap pages have been)124 W
9288 48755 MT
(scanned. At)
922 W( this point)
311 W( all live pages have even space identifiers.  These even pages)312 W
9288 50475 MT
(constitute the stable)
48 W( set and are retained in the next collection.  Heap pages in current-space)47 W
9288 52195 MT
(can be recycled as free pages.  Garbage collection is terminated by setting)SH
/Courier SF
12888 53915 MT
(curr_space = curr_space+2;)SH
12888 55635 MT
(next_space = curr_space;)SH
/Times-Roman SF
9288 57355 MT
(This way once again we have)228 W
/Courier SF
25120 XM
(curr_space == next_space)228 W
/Times-Roman SF
(, just as it used to be)229 W
9288 59075 MT
(before garbage collection was initiated.)
77 W( The)
453 W( space identifier)76 W
/Courier SF
39313 XM
(curr_space)SH
/Times-Roman SF
46889 XM
(is incremented)76 W
9288 60795 MT
(by 2 so that the)
81 W( new heap pages to be allocated in current-space are distinguished from the)82 W
9288 62515 MT
(reclaimed, used-to-be current-space pages, and from the retained stable heap pages.)SH
10 SS 
30811 75600 MT
(-24-)SH
ES
%%Page: 25 25
BS
0 SI
14 /Times-Bold AF
28630 11947 MT
(Chapter 3)SH
15506 14560 MT
(Incremental, Generational Mostly-Copying Collection)SH
12 SS 
9288 18964 MT
(3.1 The Big Picture)SH
/Times-Roman SF
12288 22667 MT
(The essence of incremental collection is to)
207 W( minimize garbage collection pauses by)206 W
9288 24387 MT
(configuring the collector to scan only)
58 W( a bounded number of ``live'' objects at a time.  After)59 W
9288 26107 MT
(garbage collection is initiated, and after the necessary bookkeeping and setup)
262 W( work for)261 W
9288 27827 MT
(incremental collection is completed, the application program can proceed)
227 W( normally even)228 W
9288 29547 MT
(though garbage collection is not yet finished.  While in the non-incremental scheme the)208 W
9288 31267 MT
(application program can suffer a)
125 W( potentially long and detectable pause every time garbage)126 W
9288 32987 MT
(collection takes place;)
86 W( under the incremental scheme the application program is interrupted)85 W
9288 34707 MT
(intermittently to scan objects for a short duration of time.  This way)
131 W( garbage collection is)132 W
/Times-Italic SF
9288 36427 MT
(incrementalized)SH
/Times-Roman SF
(, because the total work needed for garbage collection is)
262 W( divided into a)261 W
9288 38147 MT
(number of comparable subtasks.  The subtasks are spread out)
55 W( over time, each subtask being)56 W
9288 39867 MT
(executed in a smaller time interval.)SH
12288 43479 MT
(Incremental collection is synchronized at the granularity of physical pages.)634 W
9288 45199 MT
(Incremental collection for applications running on commercially-available)
96 W( stock processors)97 W
9288 46919 MT
(depends crucially on the virtual memory system's provision to allow)
242 W( control for virtual)241 W
9288 48639 MT
(memory page protections.  At the start of incremental)
87 W( collection, the virtual memory pages)88 W
9288 50359 MT
(on which objects referenced by the roots reside are read/write protected, i.e. they)
39 W( are neither)38 W
9288 52079 MT
(readable nor writable.  In the context of the mostly-copying strategy, this means that)
174 W( the)175 W
/Times-Italic SF
9288 53799 MT
(physical pages)45 W
/Times-Roman SF
16779 XM
(containing one)
45 W( or more promoted)44 W
/Times-Italic SF
33369 XM
(heap pages)44 W
/Times-Roman SF
39190 XM
(are protected.  The application)44 W
9288 55519 MT
(is then allowed to resume as normal, while)
32 W( garbage collection is technically still "going on.")33 W
9288 57239 MT
(When the application attempts to)
163 W( access a protected page, a virtual memory page fault is)162 W
9288 58959 MT
(generated and program control is transferred to)
177 W( a special trap handler, which triggers the)178 W
9288 60679 MT
(garbage collector to do all)
41 W( necessary work in order to make the physical page needed by the)40 W
9288 62399 MT
(application accessible.)
9 W( To)
320 W( avoid the situation where the heap is exhausted by the application)10 W
9288 64119 MT
(allocation before garbage collection is completed, the collector can randomly select a)343 W
9288 65839 MT
(protected physical page to scan)
200 W( each time the application causes a new heap page to be)201 W
9288 67559 MT
(allocated.)SH
12288 71171 MT
(The GC work needed to be done at the page fault trap)
251 W( includes unprotecting the)250 W
10 SS 
30811 75600 MT
(-25-)SH
ES
%%Page: 26 26
BS
0 SI
12 SS 
95 100 0 2214 77256 GB 
%%BeginDocument: incr-picture.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Helvetica Times-Roman Times-Bold Courier-Bold
%%%Pages: 1
%%BoundingBox: 102 140 516 661
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 84 86 ] concat
%I
172 381 365 381 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 85 -107 ] concat
%I
172 381 365 381 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 84 86 ] concat
%I
366 381 366 189 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 84 86 ] concat
%I
172 380 172 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 80 86 ] concat
%I
202 379 202 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 110 87 ] concat
%I
202 379 202 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 139 87 ] concat
%I
202 379 202 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 166 87 ] concat
%I
202 379 202 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 194 87 ] concat
%I
202 379 202 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 222 87 ] concat
%I
202 379 202 189 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 84 79 ] concat
%I
173 351 367 351 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 83 0 ] concat
%I
173 351 367 351 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 82 38 ] concat
%I
173 351 367 351 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 84 -38 ] concat
%I
173 351 367 351 Line
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.25 SetP
%I t
[ 1 0 0 1 85 86 ] concat
%I
259 306 281 341 Rect
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 104 58 ] concat
%I
74 311 35 24 Elli
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 49 ] concat
%I
106 322 148 322 Line
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 56 ] concat
%I
105 306 148 306 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 159 375 ] concat
%I
[
(C P U)
] Text
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 106 53 ] concat
%I
345 323 369 323 Line
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 106 54 ] concat
%I
344 311 370 311 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 103 60 ] concat
%I
373 347 373 281 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 159 60 ] concat
%I
373 347 373 281 Line
End

Begin %I BSpl
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 61 ] concat
%I 3
369 345
397 328
425 344
3 BSpl
End

Begin %I BSpl
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 107 -3 ] concat
%I 3
369 345
397 328
425 344
3 BSpl
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 310 266 ] concat
%I
[
(Main Memory)
] Text
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 107 54 ] concat
%I
159 443 234 362 Line
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 0.814815 416 -108.815 ] concat
%I
49 501 11 13 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
1 SetP
%I t
[ 1 0 0 0.814815 249 30.185 ] concat
%I
49 501 11 13 Elli
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 0.814815 271 78.185 ] concat
%I
49 501 11 13 Elli
End

Begin %I BSpl
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 108 55 ] concat
%I 4
87 291
146 189
323 175
322 175
4 BSpl
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 111 55 ] concat
%I
320 175 330 173 Line
End

Begin %I Rect
%I b 65535
1 1 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.13907 0 0 0.917449 294.046 -250.182 ] concat
%I
51 446 201 519 Rect
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 108 55 ] concat
%I
393 173 260 347 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 108 55 ] concat
%I
244 335 366 175 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 209 291 ] concat
%I
[
(user)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 206 280 ] concat
%I
[
(process)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 376 219 ] concat
%I
[
(Mutator )
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-120-*
/Helvetica 12 SetF
%I t
[ 1 0 0 1 380 203 ] concat
%I
[
(. . .)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-120-*
/Helvetica 12 SetF
%I t
[ 1 0 0 1 380 177 ] concat
%I
[
(. . .)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-120-*
/Helvetica 12 SetF
%I t
[ 1 0 0 1 434 217 ] concat
%I
[
(\(user's prog.\))
] Text
End

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
1 SetP
%I t
[ 1 0 0 0.814815 327 -73.815 ] concat
%I
49 501 11 13 Elli
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 462 306 ] concat
%I
[
(1)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 317 492 ] concat
%I
[
(2)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 295 445 ] concat
%I
[
(3)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 373 340 ] concat
%I
[
(4)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-120-*
/Helvetica 12 SetF
%I t
[ 1 0 0 1 379 186 ] concat
%I
[
(b = p.val + q.val;)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-120-*
/Helvetica 12 SetF
%I t
[ 1 0 0 1 491 371 ] concat
%I
[
(DISK)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-bold-r-*-120-*
/Courier-Bold 12 SetF
%I t
[ 1 0 0 1 335 497 ] concat
%I
[
(unscanned page not)
(accessible - page trap)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-bold-r-*-120-*
/Courier-Bold 12 SetF
%I t
[ 1 0 0 1 480 313 ] concat
%I
[
(accesses a)
(page that has)
(not been)
(scanned)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-bold-r-*-120-*
/Courier-Bold 12 SetF
%I t
[ 1 0 0 1 265 425 ] concat
%I
[
(page trap)
(done)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-bold-r-*-120-*
/Courier-Bold 12 SetF
%I t
[ 1 0 0 1 329 323 ] concat
%I
[
(page access)
(granted)
] Text
End

Begin %I CBSpl
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 113 137 ] concat
%I 20
103 563
33 565
4 507
37 473
45 420
23 404
39 357
107 398
145 341
191 381
263 363
284 428
354 420
342 466
373 500
325 538
271 531
241 578
223 595
139 593
20 CBSpl
End

Begin %I Poly
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.05495 0 0 0.99315 78.2739 165.534 ] concat
%I 4
87 373
87 515
174 516
175 373
4 Poly
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 93 159 ] concat
%I
123 515 123 377 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 96 157 ] concat
%I
76 450 163 450 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 93 192 ] concat
%I
76 450 163 450 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 97 122 ] concat
%I
76 450 163 450 Line
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.5 SetP
%I t
[ 1 0 0 1 96 158 ] concat
%I
76 486 118 517 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.5 SetP
%I t
[ 1 0 0 1 96 123 ] concat
%I
76 486 118 517 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.5 SetP
%I t
[ 1 0 0 1 142 123 ] concat
%I
76 486 118 517 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 142 53 ] concat
%I
76 486 118 517 Rect
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
256 276 151 393 Line
End

Begin %I Rect
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
1 SetP
%I t
[ 1 0 0 1 106 124 ] concat
%I
178 401 202 417 Rect
End

Begin %I Rect
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 143 ] concat
%I
178 401 202 417 Rect
End

Begin %I Rect
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.5 SetP
%I t
[ 1 0 0 1 106 162 ] concat
%I
178 401 202 417 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 230 701 ] concat
%I
[
(Page Fault Trap)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 312 538 ] concat
%I
[
(Free)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 312 574 ] concat
%I
[
(Current)
] Text
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 96 53 ] concat
%I
76 486 118 517 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 312 556 ] concat
%I
[
(Stable)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-120-*
/Helvetica 12 SetF
%I t
[ 1 0 0 1 282 659 ] concat
%I
[
(- Unprotect physical)
(   page)
()
(- Scan current and stable)
(   heap page\(s\))
] Text
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
15308 68366 MT
(Figure 3-1:)SH
/Times-Roman SF
21608 XM
(Incremental, Generational, Mostly-Copying Collection)SH
10 SS 
30811 75600 MT
(-26-)SH
ES
%%Page: 27 27
BS
0 SI
10 /Times-Roman AF
44856 10262 MT
(3)SH
12 SS 
9288 10643 MT
(faulted virtual page and scanning the promoted heap pages inside it.)293 W
46543 XM
(This is termed)294 W
9288 12363 MT
(``mostly-copying'' collection because)
162 W( objects in the promoted heap pages are not moved.)161 W
9288 14083 MT
(They are referenced by the ambiguous roots)
44 W( and therefore their contents cannot be changed.)45 W
9288 15803 MT
(They are allowed to remain intact in)
97 W( the heap.  Only objects not directly referenced by the)96 W
9288 17523 MT
(root objects)
58 W( are copied into a more compact area in the heap, and their forward pointers are)59 W
9288 19243 MT
(updated in the root objects appropriately.)SH
12288 22855 MT
(When generational collection is added, not only)
91 W( do the)90 W
/Times-Italic SF
39641 XM
(promoted)SH
/Times-Roman SF
44631 XM
(heap pages need to)90 W
9288 24575 MT
(be scanned, heap pages in the remembered set have to be)
15 W( scanned also.  The remembered set)16 W
9288 26295 MT
(is the)
93 W( set of stable objects which have been mutated since the last time they were scanned.)92 W
9288 28015 MT
(To avoid trapping writes into stable objects, this version of the generational collector in fact)43 W
9288 29735 MT
(treats the entire stable set)
159 W( as the remembered set.  Objects become stable once they have)158 W
9288 31455 MT
(survived at least one collection.  They have to be scanned because)
17 W( if they have been mutated)18 W
9288 33175 MT
(since the last time)
168 W( they were scanned, they may contain pointers into newly-created \050and)167 W
9288 34895 MT
(hence unstable\051 objects.  Similar to the scanning)
141 W( and forwarding strategy described in the)142 W
9288 36615 MT
(previous paragraph, the unstable objects referenced by)
146 W( the stable ones are forwarded \050and)145 W
9288 38335 MT
(therefore become stable\051, and)
107 W( their forward pointers are updated in the stable objects.  GC)108 W
9288 40055 MT
(work on the physical page)
18 W( is complete after scanning and forwarding of promoted and stable)17 W
9288 41775 MT
(objects are done.  The physical page can be)
44 W( safely accessed by the application now, the trap)45 W
9288 43495 MT
(handler can exit, and the application then resumes from the point where it was interrupted.)SH
12288 47107 MT
(This process of faulting on)
343 W( a protected page, unprotecting it, and scanning and)342 W
9288 48827 MT
(forwarding objects inside it repeats until there are no more protected pages)
69 W( left in the heap.)70 W
9288 50547 MT
(Garbage collection is then complete, and the application)
34 W( executes with no interruptions until)33 W
9288 52267 MT
(the next time garbage collection is initiated.  Successive generational garbage)
179 W( collections)180 W
9288 53987 MT
(enlarge the set of stable heap pages to)
116 W( be retained in the heap.  When more than a certain)115 W
9288 55707 MT
(fraction of the heap is)
109 W( retained after a generational collection is finished, a)110 W
/Times-Italic SF
46653 XM
(total)SH
/Times-Roman SF
49265 XM
(collection)SH
9288 57427 MT
(will be carried out)
116 W( such that all live heap pages, whether they are ``young'' or ``old,'' are)115 W
9288 59147 MT
(collected. In)
390 W( addition, the heap can be expanded,)
45 W( if it is discovered that more than a certain)46 W
9288 60867 MT
(fraction of the heap is occupied after a total collection.  Figure 3-1 illustrates)
17 W( this scheme for)16 W
9288 62587 MT
(performing an incremental collection on a single-tasking)
24 W( stock processor utilizing a standard)25 W
9288 64307 MT
(virtual memory system.)SH
10800 50 9288 67780 UL
8 SS 
10288 69445 MT
(3)SH
10 SS 
10688 69790 MT
(For the moment consider only the case in which all)
79 W( the objects in the faulted page lie within the physical)80 W
9288 70895 MT
(page boundary,)
166 W( that is, only the faulted page will have to be unprotected and scanned.  A more elaborate)165 W
9288 72000 MT
(scheme for dealing with bigger objects spanning across physical pages will be discussed in section 3.2.4.1.)SH
30811 75600 MT
(-27-)SH
ES
%%Page: 28 28
BS
0 SI
12 /Times-Roman AF
12288 10399 MT
(The following section discusses)
318 W( how the incremental version of the generational)317 W
9288 12119 MT
(mostly-copying garbage collector is implemented in more)
69 W( detail.  In particular, the state-to-)70 W
9288 13839 MT
(state transitions of the different stages of the collection)
80 W( algorithm are described, along with)79 W
9288 15559 MT
(various special considerations that have to be taken into account in order)
313 W( to optimize)314 W
9288 17279 MT
(performance.)SH
/Times-Bold SF
9288 21683 MT
(3.2 An Incremental, Generational Mostly-Copying Collector)SH
9288 25367 MT
(3.2.1 Special Considerations)SH
/Times-Roman SF
12288 28350 MT
(To integrate Bartlett's generational mostly-copying)
388 W( collection algorithm into the)387 W
9288 30070 MT
(incremental framework, a few special)
41 W( considerations have to be taken into account.  Section)42 W
9288 31790 MT
(3.2.1.1 explains why the current-space/next-space partition of)
477 W( the heap in the non-)476 W
9288 33510 MT
(incremental collector must be)
372 W( adjusted to a current-space/previous-space/forward-space)373 W
9288 35230 MT
(partition. Section)
472 W( 3.2.1.2 states a new restriction on the choice of heap size and heap)
86 W( page)85 W
9288 36950 MT
(size. Section)
1216 W( 3.2.1.3 discusses the)
458 W( effects of the allocation algorithm on real-time)459 W
9288 38670 MT
(performance. Section)
642 W( 3.2.1.4 describes how the miscellaneous page status information is)170 W
9288 40390 MT
(handled.)SH
/Times-Bold SF
9288 43354 MT
(3.2.1.1 Space Numbers)SH
/Times-Roman SF
12288 45977 MT
(The current-space/next-space approach employed)
30 W( by Bartlett's collector works well in)31 W
9288 47697 MT
(the non-incremental framework because application allocation for a particular)
311 W( value of)310 W
/Courier SF
9288 49417 MT
(curr_space)SH
/Times-Roman SF
17285 XM
(is not intermixed with collector allocation for)
497 W( a particular value of)498 W
/Courier SF
9288 51137 MT
(next_space)SH
/Times-Roman SF
(. This)
618 W( two-space framework is not sufficient for the incremental collector,)158 W
9288 52857 MT
(because application allocation and collector allocation are)
387 W( intermixed.  After garbage)388 W
9288 54577 MT
(collection is)
248 W( initiated, all the heap pages that used to be in current-space and were not)247 W
9288 56297 MT
(promoted are now occupying memory which the collector is)
219 W( trying to reclaim.  But the)220 W
9288 58017 MT
(memory cannot be reclaimed until GC is completely)
29 W( finished, because some of these objects)28 W
9288 59737 MT
(may be referenced by objects in the)
129 W( promoted heap pages, i.e.  objects in this region may)130 W
9288 61457 MT
(still be salvaged.  While)
162 W( the collector is intermittently salvaging objects in this otherwise)161 W
9288 63177 MT
(reclaimable area, application allocation is going)
89 W( on.  Therefore, the reclaimable area which)90 W
9288 64897 MT
(used to be in current-space must be distinguished)
283 W( from the current-space in which the)282 W
9288 66617 MT
(application is)
18 W( allocating new heap pages.  A three-space approach is necessary because there)19 W
9288 68337 MT
(are three kinds of heap pages to)
468 W( differentiate: the newly-allocated heap pages, the)467 W
9288 70057 MT
(salvageable and used-to-be current-space heap pages, and the heap pages containing)428 W
9288 71777 MT
(forwarded/promoted objects.  The following is)
301 W( the modified space designation strategy)300 W
9288 73497 MT
(designed for incremental collection:)SH
10 SS 
30811 75600 MT
(-28-)SH
ES
%%Page: 29 29
BS
0 SI
12 /Symbol AF
11436 12565 MT
(\267)SH
/Times-Italic SF
12288 XM
(current-space)SH
/Times-Roman SF
19609 XM
(-- space where newly-allocated heap pages are found.  The)355 W
12288 13851 MT
(application allocates in the current-space, by)
186 W( setting the space number of the)185 W
12288 15137 MT
(allocated page to be)SH
/Courier SF
22155 XM
(curr_space)SH
/Times-Roman SF
(.)SH
/Symbol SF
11436 17166 MT
(\267)SH
/Times-Italic SF
12288 XM
(previous-space)SH
/Times-Roman SF
19871 XM
(-- space where unscanned and \050possibly\051 reclaimable)
16 W( heap pages)17 W
12288 18452 MT
(are found.  Heap pages which used to be in current-space before collection)240 W
12288 19738 MT
(begins and which are not promoted after collection has been)
346 W( initiated are)347 W
12288 21024 MT
(entered into previous-space \050denoted as)418 W
/Courier SF
33679 XM
(prev_space)SH
/Times-Roman SF
(\051, by)
418 W( asserting that)417 W
/Courier SF
12288 22310 MT
(prev_space)SH
/Times-Roman SF
20422 XM
(be equal)634 W
/Courier SF
26023 XM
(curr_space)SH
/Times-Roman SF
34157 XM
(at the start)
634 W( of collection, and)635 W
12288 23596 MT
(subsequently advancing the value of)SH
/Courier SF
30056 XM
(curr_space)SH
/Times-Roman SF
(.)SH
/Symbol SF
11436 25625 MT
(\267)SH
/Times-Italic SF
12288 XM
(forward-space)SH
/Times-Roman SF
19681 XM
(-- space where)
92 W( promoted heap pages and heap pages containing)91 W
12288 26911 MT
(forwarded objects are)
197 W( found.  The collector promotes pages into or allocates)198 W
12288 28197 MT
(pages in forward-space by setting the space number of)
73 W( the allocated page to be)72 W
/Courier SF
12288 29483 MT
(forw_space)SH
/Times-Roman SF
(.)SH
12288 33095 MT
(Collection in progress is)
808 W( indicated by the inequality)809 W
/Courier SF
43831 XM
(curr_space !=)809 W
9288 34815 MT
(forw_space)SH
/Times-Roman SF
(. Current-space)
370 W( and forward-space in the)
35 W( three-space scheme are the same as)34 W
9288 36535 MT
(current-space and next-space, respectively, in the two-space scheme.)
337 W( The)
976 W( addition of)338 W
9288 38255 MT
(previous-space holds \050temporarily\051 the used-to-be current-space)
568 W( objects, and allows)567 W
9288 39975 MT
(application allocation to continue while previous-space objects are being scanned.  At the)145 W
9288 41695 MT
(end of collection, the collector will)
120 W( be able to reclaim the previous-space pages by simply)119 W
9288 43415 MT
(changing the value of)SH
/Courier SF
19955 XM
(prev_space)SH
/Times-Roman SF
27455 XM
(to be equal to)SH
/Courier SF
34256 XM
(curr_space)SH
/Times-Roman SF
(.)SH
/Times-Bold SF
9288 46379 MT
(3.2.1.2 Heap Size and Heap Page Size)SH
/Times-Roman SF
12288 49002 MT
(The incremental collector performs GC work on the)
231 W( granularity of a unit of page)232 W
9288 50722 MT
(protection. On)
376 W( the DECStation 3100, a unit of page protection is a)
38 W( physical page.  On other)37 W
9288 52442 MT
(machines, this may be)
14 W( different.  Since it is undesirable to have the collector protect)15 W
/Times-Italic SF
50085 XM
(any)SH
/Times-Roman SF
52133 XM
(part)SH
9288 54162 MT
(of memory that does not belong to the garbage collected heap, the heap size must be a)213 W
9288 55882 MT
(multiple of the protection unit, meaning that for)
144 W( the DECStation implementation the heap)145 W
9288 57602 MT
(size is rounded to the nearest number of physical pages.)SH
12288 61214 MT
(To simplify the collector, the size of a protection unit)
56 W( must be evenly divisible by the)55 W
9288 62934 MT
(size of)
14 W( a heap page.  Bartlett has shown in)
15 W( [Bartlett)
SH( 88] that configuring the collector to have)15 W
9288 64654 MT
(smaller heap pages generally yields better)
81 W( performance.  He chose 512-byte heap pages for)80 W
9288 66374 MT
(the mostly-copying)
121 W( collector and its generational version, for both Scheme and C++.  The)122 W
9288 68094 MT
(incremental collector presented here also uses 512-byte heap pages, and the)
96 W( heap page and)95 W
9288 69814 MT
(physical page boundaries are aligned such that there are eight)
92 W( \0504096/512=8\051 heap pages on)93 W
9288 71534 MT
(each physical page.)SH
10 SS 
30811 75600 MT
(-29-)SH
ES
%%Page: 30 30
BS
0 SI
12 /Times-Bold AF
9288 10380 MT
(3.2.1.3 Allocation)SH
/Times-Roman SF
12288 13003 MT
(During each garbage collection pause the collector scans a certain amount of memory)48 W
9288 14723 MT
(and returns control to the application.  The less there is to)
50 W( scan at each GC pause, the better)51 W
9288 16443 MT
(the real-time performance)
330 W( is.  This is because when there is no object crossing page)329 W
9288 18163 MT
(boundaries at both ends of a physical page, then that physical)
87 W( page can be unprotected and)88 W
9288 19883 MT
(scanned as a unit.)
170 W( But)
639 W( when there is an object crossing either boundary, then instead of)169 W
9288 21603 MT
(unprotecting just one physical page, at)
45 W( least two physical pages will need to be unprotected,)46 W
9288 23323 MT
(and subsequently scanned.)SH
12288 26935 MT
(It is important to allocate objects in such a way that will minimize the amount of)200 W
9288 28655 MT
(memory that needs to be scanned each time.  The amount)
2 W( of memory to scan is dependent on)3 W
9288 30375 MT
(how the objects are laid out on the physical pages.  Scanning must be done in units)
156 W( of a)155 W
9288 32095 MT
(physical page, since a physical page is a page protection unit.  To illustrate this point with an)8 W
9288 33815 MT
(extreme example, assume)
93 W( that current-space consists of a set of contiguous physical pages,)92 W
9288 35535 MT
(and there are)16 W
/Times-Italic SF
15835 XM
(objects lying across each physical page boundary)16 W
/Times-Roman SF
(. Suppose)
332 W( that all the objects)16 W
9288 37255 MT
(are promoted to forward-space at the beginning of collection,)
20 W( and all the physical pages they)19 W
9288 38975 MT
(lie on are protected.  When it is necessary to scan any one of)
239 W( these objects, it will be)240 W
9288 40695 MT
(necessary to)40 W
/Times-Italic SF
15568 XM
(scan all of the protected physical pages)40 W
/Times-Roman SF
35152 XM
(as one unit.  Thus, the collector)
40 W( cannot)39 W
9288 42415 MT
(incrementally collect.)SH
/Times-Bold SF
9288 45379 MT
(3.2.1.4 Miscellaneous Bookkeeping)SH
/Times-Roman SF
12288 48002 MT
(The incremental collector)
375 W( often checks whether a physical page in the heap is)376 W
9288 49722 MT
(protected. This)
422 W( information is kept in an array indexed by physical page.  When)
61 W( a physical)60 W
9288 51442 MT
(page is)
390 W( protected, its corresponding protect map entry is set; and when the page is)391 W
9288 53162 MT
(unprotected, the same entry is cleared.)
53 W( The)
404 W( variable)52 W
/Courier SF
35129 XM
(protectedpages)SH
/Times-Roman SF
45561 XM
(holds the number)52 W
9288 54882 MT
(of physical pages that are still protected, and)
64 W( is maintained to be consistent with the protect)65 W
9288 56602 MT
(map.)SH
12288 60214 MT
(In the non-incremental collector,)218 W
/Courier SF
29196 XM
(allocatedpages)SH
/Times-Roman SF
39794 XM
(holds the number)
218 W( of ``live'')217 W
9288 61934 MT
(heap pages, and)48 W
/Courier SF
17364 XM
(stablepages)SH
/Times-Roman SF
25632 XM
(holds the number of heap pages with even)
48 W( space numbers.)49 W
9288 63654 MT
(For the incremental collector, this no longer)
83 W( works because as mentioned in section 3.2.1.1)82 W
9288 65374 MT
(we have added the notion)
150 W( of previous-space.  Instead, the following variables are used to)151 W
9288 67094 MT
(facilitate accounting:)SH
/Symbol SF
11436 70346 MT
(\267)SH
/Courier SF
12288 XM
(currentpages)SH
/Times-Roman SF
22179 XM
(-- number of heap)
951 W( pages currently allocated in)950 W
/Courier SF
12288 71632 MT
(curr_space)SH
/Times-Roman SF
(.)SH
10 SS 
30811 75600 MT
(-30-)SH
ES
%%Page: 31 31
BS
0 SI
12 /Symbol AF
11436 10536 MT
(\267)SH
/Courier SF
12288 XM
(forwardedpages)SH
/Times-Roman SF
22668 XM
(-- total number of stable heap pages.)SH
/Symbol SF
11436 12565 MT
(\267)SH
/Courier SF
12288 XM
(allocatedpages)SH
/Times-Roman SF
22810 XM
(-- total number of ``live'' heap pages, i.e. pages that)
142 W( are)143 W
12288 13851 MT
(not free for allocation.)SH
12288 17463 MT
(When the heap is first configured, all)
476 W( these variables are initialized to zero.)475 W
9288 19183 MT
(Application allocation causes both)19 W
/Courier SF
26234 XM
(currentpages)SH
/Times-Roman SF
35193 XM
(and)SH
/Courier SF
37245 XM
(allocatedpages)SH
/Times-Roman SF
47645 XM
(to increment.)20 W
9288 20903 MT
(When collection is initiated, what used to be in current-space is ``demoted'' to previous-)167 W
9288 22623 MT
(space, and)62 W
/Courier SF
14711 XM
(currentpages)SH
/Times-Roman SF
23713 XM
(is reset to zero.  Promoting pages causes)63 W
/Courier SF
43920 XM
(forwardedpages)SH
/Times-Roman SF
9288 24343 MT
(to increment.)
513 W( Subsequently)
1325 W( application allocation increments)512 W
/Courier SF
42815 XM
(currentpages)SH
/Times-Roman SF
52267 XM
(and)SH
/Courier SF
9288 26063 MT
(allocatedpages)SH
/Times-Roman SF
(, just as before.  When the collector allocates a page)
83 W( in forward-space,)84 W
9288 27783 MT
(both)SH
/Courier SF
11932 XM
(forwardedpages)SH
/Times-Roman SF
22522 XM
(and)SH
/Courier SF
24764 XM
(allocatedpages)SH
/Times-Roman SF
35353 XM
(are incremented.  When collection is)209 W
9288 29503 MT
(finished, the following assignment happens:)SH
/Courier SF
12888 31223 MT
(allocatedpages=currentpages + forwardedpages;)SH
/Times-Roman SF
9288 32943 MT
(which correctly exclude the reclaimed pages in the statistics.)SH
/Times-Bold SF
9288 36627 MT
(3.2.2 Before GC)SH
/Times-Roman SF
12288 39610 MT
(When the heap is)
125 W( first configured, all the heap pages are free and are given a space)126 W
9288 41330 MT
(number equal to 1.)
150 W( The)
599 W( current-space marker)149 W
/Courier SF
32717 XM
(curr_space)SH
/Times-Roman SF
40366 XM
(is set to 3 initially; and the)149 W
9288 43050 MT
(following condition is true)SH
/Courier SF
12888 44770 MT
(curr_space==forw_space==prev_space)SH
/Times-Roman SF
9288 46490 MT
(whenever garbage collection is not taking place.  Heap pages)
75 W( are allocated in current-space)76 W
9288 48210 MT
(until one-third)
443 W( of the heap is exhausted.  Unlike the non-incremental collector, the)442 W
9288 49930 MT
(incremental collector does not wait until collection)
108 W( is completely done before allowing the)109 W
9288 51650 MT
(application to resume.  Therefore collection must start)
157 W( sooner to allow the intermixing of)156 W
9288 53370 MT
(application allocation and collector allocation \050for forwarded objects\051.)
367 W( If)
1035 W( incremental)368 W
9288 55090 MT
(collection starts when one-half)
187 W( of the heap is exhausted, and assuming the worst case in)186 W
9288 56810 MT
(which all the previous-space objects have to)
289 W( be forwarded -- half of the heap will be)290 W
9288 58530 MT
(occupied by previous-space objects and the other half by their)
13 W( forwarded copies -- then there)12 W
9288 60250 MT
(will not be enough memory for the application to continue.)SH
/Times-Bold SF
9288 63934 MT
(3.2.3 Start GC)SH
/Times-Roman SF
12288 66917 MT
(The gist)
248 W( of incremental collection is to protect all the root objects at the start of)249 W
9288 68637 MT
(collection, and delay the process of scanning them until it is convenient to)
122 W( do so.  All the)121 W
9288 70357 MT
(ambiguous root pointers in the processor stack, registers and the)
136 W( program's static area are)137 W
10 SS 
30811 75600 MT
(-31-)SH
ES
%%Page: 32 32
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(identified. The)
380 W( heap pages which the ambiguous root pointers reference are ``promoted'' to)39 W
9288 12119 MT
(forward-space, by setting the space numbers of those)
267 W( pages to be)268 W
/Courier SF
43697 XM
(forw_space)SH
/Times-Roman SF
(. For)836 W
9288 13839 MT
(incremental collection to be correct, such that before garbage collection)
270 W( is over all the)269 W
9288 15559 MT
(objects accessible from the roots will)
18 W( be scanned and properly forwarded, the physical pages)19 W
9288 17279 MT
(containing the ambiguous root objects must be protected.)SH
/Times-Bold SF
9288 20243 MT
(3.2.3.1 Protecting Objects)SH
/Times-Roman SF
12288 22866 MT
(When there is)
18 W( an ambiguous root pointer in the stack or registers referencing an object)17 W
9288 24586 MT
(in the heap, not only the physical)
131 W( page containing that part of the object being referenced)132 W
9288 26306 MT
(needs to be protected.  If the object is big and spans across several physical pages,)
28 W( the entire)27 W
9288 28026 MT
(object has to be protected by protecting)118 W
/Times-Italic SF
29351 XM
(all the physical pages)119 W
/Times-Roman SF
40563 XM
(that it lies on.  It would be)119 W
9288 29746 MT
(incorrect to protect an object only)
21 W( partially, since the application would be able to access the)20 W
9288 31466 MT
(unprotected part, and might therefore access a previous-space pointer.)SH
12288 35078 MT
(The collector)
80 W( needs to protect the minimum number of physical pages containing the)81 W
9288 36798 MT
(ambiguous root object such that)
5 W( no object is protected partially.  This set of physical pages is)4 W
9288 38518 MT
(called a)69 W
/Times-Italic SF
13426 XM
(physical page cluster)69 W
/Times-Roman SF
(, and is defined as the set)
69 W( of contiguous physical pages which)70 W
9288 40238 MT
(have to be protected if any one object in any one of the pages is referenced by a root pointer.)SH
12288 43850 MT
(Figure 3-2 illustrates three situations the collector has to consider when protecting)
3 W( root)2 W
9288 45570 MT
(objects. Figure)
650 W( \050a\051 shows the case in which an ambiguous root)
175 W( pointer is pointing at an)176 W
9288 47290 MT
(object in a physical page which does not have any object crossing its page boundary;)
11 W( there is)10 W
9288 49010 MT
(only one physical page in the page cluster.  In)
49 W( figure \050b\051 there is one object spanning across)50 W
9288 50730 MT
(more than)
18 W( one physical pages, so the page cluster contains the set of physical pages from the)17 W
9288 52450 MT
(one containing the beginning of the object to the one containing)
49 W( the end.  In figure \050c\051 there)50 W
9288 54170 MT
(is more than one object crossing more than one physical)
39 W( page boundary, forming a ``chain'')38 W
9288 55890 MT
(of pages which must be protected.)SH
12288 59502 MT
(The type identifier of the heap pages is used to)
120 W( determine the extent of the physical)121 W
9288 61222 MT
(page cluster.  There should be no object crossing the)
97 W( page boundaries \050one at each end\051 of)96 W
9288 62942 MT
(the physical page cluster.  The first heap page of the cluster must be of type)220 W
/Courier SF
49380 XM
(OBJECT)SH
/Times-Roman SF
(,)SH
9288 64662 MT
(because a)227 W
/Courier SF
14674 XM
(CONTINUED)SH
/Times-Roman SF
21681 XM
(heap page would mean the head)
227 W( of the object is outside of the)226 W
9288 66382 MT
(cluster. The)
476 W( first heap page just after the end of the cluster must be of type)88 W
/Courier SF
47057 XM
(OBJECT)SH
/Times-Roman SF
51766 XM
(also,)SH
9288 68102 MT
(because a)3 W
/Courier SF
14225 XM
(CONTINUED)SH
/Times-Roman SF
21007 XM
(page there would have meant the continuation of an object is outside)2 W
10 SS 
30811 75600 MT
(-32-)SH
ES
%%Page: 33 33
BS
0 SI
12 SS 
10 10 0 2484 71496 GB 
%%BeginDocument: page_cluster.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Times-Roman
%%%Pages: 1
%%BoundingBox: 148 233 492 595
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 0.7 0 0 0.7 145.75 221.75 ] concat
%I
55 354 150 471 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 0.7 0 0 0.7 266.75 163.75 ] concat
%I
55 354 150 471 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 0.7 0 0 0.7 388.75 328.75 ] concat
%I
55 354 150 471 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 0.7 0 0 0.7 389.75 216.75 ] concat
%I
55 354 150 471 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 0.7 0 0 0.7 389.75 105.75 ] concat
%I
55 354 150 471 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 0.7 0 0 0.7 266.75 275.75 ] concat
%I
55 354 150 471 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.75 SetP
%I t
[ 0.7 0 0 0.7 133.55 208.7 ] concat
%I
80 408 117 430 Rect
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.75 SetP
%I t
[ 1 0 0 1 231 84 ] concat
%I
230 378 230 355 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.75 SetP
%I t
[ 1 0 0 1 231 195 ] concat
%I
230 378 230 355 Line
End

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.75 SetP
%I t
[ 1 0 0 1 109 141 ] concat
%I 4
208 382
208 407
251 407
251 381
4 MLine
End

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.75 SetP
%I t
[ 1 0 0 1 109 143 ] concat
%I 4
208 351
208 315
250 315
250 350
4 MLine
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.75 SetP
%I t
[ 1 0 0 1 135 142 ] concat
%I
204 378 204 355 Line
End

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.75 SetP
%I t
[ 1 0 0 1 231 195 ] concat
%I 4
208 382
208 407
251 407
251 381
4 MLine
End

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0.75 SetP
%I t
[ 1 0 0 1 233 196 ] concat
%I 4
208 351
208 315
250 315
250 350
4 MLine
End

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< ff 88 88 88 ff 88 88 88 > -1 SetP
%I t
[ 1 0 0 1 232 83 ] concat
%I 4
208 382
208 407
251 407
251 381
4 MLine
End

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< ff 88 88 88 ff 88 88 88 > -1 SetP
%I t
[ 1 0 0 1 233 85 ] concat
%I 4
208 351
208 315
250 315
250 350
4 MLine
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 208 345 ] concat
%I
[
(\(a\))
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 332 346 ] concat
%I
[
(\(b\))
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 456 346 ] concat
%I
[
(\(c\))
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 168 310 ] concat
%I
[
(\(a\) Objects do not cross physical page boundary, i.e. page cluster has)
(      only one page.)
(\(b\) Page cluster has one object crossing physical page boundary.)
(\(c\) Page cluster has more than one object crossing physical page boundary.)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 303 654 ] concat
%I
[
(Physical pages)
] Text
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
227 499 227 464 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
263 501 321 474 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 200 433 ] concat
%I
[
(Heap objects)
] Text
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
107 296 96 351 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
140 295 209 336 Line
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
20026 52508 MT
(Figure 3-2:)SH
/Times-Roman SF
26326 XM
(Objects and Physical Page Clusters)SH
10 SS 
15856 56835 MT
(4)SH
12 SS 
9288 57216 MT
(of the cluster.)SH
16956 XM
(Figure 3-3 illustrates the idea.)SH
/Times-Bold SF
9288 60180 MT
(3.2.3.2 Forward Region)SH
/Times-Roman SF
12288 62803 MT
(One reason for using a copying garbage collector is)
255 W( to compact memory.  When)254 W
9288 64523 MT
(objects are copied into)236 W
/Courier SF
21367 XM
(forw_space)SH
/Times-Roman SF
(, it is desirable to have them close to)
236 W( each other.)237 W
9288 66243 MT
(Because incremental collection distributes the task of)
25 W( scanning objects over several intervals)24 W
10800 50 9288 68885 UL
8 SS 
10288 70550 MT
(4)SH
10 SS 
10688 70895 MT
(Invalid heap)
136 W( pages outside of the heap are of type)137 W
8 SS 
32163 XM
(OBJECT)SH
10 SS 
(, so this method of determining page clusters)137 W
9288 72000 MT
(never mistakes an invalid page to be in the cluster.)SH
30811 75600 MT
(-33-)SH
ES
%%Page: 34 34
BS
0 SI
12 SS 
1 1 0 2124 61776 GB 
%%BeginDocument: det_cluster.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Times-Roman
%%%Pages: 1
%%BoundingBox: 154 273 456 504
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 61 -9 ] concat

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< ff 00 00 00 ff 00 00 00 > -1 SetP
%I t
[ 1 0 0 1 -26 68 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< 77 bb ee dd 77 bb ee dd > -1 SetP
%I t
[ 1 0 0 1 -13 68 ] concat
%I
160 371 169 423 Rect
End

End %I eop

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 64 0 ] concat

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< ff 00 00 00 ff 00 00 00 > -1 SetP
%I t
[ 1 0 0 1 119 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< 77 bb ee dd 77 bb ee dd > -1 SetP
%I t
[ 1 0 0 1 132 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< ff 00 00 00 ff 00 00 00 > -1 SetP
%I t
[ 1 0 0 1 145 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< ff 00 00 00 ff 00 00 00 > -1 SetP
%I t
[ 1 0 0 1 197 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< ff 00 00 00 ff 00 00 00 > -1 SetP
%I t
[ 1 0 0 1 210 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< ff 00 00 00 ff 00 00 00 > -1 SetP
%I t
[ 1 0 0 1 184 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< 77 bb ee dd 77 bb ee dd > -1 SetP
%I t
[ 1 0 0 1 171 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< 77 bb ee dd 77 bb ee dd > -1 SetP
%I t
[ 1 0 0 1 158 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 132 59 ] concat
%I
141 367 252 429 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< 77 bb ee dd 77 bb ee dd > -1 SetP
%I t
[ 1 0 0 1 6 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< ff 00 00 00 ff 00 00 00 > -1 SetP
%I t
[ 1 0 0 1 19 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< ff 00 00 00 ff 00 00 00 > -1 SetP
%I t
[ 1 0 0 1 32 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< ff 00 00 00 ff 00 00 00 > -1 SetP
%I t
[ 1 0 0 1 84 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< ff 00 00 00 ff 00 00 00 > -1 SetP
%I t
[ 1 0 0 1 97 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< 77 bb ee dd 77 bb ee dd > -1 SetP
%I t
[ 1 0 0 1 71 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< 77 bb ee dd 77 bb ee dd > -1 SetP
%I t
[ 1 0 0 1 58 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< 77 bb ee dd 77 bb ee dd > -1 SetP
%I t
[ 1 0 0 1 45 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 19 59 ] concat
%I
141 367 252 429 Rect
End

End %I eop

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 -49 0 ] concat

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< 77 bb ee dd 77 bb ee dd > -1 SetP
%I t
[ 1 0 0 1 358 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< 77 bb ee dd 77 bb ee dd > -1 SetP
%I t
[ 1 0 0 1 345 59 ] concat
%I
160 371 169 423 Rect
End

Begin %I MLine
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 106 135 ] concat
%I 4
420 353
394 353
394 290
421 290
4 MLine
End

End %I eop

Begin %I MLine
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 169 134 ] concat
%I 4
25 354
51 354
51 292
25 292
4 MLine
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< 77 bb ee dd 77 bb ee dd > -1 SetP
%I t
[ 1 0 0 1 72 -64 ] concat
%I
160 371 169 423 Rect
End

Begin %I Rect
%I b 65535
1 1 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
< ff 00 00 00 ff 00 00 00 > -1 SetP
%I t
[ 1 0 0 1 194 -63 ] concat
%I
160 371 169 423 Rect
End

Begin %I MLine
%I b 65535
1 1 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 141 ] concat
%I 4
118 281
118 270
342 270
341 282
4 MLine
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 99 143 ] concat
%I
382 314 402 314 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 111 144 ] concat
%I
79 312 65 312 Line
End

Begin %I MLine
%I b 65535
1 1 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 107 143 ] concat
%I 2
354 340
354 365
2 MLine
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 270 522 ] concat
%I
[
(First heap page after end of cluster is OBJECT)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 252 342 ] concat
%I
[
(OBJECT)
(heap page)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 374 343 ] concat
%I
[
(CONTINUED)
(heap page)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 175 554 ] concat
%I
[
(First heap page of cluster is OBJECT)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 263 404 ] concat
%I
[
(    A physical page cluster)
(\(containing 2 physical pages\))
] Text
End

Begin %I Line
%I b 65535
1 1 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
129 343 129 397 Line
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
20276 38828 MT
(Figure 3-3:)SH
/Times-Roman SF
26576 XM
(Determining physical page cluster)SH
9288 43292 MT
(in time, forwarding objects in)
57 W( garbage collection mode occurs intermittently with allocating)58 W
9288 45012 MT
(new objects in application mode.  If special care is not taken)
234 W( to treat the two kinds of)233 W
9288 46732 MT
(allocations differently, the resulting heap is likely to be very ``fragmented'',)
12 W( with a few heap)13 W
9288 48452 MT
(pages of forwarded objects, followed by a)
137 W( few of newly-allocated objects, and so on.  To)136 W
9288 50172 MT
(deal with this problem, a ``forward region'' is reserved at the start of collection,)
89 W( by setting)90 W
/Courier SF
9288 51892 MT
(forw_freepage)SH
/Times-Roman SF
19581 XM
(to be equal to)632 W
/Courier SF
28910 XM
(curr_freepage)SH
/Times-Roman SF
39202 XM
(and subsequently advancing)632 W
/Courier SF
9288 53612 MT
(curr_freepage)SH
/Times-Roman SF
19028 XM
(to a number of free heap pages beyond the current value.  The variable)80 W
/Courier SF
9288 55332 MT
(curr_freepage)SH
/Times-Roman SF
18992 XM
(holds the page)
44 W( number of the first free page that will be allocated for an)43 W
9288 57052 MT
(application heap page in current-space; likewise,)165 W
/Courier SF
33980 XM
(forw_freepage)SH
/Times-Roman SF
43805 XM
(is the first free page)165 W
9288 58772 MT
(that will be allocated in)
590 W( forward-space.  By spacing out)589 W
/Courier SF
42018 XM
(curr_freepage)SH
/Times-Roman SF
52267 XM
(and)SH
/Courier SF
9288 60492 MT
(forw_freepage)SH
/Times-Roman SF
(, a ``forward region'' is set up consisting)
27 W( of a group of heap pages where)28 W
9288 62212 MT
(the forwarded objects are likely to be copied.)SH
10 SS 
30811 75600 MT
(-34-)SH
ES
%%Page: 35 35
BS
0 SI
12 /Times-Bold AF
9288 10380 MT
(3.2.4 During GC)SH
9288 13344 MT
(3.2.4.1 Page Fault Trap)SH
/Times-Roman SF
12288 15967 MT
(When the application)
246 W( accesses an object on a protected physical page, the virtual)245 W
9288 17687 MT
(memory system generates a page fault signal.  This signal interrupts the)
59 W( application process)60 W
9288 19407 MT
(and causes program control to be)
72 W( transferred to a fault handler.  The fault handler finds out)71 W
9288 21127 MT
(the faulting address of the protected page, and figures out the physical)
205 W( page cluster that)206 W
9288 22847 MT
(needs to be unprotected and scanned \050see section)
268 W( 3.2.3.1\051.  The handler unprotects the)267 W
9288 24567 MT
(physical page\050s\051)
64 W( in the page cluster and then calls the garbage collector's procedure to scan)65 W
9288 26287 MT
(the page cluster.  All the physical page\050s\051)
1 W( in the page cluster are unprotected at the beginning)SH
9288 28007 MT
(of the scanning, and)SH
/Times-Italic SF
19255 XM
(stay unprotected)SH
/Times-Roman SF
27523 XM
(throughout.)SH
/Times-Bold SF
9288 30971 MT
(3.2.4.2 Scanning Objects)SH
/Times-Roman SF
12288 33594 MT
(The basic scanning algorithm)
179 W( for the incremental collector is like that for the non-)180 W
9288 35314 MT
(incremental collector described)
286 W( in section 2.2.3.  The page cluster represents a unit of)285 W
9288 37034 MT
(scanning work and is therefore also)
20 W( called the)21 W
/Times-Italic SF
31719 XM
(scan region)21 W
/Times-Roman SF
(. The)
342 W( scanning procedure looks at)21 W
9288 38754 MT
(all the promoted and stable heap pages in the)
341 W( scan region, and scans the objects by)340 W
9288 40474 MT
(proceeding in a breadth-first manner.  However, there are)
370 W( additional concerns in the)371 W
9288 42194 MT
(incremental collector which do not arise in the non-incremental one.)SH
12288 45806 MT
(The concerns are primarily due to efficiency requirements imposed by the real-time)140 W
9288 47526 MT
(aspect of the incremental collector.  To)
279 W( achieve satisfactory real-time performance, the)280 W
9288 49246 MT
(collector must spend)
244 W( as little time as necessary in scanning the scan region, and return)243 W
9288 50966 MT
(control to the application)
35 W( as quickly as possible.  Therefore, the collector should scan all the)36 W
9288 52686 MT
(necessary objects, but not any more than)
278 W( necessary.  This criterion directly affects the)277 W
9288 54406 MT
(allocation of forward-space heap pages for)
134 W( the forwarded objects.  Because the forwarded)135 W
9288 56126 MT
(objects must)
37 W( be scanned eventually, they will have to be protected.  If the forwarded objects)36 W
9288 57846 MT
(were allowed to be allocated in the scan)
29 W( region, then the scanning routine will have to finish)30 W
9288 59566 MT
(scanning these newly-forwarded objects before it can revert control to)
307 W( the application.)306 W
9288 61286 MT
(Additionally, scanning the forwarded objects might in turn cause more)
54 W( to be forwarded into)55 W
9288 63006 MT
(the scan region.)SH
12288 66618 MT
(To avoid scanning more objects than absolutely necessary,)
188 W( a special forward-space)187 W
9288 68338 MT
(allocation discipline is enforced where)8 W
/Times-Italic SF
28164 XM
(the forwarded objects are always allocated outside of)9 W
9288 70058 MT
(the scan region)10 W
/Times-Roman SF
(. Figure)
320 W( 3-4 shows the same data structure as)
10 W( in figure 2-2, but with object A)9 W
9288 71778 MT
(being on a different physical page from the rest of)
194 W( the objects.  The bold outline of the)195 W
10 SS 
30811 75600 MT
(-35-)SH
ES
%%Page: 36 36
BS
0 SI
12 SS 
1 1 0 -1476 67176 GB 
%%BeginDocument: scan_a_1.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Times-Bold Times-Roman
%%%Pages: 1
%%BoundingBox: 246 358 432 561
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 258.214 224.214 ] concat
%I
54 295 101 318 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 332.214 536.214 ] concat
%I
[
(A)
] Text
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 258.214 126.214 ] concat
%I
54 295 101 318 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 258.214 156.214 ] concat
%I
54 295 101 318 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 258.214 184.214 ] concat
%I
54 295 101 318 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 257.214 226.214 ] concat
%I
45 175 126 282 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 331.214 496.214 ] concat
%I
[
(B)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 332.214 468.214 ] concat
%I
[
(C)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 331.214 438.214 ] concat
%I
[
(D)
] Text
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 235.214 238.214 ] concat
%I 4
125 250
137 250
137 229
125 229
4 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 235.214 238.214 ] concat
%I 4
125 220
136 220
136 198
125 198
4 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 235.214 237.214 ] concat
%I 4
76 294
56 294
56 253
76 253
4 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 235.214 236.214 ] concat
%I 4
76 300
42 300
42 230
76 230
4 MLine
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 258.214 338.214 ] concat
%I
45 175 126 282 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 435 518 ] concat
%I
[
(Physical)
(pages)
] Text
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
323 380 279 412 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
326 350 278 318 Line
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
24060 36668 MT
(Figure 3-4:)SH
/Times-Roman SF
30360 XM
(Scanning object A)SH
9288 41132 MT
(rectangle enclosing A indicates that the physical page)
376 W( containing A is protected and)375 W
10 SS 
33343 42471 MT
(5)SH
12 SS 
9288 42852 MT
(currently causing a virtual memory page fault.)303 W
35049 XM
(Therefore the page cluster has to be)303 W
9288 44572 MT
(unprotected and)
160 W( scanned.  Assume again that objects B, C, and D are less than one heap)159 W
9288 46292 MT
(page in size, so that they will have to be copied.)
35 W( Figure)
371 W( 3-5 shows the result of scanning A:)36 W
9288 48012 MT
(the objects B and C that A directly references are)
275 W( forwarded to another physical page)274 W
9288 49732 MT
(\050outside the scan region\051, and)
269 W( their copies B' and C' are subsequently protected.  The)270 W
9288 51452 MT
(forward pointers of B and C can be found)
68 W( in B's and C's header words.  A forward pointer)67 W
9288 53172 MT
(indicates the location of the copied object,)
95 W( so that other objects containing reference to the)96 W
9288 54892 MT
(forwarded object can subsequently update the reference)
68 W( with the new location.  In addition,)67 W
9288 56612 MT
(A's internal pointers to B and C)
304 W( are updated to point to the forwarded copies.  This)305 W
9288 58332 MT
(completes scanning, and)
45 W( the physical page containing A can be accessible to the application)44 W
9288 60052 MT
(now.)SH
12288 63664 MT
(Scanning is triggered again when the physical page containing)
185 W( B' and C' causes a)186 W
9288 65384 MT
(page fault.  Scanning B' corrects its internal pointer \050which still points to)
18 W( C when the fault is)17 W
10800 50 9288 67780 UL
8 SS 
10288 69445 MT
(5)SH
10 SS 
10688 69790 MT
(Note that although the page containing)
128 W( B, C and D is not protected, by the invariant of the incremental)129 W
9288 70895 MT
(collector, the application program will never access these objects without going through)
137 W( the pointers in the)136 W
9288 72000 MT
(forw-space \050or stable\051 objects \050see invariants listed in 1.3\051.)SH
30811 75600 MT
(-36-)SH
ES
%%Page: 37 37
BS
0 SI
12 SS 
1 1 0 684 65736 GB 
%%BeginDocument: scan_a_2.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Times-Bold
%%%Pages: 1
%%BoundingBox: 190 343 407 547
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 203 210 ] concat
%I
54 295 101 318 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 204 110 ] concat
%I
54 295 101 318 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 204 140 ] concat
%I
54 295 101 318 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 204 168 ] concat
%I
54 295 101 318 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 327 204 ] concat
%I
54 295 101 318 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 203 210 ] concat
%I
45 175 126 282 Rect
End

Begin %I Rect
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 325 150 ] concat
%I
45 286 125 388 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 327 176 ] concat
%I
54 295 101 318 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 277 522 ] concat
%I
[
(A)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 277 480 ] concat
%I
[
(B)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 278 452 ] concat
%I
[
(C)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 277 422 ] concat
%I
[
(D)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 399 516 ] concat
%I
[
(B')
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 398 488 ] concat
%I
[
(C')
] Text
End

Begin %I MLine
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 0.75 181 287.2 ] concat
%I 4
124 253
162 253
162 292
199 292
4 MLine
End

Begin %I MLine
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 0.891892 181 246.324 ] concat
%I 4
124 225
174 225
174 261
200 261
4 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 181 222 ] concat
%I 4
76 294
56 294
56 253
76 253
4 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 181 222 ] concat
%I 4
76 300
42 300
42 230
76 230
4 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 181 222 ] concat
%I 4
125 250
137 250
137 229
125 229
4 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 181 222 ] concat
%I 4
125 220
136 220
136 198
125 198
4 MLine
End

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 93 -142 ] concat

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
30 498 42 486 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
42 498 31 487 Line
End

End %I eop

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 79 -165 ] concat

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
30 498 42 486 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I
42 498 31 487 Line
End

End %I eop

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 180 225 ] concat
%I 2
124 293
200 293
2 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 181 222 ] concat
%I 4
124 290
176 290
176 266
200 266
4 MLine
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 204 323 ] concat
%I
45 175 126 282 Rect
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
23160 35948 MT
(Figure 3-5:)SH
/Times-Roman SF
29460 XM
(Scanning object A - II)SH
1 1 0 1044 96469 GB 
%%BeginDocument: scan_a_3.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Times-Bold
%%%Pages: 1
%%BoundingBox: 157 343 456 542
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 133 210 ] concat
%I
54 295 101 318 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 134 110 ] concat
%I
54 295 101 318 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 134 140 ] concat
%I
54 295 101 318 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 134 168 ] concat
%I
54 295 101 318 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 257 204 ] concat
%I
54 295 101 318 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 133 210 ] concat
%I
45 175 126 282 Rect
End

Begin %I Rect
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 255 150 ] concat
%I
45 286 125 388 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 257 176 ] concat
%I
54 295 101 318 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 207 522 ] concat
%I
[
(A)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 207 480 ] concat
%I
[
(B)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 208 452 ] concat
%I
[
(C)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 207 422 ] concat
%I
[
(D)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 329 516 ] concat
%I
[
(B')
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 328 488 ] concat
%I
[
(C')
] Text
End

Begin %I MLine
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 0.75 111 287.2 ] concat
%I 4
124 253
162 253
162 292
199 292
4 MLine
End

Begin %I MLine
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 0.891892 111 246.324 ] concat
%I 4
124 225
174 225
174 261
200 261
4 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 110 225 ] concat
%I 2
124 293
200 293
2 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 111 222 ] concat
%I 4
124 290
176 290
176 266
200 266
4 MLine
End

Begin %I Rect
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 379 168 ] concat
%I
45 286 125 388 Rect
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 383 215 ] concat
%I
54 295 101 318 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 456 527 ] concat
%I
[
(D')
] Text
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1.06667 107 120.614 ] concat
%I 4
252 338
289 338
289 378
329 378
4 MLine
End

Begin %I MLine
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1.05825 107 121.155 ] concat
%I 4
129 273
305 273
305 375
330 375
4 MLine
End

Begin %I MLine
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 107 143 ] concat
%I 4
252 368
263 368
263 343
252 343
4 MLine
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 134 212 ] concat
%I
45 286 125 388 Rect
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
22960 65961 MT
(Figure 3-6:)SH
/Times-Roman SF
29260 XM
(Scanning object A - III)SH
9288 70425 MT
(generated\051 to point to C' instead, as illustrated in figure 3-6.  C' is not)
248 W( copied \050again\051)249 W
10 SS 
30811 75600 MT
(-37-)SH
ES
%%Page: 38 38
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(because it is already forwarded)
230 W( and therefore stable.  Stable objects are retained by the)229 W
9288 12119 MT
(collector and their locations do not change.)
78 W( They)
457 W( are also guaranteed to be scanned before)79 W
9288 13839 MT
(collection is over.  Scanning)
36 W( C' is similar to that for scanning A: D is copied into D', on yet)35 W
9288 15559 MT
(another physical)
42 W( page outside of the current scan region containing B' and C'.  The forward)43 W
9288 17279 MT
(pointer in D's)
90 W( header is updated to point to D', and the internal pointer in C' is updated to)89 W
9288 18999 MT
(point to)
66 W( D' as well.  D' will be protected after this level of scanning is complete.  Since D')67 W
9288 20719 MT
(does not have)
66 W( any reference to other objects, scanning D' later in collection does cause any)65 W
9288 22439 MT
(additional forwarding.  \050The above describes the basics)
203 W( of the scanning strategy, section)204 W
9288 24159 MT
(3.2.4.4 will discuss a memory fragmentation)
65 W( problem entailed by this scheme and present a)64 W
9288 25879 MT
(revised design.\051)SH
12288 29491 MT
(In general, if a stable pointer is discovered)
74 W( when scanning an object, no further work)75 W
9288 31211 MT
(needs to be done.  For an internal)
46 W( pointer to an unstable object, there are a few possibilities,)45 W
9288 32931 MT
(as outlined in figure 3-7.  In)
70 W( this example, scanning C' discovers a pointer to D, which is a)71 W
9288 34651 MT
(small object outside of the scan region, so D is forwarded.  All)
176 W( \050unstable\051 small objects,)175 W
9288 36371 MT
(whether outside or inside the scan region, are forwarded in the hope of compacting memory.)SH
1 1 0 684 88777 GB 
%%BeginDocument: scan_unstable.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Helvetica Times-Roman
%%%Pages: 1
%%BoundingBox: 157 350 453 490
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 247 497 ] concat
%I
[
(Promote and)
(protect object)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 387 497 ] concat
%I
[
(Scan object )
(before exit)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 247 430 ] concat
%I
[
(Forward object)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-helvetica-medium-r-*-140-*
/Helvetica 14 SetF
%I t
[ 1 0 0 1 388 430 ] concat
%I
[
(Forward object)
] Text
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1.07759 140 28.0086 ] concat
%I
80 336 363 451 Rect
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 140 63 ] concat
%I
80 389 363 389 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 140 63 ] concat
%I
222 451 222 327 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 264 541 ] concat
%I
[
( OUTSIDE)
(scan region)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 406 541 ] concat
%I
[
(  INSIDE)
(scan region)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 185 488 ] concat
%I
[
(  BIG)
(object)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 176 435 ] concat
%I
[
(SMALL)
( object)
] Text
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
19359 58989 MT
(Figure 3-7:)SH
/Times-Roman SF
25659 XM
(Scanning strategy for unstable objects)SH
12288 64956 MT
(However, when a pointer to a large object is)
89 W( discovered, the location of the object is)90 W
9288 66676 MT
(important. If)
664 W( the large object resides outside of the scan)
182 W( region, then its heap pages are)181 W
9288 68396 MT
(promoted to forward-space, and the physical page\050s\051 where)
93 W( it reside on is/are protected.  It)94 W
9288 70116 MT
(involves more work if the large)
58 W( object is inside the scan region, because no part of the scan)57 W
9288 71836 MT
(region can be protected.)
151 W( Therefore)
604 W( the object must be promoted)152 W
/Times-Italic SF
42092 XM
(and)SH
/Times-Roman SF
44344 XM
(scanned. Since)
604 W( the)152 W
10 SS 
30811 75600 MT
(-38-)SH
ES
%%Page: 39 39
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(scan region is always scanned in)
20 W( order -- the scan pointer makes one pass through the region)19 W
9288 12119 MT
(and scans all objects which need to be scanned -- it can be determined)
276 W( with certainty)277 W
9288 13839 MT
(whether an object in the scan region has had its chance to be)
178 W( scanned by comparing the)177 W
9288 15559 MT
(address of that object with the scanning pointer.  If the large object about to be)
10 W( promoted has)11 W
9288 17279 MT
(not been swept by the scanning pointer, then it can be safely assumed)
194 W( that the scanning)193 W
9288 18999 MT
(pointer will get to it later, realize that)
129 W( it has been made a stable object, and will therefore)130 W
9288 20719 MT
(scan it.  If on the other hand the object has already been)
36 W( swept by the scanning pointer, then)35 W
9288 22439 MT
(the scanning procedure will have to ``backtrack'' to scan)
208 W( it properly.  Correct operation)209 W
9288 24159 MT
(requires that all)
199 W( the promoted objects in the scan region be scanned before the scanning)198 W
9288 25879 MT
(procedure exits.)SH
12288 29491 MT
(Depending upon the operating)
69 W( system the collector runs on, the cost of physical page)70 W
9288 31211 MT
(protection facility may dominate the overhead of incremental collection.  For this reason,)
72 W( it)71 W
9288 32931 MT
(is desirable to not only)
75 W( minimize the amount of scanning each time the program pauses for)76 W
9288 34651 MT
(garbage collection, but to minimize the)
51 W( number of memory protection calls.  The naive way)50 W
9288 36371 MT
(of implementing the forwarding strategy would be:)SH
11688 39486 MT
(1.)SH
12888 XM
(Unprotect the physical page containing the)
250 W( object to be forwarded, if it is)251 W
12888 40772 MT
(protected.)SH
11688 42801 MT
(2.)SH
12888 XM
(Allocate a heap page in forward-space if necessary.)SH
11688 44830 MT
(3.)SH
12888 XM
(Unprotect the enclosing physical page if it is protected.)SH
11688 46859 MT
(4.)SH
12888 XM
(Copy the object onto the current actively forward heap page.)SH
11688 48888 MT
(5.)SH
12888 XM
(Protect the physical page containing this forward heap page.)SH
11688 50917 MT
(6.)SH
12888 XM
(Protect the physical page containing the forwarded object if it was unprotected)31 W
12888 52203 MT
(in step 1.)SH
9288 55952 MT
(Although this is)
77 W( a correct implementation, it is unnecessarily inefficient because more calls)78 W
9288 57672 MT
(to protect/unprotect physical pages would have to be)
50 W( made.  It is usually the case that a few)49 W
9288 59392 MT
(forward-space heap pages are allocated on the same)
188 W( physical page, and a few forwarded)189 W
9288 61112 MT
(objects are copied on the)
39 W( same forward-space heap page.  Therefore it is wasteful to have to)38 W
9288 62832 MT
(go through steps 3 and 5 on each copying operation.  In the case where many forwarded)155 W
9288 64552 MT
(objects tend to scatter on only a few physical pages, it would be costly to)
45 W( repeat steps 1 and)44 W
9288 66272 MT
(6 for every)
202 W( forwarded object.  To minimize the number of memory protection calls, the)203 W
9288 67992 MT
(scanning procedure registers those physical pages that are)
63 W( unprotected in steps 1 and 3, and)62 W
9288 69712 MT
(remember to protect them before scanning exits.  This strategy effectively unprotects all the)49 W
9288 71432 MT
(necessary pages demanded by the scanning process and delays having to)
6 W( reprotect them until)5 W
9288 73152 MT
(the very end.)SH
10 SS 
30811 75600 MT
(-39-)SH
ES
%%Page: 40 40
BS
0 SI
12 /Times-Bold AF
9288 10380 MT
(3.2.4.3 Application Allocation)SH
/Times-Roman SF
12288 13003 MT
(With only minor refinement, the)
344 W( incremental collector's allocation algorithm for)345 W
9288 14723 MT
(newly-created current-space \050application\051 objects follows closely from the)
92 W( one for the non-)91 W
9288 16443 MT
(incremental collector described in section 2.2.2.  Regardless of whether)
206 W( there is garbage)207 W
9288 18163 MT
(collection ``going on,'' the collector finds a free heap page and allocates)
593 W( it in)592 W
/Courier SF
9288 19883 MT
(curr_space)SH
/Times-Roman SF
(. If)
796 W( there is indeed unfinished garbage collection work, then a protected)248 W
9288 21603 MT
(physical page is selected \050randomly\051 to be scanned every time a current-space)
93 W( allocation is)92 W
9288 23323 MT
(requested. This)
442 W( ensures that scanning will catch up with application allocation, so)
71 W( that it is)72 W
9288 25043 MT
(less likely the heap will run out of space before collection is over.)SH
12288 28655 MT
(Another refinement is that the incremental allocation algorithm has to)
140 W( be concerned)139 W
9288 30375 MT
(with)SH
/Times-Italic SF
11781 XM
(page clusters)59 W
/Times-Roman SF
(. Scanning)
418 W( occurs on the granularity of one page cluster at a)
59 W( time, so the)60 W
9288 32095 MT
(length of a garbage collection pause)
121 W( is directly proportional to the size of the page cluster)120 W
9288 33815 MT
(\050the scan region\051, thus it is important)
104 W( that page clusters are not allowed to grow arbitrarily)105 W
9288 35535 MT
(large, or the purpose of incremental collection will be defeated.  Recall in figure)
36 W( 3-2 \050c\051 that)35 W
9288 37255 MT
(a big page cluster)
71 W( spanning several pages is formed when there are objects \050larger than one)72 W
9288 38975 MT
(heap page in size\051 crossing physical page boundaries on consecutive)
178 W( physical pages.  To)177 W
9288 40695 MT
(limit the size of page)
125 W( clusters, the current implementation forbids page clusters with more)126 W
9288 42415 MT
(than one object crossing the physical page boundary.)
21 W( By)
340 W( checking the type identifiers of the)20 W
9288 44135 MT
(heap pages at the neighboring physical page)
167 W( boundaries, the allocation procedure verifies)168 W
9288 45855 MT
(that the heap page\050s\051 about to be allocated do not contribute to the)
36 W( creation of a page cluster)35 W
9288 47575 MT
(consisting of more than one object crossing page boundary.  It)
202 W( is possible to adjust this)203 W
9288 49295 MT
(restriction to)
132 W( tune performance on different hardware platforms.  For instance, if scanning)131 W
9288 51015 MT
(can be)
33 W( carried out faster on a high performance machine, then the restriction on page cluster)34 W
9288 52735 MT
(size could allow more pages and still achieve satisfactory collection pauses.)SH
/Times-Bold SF
9288 55699 MT
(3.2.4.4 Collector Allocation)SH
/Times-Roman SF
12288 58322 MT
(Section 3.2.4.2 mentions that forwarded objects are always copied)
107 W( into areas outside)106 W
9288 60042 MT
(of the scan region, so that scanning proceeds in a)
21 W( breath-first manner and pauses can be kept)22 W
9288 61762 MT
(short. In)
694 W( the data structure in figure 2-2 on page 22, objects A, B, C and D are linked)197 W
9288 63482 MT
(together in the same physical page)
208 W( cluster originally.  But as the figure 3-6 on page 37)209 W
9288 65202 MT
(illustrates, by the time scanning is finished the whole object)
65 W( will be spread out over several)64 W
9288 66922 MT
(physical pages, determined by the number of ``levels'' in the application's data structure.  In)17 W
9288 68642 MT
(the example, there are only three levels, but conceivably a)
1 W( very large and ``long'' linked data)SH
9288 70362 MT
(structure can be in the same page cluster, and scanning it will)
143 W( ``fragment'' the composite)144 W
9288 72082 MT
(object onto many physical pages.)SH
10 SS 
30811 75600 MT
(-40-)SH
ES
%%Page: 41 41
BS
0 SI
12 /Times-Roman AF
12288 10399 MT
(Using the allocation strategy discussed so far, A allocates)
190 W( a forward-space page to)189 W
10 SS 
30558 11738 MT
(6)SH
12 SS 
9288 12119 MT
(copy B and C, into B' and)
100 W( C', respectively)101 W
31058 XM
(, and when B' and C' are scanned, the trailing)101 W
9288 13839 MT
(space on)
197 W( their)196 W
/Courier SF
16844 XM
(forw_space)SH
/Times-Roman SF
24540 XM
(heap page is discarded.  For a program traversing down a)196 W
9288 15559 MT
(linked list in order, this means that)
251 W( when the elements are forwarded one by one after)252 W
9288 17279 MT
(successive page faults,)
135 W( each element will be made to ``occupy'' one whole heap page.  If)134 W
9288 18999 MT
(each element is much less than one heap page in size, the amount of memory)
47 W( fragmentation)48 W
9288 20719 MT
(is significant.)SH
12288 24331 MT
(To avoid fragmentation two)49 W
/Courier SF
26219 XM
(forw_freepage)SH
/Times-Roman SF
('s are maintained.  The idea is to flip-)48 W
9288 26051 MT
(flop between the two ``forward regions'' referred to by the)182 W
/Courier SF
39641 XM
(forw_freepage)SH
/Times-Roman SF
('s, so that)182 W
9288 27771 MT
(instead of ``spreading)
65 W( out'' the composite object onto potentially many physical pages, it is)64 W
9288 29491 MT
(separated into two regions.  In addition,)
45 W( the original rule saying that ``the forwarded objects)46 W
9288 31211 MT
(are always allocated outside of the scan region'' becomes)57 W
/Times-Italic SF
37769 XM
(the forwarded objects are always)57 W
9288 32931 MT
(allocated outside of the scan region, unless the current forward-space free heap page has)126 W
9288 34651 MT
(enough space remaining for the next forward object to be copied there.)88 W
/Times-Roman SF
45235 XM
(Perhaps it is most)87 W
9288 36371 MT
(appropriate to illustrate with an example.)SH
12288 39983 MT
(Figure 3-8 shows a linked list of six objects.  Assume that each object occupies half a)42 W
9288 41703 MT
(heap page,)
59 W( and that they are all residing on different physical pages.  For simplicity assume)58 W
9288 43423 MT
(also that all the physical pages are unoccupied except)
2 W( for the objects shown.  The head of the)3 W
9288 45143 MT
(list A is protected, so eventually the whole list structure will)
225 W( be forwarded into a more)224 W
9288 46863 MT
(compact area.  When a page)
123 W( fault ocurrs on the physical page containing A, A is scanned)124 W
9288 48583 MT
(which causes B to be forwarded.)
19 W( B)
336 W( is subsequently protected, and the application is allowed)18 W
9288 50303 MT
(to continue.)
13 W( Without)
328 W( the augmented rule, by the time B is scanned, the trailing space after B)14 W
9288 52023 MT
(would have been)
146 W( wasted; but with the augmented rule, scanning B causes C to be copied)145 W
9288 53743 MT
(onto the trailing space)
13 W( after B, and C is scanned immediately afterwards.  Scanning C causes)14 W
9288 55463 MT
(D to be forwarded, but this)
16 W( time onto a different physical page.  Then D is protected, and the)15 W
9288 57183 MT
(application continues.  Eventually D is unprotected)
102 W( and scanned, so that E is copied to the)103 W
9288 58903 MT
(trailing space after D. Like before, E is immediately scanned, which causes F to be)353 W
9288 60623 MT
(forwarded. F)
906 W( is then protected and once again the application is allowed to)
303 W( proceed.)304 W
9288 62343 MT
(Finally, when F is unprotected)
248 W( and scanned, there is no more objects to forward.  The)247 W
9288 64063 MT
(ultimate result)
47 W( of the scanning, as shown in the figure, is that the linked structure pointed to)48 W
9288 65783 MT
(by A is compacted onto three heap pages on two physical pages.)
144 W( Because)
587 W( forward-space)143 W
9288 67503 MT
(heap page allocation tries to flip-flop between two physical pages,)
177 W( if the linked structure)178 W
10800 50 9288 69990 UL
8 SS 
10288 71655 MT
(6)SH
10 SS 
10688 72000 MT
(Assumes that B' and C' are small enough to be on the same heap page.)SH
30811 75600 MT
(-41-)SH
ES
%%Page: 42 42
BS
0 SI
12 SS 
1 1 0 2484 79416 GB 
%%BeginDocument: linked_list.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Times-Bold Times-Roman
%%%Pages: 1
%%BoundingBox: 142 195 470 630
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 110 188 ] concat
%I
89 469 115 469 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 171 187 ] concat
%I
89 469 115 469 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 234 188 ] concat
%I
89 469 115 469 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 296 189 ] concat
%I
89 469 115 469 Line
End

Begin %I Line
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 359 189 ] concat
%I
89 469 115 469 Line
End

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 3 50 ] concat

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 106 142 ] concat
%I
53 451 89 478 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 174 612 ] concat
%I
[
(A)
] Text
End

End %I eop

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 3 50 ] concat

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 168 142 ] concat
%I
53 451 89 478 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 235 612 ] concat
%I
[
(B)
] Text
End

End %I eop

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 3 50 ] concat

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 230 142 ] concat
%I
53 451 89 478 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 297 613 ] concat
%I
[
(C)
] Text
End

End %I eop

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 3 50 ] concat

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 293 142 ] concat
%I
53 451 89 478 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 359 613 ] concat
%I
[
(D)
] Text
End

End %I eop

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 3 50 ] concat

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 355 143 ] concat
%I
53 451 89 478 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 422 613 ] concat
%I
[
(E)
] Text
End

End %I eop

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 3 50 ] concat

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 417 143 ] concat
%I
53 451 89 478 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 484 614 ] concat
%I
[
(F)
] Text
End

End %I eop

Begin %I Rect
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1.94333 94 -289.106 ] concat
%I
79 262 181 404 Rect
End

Begin %I MLine
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 99 230 ] concat
%I 4
75 351
75 278
178 278
178 350
4 MLine
End

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 22 -80 ] concat

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 106 142 ] concat
%I
53 451 89 478 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 174 612 ] concat
%I
[
(A)
] Text
End

End %I eop

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.18182 0 0 3 76.3636 -232 ] concat
%I
81 231 168 231 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.13636 0 0 1 83.0341 163 ] concat
%I
81 231 168 231 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.15909 0 0 1 79.2045 197 ] concat
%I
81 231 168 231 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.15909 0 0 1 80.1705 131 ] concat
%I
81 231 168 231 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.13636 0 0 1 83.0341 25 ] concat
%I
81 231 168 231 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.14773 0 0 1 82.1136 62 ] concat
%I
81 231 168 231 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.13636 0 0 1 82.0227 97 ] concat
%I
81 231 168 231 Line
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1.94333 311 -288.106 ] concat
%I
79 262 181 404 Rect
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.18182 0 0 3 293.364 -231 ] concat
%I
81 231 168 231 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.13636 0 0 1 300.034 164 ] concat
%I
81 231 168 231 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.15909 0 0 1 296.205 198 ] concat
%I
81 231 168 231 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.15909 0 0 1 297.17 132 ] concat
%I
81 231 168 231 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.13636 0 0 1 300.034 26 ] concat
%I
81 231 168 231 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.14773 0 0 1 299.114 63 ] concat
%I
81 231 168 231 Line
End

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.13636 0 0 1 299.023 98 ] concat
%I
81 231 168 231 Line
End

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 2 0 ] concat

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 391 15 ] concat
%I
53 451 89 478 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 456 485 ] concat
%I
[
(E')
] Text
End

End %I eop

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 2 1 ] concat

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 345 14 ] concat
%I
53 451 89 478 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 409 484 ] concat
%I
[
(D')
] Text
End

End %I eop

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 2 -1 ] concat

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 174 14 ] concat
%I
53 451 89 478 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 239 484 ] concat
%I
[
(C')
] Text
End

End %I eop

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 1 0 ] concat

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 128 13 ] concat
%I
53 451 89 478 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 193 484 ] concat
%I
[
(B')
] Text
End

End %I eop

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 -1 -1 ] concat

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 129 -19 ] concat
%I
53 451 89 478 Rect
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-bold-r-*-140-*
/Times-Bold 14 SetF
%I t
[ 1 0 0 1 193 451 ] concat
%I
[
(F')
] Text
End

End %I eop

Begin %I Line
%I b 13107
1 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1.15909 0 0 1 81.2045 314 ] concat
%I
81 231 168 231 Line
End

Begin %I Line
%I b 65535
1 1 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 99 159 ] concat
%I
178 216 214 236 Line
End

Begin %I Line
%I b 65535
1 1 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 99 159 ] concat
%I
290 219 253 239 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 302 412 ] concat
%I
[
(Heap pages)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 163 602 ] concat
%I
[
(After scanning, objects B, ..., F are compacted onto two physical pages.)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 163 694 ] concat
%I
[
(Before scanning, all objects are on separate physical pages...)
] Text
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
23309 69068 MT
(Figure 3-8:)SH
/Times-Roman SF
29609 XM
(Scanning a linked list)SH
10 SS 
30811 75600 MT
(-42-)SH
ES
%%Page: 43 43
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(were longer, then the remaining elements)
132 W( would also be compacted on these two physical)131 W
9288 12119 MT
(pages.)SH
/Times-Bold SF
9288 15803 MT
(3.2.5 End GC)SH
/Times-Roman SF
12288 18786 MT
(Garbage collection is finished when all the)
358 W( protected physical pages have been)359 W
9288 20506 MT
(unprotected and scanned.  Each)
99 W( time a current-space heap page allocation is requested, the)98 W
9288 22226 MT
(collector checks whether)552 W
/Courier SF
23177 XM
(protectedpages==0)SH
/Times-Roman SF
(, and if so, garbage)
552 W( collection is)553 W
9288 23946 MT
(terminated. The)
384 W( trailing words left in)42 W
/Courier SF
27920 XM
(forw_freepage)SH
/Times-Roman SF
37622 XM
(are discarded; since there will)
42 W( not)41 W
9288 25666 MT
(be any more forward objects to be copied.  To mark that collection is over,)15 W
/Courier SF
45683 XM
(forw_space)SH
/Times-Roman SF
53199 XM
(is)SH
9288 27386 MT
(set to be equal to)570 W
/Courier SF
20573 XM
(curr_space)SH
/Times-Roman SF
(. To)
1440 W( reclaim storage,)570 W
/Courier SF
41124 XM
(prev_space)SH
/Times-Roman SF
49193 XM
(is set to)569 W
/Courier SF
9288 29106 MT
(curr_space)SH
/Times-Roman SF
(, so that all the heap pages which used to be)
96 W( in previous-space are now free)97 W
9288 30826 MT
(for allocation -- a)
51 W( heap page is allocatable if and only if its space identifier is not stable and)50 W
9288 32546 MT
(is not equal to)821 W
/Courier SF
19641 XM
(prev_space)SH
/Times-Roman SF
27962 XM
(or)SH
/Courier SF
30083 XM
(curr_space)SH
/Times-Roman SF
(. The)
1942 W( bookkeeping variable)821 W
/Courier SF
9288 34266 MT
(allocatedpages)SH
/Times-Roman SF
19748 XM
(is corrected, and depending on)
80 W( how much of the heap is occupied \050by)79 W
9288 35986 MT
(examining the fraction)432 W
/Courier SF
21753 XM
(allocatedpages/heappages)SH
/Times-Roman SF
(\051, a)
432 W( total collection may be)433 W
9288 37706 MT
(started. In)
430 W( that situation, all the stable heap pages are made unstable)
65 W( by assigning them the)64 W
/Courier SF
9288 39426 MT
(curr_space)SH
/Times-Roman SF
16788 XM
(space identifier, and a new garbage collection is initiated.)SH
/Times-Bold SF
9288 43110 MT
(3.2.6 Heap Page State Transitions)SH
/Times-Roman SF
12288 46093 MT
(This section recapitulates the process)
275 W( of incremental, generational mostly-copying)276 W
9288 47813 MT
(collection using state transitions.)
43 W( Figure)
384 W( 3-9 shows a map of all the different possible states)42 W
9288 49533 MT
(for a heap page.  The set of possible states is constructed from the cross product)
90 W( of {space)91 W
10 SS 
44484 50872 MT
(7)SH
12 SS 
9288 51253 MT
(identifier:)SH
/Times-Italic SF
14359 XM
(free)SH
/Times-Roman SF
(,)SH
/Times-Italic SF
16861 XM
(current-space)SH
/Times-Roman SF
(,)SH
/Times-Italic SF
24164 XM
(previous-space)SH
/Times-Roman SF
(,)SH
/Times-Italic SF
32067 XM
(forward-space)SH
/Times-Roman SF
(, or)36 W
/Times-Italic SF
41040 XM
(stable)SH
/Times-Roman SF
(})SH
44984 XM
(, {page protection:)36 W
9288 52973 MT
(protected, or unprotected}, and {collection status: scanned,)
99 W( or not scanned}.  As the figure)98 W
9288 54693 MT
(indicates the cross product generates twenty different combinations, but a number of)
117 W( them)118 W
9288 56413 MT
(do not exist.  For)
14 W( instance, only forward-space and stable heap pages are ever scanned, so by)13 W
9288 58133 MT
(definition, there is not)
205 W( any scanned heap page \050protected or otherwise\051 in either current,)206 W
9288 59853 MT
(previous, or free space.)
217 W( The)
732 W( collector never allows the application to access unscanned)216 W
9288 61573 MT
(stable and forward-space heap pages, so unprotected and)
288 W( unscanned forward-space and)289 W
9288 63293 MT
(stable heap)
23 W( pages are not possible.  Then there are some states that heap pages arrive in only)22 W
10800 50 9288 66675 UL
8 SS 
10288 68340 MT
(7)SH
10 SS 
10688 68685 MT
(The difference between forward-space and stable heap pages is)
18 W( that the former has its space identifier set to)17 W
/Courier SF
9288 69790 MT
(forw_space)SH
/Times-Roman SF
(, while the latter has an)
164 W( even space identifier which is not equal to)165 W
/Courier SF
44227 XM
(forw_space)SH
/Times-Roman SF
(. In)
580 W( this)165 W
9288 70895 MT
(section, stable heap pages and forward-space)
72 W( heap pages are distinct from each other: the entity ``stable heap)71 W
9288 72000 MT
(page'' does not include any ``forward-space heap page'' and vice versa.)SH
30811 75600 MT
(-43-)SH
ES
%%Page: 44 44
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(by coincidence.  Since there is more)
102 W( than one heap page in a physical page, heap pages in)103 W
9288 12119 MT
(current, previous, or free spaces can be found on a)59 W
/Times-Italic SF
34342 XM
(protected)SH
/Times-Roman SF
39234 XM
(physical page if there happens)58 W
9288 13839 MT
(to be unscanned forward-space or stable heap page on the same physical page.)
123 W( When)
547 W( the)124 W
9288 15559 MT
(protected page)
174 W( is unprotected, the collector scans only the forward-space and stable heap)173 W
9288 17279 MT
(pages. The)
568 W( collector does not operate on the other heap pages.  Heap pages arriving in)
134 W( a)135 W
9288 18999 MT
(state by coincidence leaves the state)
244 W( eventually, without active work on the part of the)243 W
9288 20719 MT
(collector.)SH
1 1 0 2844 86805 GB 
%%BeginDocument: page_state_table.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Courier-Bold Times-Roman
%%%Pages: 1
%%BoundingBox: 101 286 489 616
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 0.978142 0 0 1 106.749 9 ] concat
%I
80 446 445 446 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-bold-r-*-120-*
/Courier-Bold 12 SetF
%I t
[ 1 0 0 1 191 425 ] concat
%I
[
(Adjacent \(unscanned\) forward/)
(stable heap pages protected)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 115 634 ] concat
%I
[
(Unprotected,)
(Scanned)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 115 566 ] concat
%I
[
(Unprotected,)
(Unscanned)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 116 501 ] concat
%I
[
(Protected,)
(Scanned)
] Text
End

Begin %I Rect
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 0.978142 0 0 1 107.727 142 ] concat
%I
79 239 444 521 Rect
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 -36 142 ] concat
%I
365 520 365 239 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 34 142 ] concat
%I
365 520 365 239 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 106 144 ] concat
%I
365 520 365 239 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 -107 143 ] concat
%I
365 520 365 239 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 0.980874 0 0 1 105.53 144 ] concat
%I
80 446 445 446 Line
End

Begin %I Line
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 0.972678 0 0 1 109.186 76 ] concat
%I
80 446 445 446 Line
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-courier-bold-r-*-120-*
/Courier-Bold 12 SetF
%I t
[ 1 0 0 1 402 500 ] concat
%I
[
(Adjacent \(unscanned\))
(forward/stable heap)
(pages protected)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 208 680 ] concat
%I
[
(Free)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 274 680 ] concat
%I
[
(Current)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 341 680 ] concat
%I
[
(Previous)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 412 680 ] concat
%I
[
(Forward)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 490 680 ] concat
%I
[
(Stable)
] Text
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 327 291 ] concat
%I
114 217 130 217 Line
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 256 224 ] concat
%I
114 217 130 217 Line
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 397 292 ] concat
%I
114 217 130 217 Line
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 118 224 ] concat
%I
114 217 130 217 Line
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 187 224 ] concat
%I
114 217 130 217 Line
End

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1.05556 401 480.722 ] concat
%I 3
116 158
121 150
130 165
3 MLine
End

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1.05556 331 479.722 ] concat
%I 3
116 158
121 150
130 165
3 MLine
End

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1.05556 402 273.722 ] concat
%I 3
116 158
121 150
130 165
3 MLine
End

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1.05556 328 272.722 ] concat
%I 3
116 158
121 150
130 165
3 MLine
End

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1.05556 258 408.722 ] concat
%I 3
116 158
121 150
130 165
3 MLine
End

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1.05556 189 407.722 ] concat
%I 3
116 158
121 150
130 165
3 MLine
End

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1.05556 118 407.722 ] concat
%I 3
116 158
121 150
130 165
3 MLine
End

Begin %I Line
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 104 137 ] concat
%I
114 217 130 217 Line
End

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 -2 28 ] concat

Begin %I MLine
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1.05556 106 133.722 ] concat
%I 3
116 158
121 150
130 165
3 MLine
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 248 306 ] concat
%I
[
(State exists)
] Text
End

End %I eop

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 244 358 ] concat
%I
[
(State arrived at by coincidence)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 117 430 ] concat
%I
[
(Protected,)
(Unscanned)
] Text
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
23377 63497 MT
(Figure 3-9:)SH
/Times-Roman SF
29677 XM
(Heap page state table)SH
12288 69464 MT
(From figure 3-9 one can see that out of twenty states only seven)
17 W( are reachable.  Figure)18 W
9288 71184 MT
(3-10 describes the)
43 W( relationships among these seven states by inserting directed arcs between)42 W
10 SS 
30811 75600 MT
(-44-)SH
ES
%%Page: 45 45
BS
0 SI
12 SS 
1 1 0 1404 81576 GB 
%%BeginDocument: page_transition.PS
%!PS-Adobe-2.0 EPSF-1.2
%%DocumentFonts: Times-Roman
%%%Pages: 1
%%BoundingBox: 114 -333 502 616
%%EndComments

50 dict begin

/arrowHeight 8 def
/arrowWidth 4 def
/none null def
/numGraphicParameters 17 def
/stringLimit 65535 def

/Begin {
save
numGraphicParameters dict begin
} def

/End {
end
restore
} def

/SetB {
dup type /nulltype eq {
pop
false /brushRightArrow idef
false /brushLeftArrow idef
true /brushNone idef
} {
/brushDashOffset idef
/brushDashArray idef
0 ne /brushRightArrow idef
0 ne /brushLeftArrow idef
/brushWidth idef
false /brushNone idef
} ifelse
} def

/SetCFg {
/fgblue idef
/fggreen idef
/fgred idef
} def

/SetCBg {
/bgblue idef
/bggreen idef
/bgred idef
} def

/SetF {
/printSize idef
/printFont idef
} def

/SetP {
dup type /nulltype eq {
pop true /patternNone idef
} {
/patternGrayLevel idef
patternGrayLevel -1 eq {
/patternString idef
} if
false /patternNone idef
} ifelse
} def

/BSpl {
0 begin
storexyn
newpath
n 1 gt {
0 0 0 0 0 0 1 1 true subspline
n 2 gt {
0 0 0 0 1 1 2 2 false subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
} if
n 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Circ {
newpath
0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
} def

/CBSpl {
0 begin
dup 2 gt {
storexyn
newpath
n 1 sub dup 0 0 1 1 2 2 true subspline
1 1 n 3 sub {
/i exch def
i 1 sub dup i dup i 1 add dup i 2 add dup false subspline
} for
n 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
n 2 sub dup n 1 sub dup 0 0 1 1 false subspline
patternNone not { ifill } if
brushNone not { istroke } if
} {
Poly
} ifelse
end
} dup 0 4 dict put def

/Elli {
0 begin
newpath
4 2 roll
translate
scale
0 0 1 0 360 arc
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 1 dict put def

/Line {
0 begin
2 storexyn
newpath
x 0 get y 0 get moveto
x 1 get y 1 get lineto
brushNone not { istroke } if
0 0 1 1 leftarrow
0 0 1 1 rightarrow
end
} dup 0 4 dict put def

/MLine {
0 begin
storexyn
newpath
n 1 gt {
x 0 get y 0 get moveto
1 1 n 1 sub {
/i exch def
x i get y i get lineto
} for
patternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
brushNone not { istroke } if
0 0 1 1 leftarrow
n 2 sub dup n 1 sub dup rightarrow
} if
end
} dup 0 4 dict put def

/Poly {
3 1 roll
newpath
moveto
-1 add
{ lineto } repeat
closepath
patternNone not { ifill } if
brushNone not { istroke } if
} def

/Rect {
0 begin
/t exch def
/r exch def
/b exch def
/l exch def
newpath
l b moveto
l t lineto
r t lineto
r b lineto
closepath
patternNone not { ifill } if
brushNone not { istroke } if
end
} dup 0 4 dict put def

/Text {
ishow
} def

/idef {
dup where { pop pop pop } { exch def } ifelse
} def

/ifill {
0 begin
gsave
patternGrayLevel -1 ne {
fgred bgred fgred sub patternGrayLevel mul add
fggreen bggreen fggreen sub patternGrayLevel mul add
fgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
eofill
} {
eoclip
originalCTM setmatrix
pathbbox /t exch def /r exch def /b exch def /l exch def
/w r l sub ceiling cvi def
/h t b sub ceiling cvi def
/imageByteWidth w 8 div ceiling cvi def
/imageHeight h def
bgred bggreen bgblue setrgbcolor
eofill
fgred fggreen fgblue setrgbcolor
w 0 gt h 0 gt and {
l b translate w h scale
w h true [w 0 0 h neg 0 h] { patternproc } imagemask
} if
} ifelse
grestore
end
} dup 0 8 dict put def

/istroke {
gsave
brushDashOffset -1 eq {
[] 0 setdash
1 setgray
} {
brushDashArray brushDashOffset setdash
fgred fggreen fgblue setrgbcolor
} ifelse
brushWidth setlinewidth
originalCTM setmatrix
stroke
grestore
} def

/ishow {
0 begin
gsave
fgred fggreen fgblue setrgbcolor
/fontDict printFont findfont printSize scalefont dup setfont def
/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
transform exch pop def
/vertoffset 0 descender sub printSize sub printFont /Courier ne
printFont /Courier-Bold ne and { 1 add } if def {
0 vertoffset moveto show
/vertoffset vertoffset printSize sub def
} forall
grestore
end
} dup 0 3 dict put def

/patternproc {
0 begin
/patternByteLength patternString length def
/patternHeight patternByteLength 8 mul sqrt cvi def
/patternWidth patternHeight def
/patternByteWidth patternWidth 8 idiv def
/imageByteMaxLength imageByteWidth imageHeight mul
stringLimit patternByteWidth sub min def
/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
patternHeight mul patternHeight max def
/imageHeight imageHeight imageMaxHeight sub store
/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
0 1 imageMaxHeight 1 sub {
/y exch def
/patternRow y patternByteWidth mul patternByteLength mod def
/patternRowString patternString patternRow patternByteWidth getinterval def
/imageRow y imageByteWidth mul def
0 patternByteWidth imageByteWidth 1 sub {
/x exch def
imageString imageRow x add patternRowString putinterval
} for
} for
imageString
end
} dup 0 12 dict put def

/min {
dup 3 2 roll dup 4 3 roll lt { exch } if pop
} def

/max {
dup 3 2 roll dup 4 3 roll gt { exch } if pop
} def

/arrowhead {
0 begin
transform originalCTM itransform
/taily exch def
/tailx exch def
transform originalCTM itransform
/tipy exch def
/tipx exch def
/dy tipy taily sub def
/dx tipx tailx sub def
/angle dx 0 ne dy 0 ne or { dy dx atan } { 90 } ifelse def
gsave
originalCTM setmatrix
tipx tipy translate
angle rotate
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
patternNone not {
originalCTM setmatrix
/padtip arrowHeight 2 exp 0.25 arrowWidth 2 exp mul add sqrt brushWidth mul
arrowWidth div def
/padtail brushWidth 2 div def
tipx tipy translate
angle rotate
padtip 0 translate
arrowHeight padtip add padtail add arrowHeight div dup scale
arrowheadpath
ifill
} if
brushNone not {
originalCTM setmatrix
tipx tipy translate
angle rotate
arrowheadpath
istroke
} if
grestore
end
} dup 0 9 dict put def

/arrowheadpath {
newpath
0 0 moveto
arrowHeight neg arrowWidth 2 div lineto
arrowHeight neg arrowWidth 2 div neg lineto
closepath
} def

/leftarrow {
0 begin
y exch get /taily exch def
x exch get /tailx exch def
y exch get /tipy exch def
x exch get /tipx exch def
brushLeftArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/rightarrow {
0 begin
y exch get /tipy exch def
x exch get /tipx exch def
y exch get /taily exch def
x exch get /tailx exch def
brushRightArrow { tipx tipy tailx taily arrowhead } if
end
} dup 0 4 dict put def

/midpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 x1 add 2 div
y0 y1 add 2 div
end
} dup 0 4 dict put def

/thirdpoint {
0 begin
/y1 exch def
/x1 exch def
/y0 exch def
/x0 exch def
x0 2 mul x1 add 3 div
y0 2 mul y1 add 3 div
end
} dup 0 4 dict put def

/subspline {
0 begin
/movetoNeeded exch def
y exch get /y3 exch def
x exch get /x3 exch def
y exch get /y2 exch def
x exch get /x2 exch def
y exch get /y1 exch def
x exch get /x1 exch def
y exch get /y0 exch def
x exch get /x0 exch def
x1 y1 x2 y2 thirdpoint
/p1y exch def
/p1x exch def
x2 y2 x1 y1 thirdpoint
/p2y exch def
/p2x exch def
x1 y1 x0 y0 thirdpoint
p1x p1y midpoint
/p0y exch def
/p0x exch def
x2 y2 x3 y3 thirdpoint
p2x p2y midpoint
/p3y exch def
/p3x exch def
movetoNeeded { p0x p0y moveto } if
p1x p1y p2x p2y p3x p3y curveto
end
} dup 0 17 dict put def

/storexyn {
/n exch def
/y n array def
/x n array def
n 1 sub -1 0 {
/i exch def
y i 3 2 roll put
x i 3 2 roll put
} for
} def

%%EndProlog

%I Idraw 7 Grid 8 

%%%Page: 1 1

Begin
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 0.9 0 0 0.9 0 0 ] concat
/originalCTM matrix currentmatrix def

Begin %I Elli
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 44 86 ] concat
%I
206 442 48 34 Elli
End

Begin %I Elli
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 154 -41 ] concat
%I
206 442 48 34 Elli
End

Begin %I Elli
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 113 206 ] concat
%I
206 442 48 34 Elli
End

Begin %I Elli
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 -22 -26 ] concat
%I
206 442 48 34 Elli
End

Begin %I Elli
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 216 114 ] concat
%I
206 442 48 34 Elli
End

Begin %I Elli
%I b 65535
2 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 47 -140 ] concat
%I
206 442 48 34 Elli
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 307 672 ] concat
%I
[
(Free)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 286 651 ] concat
%I
[
(Unprotected,)
(Unscanned)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 402 578 ] concat
%I
[
(Current)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 392 560 ] concat
%I
[
(Unprotected,)
(Unscanned)
] Text
End

Begin %I Pict
%I b 65535
2 0 0 [] 0 SetB
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 -11 -23 ] concat

Begin %I Elli
%I b 65535
1 0 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 293 12 ] concat
%I
206 442 48 34 Elli
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 476 477 ] concat
%I
[
(Previous)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 468 457 ] concat
%I
[
(Unprotected,)
(Unscanned)
] Text
End

End %I eop

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 233 550 ] concat
%I
[
(Stable)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 218 531 ] concat
%I
[
(Unprotected,)
(Scanned)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 167 440 ] concat
%I
[
(Stable)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 155 418 ] concat
%I
[
(Protected,)
(Unscanned)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 336 423 ] concat
%I
[
(Forward)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 330 404 ] concat
%I
[
(Protected,)
(Unscanned)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 231 325 ] concat
%I
[
(Forward)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 221 303 ] concat
%I
[
(Unprotected,)
(Scanned)
] Text
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 3
254 487
287 476
299 447
3 BSpl
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 0.973333 106 -651.44 ] concat
%I 3
303 381
279 346
266 292
3 BSpl
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
%I p
0 SetP
%I t
[ 0.943463 0 0 1 120.259 142 ] concat
%I 4
250 225
240 200
213 186
184 181
4 BSpl
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 0.984876 106 144.901 ] concat
%I 4
145 194
168 235
180 294
163 355
4 BSpl
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
%I p
0 SetP
%I t
[ 0.969466 0 0 0.955947 110.094 157.692 ] concat
%I 3
132 354
128 325
104 302
3 BSpl
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 3
54 304
56 352
99 371
3 BSpl
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg Black
0 0 0 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 4
150 420
174 449
220 451
276 433
4 BSpl
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 216 486 ] concat
%I
[
(Start)
( GC)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 286 586 ] concat
%I
[
(Total GC)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 403 669 ] concat
%I
[
(End GC)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 296 354 ] concat
%I
[
(Scanning)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 130 507 ] concat
%I
[
(Scanning)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 387 637 ] concat
%I
[
(Application)
( Allocation)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 280 469 ] concat
%I
[
(End)
( GC)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 333 307 ] concat
%I
[
(Forwarding)
] Text
End

Begin %I BSpl
%I b 65535
1 1 0 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 2
195 150
199 149
2 BSpl
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 418 382 ] concat
%I
[
(Promote)
(  Page)
] Text
End

Begin %I Pict
%I b u
%I cfg u
%I cbg u
%I f u
%I p u
%I t
[ 1 0 0 1 -18 24 ] concat

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 409 475 ] concat
%I
[
(prev_space = curr_space;)
(curr_space += 2;)
] Text
End

Begin %I Text
%I cfg Black
0 0 0 SetCFg
%I f *-times-medium-r-*-120-*
/Times-Roman 12 SetF
%I t
[ 1 0 0 1 410 488 ] concat
%I
[
(Start GC)
] Text
End

End %I eop

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 7
422 309
446 339
449 393
430 449
386 497
311 517
261 515
7 BSpl
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 4
357 259
344 247
316 240
299 245
4 BSpl
End

Begin %I BSpl
%I b 65535
1 0 1 [] 0 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
%I p
0 SetP
%I t
[ 1 0 0 1 106 142 ] concat
%I 4
352 389
369 373
378 349
378 323
4 BSpl
End

Begin %I BSpl
%I b 13107
2 0 0 [2 2 2 2 2 2 2 2] 15 SetB
%I cfg Black
0 0 0 SetCFg
%I cbg White
1 1 1 SetCBg
none SetP %I p n
%I t
[ 1 0 0 1 106 142 ] concat
%I 5
382 253
373 205
336 172
273 147
204 148
5 BSpl
End

End %I eop

showpage

%%Trailer

end

%%EndDocument
 GE /Times-Bold SF
19626 69068 MT
(Figure 3-10:)SH
/Times-Roman SF
26526 XM
(Heap page state transitions diagram)SH
10 SS 
30811 75600 MT
(-45-)SH
ES
%%Page: 46 46
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(states and annotating how one state transitions to the next.  Starting at the top of the figure,)
13 W( a)14 W
9288 12119 MT
(free heap page is first allocated by the application)
44 W( program in current-space.  When garbage)43 W
9288 13839 MT
(collection is initiated, two possibilities can occur: either the heap page contains)
439 W( an)440 W
9288 15559 MT
(ambiguous root)
76 W( object and is therefore promoted into forward-space, or the heap page does)75 W
9288 17279 MT
(not contain any root object and is therefore demoted into previous-space.)
189 W( If)
680 W( the page is)190 W
9288 18999 MT
(promoted it will have to be protected, but if it is demoted then no protection)
119 W( is necessary.)118 W
9288 20719 MT
(Sometime during the collection some objects in a demoted page maybe copied into)
72 W( another)73 W
9288 22439 MT
(forward-space heap page, if)
116 W( they are found to be accessible from the root objects.  This is)115 W
9288 24159 MT
(shown with a dotted arc because the previous-space heap page does not actually change)201 W
9288 25879 MT
(state, only some objects inside it are forwarded.  Another possibility is that)
98 W( if the collector)97 W
9288 27599 MT
(discovers an object it needs to forward is larger than or equal to one heap page in size,)
9 W( it will)10 W
9288 29319 MT
(just promote and protect the demoted page)
226 W( containing the big object into forward-space)225 W
9288 31039 MT
(instead. At)
576 W( the end of collection, the previous-space page is reclaimed when)
138 W( it returns to)139 W
9288 32759 MT
(free-space. A)
654 W( promoted page in)
177 W( forward-space may take a longer time to return to free-)176 W
9288 34479 MT
(space. The)
444 W( protected forward-space page is eventually unprotected and scanned, and at the)73 W
9288 36199 MT
(end of the collection it becomes a stable heap page.  The stable)
36 W( heap page is retained, and is)35 W
9288 37919 MT
(protected and scanned at each subsequent collection.)
200 W( This)
702 W( goes on until too many heap)201 W
9288 39639 MT
(pages are retained)
95 W( in the heap, at which point the collector decides to do a total collection,)94 W
9288 41359 MT
(and the stable heap page are sent into current-space and collected.)SH
10 SS 
30811 75600 MT
(-46-)SH
ES
%%Page: 47 47
BS
0 SI
14 /Times-Bold AF
28630 11947 MT
(Chapter 4)SH
25208 14560 MT
(Experimental Results)SH
12 /Times-Roman AF
12288 18983 MT
(An incremental, generational)
650 W( mostly-copying collector has been built which)651 W
9288 20703 MT
(accomplishes the following objectives:)SH
11688 23818 MT
(1.)SH
/Times-Italic SF
12888 XM
(Hardware and compiler independence)497 W
/Times-Roman SF
33675 XM
(-- The mostly-copying collection)496 W
12888 25104 MT
(algorithm does not require any specialized hardware)
197 W( or compiler support to)198 W
12888 26390 MT
(identify root objects.  The result is a highly portable garbage collector)
39 W( that can)38 W
12888 27676 MT
(be adapted to uncooperative environments.)SH
11688 29705 MT
(2.)SH
/Times-Italic SF
12888 XM
(Real-time performance)196 W
/Times-Roman SF
24680 XM
(-- The incremental)
196 W( collection strategy distributes the)197 W
12888 30991 MT
(task of scanning objects over time and reduces the length)
326 W( of GC pauses)325 W
12888 32277 MT
(typically suffered by)
700 W( non-incremental collectors drastically.  On the)701 W
12888 33563 MT
(DECStation 3100, the maximum GC pause of the incremental collector)
34 W( is well)33 W
12888 34849 MT
(within the 100-millisecond)
59 W( limit imposed by most real-time applications.  The)60 W
12888 36135 MT
(average GC pause is merely 4 milliseconds long.)SH
11688 38164 MT
(3.)SH
/Times-Italic SF
12888 XM
(Satisfactory total execution)
601 W( time)600 W
/Times-Roman SF
31095 XM
(-- With generational collection, total)600 W
12888 39450 MT
(execution time is reduced because repeated copying of long-living stable)349 W
12888 40736 MT
(objects can be avoided.  Generational collection is important for the)554 W
12888 42022 MT
(incremental collector because incremental)
105 W( collection inherently requires more)106 W
12888 43308 MT
(heap space, while)
361 W( generational collection lessens the contention for heap)360 W
12888 44594 MT
(space.)SH
12288 48206 MT
(Elaboration of these results can be found in the following sections.)
50 W( Section)
402 W( 4.1 states)51 W
9288 49926 MT
(the success and limitation of the first objective.  Section)
298 W( 4.2 describes the benchmark)297 W
9288 51646 MT
(programs used and)
321 W( presents the benchmark measurements.  Sections 4.3 discusses the)322 W
9288 53366 MT
(accomplishment of the second objective, and section 4.4, the third objective.)SH
/Times-Bold SF
9288 57770 MT
(4.1 Hardware and Compiler Independence)SH
/Times-Roman SF
12288 61473 MT
(The incremental collector)
128 W( uses standard virtual memory support for page protection.)127 W
9288 63193 MT
(It does not require any specialized hardware support.  Because of this, the collector is very)85 W
9288 64913 MT
(portable across)
107 W( different hardware platforms.  Any system with support for user controlled)106 W
9288 66633 MT
(page protection is able)
252 W( to use the collector.  The collector currently runs under Digital)253 W
9288 68353 MT
(Equipment Corporation's U)57 W
10 SS 
(LTRIX)SH
12 SS 
(, and is using the)
57 W( operating system's facility,)56 W
/Courier SF
47940 XM
(mprotect)SH
/Times-Roman SF
(,)SH
9288 70073 MT
(to control page protection of the heap.  The function)125 W
/Courier SF
35907 XM
(mprotect)SH
/Times-Roman SF
42093 XM
(is also found in SunOS;)126 W
9288 71793 MT
(and many other versions of U)93 W
10 SS 
(NIX)SH
12 SS 
26156 XM
(provide similar utilities to perform page protection.  The)92 W
10 SS 
30811 75600 MT
(-47-)SH
ES
%%Page: 48 48
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(collector was developed on the DECStation)
100 W( 3100 platform \050MIPS\051, and has been ported to)101 W
9288 12119 MT
(the VAX architecture.)SH
12288 15731 MT
(The collector also)
231 W( has the advantage of being able to be used with different C++)230 W
9288 17451 MT
(compilers. The)
1312 W( implementation of the incremental collector)
506 W( does not involve any)507 W
9288 19171 MT
(modification to the compiler.  This way,)
54 W( the programmer is not tied to a particular compiler)53 W
9288 20891 MT
(because of its garbage collection feature; rather, the programmer is free to choose a)
10 W( compiler)11 W
9288 22611 MT
(that is most suitable to)
25 W( the application.  The current implementation \050listed in appendix B\051 is)24 W
9288 24331 MT
(compatible with AT&T C++ Language)
103 W( Releases 1.2 and 2.0.  It runs with both the AT&T)104 W
9288 26051 MT
(C++ Translator for version 1.2 and the Glockenspiel C++ compiler for version 2.0.)SH
12288 29663 MT
(However, it should be)
40 W( noted that some optimizing compilers which do not necessarily)39 W
9288 31383 MT
(maintain all accessible)
92 W( pointers \050i.e. roots\051 in the program state may destroy the validity of)93 W
9288 33103 MT
(the root-finding heuristic used by the mostly-copying collection algorithm.)
170 W( For)
638 W( example,)169 W
9288 34823 MT
(instead of having two root pointers referencing two different heap)
178 W( objects, an optimizing)179 W
9288 36543 MT
(compiler may find it more convenient to keep track)
38 W( of just one pointer to one of the objects,)37 W
9288 38263 MT
(and an)257 W
/Times-Italic SF
13268 XM
(integer)SH
/Times-Roman SF
17226 XM
(offset from that pointer to locate)
257 W( the other object.  The mostly-copying)258 W
9288 39983 MT
(collector would then fail to retain the second object because there does not)
36 W( exist a pointer to)35 W
9288 41703 MT
(it in the registers and stack.)SH
/Times-Bold SF
9288 46107 MT
(4.2 Benchmark Measurements)SH
/Times-Roman SF
12288 49810 MT
(The two benchmark programs)
182 W( chosen to assess the performance of the incremental)183 W
9288 51530 MT
(collector were written at Digital Equipment Corporation's Western Research Laboratory,)212 W
9288 53250 MT
(and used)
63 W( Bartlett's generational, mostly-copying collector.  Since the syntax, semantics and)64 W
9288 54970 MT
(pointer-finding methods of the new collector remain the same)
449 W( as Bartlett's original)448 W
9288 56690 MT
(implementation, it was easy to use the programs with the new collector.)SH
12288 60302 MT
(The first program,)109 W
/Courier SF
21683 XM
(words)SH
/Times-Roman SF
(, courtesy of Joel Bartlett, reads in a text file)
109 W( and builds a)110 W
9288 62022 MT
(binary tree of storage records with information about)
47 W( each word in the file.  The records are)46 W
9288 63742 MT
(arranged according to the lexicographical)
100 W( order of the words.  \050The program listing can be)101 W
9288 65462 MT
(found in appendix A.\051  The program's behavior in constructing, traversing)
52 W( and mutating the)51 W
9288 67182 MT
(data structure puts heavy demand)
200 W( on efficient allocation and effective memory recycling)201 W
9288 68902 MT
(mechanisms, which represents the class of applications that usually finds)
52 W( garbage collection)51 W
9288 70622 MT
(useful.)SH
10 SS 
30811 75600 MT
(-48-)SH
ES
%%Page: 49 49
BS
0 SI
12 /Times-Roman AF
12288 10399 MT
(The second program,)159 W
/Courier SF
23231 XM
(bipsctrl)SH
/Times-Roman SF
(, courtesy of Jeremy Dion and Louis Monier, is a)160 W
9288 12119 MT
(part of the CAD system created at WRL for the)
1 W( design of a bipolar integrated processor chip.)SH
9288 13839 MT
(Unlike)SH
/Courier SF
13246 XM
(words)SH
/Times-Roman SF
(, which manipulates only one data type that constitutes)
391 W( the individual)392 W
9288 15559 MT
(elements of the binary tree;)240 W
/Courier SF
23923 XM
(bipsctrl)SH
/Times-Roman SF
30222 XM
(instantiates part of the chip design by creating)239 W
9288 17279 MT
(instances of many data types to describe the various logical and)
43 W( electrical components.  The)44 W
9288 18999 MT
(program then automatically lays out and wires these components.)SH
12288 22611 MT
(The programs were executed on a DECStation)
335 W( 3100 to generate the benchmark)334 W
9288 24331 MT
(measurements shown)
290 W( in table 4-I.  The left half of the table shows the measurements)291 W
9288 26051 MT
(obtained for)
33 W( the)32 W
/Courier SF
17286 XM
(words)SH
/Times-Roman SF
21218 XM
(program, while the right half is for)32 W
/Courier SF
38379 XM
(bipsctrl)SH
/Times-Roman SF
(. For)
364 W( each program,)32 W
9288 27771 MT
(four versions of the collector are)
369 W( used: \050from left to right\051 they are non-incremental)370 W
9288 29491 MT
(generational, incremental generational, non-incremental non-generational, and)
179 W( incremental)178 W
9288 31211 MT
(non-generational. For)
886 W( each version of the collector, each program was run five times)293 W
9288 32931 MT
(consecutively, and the measurements for the best run \050chosen to be the)
34 W( one with the shortest)33 W
9288 34651 MT
(total execution time\051 were used.  The time)
428 W( measurements were obtained by adding)429 W
/Courier SF
9288 36371 MT
(getrusage)SH
/Times-Roman SF
16187 XM
(calls to the collector.  It was verified that)119 W
/Courier SF
37195 XM
(getrusage)SH
/Times-Roman SF
44093 XM
(did not significantly)118 W
9288 38091 MT
(change the running times of the programs.)SH
12288 41703 MT
(Reading the)
180 W( table from top to bottom,)181 W
/Courier SF
31959 XM
(Total time)181 W
/Times-Roman SF
39821 XM
(measures the total execution)181 W
9288 43423 MT
(time of the program in seconds.)125 W
/Courier SF
25966 XM
(Initial Heap)125 W
/Times-Roman SF
35156 XM
(is the size of the heap \050in Megabytes\051)125 W
9288 45143 MT
(when it is first configured, and)209 W
/Courier SF
25578 XM
(Final Heap)210 W
/Times-Roman SF
33498 XM
(is the size of the heap at the end of the)210 W
9288 46863 MT
(program's execution.)90 W
/Courier SF
20359 XM
(Time in GC)90 W
/Times-Roman SF
28128 XM
(measures the cumulative time \050measured in seconds\051)89 W
9288 48583 MT
(the program spends inside the collector module.)113 W
/Courier SF
33830 XM
(Time in AP)114 W
/Times-Roman SF
41672 XM
(is the cumulative time in)114 W
9288 50303 MT
(the application program itself, and is obtained by subtracting)116 W
/Courier SF
39806 XM
(Time in GC)115 W
/Times-Roman SF
47651 XM
(from)SH
/Courier SF
50400 XM
(Total)SH
9288 52023 MT
(time)SH
/Times-Roman SF
(. The)
700 W( reading of)200 W
/Courier SF
21434 XM
(%time in GC)200 W
/Times-Roman SF
30254 XM
(is the percentage of the total time the program)201 W
9288 53743 MT
(spends in GC mode, and)130 W
/Courier SF
22005 XM
(%time GC)
130 W( overlaps AP)129 W
/Times-Roman SF
37222 XM
(is the percentage of the total time)129 W
9288 55463 MT
(span when GC is technically ``going on'')
242 W( \050i.e. when)243 W
/Courier SF
36703 XM
(curr_space)SH
/Times-Roman SF
44446 XM
(!=)SH
/Courier SF
46066 XM
(forw_space)SH
/Times-Roman SF
(\051;)SH
9288 57183 MT
(while)SH
/Courier SF
12460 XM
(%AP during GC)205 W
/Times-Roman SF
22735 XM
(is the percentage of the GC time span \050i.e. the total time GC)205 W
9288 58903 MT
(overlaps AP\051 during which application is executing.  The)
417 W( number of times garbage)418 W
9288 60623 MT
(collection is initiated is listed at)131 W
/Courier SF
25615 XM
(#collections)SH
/Times-Roman SF
(; and the percentage of all the allocated)130 W
9288 62343 MT
(heap pages that are)
95 W( reclaimed is shown in)96 W
/Courier SF
30321 XM
(%collected)SH
/Times-Roman SF
(. Following)492 W
/Courier SF
43944 XM
(%collected)SH
/Times-Roman SF
(,)SH
/Courier SF
51840 XM
(Max)SH
9288 64063 MT
(Pause)SH
/Times-Roman SF
13308 XM
(indicates the maximum GC pause recorded during the run.)
120 W( The)
538 W( next three entries)119 W
10 SS 
48592 65402 MT
(8)SH
12 SS 
9288 65783 MT
(show the median, mean and standard deviation)
159 W( of all the non-zero GC pauses.)158 W
50008 XM
(The last)158 W
10800 50 9288 68885 UL
8 SS 
10288 70550 MT
(8)SH
10 SS 
10688 70895 MT
(Because of the resolution of)201 W
/Courier SF
23164 XM
(getrusage)SH
/Times-Roman SF
(, a large number of the pauses are recorded as having zero)202 W
9288 72000 MT
(millisecond duration.)SH
30811 75600 MT
(-49-)SH
ES
%%Page: 50 50
BS
0 SI
12 /Times-Bold AF
16025 10399 MT
(Table 4-I:)SH
/Times-Roman SF
21726 XM
(Comparative Measurements of Benchmark Programs)SH
9 /Courier-Bold AF
26568 14399 MT
(words<mantext bipsctrl)9720 W
22248 17313 MT
(GENERATIONAL NO)
540 W( GENERATION)
SH( GENERATIONAL NO)
1080 W( GENERATION)SH
22248 20227 MT
(NOINC INC  NOINC INC)
540 W( NOINC)
2700 W( INC  NOINC INC)540 W
9288 23141 MT
(Total time \050sec\051)
SH( 14.65)
3780 W( 18.18 15.41 23.86  4.29)
540 W( 4.61 4.14 4.78)1080 W
9288 26055 MT
(Initial Heap \050MB\051)
SH( 1)
3240 W( 1 1 1)
2700 W( 1)
3780 W( 1 1 1)2700 W
9288 28969 MT
(Final Heap \050MB\051)
SH( 1)
4320 W( 2 1 1)
2700 W( 2)
3780 W( 2 2 2)2700 W
9288 31883 MT
(Time in GC \050sec\051)
SH( 1.26)
3780 W( 3.58 2.04 9.02)
1080 W( 1.02)
2160 W( 0.86 0.85 1.01)1080 W
9288 34797 MT
(Time in AP \050sec\051)
SH( 13.39)
3780 W( 14.6)
540 W( 13.37)
1080 W( 14.84  3.27)
540 W( 3.75 3.29 3.77)1080 W
9288 37711 MT
(% time in GC)
SH( 8.64)
5940 W( 19.68)
1080 W( 13.26 37.83  23.74 18.57 20.59 21.08)540 W
9288 40625 MT
(% time GC overlaps AP)
SH( -  29.21)
1080 W( -)
540 W( 44.99)
2700 W( -)
1620 W( 25.60)
2700 W( -)
540 W( 28.77)2700 W
9288 43539 MT
(% AP during GC)
SH( -)
4860 W( 32.84)
2700 W( -)
540 W( 16.10)
2700 W( -)
1620 W( 28.47)
2700 W( -)
540 W( 27.91)2700 W
9288 46453 MT
(# collections)
SH( 18)
5400 W( 27 17 36)
2160 W( 3)
3240 W( 3 3 3)2700 W
9288 49367 MT
(% collected)
SH( 96.14)
6480 W( 96.04 57.25 7.01)
540 W( 36.63)
2160 W( 79.4)
540 W( 61.56)
1080 W( 58.14)540 W
9288 52281 MT
(Max Pause \050msec\051)
SH( 86)
3780 W( 59 176)
2160 W( 20)
1620 W( 605)
3240 W( 86)
1620 W( 352)
2160 W( 43)1620 W
9288 55195 MT
(Median Pause \050msec\051)
SH( 70 4)
2160 W( 121)
2700 W( 4  207 4)
1620 W( 262)
2700 W( 4)1620 W
9288 56652 MT
(\050of non-zero pauses\051)SH
9288 59566 MT
(Mean Pause \050msec\051)
SH( 66.58)
3240 W( 4.50)
540 W( 113.5)
1080 W( 4.85)
540 W( 254.75)
2160 W( 6.03)
SH( 213.25)
1080 W( 6.59)SH
9288 61023 MT
(\050of non-zero pauses\051)SH
9288 63937 MT
(Std. Dev. of Pause)
SH( 18.80)
2700 W( 2.85)
540 W( 41.38)
1080 W( 1.87)
540 W( 250.96)
2160 W( 8.13)
SH( 142.16)
1080 W( 5.76)SH
9288 65394 MT
(\050of non-zero pauses\051)SH
9288 68308 MT
(Mean Pause \050msec\051)
SH( 66.58)
3240 W( 1.58)
540 W( 113.5)
1080 W( 2.74)
540 W( 254.75)
2160 W( 3.29)
SH( 213.25)
1080 W( 4.22)SH
9288 69765 MT
(.\050of ALL pauses\051)SH
10 /Times-Roman AF
30811 75600 MT
(-50-)SH
ES
%%Page: 51 51
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(entry shows the average GC pause of all the pauses, accounting for both)
74 W( non-zero and zero)75 W
9288 12119 MT
(pauses.)SH
12288 15731 MT
(The next two sections describe the real-time and)
51 W( generational aspects of the collector,)50 W
9288 17451 MT
(respectively, and interpret some of the results in table 4-I.)SH
/Times-Bold SF
9288 21855 MT
(4.3 Real-Time Performance)SH
/Times-Roman SF
12288 25558 MT
(The major benefit of incremental collection is real-time performance.)
307 W( Real-time)915 W
9288 27278 MT
(applications cannot tolerate the long and potentially unbounded GC pauses)
20 W( imposed by most)19 W
9288 28998 MT
(non-incremental collectors.  Figure 4-1 shows the time)
120 W( profile of the)121 W
/Courier SF
43752 XM
(bipsctrl)SH
/Times-Roman SF
49933 XM
(program)SH
9288 30718 MT
(running with the non-incremental,)
178 W( generational mostly-copying collector.  The dark areas)177 W
9288 32438 MT
(indicate that program control is inside the application itself, and)
151 W( the lighter areas indicate)152 W
9288 34158 MT
(that control is inside the garbage collector.  The duration of each of the lighter areas is on the)4 W
9288 35878 MT
(order of hundreds of milliseconds.)
7 W( This)
315 W( is unacceptable for real-time performance.  Appel et)8 W
9288 37598 MT
(al. indicate that for a garbage collector to be real-time, the GC pauses must be less than a)118 W
9288 39318 MT
(very small constant time.  And)
102 W( for interactive applications, this maximum pause should be)103 W
9288 41038 MT
(less 100 milliseconds [Appel et al. 88].)SH
9 10 0 7493 99583 GB 
%%BeginDocument: before.PS
%!PS-Adobe-
%%DocumentFonts: (atend)
%%Creator: ezd - easy drawing for X11 displays. *EZD-VERSION* 06nov90jfb
%%EndComments
% [Rotate] and Translate right 3/8 inch and up 1-3/8 inch
0 0 translate % INCLUDE-DELETE
% Scale to reflect ?? dpi screen vs. 72 points/inch printer and save
.9225398936170213 .9225398936170213 scale 1 setlinewidth 0 650 translate 1 -1 scale /xwindowmatrix matrix currentmatrix def
%%EndProlog
%%%Page: 0 1
/windowborderpath { newpath 600 650 moveto -600 0 rlineto 0 -650 rlineto 600 0 rlineto closepath } def
windowborderpath clip
% Scale to reflect user distance and origin
xwindowmatrix setmatrix 0 0 translate 1 1 scale
/viewmatrix matrix currentmatrix def
% .9882352941176471 .9882352941176471 .9882352941176471 setrgbcolor
% newpath 0 0 moveto 600 0 rlineto 0 650 rlineto -600 0 rlineto closepath fill
0 setgray
newpath 50 10 moveto 250 10 lineto
gsave xwindowmatrix setmatrix 2 setlinewidth stroke grestore
newpath 50 8 moveto 50 12 lineto
gsave xwindowmatrix setmatrix 2 setlinewidth stroke grestore
xwindowmatrix setmatrix /FONT-fixed /Helvetica findfont [ 13.00756756756757 0 0 -13.00756756756757 0 0 ] makefont def viewmatrix setmatrix
FONT-fixed setfont
xwindowmatrix setmatrix 47 22 moveto (0) show viewmatrix setmatrix
newpath 100 8 moveto 100 12 lineto
gsave xwindowmatrix setmatrix 2 setlinewidth stroke grestore
xwindowmatrix setmatrix 92 22 moveto (50ms) show viewmatrix setmatrix
newpath 150 8 moveto 150 12 lineto
gsave xwindowmatrix setmatrix 2 setlinewidth stroke grestore
xwindowmatrix setmatrix 139 22 moveto (100ms) show viewmatrix setmatrix
newpath 250 8 moveto 250 12 lineto
gsave xwindowmatrix setmatrix 2 setlinewidth stroke grestore
xwindowmatrix setmatrix 239 22 moveto (200ms) show viewmatrix setmatrix
0 0 1 setrgbcolor
newpath 50 40 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 51 40 moveto 12 0 rlineto 0 5 rlineto -12 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 63 40 moveto 487 0 rlineto 0 5 rlineto -487 0 rlineto closepath fill
newpath 50 50 moveto 500 0 rlineto 0 5 rlineto -500 0 rlineto closepath fill
newpath 50 60 moveto 500 0 rlineto 0 5 rlineto -500 0 rlineto closepath fill
newpath 50 70 moveto 107 0 rlineto 0 5 rlineto -107 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 157 70 moveto 211 0 rlineto 0 5 rlineto -211 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 368 70 moveto 182 0 rlineto 0 5 rlineto -182 0 rlineto closepath fill
newpath 50 80 moveto 500 0 rlineto 0 5 rlineto -500 0 rlineto closepath fill
newpath 50 90 moveto 205 0 rlineto 0 5 rlineto -205 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 255 90 moveto 199 0 rlineto 0 5 rlineto -199 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 454 90 moveto 96 0 rlineto 0 5 rlineto -96 0 rlineto closepath fill
newpath 50 100 moveto 500 0 rlineto 0 5 rlineto -500 0 rlineto closepath fill
newpath 50 110 moveto 37 0 rlineto 0 5 rlineto -37 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 87 110 moveto 463 0 rlineto 0 5 rlineto -463 0 rlineto closepath fill
newpath 50 120 moveto 139 0 rlineto 0 5 rlineto -139 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 189 120 moveto 168 0 rlineto 0 5 rlineto -168 0 rlineto closepath fill
showpage % INCLUDE-DELETE
%%Trailer
%%DocumentFonts: Helvetica

%%EndDocument
 GE /Times-Bold SF
11344 60657 MT
(Figure 4-1:)SH
/Times-Roman SF
17644 XM
(Time profile of)SH
/Courier SF
25279 XM
(bipsctrl)SH
/Times-Roman SF
31339 XM
(running with the non-incremental collector)SH
12288 66624 MT
(With the incremental collector, GC is divided into smaller chunks of)
370 W( work, as)369 W
9288 68344 MT
(illustrated in figure 4-2.  Instead of having)
33 W( pauses of hundreds of milliseconds each time the)34 W
9288 70064 MT
(program enters garbage collection mode, GC now pauses much more frequently, but the)198 W
9288 71784 MT
(length of each pause is significantly reduced.  Most are less than)
120 W( 10 milliseconds, and the)121 W
10 SS 
30811 75600 MT
(-51-)SH
ES
%%Page: 52 52
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(maximum pause is still well within 100 milliseconds.  Comparing figures 4-1 and)
93 W( 4-2, one)92 W
9288 12119 MT
(can also notice that the total execution time for the incremental)
83 W( collector is longer.  This is)84 W
9288 13839 MT
(due to the overhead for having real-time collection.)SH
9 10 0 7493 72951 GB 
%%BeginDocument: after.PS
%!PS-Adobe-
%%DocumentFonts: (atend)
%%Creator: ezd - easy drawing for X11 displays. *EZD-VERSION* 06nov90jfb
%%EndComments
% [Rotate] and Translate right 3/8 inch and up 1-3/8 inch
0 0 translate % INCLUDE-DELETE
% Scale to reflect ?? dpi screen vs. 72 points/inch printer and save
.9225398936170213 .9225398936170213 scale 1 setlinewidth 0 650 translate 1 -1 scale /xwindowmatrix matrix currentmatrix def
%%EndProlog
%%%Page: 0 1
/windowborderpath { newpath 600 650 moveto -600 0 rlineto 0 -650 rlineto 600 0 rlineto closepath } def
windowborderpath clip
% Scale to reflect user distance and origin
xwindowmatrix setmatrix 0 0 translate 1 1 scale
/viewmatrix matrix currentmatrix def
% .9882352941176471 .9882352941176471 .9882352941176471 setrgbcolor
% newpath 0 0 moveto 600 0 rlineto 0 650 rlineto -600 0 rlineto closepath fill
0 setgray
newpath 50 10 moveto 250 10 lineto
gsave xwindowmatrix setmatrix 2 setlinewidth stroke grestore
newpath 50 8 moveto 50 12 lineto
gsave xwindowmatrix setmatrix 2 setlinewidth stroke grestore
xwindowmatrix setmatrix /FONT-fixed /Helvetica findfont [ 13.00756756756757 0 0 -13.00756756756757 0 0 ] makefont def viewmatrix setmatrix
FONT-fixed setfont
xwindowmatrix setmatrix 47 22 moveto (0) show viewmatrix setmatrix
newpath 100 8 moveto 100 12 lineto
gsave xwindowmatrix setmatrix 2 setlinewidth stroke grestore
xwindowmatrix setmatrix 92 22 moveto (50ms) show viewmatrix setmatrix
newpath 150 8 moveto 150 12 lineto
gsave xwindowmatrix setmatrix 2 setlinewidth stroke grestore
xwindowmatrix setmatrix 139 22 moveto (100ms) show viewmatrix setmatrix
newpath 250 8 moveto 250 12 lineto
gsave xwindowmatrix setmatrix 2 setlinewidth stroke grestore
xwindowmatrix setmatrix 239 22 moveto (200ms) show viewmatrix setmatrix
0 0 1 setrgbcolor
newpath 50 40 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 54 40 moveto 12 0 rlineto 0 5 rlineto -12 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 66 40 moveto 484 0 rlineto 0 5 rlineto -484 0 rlineto closepath fill
newpath 50 50 moveto 282 0 rlineto 0 5 rlineto -282 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 332 50 moveto 35 0 rlineto 0 5 rlineto -35 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 367 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 371 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 372 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 373 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 377 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 378 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 379 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 383 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 384 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 388 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 389 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 393 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 394 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 395 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 399 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 400 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 404 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 405 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 409 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 410 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 411 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 412 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 416 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 417 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 421 50 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 429 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 430 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 431 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 435 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 436 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 437 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 441 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 442 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 443 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 447 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 448 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 452 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 453 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 454 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 458 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 459 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 460 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 464 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 465 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 469 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 470 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 471 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 475 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 476 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 477 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 481 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 482 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 483 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 487 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 488 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 489 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 493 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 497 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 498 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 499 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 503 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 504 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 505 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 509 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 510 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 511 50 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 519 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 520 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 524 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 525 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 529 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 533 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 537 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 538 50 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 542 50 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 543 50 moveto 7 0 rlineto 0 5 rlineto -7 0 rlineto closepath fill
newpath 50 60 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 51 60 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 52 60 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 53 60 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 57 60 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 58 60 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 59 60 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 60 60 moveto 490 0 rlineto 0 5 rlineto -490 0 rlineto closepath fill
newpath 50 70 moveto 500 0 rlineto 0 5 rlineto -500 0 rlineto closepath fill
newpath 50 80 moveto 57 0 rlineto 0 5 rlineto -57 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 107 80 moveto 35 0 rlineto 0 5 rlineto -35 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 142 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 146 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 147 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 151 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 152 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 153 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 157 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 158 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 159 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 163 80 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 171 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 172 80 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 180 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 184 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 185 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 186 80 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 194 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 195 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 199 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 203 80 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 211 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 212 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 216 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 217 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 218 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 219 80 moveto 12 0 rlineto 0 5 rlineto -12 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 231 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 232 80 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 240 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 241 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 245 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 246 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 250 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 251 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 255 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 256 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 257 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 261 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 262 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 263 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 264 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 265 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 269 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 270 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 271 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 275 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 276 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 277 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 278 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 282 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 283 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 284 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 285 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 289 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 290 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 294 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 295 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 296 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 300 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 301 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 302 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 303 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 307 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 311 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 312 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 313 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 314 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 318 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 319 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 320 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 324 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 325 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 326 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 330 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 331 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 332 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 333 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 337 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 341 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 342 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 343 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 347 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 351 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 355 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 359 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 360 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 364 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 365 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 366 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 367 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 371 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 372 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 376 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 377 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 381 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 382 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 386 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 387 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 388 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 389 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 393 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 394 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 395 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 399 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 400 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 401 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 405 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 406 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 407 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 411 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 412 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 416 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 417 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 421 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 422 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 423 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 427 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 428 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 429 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 433 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 434 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 435 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 439 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 440 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 441 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 445 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 446 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 447 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 451 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 452 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 456 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 457 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 458 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 462 80 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 470 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 474 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 478 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 479 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 483 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 484 80 moveto 12 0 rlineto 0 5 rlineto -12 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 496 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 497 80 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 505 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 509 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 510 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 511 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 515 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 516 80 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 524 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 525 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 529 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 530 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 534 80 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 538 80 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 546 80 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 547 80 moveto 3 0 rlineto 0 5 rlineto -3 0 rlineto closepath fill
newpath 50 90 moveto 9 0 rlineto 0 5 rlineto -9 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 59 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 63 90 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 71 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 72 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 76 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 80 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 84 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 85 90 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 93 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 94 90 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 102 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 103 90 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 111 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 112 90 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 120 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 121 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 125 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 129 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 133 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 137 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 141 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 145 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 149 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 150 90 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 158 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 162 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 166 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 167 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 168 90 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 176 90 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 184 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 188 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 192 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 196 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 200 90 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 208 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 212 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 213 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 214 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 215 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 216 90 moveto 199 0 rlineto 0 5 rlineto -199 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 415 90 moveto 82 0 rlineto 0 5 rlineto -82 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 497 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 498 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 502 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 503 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 504 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 508 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 509 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 510 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 511 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 515 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 516 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 517 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 518 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 519 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 523 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 524 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 525 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 526 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 530 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 531 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 532 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 536 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 537 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 538 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 542 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 543 90 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 547 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 548 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 549 90 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 50 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 54 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 55 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 59 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 60 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 61 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 62 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 66 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 67 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 68 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 69 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 73 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 74 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 78 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 79 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 80 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 81 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 85 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 86 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 87 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 91 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 92 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 93 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 94 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 95 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 99 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 100 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 101 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 105 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 109 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 110 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 114 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 118 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 119 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 120 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 124 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 125 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 126 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 127 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 128 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 132 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 133 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 134 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 135 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 139 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 140 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 141 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 142 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 146 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 147 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 148 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 149 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 153 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 154 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 155 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 159 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 160 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 161 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 162 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 166 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 167 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 171 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 172 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 173 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 174 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 178 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 179 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 180 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 184 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 185 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 186 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 190 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 191 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 192 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 196 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 197 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 198 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 202 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 203 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 207 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 208 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 209 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 210 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 214 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 215 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 219 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 220 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 221 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 222 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 226 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 227 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 231 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 232 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 233 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 237 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 238 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 239 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 243 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 244 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 248 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 249 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 253 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 254 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 255 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 259 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 260 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 261 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 265 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 266 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 270 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 271 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 275 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 276 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 277 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 281 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 282 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 283 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 287 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 288 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 292 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 293 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 297 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 298 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 302 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 303 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 307 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 308 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 309 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 313 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 314 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 315 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 319 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 320 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 321 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 322 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 326 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 327 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 328 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 329 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 333 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 334 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 335 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 336 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 340 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 341 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 342 100 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 350 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 351 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 352 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 353 100 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 361 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 362 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 363 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 364 100 moveto 8 0 rlineto 0 5 rlineto -8 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 372 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 376 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 377 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 378 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 382 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 383 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 387 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 388 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 389 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 393 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 394 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 398 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 399 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 400 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 404 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 405 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 409 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 410 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 414 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 415 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 419 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 420 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 424 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 425 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 429 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 430 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 434 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 435 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 439 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 440 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 444 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 445 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 449 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 450 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 454 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 455 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 459 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 463 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 464 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 468 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 469 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 470 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 474 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 475 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 479 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 480 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 484 100 moveto 4 0 rlineto 0 5 rlineto -4 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 488 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 489 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 490 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
1 1 0 setrgbcolor
newpath 491 100 moveto 1 0 rlineto 0 5 rlineto -1 0 rlineto closepath fill
0 0 1 setrgbcolor
newpath 492 100 moveto 58 0 rlineto 0 5 rlineto -58 0 rlineto closepath fill
newpath 50 110 moveto 500 0 rlineto 0 5 rlineto -500 0 rlineto closepath fill
newpath 50 120 moveto 500 0 rlineto 0 5 rlineto -500 0 rlineto closepath fill
newpath 50 130 moveto 43 0 rlineto 0 5 rlineto -43 0 rlineto closepath fill
showpage % INCLUDE-DELETE
%%Trailer
%%DocumentFonts: Helvetica

%%EndDocument
 GE /Times-Bold SF
12444 34025 MT
(Figure 4-2:)SH
/Times-Roman SF
18744 XM
(Time profile of)SH
/Courier SF
26379 XM
(bipsctrl)SH
/Times-Roman SF
32439 XM
(running with the incremental collector)SH
12288 39992 MT
(Looking across the)55 W
/Courier SF
21886 XM
(Max Pause)54 W
/Times-Roman SF
28774 XM
(and)SH
/Courier SF
30861 XM
(Median Pause)54 W
/Times-Roman SF
39909 XM
(rows in table 4-I on page 50,)54 W
9288 41712 MT
(one can see that the incremental collector has much)
159 W( smaller maximum pause and median)160 W
9288 43432 MT
(pause than the non-incremental one for)
191 W( both benchmark programs.  However, this is not)190 W
9288 45152 MT
(achieved without any cost.  For instance, the total time for)331 W
/Courier SF
41169 XM
(words)SH
/Times-Roman SF
45401 XM
(running with the)332 W
9288 46872 MT
(incremental generational collector is 24% longer than that running)
43 W( with the non-incremental)42 W
9288 48592 MT
(generational collector \050\05018.18-14.65\051/14.65 = 24%\051.  This is due to)
197 W( the fact that a larger)198 W
9288 50312 MT
(number of garbage collection sessions are initiated in the incremental)
84 W( case than in the non-)83 W
9288 52032 MT
(incremental case \05027 times vs. 18 times\051.  The)
5 W( incremental collector inherently requires more)6 W
9288 53752 MT
(memory in order to run as)
19 W( efficiently as the non-incremental collector, because the previous-)18 W
9288 55472 MT
(space heap pages are not reclaimed)
176 W( until the end of the collection, so comparatively less)177 W
9288 57192 MT
(space is available.  Therefore)
259 W( if the heap is not large enough, then collection is called)258 W
9288 58912 MT
(frequently, resulting in much wasted scanning.)SH
12288 62524 MT
(Along the same line of thinking, the reason why the incremental)
67 W( generational version)68 W
9288 64244 MT
(of)SH
/Courier SF
10592 XM
(bipsctrl)SH
/Times-Roman SF
16656 XM
(is only 7% slower than the non-incremental)
4 W( generational version \0504.61 sec vs.)3 W
9288 65964 MT
(4.29 sec\051 is likely because the)
29 W( behavior of the program is such that equal number of garbage)30 W
9288 67684 MT
(collection sessions \0503\051 are initiated in both cases,)
53 W( and the heap is expanded once equally.  It)52 W
9288 69404 MT
(is likely that the amount of scanning is)
357 W( comparable in both cases, and therefore the)358 W
9288 71124 MT
(comparable total execution times.)SH
10 SS 
30811 75600 MT
(-52-)SH
ES
%%Page: 53 53
BS
0 SI
12 /Times-Roman AF
12288 10399 MT
(The costs)
57 W( of incremental collection come not only from scanning and forwarding, but)56 W
9288 12119 MT
(from the overhead of)56 W
/Courier SF
19912 XM
(mprotect)SH
/Times-Roman SF
26028 XM
(and page fault trap)
56 W( also.  Figure 4-II itemizes these costs.)57 W
9288 13839 MT
(On the DECStation 3100,)
192 W( the cost of)191 W
/Courier SF
28563 XM
(mprotect)SH
/Times-Roman SF
34814 XM
(is 45)191 W
/Symbol SF
(m)SH
/Times-Roman SF
(sec per call.  A page trap takes)191 W
9288 15559 MT
(200)SH
/Symbol SF
(m)SH
/Times-Roman SF
(sec, which includes the time it takes to interrupt the program, enter and then exit)
123 W( the)124 W
9288 17279 MT
(trap handler to return to the main program control.)
212 W( The)
722 W( matrix shows the overhead \050in)211 W
9288 18999 MT
(milliseconds\051 of the number of pointers to scan versus the size of each)
58 W( forwarded object \050in)59 W
9288 20719 MT
(number of words\051.  For)
91 W( example, to scan a physical page of 1024 pointers and forward the)90 W
9288 22439 MT
(1024 64-word long objects that these pointers reference takes 16 milliseconds.  The)
3 W( scanning)4 W
9288 24159 MT
(and forwarding operation is essentially free)
273 W( unless the collector has to forward a large)272 W
9288 25879 MT
(number of relatively large objects,)
210 W( e.g. the collector scans an object with 4096 pointers,)211 W
9288 27599 MT
(which occupies 4 physical pages, such that each)
82 W( pointer points at a 100-words long objects)81 W
9288 29319 MT
(to be forwarded.  Such an object)
27 W( is somewhat unlikely, but the collector can still handle it in)28 W
9288 31039 MT
(a reasonable amount of)
1 W( time \05094 milliseconds\051.  In addition, since the collector does not copy)SH
9288 32759 MT
(large objects)
157 W( exceeding one heap page \050512 bytes = 128 words\051 in size, the overhead for)158 W
9288 34479 MT
(forwarding these objects -- by simply changing the space identifier\050s\051 -- is very)
105 W( low.  This)104 W
9288 36199 MT
(can be observed by the sharp drop in time overhead right past)
379 W( the 128-word mark:)380 W
9288 37919 MT
(forwarding 4096 100-word long objects takes 94 milliseconds, but forwarding the same)240 W
9288 39639 MT
(number of 128-word long objects takes only 20 milliseconds.)SH
12288 43251 MT
(Figure 4-II indicates that the costs of each overhead is not overwhelmingly large.  But)29 W
9288 44971 MT
(when the cost is incurred over and again a large number of times,)
83 W( the cumulative overhead)82 W
9288 46691 MT
(becomes significant.  In the original design of)
122 W( the collector when no attempt was made to)123 W
9288 48411 MT
(minimize the number calls to protect memory,)24 W
/Courier SF
31996 XM
(mprotect)SH
/Times-Roman SF
38080 XM
(was the dominant overhead.)
24 W( But)347 W
9288 50131 MT
(with the optimization described in section 3.2.4.2,)15 W
/Courier SF
33699 XM
(mprotect)SH
/Times-Roman SF
39774 XM
(ceases to be the major cost)
15 W( of)16 W
9288 51851 MT
(incremental collection.  In fact, the combination of)96 W
/Courier SF
34728 XM
(mprotect)SH
/Times-Roman SF
40884 XM
(and page fault overhead)
96 W( in)95 W
9288 53571 MT
(the benchmark)
15 W( programs accounts for only 3% of the total execution time.  It is, on the other)16 W
9288 55291 MT
(hand, when GC is initiated too often, then)
8 W( the cost of scanning/forwarding in the incremental)7 W
9288 57011 MT
(collector becomes the dominating overhead.  The data in)
138 W( table 4-I supports the claim that)139 W
9288 58731 MT
(total execution time is proportional to)
152 W( the number of collections initiated.  When garbage)151 W
9288 60451 MT
(collection is called for frequently, it is)
83 W( probably because the heap is not big enough for the)84 W
9288 62171 MT
(application's allocation need.  Instead of spending most effort on)
131 W( reclaiming stale objects,)130 W
9288 63891 MT
(the collector is likely to expend a disproportionate)
2 W( amount of time scanning objects that have)3 W
9288 65611 MT
(just been scanned recently.)SH
12288 69223 MT
(It is therefore important to tune performance of an application)
309 W( running with the)308 W
9288 70943 MT
(incremental collector to ensure that the heap)
38 W( is large enough, so that excessive scanning and)39 W
10 SS 
30811 75600 MT
(-53-)SH
ES
%%Page: 54 54
BS
0 SI
12 /Times-Bold AF
15480 12754 MT
(Table 4-II:)SH
/Times-Roman SF
21648 XM
(Overhead of page fault trap,)SH
/Courier SF
35447 XM
(mprotect)SH
/Times-Roman SF
41507 XM
(and scanning)SH
9 /Courier-Bold AF
9288 19109 MT
(Hardware platform: DECStation 3100)SH
9288 22023 MT
(Trap overhead = 200)SH
/Symbol SF
(m)SH
/Courier-Bold SF
(sec/trap Mprotect)
3780 W( overhead = 45)SH
/Symbol SF
(m)SH
/Courier-Bold SF
(sec/call)SH
9288 24937 MT
(Scanning and forwarding overhead:)SH
16308 26394 MT
(| #)
9720 W( W O R D S / O B J E C T)SH
16308 27851 MT
(| 4)
SH( 8 16)
1620 W( 32 64 100)
1080 W( 128 256 512 1024)
540 W( 2048 4096)SH
13608 29308 MT
(-----+------------------------------------------------------------)SH
13608 30765 MT
(# 2|)
1080 W( -)
SH( - - - - - - - - 4 - -)1620 W
16308 32222 MT
(|)SH
13608 33679 MT
(P 4|)
1080 W( -)
SH( - 4 - - - - - - - - -)1620 W
16308 35136 MT
(|)SH
13608 36593 MT
(T 8|)
1080 W( -)
SH( - - - - - - - - - - -)1620 W
16308 38050 MT
(|)SH
13608 39507 MT
(R 16|)
540 W( -)
SH( - - - - - - - - - - -)1620 W
16308 40964 MT
(|)SH
13608 42421 MT
(S 32|)
540 W( -)
SH( - - - - - - - - - - -)1620 W
16308 43878 MT
(|)SH
15228 45335 MT
(64| -)
SH( - - - - - - - - - - -)1620 W
16308 46792 MT
(|)SH
14688 48249 MT
(128| -)
SH( - - 4 4 4 - - - - - -)1620 W
16308 49706 MT
(|)SH
14688 51163 MT
(256| 4)
SH( - 4 - 4 4 - - - - - 4)1620 W
16308 52620 MT
(|)SH
14688 54077 MT
(512| 4)
SH( 3 4 12)
1620 W( 8)
1080 W( 11)
1620 W( 3)
1080 W( 4 4 4 4 4)1620 W
16308 55534 MT
(|)SH
14148 56991 MT
(1024| 4)
SH( 8 8 12)
1620 W( 16 24 4)
1080 W( 3 4 4 4 4)1620 W
16308 58448 MT
(|)SH
14148 59905 MT
(2048| 19)
SH( 16 19 19 35 43 12 12 11 11 11 11)1080 W
16308 61362 MT
(|)SH
14148 62819 MT
(4096| 24)
SH( 27 35 43 66 94 20 20 16 20 24 24)1080 W
16308 64276 MT
(|)SH
20628 65733 MT
(\050Measurements inside matrix are in milliseconds.\051)SH
10 /Times-Roman AF
30811 75600 MT
(-54-)SH
ES
%%Page: 55 55
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(forwarding as a result of too many GC)
477 W( initiations is prevented.  But under most)476 W
9288 12119 MT
(circumstances, figure 4-II suggests that the real-time performance of)
407 W( the incremental)408 W
9288 13839 MT
(collector will still be)
1 W( satisfactory for even very memory intensive codes.  The sum of the trap)SH
9288 15559 MT
(and)SH
/Courier SF
11329 XM
(mprotect)SH
/Times-Roman SF
17397 XM
(overheads, and the time for scanning and forwarding objects)
8 W( are likely to be)9 W
9288 17279 MT
(within the 100 millisecond limit.)SH
/Times-Bold SF
9288 21683 MT
(4.4 Soundness of Generational Collection)SH
/Times-Roman SF
12288 25386 MT
(Generational collection)
798 W( improves performance whenever the extra cost of)797 W
9288 27106 MT
(bookkeeping is less than the cost of the conducting the additional GC work.)
118 W( The)
538 W( strategy)119 W
9288 28826 MT
(presented in this thesis treats the entire stable set as the remembered)
336 W( set.  Since the)335 W
9288 30546 MT
(remembered set)
251 W( is scanned at each collection, the desirability of generational collection)252 W
9288 32266 MT
(decidedly depends upon whether retention of the so-called stable objects is a wise choice.)
25 W( It)349 W
9288 33986 MT
(is beneficial if the stable objects remain alive for)
414 W( a relatively long period of time.)415 W
9288 35706 MT
(Otherwise, if most of the stable objects ``die'' right after they become stable, then the heap)67 W
9288 37426 MT
(space is not efficiently utilized, and generational collection is not saving much)
81 W( GC work at)82 W
9288 39146 MT
(all -- it would actually be increasing GC work.)SH
12288 42758 MT
(From table 4-I it can be seen)
124 W( that with generational collection the benchmarks yield)123 W
9288 44478 MT
(almost uniformly better total execution time.  Except for)62 W
/Courier SF
37254 XM
(bipsctrl)SH
/Times-Roman SF
43376 XM
(running with the non-)63 W
9288 46198 MT
(incremental collector, all the other programs achieve)
88 W( better total time, as they are spending)87 W
9288 47918 MT
(less time in GC.  The percentage of GC work saved ranges from about)
80 W( 15%, in the case of)81 W
9288 49638 MT
(the incremental version of)17 W
/Courier SF
22225 XM
(bipsctrl)SH
/Times-Roman SF
28302 XM
(\050\0501.01-0.86\051/1.01 = 15%\051, to over 60%, in the case of)17 W
9288 51358 MT
(the incremental version of)56 W
/Courier SF
22381 XM
(words)SH
/Times-Roman SF
26337 XM
(\050\0509.02-3.58\051/9.02 = 60%\051.  It is, however,)
56 W( worth noticing)57 W
9288 53078 MT
(that the heap)
27 W( space requirement for the incremental generational version of)26 W
/Courier SF
45880 XM
(words)SH
/Times-Roman SF
49806 XM
(is higher)26 W
9288 54798 MT
(than its counterparts.  This is likely due to the fact)
95 W( that incremental generational collection)96 W
9288 56518 MT
(tends to retain more stable objects.)SH
12288 60130 MT
(Another point worth noticing is that the)
225 W( incremental generational versions of both)224 W
9288 61850 MT
(benchmarks incur higher maximum GC pauses than the)
582 W( non-incremental versions.)583 W
9288 63570 MT
(Maximum GC pause for the)
44 W( incremental collector always occurs during the call to start GC.)43 W
9288 65290 MT
(The more objects to protect, the longer)
92 W( GC initiation takes.  With incremental generational)93 W
9288 67010 MT
(collection, more objects have to)
183 W( be protected during GC initiation because in addition to)182 W
9288 68730 MT
(protecting the ambiguous roots, the collector has to)
52 W( protect the retained objects in the stable)53 W
9288 70450 MT
(set.)SH
10 SS 
30811 75600 MT
(-55-)SH
ES
%%Page: 56 56
BS
0 SI
12 /Times-Roman AF
12288 10399 MT
(Perhaps the longer GC pause can be viewed as a drawback of)
73 W( generational collection)72 W
9288 12119 MT
(for the incremental collector; but when considering other)
587 W( more desirable aspects,)588 W
9288 13839 MT
(generational collection seems to be)
183 W( favorable when used in conjunction with incremental)182 W
9288 15559 MT
(collection. Incremental)
1492 W( collection)
596 W( spreads out application allocation and collector)597 W
9288 17279 MT
(scanning/forwarding, so that at any time less memory is available for)
564 W( allocation.)563 W
9288 18999 MT
(Generational collection can decrease the collector's contention on heap)
125 W( space, because the)126 W
9288 20719 MT
(amount of forwarding is reduced as stable objects are)
245 W( never forwarded.  Therefore two)244 W
9288 22439 MT
(benefits are accomplished simultaneously: \0501\051)
70 W( less overhead for copying forwarded objects;)71 W
9288 24159 MT
(and \0502\051 more heap space is available for application allocation.  The first)
34 W( benefit depends on)33 W
9288 25879 MT
(whether the stable objects are in fact long-living.)
69 W( The)
439 W( second one helps reduce the number)70 W
9288 27599 MT
(of garbage collections needed.)SH
10 SS 
30811 75600 MT
(-56-)SH
ES
%%Page: 57 57
BS
0 SI
14 /Times-Bold AF
28630 11947 MT
(Chapter 5)SH
23225 14560 MT
(Summary and Future Work)SH
12 SS 
9288 18964 MT
(5.1 Summary)SH
/Times-Roman SF
12288 22667 MT
(My thesis in this project is)
288 W( that incremental collection can be done feasibly and)287 W
9288 24387 MT
(efficiently in an architecture)
133 W( and compiler independent manner.  To support my thesis, an)134 W
9288 26107 MT
(experiment in)
49 W( building such a collector was carried out, and the following results have been)48 W
9288 27827 MT
(gathered:)SH
/Symbol SF
11436 31079 MT
(\267)SH
/Times-Roman SF
12288 XM
(An incremental, generational mostly-copying collector for C++ has been built.)SH
/Symbol SF
11436 33108 MT
(\267)SH
/Times-Roman SF
12288 XM
(The collector runs on commercially-available uniprocessors without)
38 W( any special)39 W
12288 34394 MT
(hardware assist.  Currently it runs on both the MIPS and the VAX architectures.)SH
/Symbol SF
11436 36423 MT
(\267)SH
/Times-Roman SF
12288 XM
(The collector runs in the U)127 W
10 SS 
(NIX)SH
12 SS 
28028 XM
(platform, using the)
127 W( operating system's support)126 W
12288 37709 MT
(for user controlled page protection)
205 W( \050)206 W
/Courier SF
(mprotect)SH
/Times-Roman SF
(\051 to synchronize between the)206 W
12288 38995 MT
(mutator and the scanner.)SH
/Symbol SF
11436 41024 MT
(\267)SH
/Times-Roman SF
12288 XM
(The implementation)
177 W( of the collector does not require any modification to the)176 W
12288 42310 MT
(C++ compiler.  It is)
116 W( compatible with both AT&T C++ Language Releases 1.2)117 W
12288 43596 MT
(and 2.0.)SH
/Symbol SF
11436 45625 MT
(\267)SH
/Times-Roman SF
12288 XM
(On the DECStation 3100, the maximum GC pause of the collector is well within)3 W
12288 46911 MT
(the 100-millisecond limit imposed)
19 W( by most real-time applications.  The majority)20 W
12288 48197 MT
(of the GC pauses \050i.e. average pause\051 are only 4 milliseconds each.)SH
/Symbol SF
11436 50226 MT
(\267)SH
/Times-Roman SF
12288 XM
(The total execution times of the application programs)
4 W( are not adversely affected.)3 W
12288 51512 MT
(This is due in part to generational collection, which)
191 W( alleviates contention for)192 W
12288 52798 MT
(heap space and helps reduce the number of garbage collections needed.)SH
9288 56547 MT
(There are two important lessons obtained from conducting this investigation:)SH
11688 59662 MT
(1.)SH
12888 XM
(An incremental collector requires)
353 W( more heap memory in order to run as)352 W
12888 60948 MT
(efficiently as its non-incremental version.)
200 W( Incremental)
701 W( collection inherently)201 W
12888 62234 MT
(demands more memory)
56 W( because collection is spread out over time and storage)55 W
12888 63520 MT
(is not reclaimed until the end of collection.)SH
11688 65549 MT
(2.)SH
12888 XM
(The costs of trapping,)488 W
/Courier SF
25608 XM
(mprotect)SH
/Times-Roman SF
32156 XM
(calls, and scanning objects)
488 W( are not)489 W
12888 66835 MT
(overwhelmingly large when viewed individually as single units.)
10 W( But)
319 W( when one)9 W
12888 68121 MT
(or more of these costs are incurred a)
413 W( large number of times, then the)414 W
12888 69407 MT
(cumulative effect can become prohibitively expensive.)
242 W( To)
783 W( enable efficient)241 W
12888 70693 MT
(incremental collection, invocations of all of these)
272 W( costs must be kept at a)273 W
12888 71979 MT
(minimum.)SH
10 SS 
30811 75600 MT
(-57-)SH
ES
%%Page: 58 58
BS
0 SI
12 /Times-Roman AF
12288 10399 MT
(The second lesson is related)
24 W( to the first one in that when the available heap memory is)23 W
9288 12119 MT
(insufficient, garbage collection is initiated frequently, resulting in repeated incurrence of)217 W
9288 13839 MT
(trapping,)SH
/Courier SF
14014 XM
(mprotect)SH
/Times-Roman SF
20199 XM
(and scanning costs,)
125 W( which otherwise could have been avoided.  It is)124 W
9288 15559 MT
(observed that excessive number of garbage collections can)
31 W( degrade performance reflected in)32 W
9288 17279 MT
(the total execution time significantly.)SH
/Times-Bold SF
9288 21683 MT
(5.2 Future Work)SH
/Times-Roman SF
12288 25386 MT
(This incremental, non-concurrent collector)
395 W( can be easily extended to become a)394 W
9288 27106 MT
(concurrent collector.  The)
506 W( collector read/write protects the physical pages that the)507 W
9288 28826 MT
(application is)
44 W( not supposed to access.  Because of this, in a multiprocessor environment, the)43 W
9288 30546 MT
(collector can scan the protected pages in parallel)
89 W( with the application program's execution.)90 W
9288 32266 MT
(The concurrent collectors described in)
55 W( [Appel)
SH( et al.)
55 W( 88] and)
54 W( [Detlefs)
SH( 90] use this strategy of)54 W
9288 33986 MT
(virtual memory page protection)
14 W( to synchronize between the mutator and the scanner.  With a)15 W
9288 35706 MT
(concurrent collection scheme,)
207 W( the total execution time for an application can be reduced)206 W
9288 37426 MT
(significantly. Both)
506 W( [Appel)
SH( et al. 88] and)
103 W( [Detlefs)
SH( 90] report reductions in GC)
103 W( overhead by)104 W
9288 39146 MT
(about 50%.)SH
12288 42758 MT
(Presently, generational collection is conducted by protecting)
131 W( all the stable objects at)130 W
9288 44478 MT
(the start of each collection.  When the application accesses a protected stable object,)
179 W( the)180 W
9288 46198 MT
(program traps and the collector enters to unprotect and scan the physical page cluster)298 W
9288 47918 MT
(containing the object.  This can be potentially)
182 W( wasteful because stable objects would not)183 W
9288 49638 MT
(need to be scanned if)
168 W( they have not been mutated since the last time they were scanned.)167 W
9288 51358 MT
(Conceivably more experiments can be)
70 W( done with different generational collection strategies)71 W
9288 53078 MT
(in the C++ environment.  For instance, if stable objects can be grouped together on the same)22 W
9288 54798 MT
(physical page, and the)
33 W( page is WRITE protected only \050so it can be read from but not written)34 W
9288 56518 MT
(to\051, then the application will)
72 W( be able to read into stable objects without causing page faults.)71 W
9288 58238 MT
(Page faults occur only when application tries to overwrite some part of the)
38 W( physical page, at)39 W
9288 59958 MT
(which point)
180 W( the garbage collection can register that the page has been mutated and must)179 W
9288 61678 MT
(remember to scan it later.  Depending on the behavior of)
23 W( the program, this scheme may save)24 W
9288 63398 MT
(some amount of scanning and page trap overhead.)SH
12288 67010 MT
(Another area to work on is the)
26 W( further incrementalization of the collector, specifically,)25 W
9288 68730 MT
(the incrementalization the GC initiation process.  Maximum GC pause always)
28 W( occurs during)29 W
9288 70450 MT
(the call to start garbage collection.  But since the program)
145 W( faults many times during each)144 W
10 SS 
30811 75600 MT
(-58-)SH
ES
%%Page: 59 59
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
(garbage collection session, the average GC pause is the average time)
38 W( it takes to perform GC)39 W
9288 12119 MT
(work at each page fault.)
89 W( For)
476 W( the benchmark programs used in section 4.2, the average GC)88 W
9288 13839 MT
(pause is only 4 milliseconds.  It)
17 W( usually takes on the order to 4 milliseconds to unprotect and)18 W
9288 15559 MT
(scan a physical page cluster \050refer to figure 4-II\051.)
363 W( Even)
1024 W( for very memory intensive)362 W
9288 17279 MT
(programs, the overhead for unprotecting and)
175 W( scanning seems to be fairly well controlled.)176 W
9288 18999 MT
(However, for the GC initiation process, the overhead is)
108 W( directly proportional to the size of)107 W
9288 20719 MT
(the root set to be)
21 W( protected, and can approach the vicinity of 100 millisecond limit for a very)22 W
9288 22439 MT
(large root set.)
288 W( Therefore,)
874 W( in order to reduce maximum pause, it is necessary that the)287 W
9288 24159 MT
(performance bottleneck found in the GC)
305 W( initiation process be alleviated.  It would be)306 W
9288 25879 MT
(desirable to ``spread out'' the task)
139 W( of initiating GC, much like the concept of incremental)138 W
9288 27599 MT
(collection, where the task of GC itself is ``spread out'' over time.)SH
10 SS 
30811 75600 MT
(-59-)SH
ES
%%Page: 60 60
BS
0 SI
14 /Times-Bold AF
28046 11947 MT
(Appendix A)SH
17760 13667 MT
(Sample C++ program using garbage collection)SH
12 /Times-Italic AF
9288 18088 MT
(The following is the listing of the benchmark program)SH
/Times-Bold SF
35528 XM
(words)SH
/Times-Italic SF
(.)SH
9 /Courier-Bold AF
9288 21271 MT
(/* Read in words on cin.  Build a binary tree with a word record at each)SH
10908 22309 MT
(node. Keep)
540 W( a frequency count of a word by updating the 'count' field)SH
10908 23347 MT
(in its word record in the tree.  Then output words in alphabetical)SH
10908 24385 MT
(order on cout.)SH
10908 26461 MT
(Copyright \050c\051 1989, Digital Equipment Corp.  All rights reserved.)SH
9288 27499 MT
(*/)SH
9288 29575 MT
(#include <stream.h>)SH
9288 30613 MT
(#include <string.h>)SH
9288 31651 MT
(#include <ctype.h>)SH
9288 33727 MT
(#include "gcalloc.h")540 W
9288 35803 MT
(/* The basic data structure is a binary tree made up of items of the following)SH
10908 36841 MT
(form.)SH
9288 37879 MT
(*/)SH
9288 39955 MT
(struct word {)540 W
13608 40993 MT
(word* lesser;)SH
13608 42031 MT
(word* greater;)SH
13608 43069 MT
(int count;)540 W
13608 44107 MT
(char symbol[)
540 W( 1 ];)SH
13608 45145 MT
(word\050 char* chars \051;)SH
13608 46183 MT
(GCCLASS\050 word \051;)SH
9288 47221 MT
(};)SH
9288 49297 MT
(word::word\050 char* chars \051)SH
9288 50335 MT
({)SH
13608 51373 MT
(GCALLOCV\050 word, sizeof\050 word \051+strlen\050 chars \051+\0501-4\051 \051;)SH
13608 52411 MT
(lesser = NULL;)SH
13608 53449 MT
(greater = NULL;)SH
13608 54487 MT
(count = 1;)SH
13608 55525 MT
(strcpy\050 symbol, chars \051;)SH
9288 56563 MT
(})SH
9288 58639 MT
(void word::GCPointers\050)
540 W( \051  {)SH
13608 59677 MT
(gcpointer\050 lesser \051;)SH
13608 60715 MT
(gcpointer\050 greater \051;)SH
9288 61753 MT
(})SH
9288 63829 MT
(/* A word is read from CIN and a word entry is made by the following)SH
10908 64867 MT
(function. Words)
540 W( are considered to be a string of one more alphabetical)SH
10908 65905 MT
(characters, case is ignored.)SH
9288 66943 MT
(*/)SH
9288 69019 MT
(int nextc)
540 W( = ' ';)SH
9288 71095 MT
(word* read_word\050\051)540 W
10 /Times-Roman AF
30811 75600 MT
(-60-)SH
ES
%%Page: 61 61
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
({)SH
13608 11221 MT
(char symbol[)
540 W( 100 ];)SH
13608 12259 MT
(int cnt;)540 W
13608 14335 MT
(while \050isalpha\050)
540 W( nextc \051 == 0\051  {)SH
15228 15373 MT
(if \050nextc)
540 W( == EOF\051  return\050 NULL \051;)SH
15228 16411 MT
(nextc = getchar\050\051;)SH
13608 17449 MT
(})SH
13608 18487 MT
(cnt = 0;)SH
13608 19525 MT
(while \050isalpha\050)
540 W( nextc \051\051  {)SH
15228 20563 MT
(if \050isupper\050)
540 W( nextc \051\051  nextc = nextc+' ';)SH
15228 21601 MT
(symbol[ cnt++ ] = nextc;)SH
15228 22639 MT
(nextc = getchar\050\051;)SH
13608 23677 MT
(})SH
13608 24715 MT
(symbol[ cnt ] = 0;)SH
13608 25753 MT
(return new word\050 symbol \051;)SH
9288 26791 MT
(})SH
9288 28867 MT
(/* The table is printed on COUT by walking the tree in alphabetical order */)SH
9288 30943 MT
(void output_table\050)
540 W( word* tree \051)SH
9288 31981 MT
({)SH
13608 33019 MT
(if \050tree)
540 W( != NULL\051  {)SH
15228 34057 MT
(output_table\050 tree->lesser \051;)SH
15228 35095 MT
(cout << tree->count << "\134t" << tree->symbol << "\134n";)SH
15228 36133 MT
(output_table\050 tree->greater \051;)SH
13608 37171 MT
(})SH
9288 38209 MT
(})SH
9288 40285 MT
(/* A entry is inserted into the table, or the count is incremented for each)SH
10908 41323 MT
(word by the following function.)SH
9288 42361 MT
(*/)SH
9288 44437 MT
(word* count_word\050)
540 W( word* tree, word* newword \051)SH
9288 45475 MT
({)SH
13608 46513 MT
(int cmp;)540 W
13608 48589 MT
(if \050tree)
540 W( != NULL\051  {)SH
15228 49627 MT
(cmp = strcmp\050 &newword->symbol[0], &tree->symbol[0] \051;)SH
15228 50665 MT
(if \050cmp)
540 W( < 0\051)SH
16848 51703 MT
(tree->lesser = count_word\050 tree->lesser, newword \051;)SH
15228 52741 MT
(else if \050cmp)
540 W( > 0\051)SH
16848 53779 MT
(tree->greater = count_word\050 tree->greater, newword \051;)SH
15228 54817 MT
(else)SH
16848 55855 MT
(tree->count = tree->count+1;)SH
15228 56893 MT
(return\050 tree \051;)SH
13608 57931 MT
(})SH
13608 58969 MT
(return\050 newword \051;)SH
9288 60007 MT
(})SH
9288 62083 MT
(main\050 int argc, char* argv[] \051)SH
9288 63121 MT
({)SH
13608 64159 MT
(word *wp,)
540 W( *tree = NULL;)SH
13608 66235 MT
(while \050\050wp)
540 W( = read_word\050\051\051 != NULL\051  tree = count_word\050 tree, wp \051;)SH
13608 67273 MT
(output_table\050 tree \051;)SH
9288 68311 MT
(})SH
10 /Times-Roman AF
30811 75600 MT
(-61-)SH
ES
%%Page: 62 62
BS
0 SI
14 /Times-Bold AF
28085 11947 MT
(Appendix B)SH
16324 13667 MT
(Source code for the Incremental Garbage Collector)SH
12 SS 
9288 18071 MT
(B.1 Header file for C++ version 1.2)SH
/Times-Italic SF
9288 21772 MT
(The following is the listing of)SH
/Times-Bold SF
23629 XM
(gcalloc-1.2.h)SH
/Times-Italic SF
(, the header file for C++ version 1.2.)SH
9 /Courier-Bold AF
9288 24955 MT
(/* This module implements garbage collected storage for C++ \050version 1.2\051)SH
10908 25993 MT
(programs using an incremental  version of the generational)SH
10908 27031 MT
(mostly-copying garbage collection algorithm.)SH
10908 29107 MT
(Copyright \050c\051 1991, 1989, Digital Equipment Corp.  All rights reserved.)SH
9288 30145 MT
(*/)SH
9288 32221 MT
(#ifndef GCALLOCH)SH
9288 33259 MT
(#define GCALLOCH 1)SH
9288 35335 MT
(/* Defining garbage collected classes)SH
10908 36373 MT
(----------------------------------)SH
10908 37411 MT
(Classes allocated in the garbage collected heap must have constructor method)SH
10908 38449 MT
(and a "pointer locator" method name GCPointer.  For example, a class that)SH
10908 39487 MT
(holds a variable length string, a reference count, and pointers to strings)SH
10908 40525 MT
(that are greater or lesser than it can be defined as follows:)SH
13608 42601 MT
(struct word {)540 W
17928 43639 MT
(word* lesser;)SH
17928 44677 MT
(word* greater;)SH
17928 45715 MT
(int count;)540 W
17928 46753 MT
(char symbol[)
540 W( 4 ];)SH
17928 47791 MT
(word\050 char* chars \051;)SH
17928 48829 MT
(GCCLASS\050 word \051;)SH
13608 49867 MT
(};)SH
13608 51943 MT
(word::word\050 char* chars \051)SH
13608 52981 MT
({)SH
17928 54019 MT
(GCALLOCV\050 word, sizeof\050 word \051+strlen\050 chars \051-3 \051;)SH
17928 55057 MT
(lesser = NULL;)SH
17928 56095 MT
(greater = NULL;)SH
17928 57133 MT
(count = 1;)SH
17928 58171 MT
(strcpy\050 symbol, chars \051;)SH
13608 59209 MT
(})SH
13608 61285 MT
(void word::GCPointers\050)
540 W( \051  {)SH
17928 62323 MT
(gcpointer\050 lesser \051;)SH
17928 63361 MT
(gcpointer\050 greater \051;)SH
13608 64399 MT
(})SH
10908 66475 MT
(The declaration GCCLASS informs the garbage collector that the type word)SH
10908 67513 MT
(is garbage collected and has a callback method word::GCPointers.)SH
10908 69589 MT
(The constructor, word::word, allocates space in the heap and then)SH
10908 70627 MT
(initializes it.  Space allocation is done by the define GCALLOCV that takes)SH
10908 71665 MT
(the type and the size in bytes as its arguments.  When the size of the type)SH
10 /Times-Roman AF
30811 75600 MT
(-62-)SH
ES
%%Page: 63 63
BS
0 SI
9 /Courier-Bold AF
10908 10183 MT
(is known at compile time, storage can be allocated in the constructor method)SH
10908 11221 MT
(by using GCALLOC which takes the object type as it's argument.  For example,)SH
10908 12259 MT
(for a type t, GCALLOCV\050 t, sizeof\050 t \051 \051 can be replaced by GCALLOC\050 t \051.)SH
10908 14335 MT
(The "pointer locator" method, word::GCPointers, is used by the garbage)SH
10908 15373 MT
(collector to identify all pointers in the object.  This is done by)SH
10908 16411 MT
(having the method call gcpointer with each pointer in the object that could)SH
10908 17449 MT
(point to a garbage collected object.  In order to correctly invoke pointer)SH
10908 18487 MT
(location methods for superclasses or class objects contained in the class,)SH
10908 19525 MT
(the following rules must be followed:)SH
13608 21601 MT
(1\051 for class C:P {}, C::GCPointers must contain P::GCPointers\050\051)SH
13608 22639 MT
(2\051 for class C { X x; }, C::GCPointers must contain x.GCPointers\050\051)SH
13608 23677 MT
(3\051 for class C { X* x; }, C::GCPointers must contain gcpointer\050 x \051)SH
10908 25753 MT
(Sometimes a class will be a subclass of a garbage collected object, yet)SH
10908 26791 MT
(add no pointers to the class.  In this case, it need not specify GCCLASS)SH
10908 27829 MT
(in the class declaration, but it must include a constructor method that)SH
10908 28867 MT
(allocates garbage collected storage.  Often this method can be expressed)SH
10908 29905 MT
(as:)SH
13608 30943 MT
(subclass::subclass {GCALLOC\050subclass\051})SH
10908 33019 MT
(If the subclass does not provide this constructor, then instances of the)SH
10908 34057 MT
(subclass will be allocated from the non-garbage-collected heap.  The base)SH
10908 35095 MT
(class may assure that this never happens by including the following test)SH
10908 36133 MT
(in its constructor method:)SH
13608 38209 MT
(if \050gcobject\050)
540 W( this \051 == 0\051  abort\050\051;)SH
10908 40285 MT
(Once the object has been defined, storage is allocated using the normal)SH
10908 41323 MT
(C++ mechanism:)SH
13608 43399 MT
(sp = new word\050 "dictionary" \051;)SH
10908 45475 MT
(Definitions)SH
10908 46513 MT
(-----------)SH
10908 47551 MT
(pointer to an object - a pointer that points to the start of an object.)SH
10908 48589 MT
(garbage collected object - an object whose storage is allocated by gcalloc.)SH
10908 50665 MT
(Caveats)SH
10908 51703 MT
(-------)SH
10908 52741 MT
(When the garbage collector is invoked, it searches the processor's)SH
10908 53779 MT
(registers, the stack, and the program's static area for "hints" as to what)SH
10908 54817 MT
(storage is still accessible.  These hints are used to identify objects that)SH
10908 55855 MT
(are the "roots" and are to be left in place.  Objects that the roots point)SH
10908 56893 MT
(to will be moved to compact the heap.  Because of this:)SH
10908 58969 MT
(Objects allocated in the garbage collected heap MAY MOVE.)SH
10908 61045 MT
(Pointers to)
540 W( garbage collected objects MAY BE passed as arguments or stored)SH
10908 62083 MT
(in static storage.)SH
10908 64159 MT
(Pointers to garbage collected objects MAY NOT be stored in dynamically)SH
10908 65197 MT
(allocated objects that are not garbage collected, UNLESS one has specified)SH
10908 66235 MT
(the GCHEAPROOTS flag in a gcheap declaration.)SH
10908 68311 MT
(Pointers to garbage collected objects contained in garbage collected objects)SH
10908 69349 MT
(MUST always point outside the garbage collected heap or to a garbage)SH
10908 70387 MT
(collected object.)SH
10 /Times-Roman AF
30811 75600 MT
(-63-)SH
ES
%%Page: 64 64
BS
0 SI
9 /Courier-Bold AF
10908 10183 MT
(Sizing the heap)SH
10908 11221 MT
(---------------)SH
10908 12259 MT
(In order to make heap allocated storage as painless as possible, the user)SH
10908 13297 MT
(does not have to do anything to configure the heap.  This default is an)SH
10908 14335 MT
(initial heap of 1 megabyte that is expanded in 1 megabyte increments)SH
10908 15373 MT
(whenever the heap is more than 25% full after a total garbage collection.)SH
10908 16411 MT
(Total garbage collections are done when the heap is more than 35% full.)SH
10908 18487 MT
(However, if this is not the desired behavior, then it is possible to "tune")SH
10908 19525 MT
(the collector by including one or more global gcheap declarations in the)SH
10908 20563 MT
(program. In)
540 W( order to understand the parameters supplied in a gcheap)SH
10908 21601 MT
(declaration, one needs an overview of the storage allocation and garbage)SH
10908 22639 MT
(collection algorithm.)SH
10908 24715 MT
(Storage is allocated from the heap until 50% of the heap has been allocated.)SH
10908 25753 MT
(All accessible objects allocated since the last collection are retained and)SH
10908 26791 MT
(made a part of the stable set.  If less than <collect all percent> of the)SH
10908 27829 MT
(heap is allocated, then the collection process is finished.  Otherwise, the)SH
10908 28867 MT
(entire heap \050including the stable set\051 is garbage collected.  If the amount)SH
10908 29905 MT
(allocated following the total collection is greater than <increment heap)SH
10908 30943 MT
(percent>, then an attempt is made to expand the heap.)SH
13608 33019 MT
(gcheap <CC-identifier>\050)
540 W( <initial heap size>,)SH
27108 34057 MT
(<maximum heap size>,)SH
27108 35095 MT
(<increment size>,)SH
27108 36133 MT
(<collect all percent>,)SH
27108 37171 MT
(<increment heap percent>,)SH
27108 38209 MT
(<increment stable percent>,)SH
27108 39247 MT
(<heap log> \051)SH
10908 41323 MT
(The arguments are defined as follows:)SH
13608 43399 MT
(<CC-identifier> a)
5940 W( legal C++ identifier.)SH
13608 44437 MT
(<initial heap size>)
SH( initial)
3780 W( size of the heap in bytes.)SH
28188 45475 MT
(DEFAULT: 1048576.)SH
13608 46513 MT
(<maximum heap size>)
SH( maximum)
3780 W( heap size in bytes.)SH
28188 47551 MT
(DEFAULT: 2147483647.)SH
13608 48589 MT
(<increment size>)
SH( #)
5400 W( of bytes to add to each heap on each)SH
28188 49627 MT
(expansion. DEFAULT:)
540 W( 1048576.)SH
13608 50665 MT
(<collect all percent>)
SH( number)
2700 W( between 0 and 50 that is the percent)SH
28188 51703 MT
(allocated after a partial collection that will)SH
28188 52741 MT
(force a total collection.  A value of 0 will)SH
28188 53779 MT
(disable generational collection.  DEFAULT: 35.)SH
13608 54817 MT
(<increment heap percent>)
SH( number)
1080 W( between 0 and 50 that is the percent)SH
28188 55855 MT
(of newly allocated after a collection that)SH
28188 56893 MT
(will force heap expansion.  DEFAULT: 25.)SH
13608 57931 MT
(<increment stable percent> number between 0 and 50 that is the percent)SH
28188 58969 MT
(stable after a collection is initiated that)SH
28188 60007 MT
(will force heap expansion.  DEFAULT: 20.)SH
13608 61045 MT
(<flags> controls)
10260 W( logging on stderr, error checking,)SH
28188 62083 MT
(and root finding:)SH
29268 63121 MT
(& GCSTATS = log collection statistics)SH
29268 64159 MT
(& GCMEM = log memory usage statistics)SH
29268 65197 MT
(& GCROOTLOG = log roots found in the stack,)SH
36828 66235 MT
(registers, and static area)SH
29268 67273 MT
(& GCHEAPROOTS = treat non-GC heap as roots)SH
29268 68311 MT
(& GCHEAPLOG = log possible roots in non-GC)SH
36828 69349 MT
(heap)SH
29268 70387 MT
(& GCTSTOBJ = perform object consistency)SH
36288 71425 MT
(tests)SH
10 /Times-Roman AF
30811 75600 MT
(-64-)SH
ES
%%Page: 65 65
BS
0 SI
9 /Courier-Bold AF
29268 10183 MT
(& GCGUESSPTRS = guess number of pointers in)SH
37908 11221 MT
(objects)SH
29268 12259 MT
(& GCZERO = zero free memory after GC)SH
29268 13297 MT
(& GCDEBUGLOG = log events internal to the)SH
37368 14335 MT
(garbage collector)SH
29268 15373 MT
(& GCHEAPMAP = maintain memory allocation)SH
36828 16411 MT
(map)SH
28188 17449 MT
(DEFAULT: 0.)SH
10908 19525 MT
(When multiple gcheap declarations occur, the one that specifies the largest)SH
10908 20563 MT
(<maximum heap size> value will control all factors except flags which is)SH
10908 21601 MT
(the inclusive-or of all <flags> values.)SH
10908 23677 MT
(Configured values may be overridden by values supplied from environment)SH
10908 24715 MT
(variables. The)
540 W( user must set these variables in a consistent manner.  The)SH
10908 25753 MT
(variables and the values they set are:)SH
13608 27829 MT
(GCMINBYTES <initial)
4320 W( heap size>)SH
13608 28867 MT
(GCMAXBYTES <maximum)
4320 W( heap size>)SH
13608 29905 MT
(GCINCBYTES <increment)
4320 W( size>)SH
13608 30943 MT
(GCALLPERCENT <collect)
3240 W( all percent>)SH
13608 31981 MT
(GCINCPERCENT <increment)
3240 W( heap percent>)SH
13608 33019 MT
(GCSTABLEPERCENT <increment)
1620 W( stable percent>)SH
13608 34057 MT
(GCFLAGS <flags>)5940 W
10908 36133 MT
(If any of these variables are supplied, then the actual values used to)SH
10908 37171 MT
(configure the garbage collector are logged on stderr.)SH
10908 39247 MT
(Limits)SH
10908 40285 MT
(------)SH
10908 41323 MT
(No more than 2046 garbage collected classes.)SH
10908 42361 MT
(Individual objects no larger than 4,193,788 bytes.)SH
9288 43399 MT
(*/)SH
13068 45475 MT
(/*******************************************************)SH
13608 46513 MT
(* C++ Garbage Collected Storage Interface Definitions *)SH
13608 47551 MT
(*******************************************************/)SH
9288 49627 MT
(/* Declarations for objects not directly used by the user of the interface. */)SH
9288 51703 MT
(typedef int  *GCP;)
SH( /*)
7020 W( Pointer to a garbage collected object. */)SH
9288 53779 MT
(extern GCP)
540 W( gcmove\050 GCP ptr \051;  /* Objects are moved by this function. */)SH
9288 55855 MT
(extern void  gccollect\050\051;)
SH( /*)
3240 W( Invokes the collector. */)SH
9288 57931 MT
(typedef void \050*GCCALLBACKPROC\051\050 GCP \051;)SH
26568 58969 MT
(/* Callback procedure type */)SH
9288 61045 MT
(extern int  gcregistercallback\050 GCCALLBACKPROC pointers, char* type \051;)SH
26568 62083 MT
(/* Registers a callback method */)SH
9288 64159 MT
(/* The following defines are used to compute the number of words needed for)SH
10908 65197 MT
(an object.  The count includes 1 word for the header.  These defines are)SH
10908 66235 MT
(used inside GCALLOC and GCALLOCV.)SH
9288 67273 MT
(*/)SH
9288 69349 MT
(#define GCBYTEStoWORDS\050 x \051 \050\050\050x\051+7\051>>2\051)
SH( /*)
3780 W( Word align */)SH
9288 71425 MT
(extern GCP)
540 W( gcalloc\050 int words, int callback \051; /* Actual space allocator */)SH
10 /Times-Roman AF
30811 75600 MT
(-65-)SH
ES
%%Page: 66 66
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
(/* User defined objects use the following definition to define the class)SH
10908 11221 MT
(as garbage collected.  It defines the pointer method, a static variable)SH
10908 12259 MT
(to hold the index into the garbage collector's table of methods, and a)SH
10908 13297 MT
(method to return the type name.)SH
9288 14335 MT
(*/)SH
9288 16411 MT
(#define GCCLASS\050 type \051  void  GCPointers\050\051;)
SH( \134)17820 W
22788 17449 MT
(static int  __GCPointers;)
SH( \134)14580 W
22788 18487 MT
(char* __GCType\050\051{)
540 W( return "type"; })SH
9288 20563 MT
(/* Storage for fixed size objects is allocated by:  */)SH
9288 22639 MT
(#define GCALLOC\050 type \051)
SH( \134)29160 W
10908 23677 MT
(this = \050\050this==0\051 ?)
SH( \134)29700 W
15228 24715 MT
(\050\050\050__GCPointers==0\051 ?)
SH( \134)24300 W
16308 25753 MT
(__GCPointers= \134)27540 W
20088 26791 MT
(gcregistercallback\050 \050GCCALLBACKPROC\051&type::GCPointers,)
SH( \134)1620 W
30888 27829 MT
(type::__GCType\050\051 \051 :)
SH( \134)9180 W
16308 28867 MT
(0\051, \134)32940 W
15768 29905 MT
(\050type*\051gcalloc\050 GCBYTEStoWORDS\050 sizeof\050type\051 \051, __GCPointers \051\051 : \134)SH
15228 30943 MT
(this \051)SH
9288 33019 MT
(/* Storage for variable size objects is allocated by:  */)SH
9288 35095 MT
(#define GCALLOCV\050 type, bytes \051)
SH( \134)24840 W
10908 36133 MT
(this = \050\050this==0\051 ?)
SH( \134)29700 W
15228 37171 MT
(\050\050\050__GCPointers==0\051 ?)
SH( \134)24300 W
16308 38209 MT
(__GCPointers= \134)27540 W
20088 39247 MT
(gcregistercallback\050 \050GCCALLBACKPROC\051&type::GCPointers,)
SH( \134)1620 W
30888 40285 MT
(type::__GCType\050\051 \051 :)
SH( \134)9180 W
16308 41323 MT
(0\051, \134)32940 W
15768 42361 MT
(\050type*\051gcalloc\050 GCBYTEStoWORDS\050 bytes \051, __GCPointers \051\051 :)
SH( \134)3780 W
15228 43399 MT
(this \051)SH
9288 45475 MT
(/* The procedure gcpointer is called by the callback procedure with each)SH
10908 46513 MT
(pointer to a garbage collected object in the object.)SH
9288 47551 MT
(*/)SH
9288 49627 MT
(inline void  gcpointer\050 void*& ptr \051 { ptr = \050void*\051gcmove\050 \050GCP\051ptr \051; })SH
9288 51703 MT
(/* The following predicate returns 1 if the object is allocated where it will)SH
10908 52741 MT
(be scanned by the garbage collector, otherwise it returns 0.)SH
9288 53779 MT
(*/)SH
9288 55855 MT
(extern int  gcobject\050 void* ptr \051;)SH
9288 57931 MT
(/* The class gcheap is used to configure the heap as earlier described.  */)SH
9288 60007 MT
(class gcheap)
540 W( {)SH
10908 61045 MT
(public:)SH
13608 62083 MT
(gcheap\050 int minheapbytes,)SH
17928 63121 MT
(int maxheapbytes,)SH
17928 64159 MT
(int incheapbytes,)SH
17928 65197 MT
(int allpercent,)SH
17928 66235 MT
(int incpercent,)SH
17928 67273 MT
(int stablepercent,)SH
17928 68311 MT
(int flags \051;)SH
9288 69349 MT
(};)SH
9288 71425 MT
(const GCSTATS)
1080 W( = 1,)
SH( /*)
5940 W( Log garbage collector info */)SH
10 /Times-Roman AF
30811 75600 MT
(-66-)SH
ES
%%Page: 67 67
BS
0 SI
9 /Courier-Bold AF
13608 10183 MT
(GCMEM = 2,)
SH( /*)
7020 W( Log memory usage information */)SH
13608 11221 MT
(GCROOTLOG = 4,)
SH( /*)
4860 W( Log roots found in registers, stack and)SH
28188 12259 MT
(static area */)SH
13608 13297 MT
(GCHEAPROOTS = 8,)
SH( /*)
3780 W( Treat non-GC heap as roots */)SH
13608 14335 MT
(GCHEAPLOG = 16,)
SH( /*)
4320 W( Log possible non-GC heap roots */)SH
13608 15373 MT
(GCTSTOBJ = 32,)
SH( /*)
4860 W( Extensively test objects */)SH
13608 16411 MT
(GCGUESSPTRS = 64,)
SH( /*)
3240 W( Guess pointers in objects */)SH
13608 17449 MT
(GCZERO = 128,)
SH( /*)
5400 W( Zero free memory after GC */)SH
13608 18487 MT
(GCDEBUGLOG = 256,)
SH( /*)
3240 W( Log events internal to collector */)SH
13608 19525 MT
(GCHEAPMAP = 512,)
SH( /*)
3780 W( X-window display showing allocation */)SH
13608 20563 MT
(GCNOINC = 1024;)
SH( /*)
4320 W( Force non-incremental collection */)SH
9288 22639 MT
(#endif)SH
12 /Times-Bold AF
9288 27043 MT
(B.2 Header file for C++ version 2.0)SH
/Times-Italic SF
9288 30744 MT
(The following is the listing of)SH
/Times-Bold SF
23629 XM
(gcalloc-2.0.h)SH
/Times-Italic SF
(, the header file for C++ version 2.0.)SH
9 /Courier-Bold AF
9288 33927 MT
(/* This module implements garbage collected storage for C++ \050version 2.0\051)SH
10908 34965 MT
(programs using an incremental  version of the generational)SH
10908 36003 MT
(mostly-copying garbage collection algorithm.)SH
10908 38079 MT
(Copyright \050c\051 1991, 1989, Digital Equipment Corp.  All rights reserved.)SH
9288 39117 MT
(*/)SH
9288 41193 MT
(#ifndef GCALLOCH)SH
9288 42231 MT
(#define GCALLOCH 1)SH
9288 44307 MT
(/* Defining garbage collected classes)SH
10908 45345 MT
(----------------------------------)SH
10908 46383 MT
(Classes allocated in the garbage collected heap are denoted by the GCCLASS)SH
10908 47421 MT
(statement in their declaration.  For example, a class that holds a fixed)SH
10908 48459 MT
(length string, a reference count, and pointers to strings that are greater)SH
10908 49497 MT
(or lesser than it can be defined as follows:)SH
13608 51573 MT
(struct word {)540 W
17928 52611 MT
(word* lesser;)SH
17928 53649 MT
(word* greater;)SH
17928 54687 MT
(int count;)540 W
17928 55725 MT
(char symbol[)
540 W( 4 ];)SH
17928 56763 MT
(word\050 char* chars \051;)SH
17928 57801 MT
(GCCLASS\050 word \051;)SH
13608 58839 MT
(};)SH
13608 60915 MT
(word::word\050 char* chars \051)SH
13608 61953 MT
({)SH
17928 62991 MT
(lesser = NULL;)SH
17928 64029 MT
(greater = NULL;)SH
17928 65067 MT
(count = 1;)SH
17928 66105 MT
(strcpy\050 symbol, chars \051;)SH
13608 67143 MT
(})SH
13608 69219 MT
(void word::GCPointers\050)
540 W( \051  {)SH
17928 70257 MT
(gcpointer\050 lesser \051;)SH
17928 71295 MT
(gcpointer\050 greater \051;)SH
10 /Times-Roman AF
30811 75600 MT
(-67-)SH
ES
%%Page: 68 68
BS
0 SI
9 /Courier-Bold AF
13608 10183 MT
(})SH
10908 12259 MT
(The declaration GCCLASS informs the garbage collector that the type word)SH
10908 13297 MT
(is garbage collected.  Besides overloading new and delete for this type of)SH
10908 14335 MT
(object, it declares the user defined "pointer locator" method.)SH
10908 16411 MT
(The "pointer locator" method, word::GCPointers, is used by the garbage)SH
10908 17449 MT
(collector to identify all pointers in the object.  This is done by)SH
10908 18487 MT
(having the method call gcpointer with each pointer in the object that could)SH
10908 19525 MT
(point to a garbage collected object.  In order to correctly invoke pointer)SH
10908 20563 MT
(location methods for superclasses or class objects contained in the class,)SH
10908 21601 MT
(the following rules must be followed:)SH
13608 23677 MT
(1\051 for class C:P {}, C::GCPointers must contain P::GCPointers\050\051)SH
13608 24715 MT
(2\051 for class C { X x; }, C::GCPointers must contain x.GCPointers\050\051)SH
13608 25753 MT
(3\051 for class C { X* x; }, C::GCPointers must contain gcpointer\050 x \051)SH
10908 27829 MT
(Once the object has been defined, storage is allocated using the normal)SH
10908 28867 MT
(C++ mechanism:)SH
13608 30943 MT
(sp = new word\050 "dictionary" \051;)SH
10908 33019 MT
(Caveats)SH
10908 34057 MT
(-------)SH
10908 35095 MT
(When the garbage collector is invoked, it searches the processor's)SH
10908 36133 MT
(registers, the stack, and the program's static area for "hints" as to what)SH
10908 37171 MT
(storage is still accessible.  These hints are used to identify objects that)SH
10908 38209 MT
(are the "roots" and are to be left in place.  Objects that the roots point)SH
10908 39247 MT
(to will be moved to compact the heap.  Because of this:)SH
10908 41323 MT
(Objects allocated in the garbage collected heap MAY MOVE.)SH
10908 43399 MT
(Pointers to garbage collected objects MAY BE passed as arguments or stored)SH
10908 44437 MT
(in static storage.)SH
10908 46513 MT
(Pointers to garbage collected objects MAY NOT be stored in dynamically)SH
10908 47551 MT
(allocated objects that are not garbage collected, UNLESS one has specified)SH
10908 48589 MT
(the GCHEAPROOTS flag in a gcheap declaration.)SH
10908 50665 MT
(Pointers to garbage collected objects contained in garbage collected objects)SH
10908 51703 MT
(MUST always point outside the garbage collected heap or to a garbage)SH
10908 52741 MT
(collected object.)SH
10908 54817 MT
(Garbage collected arrays are not supported as arrays are always allocated by)SH
10908 55855 MT
(the global ::operator new\050\051 \050section 5.3.3, AT&T C++ Language System Release)SH
10908 56893 MT
(2.0\051.)SH
10908 58969 MT
(Variable size objects)SH
10908 60007 MT
(---------------------)SH
10908 62083 MT
(Garbage collected objects who's size is computed at runtime have their)SH
10908 63121 MT
(storage allocated by having the class' constructor method have a call to)SH
10908 64159 MT
(GCALLOV as its first statement.  GCALLOV takes two arguments, the name of)SH
10908 65197 MT
(the class and the number of bytes needed.  For example, a variable size)SH
10908 66235 MT
(word might use the constructor:)SH
13608 68311 MT
(word::word\050 char* chars \051)SH
13608 69349 MT
({)SH
17928 70387 MT
(GCALLOCV\050 word, <SOME FIXED SIZE>+strlen\050 chars \051 \051;)SH
17928 71425 MT
(lesser = NULL;)SH
10 /Times-Roman AF
30811 75600 MT
(-68-)SH
ES
%%Page: 69 69
BS
0 SI
9 /Courier-Bold AF
17928 10183 MT
(greater = NULL;)SH
17928 11221 MT
(count = 1;)SH
17928 12259 MT
(strcpy\050 symbol, chars \051;)SH
13608 13297 MT
(})SH
10908 15373 MT
(N.B. As)
540 W( GCALLOCV relies on the "assignment to this" anachronism, it is)SH
10908 16411 MT
(subject to change in future releases of the compiler.)SH
10908 18487 MT
(Sizing the heap)SH
10908 19525 MT
(---------------)SH
10908 20563 MT
(In order to make heap allocated storage as painless as possible, the user)SH
10908 21601 MT
(does not have to do anything to configure the heap.  This default is an)SH
10908 22639 MT
(initial heap of 1 megabyte that is expanded in 1 megabyte increments)SH
10908 23677 MT
(whenever the heap is more than 25% full after a total garbage collection.)SH
10908 24715 MT
(Total garbage collections are done when the heap is more than 35% full.)SH
10908 26791 MT
(However, if this is not the desired behavior, then it is possible to "tune")SH
10908 27829 MT
(the collector by including one or more global gcheap declarations in the)SH
10908 28867 MT
(program. In)
540 W( order to understand the parameters supplied in a gcheap)SH
10908 29905 MT
(declaration, one needs an overview of the storage allocation and garbage)SH
10908 30943 MT
(collection algorithm.)SH
10908 33019 MT
(Storage is allocated from the heap until 50% of the heap has been allocated.)SH
10908 34057 MT
(All accessible objects allocated since the last collection are retained and)SH
10908 35095 MT
(made a part of the stable set.  If less than <collect all percent> of the)SH
10908 36133 MT
(heap is allocated, then the collection process is finished.  Otherwise, the)SH
10908 37171 MT
(entire heap \050including the stable set\051 is garbage collected.  If the amount)SH
10908 38209 MT
(allocated following the total collection is greater than <increment heap)SH
10908 39247 MT
(percent>, then an attempt is made to expand the heap.)SH
13608 41323 MT
(gcheap <CC-identifier>\050)
540 W( <initial heap size>,)SH
27108 42361 MT
(<maximum heap size>,)SH
27108 43399 MT
(<increment size>,)SH
27108 44437 MT
(<collect all percent>,)SH
27108 45475 MT
(<increment heap percent>,)SH
27108 46513 MT
(<increment stable percent>,)SH
27108 47551 MT
(<heap log> \051)SH
10908 49627 MT
(The arguments are defined as follows:)SH
13608 51703 MT
(<CC-identifier> a)
5940 W( legal C++ identifier.)SH
13608 52741 MT
(<initial heap size>)
SH( initial)
3780 W( size of the heap in bytes.)SH
28188 53779 MT
(DEFAULT: 1048576.)SH
13608 54817 MT
(<maximum heap size>)
SH( maximum)
3780 W( heap size in bytes.)SH
28188 55855 MT
(DEFAULT: 2147483647.)SH
13608 56893 MT
(<increment size>)
SH( #)
5400 W( of bytes to add to each heap on each)SH
28188 57931 MT
(expansion. DEFAULT:)
540 W( 1048576.)SH
13608 58969 MT
(<collect all percent>)
SH( number)
2700 W( between 0 and 50 that is the percent)SH
28188 60007 MT
(allocated after a partial collection that will)SH
28188 61045 MT
(force a total collection.  A value of 0 will)SH
28188 62083 MT
(disable generational collection.  DEFAULT: 35.)SH
13608 63121 MT
(<increment heap percent>)
SH( number)
1080 W( between 0 and 50 that is the percent)SH
28188 64159 MT
(of newly allocated after a collection that)SH
28188 65197 MT
(will force heap expansion.  DEFAULT: 25.)SH
13608 66235 MT
(<increment stable percent> number between 0 and 50 that is the percent)SH
28188 67273 MT
(stable after a collection is initiated that)SH
28188 68311 MT
(will force heap expansion.  DEFAULT: 20.)SH
13608 69349 MT
(<flags> controls)
10260 W( logging on stderr, error checking,)SH
28188 70387 MT
(and root finding:)SH
29268 71425 MT
(& GCSTATS =  log collection statistics)SH
10 /Times-Roman AF
30811 75600 MT
(-69-)SH
ES
%%Page: 70 70
BS
0 SI
9 /Courier-Bold AF
29268 10183 MT
(& GCMEM =  log memory usage statistics)SH
29268 11221 MT
(& GCROOTLOG = log roots found in the stack,)SH
35748 12259 MT
(registers, and static area)SH
29268 13297 MT
(& GCHEAPROOTS = treat non-GC heap as roots)SH
29268 14335 MT
(& GCHEAPLOG = log possible roots in non-GC)SH
36828 15373 MT
(heap)SH
29268 16411 MT
(& GCTSTOBJ = perform object consistency)SH
36288 17449 MT
(tests)SH
29268 18487 MT
(& GCGUESSPTRS = guess number of pointers in)SH
37908 19525 MT
(objects)SH
29268 20563 MT
(& GCZERO = zero free memory after GC)SH
29268 21601 MT
(& GCDEBUGLOG = log events internal to the)SH
37368 22639 MT
(garbage collector)SH
29268 23677 MT
(& GCHEAPMAP = maintain memory allocation)SH
36828 24715 MT
(map)SH
28188 25753 MT
(DEFAULT: 0.)SH
10908 27829 MT
(When multiple gcheap declarations occur, the one that specifies the largest)SH
10908 28867 MT
(<maximum heap size> value will control all factors except flags which is)SH
10908 29905 MT
(the inclusive-or of all <flags> values.)SH
10908 31981 MT
(Configured values may be overridden by values supplied from environment)SH
10908 33019 MT
(variables. The)
540 W( user must set these variables in a consistent manner.  The)SH
10908 34057 MT
(variables and the values they set are:)SH
13608 36133 MT
(GCMINBYTES <initial)
4320 W( heap size>)SH
13608 37171 MT
(GCMAXBYTES <maximum)
4320 W( heap size>)SH
13608 38209 MT
(GCINCBYTES <increment)
4320 W( size>)SH
13608 39247 MT
(GCALLPERCENT <collect)
3240 W( all percent>)SH
13608 40285 MT
(GCINCPERCENT <increment)
3240 W( heap percent>)SH
13608 41323 MT
(GCSTABLEPERCENT <increment)
1620 W( stable percent>)SH
13608 42361 MT
(GCFLAGS <flags>)5940 W
10908 44437 MT
(If any of these variables are supplied, then the actual values used to)SH
10908 45475 MT
(configure the garbage collector are logged on stderr.)SH
10908 47551 MT
(Limits)SH
10908 48589 MT
(------)SH
10908 49627 MT
(No more than 2046 user defined garbage collected classes.)SH
10908 50665 MT
(Individual objects no larger than 4,193,788 bytes.)SH
9288 51703 MT
(*/)SH
13068 53779 MT
(/*******************************************************)SH
13608 54817 MT
(* C++ Garbage Collected Storage Interface Definitions *)SH
13608 55855 MT
(*******************************************************/)SH
9288 57931 MT
(/* Declarations for objects not directly used by the user of the interface. */)SH
9288 60007 MT
(typedef int  *GCP;)
SH( /*)
7020 W( Pointer to a garbage collected object. */)SH
9288 62083 MT
(extern GCP)
540 W( gcmove\050 GCP ptr \051;  /* Objects are moved by this function. */)SH
9288 64159 MT
(extern void  gccollect\050\051;)
SH( /*)
3240 W( Invokes the collector. */)SH
9288 66235 MT
(typedef void \050*GCCALLBACKPROC\051\050 GCP \051;)SH
26568 67273 MT
(/* Callback procedure type */)SH
9288 69349 MT
(extern int  gcregistercallback\050 GCCALLBACKPROC pointers, char* type \051;)SH
26568 70387 MT
(/* Registers a callback method */)SH
10 /Times-Roman AF
30811 75600 MT
(-70-)SH
ES
%%Page: 71 71
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
(/* The following define is used to compute the number of words needed for)SH
10908 11221 MT
(an object.  The count includes 1 word for the header.  The defines are)SH
10908 12259 MT
(used inside GCCLASS and GCALLOCV.)SH
9288 13297 MT
(*/)SH
9288 15373 MT
(#define GCBYTEStoWORDS\050 x \051 \050\050\050x\051+7\051>>2\051)
SH( /*)
3780 W( Word align */)SH
9288 17449 MT
(extern GCP)
540 W( gcalloc\050 int words, int callback \051; /* Actual space allocator */)SH
9288 19525 MT
(/* User defined objects use the following definition to define the class)SH
10908 20563 MT
(as garbage collected.  It defines the pointer method, a static variable)SH
10908 21601 MT
(to hold the index into the garbage collector's table of methods, and storage)SH
10908 22639 MT
(allocation methods.)SH
9288 23677 MT
(*/)SH
9288 25753 MT
(#define GCCLASS\050 type \051)
SH( \134)29160 W
13608 26791 MT
(void* operator new\050 unsigned int bytes \051  {)
SH( \134)14040 W
15228 27829 MT
(if \050__GCPointers)
540 W( == 0\051)
SH( \134)23220 W
16848 28867 MT
(__GCPointers =)
SH( \134)26460 W
20088 29905 MT
(gcregistercallback\050 \050GCCALLBACKPROC\051&type::GCPointers,)
SH( \134)1620 W
30888 30943 MT
(#type \051;)
SH( \134)15660 W
15228 31981 MT
(return \050void*\051gcalloc\050 GCBYTEStoWORDS\050 bytes \051, __GCPointers \051;)
SH( \134)1620 W
13608 33019 MT
(} \134)36720 W
13608 34057 MT
(void operator delete\050 void* \051 {})
SH( \134)19980 W
13608 35095 MT
(void GCPointers\050\051;)
540 W( \134)27000 W
13608 36133 MT
(static int  __GCPointers)SH
9288 38209 MT
(/* GCPointer methods move pointers by calling the procedure gcpointer.  It is)SH
10908 39247 MT
(actually a define enclosing an inline procedure as C++ 2.0 does not)SH
10908 40285 MT
(correctly compile void*& arguments.)SH
9288 41323 MT
(*/)SH
9288 43399 MT
(#define gcpointer\050)
540 W( x \051 _gcpointer\050 &x \051)SH
9288 45475 MT
(inline void  _gcpointer\050 void* ptr \051{ *\050\050GCP*\051ptr\051 = gcmove\050 *\050\050GCP*\051ptr\051 \051; })SH
9288 47551 MT
(/* Storage for variable size objects is allocated by the following mechanism)SH
10908 48589 MT
(that depends upon ASSIGNMENT TO THIS, i.e. this feature might not work in)SH
10908 49627 MT
(the future.)SH
9288 50665 MT
(*/)SH
9288 52741 MT
(#define GCALLOCV\050 type, bytes \051)
SH( \134)24840 W
10908 53779 MT
(this = \050\050this==0\051 ?)
SH( \134)29700 W
15228 54817 MT
(\050\050\050__GCPointers==0\051 ?)
SH( \134)24300 W
16308 55855 MT
(__GCPointers= \134)27540 W
20088 56893 MT
(gcregistercallback\050 \050GCCALLBACKPROC\051&type::GCPointers,)
SH( \134)1620 W
30888 57931 MT
(#type \051 :)
SH( \134)15120 W
16308 58969 MT
(0\051, \134)32940 W
15768 60007 MT
(\050type*\051gcalloc\050 GCBYTEStoWORDS\050 bytes \051, __GCPointers \051\051 :)
SH( \134)3780 W
15228 61045 MT
(this \051)SH
9288 63121 MT
(/* The class gcheap is used to configure the heap as earlier described.  */)SH
9288 65197 MT
(class gcheap)
540 W( {)SH
10908 66235 MT
(public:)SH
13608 67273 MT
(gcheap\050 int minheapbytes,)SH
17928 68311 MT
(int maxheapbytes,)SH
17928 69349 MT
(int incheapbytes,)SH
17928 70387 MT
(int allpercent,)SH
17928 71425 MT
(int incpercent,)SH
10 /Times-Roman AF
30811 75600 MT
(-71-)SH
ES
%%Page: 72 72
BS
0 SI
9 /Courier-Bold AF
17928 10183 MT
(int stablepercent,)SH
17928 11221 MT
(int flags \051;)SH
9288 12259 MT
(};)SH
9288 14335 MT
(const GCSTATS)
1080 W( = 1,)
SH( /*)
5940 W( Log garbage collector info */)SH
13608 15373 MT
(GCMEM = 2,)
SH( /*)
7020 W( Log memory usage information */)SH
13608 16411 MT
(GCROOTLOG = 4,)
SH( /*)
4860 W( Log roots found in registers, stack and)SH
28188 17449 MT
(static area */)SH
13608 18487 MT
(GCHEAPROOTS = 8,)
SH( /*)
3780 W( Treat non-GC heap as roots */)SH
13608 19525 MT
(GCHEAPLOG = 16,)
SH( /*)
4320 W( Log possible non-GC heap roots */)SH
13608 20563 MT
(GCTSTOBJ = 32,)
SH( /*)
4860 W( Extensively test objects */)SH
13608 21601 MT
(GCGUESSPTRS = 64,)
SH( /*)
3240 W( Guess pointers in objects */)SH
13608 22639 MT
(GCZERO = 128,)
SH( /*)
5400 W( Zero free memory after GC */)SH
13608 23677 MT
(GCDEBUGLOG = 256,)
SH( /*)
3240 W( Log events internal to collector */)SH
13608 24715 MT
(GCHEAPMAP = 512,)
SH( /*)
3780 W( X-window display showing allocation */)SH
13608 25753 MT
(GCNOINC = 1024;)
SH( /*)
4320 W( Force non-incremental collection */)SH
9288 26791 MT
(#endif)SH
12 /Times-Bold AF
9288 31195 MT
(B.3 Program file for the incremental collector)SH
/Times-Italic SF
9288 34896 MT
(The following is the listing of the incremental, generational mostly-copying)
420 W( garbage)421 W
9288 36616 MT
(collector for C++.  It is compatible with C++ versions 1.2 and 2.0.)SH
9 /Courier-Bold AF
9288 39794 MT
(/* This module implements garbage collected storage for C++ programs using)SH
10908 40832 MT
(an incremental version of the generational "mostly-copying" garbage)SH
10908 41870 MT
(collection algorithm.  The implementation is compatible with AT&T C++)SH
10908 42908 MT
(Language System Releases 1.2 and 2.0.)SH
10908 44984 MT
(Copyright \050c\051 1991, 1989, Digital Equipment Corp.  All rights reserved.)SH
10908 47060 MT
(For a discussion of the interface, see gcalloc-1.2.h \050for C++ version)SH
10908 48098 MT
(1.2\051 or gcalloc-2.0.h file \050for C++ version 2.0\051.)SH
10908 50174 MT
(For a discussion of the mostly-copying garbage collection)SH
10908 51212 MT
(algorithm, see)SH
10908 53288 MT
(Joel Bartlett,)SH
10908 54326 MT
("Compacting Garbage Collection with Ambiguous Roots",)SH
10908 55364 MT
(WRL Research Report 88/2, February 1988.)SH
10908 57440 MT
(Joel Bartlett,)SH
10908 58478 MT
("Mostly-Copying Garbage Collection Picks Up Generations and C++",)SH
10908 59516 MT
(WRL Technical Note TN-12, October 1989.)SH
10908 61592 MT
(For a discussion of the incremental, generational mostly-copying)SH
10908 62630 MT
(collection algorithm, see)SH
10908 64706 MT
(G. May Yip,)SH
10908 65744 MT
("Incremental, Generational Copying Garbage Collection in)SH
10908 66782 MT
(Uncooperative Environments",)SH
10908 67820 MT
(MIT SM Thesis, June 1991.)SH
9288 68858 MT
(*/)SH
9288 70934 MT
(/* Default is C++ Version 1.2 */)SH
10 /Times-Roman AF
30811 75600 MT
(-72-)SH
ES
%%Page: 73 73
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
(#if \050!COMPILER_VERSION_1_2 & !COMPILER_VERSION_2_0\051)SH
9288 11221 MT
(#define COMPILER_VERSION_1_2  1)SH
9288 12259 MT
(#endif)SH
9288 14335 MT
(/* External definitions */)SH
9288 16411 MT
(#include <stdio.h>)
SH( /*)
2700 W( Streams are not used as they might not be)SH
23868 17449 MT
(initialized when needed. */)SH
9288 18487 MT
(#include <sys/ioctl.h>)SH
9288 19525 MT
(#include <sys/time.h>)SH
9288 20563 MT
(#include <machine/param.h>)SH
9288 21601 MT
(#include <sys/mman.h>)SH
9288 22639 MT
(#include <sys/types.h>)SH
9288 23677 MT
(#include <signal.h>)SH
9288 25753 MT
(#ifdef COMPILER_VERSION_2_0)SH
9288 27829 MT
(#include <libc.h>)SH
9288 28867 MT
(#include <osfcn.h>)SH
9288 29905 MT
(#include <stdlib.h>)SH
9288 31981 MT
(#endif)SH
9288 34057 MT
(#ifdef COMPILER_VERSION_1_2)SH
9288 35095 MT
(extern char*  getenv\050 char* name \051;)SH
9288 37171 MT
(extern unsigned*  sbrk\050 int size \051;)SH
9288 39247 MT
(extern void  bzero\050 char* string, int length \051;)SH
9288 41323 MT
(extern free\050)
540 W( char* obj \051;)SH
9288 43399 MT
(extern pipe\050)
540 W( int filedes[ 2 ] \051;)SH
9288 45475 MT
(extern fork\050\051;)540 W
9288 47551 MT
(extern close\050)
540 W( int d \051;)SH
9288 49627 MT
(extern dup\050)
540 W( int d \051;)SH
9288 51703 MT
(extern select\050)
540 W( int nfds, int *readfds, int *writefds, int *execptfds,)SH
17928 52741 MT
(struct timeval *timeout\051;)SH
9288 54817 MT
(extern execlp\050char)
540 W( *file, char *arg0 ... \051;)SH
9288 56893 MT
(extern int  getpagesize\050\051;)SH
9288 58969 MT
(extern int  mprotect\050 void* addr, int numbytes, int protection\051;)SH
9288 60007 MT
(#endif)SH
9288 62083 MT
(#ifdef COMPILER_VERSION_2_0)SH
9288 63121 MT
(extern "C"  void  bzero\050 char* string, int length \051;)SH
9288 65197 MT
(extern "C"  select\050 int nfds, int *readfds, int *writefds, int *execptfds,)SH
20088 66235 MT
(struct timeval *timeout\051;)SH
9288 68311 MT
(extern "C"  getpagesize\050\051;)SH
9288 70387 MT
(extern "C"  mprotect\050 void* addr, int numbytes, int protection\051;)SH
9288 71425 MT
(#endif)SH
10 /Times-Roman AF
30811 75600 MT
(-73-)SH
ES
%%Page: 74 74
BS
0 SI
9 /Courier-Bold AF
13068 10183 MT
(/***********************************)SH
13608 11221 MT
(* Processor Dependent Definitions *)SH
13608 12259 MT
(***********************************/)SH
9288 14335 MT
(/* MIPS */)SH
9288 16411 MT
(#ifdef mips)SH
9288 18487 MT
(#include <machine/vmparam.h>)SH
9288 20563 MT
(/* Assume stack alignment on 32-bit words. */)SH
9288 22639 MT
(#define STACKINC 4)540 W
9288 24715 MT
(/* Need to save and examine registers s0-s8. */)SH
9288 26791 MT
(#define REGISTER_COUNT)
540 W( 9)SH
9288 27829 MT
(#ifdef COMPILER_VERSION_1_2)SH
9288 28867 MT
(extern unsigned*  gcregisters\050 unsigned* registers \051;)SH
9288 29905 MT
(#endif)SH
9288 30943 MT
(#ifdef COMPILER_VERSION_2_0)SH
9288 31981 MT
(extern "C" unsigned*  gcregisters\050 unsigned* registers \051;)SH
9288 33019 MT
(#endif)SH
9288 35095 MT
(/* Static area bounds */)SH
9288 37171 MT
(extern unsigned  end;)SH
9288 38209 MT
(#define STATIC_0 \050\050unsigned*\051USRDATA\051)SH
9288 39247 MT
(#define STATIC_1 \050&end\051)SH
9288 41323 MT
(/* Objects must be double aligned */)SH
9288 43399 MT
(#ifndef MISALIGN)SH
9288 44437 MT
(#define DOUBLE_ALIGN 1)SH
9288 45475 MT
(#endif)SH
9288 47551 MT
(/* Physical page size: phys_shift = log[base 2]\050 size of a physical page \051 */)SH
9288 49627 MT
(#define phys_shift 12)SH
9288 51703 MT
(#endif /*)
540 W( MIPS */)SH
9288 54817 MT
(/* VAX */)SH
9288 56893 MT
(#ifdef vax)SH
9288 58969 MT
(#include <machine/vmparam.h>)SH
9288 61045 MT
(/* Assume stack alignment on 32-bit words. */)SH
9288 63121 MT
(#define STACKINC 4)540 W
9288 65197 MT
(/* Need to save and examine registers 2-10. */)SH
9288 67273 MT
(#define REGISTER_COUNT)
540 W( 10)SH
9288 68311 MT
(#ifdef COMPILER_VERSION_1_2)SH
9288 69349 MT
(extern unsigned*  gcregisters\050 unsigned* registers \051;)SH
9288 70387 MT
(#endif)SH
9288 71425 MT
(#ifdef COMPILER_VERSION_2_0)SH
10 /Times-Roman AF
30811 75600 MT
(-74-)SH
ES
%%Page: 75 75
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
(extern "C" unsigned*  gcregisters\050 unsigned* registers \051;)SH
9288 11221 MT
(#endif)SH
9288 13297 MT
(/* Static area bounds */)SH
9288 15373 MT
(extern unsigned  etext, end;)SH
9288 16411 MT
(#define STATIC_0 \050\050unsigned*\051\050\050\050\050\050int\051&etext\051+NBPG-1\051/NBPG\051*NBPG\051\051)SH
9288 17449 MT
(#define STATIC_1 \050&end\051)SH
9288 19525 MT
(/* Physical page size: phys_shift = log[base 2]\050 size of a physical page \051 */)SH
9288 21601 MT
(#define phys_shift 10)SH
9288 23677 MT
(#endif /*)
540 W( VAX */)SH
9288 26791 MT
(/* Bottom of stack is computed by the constructor for the global variable)SH
10908 27829 MT
(sb.)SH
9288 28867 MT
(*/)SH
9288 30943 MT
(static struct stackbase {)SH
13608 31981 MT
(unsigned address;)540 W
13608 33019 MT
(stackbase\050 int i \051 { address = \050\050\050unsigned\051&i+NBPG-1\051/NBPG\051*NBPG; })SH
9288 34057 MT
(};)SH
9288 36133 MT
(static stackbase sb\050)
540 W( 0 \051;)SH
9288 38209 MT
(#define STACKBASE)
540 W( \050sb.address\051)SH
13068 41323 MT
(/**************************************)SH
13608 42361 MT
(* Garbage Collected Heap Definitions *)SH
13608 43399 MT
(**************************************/)SH
9288 45475 MT
(/* The heap consists of a discontiguous set of memory blocks, called)SH
10908 46513 MT
(heap pages, and each heap page is PAGEBYTES long.  There are two)SH
10908 47551 MT
(restriction on the size of a heap page: \050i\051 PAGEBYTES must be)SH
10908 48589 MT
(*smaller* than the virtual memory page size, and \050ii\051 the virtual)SH
10908 49627 MT
(memory page size \050in bytes\051 must be a multiple of PAGEBYTES.)SH
10908 51703 MT
(Terminology: for the purpose of documentation, "page" and "heap page")SH
10908 52741 MT
(both all refer to a PAGEBYTES-long memory in the heap, while)SH
10908 53779 MT
("physical page" refers to a virtual memory page.  Furthermore, whenever)SH
10908 54817 MT
(the word "page" is encountered, it is assumed to mean a page in the heap,)SH
10908 55855 MT
(unless when modified explicitly, as in "a page in the heap must be smaller)SH
10908 56893 MT
(than a physical page.")SH
9288 57931 MT
(*/)SH
9288 60007 MT
(static int)
540 W( firstheappage,)
SH( /*)
2160 W( Page # of first heap page */)SH
15768 61045 MT
(lastheappage, /*)
2700 W( Page # of last heap page */)SH
15768 62083 MT
(heappages, /*)
4320 W( # of pages in the heap */)SH
15768 63121 MT
(heapspanpages, /*)
2160 W( # of pages that span the heap */)SH
15768 64159 MT
(physspanpages, /*)
2160 W( # of physical pages that span the heap */)SH
15768 65197 MT
(curr_freewords, /*)
1620 W( # words left on the current page */)SH
15768 66235 MT
(*curr_freep, /*)
3240 W( Ptr to the first free word on the current)SH
27648 67273 MT
(page */)SH
15768 68311 MT
(forw_freewords, /*)
1620 W( # words left on the forward page */)SH
15768 69349 MT
(*forw_freep, /*)
3240 W( Ptr to the first free word on the forward)SH
27648 70387 MT
(page */)SH
15768 71425 MT
(firstword_to_scan, /* Address of first word to be scanned */)SH
10 /Times-Roman AF
30811 75600 MT
(-75-)SH
ES
%%Page: 76 76
BS
0 SI
9 /Courier-Bold AF
15768 10183 MT
(lastword_to_scan, /*)
540 W( Address of last word to be scanned */)SH
15768 11221 MT
(*scanp, /*)
5940 W( Pointer to the object being scanned */)SH
15768 12259 MT
(allocatedpages, /*)
1620 W( # total number of pages allocated */)SH
15768 13297 MT
(currentpages, /*)
2700 W( # of pages allocated for current space */)SH
15768 14335 MT
(forwardedpages, /*)
1620 W( # of pages in the stable set \050forwarded\051 */)SH
15768 15373 MT
(protectedpages, /*)
1620 W( # of physical pages being protected */)SH
15768 16411 MT
(curr_freepage, /*)
2160 W( First free page in current space */)SH
15768 17449 MT
(forw_freepage, /*)
2160 W( First free page in forward space */)SH
15768 18487 MT
(old_forw_freepage, /* Previous value of forw_freepage */)SH
15768 19525 MT
(*space, /*)
5940 W( Space number for each page */)SH
15768 20563 MT
(*plink, /*)
5940 W( Page link for each page */)SH
15768 21601 MT
(*type, /*)
6480 W( Type of object allocated on the page */)SH
15768 22639 MT
(*protect, /*)
4860 W( protect map for physical pages */)SH
15768 23677 MT
(*firstword, /*)
3780 W( Bitmap of 1st words of user objects */)SH
15768 24715 MT
(queue_head, /*)
3780 W( Head of list of stable set of pages */)SH
15768 25753 MT
(queue_tail, /*)
3780 W( Tail of list of stable set of pages */)SH
15768 26791 MT
(curr_space, /*)
3780 W( Current space number */)SH
15768 27829 MT
(prev_space, /*)
3780 W( Previous space number */)SH
15768 28867 MT
(forw_space; /*)
3780 W( Forward space number */)SH
9288 31981 MT
(/* During incremental collection, heap pages can be in one of the)SH
10908 33019 MT
(following states, depending on their page generation \050i.e. space\051)SH
10908 34057 MT
(number:)SH
10908 36133 MT
(\050*\051 NEWLY ALLOCATED - for recently allocated pages;)SH
22788 37171 MT
(space[page] == curr_space.)SH
10908 38209 MT
(\050*\051 PREVIOUSLY ALLOCATED - for pages that were allocated before)SH
25488 39247 MT
(incremental collection was initiated;)SH
25488 40285 MT
(space[ page ] == prev_space.)SH
10908 41323 MT
(\050*\051 FORWARDED - for pages containing forwarded objects;)SH
19548 42361 MT
(space[ page ] == forw_space.)SH
10908 43399 MT
(\050*\051 FREE - free pages that could be allocated, either as newly allocated)SH
16848 44437 MT
(pages or forwarded pages;)SH
16848 45475 MT
(space[ page ] != curr_space && space[ page ] != prev_space &&)SH
16848 46513 MT
(space[ page ] != forw_space.)SH
9288 47551 MT
(*/)SH
9288 49627 MT
(/* Page types */)SH
9288 51703 MT
(#define OBJECT 0)SH
9288 52741 MT
(#define CONTINUED 1)SH
9288 54817 MT
(/* PAGEBYTES controls the number of bytes/heap page */)SH
9288 56893 MT
(#define PAGEBYTES 512)SH
9288 57931 MT
(#define PAGEWORDS \050PAGEBYTES/sizeof\050int\051\051)SH
9288 58969 MT
(#define WORDBYTES \050sizeof\050int\051\051)SH
9288 60007 MT
(#define HEAPPERCENT\050 x \051 \050\050\050x\051*100\051/heappages\051)SH
9288 62083 MT
(/* The following variable holds the capacity of a physical page,)SH
10908 63121 MT
(i.e. # of heap pages/physical page.)SH
9828 64159 MT
(*/)SH
9288 65197 MT
(static int  phys_cap;)SH
9288 67273 MT
(/* PHYS_PAGEBYTESAES controls the nubmer of bytes/physical page */)SH
9288 69349 MT
(#define PHYS_PAGEBYTES \050phys_cap*PAGEBYTES\051)SH
9288 70387 MT
(#define PHYS_PAGEWORDS \050PHYS_PAGEBYTES/sizeof\050int\051\051)SH
10 /Times-Roman AF
30811 75600 MT
(-76-)SH
ES
%%Page: 77 77
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
(/* Number of pages reserved for forwarded objects in the "forward region" */)SH
9288 11221 MT
(#define RESERVEDPAGES  \050heappages/5\051)SH
9288 13297 MT
(/* The physical page mask can be bitwise ANDed with an address to obtain)SH
10908 14335 MT
(the corresponding starting address of the physical page.)SH
9288 15373 MT
(*/)SH
9288 16411 MT
(static int  phys_pagemask;)SH
9288 18487 MT
(/* Similarly, the heap page mask can be bitwise ANDed with an address to)SH
10908 19525 MT
(obtain the corresponding starting address of the heap page.)SH
9288 20563 MT
(*/)SH
9288 21601 MT
(static int  heap_pagemask;)SH
9288 23677 MT
(/* Page number <--> pointer conversion is done by the following defines */)SH
9288 25753 MT
(#define PAGE_to_GCP\050 p \051 \050\050GCP\051\050\050p\051*PAGEBYTES\051\051)SH
9288 26791 MT
(#define GCP_to_PAGE\050 p \051 \050\050\050int\051\050p\051\051/PAGEBYTES\051)SH
9288 28867 MT
(/* GC Pointer, ADDRess, PAGE number, and Physical Page ADDRess conversion */)SH
9288 30943 MT
(#define GCP_to_PPADDR\050 gcp \051)
SH( \050int\050gcp\051)
2160 W( & phys_pagemask\051)SH
9288 31981 MT
(#define ADDR_to_PAGE\050 addr \051)
SH( \050\050\050addr\051)
2160 W( & heap_pagemask\051/PAGEBYTES\051)SH
9288 33019 MT
(#define PAGE_to_ADDR\050 page \051)
SH( \050\050page\051*PAGEBYTES\051)2160 W
9288 34057 MT
(#define PAGE_to_PPADDR\050 page \051)
SH( \050\050page\051*PAGEBYTES)
1080 W( & phys_pagemask\051)SH
9288 36133 MT
(/* Space values */)SH
9288 38209 MT
(#define UNALLOCATEDPAGE -2)SH
9288 39247 MT
(#define FREEPAGE 1;)SH
9288 40285 MT
(#define STABLE\050 x \051)
SH( \050\050~space[)
2160 W( \050x\051 ]\051 & 1\051)SH
9288 41323 MT
(#define UNSTABLE\050 x \051)
SH( \050space[)
1080 W( \050x\051 ] & 1\051)SH
9288 44437 MT
(/* Objects that are allocated in the heap have a one word header.  The form)SH
10908 45475 MT
(of the header is:)SH
14148 47551 MT
(31 21)
5400 W( 20)
SH( 1)
6480 W( 0)SH
13608 48589 MT
(+---------------+----------------+-+)SH
13608 49627 MT
(| callback indx | # words in obj |1|)SH
13608 50665 MT
(+---------------+----------------+-+)SH
13608 51703 MT
(| user)
4860 W( data)
SH( |)
7560 W( <--)
540 W( user data starts here.)SH
21708 52741 MT
(.)SH
21708 53779 MT
(.)SH
21708 54817 MT
(.)SH
13608 55855 MT
(| |)17820 W
13608 56893 MT
(+----------------------------------+)SH
10908 58969 MT
(The number of words in the object count INCLUDES one word for the header.)SH
10908 61045 MT
(When an object is forwarded, the header is replaced by the pointer to)SH
10908 62083 MT
(the new object that will have bit 0 equal to 0.)SH
9288 63121 MT
(*/)SH
9288 65197 MT
(#define MAKE_CALLBACK\050 index \051 \050\050index\051<<21 | 1\051)SH
9288 66235 MT
(#define MAKE_HEADER\050 words, callback \051 \050\050words\051<<1 | \050callback\051\051)SH
9288 67273 MT
(#define FORWARDED\050 header \051 \050\050\050header\051 & 1\051 == 0\051)SH
9288 68311 MT
(#define HEADER_CALLBACK\050 header \051 \050\050header\051>>21 & 0x7FF\051)SH
9288 69349 MT
(#define HEADER_WORDS\050 header \051 \050\050header\051>>1 &0xFFFFF \051)SH
9288 70387 MT
(#define HEADER_BYTES\050 header \051 \050\050\050header\051>>1 & 0xFFFFF\051*WORDBYTES\051)SH
9288 71425 MT
(#ifdef DOUBLE_ALIGN)SH
10 /Times-Roman AF
30811 75600 MT
(-77-)SH
ES
%%Page: 78 78
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
(#define ONEPAGEOBJ_WORDS \050PAGEWORDS-1\051)SH
9288 11221 MT
(#define HEADER_PAGES\050 header \051 \050\050HEADER_WORDS\050 header \051+PAGEWORDS\051/PAGEWORDS\051)SH
9288 12259 MT
(#else)SH
9288 13297 MT
(#define ONEPAGEOBJ_WORDS PAGEWORDS)SH
9288 14335 MT
(#define HEADER_PAGES\050 header \051 \050\050HEADER_WORDS\050 header \051+PAGEWORDS-1\051/PAGEWORDS\051)SH
9288 15373 MT
(#endif)SH
9288 16411 MT
(#define MAX_HEADER_PAGES \0500xFFFFF/PAGEWORDS\051)
SH( /*)
1620 W( 8191 =  4,193,792 bytes */)SH
9288 17449 MT
(#define MAX_HEADER_CALLBACK 0x7FF)
SH( /*)
7560 W( 2047 */)SH
9288 19525 MT
(/* The first word of user objects is noted in the firstword bit map.  This)SH
10908 20563 MT
(allows gcmove to rapidly detect a derived pointer and convert it into an)SH
10908 21601 MT
(object and an offset.)SH
9288 22639 MT
(*/)SH
9288 24715 MT
(#define BIT_BYTES \050PAGEWORDS/8\051)SH
9288 25753 MT
(#define BIT_WORDS \050PAGEWORDS/32\051)SH
9288 26791 MT
(#define ISA_FIRSTWORD\050 p \051 \050firstword[ \050\050int\051p\051/\050PAGEBYTES/BIT_WORDS\051 ] &)
SH( \134)1080 W
24408 27829 MT
(1<<\050 \050\050int\051p\051>>2 & 0x1F \051\051)SH
9288 28867 MT
(#define SET_FIRSTWORD\050 p \051 \050firstword[ \050\050int\051p\051/\050PAGEBYTES/BIT_WORDS\051 ] |=  \134)SH
24408 29905 MT
(1<<\050 \050\050int\051p\051>>2 & 0x1F \051\051)SH
9288 31981 MT
(/* There is an option to draw the heap map using the EZX program.)SH
10908 33019 MT
(Objects are drawn on 'display'.)SH
9288 34057 MT
(*/)SH
9288 35095 MT
(static FILE*  display;)SH
13068 38209 MT
(/**********************************)SH
13608 39247 MT
(* Exported Interface Definitions *)SH
13608 40285 MT
(**********************************/)SH
9288 42361 MT
(#ifdef COMPILER_VERSION_1_2)SH
9288 43399 MT
(#include "gcalloc-1.2.h")SH
9288 44437 MT
(#endif)SH
9288 45475 MT
(#ifdef COMPILER_VERSION_2_0)SH
9288 46513 MT
(#include "gcalloc-2.0.h")SH
9288 47551 MT
(#endif)SH
9288 49627 MT
(/* An instance of the type gcheap is created to configure the size of the)SH
10908 50665 MT
(initial heap, the expansion increment, the maximum size of the heap, the)SH
10908 51703 MT
(allocation percentage to force a total collection, the allocation)SH
10908 52741 MT
(percentage to force heap expansion, and garbage collection options.)SH
9288 53779 MT
(*/)SH
9288 55855 MT
(/* Default heap configuration */)SH
9288 57931 MT
(const int  GCMINBYTES = 1048576,)
SH( /*)
1080 W( # of bytes of initial heap */)SH
15228 58969 MT
(GCMAXBYTES = 2147483647,/* # of bytes of the final heap */)SH
15228 60007 MT
(GCINCBYTES = 1048576,)
SH( /*)
1080 W( # of bytes of each increment */)SH
15228 61045 MT
(GCALLPERCENT = 35,)
SH( /*)
2700 W( % allocated to force total)SH
29808 62083 MT
(collection */)SH
15228 63121 MT
(GCINCPERCENT =)
540 W( 25,)
SH( /*)
2160 W( % NEWLY allocated to force expansion */)SH
15228 64159 MT
(GCSTABLEPERCENT = 20,)
SH( /*)
1080 W( % stable to force expansion */)SH
15228 65197 MT
(GCFLAGS = 0;)
SH( /*)
5940 W( option flags */)SH
9288 67273 MT
(/* Actual heap configuration */)SH
9288 69349 MT
(static int  gcminbytes = GCMINBYTES,)
SH( /*)
1620 W( # of bytes of initial heap */)SH
15768 70387 MT
(gcmaxbytes = GCMAXBYTES,)
SH( /*)
1620 W( # of bytes of the final heap */)SH
15768 71425 MT
(gcincbytes = GCINCBYTES,)
SH( /*)
1620 W( # of bytes of each increment */)SH
10 /Times-Roman AF
30811 75600 MT
(-78-)SH
ES
%%Page: 79 79
BS
0 SI
9 /Courier-Bold AF
15768 10183 MT
(gcallpercent = GCALLPERCENT,/* % allocated to force total)SH
32508 11221 MT
(collection */)SH
15768 12259 MT
(gcincpercent = GCINCPERCENT,/* % NEWLY allocated to force)SH
32508 13297 MT
(expansion */)SH
15768 14335 MT
(gcstablepercent=GCSTABLEPERCENT,/* %stable to force expansion */)SH
15768 15373 MT
(gcflags = GCFLAGS,)
SH( /*)
4860 W( option flags */)SH
15768 16411 MT
(gcdefaults = 1,)
SH( /*)
6480 W( default setting in force */)SH
15768 17449 MT
(gcheapcreated = 0;)
SH( /*)
4860 W( boolean indicating heap created */)SH
9288 19525 MT
(gcheap::gcheap\050 int minheapbytes,)SH
17928 20563 MT
(int maxheapbytes,)SH
17928 21601 MT
(int incheapbytes,)SH
17928 22639 MT
(int allpercent,)SH
17928 23677 MT
(int incpercent,)SH
17928 24715 MT
(int stablepercent,)SH
17928 25753 MT
(int flags \051  {)SH
13608 27829 MT
(if \050gcheapcreated)
540 W( == 0  &&  minheapbytes > 0  &&)SH
16308 28867 MT
(\050gcdefaults || maxheapbytes >= gcmaxbytes\051\051  {)SH
15228 29905 MT
(gcdefaults = 0;)SH
15228 30943 MT
(gcminbytes = minheapbytes;)SH
15228 31981 MT
(gcmaxbytes = maxheapbytes;)SH
15228 33019 MT
(gcincbytes = incheapbytes;)SH
15228 34057 MT
(gcallpercent = allpercent;)SH
15228 35095 MT
(gcincpercent = incpercent;)SH
15228 36133 MT
(gcstablepercent = stablepercent;)SH
15228 37171 MT
(if \050gcminbytes)
540 W( < 4*PAGEBYTES\051  gcminbytes = 4*PAGEBYTES;)SH
15228 38209 MT
(if \050gcmaxbytes)
540 W( < gcminbytes\051  gcmaxbytes = gcminbytes;)SH
15228 39247 MT
(if \050gcallpercent)
540 W( < 0  ||  gcallpercent > 50\051)SH
16848 40285 MT
(gcallpercent = GCALLPERCENT;)SH
15228 41323 MT
(if \050gcincpercent)
540 W( < 0  ||  gcincpercent > 50\051)SH
16848 42361 MT
(gcincpercent = GCINCPERCENT;)SH
15228 43399 MT
(if \050gcstablepercent)
540 W( < 0  ||  gcstablepercent > 50\051)SH
16848 44437 MT
(gcstablepercent = GCSTABLEPERCENT;)SH
13608 45475 MT
(})SH
13608 46513 MT
(gcflags = gcflags | flags;)SH
9288 47551 MT
(})SH
9288 50665 MT
(/* The following structure contains the callback procedures registered with)SH
10908 51703 MT
(the garbage collector.  It is allocated from the non-garbage collected)SH
10908 52741 MT
(heap.)SH
9288 53779 MT
(*/)SH
9288 55855 MT
(static int  callbacks_count = 0;)SH
9288 56893 MT
(static int  callbacks_size = 0;)SH
9288 57931 MT
(static const int  callbacks_inc = 100;)SH
9288 60007 MT
(static struct  callback_struct  {)SH
13608 61045 MT
(GCCALLBACKPROC proc;)
540 W( /*)
1080 W( GCPointers method */)SH
13608 62083 MT
(char* type;)
540 W( /*)
5940 W( Type name */)SH
13608 63121 MT
(int number;)
540 W( /*)
5940 W( Number of the type in heap */)SH
13608 64159 MT
(int bytes;)
540 W( /*)
6480 W( Number of bytes of the type in heap */)SH
9288 65197 MT
(} *callbacks;)540 W
9288 67273 MT
(/* Freespace objects have a null callback that stored in callbacks[ 0 ].  Pad)SH
10908 68311 MT
(objects for double alignment have a null callback in callbacks[ 1 ].  The)SH
10908 69349 MT
(header for a one-word double alignment pad is kept in doublepad.)SH
9288 70387 MT
(*/)SH
10 /Times-Roman AF
30811 75600 MT
(-79-)SH
ES
%%Page: 80 80
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
(static int  freespace_callback = MAKE_CALLBACK\050 0 \051;)SH
9288 12259 MT
(static void)
540 W( freespace_pointers\050 GCP dummy \051 {};)SH
9288 14335 MT
(#ifdef DOUBLE_ALIGN)SH
9288 15373 MT
(static int  doublepad;)SH
9288 16411 MT
(#endif)SH
9288 18487 MT
(/* Callback procedures are "registered" with the garbage collector by the)SH
10908 19525 MT
(following procedure.  Calls to it are hidden inside GCALLOC and GCALLOCV.)SH
9288 20563 MT
(*/)SH
9288 22639 MT
(int gcregistercallback\050)
540 W( GCCALLBACKPROC  proc, char* type \051  {)SH
13608 23677 MT
(if \050callbacks_count)
540 W( > MAX_HEADER_CALLBACK\051  {)SH
15228 24715 MT
(fprintf\050 stderr, "\134n***** gcalloc  %d classes already defined\134n",)SH
20088 25753 MT
(MAX_HEADER_CALLBACK-1 \051;)SH
15228 26791 MT
(abort\050\051;)SH
13608 27829 MT
(})SH
13608 28867 MT
(if \050callbacks_count)
540 W( == callbacks_size\051  {)SH
15228 29905 MT
(callback_struct* np)
540 W( = new callback_struct[ callbacks_size+)SH
38988 30943 MT
(callbacks_inc ];)SH
15228 31981 MT
(for \050int)
540 W( i=0; i < callbacks_count; i++\051  np[ i ] = callbacks[ i ];)SH
15228 33019 MT
(delete callbacks;)540 W
15228 34057 MT
(callbacks = np;)SH
15228 35095 MT
(callbacks_size = callbacks_size+callbacks_inc;)SH
15228 36133 MT
(if \050callbacks_count)
540 W( == 0\051  {)SH
16848 37171 MT
(callbacks[ 0 ].proc = freespace_pointers;)SH
16848 38209 MT
(callbacks[ 0 ].type = "GCFreeSpace";)SH
16848 39247 MT
(callbacks[ 1 ].proc = freespace_pointers;)SH
16848 40285 MT
(callbacks[ 1 ].type = "GCDoublePad";)SH
16848 41323 MT
(callbacks_count = 2;)SH
15228 42361 MT
(})SH
13608 43399 MT
(})SH
13608 44437 MT
(callbacks[ callbacks_count ].proc = proc;)SH
13608 45475 MT
(callbacks[ callbacks_count ].type = type;)SH
13608 46513 MT
(return MAKE_CALLBACK\050)
540 W( callbacks_count++ \051;)SH
9288 47551 MT
(})SH
13068 50665 MT
(/****************************)SH
13608 51703 MT
(* Mostly Copying Collector *)SH
13608 52741 MT
(****************************/)SH
9288 54817 MT
(/* Get heap configuration information from the environment.  Return true if)SH
10908 55855 MT
(the value is provided.)SH
9288 56893 MT
(*/)SH
9288 58969 MT
(static int  environment_value\050 char* name, int& value \051)SH
9288 60007 MT
({)SH
13608 61045 MT
(char* valuestring = getenv\050 name \051;)SH
13608 63121 MT
(if \050valuestring != NULL\051  {)SH
15228 64159 MT
(value = atoi\050 valuestring \051;)SH
15228 65197 MT
(return 1;)540 W
13608 66235 MT
(})SH
13608 67273 MT
(return 0;)540 W
9288 68311 MT
(})SH
9288 70387 MT
(/* When run with GCHEAPMAP flag set \050see gcalloc-??.h\051, a graphical)SH
10908 71425 MT
(display will appear on the screen to monitor the allocation/)SH
10 /Times-Roman AF
30811 75600 MT
(-80-)SH
ES
%%Page: 81 81
BS
0 SI
9 /Courier-Bold AF
10908 10183 MT
(deallocation activities in the heap.)SH
10908 12259 MT
(The graphical display is set up by means of a pipe to an EZX process.)SH
10908 13297 MT
(Garbage collection can be stepped using the mouse buttons:)SH
13608 15373 MT
(button 1 - advance to the next step.)SH
13608 16411 MT
(button 2 - enable/disable stepping.)SH
13608 17449 MT
(button 3 - Postscript for display to gcheap.PSF.)SH
9288 18487 MT
(*/)SH
9288 20563 MT
(/* Colors to use for free storage. */)SH
9288 22639 MT
(static char*)
540 W( freecolors[16] =)SH
13608 23677 MT
({ 0, "red", 0, "turquoise", 0, "green", 0, "yellow",)SH
14688 24715 MT
(0, "red", 0, "turquoise", 0, "green", 0, "yellow" };)SH
9288 26791 MT
(/* The following procedure writes the header on the heap display. */)SH
9288 28867 MT
(static void  display_headers\050 char* phase \051)SH
9288 29905 MT
({)SH
13608 30943 MT
(fputs\050 "\050object header", display \051;)SH
13608 31981 MT
(fprintf\050 display, "\050fill-rectangle 10 0 10 10 %s\051",)SH
18468 33019 MT
(freecolors[ \050curr_space % 8\051+2 ] \051;)SH
13608 34057 MT
(fprintf\050 display, "\050fill-rectangle 22 0 10 10 %s\051",)SH
18468 35095 MT
(freecolors[ \050curr_space % 8\051+4 ] \051;)SH
13608 36133 MT
(fprintf\050 display, "\050fill-rectangle 34 0 10 10 %s\051",)SH
18468 37171 MT
(freecolors[ \050curr_space % 8\051+6 ] \051;)SH
13608 38209 MT
(fputs\050 "\050text 50 10 \134"Free space\134" \134"8x13\134"\051", display \051;)SH
13608 39247 MT
(fprintf\050 display, "\050fill-rectangle 140 0 10 10 %s\051",)SH
18468 40285 MT
(freecolors[ \050curr_space % 8\051 ] \051;)SH
13608 41323 MT
(fputs\050 "\050text 156 10 \134"Recently Allocated\134" \134"8x13\134"\051", display \051;)SH
13608 42361 MT
(fputs\050 "\050fill-rectangle 310 0 10 10 black\051", display \051;)SH
13608 43399 MT
(fputs\050 "\050text 326 10 \134"Stable set\134" \134"8x13\134"\051", display \051;)SH
13608 44437 MT
(fprintf\050 display, "\050text 420 10 \134"%s\134" \134"8x13\134"\051", phase \051;)SH
13608 45475 MT
(fputs\050 "\051", display \051;)SH
13608 46513 MT
(fputs\050 "\050step #t\051", display \051;)SH
13608 47551 MT
(fflush\050 display \051;)SH
9288 48589 MT
(})SH
9288 50665 MT
(/* Each page is represented by a square of the following size.  */)SH
9288 52741 MT
(#define PAGE_PIXELS 5)540 W
9288 54817 MT
(/* The following procedure is called to create the heap display. */)SH
9288 56893 MT
(static void  displayinit\050\051)SH
9288 57931 MT
({)SH
13608 58969 MT
(int toezx[)
540 W( 2 ];)SH
13608 61045 MT
(if \050\050gcflags)
540 W( & GCHEAPMAP\051 == 0\051  return;)SH
13608 62083 MT
(/* Spawn off an ezx process */)SH
13608 63121 MT
(pipe\050 toezx \051;)SH
13608 64159 MT
(if \050fork\050\051)
540 W( == 0\051  {)SH
15228 65197 MT
(close\050 0 \051;)SH
15228 66235 MT
(dup\050 toezx[ 0 ] \051;)SH
15228 67273 MT
(close\050 toezx[ 0 ] \051;)SH
15228 68311 MT
(close\050 toezx[ 1 ] \051;)SH
15228 69349 MT
(execlp\050 "ezx", "ezx", 0 \051;)SH
15228 70387 MT
(exit\050 1 \051;)SH
13608 71425 MT
(})SH
10 /Times-Roman AF
30811 75600 MT
(-81-)SH
ES
%%Page: 82 82
BS
0 SI
9 /Courier-Bold AF
13608 10183 MT
(display = fdopen\050 toezx[ 1 ], "w" \051;)SH
13608 11221 MT
(/* Initialize the display */)SH
13608 12259 MT
(fprintf\050 display,)SH
17928 13297 MT
("\050window heap 0 0 %d 220 \134"C++ Garbage Collected Heap\134"\051\134n",)SH
17928 14335 MT
(PAGE_PIXELS*128 \051;)SH
13608 15373 MT
(fputs\050 "\050click 1 0 0 0 0 \050next-step\051\051", display \051;)SH
13608 16411 MT
(fputs\050 "\050click 2 0 0 0 0 \050set! *stepper* \050not *stepper*\051\051\051", display \051;)SH
13608 17449 MT
(fputs\050 "\050click 3 0 0 0 0 \050ezx-command '\050postscript \134"gcppheap.PSF\134"\051\051\051",)SH
17388 18487 MT
(display \051;)SH
13608 19525 MT
(display_headers\050 "Application Allocation" \051;)SH
9288 20563 MT
(})SH
9288 22639 MT
(/* A page is colored on the heap map by the following function. */)SH
9288 24715 MT
(static void  page_map\050 int page \051)SH
9288 25753 MT
({)SH
13608 26791 MT
(char* color;)540 W
13608 28867 MT
(if \050STABLE\050)
540 W( page \051\051)SH
15228 29905 MT
(color = "BLACK";)SH
13608 30943 MT
(else)SH
15228 31981 MT
(color = freecolors[ space[ page ] % 8 ];)SH
13608 33019 MT
(page = page-firstheappage;)SH
13608 34057 MT
(fprintf\050 display, "\050object p%x \050fill-rectangle %d %d %d %d %s\051\051",)SH
18468 35095 MT
(page, \050page & 127\051*PAGE_PIXELS,)SH
18468 36133 MT
(PAGE_PIXELS*\050page/2048\051+\050page/128\051*PAGE_PIXELS+20,)SH
18468 37171 MT
(PAGE_PIXELS, PAGE_PIXELS, color \051;)SH
13608 38209 MT
(fflush\050 display \051;)SH
9288 39247 MT
(})SH
9288 41323 MT
(/* The heap is allocated and the appropriate data structures are initialized)SH
10908 42361 MT
(by the following function.  It is called the first time any storage is)SH
10908 43399 MT
(allocated from the heap.)SH
9288 44437 MT
(*/)SH
9288 46513 MT
(static void  gcinit\050 \051)SH
9288 47551 MT
({)SH
13608 48589 MT
(char *heap;)540 W
13608 49627 MT
(int i;)540 W
13608 51703 MT
(/* Log actual heap parameters if from environment or logging */)SH
13608 52741 MT
(if \050\050environment_value\050)
540 W( "GCMINBYTES", gcminbytes \051 |)SH
16848 53779 MT
(environment_value\050 "GCMAXBYTES", gcmaxbytes \051 |)SH
16848 54817 MT
(environment_value\050 "GCINCBYTES", gcincbytes \051 |)SH
16848 55855 MT
(environment_value\050 "GCALLPERCENT", gcallpercent \051 |)SH
16848 56893 MT
(environment_value\050 "GCINCPERCENT", gcincpercent \051 |)SH
16848 57931 MT
(environment_value\050 "GCSTABLEPERCENT", gcstablepercent \051 |)SH
16848 58969 MT
(environment_value\050 "GCFLAGS", gcflags \051\051  ||)SH
16848 60007 MT
(gcflags & GCSTATS\051  {)SH
15228 61045 MT
(fprintf\050 stderr,)SH
20088 62083 MT
("***** YIP gcalloc gcheap\050 %d, %d, %d, %d, %d, %d, %d \051\134n",)SH
20088 63121 MT
(gcminbytes, gcmaxbytes, gcincbytes, gcallpercent,)SH
20088 64159 MT
(gcincpercent, gcstablepercent, gcflags \051;)SH
13608 65197 MT
(})SH
13608 67273 MT
(void page_fault_handler\050 int sig, int code, struct sigcontext *scp \051;)SH
9288 68311 MT
(#ifdef mips)SH
13608 69349 MT
(signal\050 SIGSEGV, \050SIG_PF\051page_fault_handler \051;)SH
9288 70387 MT
(#endif)SH
9288 71425 MT
(#ifdef vax)SH
10 /Times-Roman AF
30811 75600 MT
(-82-)SH
ES
%%Page: 83 83
BS
0 SI
9 /Courier-Bold AF
13608 10183 MT
(signal\050 SIGBUS, \050SIG_PF\051page_fault_handler \051;)SH
9288 11221 MT
(#endif)SH
13608 13297 MT
(/* Record system parameters and assign page mask values */)SH
13608 14335 MT
(int physical_pagebytes = getpagesize\050\051;)SH
13608 15373 MT
(phys_cap = physical_pagebytes/PAGEBYTES;)SH
13608 16411 MT
(phys_pagemask = ~\050PHYS_PAGEBYTES-1\051;)SH
13608 17449 MT
(heap_pagemask = ~\050PAGEBYTES-1\051;)SH
13608 19525 MT
(/* heap size rounded up to the nearest physical page size */)SH
13608 20563 MT
(physspanpages = \050gcminbytes+PHYS_PAGEBYTES-1\051/PHYS_PAGEBYTES;)SH
13608 21601 MT
(heapspanpages = heappages = physspanpages*phys_cap;)SH
13608 23677 MT
(/* Allocate heap and side tables.  Exit on allocation failure. */)SH
13608 24715 MT
(if \050\050heap=new)
540 W( char[ heappages*PAGEBYTES+PHYS_PAGEBYTES-1 ]\051 == NULL\051)SH
15228 25753 MT
(goto fail;)SH
13608 26791 MT
(if \050\050unsigned\051heap & \050PHYS_PAGEBYTES-1\051\051)SH
15228 27829 MT
(heap = heap+\050PHYS_PAGEBYTES-\050\050unsigned\051heap&\050PHYS_PAGEBYTES-1\051\051\051;)SH
13608 28867 MT
(firstheappage = GCP_to_PAGE\050 heap \051;)SH
13608 29905 MT
(lastheappage = firstheappage+heapspanpages-1;)SH
13608 30943 MT
(if \050\050space)
540 W( = new int[ heapspanpages ]\051 == NULL)
SH( ||)1620 W
16308 31981 MT
(\050plink = new int[ heapspanpages]\051 == NULL)
SH( ||)2160 W
16308 33019 MT
(\050type = new int[ heapspanpages+1 ]\051 == NULL)
SH( ||)1080 W
16308 34057 MT
(\050protect = new int[ physspanpages ]\051 == NULL  ||)SH
16308 35095 MT
(\050firstword = new int[ \050heapspanpages+1\051*BIT_WORDS ]\051 == NULL\051 {)SH
9288 36133 MT
(fail: fprintf\050)
2700 W( stderr,)SH
20088 37171 MT
("\134n****** gcalloc  Unable to allocate %d byte heap\134n",)SH
20088 38209 MT
(gcminbytes \051;)SH
15228 39247 MT
(abort\050\051;)SH
13608 40285 MT
(})SH
13608 41323 MT
(space = space-firstheappage;)SH
13608 42361 MT
(plink = plink-firstheappage;)SH
13608 43399 MT
(type = type-firstheappage;)SH
13608 44437 MT
(type[lastheappage+1] = OBJECT;)SH
13608 45475 MT
(firstword = firstword-firstheappage*BIT_WORDS;)SH
13608 46513 MT
(SET_FIRSTWORD\050 \050\050int*\051\050\050lastheappage+1\051*PAGEBYTES\051\051 + 2 \051;)SH
13608 48589 MT
(/* Initialize tables */)SH
13608 49627 MT
(for \050i = firstheappage ; i <= lastheappage ; i++\051)SH
15228 50665 MT
(space[ i ] = FREEPAGE;)SH
13608 51703 MT
(bzero\050 \050char*\051protect, physspanpages*sizeof\050int\051 \051;)SH
13608 52741 MT
(protect = protect - \050PAGE_to_ADDR\050firstheappage\051>>phys_shift\051;)SH
13608 54817 MT
(static void setup_endangered_rec\050\051;)SH
13608 55855 MT
(setup_endangered_rec\050\051;)SH
13608 57931 MT
(curr_space = 3;)SH
13608 58969 MT
(forw_space = 3;)SH
13608 60007 MT
(prev_space = 3;)SH
13608 61045 MT
(curr_freepage = firstheappage;)SH
13608 62083 MT
(curr_freewords = 0;)SH
13608 63121 MT
(allocatedpages = 0;)SH
13608 64159 MT
(forwardedpages = 0;)SH
13608 65197 MT
(currentpages = 0;)SH
13608 66235 MT
(protectedpages = 0;)SH
13608 67273 MT
(queue_head = 0;)SH
13608 68311 MT
(gcheapcreated = 1;)SH
9288 69349 MT
(#ifdef DOUBLE_ALIGN)SH
13608 70387 MT
(doublepad = MAKE_HEADER\050 1, MAKE_CALLBACK\050 1 \051 \051;)SH
9288 71425 MT
(#endif)SH
10 /Times-Roman AF
30811 75600 MT
(-83-)SH
ES
%%Page: 84 84
BS
0 SI
9 /Courier-Bold AF
13608 10183 MT
(displayinit\050\051;)SH
9288 11221 MT
(})SH
9288 13297 MT
(/* Once the heap has been allocated, it is expanded after garbage)SH
10908 14335 MT
(collection whenever it is appropriate until the maximum size is)SH
10908 15373 MT
(reached. If)
540 W( space cannot be allocated to expand the heap, then the)SH
10908 16411 MT
(heap will be left at its current size and no further expansions will)SH
10908 17449 MT
(be attempted.  SHOULDEXPANDHEAP is a boolean that returns true when)SH
10908 18487 MT
(the heap should be expanded.  EXPANDHEAP is called to expand the)SH
10908 19525 MT
(heap. It)
540 W( returns true when the heap could be expanded.)SH
9288 20563 MT
(*/)SH
9288 22639 MT
(static int  shouldexpandheap\050\051)SH
9288 23677 MT
({)SH
13608 24715 MT
(if \050HEAPPERCENT\050)
540 W( allocatedpages \051 < gcincpercent  ||)SH
16308 25753 MT
(heappages >= gcmaxbytes/PAGEBYTES  ||  gcincbytes == 0\051)SH
15228 26791 MT
(return 0;)540 W
13608 27829 MT
(else)SH
15228 28867 MT
(return 1;)540 W
9288 29905 MT
(})SH
9288 31981 MT
(static expandfailed)
540 W( = 0;)SH
9288 34057 MT
(static int  expandheap\050\051  {)SH
13608 36133 MT
(int incphyspages)
540 W( = \050gcincbytes+PHYS_PAGEBYTES-1\051/PHYS_PAGEBYTES,)SH
16308 37171 MT
(incheappages = incphyspages*phys_cap,)SH
16308 38209 MT
(new_firstheappage = firstheappage,)SH
16308 39247 MT
(inc_firstheappage,)SH
16308 40285 MT
(new_lastheappage = lastheappage,)SH
16308 41323 MT
(inc_lastheappage,)SH
16308 42361 MT
(new_heappages,)SH
16308 43399 MT
(new_heapspanpages,)SH
16308 44437 MT
(new_physspanpages,)SH
16308 45475 MT
(*new_space = NULL,)SH
16308 46513 MT
(*new_plink = NULL,)SH
16308 47551 MT
(*new_type = NULL,)SH
16308 48589 MT
(*new_protect = NULL,)SH
16308 49627 MT
(*new_scanned = NULL,)SH
16308 50665 MT
(*new_firstword = NULL,)SH
16308 51703 MT
(i;)SH
13608 52741 MT
(char* heap;)540 W
13608 54817 MT
(/* Check for previous expansion failure */)SH
13608 55855 MT
(if \050expandfailed\051 return 0;)540 W
13608 57931 MT
(/* Allocate additional heap and determine page span */)SH
13608 58969 MT
(heap = new char[ incheappages*PAGEBYTES+PHYS_PAGEBYTES-1 ];)SH
13608 60007 MT
(if \050heap)
540 W( == NULL\051  goto fail;)SH
13608 61045 MT
(if \050\050unsigned\051heap & \050PHYS_PAGEBYTES-1\051\051)SH
15228 62083 MT
(heap = heap+\050PHYS_PAGEBYTES-\050\050unsigned\051heap&\050PHYS_PAGEBYTES-1\051\051\051;)SH
13608 63121 MT
(inc_firstheappage = GCP_to_PAGE\050 heap \051;)SH
13608 64159 MT
(inc_lastheappage = inc_firstheappage+incheappages-1;)SH
13608 65197 MT
(if \050inc_firstheappage)
540 W( < firstheappage\051)SH
15228 66235 MT
(new_firstheappage = inc_firstheappage;)SH
13608 67273 MT
(if \050inc_lastheappage)
540 W( > lastheappage\051)SH
15228 68311 MT
(new_lastheappage = inc_lastheappage;)SH
13608 69349 MT
(new_heappages = heappages+incheappages;)SH
13608 70387 MT
(new_heapspanpages = new_lastheappage-new_firstheappage+1;)SH
13608 71425 MT
(new_physspanpages = new_heapspanpages/phys_cap;)SH
10 /Times-Roman AF
30811 75600 MT
(-84-)SH
ES
%%Page: 85 85
BS
0 SI
9 /Courier-Bold AF
13608 10183 MT
(/* Allocate contiguous space for each side table, recover gracefully)SH
15228 11221 MT
(from allocation failure.  */)SH
13608 12259 MT
(if \050\050new_space)
540 W( = new int[ new_heapspanpages ]\051 == NULL)
SH( ||)1080 W
16308 13297 MT
(\050new_plink = new int[ new_heapspanpages ]\051 == NULL)
SH( ||)1080 W
16308 14335 MT
(\050new_type = new int[ new_heapspanpages+1 ]\051 == NULL  ||)SH
16308 15373 MT
(\050new_protect = new int[ new_physspanpages ]\051 == NULL ||)SH
16308 16411 MT
(\050new_scanned = new int[ new_heapspanpages ]\051 == NULL ||)SH
16308 17449 MT
(\050new_firstword = new int[ \050new_heapspanpages+1\051*BIT_WORDS ]\051)SH
17928 18487 MT
(== NULL\051 {)SH
9288 19525 MT
(fail: if)
2700 W( \050heap\051 delete)
540 W( heap;)SH
15228 20563 MT
(if \050new_space\051 delete)
540 W( new_space;)SH
15228 21601 MT
(if \050new_plink\051 delete)
540 W( new_plink;)SH
15228 22639 MT
(if \050new_type\051 delete)
540 W( new_type;)SH
15228 23677 MT
(if \050new_protect\051)
540 W( delete new_protect;)SH
15228 24715 MT
(if \050new_scanned\051)
540 W( delete new_scanned;)SH
15228 25753 MT
(if \050new_firstword\051 delete)
540 W( new_firstword;)SH
15228 26791 MT
(expandfailed = 1;)SH
15228 27829 MT
(if \050gcflags)
540 W( & GCSTATS\051)SH
16848 28867 MT
(fprintf\050 stderr, "\134n***** gcalloc  Heap expansion failed\134n" \051;)SH
15228 29905 MT
(return 0;)540 W
13608 30943 MT
(})SH
13608 31981 MT
(new_space = new_space-new_firstheappage;)SH
13608 33019 MT
(new_plink = new_plink-new_firstheappage;)SH
13608 34057 MT
(new_type = new_type-new_firstheappage;)SH
13608 35095 MT
(new_firstword = new_firstword-new_firstheappage*BIT_WORDS;)SH
13608 37171 MT
(/* Initialize new side tables, delete the old ones */)SH
13608 39247 MT
(bzero\050 \050char*\051new_scanned, new_heapspanpages*sizeof\050int\051 \051;)SH
13608 40285 MT
(new_scanned = new_scanned-new_firstheappage;)SH
13608 42361 MT
(for \050i = new_firstheappage ; i < firstheappage ; i++\051)SH
15228 43399 MT
(new_space[ i ] = UNALLOCATEDPAGE;)SH
13608 44437 MT
(for \050i = firstheappage ; i <= lastheappage ; i++\051 {)SH
15228 45475 MT
(new_space[ i ] = space[ i ];)SH
13608 46513 MT
(})SH
13608 47551 MT
(for \050i = lastheappage+1 ; i < new_lastheappage ; i++\051)SH
15228 48589 MT
(new_space[ i ] = UNALLOCATEDPAGE;)SH
13608 49627 MT
(for \050i = inc_firstheappage ; i <= inc_lastheappage ; i++\051)SH
15228 50665 MT
(new_space[ i ] = FREEPAGE;)SH
13608 51703 MT
(delete \050space+firstheappage\051;)SH
13608 52741 MT
(space = new_space;)SH
13608 54817 MT
(for \050i)
540 W( = firstheappage; i <= lastheappage; i++\051  {)SH
15228 55855 MT
(new_plink[ i ] = plink[ i ];)SH
15228 56893 MT
(new_type[ i ] = type[ i ];)SH
13608 57931 MT
(})SH
13608 58969 MT
(delete \050plink+firstheappage\051;)SH
13608 60007 MT
(plink = new_plink;)SH
13608 61045 MT
(delete \050type+firstheappage\051;)SH
13608 62083 MT
(type = new_type;)SH
13608 64159 MT
(bzero\050 \050char*\051new_protect, new_physspanpages*sizeof\050int\051 \051;)SH
13608 65197 MT
(new_protect =)SH
16308 66235 MT
(new_protect - \050PAGE_to_PPADDR\050new_firstheappage\051>>phys_shift\051;)SH
13608 67273 MT
(for \050int addr_physpage = PAGE_to_ADDR\050firstheappage\051;)SH
16308 68311 MT
(addr_physpage < PAGE_to_ADDR\050lastheappage\051;)540 W
16308 69349 MT
(addr_physpage += PHYS_PAGEBYTES \051)SH
15228 70387 MT
(*\050new_protect+\050addr_physpage>>phys_shift\051\051 =)SH
24408 71425 MT
(is_physpage_protected\050 addr_physpage \051;)SH
10 /Times-Roman AF
30811 75600 MT
(-85-)SH
ES
%%Page: 86 86
BS
0 SI
9 /Courier-Bold AF
13608 10183 MT
(delete \050protect+\050PAGE_to_ADDR\050firstheappage\051>>phys_shift\051\051;)SH
13608 11221 MT
(protect = new_protect;)SH
13608 13297 MT
(for \050i)
540 W( = firstheappage*BIT_WORDS;)SH
16848 14335 MT
(i <= lastheappage*BIT_WORDS+BIT_WORDS-1; i++\051)SH
15228 15373 MT
(new_firstword[ i ] = firstword[ i ];)SH
13608 16411 MT
(delete \050firstword+firstheappage*BIT_WORDS\051;)SH
13608 17449 MT
(firstword = new_firstword;)SH
13608 19525 MT
(/* To facilitate easy implementation of NEXT_OBJECT, SMALL_CLUSTER,)SH
15228 20563 MT
(and DETERMINE_PHYSPAGE_CLUSTER, the following \050phony\051 bookkeeping)SH
15228 21601 MT
(is made about the non-existing "page" just beyond the heap */)SH
13608 22639 MT
(new_type[ new_lastheappage+1 ] = OBJECT;)SH
13608 23677 MT
(SET_FIRSTWORD\050 \050\050int*\051\050\050new_lastheappage+1\051*PAGEBYTES\051\051 + 2 \051;)SH
13608 25753 MT
(firstheappage = new_firstheappage;)SH
13608 26791 MT
(lastheappage = new_lastheappage;)SH
13608 27829 MT
(heappages = new_heappages;)SH
13608 28867 MT
(heapspanpages = new_heapspanpages;)SH
13608 29905 MT
(physspanpages = new_physspanpages;)SH
13608 31981 MT
(if \050gcflags)
540 W( & GCSTATS\051)SH
15228 33019 MT
(fprintf\050 stderr, "\134n***** gcalloc  Heap expanded to %d bytes\134n",)SH
20088 34057 MT
(heappages*PAGEBYTES \051;)SH
13608 36133 MT
(return 1;)540 W
9288 37171 MT
(})SH
9288 39247 MT
(/* A pointer pointing to the header of an object is stepped to the next)SH
10908 40285 MT
(header by the following function.)SH
9288 41323 MT
(*/)SH
9288 43399 MT
(static GCP  next_object\050 GCP xp \051)SH
9288 44437 MT
({)SH
13608 45475 MT
(xp++; /*)
2160 W( xp now points at body of object */)SH
13608 46513 MT
(while \050xp++\051)540 W
15228 47551 MT
(if \050ISA_FIRSTWORD\050)
540 W( xp \051\051)SH
16848 48589 MT
(return \050xp-1\051;)SH
9288 49627 MT
(})SH
9288 51703 MT
(/* A pointer can be verified to point to an object in the heap by the)SH
10908 52741 MT
(following function.  An invalid pointer will be logged and the program)SH
10908 53779 MT
(will abort.)SH
9288 54817 MT
(*/)SH
9288 56893 MT
(static void  verify_object\050 GCP cp, int old \051)SH
9288 57931 MT
({)SH
13608 58969 MT
(int page)
540 W( = GCP_to_PAGE\050 cp \051;)SH
13608 60007 MT
(GCP xp)
540 W( = PAGE_to_GCP\050 page \051; /* Ptr to start of page */)SH
13608 61045 MT
(int error)
540 W( = 0;)SH
13608 63121 MT
(if \050page)
540 W( < firstheappage\051  goto fail;)SH
13608 64159 MT
(error = 1;)SH
13608 65197 MT
(if \050page)
540 W( > lastheappage\051  goto fail;)SH
13608 66235 MT
(error = 2;)SH
13608 67273 MT
(if \050space[)
540 W( page ] == UNALLOCATEDPAGE\051  goto fail;)SH
13608 68311 MT
(error = 3;)SH
13608 69349 MT
(if \050old && UNSTABLE\050)
540 W( page \051  &&  space[ page ] != prev_space\051)SH
15228 70387 MT
(goto fail;)SH
13608 71425 MT
(error = 4;)SH
10 /Times-Roman AF
30811 75600 MT
(-86-)SH
ES
%%Page: 87 87
BS
0 SI
9 /Courier-Bold AF
13608 10183 MT
(if \050old)
540 W( == 0  &&  space[ page ] != forw_space\051  goto fail;)SH
13608 11221 MT
(error = 5;)SH
13608 12259 MT
(if \050callbacks[)
540 W( HEADER_CALLBACK\050 cp[-1] \051 ].proc == freespace_pointers\051)SH
15228 13297 MT
(return;)SH
13608 14335 MT
(while \050cp)
540 W( > xp+1\051  xp = next_object\050 xp \051;)SH
13608 15373 MT
(if \050cp)
540 W( == xp+1\051  return;)SH
9288 16411 MT
(fail:)SH
13608 17449 MT
(fprintf\050 stderr, "\134n***** gcalloc  invalid pointer " \051;)SH
13608 18487 MT
(fprintf\050 stderr,)SH
17928 19525 MT
("error: %d  pointer: 0x%x nextcp 0x%x xp 0x%x\134n",)SH
18468 20563 MT
(error, cp, cp+HEADER_WORDS\050*cp\051, xp \051;)SH
13608 21601 MT
(abort\050\051;)SH
9288 22639 MT
(})SH
9288 24715 MT
(/* An object's header is verified by the following function.  An invalid)SH
10908 25753 MT
(header will be logged and the program will abort.)SH
9288 26791 MT
(*/)SH
9288 28867 MT
(static void  verify_header\050 GCP cp \051)SH
9288 29905 MT
({)SH
13608 30943 MT
(int size)
540 W( = HEADER_WORDS\050 cp[ -1 ] \051,)SH
16308 31981 MT
(page = GCP_to_PAGE\050 cp \051,)SH
16308 33019 MT
(error = 0;)SH
13608 35095 MT
(if FORWARDED\050)
540 W( cp[ -1 ] \051  goto fail;)SH
13608 36133 MT
(error = 1;)SH
13608 37171 MT
(if \050\050unsigned\051HEADER_CALLBACK\050)
540 W( cp[ -1 ] \051 >=)SH
16308 38209 MT
(\050unsigned\051callbacks_count\051 goto)
540 W( fail;)SH
13608 39247 MT
(if \050size)
540 W( <= ONEPAGEOBJ_WORDS\051  {)SH
15228 40285 MT
(error = 2;)SH
15228 41323 MT
(if \050cp-1+size)
540 W( > PAGE_to_GCP\050 page+1 \051\051  goto fail;)SH
13608 42361 MT
(} else  {)SH
15228 43399 MT
(error = 3;)SH
15228 44437 MT
(int pages)
540 W( = HEADER_PAGES\050 cp[ -1 ] \051,)SH
17928 45475 MT
(pagex = page;)SH
15228 46513 MT
(while \050--pages\051 {)540 W
16848 47551 MT
(pagex++;)SH
16848 48589 MT
(if \050pagex)
540 W( > lastheappage  ||)SH
19548 49627 MT
(type[ pagex ] != CONTINUED  ||)SH
19548 50665 MT
(space[ pagex ] != space[ page ]\051)SH
18468 51703 MT
(goto fail;)SH
15228 52741 MT
(})SH
13608 53779 MT
(})SH
13608 54817 MT
(return;)SH
9288 55855 MT
(fail: fprintf\050)
1080 W( stderr,"\134n***** gcalloc  invalid header  "\051;)SH
13608 56893 MT
(fprintf\050 stderr,)SH
17928 57931 MT
("error: %d  object&: 0x%x  header: 0x%x\134n",)SH
18468 58969 MT
(error, cp, cp[ -1 ] \051;)SH
13608 60007 MT
(abort\050\051;)SH
9288 61045 MT
(})SH
9288 63121 MT
(/* The consistency of the heap is checked by the following function. */)SH
9288 65197 MT
(static void  verify_heap\050\051)SH
9288 66235 MT
({)SH
13608 67273 MT
(GCP cp, lastcp;)SH
13608 68311 MT
(for \050int)
540 W( page = firstheappage; page < lastheappage; page++\051 {)SH
15768 69349 MT
(cp = PAGE_to_GCP\050 page \051;)SH
15768 70387 MT
(if \050)
540 W( type[page] == OBJECT &&)SH
18468 71425 MT
(\050 space[page] == curr_space ||)SH
10 /Times-Roman AF
30811 75600 MT
(-87-)SH
ES
%%Page: 88 88
BS
0 SI
9 /Courier-Bold AF
19008 10183 MT
(\050STABLE\050page\051 && space[ page ] != UNALLOCATEDPAGE\051 \051 \051 {)SH
17388 11221 MT
(lastcp = PAGE_to_GCP\050page+1\051 - 1;)SH
17388 12259 MT
(while \050cp)
540 W( < lastcp &&)SH
21708 13297 MT
(\050curr_freewords == 0 || cp != curr_freep\051\051 {)SH
20628 14335 MT
(verify_object\050 cp+1, 1\051;)SH
20628 15373 MT
(verify_header\050 cp+1 \051;)SH
20628 16411 MT
(cp = cp+HEADER_WORDS\050 *cp \051;)SH
17388 17449 MT
(})SH
15768 18487 MT
(})SH
13608 19525 MT
(})SH
9288 20563 MT
(})SH
9288 22639 MT
(/* The following variable holds the number of pointers guessed in an object)SH
10908 23677 MT
(by guess_pointer.  Note that cp points to the object header.)SH
9288 24715 MT
(*/)SH
9288 26791 MT
(static int  guess_pointer_count;)SH
9288 28867 MT
(static int  guess_pointers\050 GCP cp \051)SH
9288 29905 MT
({)SH
13608 30943 MT
(guess_pointer_count = 0;)SH
13608 31981 MT
(if \050HEADER_CALLBACK\050)
540 W( *cp \051 != 0\051  {)SH
15228 33019 MT
(for \050int)
540 W( i=1; i < HEADER_WORDS\050 *cp \051; i++\051  {)SH
16848 34057 MT
(int page)
540 W( = GCP_to_PAGE\050 \050GCP\051cp[ i ] \051;)SH
16848 35095 MT
(if \050page)
540 W( >= firstheappage  &&  page <= lastheappage  &&)SH
19548 36133 MT
(space[ page ] != UNALLOCATEDPAGE\051)SH
18468 37171 MT
(guess_pointer_count++;)SH
15228 38209 MT
(})SH
13608 39247 MT
(})SH
13608 40285 MT
(return guess_pointer_count;)540 W
9288 41323 MT
(})SH
9288 43399 MT
(/* The stable set is moved into the current_generation by the following)SH
10908 44437 MT
(function. A)
540 W( total collection is performed by calling this before calling)SH
10908 45475 MT
(gccollect. When)
540 W( generational collection is not desired, this is called)SH
10908 46513 MT
(after collection to empty the stable set.)SH
9288 47551 MT
(*/)SH
9288 49627 MT
(static void  makecurrentstableset\050\051)SH
9288 50665 MT
({)SH
13608 51703 MT
(int pagecount, i;)SH
13608 52741 MT
(while \050queue_head\051 {)540 W
9288 53779 MT
(#ifdef DOUBLE_ALIGN)SH
15228 54817 MT
(pagecount = HEADER_PAGES\050 *\050PAGE_to_GCP\050 queue_head \051+1\051 \051;)SH
9288 55855 MT
(#else)SH
15228 56893 MT
(pagecount = HEADER_PAGES\050 *PAGE_to_GCP\050 queue_head \051 \051;)SH
9288 57931 MT
(#endif)SH
15228 58969 MT
(i = queue_head;)SH
15228 60007 MT
(while \050pagecount--\051 {)540 W
16848 61045 MT
(space[ i++ ] = curr_space;)SH
16848 62083 MT
(if \050gcflags)
540 W( & GCHEAPMAP\051  page_map\050 i-1 \051;)SH
15228 63121 MT
(})SH
15228 64159 MT
(queue_head = plink[ queue_head ];)SH
13608 65197 MT
(})SH
13608 67273 MT
(currentpages = allocatedpages;)SH
13608 68311 MT
(forwardedpages = 0;)SH
9288 69349 MT
(})SH
9288 71425 MT
(/* A page index is advanced by the following function */)SH
10 /Times-Roman AF
30811 75600 MT
(-88-)SH
ES
%%Page: 89 89
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
(static inline int  next_page\050 int page \051)SH
9288 11221 MT
({)SH
13608 12259 MT
(return \050page)
540 W( == lastheappage\051 ? firstheappage : page+1;)SH
9288 13297 MT
(})SH
9288 15373 MT
(/* A page is added to the stable set page queue by the following function. */)SH
9288 17449 MT
(static void  queue\050 int page \051)SH
9288 18487 MT
({)SH
13608 19525 MT
(if \050queue_head)
540 W( != 0\051)SH
15228 20563 MT
(plink[ queue_tail ] = page;)SH
13608 21601 MT
(else)SH
15228 22639 MT
(queue_head = page;)SH
13608 23677 MT
(plink[ page ] = 0;)SH
13608 24715 MT
(queue_tail = page;)SH
9288 25753 MT
(})SH
9288 27829 MT
(/* Pages that have might have references in the stack or the registers are)SH
10908 28867 MT
(promoted to the forward space \050which is stable\051 by the following function.)SH
9288 29905 MT
(*/)SH
9288 31981 MT
(static void  promote_page\050 int page \051)SH
9288 33019 MT
({)SH
13608 34057 MT
(if \050page)
540 W( >= firstheappage  &&  page <= lastheappage  &&)SH
16308 35095 MT
(space[ page ] == prev_space\051  {)SH
15228 36133 MT
(if \050type[)
540 W( page ] == CONTINUED\051  {)SH
16848 37171 MT
(while \050type[)
540 W( --page ] == CONTINUED\051;)SH
15228 38209 MT
(})SH
9288 39247 MT
(#ifdef DOUBLE_ALIGN)SH
15228 40285 MT
(int pagecount)
540 W( = HEADER_PAGES\050 *\050PAGE_to_GCP\050 page \051+1\051 \051;)SH
9288 41323 MT
(#else)SH
15228 42361 MT
(int pagecount)
540 W( = HEADER_PAGES\050 *PAGE_to_GCP\050 page \051 \051;)SH
9288 43399 MT
(#endif)SH
15228 44437 MT
(if \050gcflags)
540 W( & GCDEBUGLOG\051)SH
16848 45475 MT
(fprintf\050 stderr, "promoted 0x%x\134n", PAGE_to_GCP\050 page \051 \051;)SH
15228 46513 MT
(queue\050 page \051;)SH
15228 47551 MT
(forwardedpages += pagecount;)SH
15228 48589 MT
(if \050gcflags)
540 W( & GCHEAPMAP\051  {)SH
16848 49627 MT
(for \050int)
540 W( i = 0; i < pagecount; i++\051  {)SH
18468 50665 MT
(space[ page+i ] = forw_space;)SH
18468 51703 MT
(page_map\050 page+i \051;)SH
16848 52741 MT
(})SH
15228 53779 MT
(})SH
15228 54817 MT
(else do {)540 W
20088 55855 MT
(space[ page++ ] = forw_space;)SH
18468 56893 MT
(} while)
540 W( \050--pagecount\051;)SH
13608 57931 MT
(})SH
9288 58969 MT
(})SH
13608 61045 MT
(/******************************************)SH
14148 62083 MT
(* Protecting/unprotecting physical pages *)SH
14148 63121 MT
(******************************************/)SH
9288 65197 MT
(/* Test whether a physical page is protected. */)SH
9288 67273 MT
(#define is_physpage_protected\050 addr \051)
SH( \050*\050protect+\050addr>>phys_shift\051\051\051)1080 W
9288 69349 MT
(/* The following routine registers that a physical page is protected. */)SH
9288 71425 MT
(inline static void  physpage_set_protected\050 int addr_physpage \051)SH
10 /Times-Roman AF
30811 75600 MT
(-89-)SH
ES
%%Page: 90 90
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
({)SH
13608 11221 MT
(*\050protect+\050addr_physpage>>phys_shift\051\051 = 1;)SH
13608 12259 MT
(protectedpages++;)SH
9288 13297 MT
(})SH
9288 15373 MT
(/* The following routine registers that a physical page is unprotected. */)SH
9288 17449 MT
(inline static void  physpage_set_unprotected\050 int addr_physpage \051)SH
9288 18487 MT
({)SH
13608 19525 MT
(*\050protect+\050addr_physpage>>phys_shift\051\051 = 0;)SH
13608 20563 MT
(protectedpages--;)SH
9288 21601 MT
(})SH
9288 23677 MT
(#define NO_ACCESS 0)
SH( /*)
1080 W( Page access code \050argument to mprotect\051 */)SH
9288 25753 MT
(/* Inline wrapper for call to mprotect. */)SH
9288 27829 MT
(static inline void call_mprotect\050 void* addr, int numbytes, int protection \051)SH
9288 28867 MT
({)SH
15228 29905 MT
(mprotect\050 addr, numbytes, protection \051;)SH
9288 30943 MT
(})SH
9288 33019 MT
(/* An endangered physical page is one that has to be protected before)SH
10908 34057 MT
(the garbage collector returns control to the application.  The)SH
10908 35095 MT
(following routine marks a physical page as endangered.)SH
9288 36133 MT
(*/)SH
9288 37171 MT
(extern void add_endangered_physpage\050 int addr_physpage \051;)SH
9288 39247 MT
(/* Boolean to indicate whether scanning is going on */)SH
9288 40285 MT
(extern int scanning_physpage;)SH
9288 42361 MT
(/* The following routine protects a physical page and registers it as)SH
10908 43399 MT
(protected.)SH
9288 44437 MT
(*/)SH
9288 45475 MT
(inline static void  protect_physpage\050 int addr_physpage \051)SH
9288 46513 MT
({)SH
13608 47551 MT
(if \050)
540 W( !is_physpage_protected\050 addr_physpage \051 \051 {)SH
15228 48589 MT
(/* if scanning is going on, then delay protecting of)SH
16848 49627 MT
(the physical page.  Mark it as endangered. */)SH
15228 50665 MT
(if \050)
540 W( scanning_physpage \051)SH
16848 51703 MT
(add_endangered_physpage\050 addr_physpage \051;)SH
15228 52741 MT
(else {)SH
16848 53779 MT
(call_mprotect\050 \050void*\051addr_physpage, PHYS_PAGEBYTES, NO_ACCESS \051;)SH
16848 54817 MT
(physpage_set_protected\050 addr_physpage \051;)SH
15228 55855 MT
(})SH
13608 56893 MT
(})SH
9288 57931 MT
(})SH
9288 60007 MT
(/* The following routine unprotects a physical page and registers it as)SH
10908 61045 MT
(unprotected.)SH
9288 62083 MT
(*/)SH
9288 63121 MT
(inline static void  unprotect_physpage\050 int addr_physpage \051)SH
9288 64159 MT
({)SH
13608 65197 MT
(if \050)
540 W( is_physpage_protected\050 addr_physpage \051 \051 {)SH
15228 66235 MT
(call_mprotect\050 \050void*\051addr_physpage, PHYS_PAGEBYTES, PROT_WRITE \051;)SH
15228 67273 MT
(physpage_set_unprotected\050 addr_physpage \051;)SH
13608 68311 MT
(})SH
9288 69349 MT
(})SH
9288 71425 MT
(/* A physical page cluster is the smallest set of contigous pages in the heap)SH
10 /Times-Roman AF
30811 75600 MT
(-90-)SH
ES
%%Page: 91 91
BS
0 SI
9 /Courier-Bold AF
10908 10183 MT
(which needs to be scanned.  The following three functions determine,)SH
10908 11221 MT
(protect and unprotect, respectivenly, the physical page cluster containing)SH
10908 12259 MT
(the specified physical page address.)SH
9288 13297 MT
(*/)SH
9288 15373 MT
(static void  determine_physpage_cluster\050 int& addr_physpage,)SH
31428 16411 MT
(int& num_physpages \051)SH
9288 17449 MT
({)SH
13608 18487 MT
(num_physpages = 1;)SH
13608 19525 MT
(while \050type[)
540 W( ADDR_to_PAGE\050addr_physpage\051 ] != OBJECT\051 {)SH
15228 20563 MT
(addr_physpage -= PHYS_PAGEBYTES;)SH
15228 21601 MT
(num_physpages++;)SH
13608 22639 MT
(})SH
13608 23677 MT
(while \050type[ADDR_to_PAGE\050addr_physpage+PHYS_PAGEBYTES*num_physpages\051])540 W
17928 24715 MT
(!=OBJECT\051)SH
15228 25753 MT
(num_physpages++;)SH
9288 26791 MT
(})SH
9288 28867 MT
(static void  protect_physpage_cluster\050 int addr_physpage, int num_physpages=0 \051)SH
9288 29905 MT
({)SH
13608 30943 MT
(if \050!num_physpages\051)540 W
15228 31981 MT
(determine_physpage_cluster\050 addr_physpage, num_physpages \051;)SH
13608 34057 MT
(if \050num_physpages)
540 W( == 1\051 {)SH
15228 35095 MT
(if \050)
540 W( !is_physpage_protected\050 addr_physpage \051 \051 {)SH
16848 36133 MT
(call_mprotect\050 \050void*\051addr_physpage, PHYS_PAGEBYTES, NO_ACCESS \051;)SH
16848 37171 MT
(physpage_set_protected\050 addr_physpage \051;)SH
15228 38209 MT
(})SH
13608 39247 MT
(})SH
13608 40285 MT
(else {)SH
15228 41323 MT
(for \050;)
540 W( num_physpages > 0;)SH
19548 42361 MT
(num_physpages--, addr_physpage += PHYS_PAGEBYTES\051 {)SH
17388 43399 MT
(if \050)
540 W( !is_physpage_protected\050 addr_physpage \051 \051 {)SH
19008 44437 MT
(call_mprotect\050 \050void*\051addr_physpage,)SH
27108 45475 MT
(num_physpages*PHYS_PAGEBYTES, NO_ACCESS \051;)SH
19008 46513 MT
(break;)SH
17388 47551 MT
(})SH
15228 48589 MT
(})SH
15228 49627 MT
(while \050num_physpages--\051)
540 W( {)SH
16848 50665 MT
(if \050!is_physpage_protected\050)
540 W( addr_physpage \051\051)SH
18468 51703 MT
(physpage_set_protected\050 addr_physpage \051;)SH
16848 52741 MT
(addr_physpage += PHYS_PAGEBYTES;)SH
15228 53779 MT
(})SH
13608 54817 MT
(})SH
9288 55855 MT
(})SH
9288 57931 MT
(static void  unprotect_physpage_cluster\050int addr_physpage,int num_physpages=0\051)SH
9288 58969 MT
({)SH
13608 60007 MT
(if \050num_physpages\051)540 W
15228 61045 MT
(call_mprotect\050 \050void*\051addr_physpage, num_physpages*PHYS_PAGEBYTES,)SH
23328 62083 MT
(PROT_WRITE\051;)SH
13608 63121 MT
(else {)SH
15228 64159 MT
(determine_physpage_cluster\050 addr_physpage, num_physpages \051;)SH
15228 65197 MT
(call_mprotect\050 \050void*\051addr_physpage, num_physpages*PHYS_PAGEBYTES,)SH
23328 66235 MT
(PROT_WRITE \051;)SH
13608 67273 MT
(})SH
13608 68311 MT
(while \050num_physpages--\051)
540 W( {)SH
15228 69349 MT
(if \050)
540 W( is_physpage_protected\050 addr_physpage \051 \051)SH
16848 70387 MT
(physpage_set_unprotected\050 addr_physpage \051;)SH
15228 71425 MT
(addr_physpage += PHYS_PAGEBYTES;)SH
10 /Times-Roman AF
30811 75600 MT
(-91-)SH
ES
%%Page: 92 92
BS
0 SI
9 /Courier-Bold AF
13608 10183 MT
(})SH
9288 11221 MT
(})SH
9288 14335 MT
(/* Test whether two addresses are residing on the same physical page. */)SH
9288 16411 MT
(static inline int  same_physpage\050 int addr_a, int addr_b \051 {)SH
13608 17449 MT
(return \050\050addr_a & phys_pagemask\051 == \050addr_b & phys_pagemask\051\051;)SH
9288 18487 MT
(})SH
9288 20563 MT
(/* Is the address inside the region being scanned? */)SH
9288 22639 MT
(static inline int  inside_scan_region\050 int addr \051 {)SH
13608 23677 MT
(return \050 firstword_to_scan <= addr && addr <= lastword_to_scan \051;)SH
9288 24715 MT
(})SH
9288 26791 MT
(/* The following routine performs collector allocation to allocate a)SH
10908 27829 MT
(free heap page in forward-space.  If space is not available then)SH
10908 28867 MT
(the heap is expanded.)SH
10908 30943 MT
(The argument to allocate_forwpage, badptr, is necessary so that any heap)SH
10908 31981 MT
(page on the physical page that badptr is on will not be allocated.)SH
9288 33019 MT
(*/)SH
9288 35095 MT
(static void  allocate_forwpage\050 GCP badptr \051)SH
9288 36133 MT
({)SH
13608 37171 MT
(int allpages = heapspanpages;)SH
13608 39247 MT
(while \050allpages--\051 {)540 W
15228 40285 MT
(if \050space[)
540 W( forw_freepage ] < prev_space  &&)SH
17928 41323 MT
(UNSTABLE\050 forw_freepage \051 &&)SH
17928 42361 MT
(!same_physpage\050 \050int\051badptr, PAGE_to_ADDR\050forw_freepage\051 \051 &&)SH
17928 43399 MT
(!inside_scan_region\050 PAGE_to_ADDR\050forw_freepage\051 \051\051 {)SH
16848 44437 MT
(forw_freewords = PAGEWORDS;)SH
16848 45475 MT
(allocatedpages++;)SH
16848 46513 MT
(forwardedpages++;)SH
16848 47551 MT
(space[ forw_freepage ] = forw_space;)SH
16848 48589 MT
(type[ forw_freepage ] = OBJECT;)SH
16848 49627 MT
(bzero\050 \050char*\051&firstword[forw_freepage*BIT_WORDS], BIT_BYTES \051;)SH
16848 50665 MT
(forw_freep = PAGE_to_GCP\050 forw_freepage \051;)SH
16848 51703 MT
(if \050gcflags)
540 W( & GCHEAPMAP\051  {)SH
18468 52741 MT
(page_map\050 forw_freepage \051;)SH
16848 53779 MT
(})SH
16848 54817 MT
(queue\050 forw_freepage \051;)SH
16848 55855 MT
(/* SWAP old_forw_freepage and forw_freepage)SH
18468 56893 MT
(to improve locality of stable pages)
SH( */)2700 W
16848 57931 MT
(int temp = old_forw_freepage;)SH
16848 58969 MT
(old_forw_freepage = next_page\050 forw_freepage \051;)SH
16848 60007 MT
(forw_freepage = temp;)SH
16848 61045 MT
(return;)SH
15228 62083 MT
(})SH
15228 63121 MT
(else forw_freepage = next_page\050 forw_freepage \051;)SH
13608 64159 MT
(})SH
13608 65197 MT
(/* Failed to allocate space, keep trying iff heap can expand. */)SH
13608 66235 MT
(if \050expandheap\050\051\051 {)540 W
15228 67273 MT
(allocate_forwpage\050 badptr \051;)SH
15228 68311 MT
(return;)SH
13608 69349 MT
(})SH
13608 70387 MT
(/* Can't do it */)SH
13608 71425 MT
(fprintf\050 stderr, "\134n***** allocate_forwpage  " \051;)SH
10 /Times-Roman AF
30811 75600 MT
(-92-)SH
ES
%%Page: 93 93
BS
0 SI
9 /Courier-Bold AF
13608 10183 MT
(fprintf\050 stderr,)SH
17928 11221 MT
("Unable to allocate %d bytes in a %d byte heap\134n",)SH
18468 12259 MT
(PAGEBYTES, heappages*PAGEBYTES \051;)SH
13608 13297 MT
(abort\050\051;)SH
9288 14335 MT
(})SH
9288 16411 MT
(/* REGISTER_GCMOVE_PROMOTED_PAGES remembers the heap pages that GCMOVE)SH
10908 17449 MT
(promotes inside the scan region.  REGISTER_GCMOVE_PROMOTED_PAGES)SH
10908 18487 MT
(first determines whether the scanning pointer has swept past the newly-)SH
10908 19525 MT
(promoted pages already.  If so, the pages are registered so that they)SH
10908 20563 MT
(will be scanned later; otherwise, these pages are guaranteed to have been)SH
10908 21601 MT
(scanned later on anyway.)SH
9288 22639 MT
(*/)SH
9288 24715 MT
(/* An object is scanned iff it is in the scan region and its address is)SH
10908 25753 MT
(less than the address of the object being scanned \050i.e. scanp\051.)SH
9288 26791 MT
(*/)SH
9288 27829 MT
(#define SCANNED\050 addr \051  \050 addr < int\050scanp\051 \051)SH
9288 29905 MT
(#define MAX_RESCAN_CHUNKS 8)
SH( /*)
4860 W( Max number of chunks to rescan */)SH
9288 30943 MT
(static int)
540 W( rescan_all  = 0;)
SH( /*)
4320 W( Flag to rescan entire scan region */)SH
9288 31981 MT
(static int)
540 W( rescanchunks = 0;)
SH( /*)
3780 W( Chunk count */)SH
9288 33019 MT
(static int)
540 W( rescan1[ MAX_RESCAN_CHUNKS ];  /* Record chunks to rescan */)SH
9288 34057 MT
(static int)
540 W( rescan2[ MAX_RESCAN_CHUNKS ];  /* Alternate with rescan1 */)SH
9288 35095 MT
(static int)
540 W( *rescan = rescan1;)
SH( /*)
6480 W( Ptr to current rescan record */)SH
9288 37171 MT
(static void  register_gcmove_promoted_pages\050 int promoted_page_head \051)SH
9288 38209 MT
({)SH
13608 39247 MT
(if \050rescan_all\051)
540 W( return;)SH
13608 41323 MT
(if \050SCANNED\050)
540 W( PAGE_to_ADDR\050 promoted_page_head \051 \051\051  {)SH
15228 42361 MT
(if \050rescanchunks)
540 W( < MAX_RESCAN_CHUNKS\051)SH
16848 43399 MT
(rescan[ rescanchunks++ ] = promoted_page_head;)SH
15228 44437 MT
(else rescan_all = 1;)SH
13608 45475 MT
(})SH
9288 46513 MT
(})SH
9288 48589 MT
(/* An object is forwarded by the following function.  The forwarded)SH
10908 49627 MT
(object must be protected because it is yet to be scanned.)SH
9288 50665 MT
(*/)SH
9288 52741 MT
(GCP gcmove\050)
540 W( GCP cp \051)SH
9288 53779 MT
({)SH
13608 54817 MT
(int page)
540 W( = GCP_to_PAGE\050 cp \051,)
SH( /*)
10800 W( Page number */)SH
16308 55855 MT
(header, /*)
19440 W( Object header */)SH
16308 56893 MT
(freep_ppaddr = GCP_to_PPADDR\050forw_freep\051;  /* freep's PPADDR */)SH
13608 57931 MT
(GCP np;)
540 W( /*)
15120 W( Pointer to the new object */)SH
13608 58969 MT
(int addr_physpage)
540 W( = 0;)
SH( /*)
4320 W( Object's Physical Page ADDRess */)SH
13608 61045 MT
(/* If out of heap then ok */)SH
13608 62083 MT
(if \050page)
540 W( < firstheappage  ||  page > lastheappage  ||)SH
16308 63121 MT
(space[ page ] == UNALLOCATEDPAGE\051)SH
15228 64159 MT
(return\050 cp \051;)SH
13608 66235 MT
(/* If)
540 W( object in stable storage or in current space then ok */)SH
13608 67273 MT
(if \050STABLE\050)
540 W( page \051 || space[page] == curr_space\051)SH
17928 68311 MT
(return\050 cp \051;)SH
13608 70387 MT
(if \050)
540 W( space[page] != prev_space \051 {)SH
15228 71425 MT
(fprintf\050stderr,)SH
10 /Times-Roman AF
30811 75600 MT
(-93-)SH
ES
%%Page: 94 94
BS
0 SI
9 /Courier-Bold AF
19548 10183 MT
("gcmove: space[%d] = %d, cp = 0x%x, prev_space %d\134n",)SH
19548 11221 MT
(page, space[page], cp, prev_space\051;)SH
15228 12259 MT
(abort\050\051;)SH
13608 13297 MT
(})SH
13608 15373 MT
(/* Check for a derived pointer */)SH
13608 16411 MT
(if \050\050\050int\051cp\051)
540 W( & 3  ||  ISA_FIRSTWORD\050 cp \051 == 0\051  {)SH
15228 17449 MT
(while \050type[)
540 W( page ] == CONTINUED\051  page--;)SH
15228 18487 MT
(GCP p1,)
540 W( p2 = PAGE_to_GCP\050 page \051;)SH
15228 19525 MT
(if \050gcflags)
540 W( & GCTSTOBJ\051  verify_object\050 p2, 1 \051;)SH
15228 20563 MT
(while \050p2)
540 W( < cp\051  {)SH
16848 21601 MT
(p1 = p2;)SH
16848 22639 MT
(p2 = next_object\050 p2 \051;)SH
15228 23677 MT
(})SH
15228 24715 MT
(return \050GCP\051\050\050char*\051gcmove\050 p1+1 \051+\050\050char*\051cp-\050char*\051\050p1+1\051\051\051;)SH
13608 25753 MT
(})SH
13608 27829 MT
(/* Object maybe protected */)SH
13608 28867 MT
(if \050!inside_scan_region\050\050int\051cp\051)
540 W( && is_physpage_protected\050\050int\051cp\051\051 {)SH
15228 29905 MT
(addr_physpage = GCP_to_PPADDR\050 cp \051;)SH
15228 30943 MT
(unprotect_physpage\050 addr_physpage \051;)SH
15228 31981 MT
(/* Addr_physpage must be reprotected on exit from gcmove */)SH
13608 33019 MT
(})SH
13608 35095 MT
(/* Verify that the object is a valid pointer and decrement ptr cnt */)SH
13608 36133 MT
(if \050gcflags\051 {)540 W
15228 37171 MT
(if \050gcflags)
540 W( & GCTSTOBJ\051  verify_object\050 cp, 1 \051;)SH
15228 38209 MT
(if \050gcflags)
540 W( & GCGUESSPTRS\051  guess_pointer_count--;)SH
13608 39247 MT
(})SH
13608 41323 MT
(/* If cell is already forwarded, return forwarding pointer */)SH
13608 42361 MT
(header = cp[-1];)SH
13608 43399 MT
(if \050FORWARDED\050)
540 W( header \051\051  {)SH
15228 44437 MT
(if \050gcflags)
540 W( & GCTSTOBJ\051  {)SH
16848 45475 MT
(verify_object\050 \050GCP\051header, 0 \051;)SH
16848 46513 MT
(verify_header\050 \050GCP\051header \051;)SH
15228 47551 MT
(})SH
15228 48589 MT
(if \050addr_physpage\051)
540 W( {)SH
16848 49627 MT
(protect_physpage\050 addr_physpage \051;)SH
15228 50665 MT
(})SH
15228 51703 MT
(return\050 \050GCP\051header \051;)SH
13608 52741 MT
(})SH
13608 54817 MT
(/* Move the object */)SH
13608 55855 MT
(if \050gcflags)
540 W( & GCTSTOBJ\051  {)SH
15228 56893 MT
(verify_header\050 cp \051;)SH
13608 57931 MT
(})SH
13608 58969 MT
(int freep_outside_scan_region=!inside_scan_region\050\050int\051forw_freep\051;)SH
13608 61045 MT
(/* Forward or promote object */)SH
13608 62083 MT
(int words)
540 W( = HEADER_WORDS\050 header \051;)SH
13608 63121 MT
(if \050words)
540 W( >= forw_freewords\051 {)SH
15228 65197 MT
(/* Objects >= a page are promoted to the stable set */)SH
15228 66235 MT
(if \050words)
540 W( >= ONEPAGEOBJ_WORDS\051  {)SH
16848 67273 MT
(int pagecount = HEADER_PAGES\050 *\050cp-1\051 \051;)SH
16848 68311 MT
(forwardedpages += pagecount;)SH
16848 69349 MT
(queue\050 page \051;)SH
16848 70387 MT
(for \050int)
540 W( i = 0; i < pagecount; i++\051)SH
19008 71425 MT
(space[ page+i ] = forw_space;)SH
10 /Times-Roman AF
30811 75600 MT
(-94-)SH
ES
%%Page: 95 95
BS
0 SI
9 /Courier-Bold AF
16848 10183 MT
(if \050)
540 W( inside_scan_region\050 PAGE_to_ADDR\050page\051 \051 \051)SH
18468 11221 MT
(register_gcmove_promoted_pages\050 page \051;)SH
16848 12259 MT
(else {)SH
21168 13297 MT
(protect_physpage_cluster\050 PAGE_to_PPADDR\050 page \051 \051;)SH
16848 14335 MT
(})SH
16848 15373 MT
(if \050gcflags)
540 W( & GCHEAPMAP\051 {)SH
18468 16411 MT
(for \050int)
540 W( i = 0; i < pagecount; i++\051)SH
20628 17449 MT
(page_map\050 page+i \051;)SH
16848 18487 MT
(})SH
16848 19525 MT
(if \050addr_physpage\051)
540 W( {)SH
18468 20563 MT
(protect_physpage\050 addr_physpage \051;)SH
16848 21601 MT
(})SH
16848 22639 MT
(return\050 cp \051;)SH
15228 23677 MT
(})SH
15228 25753 MT
(/* Discard any partial page and allocate a new one */)SH
15228 26791 MT
(if \050forw_freewords)
540 W( != 0\051  {)SH
16848 27829 MT
(if \050)
540 W( freep_outside_scan_region &&)SH
20088 28867 MT
(is_physpage_protected\050 freep_ppaddr \051 &&)SH
19548 29905 MT
(!same_physpage\050 \050int\051cp, freep_ppaddr \051 \051 {)SH
18468 30943 MT
(unprotect_physpage\050 freep_ppaddr \051;)SH
18468 31981 MT
(*forw_freep = MAKE_HEADER\050forw_freewords, freespace_callback\051;)SH
18468 33019 MT
(forw_freewords = 0;)SH
18468 34057 MT
(protect_physpage\050 freep_ppaddr \051;)SH
16848 35095 MT
(})SH
16848 36133 MT
(else {  /* No need to unprotect/protect forw_freep */)SH
18468 37171 MT
(*forw_freep = MAKE_HEADER\050forw_freewords, freespace_callback\051;)SH
18468 38209 MT
(forw_freewords = 0;)SH
16848 39247 MT
(})SH
15228 40285 MT
(})SH
15228 41323 MT
(allocate_forwpage\050 cp \051;)SH
15228 42361 MT
(freep_outside_scan_region=!inside_scan_region\050\050int\051forw_freep\051;)SH
15228 43399 MT
(freep_ppaddr = GCP_to_PPADDR\050forw_freep\051;)SH
9288 45475 MT
(#ifdef DOUBLE_ALIGN)SH
15228 46513 MT
(if \050)
540 W( freep_outside_scan_region &&)SH
18468 47551 MT
(is_physpage_protected\050 freep_ppaddr \051\051 {)SH
16848 48589 MT
(unprotect_physpage\050 freep_ppaddr \051;)SH
15228 49627 MT
(})SH
15228 50665 MT
(*forw_freep = doublepad;)SH
15228 51703 MT
(forw_freewords--;)SH
15228 52741 MT
(forw_freep++;)SH
15228 53779 MT
(goto forward_object;)SH
9288 54817 MT
(#endif)SH
13608 56893 MT
(} /*)
540 W( end if \050words >= forw_freewords\051 */)SH
13608 58969 MT
(/* Forward object, leave forwarding pointer in old object header */)SH
13608 61045 MT
(if \050)
540 W( freep_outside_scan_region &&)SH
16848 62083 MT
(is_physpage_protected\050 freep_ppaddr \051 \051  {)SH
15228 63121 MT
(unprotect_physpage\050 freep_ppaddr \051;)SH
13608 64159 MT
(})SH
9288 65197 MT
(forward_object:)SH
13608 66235 MT
(*forw_freep++ = header;)SH
13608 67273 MT
(np = forw_freep;)SH
13608 68311 MT
(SET_FIRSTWORD\050 forw_freep \051;)SH
13608 69349 MT
(cp[-1] = \050int\051np;)SH
13608 70387 MT
(forw_freewords -= words;)SH
13608 71425 MT
(while \050--words\051 *forw_freep++)
540 W( = *cp++;)SH
10 /Times-Roman AF
30811 75600 MT
(-95-)SH
ES
%%Page: 96 96
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
(#ifdef DOUBLE_ALIGN)SH
13608 11221 MT
(if \050\050forw_freewords)
540 W( & 1\051 == 0  &&  forw_freewords\051  {)SH
15228 12259 MT
(*forw_freep = doublepad;)SH
15228 13297 MT
(forw_freewords--;)SH
15228 14335 MT
(forw_freep++;)SH
13608 15373 MT
(})SH
9288 16411 MT
(#endif)SH
13608 17449 MT
(if \050)
540 W( freep_outside_scan_region \051  {)SH
15228 18487 MT
(protect_physpage\050 freep_ppaddr \051;)SH
13608 19525 MT
(})SH
13608 20563 MT
(if \050addr_physpage\051)
540 W( {)SH
15228 21601 MT
(protect_physpage\050 addr_physpage \051;)SH
13608 22639 MT
(})SH
13608 23677 MT
(return\050 np \051;)SH
9288 24715 MT
(})SH
9288 26791 MT
(/* Pages that have been remembered with REGISTER_GCMOVE_PROMOTED_PAGES)SH
10908 27829 MT
(are re-scanned by the following function.)SH
9288 28867 MT
(*/)SH
9288 30943 MT
(static void rescan_gcmove_promoted_pages\050\051)SH
9288 31981 MT
({)SH
13608 33019 MT
(int chunks = rescanchunks;)SH
13608 34057 MT
(rescanchunks = 0;)SH
13608 35095 MT
(int *rescan_record = rescan;)SH
13608 37171 MT
(/* Reset RESCAN to point to unused array */)SH
13608 38209 MT
(rescan = \050 int\050rescan\051 == int\050rescan2\051 \051 ? rescan1 : rescan2;)SH
13608 40285 MT
(GCP cp, nextcp;)SH
13608 41323 MT
(for \050int)
540 W( i=0; i < chunks; i++\051 {)SH
15768 42361 MT
(cp = PAGE_to_GCP\050 rescan_record[ i ] \051;)SH
15768 43399 MT
(nextcp = cp+PAGEWORDS;)SH
9288 44437 MT
(#ifdef DOUBLE_ALIGN)SH
15768 45475 MT
(cp++; //)
2700 W( skip over doublepad word)SH
9288 46513 MT
(#endif)SH
15768 47551 MT
(while \050)
540 W( cp < nextcp &&)SH
20088 48589 MT
(\050cp != forw_freep  || forw_freewords == 0\051\051 {)SH
17388 49627 MT
(\050*callbacks[ HEADER_CALLBACK\050 *cp \051 ].proc\051\050 cp+1 \051;)SH
17388 50665 MT
(cp = cp+HEADER_WORDS\050 *cp \051;)SH
15768 51703 MT
(})SH
13608 52741 MT
(})SH
9288 53779 MT
(})SH
9288 55855 MT
(/* To optimize performance mprotect calls are to be avoided as much as)SH
10908 56893 MT
(possible. The)
540 W( following routines implements efficient synchronization)SH
10908 57931 MT
(between SCAN_PHYSPAGE_CLUSTER and GCMOVE, such that physical pages)SH
10908 58969 MT
(unprotected in GCMOVE are not reprotected until program control is)SH
10908 60007 MT
(about to exit SCAN_PHYSPAGE_CLUSTER.)SH
9288 61045 MT
(*/)SH
9288 63121 MT
(/* Number of physical pages that are endangered */)SH
9288 65197 MT
(static int endangered_physpages=0;)SH
9288 67273 MT
(/* The data structure to hold the addresses of those physical pages that)SH
10908 68311 MT
(need to be reprotected before scanning ends.)SH
9288 69349 MT
(*/)SH
9288 70387 MT
(const NELEMS)
540 W( = 10;)SH
10 /Times-Roman AF
30811 75600 MT
(-96-)SH
ES
%%Page: 97 97
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
(static struct  array_elem {)SH
13608 11221 MT
(struct array_elem *next_array_elem;)SH
13608 12259 MT
(int array[ NELEMS ];)SH
9288 13297 MT
(} *endangered_head, *endangered;)SH
9288 15373 MT
(/* The following routine creates the endangered data structure. */)SH
9288 17449 MT
(static void setup_endangered_rec\050\051)SH
9288 18487 MT
({)SH
13608 19525 MT
(endangered_head = endangered = new array_elem\050\051;)SH
9288 20563 MT
(})SH
9288 22639 MT
(/* The following function enters a physical page into the set of)SH
10908 23677 MT
(endangered physical pages.)SH
9288 24715 MT
(*/)SH
9288 26791 MT
(static void add_endangered_physpage\050 int ppaddr \051)SH
9288 27829 MT
({)SH
13608 28867 MT
(if \050)
540 W( endangered->array[\050endangered_physpages-1\051%NELEMS] == ppaddr ||)SH
16308 29905 MT
(\050endangered_physpages%NELEMS > 1 ?)SH
16848 30943 MT
(endangered->array[\050endangered_physpages-2\051%NELEMS] : 0\051)SH
16308 31981 MT
(== ppaddr \051)SH
15228 33019 MT
(return;)SH
13608 35095 MT
(endangered->array[ endangered_physpages%NELEMS ] = ppaddr;)SH
13608 37171 MT
(if \050)
540 W( ++endangered_physpages%NELEMS == 0 \051 {)SH
15228 38209 MT
(endangered->next_array_elem = new array_elem\050\051;)SH
15228 39247 MT
(endangered = endangered->next_array_elem;)SH
15228 40285 MT
(endangered->next_array_elem = NULL;)SH
13608 41323 MT
(})SH
9288 42361 MT
(})SH
9288 44437 MT
(/* The following function reprotects all the endangered physical pages.)SH
10908 45475 MT
(It is called right before scanning exits and the application is about)SH
10908 46513 MT
(to resume execution.)SH
9288 47551 MT
(*/)SH
9288 49627 MT
(static void reprotect_endangered_physpages\050\051)SH
9288 50665 MT
({)SH
13608 51703 MT
(for \050)
540 W( endangered = endangered_head;)SH
17388 52741 MT
(endangered != NULL;)SH
17388 53779 MT
(endangered = endangered->next_array_elem \051 {)SH
15768 55855 MT
(for \050int)
540 W( i=0; i < NELEMS && endangered_physpages-- != 0; i++\051)SH
17928 56893 MT
(protect_physpage\050endangered->array[ i ]\051;)SH
13608 57931 MT
(})SH
13608 60007 MT
(if \050endangered_physpages)
540 W( != -1\051 abort\050\051;)SH
13608 61045 MT
(endangered_physpages = 0;)SH
13608 62083 MT
(endangered = endangered_head;)SH
13608 63121 MT
(endangered->next_array_elem = NULL;)SH
9288 64159 MT
(})SH
9288 66235 MT
(/* The following is a boolean variable indicating whether program)SH
10908 67273 MT
(control inside SCAN_PHYSPAGE_CLUSTER.)SH
9288 68311 MT
(*/)SH
9288 69349 MT
(int scanning_physpage = 0;)SH
9288 71425 MT
(/* The following function scans one physical page cluster. */)SH
10 /Times-Roman AF
30811 75600 MT
(-97-)SH
ES
%%Page: 98 98
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
(static int  scan_physpage_cluster\050 int addr_physpage \051)SH
9288 11221 MT
({)SH
13608 12259 MT
(scanning_physpage = 1;)SH
13608 14335 MT
(/* Find and unprotect the physical page cluster region */)SH
13608 15373 MT
(int num_physpages;)SH
13608 16411 MT
(determine_physpage_cluster\050 addr_physpage, num_physpages \051;)SH
13608 17449 MT
(firstword_to_scan=addr_physpage;)SH
13608 18487 MT
(lastword_to_scan=addr_physpage+num_physpages*PHYS_PAGEBYTES-BIT_WORDS;)SH
13608 19525 MT
(unprotect_physpage_cluster\050 firstword_to_scan, num_physpages \051;)SH
13608 21601 MT
(/* Scan the cluster */)SH
13608 22639 MT
(GCP nextscanp;)SH
9288 23677 MT
(rescan_physpage_cluster:)SH
13608 24715 MT
(for \050int)
540 W( page =  ADDR_to_PAGE\050firstword_to_scan\051;)SH
19008 25753 MT
(page <= ADDR_to_PAGE\050 lastword_to_scan\051;)SH
19008 26791 MT
(page++ \051 {)SH
15768 27829 MT
(if \050STABLE\050)
540 W( page \051 && type[ page ] == OBJECT\051 {)SH
17388 28867 MT
(scanp = PAGE_to_GCP\050 page \051;)SH
17388 29905 MT
(nextscanp = scanp+PAGEWORDS;)SH
9288 30943 MT
(#ifdef DOUBLE_ALIGN)SH
17388 31981 MT
(scanp++; //)
2700 W( skip over doublepad word)SH
9288 33019 MT
(#endif)SH
17388 34057 MT
(while \050)
540 W( scanp < nextscanp &&)SH
21708 35095 MT
(\050scanp != forw_freep  || forw_freewords == 0\051\051 {)SH
19008 36133 MT
(\050*callbacks[ HEADER_CALLBACK\050 *scanp \051 ].proc\051\050 scanp+1 \051;)SH
19008 37171 MT
(scanp = scanp+HEADER_WORDS\050 *scanp \051;)SH
17388 38209 MT
(})SH
15768 39247 MT
(})SH
13608 40285 MT
(})SH
13608 42361 MT
(/* Check if rescanning is necessary */)SH
13608 43399 MT
(while \050rescanchunks\051)
540 W( {)SH
15228 44437 MT
(if \050rescan_all\051 {)540 W
16848 45475 MT
(rescan_all = 0;)SH
16848 46513 MT
(goto rescan_physpage_cluster;)SH
15228 47551 MT
(})SH
15228 48589 MT
(else rescan_gcmove_promoted_pages\050\051;)SH
13608 49627 MT
(})SH
13608 50665 MT
(firstword_to_scan = lastword_to_scan = NULL;)SH
13608 52741 MT
(scanning_physpage = 0;)SH
13608 53779 MT
(reprotect_endangered_physpages\050\051;)SH
13608 55855 MT
(return num_physpages;)SH
9288 56893 MT
(})SH
9288 58969 MT
(/* When incremental collection is going on, the following function)SH
10908 60007 MT
(is called to scan "target" number of physical pages.)SH
9288 61045 MT
(*/)SH
9288 63121 MT
(int scan_few_physpages\050)
540 W( int target \051)SH
9288 64159 MT
({)SH
13608 65197 MT
(int addr_physpage,)
SH( //)
1080 W( Address of physical page being scanned)SH
15768 66235 MT
(num_physpages, //)
1080 W( Number of physical pages scanned so far)SH
15768 67273 MT
(sum = 0;)
SH( //)
4320 W( Total number of physical pages scanned)SH
13608 69349 MT
(while \050target)
540 W( > 0 && protectedpages\051 {)SH
15768 70387 MT
(for \050addr_physpage)
540 W( = PAGE_to_ADDR\050 firstheappage \051;)SH
19008 71425 MT
(addr_physpage < PAGE_to_ADDR\050 lastheappage \051 && target > 0;)SH
10 /Times-Roman AF
30811 75600 MT
(-98-)SH
ES
%%Page: 99 99
BS
0 SI
9 /Courier-Bold AF
19008 10183 MT
(addr_physpage += PHYS_PAGEBYTES\051 {)SH
17928 11221 MT
(if \050)
540 W( is_physpage_protected\050 addr_physpage \051 \051  {)SH
19548 12259 MT
(if \050space[ADDR_to_PAGE\050addr_physpage\051] == UNALLOCATEDPAGE\051)SH
21168 13297 MT
(abort\050\051;)SH
19548 14335 MT
(num_physpages = scan_physpage_cluster\050 addr_physpage \051;)SH
19548 15373 MT
(sum += num_physpages;)SH
19548 16411 MT
(target -= num_physpages;)SH
17928 17449 MT
(})SH
15768 18487 MT
(})SH
13608 19525 MT
(})SH
13608 20563 MT
(firstword_to_scan = lastword_to_scan = NULL;)SH
13608 21601 MT
(return sum;)SH
9288 22639 MT
(})SH
9288 24715 MT
(/* During incremental collection, physical pages where unscanned objects)SH
10908 25753 MT
(are found need to be protected.  Whenever user application accesses one of)SH
10908 26791 MT
(these pages, a page fault occurs.)
SH( The)
1080 W( following function is the trap)SH
10908 27829 MT
(handler set up to handle these page faults.  The faulted physical page)SH
10908 28867 MT
(cluster is unprotected and scanned before becoming accessible to the)SH
11448 29905 MT
(user again.)SH
9288 30943 MT
(*/)SH
9288 33019 MT
(static void  page_fault_handler\050 int sig, int code, struct sigcontext *scp \051)SH
9288 34057 MT
({)SH
9288 35095 MT
(#ifdef mips)SH
13608 36133 MT
(int faulted_addr = scp->sc_badvaddr;)SH
9288 37171 MT
(#endif)SH
9288 38209 MT
(#ifdef vax)SH
13608 39247 MT
(int faulted_addr = code;)SH
9288 40285 MT
(#endif)SH
13608 41323 MT
(int faulted_physpage = GCP_to_PPADDR\050 faulted_addr \051,)SH
15768 42361 MT
(faulted_page = ADDR_to_PAGE\050 faulted_addr \051,)SH
15768 43399 MT
(error = 0;)SH
13608 45475 MT
(/* Non-incremental mode should NOT cause page fault */)SH
13608 46513 MT
(if \050gcflags)
540 W( & GCNOINC\051 goto fail;)SH
13608 47551 MT
(error = 1;)SH
13608 48589 MT
(/* Error if not garbage collecting */)SH
13608 49627 MT
(if \050curr_space)
540 W( == forw_space\051 goto fail;)SH
13608 50665 MT
(error = 2;)SH
13608 51703 MT
(/* Error if faulted address is outside of heap */)SH
13608 52741 MT
(if \050)
540 W( faulted_page < firstheappage || faulted_page > lastheappage\051)SH
15228 53779 MT
(goto fail;)SH
13608 54817 MT
(error = 3;)SH
13608 56893 MT
(/* Finally, go ahead and scan the physical page cluster */)SH
13608 57931 MT
(scan_physpage_cluster\050 faulted_physpage \051;)SH
13608 58969 MT
(return;)SH
9288 61045 MT
(fail:)SH
13608 62083 MT
(fprintf\050 stderr,)SH
17928 63121 MT
("**** Page fault  error: %d  badaddr 0x%x\134n",)SH
17928 64159 MT
(error, faulted_addr \051;)SH
13608 65197 MT
(abort\050\051;)SH
9288 66235 MT
(})SH
9288 68311 MT
(/* Output a newline to stderr if logging is enabled. */)SH
9288 70387 MT
(void newline_if_logging\050\051)540 W
9288 71425 MT
({)SH
10 /Times-Roman AF
30811 75600 MT
(-99-)SH
ES
%%Page: 100 100
BS
0 SI
9 /Courier-Bold AF
13608 10183 MT
(if \050gcflags)
540 W( & \050GCDEBUGLOG | GCROOTLOG | GCHEAPLOG | GCGUESSPTRS\051\051)SH
15228 11221 MT
(fprintf\050 stderr, "\134n" \051;)SH
9288 12259 MT
(})SH
9288 14335 MT
(/* A root is logged to stderr by the following function. */)SH
9288 16411 MT
(static void  log_root\050 unsigned* fp \051)SH
9288 17449 MT
({)SH
13608 18487 MT
(int page)
540 W( = GCP_to_PAGE\050 fp \051;)SH
13608 19525 MT
(if \050page)
540 W( < firstheappage  ||  page > lastheappage  ||)SH
16308 20563 MT
(space[ page ] == UNALLOCATEDPAGE  ||)SH
16308 21601 MT
(\050UNSTABLE\050 page \051  &&  space[ page ] != curr_space\051\051)SH
15228 22639 MT
(return;)SH
13608 23677 MT
(while \050type[)
540 W( page ] == CONTINUED\051  page--;)SH
13608 24715 MT
(GCP p1,)
540 W( p2 = PAGE_to_GCP\050 page \051;)SH
13608 25753 MT
(while \050p2)
540 W( < \050GCP\051fp\051  {)SH
15228 26791 MT
(p1 = p2;)SH
15228 27829 MT
(p2 = next_object\050 p2 \051;)SH
13608 28867 MT
(})SH
13608 29905 MT
(fprintf\050 stderr, "***** gcalloc  root&: 0x%x  object&: 0x%x  %s\134n",)SH
18468 30943 MT
(fp, p1, callbacks[ HEADER_CALLBACK\050 *\050p1\051 \051 ].type \051;)SH
9288 31981 MT
(})SH
9288 34057 MT
(/* Log the memory use statistics on stderr. */)SH
9288 36133 MT
(static void  memory_stats\050\051)SH
9288 37171 MT
({)SH
13608 38209 MT
(GCP cp;)540 W
13608 39247 MT
(int page)
540 W( = firstheappage-1;)SH
13608 41323 MT
(for \050int)
540 W( i = 0; i < callbacks_count; i++\051  {)SH
15228 42361 MT
(callbacks[ i ].number = 0;)SH
15228 43399 MT
(callbacks[ i ].bytes = 0;)SH
13608 44437 MT
(})SH
13608 45475 MT
(while \050++page)
540 W( <= lastheappage\051  {)SH
15228 46513 MT
(if \050\050space[)
540 W( page ] == curr_space  ||)SH
18468 47551 MT
(\050STABLE\050 page \051  &&  space[ page ] != UNALLOCATEDPAGE\051\051)SH
17928 48589 MT
(&& type[)
540 W( page ] == OBJECT\051  {)SH
16848 49627 MT
(cp = PAGE_to_GCP\050 page \051;)SH
16848 50665 MT
(while \050GCP_to_PAGE\050)
540 W( cp \051 == page  &&)SH
21168 51703 MT
(\050cp != curr_freep  || curr_freewords == 0\051\051  {)SH
18468 52741 MT
(int x)
540 W( = HEADER_CALLBACK\050 *cp \051,)SH
21168 53779 MT
(words = HEADER_WORDS\050 *cp \051;)SH
18468 54817 MT
(callbacks[ x ].number++;)SH
18468 55855 MT
(callbacks[ x ].bytes += HEADER_BYTES\050 *cp \051;)SH
18468 56893 MT
(if \050words)
540 W( > ONEPAGEOBJ_WORDS\051  {)SH
20088 57931 MT
(int free)
540 W( = HEADER_PAGES\050 *cp \051*PAGEBYTES-)SH
26568 58969 MT
(HEADER_BYTES\050 *cp \051;)SH
20088 61045 MT
(if \050free\051 {)540 W
21708 62083 MT
(callbacks[ 0 ].number++;)SH
21708 63121 MT
(callbacks[ 0 ].bytes += free;)SH
20088 64159 MT
(})SH
18468 65197 MT
(})SH
18468 66235 MT
(cp = cp+words;)SH
16848 67273 MT
(})SH
15228 68311 MT
(})SH
13608 69349 MT
(})SH
13608 70387 MT
(fprintf\050 stderr, "***** gcalloc  number)
SH( bytes)
2160 W( type\134n")
540 W( \051;)SH
13608 71425 MT
(for \050i)
540 W( = 0; i < callbacks_count; i++\051  {)SH
10 /Times-Roman AF
30561 75600 MT
(-100-)SH
ES
%%Page: 101 101
BS
0 SI
9 /Courier-Bold AF
15228 10183 MT
(fprintf\050 stderr, ")
SH( %6d)
7560 W( %8d %s\134n",)540 W
20088 11221 MT
(callbacks[ i ].number, callbacks[ i ].bytes,)SH
20088 12259 MT
(callbacks[ i ].type \051;)SH
13608 13297 MT
(})SH
9288 14335 MT
(})SH
9288 16411 MT
(/* When incremental collection is over, the following function is called)SH
10908 17449 MT
(to perform miscellaneous accounting and bookkeeping tasks.)SH
9288 18487 MT
(*/)SH
9288 19525 MT
(extern void  gcwrapup\050\051;)SH
9288 21601 MT
(/* Garbage collection is initiated by the following procedure.  It is)SH
10908 22639 MT
(typically called when one-third of the pages in the heap have been)SH
10908 23677 MT
(allocated. It)
540 W( may also be directly called.)SH
9288 24715 MT
(*/)SH
9288 26791 MT
(static unsigned  registers[ REGISTER_COUNT ];)
SH( /*)
1080 W( Ambiguous registers */)SH
9288 28867 MT
(void gccollect\050\051)540 W
9288 29905 MT
({)SH
13608 30943 MT
(unsigned *fp;)
540 W( /*)
3240 W( Pointer for checking the stack */)SH
13608 31981 MT
(int page,)SH
15768 33019 MT
(freepages=0; /*)
2160 W( # of free heap pages */)SH
13608 35095 MT
(/* Check for heap not yet allocated */)SH
13608 36133 MT
(if \050gcheapcreated)
540 W( == 0\051  {)SH
15228 37171 MT
(gcinit\050\051;)SH
15228 38209 MT
(return;)SH
13608 39247 MT
(})SH
13608 40285 MT
(/* Log entry to the collector */)SH
13608 41323 MT
(if \050gcflags)
540 W( & GCSTATS\051  {)SH
15228 42361 MT
(fprintf\050 stderr, "***** gcalloc  Collecting - %d%% allocated -> \134n",)SH
20088 43399 MT
(HEAPPERCENT\050 allocatedpages \051 \051;)SH
15228 44437 MT
(newline_if_logging\050\051;)SH
13608 45475 MT
(})SH
13608 47551 MT
(/* Scan a few pages and return if already collecting */)SH
13608 48589 MT
(if \050curr_space)
540 W( != forw_space\051 {)SH
15228 49627 MT
(scan_few_physpages\050 1 \051;)SH
15228 50665 MT
(return;)SH
13608 51703 MT
(})SH
13608 53779 MT
(/* Discard any remaining portion of current page */)SH
13608 54817 MT
(if \050curr_freewords)
540 W( != 0\051  {)SH
15228 55855 MT
(*curr_freep = MAKE_HEADER\050 curr_freewords, freespace_callback \051;)SH
15228 56893 MT
(curr_freewords = 0;)SH
13608 57931 MT
(})SH
13608 60007 MT
(/* Verify that heap is consistent */)SH
13608 61045 MT
(if \050gcflags & GCDEBUGLOG\051 verify_heap\050\051;)SH
13608 63121 MT
(/* Partition regions for forwarded and newly-allocated objects */)SH
13608 64159 MT
(forw_freepage = old_forw_freepage = curr_freepage;)SH
13608 65197 MT
(forw_freep = curr_freep = PAGE_to_GCP\050 curr_freepage \051;)SH
13608 67273 MT
(/* Advance curr_freep so that _if possible_, there will be)SH
15228 68311 MT
("RESERVEDPAGES" number of free heap pages in "forward" region */)SH
13608 69349 MT
(page = forw_freepage;)SH
13608 70387 MT
(freepages = 0;)SH
13608 71425 MT
(for \050)
540 W( int i=0; freepages<=RESERVEDPAGES && i<physspanpages; i++ \051 {)SH
10 /Times-Roman AF
30561 75600 MT
(-101-)SH
ES
%%Page: 102 102
BS
0 SI
9 /Courier-Bold AF
16848 10183 MT
(if \050)
540 W( UNSTABLE\050page\051 && space[page] != curr_space \051 ++freepages;)SH
16848 11221 MT
(page = next_page\050 page \051;)SH
13608 12259 MT
(})SH
13608 13297 MT
(curr_freep = \050GCP\051PAGE_to_PPADDR\050 page \051;)SH
13608 14335 MT
(curr_freepage = GCP_to_PAGE\050 curr_freep \051;)SH
13608 16411 MT
(/* Change headers on heap display */)SH
13608 17449 MT
(if \050gcflags)
540 W( & GCHEAPMAP\051)SH
15228 18487 MT
(display_headers\050 "Starting Garbage Collection" \051;)SH
13608 20563 MT
(/* Advance space */)SH
13608 21601 MT
(currentpages = 0;)SH
13608 22639 MT
(forw_space = curr_space+1;)SH
13608 23677 MT
(curr_space = curr_space+2;)SH
13608 25753 MT
(/* Examine stack, registers, static area and possibly the non-garbage)SH
15228 26791 MT
(collected heap for possible pointers */)SH
13608 27829 MT
(if \050gcflags)
540 W( & GCROOTLOG\051  fprintf\050 stderr, "stack roots:\134n" \051;)SH
13608 28867 MT
(for \050fp = gcregisters\050 registers \051 ;)SH
16308 29905 MT
(fp < \050unsigned*\051STACKBASE ;)SH
16308 30943 MT
(fp = \050unsigned*\051\050\050\050char*\051fp\051+STACKINC\051 \051  {)SH
15228 31981 MT
(if \050gcflags)
540 W( & GCROOTLOG\051  log_root\050 fp \051;)SH
15228 33019 MT
(promote_page\050 GCP_to_PAGE\050 *fp \051 \051;)SH
13608 34057 MT
(})SH
13608 35095 MT
(if \050gcflags)
540 W( & GCROOTLOG\051)SH
15228 36133 MT
(fprintf\050 stderr, "static and register roots:\134n" \051;)SH
13608 37171 MT
(for \050fp)
540 W( = STATIC_0 ; fp < STATIC_1 ; fp++\051  {)SH
15228 38209 MT
(if \050gcflags)
540 W( & GCROOTLOG\051  log_root\050 fp \051;)SH
15228 39247 MT
(promote_page\050 GCP_to_PAGE\050 *fp \051 \051;)SH
13608 40285 MT
(})SH
13608 41323 MT
(if \050gcflags)
540 W( & GCHEAPROOTS  ||  gcflags & GCHEAPLOG\051  {)SH
15228 42361 MT
(if \050gcflags)
540 W( & GCHEAPLOG\051)SH
16848 43399 MT
(fprintf\050 stderr, "non-GC heap roots:\134n" \051;)SH
15228 44437 MT
(unsigned* heapend)
540 W( = \050unsigned*\051sbrk\050 0 \051;)SH
15228 45475 MT
(unsigned* firstheapp)
540 W( = \050unsigned*\051PAGE_to_GCP\050 firstheappage \051;)SH
15228 46513 MT
(unsigned* lastheapp)
540 W( = \050unsigned*\051PAGE_to_GCP\050 lastheappage \051;)SH
15228 47551 MT
(while \050fp)
540 W( < heapend\051  {)SH
16848 48589 MT
(if \050fp)
540 W( < firstheapp  ||  fp > lastheapp  ||)SH
19548 49627 MT
(space[ GCP_to_PAGE\050 fp \051 ] == UNALLOCATEDPAGE\051  {)SH
18468 50665 MT
(if \050gcflags)
540 W( & GCHEAPLOG\051  log_root\050 fp \051;)SH
18468 51703 MT
(if \050gcflags)
540 W( & GCHEAPROOTS\051)SH
20088 52741 MT
(promote_page\050 GCP_to_PAGE\050 *fp \051 \051;)SH
18468 53779 MT
(fp++;)SH
16848 54817 MT
(})SH
16848 55855 MT
(else {)540 W
18468 56893 MT
(fp = fp+PAGEWORDS;)SH
16848 57931 MT
(})SH
15228 58969 MT
(})SH
13608 60007 MT
(})SH
13608 62083 MT
(/* Ambiguous roots have been promoted, now protect all the)SH
15228 63121 MT
(promoted \050stable\051 pages */)SH
13608 64159 MT
(page = queue_head;)SH
13608 65197 MT
(while \050page\051 {)540 W
15228 66235 MT
(protect_physpage_cluster\050 PAGE_to_PPADDR\050page\051 \051;)SH
15228 67273 MT
(page = plink[ page ];)SH
13608 68311 MT
(})SH
13608 70387 MT
(if \050gcflags)
540 W( & GCSTATS\051)SH
15228 71425 MT
(fprintf\050stderr, "ambiguous roots: %d pages, %d%% of heap\134n",)SH
10 /Times-Roman AF
30561 75600 MT
(-102-)SH
ES
%%Page: 103 103
BS
0 SI
9 /Courier-Bold AF
19548 10183 MT
(forwardedpages, HEAPPERCENT\050 forwardedpages \051\051;)SH
13608 12259 MT
(if \050gcflags)
540 W( & GCNOINC\051 {)SH
15228 13297 MT
(if \050gcflags)
540 W( & GCHEAPMAP\051)SH
16848 14335 MT
(display_headers\050 "Copying Retained Storage" \051;)SH
15228 15373 MT
(do {)SH
16308 16411 MT
(for \050int)
540 W( addr_physpage = PAGE_to_ADDR\050 firstheappage \051;)SH
19548 17449 MT
(addr_physpage < PAGE_to_ADDR\050 lastheappage \051;)SH
19548 18487 MT
(addr_physpage += PHYS_PAGEBYTES\051  {)SH
18468 19525 MT
(if \050is_physpage_protected\050)
540 W( addr_physpage \051\051 {)SH
20088 20563 MT
(scan_physpage_cluster\050 addr_physpage \051;)SH
20088 21601 MT
(if \050)
540 W( protectedpages == 0 \051)SH
21708 22639 MT
(gcwrapup\050\051;)SH
18468 23677 MT
(})SH
16308 24715 MT
(})SH
15228 25753 MT
(} while \050 protectedpages \051;)SH
13608 26791 MT
(})SH
13608 27829 MT
(else if  \050HEAPPERCENT\050 forwardedpages \051 > gcstablepercent\051)SH
17928 28867 MT
(expandheap\050\051;)SH
9288 29905 MT
(})SH
9288 31981 MT
(/* The following procedure is called on the completion of garbage collection)SH
10908 33019 MT
(before free memory is zeroed \050memory is zeroed only when that special)SH
10908 34057 MT
(option is set\051.  It provides a handy place to put a breakpoint.)SH
9288 35095 MT
(*/)SH
9288 37171 MT
(static void  gcdone\050\051 {};)SH
9288 40285 MT
(/* The following procedure is called to end garbage collection.  It)SH
10908 41323 MT
(resets various bookkeeping parameters, and determines whether)SH
10908 42361 MT
(total collection and heap expansion are necessary.)SH
9288 43399 MT
(*/)SH
9288 45475 MT
(static void  gcwrapup\050\051)SH
9288 46513 MT
({)SH
13608 47551 MT
(forw_space = curr_space;  /* Register that GC is over */)SH
13608 48589 MT
(prev_space = curr_space;  /* Reclaim storage */)SH
13608 50665 MT
(/* Discard rest of current forward freepage */)SH
13608 51703 MT
(if \050forw_freewords)
540 W( != 0\051 {)SH
15228 52741 MT
(*forw_freep = MAKE_HEADER\050 forw_freewords, freespace_callback\051;)SH
15228 53779 MT
(forw_freewords = 0;)SH
13608 54817 MT
(})SH
13608 55855 MT
(forw_freep = NULL;)SH
13608 57931 MT
(if \050protectedpages != 0\051 abort\050\051;)SH
13608 60007 MT
(if \050gcflags)
540 W( & GCDEBUGLOG\051 verify_heap\050\051;)SH
13608 62083 MT
(/* Print memory use statistics if required */)SH
13608 63121 MT
(if \050gcflags)
540 W( & GCMEM\051  memory_stats\050\051;)SH
13608 65197 MT
(/* Change headers on heap display */)SH
13608 66235 MT
(if \050gcflags)
540 W( & GCHEAPMAP\051 display_headers\050 "Application Allocation" \051;)SH
13608 68311 MT
(/* Reset bookkeeping parameters */)SH
13608 69349 MT
(allocatedpages = currentpages+forwardedpages;)SH
13608 70387 MT
(currentpages=0;)SH
13608 71425 MT
(gcdone\050\051;)SH
10 /Times-Roman AF
30561 75600 MT
(-103-)SH
ES
%%Page: 104 104
BS
0 SI
9 /Courier-Bold AF
13608 10183 MT
(/* Zero free memory if required */)SH
13608 11221 MT
(if \050gcflags)
540 W( & GCZERO\051  {)SH
15228 12259 MT
(int page)
540 W( = firstheappage-1;)SH
15228 13297 MT
(while \050++page)
540 W( <= lastheappage\051  {)SH
16848 14335 MT
(if \050space[)
540 W( page ] != curr_space && UNSTABLE\050 page \051\051)SH
18468 15373 MT
(bzero\050 \050char*\051PAGE_to_GCP\050 page \051, PAGEBYTES \051;)SH
15228 16411 MT
(})SH
13608 17449 MT
(})SH
13608 19525 MT
(/* Check for generational collection and heap expansion */)SH
13608 20563 MT
(if \050gcallpercent\051)
540 W( {)SH
15228 21601 MT
(/* Performing generational collection */)SH
15228 22639 MT
(if \050HEAPPERCENT\050allocatedpages\051>=gcallpercent\051)
540 W( {)SH
16848 23677 MT
(/* Perform a total collection */)SH
16848 24715 MT
(makecurrentstableset\050\051;)SH
16848 25753 MT
(int save_gcallpercent = gcallpercent;)SH
16848 26791 MT
(gcallpercent = 100;)SH
16848 27829 MT
(gccollect\050\051;)SH
16848 28867 MT
(gcallpercent = save_gcallpercent;)SH
16848 29905 MT
(if \050shouldexpandheap\050\051\051)
540 W( expandheap\050\051;)SH
15228 30943 MT
(})SH
13608 31981 MT
(})SH
13608 33019 MT
(else {)540 W
15228 34057 MT
(/* Not performing generational collection */)SH
15228 35095 MT
(if \050shouldexpandheap\050\051\051 expandheap\050\051;)540 W
15228 36133 MT
(makecurrentstableset\050\051;)SH
13608 37171 MT
(})SH
9288 38209 MT
(})SH
9288 40285 MT
(/* The following function tests whether a set of contiguous heap pages are)SH
10908 41323 MT
(all unprotected)SH
9288 42361 MT
(*/)SH
9288 44437 MT
(static int  all_unprotected\050 int page, int num_pages \051)SH
9288 45475 MT
({)SH
13608 46513 MT
(int begin_physpage = PAGE_to_PPADDR\050 page \051,)SH
15768 47551 MT
(end_physpage =)
1080 W( PAGE_to_PPADDR\050 page+num_pages-1 \051;)SH
13608 48589 MT
(do)SH
15768 49627 MT
(if \050is_physpage_protected\050)
540 W( begin_physpage \051\051 return 0;)SH
13608 50665 MT
(while \050 \050begin_physpage += PHYS_PAGEBYTES\051 <= end_physpage \051;)SH
13608 51703 MT
(return 1;)SH
9288 52741 MT
(})SH
9288 54817 MT
(/* The following predicate returns 1 if the specified set of heap pages is)SH
10908 55855 MT
(not "linked" to other pages to form a physical page cluster that's larger)SH
10908 56893 MT
(than the minimum necessary cluster size.)SH
9288 57931 MT
(*/)SH
9288 60007 MT
(static inline int  SMALL_CLUSTER\050 int firstpage, int lastpage \051 {)SH
13608 61045 MT
(return \050 same_physpage\050PAGE_to_ADDR\050firstpage\051,)SH
26028 62083 MT
(PAGE_to_ADDR\050lastpage\051\051 ||)SH
17928 63121 MT
(\050type[ firstpage - firstpage%phys_cap ] == OBJECT &&)SH
18468 64159 MT
(type[ lastpage - lastpage%phys_cap + phys_cap ] == OBJECT\051 \051;)SH
9288 65197 MT
(})SH
9288 67273 MT
(/* When gcalloc is unable to allocate storage, it calls this routine to)SH
10908 68311 MT
(allocate one or more pages.  If space is not available then the garbage)SH
10908 69349 MT
(collector is called and/or the heap is expanded.)SH
9288 70387 MT
(*/)SH
10 /Times-Roman AF
30561 75600 MT
(-104-)SH
ES
%%Page: 105 105
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
(static void  allocatepage\050 int pages \051)SH
9288 11221 MT
({)SH
13608 12259 MT
(int free,)
540 W( /*)
7020 W( # contiguous free pages */)SH
16308 13297 MT
(firstpage, /*)
4320 W( Page # of first free page \050unprotected\051 */)SH
16308 14335 MT
(first_prot = -1,)
SH( /*)
1080 W( Page # of first free page \050protected\051 */)SH
16308 15373 MT
(allpages; /*)
4860 W( # of pages in the heap */)SH
13608 17449 MT
(if \050pages)
540 W( > MAX_HEADER_PAGES\051  {)SH
15228 18487 MT
(fprintf\050 stderr,)SH
14688 19525 MT
("\134n***** gcalloc  Unable to allocate objects larger than %d bytes\134n",)SH
9288 20563 MT
(#ifdef DOUBLE_ALIGN)SH
19548 21601 MT
(MAX_HEADER_PAGES*PAGEBYTES-8 \051;)SH
9288 22639 MT
(#else)SH
19548 23677 MT
(MAX_HEADER_PAGES*PAGEBYTES-4 \051;)SH
9288 24715 MT
(#endif)SH
15228 25753 MT
(abort\050\051;)SH
13608 26791 MT
(})SH
13608 28867 MT
(/* Scan a few pages iff incremental collection is going on */)SH
13608 29905 MT
(if \050curr_space)
540 W( != forw_space\051  {)SH
15228 30943 MT
(scan_few_physpages\050 1 \051;)SH
15228 31981 MT
(/* Check if collection is over */)SH
15228 33019 MT
(if \050)
540 W( protectedpages == 0 \051)SH
16848 34057 MT
(gcwrapup\050\051;)SH
13608 35095 MT
(})SH
13608 37171 MT
(if \050curr_space)
540 W( == forw_space\051  {)SH
15228 38209 MT
(/* Start incremental collection if more than 1/N of the)SH
16848 39247 MT
(space will be allocated, such that)SH
18468 40285 MT
(N = 3 if doing incremental collection,)SH
18468 41323 MT
(N = 2 otherwise.)SH
15228 42361 MT
(*/)SH
15228 43399 MT
(if \050!\050gcflags)
540 W( & GCNOINC\051\051 {)SH
19548 44437 MT
(/* incremental collection */)SH
16848 45475 MT
(if \050allocatedpages+pages)
540 W( >= heappages/3\051)SH
18468 46513 MT
(gccollect\050\051;)SH
15228 47551 MT
(} else {)SH
16848 48589 MT
(if \050allocatedpages+pages)
540 W( >= heappages/2\051)SH
18468 49627 MT
(gccollect\050\051;)SH
15228 50665 MT
(})SH
13608 51703 MT
(})SH
13608 53779 MT
(/* Try to allocate space */)SH
13608 54817 MT
(free = 0;)SH
13608 55855 MT
(allpages = heapspanpages;)SH
13608 56893 MT
(while \050allpages--\051 {)540 W
15228 57931 MT
(if \050space[)
540 W( curr_freepage ] < prev_space  &&)SH
17928 58969 MT
(UNSTABLE\050 curr_freepage \051\051 {)SH
16848 60007 MT
(/* make sure that curr_freepage is a "cluster" by itself */)SH
16848 61045 MT
(if \050free++)
540 W( == 0\051  {)
SH( /*)
1080 W( Potential first page */)SH
18468 62083 MT
(if \050)
540 W( SMALL_CLUSTER\050curr_freepage, curr_freepage+pages-1\051 \051)SH
20088 63121 MT
(firstpage = curr_freepage;)SH
18468 64159 MT
(else {)SH
20088 65197 MT
(curr_freepage =)SH
22248 66235 MT
(next_page\050curr_freepage - curr_freepage%phys_cap)SH
27648 67273 MT
(+ phys_cap-1 \051;)SH
20088 68311 MT
(free = 0;)SH
20088 69349 MT
(continue; //)
540 W( loop "while \050allpages--\051" again)SH
18468 70387 MT
(})SH
16848 71425 MT
(})SH
10 /Times-Roman AF
30561 75600 MT
(-105-)SH
ES
%%Page: 106 106
BS
0 SI
9 /Courier-Bold AF
16848 10183 MT
(if \050free)
540 W( == pages\051 {  /* Page\050s\051 found */)SH
18468 11221 MT
(curr_freep = PAGE_to_GCP\050 firstpage \051;)SH
18468 12259 MT
(curr_freewords = pages*PAGEWORDS;)SH
18468 13297 MT
(allocatedpages = allocatedpages+pages;)SH
18468 14335 MT
(currentpages =)
1080 W( currentpages+pages;)SH
18468 15373 MT
(curr_freepage =)
540 W( next_page\050 firstpage+pages-1 \051;)SH
18468 16411 MT
(space[ firstpage ] = curr_space;)SH
18468 17449 MT
(type[ firstpage ]  = OBJECT;)SH
18468 18487 MT
(bzero\050 \050char*\051&firstword[ firstpage*BIT_WORDS ],)SH
22248 19525 MT
(BIT_BYTES*pages \051;)SH
18468 20563 MT
(for \050int)
540 W( i = 1; i < pages; i++\051 {)SH
20628 21601 MT
(space[ firstpage+i ] = curr_space;)SH
20628 22639 MT
(type[ firstpage+i ]  = CONTINUED;)SH
18468 23677 MT
(})SH
18468 24715 MT
(if \050gcflags)
540 W( & GCHEAPMAP\051)SH
20088 25753 MT
(for \050i)
540 W( = 0; i < pages; i++\051)SH
22248 26791 MT
(page_map\050 firstpage+i \051;)SH
18468 27829 MT
(if \050!all_unprotected\050firstpage,)
540 W( pages\051\051)SH
20088 28867 MT
(scan_physpage_cluster\050 PAGE_to_PPADDR\050firstpage\051 \051;)SH
18468 29905 MT
(return;)SH
16848 30943 MT
(})SH
16848 31981 MT
(else {  /*  free < pages  */)SH
18468 33019 MT
(curr_freepage = next_page\050 curr_freepage \051;)SH
18468 34057 MT
(if \050curr_freepage)
540 W( == firstheappage\051  free = 0;)SH
16848 35095 MT
(})SH
15228 36133 MT
(})SH
15228 37171 MT
(else {  /* curr_freepage is not free */)SH
16848 38209 MT
(free = 0;)SH
16848 39247 MT
(curr_freepage = next_page\050 curr_freepage \051;)SH
15228 40285 MT
(})SH
13608 41323 MT
(})SH
13608 43399 MT
(/* Failed to allocate space, keep trying iff heap can expand.  Assure)SH
15228 44437 MT
(that minimum increment size is at least the size of this object.)SH
13608 45475 MT
(*/)SH
13608 46513 MT
(if \050gcincbytes/PAGEBYTES)
540 W( < pages\051 gcincbytes = pages*PAGEBYTES;)SH
13608 47551 MT
(if \050expandheap\050\051\051 {)540 W
15228 48589 MT
(allocatepage\050 pages \051;)SH
15228 49627 MT
(return;)SH
13608 50665 MT
(})SH
13608 52741 MT
(/* Can't do it */)SH
13608 53779 MT
(fprintf\050 stderr,)SH
15768 54817 MT
("\134n***** gcalloc  Unable to allocate %d bytes in a %d byte heap\134n",)SH
18468 55855 MT
(pages*PAGEBYTES, heappages*PAGEBYTES \051;)SH
13608 56893 MT
(abort\050\051;)SH
9288 57931 MT
(})SH
9288 60007 MT
(/* Storage is allocated by the following function.  It returns a pointer)SH
10908 61045 MT
(to the object.  It is up to the specific constructor procedure to assure)SH
10908 62083 MT
(that all pointer slots are correctly initialized.  The word count includes)SH
10908 63121 MT
(one word for the header.)SH
9288 64159 MT
(*/)SH
9288 66235 MT
(GCP gcalloc\050)
540 W( int words, int callback \051)SH
9288 67273 MT
({)SH
13608 68311 MT
(GCP object;  /*)
540 W( Pointer to the object */)SH
13608 70387 MT
(/* Try to allocate from current page */)SH
13608 71425 MT
(if \050words)
540 W( <= curr_freewords\051  {)SH
10 /Times-Roman AF
30561 75600 MT
(-106-)SH
ES
%%Page: 107 107
BS
0 SI
9 /Courier-Bold AF
15228 10183 MT
(*curr_freep = MAKE_HEADER\050 words, callback \051;)SH
15228 11221 MT
(object = curr_freep+1;)SH
15228 12259 MT
(curr_freewords = curr_freewords-words;)SH
15228 13297 MT
(curr_freep = curr_freep+words;)SH
9288 14335 MT
(#ifdef DOUBLE_ALIGN)SH
15228 15373 MT
(if \050\050curr_freewords)
540 W( & 1\051 == 0  &&  curr_freewords\051  {)SH
16308 16411 MT
(*curr_freep = doublepad;)SH
16308 17449 MT
(curr_freewords = curr_freewords-1;)SH
16308 18487 MT
(curr_freep = curr_freep+1;)SH
15228 19525 MT
(})SH
9288 20563 MT
(#endif)SH
15228 21601 MT
(SET_FIRSTWORD\050 object \051;)SH
15228 22639 MT
(return\050 object \051;)SH
13608 23677 MT
(})SH
13608 24715 MT
(/* Discard any remaining portion of current page */)SH
13608 25753 MT
(if \050curr_freewords)
540 W( != 0\051  {)SH
15228 26791 MT
(*curr_freep = MAKE_HEADER\050 curr_freewords, freespace_callback \051;)SH
15228 27829 MT
(curr_freewords = 0;)SH
13608 28867 MT
(})SH
13608 29905 MT
(/* Object is less than 1 page in size */)SH
13608 30943 MT
(if \050words)
540 W( < ONEPAGEOBJ_WORDS\051  {)SH
15228 31981 MT
(allocatepage\050 1 \051;)SH
9288 33019 MT
(#ifdef DOUBLE_ALIGN)SH
15228 34057 MT
(*curr_freep = doublepad;)SH
15228 35095 MT
(curr_freewords = curr_freewords-1;)SH
15228 36133 MT
(curr_freep = curr_freep+1;)SH
9288 37171 MT
(#endif)SH
15228 38209 MT
(*curr_freep = MAKE_HEADER\050 words, callback \051;)SH
15228 39247 MT
(object = curr_freep+1;)SH
15228 40285 MT
(curr_freewords = curr_freewords-words;)SH
15228 41323 MT
(curr_freep = curr_freep+words;)SH
9288 42361 MT
(#ifdef DOUBLE_ALIGN)SH
15228 43399 MT
(if \050\050curr_freewords)
540 W( & 1\051 == 0\051  {)SH
16848 44437 MT
(*curr_freep = doublepad;)SH
16848 45475 MT
(curr_freewords = curr_freewords-1;)SH
16848 46513 MT
(curr_freep = curr_freep+1;)SH
15228 47551 MT
(})SH
9288 48589 MT
(#endif)SH
15228 49627 MT
(SET_FIRSTWORD\050 object \051;)SH
15228 50665 MT
(return\050 object \051;)SH
13608 51703 MT
(})SH
13608 52741 MT
(/* Object >= 1 page in size */)SH
9288 54817 MT
(#ifdef DOUBLE_ALIGN)SH
13608 55855 MT
(allocatepage\050 \050words+PAGEWORDS\051/PAGEWORDS \051;)SH
13608 56893 MT
(*curr_freep = doublepad;)SH
13608 57931 MT
(curr_freewords = curr_freewords-1;)SH
13608 58969 MT
(curr_freep = curr_freep+1;)SH
9288 60007 MT
(#else)SH
13608 61045 MT
(allocatepage\050 \050words+PAGEWORDS-1\051/PAGEWORDS \051;)SH
9288 62083 MT
(#endif)SH
13608 64159 MT
(*curr_freep = MAKE_HEADER\050 words, callback \051;)SH
13608 65197 MT
(object = curr_freep+1;)SH
13608 66235 MT
(curr_freewords = 0;)SH
13608 67273 MT
(curr_freep = NULL;)SH
13608 68311 MT
(SET_FIRSTWORD\050 object \051;)SH
13608 69349 MT
(return\050 object \051;)SH
9288 70387 MT
(})SH
10 /Times-Roman AF
30561 75600 MT
(-107-)SH
ES
%%Page: 108 108
BS
0 SI
9 /Courier-Bold AF
9288 10183 MT
(/* The following predicate returns 1 if the object is checked by the garbage)SH
10908 11221 MT
(collector, otherwise 0.)SH
9288 12259 MT
(*/)SH
9288 14335 MT
(#ifdef COMPILER_VERSION_1_2)SH
9288 15373 MT
(int gcobject\050)
540 W( void* obj \051)SH
9288 16411 MT
({)SH
13608 17449 MT
(if \050obj)
540 W( >= STATIC_1  &&  obj < &obj\051  {)SH
15228 18487 MT
(int page)
540 W( = GCP_to_PAGE\050 obj \051;)SH
15228 19525 MT
(if \050page)
540 W( < firstheappage  ||  page > lastheappage  ||)SH
17928 20563 MT
(space[ page ] == UNALLOCATEDPAGE\051)SH
16848 21601 MT
(return 0;)SH
13608 22639 MT
(})SH
13608 23677 MT
(return 1;)540 W
9288 24715 MT
(})SH
9288 25753 MT
(#endif)SH
9288 28867 MT
(/* The delete operator is redefined so that the user program may call)SH
10908 29905 MT
(delete on garbage collected objects.)SH
9288 30943 MT
(*/)SH
9288 33019 MT
(#ifdef COMPILER_VERSION_1_2)SH
9288 34057 MT
(extern void operator  delete\050 void* p \051  {)SH
13608 35095 MT
(if \050gcheapcreated\051 {)540 W
15228 36133 MT
(int page)
540 W( = GCP_to_PAGE\050 p \051;)SH
15228 37171 MT
(if \050page)
540 W( >= firstheappage  &&  page <= lastheappage  &&)SH
17928 38209 MT
(space[ page ] != UNALLOCATEDPAGE\051)SH
16848 39247 MT
(return;)SH
13608 40285 MT
(})SH
13608 41323 MT
(if \050p\051 free\050)
540 W( \050char*\051p \051;)SH
9288 42361 MT
(})SH
9288 43399 MT
(#endif)SH
10 /Times-Roman AF
30561 75600 MT
(-108-)SH
ES
%%Page: 109 109
BS
0 SI
15 /Times-Bold AF
28145 10581 MT
(References)SH
12 /Times-Roman AF
9288 13320 MT
([Appel 89])SH
18288 XM
(Andrew W. Appel.)SH
18288 14606 MT
(Simple Generational Collection and Fast Allocation.)SH
/Times-Italic SF
18288 15892 MT
(Software-Practice and Experience)SH
/Times-Roman SF
35122 XM
(, February, 1989.)SH
9288 18001 MT
([Appel et al. 88])SH
18288 XM
(Andrew W. Appel, John R. Ellis, and Kai Li.)SH
18288 19287 MT
(Real-Time Concurrent Collection on Stock Multiprocessors.)SH
/Times-Italic SF
18288 20573 MT
(ACM SIGPLAN Notices)SH
/Times-Roman SF
30121 XM
(, June, 1988.)SH
9288 22682 MT
([Bartlett 88])SH
18288 XM
(Joel F. Bartlett.)SH
/Times-Italic SF
18288 23968 MT
(Compacting Garbage Collection with Ambiguous Roots)SH
/Times-Roman SF
(.)SH
18288 25254 MT
(Technical Report 88/2, DEC Western Research Laboratory, February,)SH
20088 26540 MT
(1988.)SH
9288 28649 MT
([Bartlett 89])SH
18288 XM
(Joel F. Bartlett.)SH
/Times-Italic SF
18288 29935 MT
(Mostly-Copying Collection Picks Up Generations and C++)SH
/Times-Roman SF
(.)SH
18288 31221 MT
(Technical Report TN-12, DEC Western Research Laboratory, October,)SH
20088 32507 MT
(1989.)SH
9288 34616 MT
([Detlefs 90])SH
18288 XM
(David Detlefs.)SH
/Times-Italic SF
18288 35902 MT
(Concurrent Garbage Collection for C++)SH
/Times-Roman SF
(.)SH
18288 37188 MT
(Technical Report CMU-CS-90-119, Carnegie Mellon University, May,)SH
20088 38474 MT
(1990.)SH
9288 40583 MT
([Fenichel&Yochelson 69])SH
18288 41869 MT
(Robert R. Fenichel, and Jerome C. Yochelson.)SH
18288 43155 MT
(A LISP garbage-collector for virtual-memory.)SH
/Times-Italic SF
18288 44441 MT
(Communciations of the ACM 12, \05011\051, 611-612)SH
/Times-Roman SF
41256 XM
(, 1969.)SH
9288 46550 MT
([Li 90])SH
18288 XM
(Kai Li.)SH
/Times-Italic SF
18288 47836 MT
(Real-time Concurrent Collection in User Mode)SH
/Times-Roman SF
(.)SH
18288 49122 MT
(Technical Report CS-TR-291-90, Princeton University, October, 1990.)SH
18288 50408 MT
(In Workshop on Garbage Collection in Objected Oriented Systems,)SH
20088 51694 MT
(October 1990, Ottawa.)SH
9288 53803 MT
([Moon 84])SH
18288 XM
(David Moon.)SH
18288 55089 MT
(Garbage Collection in a large LISP system.)SH
/Times-Italic SF
18288 56375 MT
(ACM)SH
/Times-Roman SF
21121 XM
(, 1984.)SH
18288 57661 MT
(In ACM Symposium on LISP and Functional Programming.)SH
9288 59770 MT
([Shaw 88])SH
18288 XM
(Robert Shaw.)SH
/Times-Italic SF
18288 61056 MT
(Empirical Analysis of a Lisp System)SH
/Times-Roman SF
(.)SH
18288 62342 MT
(Technical Report CSL-TR-88-351, Stanford University, February, 1988.)SH
9288 64451 MT
([Stroustrup 86])SH
18288 XM
(Bjarne Stroustrup.)SH
/Times-Italic SF
18288 65737 MT
(The C++ Programming Language.)SH
/Times-Roman SF
18288 67023 MT
(Addison-Wesley, 1986.)SH
10 SS 
30561 75600 MT
(-109-)SH
ES
%%Page: 110 110
BS
0 SI
12 /Times-Roman AF
9288 10399 MT
([Thacker&Stewart 87])SH
18288 11685 MT
(Charles P. Thacker, and Lawrence C. Stewart.)SH
18288 12971 MT
(Firefly: A Multiprocessor Workstation.)SH
/Times-Italic SF
18288 14257 MT
(ACM)SH
/Times-Roman SF
21121 XM
(, 1987.)SH
18288 15543 MT
(In Proceedings of the Second International Conference on Achitectural)SH
20088 16829 MT
(Support for Programming Languages and Operating Systems.)SH
9288 18938 MT
([Weiser 89])SH
18288 XM
(Mark Weiser.)SH
18288 20224 MT
(The Portable Common Runtime Approach to Interoperability.)SH
/Times-Italic SF
18288 21510 MT
(ACM SIGPLAN Notices)SH
/Times-Roman SF
30121 XM
(, December, 1989.)SH
10 SS 
30561 75600 MT
(-110-)SH
ES

%%Page: 111 5
BS
0 SI
15 /Times-Bold AF
24734 8205 MT
(WRL Research Reports)SH
10 /Times-Roman AF
9000 10807 MT
(``Titan System Manual.'')SH
34200 XM
(``MultiTitan: Four)
250 W( Architecture Papers.'')SH
9000 12202 MT
(Michael J. K. Nielsen.)SH
34200 XM
(Norman P. Jouppi, Jeremy)
2 W( Dion, David Boggs, Mich-)3 W
9000 13597 MT
(WRL Research Report 86/1, September 1986.)SH
35572 XM
(ael J. K. Nielsen.)SH
34200 14992 MT
(WRL Research Report 87/8, April 1988.)SH
9000 16293 MT
(``Global Register Allocation at Link Time.'')SH
9000 17688 MT
(David W. Wall.)SH
34200 XM
(``Fast Printed Circuit Board Routing.'')SH
9000 19083 MT
(WRL Research Report 86/3, October 1986.)SH
34200 XM
(Jeremy Dion.)SH
34200 20478 MT
(WRL Research Report 88/1, March 1988.)SH
9000 21779 MT
(``Optimal Finned Heat Sinks.'')SH
9000 23174 MT
(William R. Hamburgen.)SH
34200 XM
(``Compacting Garbage Collection)
262 W( with Ambiguous)261 W
9000 24569 MT
(WRL Research Report 86/4, October 1986.)SH
35572 XM
(Roots.'')SH
34200 25964 MT
(Joel F. Bartlett.)SH
9000 27265 MT
(``The Mahler Experience: Using)
416 W( an Intermediate)415 W
34200 27359 MT
(WRL Research Report 88/2, February 1988.)SH
10372 28660 MT
(Language as the Machine Description.'')SH
9000 30055 MT
(David W. Wall and Michael L. Powell.)SH
34200 XM
(``The Experimental Literature)
185 W( of The Internet:  An)186 W
9000 31450 MT
(WRL Research Report 87/1, August 1987.)SH
35572 XM
(Annotated Bibliography.'')SH
34200 32845 MT
(Jeffrey C. Mogul.)SH
9000 34146 MT
(``The Packet Filter:)
280 W( An)
812 W( Efficient Mechanism for)281 W
34200 34240 MT
(WRL Research Report 88/3, August 1988.)SH
10372 35541 MT
(User-level Network Code.'')SH
9000 36936 MT
(Jeffrey C. Mogul, Richard)
536 W( F. Rashid, Michael)535 W
34200 XM
(``Measured Capacity of an)
321 W( Ethernet:  Myths and)320 W
10372 38331 MT
(J. Accetta.)SH
35572 XM
(Reality.'')SH
9000 39726 MT
(WRL Research Report 87/2, November 1987.)SH
34200 XM
(David R. Boggs, Jeffrey)
433 W( C. Mogul, Christopher)434 W
35572 41121 MT
(A. Kent.)SH
9000 42422 MT
(``Fragmentation Considered Harmful.'')SH
34200 42516 MT
(WRL Research Report 88/4, September 1988.)SH
9000 43817 MT
(Christopher A. Kent, Jeffrey C. Mogul.)SH
9000 45212 MT
(WRL Research Report 87/3, December 1987.)SH
34200 XM
(``Visa Protocols)
96 W( for Controlling Inter-Organizational)95 W
35572 46607 MT
(Datagram Flow:  Extended Description.'')SH
9000 47908 MT
(``Cache Coherence in Distributed Systems.'')SH
34200 48002 MT
(Deborah Estrin, Jeffrey C. Mogul,)
378 W( Gene Tsudik,)379 W
9000 49303 MT
(Christopher A. Kent.)SH
35572 49397 MT
(Kamaljit Anand.)SH
9000 50698 MT
(WRL Research Report 87/4, December 1987.)SH
34200 50792 MT
(WRL Research Report 88/5, December 1988.)SH
9000 53394 MT
(``Register Windows vs. Register Allocation.'')SH
34200 53488 MT
(``SCHEME->C A Portable Scheme-to-C Compiler.'')SH
9000 54789 MT
(David W. Wall.)SH
34200 54883 MT
(Joel F. Bartlett.)SH
9000 56184 MT
(WRL Research Report 87/5, December 1987.)SH
34200 56278 MT
(WRL Research Report 89/1, January 1989.)SH
9000 58880 MT
(``Editing Graphical Objects)
817 W( Using Procedural)818 W
34200 58974 MT
(``Optimal Group Distribution in Carry-Skip Ad-)448 W
10372 60275 MT
(Representations.'')SH
35572 60369 MT
(ders.'')SH
9000 61670 MT
(Paul J. Asente.)SH
34200 61764 MT
(Silvio Turrini.)SH
9000 63065 MT
(WRL Research Report 87/6, November 1987.)SH
34200 63159 MT
(WRL Research Report 89/2, February 1989.)SH
9000 65761 MT
(``The USENET Cookbook: an)
693 W( Experiment in)692 W
34200 65855 MT
(``Precise Robotic Paste Dot Dispensing.'')SH
10372 67156 MT
(Electronic Publication.'')SH
34200 67250 MT
(William R. Hamburgen.)SH
9000 68551 MT
(Brian K. Reid.)SH
34200 68645 MT
(WRL Research Report 89/3, February 1989.)SH
9000 69946 MT
(WRL Research Report 87/7, December 1987.)SH
31650 75600 MT
(111)SH
ES
%%Page: 112 6
BS
0 SI
10 /Times-Roman AF
5400 7886 MT
(``Simple and Flexible Datagram Access Controls for)82 W
30600 XM
(``Link-Time Code Modification.'')SH
6772 9281 MT
(Unix-based Gateways.'')SH
30600 XM
(David W. Wall.)SH
5400 10676 MT
(Jeffrey C. Mogul.)SH
30600 XM
(WRL Research Report 89/17, September 1989.)SH
5400 12071 MT
(WRL Research Report 89/4, March 1989.)SH
30600 13372 MT
(``Noise Issues in the ECL Circuit Family.'')SH
30600 14767 MT
(Jeffrey Y.F. Tang and J. Leon Yang.)SH
5400 14790 MT
(``Spritely NFS:)
138 W( Implementation and Performance of)137 W
30600 16162 MT
(WRL Research Report 90/1, January 1990.)SH
6772 16185 MT
(Cache-Consistency Protocols.'')SH
5400 17580 MT
(V. Srinivasan and Jeffrey C. Mogul.)SH
30600 18858 MT
(``Efficient Generation of Test Patterns)
715 W( Using)716 W
5400 18975 MT
(WRL Research Report 89/5, May 1989.)SH
31972 20253 MT
(Boolean Satisfiablilty.'')SH
30600 21648 MT
(Tracy Larrabee.)SH
5400 21671 MT
(``Available Instruction-Level)
192 W( Parallelism for Super-)193 W
30600 23043 MT
(WRL Research Report 90/2, February 1990.)SH
6772 23066 MT
(scalar and Superpipelined Machines.'')SH
5400 24461 MT
(Norman P. Jouppi and David W. Wall.)SH
30600 25739 MT
(``Two Papers on Test Pattern Generation.'')SH
5400 25856 MT
(WRL Research Report 89/7, July 1989.)SH
30600 27134 MT
(Tracy Larrabee.)SH
30600 28529 MT
(WRL Research Report 90/3, March 1990.)SH
5400 28552 MT
(``A Unified Vector/Scalar Floating-Point Architec-)276 W
6772 29947 MT
(ture.'')SH
30600 31225 MT
(``Virtual Memory vs. The File System.'')SH
5400 31342 MT
(Norman P. Jouppi, Jonathan Bertoni, and)
401 W( David)402 W
30600 32620 MT
(Michael N. Nelson.)SH
6772 32737 MT
(W. Wall.)SH
30600 34015 MT
(WRL Research Report 90/4, March 1990.)SH
5400 34132 MT
(WRL Research Report 89/8, July 1989.)SH
30600 36711 MT
(``Efficient Use of Workstations for Passive)
73 W( Monitor-)72 W
5400 36828 MT
(``Architectural and Organizational Tradeoffs in)
227 W( the)226 W
31972 38106 MT
(ing of Local Area Networks.'')SH
6772 38223 MT
(Design of the MultiTitan CPU.'')SH
30600 39501 MT
(Jeffrey C. Mogul.)SH
5400 39618 MT
(Norman P. Jouppi.)SH
30600 40896 MT
(WRL Research Report 90/5, July 1990.)SH
5400 41013 MT
(WRL Research Report 89/9, July 1989.)SH
30600 43592 MT
(``A One-Dimensional)
174 W( Thermal Model for the VAX)175 W
5400 43709 MT
(``Integration and Packaging Plateaus)
326 W( of Processor)327 W
31972 44987 MT
(9000 Multi Chip Units.'')SH
6772 45104 MT
(Performance.'')SH
30600 46382 MT
(John S. Fitch.)SH
5400 46499 MT
(Norman P. Jouppi.)SH
30600 47777 MT
(WRL Research Report 90/6, July 1990.)SH
5400 47894 MT
(WRL Research Report 89/10, July 1989.)SH
30600 50473 MT
(``1990 DECWRL/Livermore Magic Release.'')SH
5400 50590 MT
(``A 20-MIPS)
160 W( Sustained 32-bit CMOS Microproces-)159 W
30600 51868 MT
(Robert N. Mayo, Michael H. Arnold, Walter)
20 W( S. Scott,)19 W
6772 51985 MT
(sor with High Ratio of Sustained to Peak)
98 W( Perfor-)99 W
31972 53263 MT
(Don Stark, Gordon T. Hamachi.)SH
6772 53380 MT
(mance.'')SH
30600 54658 MT
(WRL Research Report 90/7, September 1990.)SH
5400 54775 MT
(Norman P. Jouppi and Jeffrey Y. F. Tang.)SH
5400 56170 MT
(WRL Research Report 89/11, July 1989.)SH
30600 57354 MT
(``Pool Boiling)
35 W( Enhancement Techniques for Water at)36 W
31972 58749 MT
(Low Pressure.'')SH
5400 58866 MT
(``The Distribution)
116 W( of Instruction-Level and Machine)115 W
30600 60144 MT
(Wade R. McGillis,)
795 W( John S. Fitch, William)794 W
6772 60261 MT
(Parallelism and Its Effect on Performance.'')SH
31972 61539 MT
(R. Hamburgen, Van P. Carey.)SH
5400 61656 MT
(Norman P. Jouppi.)SH
30600 62934 MT
(WRL Research Report 90/9, December 1990.)SH
5400 63051 MT
(WRL Research Report 89/13, July 1989.)SH
30600 65630 MT
(``Writing Fast)
12 W( X Servers for Dumb Color Frame Buf-)13 W
5400 65747 MT
(``Long Address Traces)
659 W( from RISC Machines:)660 W
31972 67025 MT
(fers.'')SH
6772 67142 MT
(Generation and Analysis.'')SH
30600 68420 MT
(Joel McCormack.)SH
5400 68537 MT
(Anita Borg,)
60 W( R.E.Kessler, Georgia Lazana, and David)59 W
30600 69815 MT
(WRL Research Report 91/1, February 1991.)SH
6772 69932 MT
(W. Wall.)SH
5400 71327 MT
(WRL Research Report 89/14, September 1989.)SH
28050 75600 MT
(112)SH
ES
%%Page: 113 7
BS
0 SI
10 /Times-Roman AF
9000 7886 MT
(``Analysis of Power Supply Networks)
138 W( in VLSI Cir-)137 W
10372 9281 MT
(cuits.'')SH
9000 10676 MT
(Don Stark.)SH
9000 12071 MT
(WRL Research Report 91/3, April 1991.)SH
9000 14790 MT
(``Procedure Merging with Instruction Caches.'')SH
9000 16185 MT
(Scott McFarling.)SH
9000 17580 MT
(WRL Research Report 91/5, March 1991.)SH
9000 20276 MT
(``Don't Fidget with Widgets, Draw!.'')SH
9000 21671 MT
(Joel Bartlett.)SH
9000 23066 MT
(WRL Research Report 91/6, May 1991.)SH
9000 25762 MT
(``Pool Boiling on Small Heat Dissipating Elements)
10 W( in)11 W
10372 27157 MT
(Water at Subatmospheric Pressure.'')SH
9000 28552 MT
(Wade R. McGillis,)
795 W( John S. Fitch, William)794 W
10372 29947 MT
(R. Hamburgen, Van P. Carey.)SH
9000 31342 MT
(WRL Research Report 91/7, June 1991.)SH
9000 34038 MT
(``Incremental, Generational Mostly-Copying)
516 W( Gar-)517 W
10372 35433 MT
(bage Collection)
739 W( in Uncooperative Environ-)738 W
10372 36828 MT
(ments.'')SH
9000 38223 MT
(G. May Yip.)SH
9000 39618 MT
(WRL Research Report 91/8, June 1991.)SH
15 /Times-Bold AF
25316 43463 MT
(WRL Technical Notes)SH
10 /Times-Roman AF
9000 46065 MT
(``TCP/IP PrintServer: Print Server Protocol.'')SH
34200 XM
(``Mostly-Copying Garbage Collection Picks)
595 W( Up)594 W
9000 47460 MT
(Brian K. Reid and Christopher A. Kent.)SH
35572 XM
(Generations and C++.'')SH
9000 48855 MT
(WRL Technical Note TN-4, September 1988.)SH
34200 XM
(Joel F. Bartlett.)SH
34200 50250 MT
(WRL Technical Note TN-12, October 1989.)SH
9000 51551 MT
(``TCP/IP PrintServer:)
270 W( Server Architecture and Im-)271 W
10372 52946 MT
(plementation.'')SH
34200 XM
(``Limits of Instruction-Level Parallelism.'')SH
9000 54341 MT
(Christopher A. Kent.)SH
34200 XM
(David W. Wall.)SH
9000 55736 MT
(WRL Technical Note TN-7, November 1988.)SH
34200 XM
(WRL Technical Note TN-15, December 1990.)SH
9000 58432 MT
(``Smart Code, Stupid Memory: A Fast X Server for)
30 W( a)29 W
34200 XM
(``The Effect of)
177 W( Context Switches on Cache Perfor-)178 W
10372 59827 MT
(Dumb Color Frame Buffer.'')SH
35572 XM
(mance.'')SH
9000 61222 MT
(Joel McCormack.)SH
34200 XM
(Jeffrey C. Mogul and Anita Borg.)SH
9000 62617 MT
(WRL Technical Note TN-9, September 1989.)SH
34200 XM
(WRL Technical Note TN-16, December 1990.)SH
9000 65313 MT
(``Why Aren't Operating Systems Getting)
165 W( Faster As)166 W
34200 XM
(``MTOOL: A)
542 W( Method For)
146 W( Detecting Memory Bot-)145 W
10372 66708 MT
(Fast As Hardware?'')SH
35572 XM
(tlenecks.'')SH
9000 68103 MT
(John Ousterhout.)SH
34200 XM
(Aaron Goldberg and John Hennessy.)SH
9000 69498 MT
(WRL Technical Note TN-11, October 1989.)SH
34200 XM
(WRL Technical Note TN-17, December 1990.)SH
31650 75600 MT
(113)SH
ES
%%Page: 114 8
BS
0 SI
10 /Times-Roman AF
5400 7886 MT
(``Predicting Program Behavior Using Real or)
304 W( Es-)305 W
6772 9281 MT
(timated Profiles.'')SH
5400 10676 MT
(David W. Wall.)SH
5400 12071 MT
(WRL Technical Note TN-18, December 1990.)SH
5400 13466 MT
(``Systems for Late Code Modification.'')SH
5400 14861 MT
(David W. Wall.)SH
5400 16256 MT
(WRL Technical Note TN-19, June 1991.)SH
28050 75600 MT
(114)SH
ES
%%Trailer
%%Pages: 118
%%DocumentFonts: Times-Roman Times-Bold Times-Italic Courier Symbol Courier-Bold
