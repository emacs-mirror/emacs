package cm.win;
use cm.geometry;


/**
 * Pen style.
 */
public enum penStyle using int {
    /**
     * Invisible pen style.
     */
    invisiblePen = 0;

    /**
     * Solid pen style.
     */
    solidPen;

    /**
     * Solid pen style.
     */
    dotPen;

    /**
     * Dash pen style.
     */
    dashPen;

    /**
     * Dash/dot pen style.
     */
    dashDotPen;

    /**
     * Dashed/dot/dot pen style.
     */
    dashDotDotPen;
}


/**
 * Develop trace. Number of open windows resources.
 */
public int mpenCount;

/**
 * Develop trace. Number of instances.
 */
public int penCount;

/**
 * Total uses.
 */
public int totalPenUse;


/**
 * Win pen object.
 */
public class Pen {
    /**
     * Font to use.
     */
    public mpen pen : copy=null, stream=null;

    /*
     * Color.
     */
    public color penColor;

    /**
     * Width.
     */
    public int width;

    /**
     * Pen style.
     */
    public penStyle style;

    /**
     * Count of usage. If zero the mfont is destroyed (returned to windows).
     */
    public int usageCount;


    /***********************************************************************
     * Creation
     ***********************************************************************/

    /**
     * ???
     */
    public constructor(color c, penStyle style) {
	//pln("Pen constructor 1... ", c, ", ", style);
	this.penColor = c;
	this.width = 0;
	this.style = style;
	penCount++;
	//pln("Pen trace (Construct): ", mpenCount, "/", totalPenUse,"/", penCount);
    }


    /**
     * ???
     */
    public constructor(color c, int w) {
	this.penColor = c;
	this.width = w;
	this.style = solidPen;
	penCount++;
	//pln("Pen trace (Construct): ", mpenCount, "/", totalPenUse,"/", penCount);
    }


    /**
     * ...
     */
    public constructor(color c) {
	this.penColor = c;
	this.width = 0;
	this.style = solidPen;
	penCount++;
	//pln("Pen trace (Construct): ", mpenCount, "/", totalPenUse,"/", penCount);
    }



    /***********************************************************************
     * Copy
     ***********************************************************************/

    /**
     * Return a deep copy of this.
     * Example:
     *   Pen p1 = new Pen(color(255, 0, 0)).use();
     *	 Pen p2 = (deep copy p1).use();
     */
    public Pen deepCopy() {
	Pen z = super.deepCopy()::Pen;
	z.usageCount = 0;
	z.pen = null;  // should not be necessary!

	penCount++;

	return z;
    }


    /**
     * Return a shallow copy of this. Always copy deep.
     */
    public Pen shallowCopy() {
	return this.deepCopy();
    }


    /***********************************************************************
     * ByteStream
     ***********************************************************************/

    /**
     * Loaded from byte stream.
     */
    public void loaded() {
	restore();
    }


    /***********************************************************************
     * Use and release
     ***********************************************************************/

    /**
     * Use this pen.
     */
    extend public Pen use() {
	if (usageCount == 0) {
	    mpenCount++;
	    restore();
	}

	usageCount++;
	totalPenUse++;
	//pln("Pen trace (use): ", mpenCount, "/", totalUse,"/", penCount);

	return this;
    }


    /**
     * Release pen.
     */
    extend public void release() {
	usageCount--;

	if (usageCount == 0){
	  mpenCount--;
	  destroyPen(pen);
	  pen = null;
	}

	totalPenUse--;
	//pln("Pen trace (release): ", mpenCount, "/", totalUse,"/", penCount);
    }


    /**
     * Restore brush.
     */
    extend public void restore() {
	if (!pen) {
	    if (style == solidPen)
	      pen = winPen(penColor, width);
	    else
	      pen = winPenDash(penColor, style::int);
	} else bug;
    }


    /***********************************************************************
     * Misc
     ***********************************************************************/

    /**
     * Convert to string.
     */
    public str toS() {
	if (this == blackPen)
	  return "[Pen blackPen]";
	else if (this == darkGrayPen)
	  return "[Pen darkGreyPen]";
	else if (this == grayPen)
	  return "[Pen grayPen]";
	else if (this == whitePen)
	  return "[Pen whitePen, " # pen.v # "]";
	else
	  return "[Pen color=" # penColor # ", w=" # width # ", style=" # style # "]";
    }
}


/**
 * Black color pen.
 */
public Pen blackPen(color(0, 0, 0));

/**
 * Dark gray color pen.
 */
public Pen darkGrayPen(color(128, 128, 128));

/**
 * Gray color pen.
 */
public Pen grayPen(color(196, 196, 196));

/**
 * 
 */
public Pen lightGrayPen(color(220, 220, 220));

/**
 * White color pen.
 */
public Pen whitePen(color(255, 255, 255));

/**
 * 
 */
public Pen blackDotPen(color(0, 0, 0), dotPen);

/**
 * 
 */
public Pen redPen(color(255, 0, 0));
