%!PS-Adobe-3.0
%%Title: (CacheCGC.wrd)
%%Creator: (Microsoft Word: LaserWriter 8 8.2)
%%CreationDate: (3:08 PM Tuesday, December 6, 1994)
%%For: (Henry Baker)
%%Pages: 8
%%DocumentFonts: Times-Roman Times-Italic Times-Bold Courier
%%DocumentNeededFonts: Times-Roman Times-Italic Times-Bold Courier
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%%DocumentMedia: Default 612 792 0 () ()
%ADO_ImageableArea: 31 31 583 761
%%EndComments
userdict begin/dscInfo 5 dict dup begin
/Title(CacheCGC.wrd)def
/Creator(Microsoft Word: LaserWriter 8 8.2)def
/CreationDate(3:08 PM Tuesday, December 6, 1994)def
/For(Henry Baker)def
/Pages 1 def
end def end

save 
/version23-manualfeedpatch where { pop false } { true }ifelse
 % we don't do an explicit 'get' since product and version MAY
 % be in systemdict or statusdict - this technique gets the lookup
 % without failure
statusdict begin
  product (LaserWriter) eq        % true if LaserWriter
  version cvr 23.0 eq             % true if version 23
end

and  % only install this patch if both are true
and  % true only if patch is not installed and is for this printer
     % save object and boolean on stack
dup { exch restore }if
% either true OR saveobject false
dup
{
  /version23-manualfeedpatch true def
  /oldversion23-showpage /showpage load def
  /showpage       % this showpage will wait extra time if manualfeed is true
  {%
     statusdict /manualfeed known
     {% manualfeed known in statusdict
        statusdict /manualfeed get
        {% if true then we loop for 5 seconds
           usertime 5000 add       % target usertime
           { % loop
             dup usertime sub 0 lt
             { exit }if
           }loop
           pop             % pop the usertime off the stac
        }if
     }if
     oldversion23-showpage
  }bind def
}if
not{ restore }if

/md 144 dict def md begin/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 81 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if end
%%EndProlog
%%BeginSetup
md begin
countdictstack[{
%%BeginFeature: *ManualFeed False
statusdict /manualfeed false put
%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *InputSlot Cassette

%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *PageRegion LetterSmall
lettersmall
%%EndFeature
}featurecleanup
(Henry Baker)setjob
/mT[1 0 0 -1 31 761]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Times-Roman
%%IncludeFont: Times-Italic
%%IncludeFont: Times-Bold
%%IncludeFont: Courier
/f0_1/Times-Roman
:mre
/f0_18 f0_1 18 scf
/f0_12 f0_1 12 scf
/f0_10 f0_1 10 scf
/f0_9 f0_1 9 scf
/f1_1/Times-Italic
:mre
/f1_12 f1_1 12 scf
/f1_10 f1_1 10 scf
/f2_1/Times-Bold
:mre
/f2_12 f2_1 12 scf
/f3_1/Courier
:mre
/f3_10 f3_1 10 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(Henry Baker; page: 1 of 8)setjob
%%EndPageSetup
gS 0 0 552 730 rC
41 14 :M
f0_12 sf
-.062(Presented at GC'91 Workshop on Garbage Collection in Object-Oriented Systems at OOPSLA'91.)A
41 717 :M
-.093(\251 1991 Nimble Computer Corporation)A
467 717 :M
(1)S
41 55 :M
f0_18 sf
.199 .02(Cache-Conscious Copying Collectors)J
41 78 :M
f0_12 sf
.214 .021(Henry G. Baker)J
41 95 :M
f1_12 sf
-.009(Nimble Computer Corporation, 16231 Meadow Ridge Way, Encino, CA  91436)A
41 107 :M
1.676 .168(\(818\) 501-4956\312\312\312\(818\) 986-1360 \(FAX\))J
41 134 :M
f2_12 sf
.337(Abstract)A
41 151 :M
f0_12 sf
-.096(Garbage collectors must minimize the scarce resources of cache space and off-chip communications)A
41 163 :M
.173 .017(bandwidth to optimize performance on modern single-chip computer architectures.  Strategies for)J
41 175 :M
-.076(achieving these goals in the context of copying garbage collection are discussed.  A multi-processor)A
41 187 :M
-.088(mutator/collector system is analyzed.  Finally, the Intel 80860XP architecture is studied.)A
41 214 :M
f2_12 sf
1.105(1.\312\312Introduction.)A
41 231 :M
f0_12 sf
-.099(The ubiquity of on-chip caches in modern processor architectures is forced by the increasing latency)A
41 243 :M
-.087(of on-chip memory relative to off-chip memory.  Unfortunately, this latency is also accompanied by)A
41 255 :M
.048 .005(the restricted bandwidth of small pin-outs.  As a result, the management of on-chip memory space)J
41 267 :M
-.03(and off-chip communications traffic has become the major problem in gaining fast execution times)A
41 279 :M
.826 .083(on these processors.  Lam )J
f1_12 sf
.69 .069(et al)J
f0_12 sf
.984 .098( [Lam91] graphically demonstrate this issue for the problem of)J
41 291 :M
.059 .006(multiplying large matrices, where the measured performance of one processor was increased from)J
41 303 :M
.385 .039(0.9 MFLOPS to 4 MFLOPS through the more careful management of these scarce resources.  In)J
41 315 :M
.031 .003(other words, modern processor chips are no longer "CPU-bound", but "I/O-bound".)J
41 332 :M
1.038 .104(Symbolic processing has always been more "I/O-bound" than "CPU-bound" because very few)J
41 344 :M
1.59 .159(symbolic processing algorithms involve the heavy bit-twiddling of floating-point arithmetic.)J
41 356 :M
2.125 .212(Numeric processing with special-purpose floating-point hardware can also be "I/O-bound")J
41 368 :M
1.805 .18([Lam91], and the traditional remedy is increased bandwidth to memory.  Since the control)J
41 380 :M
-.082(structures of numeric programs tend to be quite oblivious to the actual data values, a programmer or)A
41 392 :M
.115 .012(compiler can utilize quite sophisticated prefetching strategies \(e.g., vector registers\) to ensure that)J
41 404 :M
-.039(the data is available when it is needed.  This traditional strategy is no longer appropriate for today's)A
41 416 :M
-.012(limited bandwidth processors, hence the great interest in SIMD architectures in which the required)A
41 428 :M
-.042(bandwidth is spread over many memories and processors.)A
41 445 :M
.303 .03(Unfortunately, the control structures of symbolic processing programs tend to be extremely data-)J
41 457 :M
.052 .005(dependent\321e.g., run-time method determination in object-oriented programming languages\321and)J
41 469 :M
-.062(hence the potential for programmer-directed and compiler-directed prefetching strategies is limited.)A
41 481 :M
1.589 .159(While the general problem of optimizing high-speed symbolic processing with modern chip)J
41 493 :M
-.072(technology is quite difficult, at least one portion of symbolic processing seems regular enough to be)A
41 505 :M
.636 .064(amenable to more sophisticated memory space and bandwidth management strategies\321garbage)J
41 517 :M
-.131(collection.)A
41 544 :M
f2_12 sf
5.311 .531(2.\312\312Copying Garbage Collection)J
41 561 :M
f0_12 sf
-.009(Minsky is credited with the first copying garbage collector [Minsky63], Cheney with an elegant 2-)A
41 573 :M
.795 .079(space model [Cheney70], and Baker with a real-time version of Cheney's algorithm [Baker78].)J
41 585 :M
1.058 .106(Because the first garbage collector did not copy, and because a large fraction of implemented)J
41 597 :M
.66 .066(garbage collectors do not copy, it is important to review the pro's and con's of copying garbage)J
41 609 :M
-.131(collection.)A
41 626 :M
1.372 .137(A non-copying garbage collector \(NCGC\) has the advantage of requiring less address space,)J
41 638 :M
-.061(because objects do not ever occupy two different locations at the same time.  NCGC does not move)A
41 650 :M
1.072 .107(objects behind the compiler's back, and so does not invalidate certain pointer register caching)J
41 662 :M
1.055 .105(compiler optimizations [Chase87].  NCGC can be used in a "conservative" garbage collection)J
41 674 :M
.548 .055(environment because it is necessary to find only )J
f1_12 sf
.174(one)A
f0_12 sf
.477 .048( pointer to each active object, instead of )J
f1_12 sf
.191(all)A
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(Henry Baker; page: 2 of 8)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 45 :M
f0_12 sf
-.062(Presented at GC'91 Workshop on Garbage Collection in Object-Oriented Systems at OOPSLA'91.)A
72 748 :M
-.093(\251 1991 Nimble Computer Corporation)A
498 748 :M
(2)S
72 81 :M
-.015(pointers to all active objects [Boehm88].  Finally, the smaller address space and less object motion)A
72 93 :M
-.108(would seem to optimize performance on cache-based architectures [Zorn91].)A
72 110 :M
.577 .058(A copying garbage collector \(CGC\) has the advantage of trivial allocation of non-homogeneous)J
72 122 :M
.858 .086(objects due to its compact free area, which advantage is essential in a "real-time" environment)J
72 134 :M
.749 .075([Baker78].  CGC can also be used to improve "locality" for virtual memory or cache purposes,)J
72 146 :M
1.947 .195(although NCGC does better than might be expected, due to its linear scan for "sweeping")J
72 158 :M
.531 .053([Clark77].  CGC is a "single-phase" algorithm, which makes it easier to understand and analyze)J
72 171 :M
1.114 .111(than the two-phase "mark/sweep" NCGC algorithm.)J
f0_9 sf
0 -3 rm
.194(1)A
0 3 rm
f0_12 sf
.729 .073(  CGC can more easily expand, and more)J
72 183 :M
-.037(importantly contract, the amount of space under management than can NCGC [Baker78].  Of all of)A
72 195 :M
.155 .016(these issues, the simplicity of storage management under widely varying demands is probably the)J
72 207 :M
-.045(biggest single benefit of CGC.)A
72 234 :M
f2_12 sf
3.568 .357(3.\312\312Overcoming the Drawbacks of Copying Garbage Collection)J
72 251 :M
f0_12 sf
.839 .084(Many of the apparent drawbacks of copying garbage collectors can be overcome.  For list pair)J
72 263 :M
.737 .074(objects, the apparent doubling of address space requirements is offset through the use of CDR-)J
72 275 :M
.883 .088(coding, which allocates the successive elements of lists in adjacent locations, so that no actual)J
72 288 :M
.074 .007("CDR" pointer is required.)J
f0_9 sf
0 -3 rm
(2)S
0 3 rm
f0_12 sf
.052 .005(  For large objects, one can finesse the need to copy by managing only)J
72 300 :M
.606 .061(small "headers"; unfortunately, this brings back the storage fragmentation problem that copying)J
72 313 :M
-.107(eliminates.  A better approach is to avoid copying large objects by modifying the page map instead;)A
f0_9 sf
0 -3 rm
(3)S
0 3 rm
72 325 :M
f0_12 sf
.046 .005(while this scheme does not save any virtual address space, it does save physical address space and)J
72 337 :M
.783 .078(copying overhead.  Of course, the system must support page maps which alias different virtual)J
72 349 :M
-.084(addresses; this requirement has significant implications in cache design, translation lookaside buffer)A
72 361 :M
.594 .059(design and operating system design.  In a properly designed system, however, the aliased cache)J
72 373 :M
-.079(locations are accessible without reloading, thus avoiding unnecessary overhead.)A
72 390 :M
-.116(Although the forwarding machinery of a copying garbage collector involves some complexity, it can)A
72 402 :M
-.017(also be used in support of "lazy allocation" [Baker92CONS].  Lazy allocation is a degenerate form)A
72 414 :M
.15 .015(of generational garbage collection in which the each generation is a stack frame.  All allocation is)J
72 426 :M
-.041(initially performed in the current stack frame, and an object is tenured and copied when a reference)A
72 438 :M
.005 .001(is installed in a higher stack frame or in the global environment.  Since CONS is a subprogram, its)J
72 450 :M
1.349 .135(arguments are already \(conceptually\) "on the stack", and so lazy allocation involves trivially)J
72 462 :M
.653 .065(returning a pointer to this block of arguments\321i.e., C's )J
f3_10 sf
.215(alloca)A
f0_12 sf
.584 .058(.  Since a substantial fraction of)J
72 474 :M
.363 .036(allocations either already conform to stack discipline, or can be made to conform through proper)J
72 486 :M
-.109(programming style, lazy allocation can use the stack to filter out these allocations before the garbage)A
72 498 :M
.077 .008(collector ever becomes aware of their existence.  We believe that lazy allocation, by removing the)J
72 510 :M
1.926 .193(load of these extremely short-lived objects, reduces much of the need for more traditional)J
72 522 :M
.999 .1(generational systems, and allows the garbage collector to spend its efforts on more permanent)J
72 534 :M
(objects.)S
72 551 :M
.811 .081(It has long been known that the Cheney list copying algorithm has the potential for substantial)J
72 563 :M
.338 .034(optimization in a virtual memory and/or cache environment [Barbacci71].  The allocate and scan)J
72 575 :M
.397 .04(pointers both step sequentially through memory, offering opportunities for optimizations such as)J
72 587 :M
.775 .077(prefetching.  In a "stop-and-copy" GC implementation using the Cheney algorithm, the storage)J
72 599 :M
1.157 .116(accessed by the allocate pointer is "write-only", and therefore should never be "paged in" \(or)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 619.24 -.24 .24 215.24 619 .24 72 619 @a
72 637 :M
f0_9 sf
-.059(1)A
f0_12 sf
0 3 rm
-.069(A single-phase NCGC has recently been described [Baker92Tread].)A
0 -3 rm
72 655 :M
f0_9 sf
(2)S
f0_12 sf
0 3 rm
.094 .009(Although CDR-coding is currently out of fashion due to not being required by Tak and 8Queens,)J
0 -3 rm
72 670 :M
-.091(the inexorable pressure to reduce off-chip bandwidth will force its revival.)A
72 685 :M
f0_9 sf
.133(3)A
f0_12 sf
0 3 rm
.598 .06(This "map-diddling" scheme requires that large objects not share pages with other objects; this)J
0 -3 rm
72 700 :M
-.005(requirement is easily arranged, and does not significantly increase overhead, so long as the objects)A
72 712 :M
-.094(are larger than one page.)A
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(Henry Baker; page: 3 of 8)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 45 :M
f0_12 sf
-.062(Presented at GC'91 Workshop on Garbage Collection in Object-Oriented Systems at OOPSLA'91.)A
72 748 :M
-.093(\251 1991 Nimble Computer Corporation)A
498 748 :M
(3)S
72 81 :M
-.026("write-allocated" in the cache\).  While the storage accessed by the scan pointer is read and updated)A
72 93 :M
.638 .064(in place, its page/cache line can be marked for replacement immediately after being completely)J
72 105 :M
1.375 .137(processed, because it will not be referenced again during the garbage collection.  Of course,)J
72 117 :M
.43 .043(copying of any kind in a direct-mapped cache can be disastrously inefficient in the unlucky case)J
72 129 :M
-.046(where both the "from" and "to" locations map to the same cache line; obviously, this situation must)A
72 141 :M
-.098(be specially handled.)A
72 158 :M
-.098(The most troublesome references in the Cheney algorithm are its references to "fromspace" to check)A
72 170 :M
2.446 .245(for and obtain a forwarding pointer.  Consider the situation in which we have the most)J
72 182 :M
.089 .009(information\321the Cheney algorithm is run twice in succession on exactly the same data.  The data)J
72 194 :M
.283 .028(under the scan pointer is used to access the fromspace, to see whether it has a forwarding pointer)J
72 206 :M
-.051(yet.  If the object in fromspace has not yet been moved, then there is no forwarding pointer, and the)A
72 218 :M
-.111(object must be copied to "tospace" at the location of the allocate pointer.  )A
f1_12 sf
-.115(But since this is the second)A
72 230 :M
-.04(running of the algorithm on the same data, the object accessed must have been at the same relative)A
72 242 :M
.096 .01(location in "fromspace" as the allocate pointer is in "tospace"!)J
f0_12 sf
.065 .007(  In other words, there is a ghost or)J
72 254 :M
-.051(shadow in "fromspace" of the allocate pointer in "tospace".  As a result of this ghosting/shadowing,)A
72 266 :M
-.101(the page/cache line in the shadow of the allocate pointer will almost certainly already be in memory,)A
72 278 :M
-.083(and therefore the first access to an object will probably not cause a page fault/cache miss!  Since the)A
72 290 :M
1.043 .104(objects being accessed in the shadow of the allocate pointer are also updated with forwarding)J
72 302 :M
.576 .058(pointers, this updating will also likely occur in the cache.  In other words, if the graph structure)J
72 314 :M
1.2 .12(being copied is really a tree\321i.e., no shared nodes\321then Cheney will copy in a highly local)J
72 326 :M
1.618 .162(fashion, so long as no rearrangement of the objects in address space is actually being done)J
72 338 :M
.04([Baker80].)A
72 355 :M
1.012 .101(The ghosting/shadowing argument works equally well for other copying algorithms, including)J
72 367 :M
.497 .05(those using depth-first orders, so long as the same strategy is used every time.  Since depth-first)J
72 379 :M
.218 .022(ordering is more likely to be preserved in the presence of mutator activity, ghosting/shadowing is)J
72 391 :M
-.063(also likely to be a factor in depth-first incremental/real-time copying garbage collectors.  Of course,)A
72 403 :M
.293 .029("out-of-order" copying caused by the mutator should be performed in a separate region from "in-)J
72 415 :M
-.092(order" copying caused by the collector itself.)A
72 432 :M
.789 .079(References which do obtain a forwarding pointer\321i.e., references which are shared and whose)J
72 444 :M
-.038(reference count exceeds 1\321are much less predictable.  The fact that there are relatively few shared)A
72 456 :M
.223 .022(objects whose reference count exceeds one does not help very much, unless the garbage collector)J
72 468 :M
.278 .028(knows which objects are shared.  It is therefore important to understand why forwarding pointers)J
72 480 :M
-.051(are important.  Forwarding pointers are used to preserve the semantics of shared objects, so that the)A
72 492 :M
-.031(sharing relationships of the copy are isomorphic to the original.  If a garbage collector does not use)A
72 504 :M
1.037 .104(forwarding pointers, then it will "unshare" all objects during copying, leaving all objects with)J
72 516 :M
.957 .096(exactly one reference, and it will diverge on cyclic list structures.  In other words, forwarding)J
72 528 :M
-.085(pointers are used to preserve "object identity" [Baker93ER].)A
72 545 :M
1.018 .102(Based on our intuition and experience, we feel that a large fraction of the unshared objects in)J
72 557 :M
-.032(Clark's measurements [Clark77] are really "functional objects" \(e.g., CONS cells\), which are never)A
72 569 :M
1.127 .113(directly modified \(e.g., by RPLACA/D\).  The usual reason for preserving sharing is so that a)J
72 581 :M
-.005(modification using one path to an object will be visible to all other paths.  In the case of functional)A
72 593 :M
.601 .06(objects, however, the object cannot be modified, and therefore such an operational definition of)J
72 605 :M
.98 .098("object identity" will not work.  So long as any predicates for comparing object identity \(e.g.,)J
72 617 :M
.06 .006(EQ/EQL\) suitably distinguish between functional and non-functional objects [Baker93ER], then a)J
72 629 :M
-.07(program will have no way of distinguishing copies of a functional object from the "original".  Thus,)A
72 641 :M
-.028(for functional objects, a forwarding pointer is not strictly necessary, although without a forwarding)A
72 653 :M
.625 .062(pointer, we may do more copying than is strictly necessary, and thereby increase the amount of)J
72 665 :M
-.033(storage required.  However, we can also efficiently and incrementally calculate the "extended size")A
72 677 :M
-.082(of a functional object while it is being created, so that the garbage collector can quickly estimate the)A
72 689 :M
1.035 .103(cost of copying versus sharing the object [Baker93ER].  Therefore, if a significant fraction of)J
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(Henry Baker; page: 4 of 8)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 45 :M
f0_12 sf
-.062(Presented at GC'91 Workshop on Garbage Collection in Object-Oriented Systems at OOPSLA'91.)A
72 748 :M
-.093(\251 1991 Nimble Computer Corporation)A
498 748 :M
(4)S
72 81 :M
.24 .024(objects are functional, then a copying garbage collector which distinguishes functional from non-)J
72 94 :M
-.068(functional)A
f0_9 sf
0 -3 rm
-.063(4)A
0 3 rm
f0_12 sf
-.071( objects can outperform one which does not.)A
72 111 :M
-.001(Shared non-functional objects still comprise a significant fraction of references, however.  We can)A
72 123 :M
.957 .096(further eliminate the copying and forwarding of non-functional objects which for some reason)J
72 135 :M
-.056(cannot become garbage\321e.g., objects referenced from "outside", or otherwise permanent objects.)A
72 152 :M
1.705 .17(Finally, we must deal with the remainder of shared temporary non-functional objects.  The)J
72 164 :M
.15 .015(forwarding pointers for these objects will be referenced again at some point during the copy, so if)J
72 176 :M
.718 .072(this forwarding pointer has fallen out of the cache/main memory, then accessing it will cause a)J
72 188 :M
-.101(cache miss/page fault.  If we have already implemented the other optimizations which make the best)A
72 200 :M
-.076(use of the cache/main memory, then almost all of the misses/faults will be of the forwarding pointer)A
72 212 :M
1.326 .133(reference type.  In other words, the cache/main memory becomes a cache for storing mainly)J
72 224 :M
.156 .016(forwarding pointers.  Obviously, in order to make the best use of this space, we should make sure)J
72 236 :M
.197 .02(that the density of forwarding pointers is at a maximum.  In this case, it might prove beneficial to)J
72 248 :M
.844 .084(keep forwarding pointers in a separate table, instead of storing them in the fromspace.  This is)J
72 260 :M
.769 .077(certainly the case with large objects, but the cost/benefit for smaller objects requires additional)J
72 272 :M
.2(study.)A
72 289 :M
.934 .093(The latency of pointer forwarding is a limit to copying collector performance.  The traditional)J
72 301 :M
-.022(Cheney GC must wait until the forwarding pointer is available before it can move the scan pointer.)A
72 313 :M
.168 .017(However, if latency\321not bandwidth\321is the bottleneck, one can perform a number of forwarding)J
72 325 :M
.126 .013(pointer lookups in a pipelined fashion, so that while the first lookup may have significant latency,)J
72 337 :M
.088 .009(the additional forwarding pointers will arrive very quickly, and the time for the whole sequence is)J
72 349 :M
.397 .04(significantly smaller than the product of the number of lookups and the random latency.  In fact,)J
72 361 :M
-.112(Appel uses this scheme in his vectorized copying garbage collector [Appel89].)A
72 378 :M
.155 .016(Unfortunately, this pipelining scheme does not reduce the communication bandwidth, since every)J
72 390 :M
-.082(pointer must be traced, even though most of them will not be forwarded.  The scheme does have the)A
72 402 :M
-.074(advantage, however, of not tying up space in the cache, which might be used more profitably by the)A
72 414 :M
-.058(mutator instead of the collector.  For example, the original implementation of Baker's RTGC on the)A
72 426 :M
-.1(MIT Lisp Machine \(not generational\) required special paging code to keep the GC from pushing out)A
72 438 :M
.328 .033(all of the mutator pages.  Even a "stop-and-copy" GC will push out all mutator pages, and recent)J
72 450 :M
.162 .016(data indicate that the cost of restoring pages/lines after a context switch may be much higher than)J
72 462 :M
-.047(previously thought [Mogul91].)A
72 479 :M
-.082(If we can reliably distinguish forwarding references with a simple calculation before performing the)A
72 491 :M
.269 .027(tracing a reference, then we can pipeline a large number of forwarding lookups to run in parallel,)J
72 503 :M
-.065(not only with the mutator, but also with the copying/allocation portion of the garbage collector.  All)A
72 515 :M
.141 .014(that is needed is a presence/scoreboard/I-structure/future bit, like that found in the Denelcor HEP,)J
72 527 :M
.01 .001(which indicates that the contents of the requested memory reference have arrived.  The pipeline of)J
72 539 :M
.061 .006(forwarding lookups is then loaded with a series of memory-memory moves, and it will drain itself)J
72 551 :M
-.178(automatically.)A
72 568 :M
-.052(Consider a scheme for distinguishing first \(copying\) from non-first \(forwarding lookup\) references.)A
72 580 :M
.875 .087(Suppose that every pointer is tagged at the time it is stored by the garbage collector with a bit)J
72 592 :M
-.008(indicating whether it is the first reference to its target object; this information is trivially computed)A
72 604 :M
-.033(by the garbage collector while copying.  We must now make sure that the mutator does not destroy)A
72 616 :M
-.107(this information.  If all new conses are in a separate region, then the garbage collector can treat these)A
72 628 :M
1.622 .162(differently from previously copied conses, and thus new conses do not have to contain this)J
72 640 :M
.521 .052(information.  The only problem occurs when the mutator changes a pointer in an old cons using)J
72 652 :M
.472 .047(RPLACA/D.  RPLACA/D of an old pointer into an old cons is the difficult case.  There are two)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 667.24 -.24 .24 215.24 667 .24 72 667 @a
72 685 :M
f0_9 sf
.248(4)A
f0_12 sf
0 3 rm
1.109 .111(Advocates of functional objects have always felt that the antonym of "functional" was "non-)J
0 -3 rm
72 700 :M
-.014(functional"!  Perhaps now the politically correct term should be "other-functioned" or "differently-)A
72 712 :M
-.063(functioned" objects.)A
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(Henry Baker; page: 5 of 8)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 45 :M
f0_12 sf
-.062(Presented at GC'91 Workshop on Garbage Collection in Object-Oriented Systems at OOPSLA'91.)A
72 748 :M
-.093(\251 1991 Nimble Computer Corporation)A
498 748 :M
(5)S
72 81 :M
-.099(possible solutions\321either have the mutator install an invisible pointer to a newly consed hidden cell)A
72 93 :M
-.085(which the GC will recognize as special, or have the mutator do additional work.  If a back-pointer is)A
72 105 :M
.335 .034(stored in every object which points back to its first reference, then RPLACA/D can compare this)J
72 117 :M
-.062(back-pointer to its first argument.  If RPLACA/D is storing into a location whose address is smaller)A
72 129 :M
.205 .02(than the back-pointer, then RPLACA/D can update the back-pointer to point to its first argument,)J
72 141 :M
-.078(which is now earlier than the previous first reference.)A
72 158 :M
.681 .068(Unfortunately, schemes for flagging the first reference \(in GC order\) provide only "hints".  If a)J
72 170 :M
.602 .06(pointer is encountered which indicates that it is the first reference, then it will be.  On the other)J
72 182 :M
.13 .013(hand, the first reference pointer itself may become inaccessible, and the GC will encounter a non-)J
72 194 :M
.368 .037(first reference before it has copied the target object.  In other words, the GC must be prepared to)J
72 206 :M
-.084(handle the case in which a forwarding pointer is expected, but it is not there.)A
72 233 :M
f2_12 sf
4.875 .488(4.\312\312Parallel Garbage Collection)J
72 250 :M
f0_12 sf
2.209 .221(Since copying garbage collection increases the traffic to memory and pushes out mutator)J
72 262 :M
-.041(information from the cache/main memory, a copying garbage collector implemented by means of a)A
72 274 :M
.983 .098(second processor chip looks promising.  So long as cache coherency between the mutator and)J
72 286 :M
-.011(collector chips can be assured, and so long as the two caches do not fight for control of the various)A
72 298 :M
.968 .097(cache lines, then a 2-chip system could provide a relatively inexpensive speedup for symbolic)J
72 310 :M
.266 .027(processing tasks.)J
72 327 :M
.16 .016(The first line of defense in a parallel symbolic system should be )J
f1_12 sf
.273 .027(lazy allocation)J
f0_12 sf
.346 .035( [Baker92CONS].)J
72 339 :M
.141 .014(Because lazy allocation efficiently allocates and deallocates very short-lived objects as part of the)J
72 351 :M
1.399 .14(normal operation of the call stack, it meshes very well with normal mutator cache behavior.)J
72 363 :M
.316 .032(Furthermore, in a parallel system with multiple mutators, each processor can lazily allocate in its)J
72 375 :M
-.076(own private stack without any interference from the other processors.)A
72 392 :M
-.012(We now consider a 2-processor system using the original RTGC scheme [Baker78].  The object of)A
72 404 :M
-.005(the game is to fool the mutator into thinking that the collection was finished completely during the)A
72 416 :M
.077 .008("flip".  We first suppose that the mutator is stopped during a "flip", so that its TLB and data cache)J
72 428 :M
.136 .014(can be invalidated.  Then, when it resumes processing, it starts accessing only the tospace.  While)J
72 440 :M
-.097(several schemes have been proposed which utilize the mutator's virtual memory page map to protect)A
72 452 :M
.789 .079(the mutator from unscanned objects [Shaw87] [Appel88], we will consider a scheme involving)J
72 464 :M
-.109(more cooperation from the mutator.)A
72 481 :M
-.049(Suppose that the mutator attempts to perform a CAR/CDR and finds a fromspace pointer.  Suppose)A
72 493 :M
-.089(the mutator attempts to handle the "move" itself.  Then it will access fromspace to find a forwarding)A
72 505 :M
-.07(pointer; if a forwarding pointer is not found, then the object must be transported into tospace.  If the)A
72 517 :M
.614 .061(mutator accesses fromspace, then it will have a miss on its TLB, as well as a miss on its cache,)J
72 529 :M
.152 .015(which will cause some mutator information to be removed from these caches.  If the mutator then)J
72 541 :M
.506 .051(finds no forwarding pointer, then it must copy the information into tospace, using either its own)J
72 553 :M
1.117 .112(allocate pointer, or somehow gaining access to the collector's allocate pointer.  Accessing the)J
72 565 :M
1.577 .158(portion of tospace where the object is being copied will also likely cause cache misses and)J
72 577 :M
-.104(replacements, although any tospace information brought into the mutator cache in this way will very)A
72 589 :M
-.113(likely be referenced, and we may have performed a beneficial prefetch.)A
72 606 :M
.336 .034(Suppose that the architecture offers a way to read bypassing the data cache.  Then the fromspace)J
72 618 :M
-.068(can be accessed without affecting the contents of the cache, and the transport can also be performed)A
72 630 :M
.78 .078(without affecting the contents of the mutator cache.  Unfortunately, the TLB cannot usually be)J
72 642 :M
-.039(bypassed, so its contents may be replaced.)A
72 659 :M
.021 .002(If the mutator does some of its own transportation, then some synchronization is required between)J
72 671 :M
-.073(the mutator and the collector.  The mutator can look for a forwarding pointer without synchronizing)A
72 683 :M
1.837 .184(with the collector, but if one is not found, then it must synchronize with the collector.  If)J
72 695 :M
.257 .026(synchronization is inevitable, then perhaps the collector should do the actual copying itself.  This)J
72 707 :M
-.113(requires that the mutator tell the collector which object to move.  The mutator puts the address of the)A
endp
%%Page: 6 6
%%BeginPageSetup
initializepage
(Henry Baker; page: 6 of 8)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 45 :M
f0_12 sf
-.062(Presented at GC'91 Workshop on Garbage Collection in Object-Oriented Systems at OOPSLA'91.)A
72 748 :M
-.093(\251 1991 Nimble Computer Corporation)A
498 748 :M
(6)S
72 81 :M
.106 .011(object in a mailbox which the collector checks on every cycle, and starts spinning on the object in)J
72 93 :M
.072 .007(fromspace waiting for a forwarding pointer to appear.  The collector finds the object address in its)J
72 105 :M
-.027(mailbox, removes it and "transports" the object, installs the forwarding pointer, and then goes back)A
72 117 :M
.831 .083(to its scanning.  No special synchronization hardware is required, because only the collector is)J
72 129 :M
.813 .081(allowed to modify fromspace with forwarding pointers.  Furthermore, if there are only the two)J
72 141 :M
-.066(processors in the system, then the mailbox consists of a single memory location.)A
72 158 :M
1.537 .154(Assuming modern MESI or MEOSI cache consistency protocols \(e.g., IEEE Futurebus\), the)J
72 170 :M
.151 .015(mutator and the collector will not fight over the fromspace forwarding address cache line because)J
72 182 :M
-.003(both processors have a copy\321i.e., the line has status "Shared".  Only when the collector stores the)A
72 194 :M
-.029(forwarding address will it invalidate the mutator's cache line, which will cause it to get the updated)A
72 206 :M
-.059(information.)A
72 223 :M
.02 .002(When the collector has finished, it sends a message in a special mailbox which the mutator checks)J
72 235 :M
.924 .092(from time to time inside its allocation routine, and the collector then goes to sleep.  When the)J
72 247 :M
.633 .063(mutator decides the time is ripe, it "flips".  To flip, it sets up certain registers and wakes up the)J
72 259 :M
.706 .071(garbage collector, which starts by scanning the mutator stack from top to bottom.  The mutator)J
72 271 :M
-.047(spins on the collector scanner, waiting for it to finish the top stack frame.  Once the top stack frame)A
72 283 :M
-.037(has been scanned, the mutator can resume processing.  From then on, every time the mutator wants)A
72 295 :M
-.079(to pop the stack, it must spin until that stack frame has been scanned.)A
72 312 :M
-.101(Should the mutator invalidate its TLB and flush its cache on a flip?  The mere action of the collector)A
72 324 :M
-.005(installing forwarding pointers during the flip will flush and/or invalidate most mutator cache lines,)A
72 336 :M
.842 .084(so an explicit flush should not be necessary.  Furthermore, it is likely that right after a flip the)J
72 348 :M
-.072(mutator will have to do a significant amount of pointer forwarding itself, in which case the old TLB)A
72 360 :M
-.101(and/or cache entries could still be useful.)A
72 377 :M
.377 .038(We have argued that objects larger than one page should be page-aligned and not be shared with)J
72 389 :M
.341 .034(other objects.  This allows the object to be "copied" by merely changing the page map instead of)J
72 401 :M
-.028(physically moving the object.  In this case, older mutator cache entries may still be valid once their)A
72 413 :M
-.015(new virtual address has been updated, and it is therefore important that these entries not be flushed)A
72 425 :M
-.062(during a flip.  When a pointer is found which points to a large object in fromspace, the mutator puts)A
72 437 :M
-.002(it into the mailbox and spins on its forwarding address, as before.  When the forwarding address is)A
72 449 :M
.477 .048(obtained, however, the mutator tospace page map is updated to point to this forwarding address,)J
72 461 :M
-.117(and the mutator can continue.)A
72 478 :M
-.073(In summary, modern cache consistency protocols should allow most garbage collection overhead to)A
72 490 :M
1.418 .142(be removed to a second processor.  The vast majority of traffic would flow through the GC)J
72 502 :M
1.104 .11(processor instead of the mutator, allowing the mutator to keep its cache locality and make its)J
72 514 :M
-.143(mutating more efficient.)A
72 541 :M
f2_12 sf
3.792 .379(5.\312\312A Case Study\321The Intel 80860XP Architecture)J
72 558 :M
f0_12 sf
.098 .01(The Intel 80860 is a modern 64-bit RISC architecture with on-chip instruction and data caches.  It)J
72 570 :M
.121 .012(has a standard 32-bit byte-addressed virtual address space which is mapped onto a 32-bit physical)J
72 582 :M
.091 .009(address space.  The page map has the standard read-write, read-only and no access capabilities, as)J
72 594 :M
.883 .088(well as reference and dirty bits.  There is an on-chip translation lookaside buffer \(TLB\) which)J
72 606 :M
.172 .017(caches page table entries.  The 80860 has single instructions which can read and write quad-word)J
72 618 :M
-.064(\(16-byte\) blocks, although these instructions do not finish in a single cycle.)A
72 635 :M
.542 .054(The 80860XP 16Kbyte on-chip data cache is 4-way set-associative, with a line size of 32 bytes.)J
72 647 :M
-.045(This on-chip cache can be easily extended into an off-chip 256Kbyte/512Kbyte SRAM cache.  The)A
72 659 :M
-.102(80860 architecture has "pipelined" load instructions which normally bypass the data cache, although)A
72 671 :M
.21 .021(for consistency they load data from the cache if there is a cache hit.  The 80860 store instructions)J
72 683 :M
-.103(write back to the cache if there is a cache hit, or write directly back to memory if there is not a cache)A
endp
%%Page: 7 7
%%BeginPageSetup
initializepage
(Henry Baker; page: 7 of 8)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 45 :M
f0_12 sf
-.062(Presented at GC'91 Workshop on Garbage Collection in Object-Oriented Systems at OOPSLA'91.)A
72 748 :M
-.093(\251 1991 Nimble Computer Corporation)A
498 748 :M
(7)S
72 81 :M
-.065(hit; they do not "write-allocate" in the cache.  In other words, only normal reads can be used to load)A
72 94 :M
-.091(the data cache.)A
f0_9 sf
0 -3 rm
(5)S
0 3 rm
72 111 :M
f0_12 sf
.67 .067(The 80860XP utilizes a MESI cache coherency protocol based on a global bus and "snooping".)J
72 123 :M
.45 .045(The caches are "write-back" by default, but can be made "write-through" on a per-page basis, or)J
72 135 :M
-.074(even "non-cachable".)A
72 152 :M
1.143 .114(The 64-bit bus and quad-word load/store capabilities give the 80860 substantial bandwidth to)J
72 164 :M
.168 .017(support a copying garbage collector, although the bandwidth of the 80860 bus will only support a)J
72 176 :M
-.037(load every other cycle [Moyer91].  The cache-bypassing capabilities of the "pfld" instruction allow)A
72 188 :M
.101 .01(the collector to operate without damaging the cache locality of the mutator.  Unfortunately, "pfld")J
72 200 :M
.459 .046(loads a floating-point register with latency of at least 6 cycles, and the information must then be)J
72 212 :M
-.069(transferred to an integer unit with a latency of 3 before before it can be used as an address.  The set-)A
72 224 :M
-.085(associativity of the cache avoids the copy-thrashing behavior of a direct-mapped cache.  Finally, the)A
72 236 :M
-.032(advanced cache coherency protocol should allow a dedicated garbage collector processor to reduce)A
72 248 :M
-.082(the load on a main mutator processor.)A
72 275 :M
f2_12 sf
1.357(6.\312\312Conclusions)A
72 292 :M
f0_12 sf
.379 .038(We have examined the details of the interaction of a copying garbage collector with the memory)J
72 304 :M
.06 .006(system of modern RISC architectures.  In most cases, the drawbacks of a copying collector can be)J
72 316 :M
-.011(easily ameliorated, especially if mechanisms for bypassing the cache are available.  We also found)A
72 328 :M
-.114(that modern cache coherency protocols support parallel garbage collection rather nicely.  Finally, we)A
72 340 :M
1.137 .114(studied the Intel 80860XP architecture, and found that it is very suitable for copying garbage)J
72 352 :M
-.064(collection, in both single-processor and multi-processor configurations.)A
72 369 :M
-.009(We are in the process of constructing a simple experiment to measure the improvement in copying)A
72 381 :M
.156 .016(collector performance due to the optimizations discussed above.  We are particularly interested in)J
72 393 :M
-.091(the improvements due to bypassing the cache.)A
72 420 :M
f2_12 sf
.672(References)A
72 437 :M
f0_10 sf
.095 .01(Appel, Andrew W.  "Garbage Collection Can Be Faster Than Stack Allocation".  )J
f1_10 sf
.09 .009(Info. Proc. Let. 25)J
f0_10 sf
.163 .016( \(1987\),275-279.)J
72 448 :M
.415 .042(Appel, Andrew W.; Ellis, John R.; and Li, Kai.  "Real-time concurrent garbage collection on stock multiprocessors".)J
89 459 :M
f1_10 sf
.546 .055(ACM Prog. Lang. Des. and Impl.)J
f0_10 sf
.903 .09(, June\3121988,11-20.)J
72 470 :M
1.372 .137(Appel, Andrew W.  "Simple Generational Garbage Collection and Fast Allocation".  )J
f1_10 sf
1.21 .121(Soft. Prac. & Exper. 19)J
f0_10 sf
.607(,2)A
89 481 :M
.159(\(Feb.\3121989\),171-183.)A
72 492 :M
.04 .004(Appel, A.W., and Bendiksen, A.  "Vectorized Garbage Collection".  )J
f1_10 sf
.051 .005(J. Supercomputing 3)J
f0_10 sf
.065 .007( \(1989\),151-160.)J
72 503 :M
.353 .035(Baker, Henry G.  "List Processing in Real Time on a Serial Computer".  )J
f1_10 sf
.429 .043(CACM 21,4 )J
f0_10 sf
.753 .075(\(April\3121978\), 280-294.)J
72 514 :M
1.185 .118(Baker, Henry G.  "The Paging Behavior of the Cheney List Copying Algorithm".  Tech. Rept., CS Dept., U. of)J
89 525 :M
.079 .008(Rochester, NY, 1980; copies available from the author.)J
72 536 :M
.277 .028(Baker, Henry G.  "Unify and Conquer \(Garbage, Updating, Aliasing, ...\) in Functional Languages".  )J
f1_10 sf
.353 .035(Proc. 1990 ACM)J
89 547 :M
.326 .033(Conf. on Lisp and Functional Progr.)J
f0_10 sf
.408 .041(, June\3121990, 218-226.)J
72 558 :M
.46 .046(Baker, Henry G.  "CONS Should not CONS its Arguments, or, A Lazy Alloc is a Smart Alloc".  ACM )J
f1_10 sf
.782 .078(Sigplan Not.)J
89 569 :M
.138(27)A
f0_10 sf
.63 .063(,3 \(March\3121992\), 24-34.)J
72 580 :M
.279 .028(Baker, Henry G.  "Equal Rights for Functional Objects or, The More Things Change, The More They Are the Same".)J
89 591 :M
.48 .048(ACM )J
f1_10 sf
.582 .058(OOPS Messenger 4)J
f0_10 sf
.544 .054(,4 \(Oct.\3121993\), 2-27.)J
72 602 :M
.191 .019(Baker, Henry G.  "The Treadmill: Real-Time Garbage Collection Without Motion Sickness".  ACM )J
f1_10 sf
.198 .02(Sigplan Not. 27)J
f0_10 sf
.083(,3)A
89 613 :M
.663 .066(\(March\3121992\), 66-70.)J
72 624 :M
.361 .036(Barbacci, M.  "A LISP Processor for C.ai".  Memo CMU-CS-71-103, CMU, Pittsburgh, 1971.)J
72 635 :M
.142 .014(Bishop, P.B.  )J
f1_10 sf
.196 .02(Computer Systems with a very large address space and garbage collection)J
f0_10 sf
.172 .017(.  Ph.D. Thesis, TR-178, MIT)J
89 646 :M
.875 .088(Lab. for Comp. Sci., Camb., MA, May\3121977.)J
72 657 :M
.465 .046(Boehm, Hans-J., and Demers, Alan.  "Garbage Collection in an Uncooperative Environment".  )J
f1_10 sf
.453 .045(Soft. Pract. & Exper.)J
89 668 :M
.197(18)A
f0_10 sf
1.166 .117(,9 \(Sept.\3121988\),807-820.)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 679.24 -.24 .24 215.24 679 .24 72 679 @a
72 697 :M
f0_9 sf
(5)S
f0_12 sf
0 3 rm
.213 .021(This cache behavior means that high-level language compilers must not "optimize" away certain)J
0 -3 rm
72 712 :M
-.08(apparently redundant loads, which are used only to load the cache.)A
endp
%%Page: 8 8
%%BeginPageSetup
initializepage
(Henry Baker; page: 8 of 8)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 45 :M
f0_12 sf
-.062(Presented at GC'91 Workshop on Garbage Collection in Object-Oriented Systems at OOPSLA'91.)A
72 748 :M
-.093(\251 1991 Nimble Computer Corporation)A
498 748 :M
(8)S
72 81 :M
f0_10 sf
1.29 .129(Chase, David.  "Garbage Collection and Other Optimizations".  PhD Thesis, Rice University Comp. Sci. Dept.,)J
89 92 :M
.365(Nov.\3121987.)A
72 103 :M
.495 .049(Cheney, C.J.  "A Nonrecursive List Compacting Algorithm".  )J
f1_10 sf
.701 .07(CACM 13)J
f0_10 sf
.917 .092(,11 \(Nov.\3121970\),677-678.)J
72 114 :M
.445 .044(Clark, D.W., and Green, C.C.  "An Empirical Study of List Structure in LISP".  )J
f1_10 sf
.753 .075(CACM 20)J
f0_10 sf
.9 .09(,2 \(Feb.\3121977\),78-87.)J
72 125 :M
.035 .003(Fisher, D.A.  "Bounded Workspace Garbage Collection in an Address-Order Preserving List Processing Environment".)J
89 136 :M
f1_10 sf
.769 .077(Inf.Proc.Lett. 3)J
f0_10 sf
.918 .092(,1 \(July\3121974\),29-32.)J
72 147 :M
.335 .034(Gelernter, H., )J
f1_10 sf
.238 .024(et al)J
f0_10 sf
.357 .036(.  "A Fortran-Compiled List-Processing Language".  )J
f1_10 sf
.278 .028(J. ACM 7)J
f0_10 sf
.592 .059(,2 \(Sept.\3121960\),87-101.)J
72 158 :M
1.445 .145(Hederman, Lucy.  "Compile Time Garbage Collection".  MS Thesis, Rice University Computer Science Dept.,)J
89 169 :M
.372(Sept.\3121988.)A
72 180 :M
.891 .089(Lam, Monica S., )J
f1_10 sf
.689 .069(et al)J
f0_10 sf
.958 .096(.  "The Cache Performance and Optimizations of Blocked Algorithms".  )J
f1_10 sf
1.896 .19(ACM ASPLOS-IV,)J
89 191 :M
.698 .07(Sigplan Not. 26)J
f0_10 sf
1.118 .112(,4 \(April\3121991\),63-74.)J
72 202 :M
.607 .061(Lieberman, H., and Hewitt, C.  "A Real-Time Garbage Collector Based on the Lifetimes of Objects".  )J
f1_10 sf
.945 .094(CACM 26)J
f0_10 sf
.332 .033(, 6)J
89 213 :M
.115(\(June\3121983\),419-429.)A
72 224 :M
.24 .024(MacLennan, B.J.  "Values and Objects in Programming Languages".  )J
f1_10 sf
.252 .025(Sigplan Not. 17)J
f0_10 sf
.415 .041(,12 \(Dec.\3121982\),70-79.)J
72 235 :M
.368 .037(McDermott, D.  "An Efficient Environment Allocation Scheme in an Interpreter for a Lexically-scoped LISP".  )J
f1_10 sf
.147(1980)A
89 246 :M
.542 .054(Lisp Conference)J
f0_10 sf
.47 .047(, Stanford, CA, Aug.\3121980,154-162.)J
72 257 :M
.264 .026(Minsky, M.L.  "A LISP garbage collector algorithm using serial secondary storage".  MIT AI Memo 58, Oct.\3121963.)J
72 268 :M
.881 .088(Mogul, J.C., and Borg, A.  "The Effect of Context Switches on Cache Performance".  )J
f1_10 sf
1.556 .156(ACM ASPLOS-IV, Sigplan)J
89 279 :M
.729 .073(Not. 26)J
f0_10 sf
1.202 .12(,4 \(April\3121991\),75-84.)J
72 290 :M
.744 .074(Moon, D.  "Garbage Collection in a Large Lisp System".  )J
f1_10 sf
.915 .091(ACM Symp. on Lisp and Functional Prog.)J
f0_10 sf
.871 .087(, Austin, TX,)J
89 301 :M
.51 .051(1984, 235-246.)J
72 312 :M
1.675 .167(Moss, J.E.B.  "Managing Stack Frames in Smalltalk".  )J
f1_10 sf
2.112 .211(SIGPLAN '87 Symp. on Interpreters and Interpretive)J
89 323 :M
.117(Techniques)A
f0_10 sf
.157 .016(, in )J
f1_10 sf
.51 .051(Sigplan Notices 22)J
f0_10 sf
.577 .058(,7 \(July\3121987\), 229-240.)J
72 334 :M
.224 .022(Moyer, Steven A.  "Performance of the iPSC/860 Node Architecture".  IPC-TR-91-007, Inst. for Parallel Comp., Eng.)J
89 345 :M
.4 .04(& Applied Sci., U. of Va., May 1991.)J
72 356 :M
1.006 .101(Rees, J. and Clinger, W., et al.  "Revised Report on the Algorithmic Language Scheme".  )J
f1_10 sf
1.382 .138(Sigplan Notices 21)J
f0_10 sf
.434(,12)A
89 367 :M
.113(\(Dec.\3121986\),37-79.)A
72 378 :M
1.169 .117(Ruggieri, Cristina; and Murtagh, Thomas P.  "Lifetime analysis of dynamically allocated objects".  )J
f1_10 sf
2.007 .201(ACM POPL)J
89 389 :M
.043('88)A
f0_10 sf
.051(,285-293.)A
72 400 :M
1.527 .153(Shaw, Robert A.  "Improving Garbage Collector Performance in Virtual Memory".  Stanford CSL-TR-87-323,)J
89 411 :M
.191(March\3121987.)A
72 422 :M
.148 .015(Terashima, M., and Goto, E.  "Genetic Order and Compactifying Garbage Collectors".  )J
f1_10 sf
.135 .013(IPL 7)J
f0_10 sf
.25 .025(,1 \(Jan.\3121978\),27-32.)J
72 433 :M
.424 .042(Unger, D.  "Generation Scavenging: A non-disruptive, high performance storage reclamation algorithm".  )J
f1_10 sf
.537 .054(ACM Soft.)J
89 444 :M
.524 .052(Eng. Symp. on Prac. Software Dev. Envs., Sigplan Notices 19)J
f0_10 sf
.95 .095(,6 \(June\3121984\),157-167.)J
72 455 :M
.347 .035(Weizenbaum, J.  "Knotted List Structures".  )J
f1_10 sf
.49 .049(CACM 5)J
f0_10 sf
.698 .07(,3 \(March\3121962\),161-165.)J
72 466 :M
.727 .073(Wilson, Paul R.  "Some Issues and Strategies in Heap Management and Memory Hierarchies".  )J
f1_10 sf
.957 .096(ACM Sigplan Not.)J
89 477 :M
.117(26)A
f0_10 sf
.706 .071(,3 \(March\3121991\),45-52.)J
72 488 :M
.16 .016(Wise, D.S., and Friedman, D.P.  "The One-Bit Reference Count".  )J
f1_10 sf
.179 .018(BIT 17)J
f0_10 sf
.282 .028( \(1977\),351-359.)J
72 499 :M
1.219 .122(Zorn, Benjamin.  "The Effect of Garbage Collection on Cache Performance".  TR CU-CS-528-91, U. Colorado,)J
89 510 :M
(Boulder, May 1991,41p.)S
endp
%%Trailer
end
%%EOF
