%!PS-Adobe-3.0
%%BoundingBox: (atend)
%%Pages: (atend)
%%PageOrder: (atend)
%%DocumentFonts: (atend)
%%Creator: Frame 5.0
%%DocumentData: Clean7Bit
%%EndComments
%%BeginProlog
%
% Frame ps_prolog 5.0, for use with Frame 5.0 products
% This ps_prolog file is Copyright (c) 1986-1995 Frame Technology
% Corporation.  All rights reserved.  This ps_prolog file may be
% freely copied and distributed in conjunction with documents created
% using FrameMaker, FrameMaker/SGML and FrameViewer as long as this 
% copyright notice is preserved.
%
% FrameMaker users specify the proper paper size for each print job in the
% "Print" dialog's "Printer Paper Size" "Width" and "Height~ fields.  If the
% printer that the PS file is sent to does not support the requested paper
% size, or if there is no paper tray of the proper size currently installed, 
% then the job will not be printed.  The following flag, if set to true, will
% cause the job to print on the default paper in such cases.
/FMAllowPaperSizeMismatch            false def
%
% Frame products normally print colors as their true color on a color printer
% or as shades of gray, based on luminance, on a black-and white printer. The
% following flag, if set to true, forces all non-white colors to print as pure
% black. This has no effect on bitmap images.
/FMPrintAllColorsAsBlack             false def
%
% Frame products can either set their own line screens or use a printer's 
% default settings. Three flags below control this separately for no 
% separations, spot separations and process separations. If a flag
% is true, then the default printer settings will not be changed. If it is
% false, Frame products will use their own settings from a table based on
% the printer's resolution.
/FMUseDefaultNoSeparationScreen      true  def
/FMUseDefaultSpotSeparationScreen    true  def
/FMUseDefaultProcessSeparationScreen false def
%
% For any given PostScript printer resolution, Frame products have two sets of 
% screen angles and frequencies for printing process separations, which are 
% recomended by Adobe. The following variable chooses the higher frequencies
% when set to true or the lower frequencies when set to false. This is only
% effective if the appropriate FMUseDefault...SeparationScreen flag is false.
/FMUseHighFrequencyScreens true def
%
% The following is a set of predefined optimal frequencies and angles for various
% common dpi settings. This is taken from "Advances in Color Separation Using
% PostScript Software Technology," from Adobe Systems (3/13/89 P.N. LPS 0043)
% and corrolated with information which is in various PPD (4.0) files.
%
% The "dpiranges" figure is the minimum dots per inch device resolution which
% can support this setting. The "low" and "high" values are controlled by the
% setting of the FMUseHighFrequencyScreens flag above. The "TDot" flags control
% the use of the "Yellow Triple Dot" feature whereby the frequency id divided by
% three, but the dot function is "trippled" giving a block of 3x3 dots per cell.
%
% PatFreq is a compromise pattern frequency for ps Level 2 printers which is close
% to the ideal WYSIWYG pattern frequency of 9 repetitions/inch but does not beat
% (too badly) against the screen frequencies of any separations for that DPI.
/dpiranges   [  2540    2400    1693     1270    1200     635      600      0      ] def
/CMLowFreqs  [ 100.402  94.8683 89.2289 100.402  94.8683  66.9349  63.2456 47.4342 ] def
/YLowFreqs   [  95.25   90.0    84.65    95.25   90.0     70.5556  66.6667 50.0    ] def
/KLowFreqs   [  89.8026 84.8528 79.8088  89.8026 84.8528  74.8355  70.7107 53.033  ] def
/CLowAngles  [  71.5651 71.5651 71.5651 71.5651  71.5651  71.5651  71.5651 71.5651 ] def
/MLowAngles  [  18.4349 18.4349 18.4349 18.4349  18.4349  18.4349  18.4349 18.4349 ] def
/YLowTDot    [  true    true    false    true    true     false    false   false   ] def
/CMHighFreqs [ 133.87  126.491 133.843  108.503 102.523  100.402   94.8683 63.2456 ] def
/YHighFreqs  [ 127.0   120.0   126.975  115.455 109.091   95.25    90.0    60.0    ] def
/KHighFreqs  [ 119.737 113.137 119.713  128.289 121.218   89.8026  84.8528 63.6395 ] def
/CHighAngles [  71.5651 71.5651 71.5651  70.0169 70.0169  71.5651  71.5651 71.5651 ] def
/MHighAngles [  18.4349 18.4349 18.4349  19.9831 19.9831  18.4349  18.4349 18.4349 ] def
/YHighTDot   [  false   false   true     false   false    true     true    false   ] def
/PatFreq     [	10.5833 10.0     9.4055  10.5833 10.0	  10.5833  10.0	   9.375   ] def
%
% PostScript Level 2 printers contain an "Accurate Screens" feature which can
% improve process separation rendering at the expense of compute time. This 
% flag is ignored by PostScript Level 1 printers.
/FMUseAcccurateScreens true def
%
% The following PostScript procedure defines the spot function that Frame
% products will use for process separations. You may un-comment-out one of
% the alternative functions below, or use your own.
%
% Dot function
/FMSpotFunction {abs exch abs 2 copy add 1 gt 
		{1 sub dup mul exch 1 sub dup mul add 1 sub }
		{dup mul exch dup mul add 1 exch sub }ifelse } def
%
% Line function
% /FMSpotFunction { pop } def
%
% Elipse function
% /FMSpotFunction { dup 5 mul 8 div mul exch dup mul exch add 
%		sqrt 1 exch sub } def
%
%
/FMversion (5.0) def 
/fMLevel1 /languagelevel where {pop languagelevel} {1} ifelse 2 lt def
/FMPColor
	fMLevel1 {
		false
		/colorimage where {pop pop true} if
	} {
		true
	} ifelse
def
/FrameDict 400 dict def 
systemdict /errordict known not {/errordict 10 dict def
		errordict /rangecheck {stop} put} if
% The readline in PS 23.0 doesn't recognize cr's as nl's on AppleTalk
FrameDict /tmprangecheck errordict /rangecheck get put 
errordict /rangecheck {FrameDict /bug true put} put 
FrameDict /bug false put 
mark 
% Some PS machines read past the CR, so keep the following 3 lines together!
currentfile 5 string readline
00
0000000000
cleartomark 
errordict /rangecheck FrameDict /tmprangecheck get put 
FrameDict /bug get { 
	/readline {
		/gstring exch def
		/gfile exch def
		/gindex 0 def
		{
			gfile read pop 
			dup 10 eq {exit} if 
			dup 13 eq {exit} if 
			gstring exch gindex exch put 
			/gindex gindex 1 add def 
		} loop
		pop 
		gstring 0 gindex getinterval true 
		} bind def
	} if
/FMshowpage /showpage load def
/FMquit /quit load def
/FMFAILURE { 
	dup = flush 
	FMshowpage 
	/Helvetica findfont 12 scalefont setfont
	72 200 moveto show
	72 220 moveto show
	FMshowpage 
	FMquit 
	} def 
/FMVERSION {
	FMversion ne {
		(Frame product version does not match ps_prolog!  Check installation;)
		(also check ~/fminit and ./fminit for old versions) FMFAILURE
		} if
	} def 
/FMBADEPSF { 
	(Adobe's PostScript Language Reference Manual, 2nd Edition, section H.2.4)
	(says your EPS file is not valid, as it calls X              )
	dup dup (X) search pop exch pop exch pop length 
	5 -1 roll 
	putinterval 
	FMFAILURE
	} def
/fmConcatProcs
	{
	/proc2 exch cvlit def/proc1 exch cvlit def/newproc proc1 length proc2 length add array def
	newproc 0 proc1 putinterval newproc proc1 length proc2 putinterval newproc cvx
}def
FrameDict begin [
	/ALDsave
	/FMdicttop
	/FMoptop
	/FMpointsize
	/FMsaveobject
	/b
	/bitmapsave
	/blut
	/bpside
	/bs
	/bstring
	/bwidth
	/c
	/cf
	/cs
	/cynu
	/depth
	/edown
	/fh
	/fillvals
	/fw
	/fx
	/fy
	/g
	/gfile
	/gindex
	/grnt
	/gryt
	/gstring
	/height
	/hh
	/i
	/im
	/indx
	/is
	/k
	/kk
	/landscape
	/lb
	/len
	/llx
	/lly
	/m
	/magu
	/manualfeed
	/n
	/offbits
	/onbits
	/organgle
	/orgbangle
	/orgbfreq
	/orgbproc
	/orgbxfer
	/orgfreq
	/orggangle
	/orggfreq
	/orggproc
	/orggxfer
	/orgmatrix
	/orgproc
	/orgrangle
	/orgrfreq
	/orgrproc
	/orgrxfer
	/orgxfer
	/pagesave
	/paperheight
	/papersizedict
	/paperwidth
	/pos
	/pwid
	/r
	/rad
	/redt
	/sl
	/str
	/tran
	/u
	/urx
	/ury
	/val
	/width
	/width
	/ws
	/ww
	/x
	/x1
	/x2
	/xindex
	/xpoint
	/xscale
	/xx
	/y
	/y1
	/y2
	/yelu
	/yindex
	/ypoint
	/yscale
	/yy
] { 0 def } forall
/FmBD {bind def} bind def
systemdict /pdfmark known {
	/fMAcrobat true def
	
	/FmPD /pdfmark load def
	
	
	/FmPT /show load def
	
	
	currentdistillerparams /CoreDistVersion get 2000 ge {
	
		
		/FmPD2 /pdfmark load def
		
		
		
		
		
		/FmPA { mark exch /Dest exch 5 3 roll 
				/View [ /XYZ null 6 -2 roll FmDC exch pop null] /DEST FmPD 
		}FmBD
	} {
		
		/FmPD2 /cleartomark load def
		/FmPA {pop pop pop}FmBD
	} ifelse
} {
	
	/fMAcrobat false def
	/FmPD /cleartomark load def
	/FmPD2 /cleartomark load def
	/FmPT /pop load def
	/FmPA {pop pop pop}FmBD
} ifelse
/FmDC {
	transform fMDefaultMatrix itransform cvi exch cvi exch
}FmBD
/FmBx {
	dup 3 index lt {3 1 roll exch} if 
	1 index 4 index lt {4 -1 roll 3 1 roll exch 4 1 roll} if
}FmBD
/FMnone 0 def
/FMcyan 1 def
/FMmagenta 2 def
/FMyellow 3 def
/FMblack 4 def
/FMcustom 5 def
/fMNegative false def 
/FrameSepIs FMnone def 
/FrameSepBlack 0 def
/FrameSepYellow 0 def
/FrameSepMagenta 0 def
/FrameSepCyan 0 def
/FrameSepRed 1 def
/FrameSepGreen 1 def
/FrameSepBlue 1 def
/FrameCurGray 1 def
/FrameCurPat null def
/FrameCurColors [ 0 0 0 1 0 0 0 ] def 
/FrameColorEpsilon .001 def	
/eqepsilon {		
	sub dup 0 lt {neg} if
	FrameColorEpsilon le
} bind def
/FrameCmpColorsCMYK { 
	2 copy 0 get exch 0 get eqepsilon {
		2 copy 1 get exch 1 get eqepsilon {
			2 copy 2 get exch 2 get eqepsilon {
				3 get exch 3 get eqepsilon
			} {pop pop false} ifelse
		}{pop pop false} ifelse
	} {pop pop false} ifelse
} bind def
/FrameCmpColorsRGB { 
	2 copy 4 get exch 0 get eqepsilon {
		2 copy 5 get exch 1 get eqepsilon {
			6 get exch 2 get eqepsilon
		}{pop pop false} ifelse
	} {pop pop false} ifelse
} bind def
/RGBtoCMYK { 
	1 exch sub 
	3 1 roll 
	1 exch sub 
	3 1 roll 
	1 exch sub 
	3 1 roll 
	3 copy 
	2 copy 
	le { pop } { exch pop } ifelse 
	2 copy 
	le { pop } { exch pop } ifelse 
	dup dup dup 
	6 1 roll 
	4 1 roll 
	7 1 roll 
	sub 
	6 1 roll 
	sub 
	5 1 roll 
	sub 
	4 1 roll 
} bind def
/CMYKtoRGB { 
	dup dup 4 -1 roll add 						  
	5 1 roll 3 -1 roll add 						  
	4 1 roll add 								  
	1 exch sub dup 0 lt {pop 0} if 3 1 roll 	  
	1 exch sub dup 0 lt {pop 0} if exch 	      
	1 exch sub dup 0 lt {pop 0} if exch	  		  
} bind def
/FrameSepInit {
	1.0 RealSetgray
} bind def
/FrameSetSepColor { 
	/FrameSepBlue exch def
	/FrameSepGreen exch def
	/FrameSepRed exch def
	/FrameSepBlack exch def
	/FrameSepYellow exch def
	/FrameSepMagenta exch def
	/FrameSepCyan exch def
	/FrameSepIs FMcustom def
	setCurrentScreen	
} bind def
/FrameSetCyan {
	/FrameSepBlue 1.0 def
	/FrameSepGreen 1.0 def
	/FrameSepRed 0.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 1.0 def
	/FrameSepIs FMcyan def
	setCurrentScreen	
} bind def
 
/FrameSetMagenta {
	/FrameSepBlue 1.0 def
	/FrameSepGreen 0.0 def
	/FrameSepRed 1.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 1.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMmagenta def
	setCurrentScreen
} bind def
 
/FrameSetYellow {
	/FrameSepBlue 0.0 def
	/FrameSepGreen 1.0 def
	/FrameSepRed 1.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 1.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMyellow def
	setCurrentScreen
} bind def
 
/FrameSetBlack {
	/FrameSepBlue 0.0 def
	/FrameSepGreen 0.0 def
	/FrameSepRed 0.0 def
	/FrameSepBlack 1.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMblack def
	setCurrentScreen
} bind def
 
/FrameNoSep { 
	/FrameSepIs FMnone def
	setCurrentScreen
} bind def
/FrameSetSepColors { 
	FrameDict begin
	[ exch 1 add 1 roll ]
	/FrameSepColors  
	exch def end
	} bind def
/FrameColorInSepListCMYK { 
	FrameSepColors {  
       		exch dup 3 -1 roll 
       		FrameCmpColorsCMYK 
       		{ pop true exit } if
    	} forall 
	dup true ne {pop false} if
	} bind def
/FrameColorInSepListRGB { 
	FrameSepColors {  
       		exch dup 3 -1 roll 
       		FrameCmpColorsRGB 
       		{ pop true exit } if
    	} forall 
	dup true ne {pop false} if
	} bind def
/RealSetgray /setgray load def
/RealSetrgbcolor /setrgbcolor load def
/RealSethsbcolor /sethsbcolor load def
end 
/setgray { 
	FrameDict begin
	FrameSepIs FMnone eq
		{ RealSetgray } 
		{ 
		FrameSepIs FMblack eq 
			{ RealSetgray } 
			{ FrameSepIs FMcustom eq 
			  FrameSepRed 0 eq and
			  FrameSepGreen 0 eq and
			  FrameSepBlue 0 eq and {
			  	RealSetgray
			  } {
				1 RealSetgray pop 
			  } ifelse
			} ifelse
		} ifelse
	end
} bind def
/setrgbcolor { 
	FrameDict begin
	FrameSepIs FMnone eq
	{  RealSetrgbcolor }
	{
		3 copy [ 4 1 roll ] 
		FrameColorInSepListRGB
		{
				FrameSepBlue eq exch 
			 	FrameSepGreen eq and exch 
			 	FrameSepRed eq and
			 	{ 0 } { 1 } ifelse
		}
		{
			FMPColor {
				RealSetrgbcolor
				currentcmykcolor
			} {
				RGBtoCMYK
			} ifelse
			FrameSepIs FMblack eq
			{1.0 exch sub 4 1 roll pop pop pop} {
			FrameSepIs FMyellow eq
			{pop 1.0 exch sub 3 1 roll pop pop} {
			FrameSepIs FMmagenta eq
			{pop pop 1.0 exch sub exch pop } {
			FrameSepIs FMcyan eq
			{pop pop pop 1.0 exch sub } 
			{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
		} ifelse
		RealSetgray
	} 
	ifelse
	end
} bind def
/sethsbcolor {
	FrameDict begin
	FrameSepIs FMnone eq 
	{ RealSethsbcolor } 
	{
		RealSethsbcolor 
		currentrgbcolor  
		setrgbcolor 
	} 
	ifelse
	end
} bind def
FrameDict begin
/setcmykcolor where {
	pop /RealSetcmykcolor /setcmykcolor load def
} {
	/RealSetcmykcolor {
		4 1 roll
		3 { 3 index add 0 max 1 min 1 exch sub 3 1 roll} repeat 
		RealSetrgbcolor pop
	} bind def
} ifelse
userdict /setcmykcolor { 
		FrameDict begin
		FrameSepIs FMnone eq
		{ RealSetcmykcolor } 
		{
			4 copy [ 5 1 roll ]
			FrameColorInSepListCMYK
			{
				FrameSepBlack eq exch 
				FrameSepYellow eq and exch 
				FrameSepMagenta eq and exch 
				FrameSepCyan eq and 
				{ 0 } { 1 } ifelse
			}
			{
				FrameSepIs FMblack eq
				{1.0 exch sub 4 1 roll pop pop pop} {
				FrameSepIs FMyellow eq
				{pop 1.0 exch sub 3 1 roll pop pop} {
				FrameSepIs FMmagenta eq
				{pop pop 1.0 exch sub exch pop } {
				FrameSepIs FMcyan eq
				{pop pop pop 1.0 exch sub } 
				{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
			} ifelse
			RealSetgray
		}
		ifelse
		end
	} bind put
fMLevel1 { 
	
	
	
	/patScreenDict 7 dict dup begin
		<0f1e3c78f0e1c387> [ 45  { pop } {exch pop} 		.5   2 sqrt] FmBD
		<0f87c3e1f0783c1e> [ 135 { pop } {exch pop}			.5   2 sqrt] FmBD
		<cccccccccccccccc> [ 0   { pop } dup				.5   2	   ] FmBD
		<ffff0000ffff0000> [ 90  { pop } dup				.5   2	   ] FmBD
		<8142241818244281> [ 45  { 2 copy lt {exch} if pop}	dup .75  2 sqrt] FmBD
		<03060c183060c081> [ 45  { pop } {exch pop}			.875 2 sqrt] FmBD
		<8040201008040201> [ 135 { pop } {exch pop}			.875 2 sqrt] FmBD
	end def
} { 
	
	/patProcDict 5 dict dup begin
		<0f1e3c78f0e1c387> { 3 setlinewidth -1 -1 moveto 9 9 lineto stroke 
											4 -4 moveto 12 4 lineto stroke
											-4 4 moveto 4 12 lineto stroke} bind def
		<0f87c3e1f0783c1e> { 3 setlinewidth -1 9 moveto 9 -1 lineto stroke 
											-4 4 moveto 4 -4 lineto stroke
											4 12 moveto 12 4 lineto stroke} bind def
		<8142241818244281> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke
											-1 -1 moveto 9 9 lineto stroke } bind def
		<03060c183060c081> { 1 setlinewidth -1 -1 moveto 9 9 lineto stroke 
											4 -4 moveto 12 4 lineto stroke
											-4 4 moveto 4 12 lineto stroke} bind def
		<8040201008040201> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke 
											-4 4 moveto 4 -4 lineto stroke
											4 12 moveto 12 4 lineto stroke} bind def
	end def
	/patDict 15 dict dup begin
		/PatternType 1 def		
		/PaintType 2 def		
		/TilingType 3 def		
		/BBox [ 0 0 8 8 ] def 	
		/XStep 8 def			
		/YStep 8 def			
		/PaintProc {
			begin
			patProcDict bstring known {
				patProcDict bstring get exec
			} {
				8 8 true [1 0 0 -1 0 8] bstring imagemask
			} ifelse
			end
		} bind def
	end def
} ifelse
/combineColor {
    FrameSepIs FMnone eq
	{
		graymode fMLevel1 or not {
			
			[/Pattern [/DeviceCMYK]] setcolorspace
			FrameCurColors 0 4 getinterval aload pop FrameCurPat setcolor
		} {
			FrameCurColors 3 get 1.0 ge {
				FrameCurGray RealSetgray
			} {
				fMAcrobat not FMPColor graymode and and {
					0 1 3 { 
						FrameCurColors exch get
						1 FrameCurGray sub mul
					} for
					RealSetcmykcolor
				} {
					4 1 6 {
						FrameCurColors exch get
						graymode {
							1 exch sub 1 FrameCurGray sub mul 1 exch sub
						} {
							1.0 lt {FrameCurGray} {1} ifelse
						} ifelse
					} for
					RealSetrgbcolor
				} ifelse
			} ifelse
		} ifelse
	} { 
		FrameCurColors 0 4 getinterval aload
		FrameColorInSepListCMYK {
			FrameSepBlack eq exch 
			FrameSepYellow eq and exch 
			FrameSepMagenta eq and exch 
			FrameSepCyan eq and
			FrameSepIs FMcustom eq and
			{ FrameCurGray } { 1 } ifelse
		} {
			FrameSepIs FMblack eq
			{FrameCurGray 1.0 exch sub mul 1.0 exch sub 4 1 roll pop pop pop} {
			FrameSepIs FMyellow eq
			{pop FrameCurGray 1.0 exch sub mul 1.0 exch sub 3 1 roll pop pop} {
			FrameSepIs FMmagenta eq
			{pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub exch pop } {
			FrameSepIs FMcyan eq
			{pop pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub } 
			{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
		} ifelse
		graymode fMLevel1 or not {
			
			[/Pattern [/DeviceGray]] setcolorspace
			FrameCurPat setcolor
		} { 
			graymode not fMLevel1 and {
				
				dup 1 lt {pop FrameCurGray} if
			} if
			RealSetgray
		} ifelse
	} ifelse
} bind def
/savematrix {
	orgmatrix currentmatrix pop
	} bind def
/restorematrix {
	orgmatrix setmatrix
	} bind def
/fMDefaultMatrix matrix defaultmatrix def
/fMatrix2 matrix def
/dpi    72 0 fMDefaultMatrix dtransform
    dup mul exch   dup mul add   sqrt def
	
/freq dpi dup 72 div round dup 0 eq {pop 1} if 8 mul div def
/sangle 1 0 fMDefaultMatrix dtransform exch atan def
	sangle fMatrix2 rotate 
	fMDefaultMatrix fMatrix2 concatmatrix 
	dup 0 get /sflipx exch def
	    3 get /sflipy exch def
/screenIndex {
	0 1 dpiranges length 1 sub { dup dpiranges exch get 1 sub dpi le {exit} {pop} ifelse } for
} bind def
/getCyanScreen {
	FMUseHighFrequencyScreens { CHighAngles CMHighFreqs} {CLowAngles CMLowFreqs} ifelse
		screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getMagentaScreen {
	FMUseHighFrequencyScreens { MHighAngles CMHighFreqs } {MLowAngles CMLowFreqs} ifelse
		screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getYellowScreen {
	FMUseHighFrequencyScreens { YHighTDot YHighFreqs} { YLowTDot YLowFreqs } ifelse
		screenIndex dup 3 1 roll get 3 1 roll get { 3 div
			{2 { 1 add 2 div 3 mul dup floor sub 2 mul 1 sub exch} repeat
			FMSpotFunction } } {/FMSpotFunction load } ifelse
			0.0 exch
} bind def
/getBlackScreen  {
	FMUseHighFrequencyScreens { KHighFreqs } { KLowFreqs } ifelse
		screenIndex get 45.0 /FMSpotFunction load 
} bind def
/getSpotScreen {
	getBlackScreen
} bind def
/getCompositeScreen {
	getBlackScreen
} bind def
/FMSetScreen 
	fMLevel1 { /setscreen load 
	}{ {
		8 dict begin
		/HalftoneType 1 def
		/SpotFunction exch def
		/Angle exch def
		/Frequency exch def
		/AccurateScreens FMUseAcccurateScreens def
		currentdict end sethalftone
	} bind } ifelse
def
/setDefaultScreen {
	FMPColor {
		orgrxfer cvx orggxfer cvx orgbxfer cvx orgxfer cvx setcolortransfer
	}
	{
		orgxfer cvx settransfer
	} ifelse
	orgfreq organgle orgproc cvx setscreen
} bind def
/setCurrentScreen {
	FrameSepIs FMnone eq {
		FMUseDefaultNoSeparationScreen {
			setDefaultScreen
		} {
			getCompositeScreen FMSetScreen
		} ifelse
	} {
		FrameSepIs FMcustom eq {
			FMUseDefaultSpotSeparationScreen {
				setDefaultScreen
			} {
				getSpotScreen FMSetScreen
			} ifelse
		} {
			FMUseDefaultProcessSeparationScreen {
				setDefaultScreen
			} {
				FrameSepIs FMcyan eq {
					getCyanScreen FMSetScreen
				} {
					FrameSepIs FMmagenta eq {
						getMagentaScreen FMSetScreen
					} {
						FrameSepIs FMyellow eq {
							getYellowScreen FMSetScreen
						} {
							getBlackScreen FMSetScreen
						} ifelse
					} ifelse
				} ifelse
			} ifelse
		} ifelse
	} ifelse 
} bind def
end
	
/FMDOCUMENT { 
	array /FMfonts exch def 
	/#copies exch def
	FrameDict begin
	0 ne /manualfeed exch def
	/paperheight exch def
	/paperwidth exch def
	0 ne /fMNegative exch def 
	0 ne /edown exch def 
	/yscale exch def
	/xscale exch def
	fMLevel1 {
		manualfeed {setmanualfeed} if
		/FMdicttop countdictstack 1 add def 
		/FMoptop count def 
		setpapername 
		manualfeed {true} {papersize} ifelse 
		{manualpapersize} {false} ifelse 
		{desperatepapersize} {false} ifelse 
		{papersizefailure} if
		count -1 FMoptop {pop pop} for
		countdictstack -1 FMdicttop {pop end} for 
		}
		{2 dict
		 dup /PageSize [paperwidth paperheight] put
		 manualfeed {dup /ManualFeed manualfeed put} if
		 {setpagedevice} stopped {papersizefailure} if
		}
	ifelse 
	
	FMPColor {
		currentcolorscreen
			cvlit /orgproc exch def
				  /organgle exch def 
				  /orgfreq exch def
			cvlit /orgbproc exch def
				  /orgbangle exch def 
				  /orgbfreq exch def
			cvlit /orggproc exch def
				  /orggangle exch def 
				  /orggfreq exch def
			cvlit /orgrproc exch def
				  /orgrangle exch def 
				  /orgrfreq exch def
			currentcolortransfer 
			fMNegative {
				1 1 4 { 
					pop { 1 exch sub } fmConcatProcs 4 1 roll
				} for
				4 copy
				setcolortransfer
			} if
			cvlit /orgxfer exch def
			cvlit /orgbxfer exch def
			cvlit /orggxfer exch def
			cvlit /orgrxfer exch def
	} {
		currentscreen 
			cvlit /orgproc exch def
				  /organgle exch def 
				  /orgfreq exch def
				  
		currenttransfer 
		fMNegative {
			{ 1 exch sub } fmConcatProcs
			dup settransfer
		} if 
		cvlit /orgxfer exch def
	} ifelse
	end 
} def 
/FMBEGINPAGE { 
	FrameDict begin 
	/pagesave save def
	3.86 setmiterlimit
	/landscape exch 0 ne def
	landscape { 
		90 rotate 0 exch dup /pwid exch def neg translate pop 
	}{
		pop /pwid exch def
	} ifelse
	edown { [-1 0 0 1 pwid 0] concat } if
	0 0 moveto paperwidth 0 lineto paperwidth paperheight lineto 
	0 paperheight lineto 0 0 lineto 1 setgray fill
	xscale yscale scale
	/orgmatrix matrix def
	gsave 
} def 
/FMENDPAGE {
	grestore 
	pagesave restore
	end 
	showpage
	} def 
/FMFONTDEFINE { 
	FrameDict begin
	findfont 
	ReEncode 
	1 index exch 
	definefont 
	FMfonts 3 1 roll 
	put
	end 
	} def 
/FMFILLS {
	FrameDict begin dup
	array /fillvals exch def
	dict /patCache exch def
	end 
	} def 
/FMFILL {
	FrameDict begin
	 fillvals 3 1 roll put
	end 
	} def 
/FMNORMALIZEGRAPHICS { 
	newpath
	1 setlinewidth
	0 setlinecap
	0 0 0 sethsbcolor
	0 setgray 
	} bind def
/FMBEGINEPSF { 
	end 
	/FMEPSF save def 
	/showpage {} def 
% See Adobe's "PostScript Language Reference Manual, 2nd Edition", page 714.
% "...the following operators MUST NOT be used in an EPS file:" (emphasis ours)
	/banddevice {(banddevice) FMBADEPSF} def
	/clear {(clear) FMBADEPSF} def
	/cleardictstack {(cleardictstack) FMBADEPSF} def 
	/copypage {(copypage) FMBADEPSF} def
	/erasepage {(erasepage) FMBADEPSF} def
	/exitserver {(exitserver) FMBADEPSF} def
	/framedevice {(framedevice) FMBADEPSF} def
	/grestoreall {(grestoreall) FMBADEPSF} def
	/initclip {(initclip) FMBADEPSF} def
	/initgraphics {(initgraphics) FMBADEPSF} def
	/quit {(quit) FMBADEPSF} def
	/renderbands {(renderbands) FMBADEPSF} def
	/setglobal {(setglobal) FMBADEPSF} def
	/setpagedevice {(setpagedevice) FMBADEPSF} def
	/setshared {(setshared) FMBADEPSF} def
	/startjob {(startjob) FMBADEPSF} def
	/lettertray {(lettertray) FMBADEPSF} def
	/letter {(letter) FMBADEPSF} def
	/lettersmall {(lettersmall) FMBADEPSF} def
	/11x17tray {(11x17tray) FMBADEPSF} def
	/11x17 {(11x17) FMBADEPSF} def
	/ledgertray {(ledgertray) FMBADEPSF} def
	/ledger {(ledger) FMBADEPSF} def
	/legaltray {(legaltray) FMBADEPSF} def
	/legal {(legal) FMBADEPSF} def
	/statementtray {(statementtray) FMBADEPSF} def
	/statement {(statement) FMBADEPSF} def
	/executivetray {(executivetray) FMBADEPSF} def
	/executive {(executive) FMBADEPSF} def
	/a3tray {(a3tray) FMBADEPSF} def
	/a3 {(a3) FMBADEPSF} def
	/a4tray {(a4tray) FMBADEPSF} def
	/a4 {(a4) FMBADEPSF} def
	/a4small {(a4small) FMBADEPSF} def
	/b4tray {(b4tray) FMBADEPSF} def
	/b4 {(b4) FMBADEPSF} def
	/b5tray {(b5tray) FMBADEPSF} def
	/b5 {(b5) FMBADEPSF} def
	FMNORMALIZEGRAPHICS 
	[/fy /fx /fh /fw /ury /urx /lly /llx] {exch def} forall 
	fx fw 2 div add fy fh 2 div add  translate
	rotate
	fw 2 div neg fh 2 div neg translate
	fw urx llx sub div fh ury lly sub div scale 
	llx neg lly neg translate 
	/FMdicttop countdictstack 1 add def 
	/FMoptop count def 
	} bind def
/FMENDEPSF {
	count -1 FMoptop {pop pop} for 
	countdictstack -1 FMdicttop {pop end} for 
	FMEPSF restore
	FrameDict begin 
	} bind def
FrameDict begin 
/setmanualfeed {
%%BeginFeature *ManualFeed True
	 statusdict /manualfeed true put
%%EndFeature
	} bind def
/max {2 copy lt {exch} if pop} bind def
/min {2 copy gt {exch} if pop} bind def
/inch {72 mul} def
/pagedimen { 
	paperheight sub abs 16 lt exch 
	paperwidth sub abs 16 lt and
	{/papername exch def} {pop} ifelse
	} bind def
/setpapername { 
	/papersizedict 14 dict def 
	papersizedict begin
	/papername /unknown def 
		/Letter 8.5 inch 11.0 inch pagedimen
		/LetterSmall 7.68 inch 10.16 inch pagedimen
		/Tabloid 11.0 inch 17.0 inch pagedimen
		/Ledger 17.0 inch 11.0 inch pagedimen
		/Legal 8.5 inch 14.0 inch pagedimen
		/Statement 5.5 inch 8.5 inch pagedimen
		/Executive 7.5 inch 10.0 inch pagedimen
		/A3 11.69 inch 16.5 inch pagedimen
		/A4 8.26 inch 11.69 inch pagedimen
		/A4Small 7.47 inch 10.85 inch pagedimen
		/B4 10.125 inch 14.33 inch pagedimen
		/B5 7.16 inch 10.125 inch pagedimen
	end
	} bind def
/papersize {
	papersizedict begin
		/Letter {lettertray letter} def
		/LetterSmall {lettertray lettersmall} def
		/Tabloid {11x17tray 11x17} def
		/Ledger {ledgertray ledger} def
		/Legal {legaltray legal} def
		/Statement {statementtray statement} def
		/Executive {executivetray executive} def
		/A3 {a3tray a3} def
		/A4 {a4tray a4} def
		/A4Small {a4tray a4small} def
		/B4 {b4tray b4} def
		/B5 {b5tray b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	statusdict begin stopped end 
	} bind def
/manualpapersize {
	papersizedict begin
		/Letter {letter} def
		/LetterSmall {lettersmall} def
		/Tabloid {11x17} def
		/Ledger {ledger} def
		/Legal {legal} def
		/Statement {statement} def
		/Executive {executive} def
		/A3 {a3} def
		/A4 {a4} def
		/A4Small {a4small} def
		/B4 {b4} def
		/B5 {b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	stopped 
	} bind def
/desperatepapersize {
	statusdict /setpageparams known
		{
		paperwidth paperheight 0 1 
		statusdict begin
		{setpageparams} stopped 
		end
		} {true} ifelse 
	} bind def
/papersizefailure {
	FMAllowPaperSizeMismatch not
		{
(The requested paper size is not available in any currently-installed tray)
(Edit the PS file to "FMAllowPaperSizeMismatch true" to use default tray)
		 FMFAILURE } if
	} def
/DiacriticEncoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
/numbersign /dollar /percent /ampersand /quotesingle /parenleft
/parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K
/L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash
/bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h
/i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar
/braceright /asciitilde /.notdef /Adieresis /Aring /Ccedilla /Eacute
/Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis
/atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis
/iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve
/ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex
/udieresis /dagger /.notdef /cent /sterling /section /bullet
/paragraph /germandbls /registered /copyright /trademark /acute
/dieresis /.notdef /AE /Oslash /.notdef /.notdef /.notdef /.notdef
/yen /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown
/exclamdown /logicalnot /.notdef /florin /.notdef /.notdef
/guillemotleft /guillemotright /ellipsis /.notdef /Agrave /Atilde
/Otilde /OE /oe /endash /emdash /quotedblleft /quotedblright
/quoteleft /quoteright /.notdef /.notdef /ydieresis /Ydieresis
/fraction /currency /guilsinglleft /guilsinglright /fi /fl /daggerdbl
/periodcentered /quotesinglbase /quotedblbase /perthousand
/Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave /Iacute
/Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex /.notdef /Ograve
/Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde /macron
/breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
] def
/ReEncode { 
	dup 
	length 
	dict begin 
	{
	1 index /FID ne 
		{def} 
		{pop pop} ifelse 
	} forall 
	0 eq {/Encoding DiacriticEncoding def} if 
	currentdict 
	end 
	} bind def
FMPColor 
	
	{
	/BEGINBITMAPCOLOR { 
		BITMAPCOLOR} def
	/BEGINBITMAPCOLORc { 
		BITMAPCOLORc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUECOLOR } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUECOLORc } def
	/BEGINBITMAPCMYK { 
		BITMAPCMYK } def
	/BEGINBITMAPCMYKc { 
		BITMAPCMYKc } def
	}
	
	{
	/BEGINBITMAPCOLOR { 
		BITMAPGRAY} def
	/BEGINBITMAPCOLORc { 
		BITMAPGRAYc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUEGRAY } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUEGRAYc } def
	/BEGINBITMAPCMYK { 
		BITMAPCMYKGRAY } def
	/BEGINBITMAPCMYKc { 
		BITMAPCMYKGRAYc } def
	}
ifelse
/K { 
	FMPrintAllColorsAsBlack {
		dup 1 eq 2 index 1 eq and 3 index 1 eq and not
			{7 {pop} repeat 0 0 0 1 0 0 0} if
	} if 
	FrameCurColors astore 
	pop combineColor
} bind def
/graymode true def
fMLevel1 {
	/fmGetFlip {
		fMatrix2 exch get mul 0 lt { -1 } { 1 } ifelse
	} FmBD
} if
/setPatternMode {
	fMLevel1 {
		2 index patScreenDict exch known {
			pop pop
			patScreenDict exch get aload pop 
			freq 								
			mul									
			5 2 roll							
			fMatrix2 currentmatrix 1 get 0 ne {
				3 -1 roll 90 add 3 1 roll 		
				sflipx 1 fmGetFlip sflipy 2 fmGetFlip neg mul
			} {  								
				sflipx 0 fmGetFlip sflipy 3 fmGetFlip mul 
			} ifelse
			0 lt {exch pop} {pop} ifelse 		
			fMNegative { 
				{neg} fmConcatProcs 			
			} if
			bind
			
			
			
			systemdict /setscreen get exec		
			/FrameCurGray exch def
		} {
			/bwidth  exch def
			/bpside  exch def
			/bstring exch def
			/onbits 0 def  /offbits 0 def
			freq sangle landscape {90 add} if 
				{/ypoint exch def
				 /xpoint exch def
				 /xindex xpoint 1 add 2 div bpside mul cvi def
				 /yindex ypoint 1 add 2 div bpside mul cvi def
				 bstring yindex bwidth mul xindex 8 idiv add get
				 1 7 xindex 8 mod sub bitshift and 0 ne fMNegative {not} if
				 {/onbits  onbits  1 add def 1}
				 {/offbits offbits 1 add def 0}
				 ifelse
				}
				setscreen
			offbits offbits onbits add div fMNegative {1.0 exch sub} if
			/FrameCurGray exch def
		} ifelse
	} { 
		pop pop
		dup patCache exch known {
			patCache exch get
		} { 
			dup
			patDict /bstring 3 -1 roll put
			patDict 
			9 PatFreq screenIndex get div dup matrix scale
			makepattern
			dup 
			patCache 4 -1 roll 3 -1 roll put
		} ifelse
		/FrameCurGray 0 def
		/FrameCurPat exch def
	} ifelse
	/graymode false def
	combineColor
} bind def
/setGrayScaleMode {
	graymode not {
		/graymode true def
		fMLevel1 {
			setCurrentScreen
		} if
	} if
	/FrameCurGray exch def
	combineColor
} bind def
/normalize {
	transform round exch round exch itransform
	} bind def
/dnormalize {
	dtransform round exch round exch idtransform
	} bind def
/lnormalize { 
	0 dtransform exch cvi 2 idiv 2 mul 1 add exch idtransform pop
	} bind def
/H { 
	lnormalize setlinewidth
	} bind def
/Z {
	setlinecap
	} bind def
	
/PFill {
	graymode fMLevel1 or not {
		gsave 1 setgray eofill grestore
	} if
} bind def
/PStroke {
	graymode fMLevel1 or not {
		gsave 1 setgray stroke grestore
	} if
	stroke
} bind def
/X { 
	fillvals exch get
	dup type /stringtype eq
	{8 1 setPatternMode} 
	{setGrayScaleMode}
	ifelse
	} bind def
/V { 
	PFill gsave eofill grestore
	} bind def
/Vclip {
	clip
	} bind def
/Vstrk {
	currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/N { 
	PStroke
	} bind def
/Nclip {
	strokepath clip newpath
	} bind def
/Nstrk {
	currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/M {newpath moveto} bind def
/E {lineto} bind def
/D {curveto} bind def
/O {closepath} bind def
/L { 
 	/n exch def
	newpath
	normalize
	moveto 
	2 1 n {pop normalize lineto} for
	} bind def
/Y { 
	L 
	closepath
	} bind def
/R { 
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	x1 y1
	x2 y1
	x2 y2
	x1 y2
	4 Y 
	} bind def
/rarc 
	{rad 
	 arcto
	} bind def
/RR { 
	/rad exch def
	normalize
	/y2 exch def
	/x2 exch def
	normalize
	/y1 exch def
	/x1 exch def
	mark
	newpath
	{
	x1 y1 rad add moveto
	x1 y2 x2 y2 rarc
	x2 y2 x2 y1 rarc
	x2 y1 x1 y1 rarc
	x1 y1 x1 y2 rarc
	closepath
	} stopped {x1 y1 x2 y2 R} if 
	cleartomark
	} bind def
/RRR { 
	/rad exch def
	normalize /y4 exch def /x4 exch def
	normalize /y3 exch def /x3 exch def
	normalize /y2 exch def /x2 exch def
	normalize /y1 exch def /x1 exch def
	newpath
	normalize moveto 
	mark
	{
	x2 y2 x3 y3 rarc
	x3 y3 x4 y4 rarc
	x4 y4 x1 y1 rarc
	x1 y1 x2 y2 rarc
	closepath
	} stopped
	 {x1 y1 x2 y2 x3 y3 x4 y4 newpath moveto lineto lineto lineto closepath} if
	cleartomark
	} bind def
/C { 
	grestore
	gsave
	R 
	clip
	setCurrentScreen
} bind def
/CP { 
	grestore
	gsave
	Y 
	clip
	setCurrentScreen
} bind def
/F { 
	FMfonts exch get
	FMpointsize scalefont
	setfont
	} bind def
/Q { 
	/FMpointsize exch def
	F 
	} bind def
/T { 
	moveto show
	} bind def
/RF { 
	rotate
	0 ne {-1 1 scale} if
	} bind def
/TF { 
	gsave
	moveto 
	RF
	show
	grestore
	} bind def
/P { 
	moveto
	0 32 3 2 roll widthshow
	} bind def
/PF { 
	gsave
	moveto 
	RF
	0 32 3 2 roll widthshow
	grestore
	} bind def
/S { 
	moveto
	0 exch ashow
	} bind def
/SF { 
	gsave
	moveto
	RF
	0 exch ashow
	grestore
	} bind def
/B { 
	moveto
	0 32 4 2 roll 0 exch awidthshow
	} bind def
/BF { 
	gsave
	moveto
	RF
	0 32 4 2 roll 0 exch awidthshow
	grestore
	} bind def
/G { 
	gsave
	newpath
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	PFill fill
	grestore
	} bind def
/Gstrk {
	savematrix
    newpath
    2 index 2 div add exch 3 index 2 div sub exch 
    normalize 2 index 2 div sub exch 3 index 2 div add exch 
    translate
    scale 
    0.0 0.0 1.0 5 3 roll arc 
    restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
    } bind def
/Gclip { 
	newpath
	savematrix
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	clip newpath
	restorematrix
	} bind def
/GG { 
	gsave
	newpath
	normalize translate 0.0 0.0 moveto 
	rotate 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath
	PFill
	fill
	grestore
	} bind def
/GGclip { 
	savematrix
	newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
	clip newpath
	restorematrix
	} bind def
/GGstrk { 
	savematrix
    newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath 
	restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/A { 
	gsave
	savematrix
	newpath
	2 index 2 div add exch 3 index 2 div sub exch 
	normalize 2 index 2 div sub exch 3 index 2 div add exch 
	translate 
	scale 
	0.0 0.0 1.0 5 3 roll arc 
	restorematrix
	PStroke
	grestore
	} bind def
/Aclip {
	newpath
	savematrix
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	strokepath clip newpath
	restorematrix
} bind def
/Astrk {
	Gstrk
} bind def
/AA { 
	gsave
	savematrix
	newpath
	
	3 index 2 div add exch 4 index 2 div sub exch 
	
	normalize 3 index 2 div sub exch 4 index 2 div add exch
	translate 
	rotate 
	scale 
	0.0 0.0 1.0 5 3 roll arc 
	restorematrix
	PStroke
	grestore
	} bind def
/AAclip {
	savematrix
	newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
	strokepath clip newpath
	restorematrix
} bind def
/AAstrk {
	GGstrk
} bind def
/BEGINPRINTCODE { 
	/FMdicttop countdictstack 1 add def 
	/FMoptop count 7 sub def 
	/FMsaveobject save def
	userdict begin 
	/showpage {} def 
	FMNORMALIZEGRAPHICS 
	3 index neg 3 index neg translate
	} bind def
/ENDPRINTCODE {
	count -1 FMoptop {pop pop} for 
	countdictstack -1 FMdicttop {pop end} for 
	FMsaveobject restore 
	} bind def
/gn { 
	0 
	{	46 mul 
		cf read pop 
		32 sub 
		dup 46 lt {exit} if 
		46 sub add 
		} loop
	add 
	} bind def
/cfs { 
	/str sl string def 
	0 1 sl 1 sub {str exch val put} for 
	str def 
	} bind def
/ic [ 
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0
	{0 hx} {1 hx} {2 hx} {3 hx} {4 hx} {5 hx} {6 hx} {7 hx} {8 hx} {9 hx}
	{10 hx} {11 hx} {12 hx} {13 hx} {14 hx} {15 hx} {16 hx} {17 hx} {18 hx}
	{19 hx} {gn hx} {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}
	{13} {14} {15} {16} {17} {18} {19} {gn} {0 wh} {1 wh} {2 wh} {3 wh}
	{4 wh} {5 wh} {6 wh} {7 wh} {8 wh} {9 wh} {10 wh} {11 wh} {12 wh}
	{13 wh} {14 wh} {gn wh} {0 bl} {1 bl} {2 bl} {3 bl} {4 bl} {5 bl} {6 bl}
	{7 bl} {8 bl} {9 bl} {10 bl} {11 bl} {12 bl} {13 bl} {14 bl} {gn bl}
	{0 fl} {1 fl} {2 fl} {3 fl} {4 fl} {5 fl} {6 fl} {7 fl} {8 fl} {9 fl}
	{10 fl} {11 fl} {12 fl} {13 fl} {14 fl} {gn fl}
	] def
/ms { 
	/sl exch def 
	/val 255 def 
	/ws cfs 
	/im cfs 
	/val 0 def 
	/bs cfs 
	/cs cfs 
	} bind def
400 ms 
/ip { 
	is 
	0 
	cf cs readline pop 
	{	ic exch get exec 
		add 
		} forall 
	pop 
	
	} bind def
/rip { 
	   
	  
	  bis ris copy pop 
      is
      0
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
	  pop pop 
	  ris gis copy pop 
	  dup is exch 
	  
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
	  pop pop
	  gis bis copy pop 
	  dup add is exch 
	  
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop 
      
      } bind def
/rip4 { 
	   
	  
	  kis cis copy pop 
      is
      0
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
	  pop pop 
	  cis mis copy pop 
	  dup is exch 
	  
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
	  pop pop
	  mis yis copy pop 
	  dup dup add is exch 
	  
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
	  pop pop
	  yis kis copy pop 
	  3 mul is exch 
	  
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop 
      
      } bind def
/wh { 
	/len exch def 
	/pos exch def 
	ws 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/bl { 
	/len exch def 
	/pos exch def 
	bs 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/s1 1 string def
/fl { 
	/len exch def 
	/pos exch def 
	/val cf s1 readhexstring pop 0 get def
	pos 1 pos len add 1 sub {im exch val put} for
	pos len 
	} bind def
/hx { 
	3 copy getinterval 
	cf exch readhexstring pop pop 
	} bind def
/wbytes { 
      dup dup
      8 gt { pop 8 idiv mul }
      { 8 eq {pop} {1 eq {7 add 8 idiv} {3 add 4 idiv} ifelse} ifelse } ifelse
	} bind def
/BEGINBITMAPBWc { 
	1 {} COMMONBITMAPc
	} bind def
/BEGINBITMAPGRAYc { 
	8 {} COMMONBITMAPc
	} bind def
/BEGINBITMAP2BITc { 
	2 {} COMMONBITMAPc
	} bind def
/COMMONBITMAPc { 
		 
	/cvtProc exch def
	/depth exch def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/height exch def /width exch def
	/lb width depth wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	cvtProc                
	/is im 0 lb getinterval def 
	ws 0 lb getinterval is copy pop 
	/cf currentfile def 
	width height depth [width 0 0 height neg 0 height] 
	{ip} image 
	bitmapsave restore 
	grestore
	} bind def
/BEGINBITMAPBW { 
	1 {} COMMONBITMAP
	} bind def
/BEGINBITMAPGRAY { 
	8 {} COMMONBITMAP
	} bind def
/BEGINBITMAP2BIT { 
	2 {} COMMONBITMAP
	} bind def
/COMMONBITMAP { 
	/cvtProc exch def
	/depth exch def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/height exch def /width exch def
	/bitmapsave save def 
	cvtProc              
	/is width depth wbytes string def
	/cf currentfile def 
	width height depth [width 0 0 height neg 0 height] 
	{cf is readhexstring pop} image
	bitmapsave restore 
	grestore
	} bind def
/ngrayt 256 array def
/nredt 256 array def
/nbluet 256 array def
/ngreent 256 array def
fMLevel1 {
/colorsetup {
	currentcolortransfer
	/gryt exch def
	/blut exch def
	/grnt exch def
	/redt exch def
	0 1 255 {
		/indx exch def
		/cynu 1 red indx get 255 div sub def
		/magu 1 green indx get 255 div sub def
		/yelu 1 blue indx get 255 div sub def
		/kk cynu magu min yelu min def
		/u kk currentundercolorremoval exec def
%		/u 0 def
		nredt indx 1 0 cynu u sub max sub redt exec put
		ngreent indx 1 0 magu u sub max sub grnt exec put
		nbluet indx 1 0 yelu u sub max sub blut exec put
		ngrayt indx 1 kk currentblackgeneration exec sub gryt exec put
	} for
	{255 mul cvi nredt exch get}
	{255 mul cvi ngreent exch get}
	{255 mul cvi nbluet exch get}
	{255 mul cvi ngrayt exch get}
	setcolortransfer
	{pop 0} setundercolorremoval
	{} setblackgeneration
	} bind def
}
{
/colorSetup2 {
	[ /Indexed /DeviceRGB 255 
		{dup red exch get 255 div 
		 exch dup green exch get 255 div 
		 exch blue exch get 255 div}
	] setcolorspace
} bind def
} ifelse
/fakecolorsetup {
	/tran 256 string def
	0 1 255 {/indx exch def 
		tran indx
		red indx get 77 mul
		green indx get 151 mul
		blue indx get 28 mul
		add add 256 idiv put} for
	currenttransfer
	{255 mul cvi tran exch get 255.0 div}
	exch fmConcatProcs settransfer
} bind def
/BITMAPCOLOR { 
	/depth 8 def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/height exch def /width exch def
	/bitmapsave save def
	fMLevel1 {	
		colorsetup
		/is width depth wbytes string def
		/cf currentfile def 
		width height depth [width 0 0 height neg 0 height] 
		{cf is readhexstring pop} {is} {is} true 3 colorimage 
	} {
		colorSetup2
		/is width depth wbytes string def
		/cf currentfile def 
		7 dict dup begin
			/ImageType 1 def
			/Width width def
			/Height height def
			/ImageMatrix [width 0 0 height neg 0 height] def
			/DataSource {cf is readhexstring pop} bind def
			/BitsPerComponent depth def
			/Decode [0 255] def
		end image	
	} ifelse
	bitmapsave restore 
	grestore
	} bind def
/BITMAPCOLORc { 
	/depth 8 def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/height exch def /width exch def
	/lb width depth wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	fMLevel1 {	
		colorsetup
		/is im 0 lb getinterval def 
		ws 0 lb getinterval is copy pop 
		/cf currentfile def 
		width height depth [width 0 0 height neg 0 height] 
		{ip} {is} {is} true 3 colorimage
	} {
		colorSetup2
		/is im 0 lb getinterval def 
		ws 0 lb getinterval is copy pop 
		/cf currentfile def 
		7 dict dup begin
			/ImageType 1 def
			/Width width def
			/Height height def
			/ImageMatrix [width 0 0 height neg 0 height] def
			/DataSource {ip} bind def
			/BitsPerComponent depth def
			/Decode [0 255] def
		end image	
	} ifelse
	bitmapsave restore 
	grestore
	} bind def
/BITMAPTRUECOLORc { 
	/depth 24 def
        gsave
 	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/height exch def /width exch def
	/lb width depth wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
        
	/is im 0 lb getinterval def	
	/ris im 0 width getinterval def	
	/gis im width width getinterval def	
	/bis im width 2 mul width getinterval def 
        
	ws 0 lb getinterval is copy pop 
	/cf currentfile def 
	width height 8 [width 0 0 height neg 0 height] 
	{width rip pop ris} {gis} {bis} true 3 colorimage
	bitmapsave restore 
	grestore
	} bind def
/BITMAPCMYKc { 
	/depth 32 def
        gsave
 	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/height exch def /width exch def
	/lb width depth wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
        
	/is im 0 lb getinterval def	
	/cis im 0 width getinterval def	
	/mis im width width getinterval def	
	/yis im width 2 mul width getinterval def 
	/kis im width 3 mul width getinterval def 
        
	ws 0 lb getinterval is copy pop 
	/cf currentfile def 
	width height 8 [width 0 0 height neg 0 height] 
	{width rip4 pop cis} {mis} {yis} {kis} true 4 colorimage
	bitmapsave restore 
	grestore
	} bind def
/BITMAPTRUECOLOR { 
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/height exch def /width exch def
        /bitmapsave save def 
        /is width string def
        /gis width string def
        /bis width string def
        /cf currentfile def 
        width height 8 [width 0 0 height neg 0 height] 
        { cf is readhexstring pop } 
        { cf gis readhexstring pop } 
        { cf bis readhexstring pop } 
        true 3 colorimage 
        bitmapsave restore 
        grestore
        } bind def
/BITMAPCMYK { 
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/height exch def /width exch def
        /bitmapsave save def 
        /is width string def
        /mis width string def
        /yis width string def
        /kis width string def
        /cf currentfile def 
        width height 8 [width 0 0 height neg 0 height] 
        { cf is readhexstring pop } 
        { cf mis readhexstring pop } 
        { cf yis readhexstring pop } 
        { cf kis readhexstring pop } 
        true 4 colorimage 
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUEGRAYc { 
	/depth 24 def
        gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/height exch def /width exch def
	/lb width depth wbytes def 
	sl lb lt {lb ms} if 
        /bitmapsave save def 
        
	/is im 0 lb getinterval def	
	/ris im 0 width getinterval def	
	/gis im width width getinterval def	
	/bis im width 2 mul width getinterval def 
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        width height 8 [width 0 0 height neg 0 height] 
        {width rip pop ris gis bis width gray} image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPCMYKGRAYc { 
	/depth 32 def
        gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/height exch def /width exch def
	/lb width depth wbytes def 
	sl lb lt {lb ms} if 
        /bitmapsave save def 
        
	/is im 0 lb getinterval def	
	/cis im 0 width getinterval def	
	/mis im width width getinterval def	
	/yis im width 2 mul width getinterval def 
	/kis im width 3 mul width getinterval def 
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        width height 8 [width 0 0 height neg 0 height] 
        {width rip pop cis mis yis kis width cgray} image
        bitmapsave restore 
        grestore
        } bind def
/cgray { 
        /ww exch def
        /k exch def
        /y exch def
        /m exch def
        /c exch def
        0 1 ww 1 sub { /i exch def c i get m i get y i get k i get CMYKtoRGB
				.144 mul 3 1 roll .587 mul 3 1 roll .299 mul add add
				c i 3 -1 roll floor cvi put } for
        c
 		} bind def
/gray { 
        /ww exch def
        /b exch def
        /g exch def
        /r exch def
        0 1 ww 1 sub { /i exch def r i get .299 mul g i get .587 mul
			b i get .114 mul add add r i 3 -1 roll floor cvi put } for
        r
        } bind def
/BITMAPTRUEGRAY { 
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/height exch def /width exch def
        /bitmapsave save def 
        /is width string def
        /gis width string def
        /bis width string def
        /cf currentfile def 
        width height 8 [width 0 0 height neg 0 height] 
        { cf is readhexstring pop 
          cf gis readhexstring pop 
          cf bis readhexstring pop width gray}  image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPCMYKGRAY { 
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/height exch def /width exch def
        /bitmapsave save def 
        /is width string def
        /yis width string def
        /mis width string def
        /kis width string def
        /cf currentfile def 
        width height 8 [width 0 0 height neg 0 height] 
        { cf is readhexstring pop 
          cf mis readhexstring pop 
          cf yis readhexstring pop 
          cf kis readhexstring pop width cgray}  image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPGRAY { 
	8 {fakecolorsetup} COMMONBITMAP
	} bind def
/BITMAPGRAYc { 
	8 {fakecolorsetup} COMMONBITMAPc
	} bind def
/ENDBITMAP {
	} bind def
end 
	/ALDmatrix matrix def ALDmatrix currentmatrix pop
/StartALD {
	/ALDsave save def
	 savematrix
	 ALDmatrix setmatrix
	} bind def
/InALD {
	 restorematrix
	} bind def
/DoneALD {
	 ALDsave restore
	} bind def
/I { setdash } bind def
/J { [] 0 setdash } bind def
%%EndProlog
%%BeginSetup
(5.0) FMVERSION
1 1 0 0 612 792 0 1 17 FMDOCUMENT
0 0 /Times-Roman FMFONTDEFINE
1 0 /Times-Bold FMFONTDEFINE
2 0 /Times-Italic FMFONTDEFINE
3 0 /Courier FMFONTDEFINE
4 0 /Courier-Oblique FMFONTDEFINE
5 0 /Courier-Bold FMFONTDEFINE
32 FMFILLS
0 0 FMFILL
1 0.1 FMFILL
2 0.3 FMFILL
3 0.5 FMFILL
4 0.7 FMFILL
5 0.9 FMFILL
6 0.97 FMFILL
7 1 FMFILL
8 <0f1e3c78f0e1c387> FMFILL
9 <0f87c3e1f0783c1e> FMFILL
10 <cccccccccccccccc> FMFILL
11 <ffff0000ffff0000> FMFILL
12 <8142241818244281> FMFILL
13 <03060c183060c081> FMFILL
14 <8040201008040201> FMFILL
16 1 FMFILL
17 0.9 FMFILL
18 0.7 FMFILL
19 0.5 FMFILL
20 0.3 FMFILL
21 0.1 FMFILL
22 0.03 FMFILL
23 0 FMFILL
24 <f0e1c3870f1e3c78> FMFILL
25 <f0783c1e0f87c3e1> FMFILL
26 <3333333333333333> FMFILL
27 <0000ffff0000ffff> FMFILL
28 <7ebddbe7e7dbbd7e> FMFILL
29 <fcf9f3e7cf9f3f7e> FMFILL
30 <7fbfdfeff7fbfdfe> FMFILL
%%EndSetup
%%Page: "1" 1
%%BeginPaperSize: Letter
%%EndPaperSize
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
J
0 0 0 1 0 0 0 K
0 8 Q
0 X
0 0 0 1 0 0 0 K
(1) 304 34.17 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 16 Q
(Finding Refer) 183.26 705.07 T
(ences in J) 278.52 705.07 T
(a) 344.06 705.07 T
(v) 351.66 705.07 T
(a) 359.5 705.07 T
1 12.8 Q
(\252) 367.5 711.47 T
1 16 Q
( Stacks) 380.3 705.07 T
0 9 Q
(Ole Agesen, Da) 257.6 666.73 T
(vid Detlefs) 314.65 666.73 T
(Sun Microsystems Laboratories) 248.76 646.73 T
(2 Elizabeth Dri) 274.44 635.73 T
(v) 329.2 635.73 T
(e) 333.57 635.73 T
(Chelmsford, MA 01824, U.S.A.) 248.25 624.73 T
(ole.agesen@sun.com, da) 215.19 613.73 T
(vid.detlefs@east.sun.com) 304.28 613.73 T
(August, 1997) 281.75 593.73 T
1 F
0.3 (Abstract) 108 573.73 P
0 F
0.3 (. Exact g) 141.49 573.73 P
0.3 (arbage collection for the strongly-typed Ja) 173.79 573.73 P
0.3 (v) 327.35 573.73 P
0.3 (a language may seem straightforw) 331.62 573.73 P
0.3 (ard. Unfortu-) 456.21 573.73 P
0.13 (nately) 108 562.73 P
0.13 (, a single pair of bytecodes in the Ja) 129.41 562.73 P
0.13 (v) 259 562.73 P
0.13 (a V) 263.27 562.73 P
0.13 (irtual Machine instruction set presents an obstacle that has thus) 275.61 562.73 P
0.59 (f) 108 551.73 P
0.59 (ar not been discussed in the literature. W) 110.91 551.73 P
0.59 (e e) 261.27 551.73 P
0.59 (xplain the problem, outline the space of possible solutions, and) 271.97 551.73 P
-0.02 (present a solution utilizing bytecode-preprocessing to enable e) 108 540.73 P
-0.02 (xact g) 332.43 540.73 P
-0.02 (arbage collection while maintaining com-) 354.11 540.73 P
(patibility with e) 108 529.73 T
(xisting compiled Ja) 164.87 529.73 T
(v) 234.69 529.73 T
(a class \336les.) 238.97 529.73 T
1 14 Q
(1  Intr) 72 499.4 T
(oduction) 109.86 499.4 T
0 10 Q
0.31 (All g) 72 479.07 P
0.31 (arbage collection algorithms determine reachability of objects from some set of) 92.54 479.07 P
2 F
0.31 (r) 416.16 479.07 P
0.31 (oots.) 419.6 479.07 P
0 F
0.31 (In most language imple-) 441.58 479.07 P
-0.23 (mentations,) 72 467.07 P
2 F
-0.23 (stac) 120.66 467.07 P
-0.23 (ks) 136.57 467.07 P
0 F
-0.23 (form one component of the root set. A stack is a re) 147.17 467.07 P
-0.23 (gion in which) 347.22 467.07 P
2 F
-0.23 (stac) 404.03 467.07 P
-0.23 (k fr) 419.94 467.07 P
-0.23 (ames) 433.17 467.07 P
0 F
-0.23 (may be allocated and) 455.99 467.07 P
0.39 (deallocated. Each method e) 72 455.07 P
0.39 (x) 183 455.07 P
0.39 (ecuting in a thread of control allocates a stack frame, and uses the) 187.85 455.07 P
2 F
0.39 (slots) 458.43 455.07 P
0 F
0.39 (of that stack to) 479.66 455.07 P
0.87 (hold the v) 72 443.07 P
0.87 (alues of local v) 113.48 443.07 P
0.87 (ariables. Some of those v) 176.65 443.07 P
0.87 (ariables may contain references to heap-allocated objects. Such) 280.68 443.07 P
0.71 (objects must be considered reachable as long as the method is e) 72 431.07 P
0.71 (x) 333.84 431.07 P
0.71 (ecuting. The term) 338.69 431.07 P
2 F
0.71 (stac) 414.15 431.07 P
0.71 (k) 430.06 431.07 P
0 F
0.71 ( is used because the stack) 434.5 431.07 P
0.03 (frames) 72 419.07 P
0.03 (obe) 101.74 419.07 P
0.03 (y a last-in/\336rst-out allocation discipline within a gi) 116.03 419.07 P
0.03 (v) 318.51 419.07 P
0.03 (en thread of control \050at least in languages without clo-) 323.36 419.07 P
(sures\051. There is generally a stack associated with each thread of control.) 72 407.07 T
0.63 (A g) 72 389.07 P
0.63 (arbage collector may be e) 87.3 389.07 P
0.63 (xact or conserv) 192.41 389.07 P
0.63 (ati) 254.52 389.07 P
0.63 (v) 264.27 389.07 P
0.63 (e in ho) 269.12 389.07 P
0.63 (w it treats dif) 297.35 389.07 P
0.63 (ferent sources of references, such as stacks. A) 352.04 389.07 P
2 F
0.07 (conservative) 72 377.07 P
0 F
0.07 ( collector kno) 122.54 377.07 P
0.07 (ws only that some re) 177.41 377.07 P
0.07 (gion of memory may contain references, b) 260.3 377.07 P
0.07 (ut doesn\325) 430.18 377.07 P
0.07 (t kno) 467.01 377.07 P
0.07 (w whether or) 487.11 377.07 P
-0.15 (not a gi) 72 365.07 P
-0.15 (v) 101.45 365.07 P
-0.15 (en v) 106.3 365.07 P
-0.15 (alue in that re) 122.83 365.07 P
-0.15 (gion is a reference. If such a collector encounters a v) 176.94 365.07 P
-0.15 (alue that is a plausible reference v) 385.93 365.07 P
-0.15 (alue,) 520.84 365.07 P
0.68 (it must k) 72 353.07 P
0.68 (eep the \322referenced\323 object ali) 108.28 353.07 P
0.68 (v) 232.38 353.07 P
0.68 (e. Because of this uncertainty) 237.23 353.07 P
0.68 (, the collector is constrained not to mo) 357.34 353.07 P
0.68 (v) 515.3 353.07 P
0.68 (e the) 520.16 353.07 P
0.12 (object, since that w) 72 341.07 P
0.12 (ould require updating the \322reference,) 149.47 341.07 P
0.12 (\323 which might actually be an unfortunately-v) 296.7 341.07 P
0.12 (alued inte) 477.15 341.07 P
0.12 (ger or) 516.28 341.07 P
0.49 (\337oating-point number) 72 329.07 P
0.49 (. The main adv) 159.44 329.07 P
0.49 (antage of conserv) 220.66 329.07 P
0.49 (ati) 291.92 329.07 P
0.49 (v) 301.67 329.07 P
0.49 (e collection is that it allo) 306.52 329.07 P
0.49 (ws g) 407.34 329.07 P
0.49 (arbage collection to be used) 426.39 329.07 P
-0.09 (with systems not originally designed to support collection. F) 72 317.07 P
-0.09 (or e) 313.1 317.07 P
-0.09 (xample, the Boehm-W) 328.13 317.07 P
-0.09 (eiser collector [2] and the Bar-) 417.98 317.07 P
(tlett collector [1] use conserv) 72 305.07 T
(ati) 188.39 305.07 T
(v) 198.14 305.07 T
(e techniques to support collection for C and C++.) 202.99 305.07 T
0.71 (In contrast, a collector is) 72 287.07 P
2 F
0.71 (e) 176.63 287.07 P
0.71 (xact) 180.87 287.07 P
0 F
0.71 ( in its treatment of a memory re) 197.53 287.07 P
0.71 (gion if it can accurately distinguish references from) 328.7 287.07 P
1.08 (non-reference v) 72 275.07 P
1.08 (alues in that re) 135.85 275.07 P
1.08 (gion. Exactness has se) 197.52 275.07 P
1.08 (v) 289.93 275.07 P
1.08 (eral adv) 294.78 275.07 P
1.08 (antages o) 327.54 275.07 P
1.08 (v) 365.95 275.07 P
1.08 (er conserv) 370.8 275.07 P
1.08 (atism. A conserv) 413 275.07 P
1.08 (ati) 482.39 275.07 P
1.08 (v) 492.14 275.07 P
1.08 (e collector) 496.99 275.07 P
-0.2 (may retain g) 72 263.07 P
-0.2 (arbage \322referenced\323 by a non-reference v) 121.54 263.07 P
-0.2 (alue that an e) 285.46 263.07 P
-0.2 (xact collector w) 337.74 263.07 P
-0.2 (ould reclaim. Perhaps more impor-) 401.11 263.07 P
0.49 (tantly) 72 251.07 P
0.49 (, an e) 94.13 251.07 P
0.49 (xact collector is free to relocate objects referenced only by e) 116.33 251.07 P
0.49 (xactly identi\336ed references. In an) 362.07 251.07 P
2 F
0.49 (e) 500.56 251.07 P
0.49 (xact sys-) 504.8 251.07 P
-0.1 (tem,) 72 239.07 P
0 F
-0.1 (one in which references and non-references can be distinguished e) 91.34 239.07 P
-0.1 (v) 355.36 239.07 P
-0.1 (erywhere, this enables a wide range of useful) 360.21 239.07 P
(and ef) 72 227.07 T
(\336cient g) 96.46 227.07 T
(arbage-collection techniques that cannot \050easily\051 be used in a conserv) 128.91 227.07 T
(ati) 406.09 227.07 T
(v) 415.84 227.07 T
(e setting.) 420.69 227.07 T
0.62 (A dra) 72 209.07 P
0.62 (wback of e) 94.96 209.07 P
0.62 (xact systems is that the) 139.91 209.07 P
0.62 (y must someho) 234.45 209.07 P
0.62 (w pro) 295.99 209.07 P
0.62 (vide the information that mak) 319.51 209.07 P
0.62 (es them e) 440.75 209.07 P
0.62 (xact. This may) 479.61 209.07 P
1 (introduce both performance and comple) 72 197.07 P
1 (xity o) 235.8 197.07 P
1 (v) 259.71 197.07 P
1 (erhead. One technique for pro) 264.56 197.07 P
1 (viding this information is) 388.07 197.07 P
2 F
1 (ta) 495.96 197.07 P
1 (g) 503.64 197.07 P
1 (ging) 508.54 197.07 P
1 (,) 526.22 197.07 P
0 F
1 (in) 532.22 197.07 P
0.48 (which v) 72 185.07 P
0.48 (alues are self-describing: one or more bits in each v) 104.17 185.07 P
0.48 (alue is reserv) 314.57 185.07 P
0.48 (ed to indicate whether the v) 368.14 185.07 P
0.48 (alue is a refer-) 481.09 185.07 P
0.19 (ence. T) 72 173.07 P
0.19 (ags may be supported by hardw) 100.82 173.07 P
0.19 (are, b) 228.59 173.07 P
0.19 (ut more commonly require the generation of e) 250.79 173.07 P
0.19 (xtra instructions to check,) 436.11 173.07 P
-0.18 (mask, and restore tags. If tagging is not used, then the system must associate data structures with each memory re) 72 161.07 P
-0.18 (gion) 522.22 161.07 P
-0.05 (allo) 72 149.07 P
-0.05 (wing references and non-references to be distinguished in that re) 86.75 149.07 P
-0.05 (gion. F) 344.65 149.07 P
-0.05 (or e) 372.78 149.07 P
-0.05 (xample, each object might start with a) 387.85 149.07 P
0.28 (references to a descriptor of the type of the object, which w) 72 137.07 P
0.28 (ould include a) 312.74 137.07 P
2 F
0.28 (layout map) 372.75 137.07 P
0 F
0.28 ( describing which \336elds of the) 417.76 137.07 P
-0.12 (object contain references. Stack frames are another kind of memory re) 72 125.07 P
-0.12 (gion that may contain references, so data struc-) 351.98 125.07 P
0.83 (tures describing which v) 72 113.07 P
0.83 (ariables in a stack frame contain references w) 172.28 113.07 P
0.83 (ould also ha) 360.41 113.07 P
0.83 (v) 410.2 113.07 P
0.83 (e to be generated; we will call) 415.05 113.07 P
-0.22 (such a data structure a) 72 101.07 P
2 F
-0.22 (stac) 162.24 101.07 P
-0.22 (k map.) 178.15 101.07 P
0 F
-0.22 (The subject of this paper is the generation of stack maps for stack frames in the Ja) 206.87 101.07 P
-0.22 (v) 530.81 101.07 P
-0.22 (a) 535.56 101.07 P
0.76 (virtual machine. W) 72 89.07 P
0.76 (e describe the general problems associated with designing and generating such stack maps, and) 149.65 89.07 P
71.75 729 540 756 R
7 X
V
2 9 Q
0 X
(Pr) 86.58 750 T
(esented at the OOPSLA) 95.24 750 T
(\32597 W) 180.15 750 T
(orkshop on Garba) 201.07 750 T
(g) 266.97 750 T
(e Collection and Memory Mana) 271.38 750 T
(g) 386.28 750 T
(ement, October 5, 1997, Atlanta, GA.) 390.69 750 T
441 765 572.38 774.88 R
7 X
V
0 10 Q
0 X
(SML document #SML-97-0405) 441 768.21 T
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "1" 1
%%Page: "2" 2
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 8 Q
0 X
0 0 0 1 0 0 0 K
(2) 304 34.17 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 10 Q
0.05 (some particular problems with doing so for Ja) 72 713.33 P
0.05 (v) 255.74 713.33 P
0.05 (a. W) 260.49 713.33 P
0.05 (e ha) 278.62 713.33 P
0.05 (v) 294.85 713.33 P
0.05 (e implemented our approach, and describe that implementa-) 299.7 713.33 P
(tion.) 72 701.33 T
1 14 Q
(2  Stack maps and gc points) 72 670.67 T
0 10 Q
0.69 (In the scheme abo) 72 650.33 P
0.69 (v) 146.38 650.33 P
0.69 (e, the layout map of an object w) 151.23 650.33 P
0.69 (as associated with its type; all objects of a gi) 284.23 650.33 P
0.69 (v) 468.19 650.33 P
0.69 (en type ha) 473.04 650.33 P
0.69 (v) 515.3 650.33 P
0.69 (e the) 520.16 650.33 P
-0.14 (same layout map, and the map of an object is the same for its entire lifetime. In contrast, the layout of a stack frame is) 72 638.33 P
0.32 (usually allo) 72 626.33 P
0.32 (wed to change during its lifetime. A gi) 118.46 626.33 P
0.32 (v) 274.91 626.33 P
0.32 (en stack frame slot may be uninitialized at the start of a method,) 279.76 626.33 P
0.16 (hold a reference v) 72 614.33 P
0.16 (ariable for one block in the method, then hold an inte) 144.14 614.33 P
0.16 (ger v) 358.08 614.33 P
0.16 (ariable for another) 378.26 614.33 P
0.16 (. F) 451.89 614.33 P
0.16 (or e) 462.46 614.33 P
0.16 (xample, a com-) 477.75 614.33 P
(piler may translate the follo) 72 602.33 T
(wing program fragment) 182.29 602.33 T
3 8 Q
(if \050b\051 {) 108 586.67 T
(int i;) 127.2 576.67 T
(...) 127.2 566.67 T
(} else {) 108 556.67 T
(Rattlesnake r;) 127.2 546.67 T
(...) 127.2 536.67 T
(}) 108 526.67 T
0 10 Q
0.15 (in such a w) 72 509.33 P
0.15 (ay that the inte) 117.63 509.33 P
0.15 (ger v) 177.1 509.33 P
0.15 (ariable) 197.28 509.33 P
3 F
0.37 (i) 227.14 509.33 P
0 F
0.15 ( and the reference v) 233.14 509.33 P
0.15 (ariable) 312.36 509.33 P
3 F
0.37 (r) 342.22 509.33 P
0 F
0.15 ( are mapped to the same slot in the stack frame.) 348.22 509.33 P
-0.07 (In f) 72 497.33 P
-0.07 (act, one could imagine that whether a gi) 85.99 497.33 P
-0.07 (v) 245.23 497.33 P
-0.07 (en stack frame slot contains a reference at a gi) 250.08 497.33 P
-0.07 (v) 433.86 497.33 P
-0.07 (en point in a method e) 438.71 497.33 P
-0.07 (x) 527.38 497.33 P
-0.07 (e-) 532.23 497.33 P
-0.22 (cution might depend not only on the current point in the program e) 72 485.33 P
-0.22 (x) 336.47 485.33 P
-0.22 (ecution b) 341.32 485.33 P
-0.22 (ut also on the control path leading to that) 377.84 485.33 P
(point, as in the code fragment belo) 72 473.33 T
(w) 210.34 473.33 T
(.) 216.91 473.33 T
3 8 Q
(if \050b\051 v =) 108 457.67 T
4 F
(an int) 160.8 457.67 T
3 F
(else v =) 108 447.67 T
4 F
(a reference;) 151.2 447.67 T
(...gcPoint...) 108 437.67 T
3 F
(if \050b\051) 108 427.67 T
4 F
(use) 141.6 427.67 T
3 F
(v) 160.8 427.67 T
4 F
( as an int) 165.6 427.67 T
3 F
(else) 108 417.67 T
4 F
(use) 132 417.67 T
3 F
(v) 151.2 417.67 T
4 F
( as a reference) 156 417.67 T
0 10 Q
0.6 (W) 72 400.33 P
0.6 (e will call the \336rst kind of v) 80.64 400.33 P
0.6 (ariation in stack layout a) 195.4 400.33 P
2 F
0.6 (contr) 299.21 400.33 P
0.6 (ol point dependency) 319.87 400.33 P
0.6 (,) 401.05 400.33 P
0 F
0.6 (the second a) 406.65 400.33 P
2 F
0.6 (contr) 460.37 400.33 P
0.6 (ol path depen-) 481.03 400.33 P
1.16 (dency) 72 388.33 P
1.16 (.) 94.77 388.33 P
0 F
1.16 (One approach to generating stack maps w) 100.93 388.33 P
1.16 (ould be to forbid either kind of dependenc) 274.95 388.33 P
1.16 (y: the layout of stack) 451.49 388.33 P
0.17 (frames allocated for in) 72 376.33 P
0.17 (v) 162.35 376.33 P
0.17 (ocations of method) 167.15 376.33 P
2 F
0.17 (m) 246.81 376.33 P
0 F
0.17 (w) 256.7 376.33 P
0.17 (ould be the same at all points of all e) 263.82 376.33 P
0.17 (x) 412.1 376.33 P
0.17 (ecutions of) 416.95 376.33 P
2 F
0.17 (m.) 463.95 376.33 P
0 F
0.17 (This means that) 476.34 376.33 P
-0.15 (stack frame slots w) 72 364.33 P
-0.15 (ould be typed as reference slots or non-reference slots, and that all reference slots w) 148.39 364.33 P
-0.15 (ould be initial-) 481.4 364.33 P
0.51 (ized \050probably to the null reference\051 before e) 72 352.33 P
0.51 (x) 254.49 352.33 P
0.51 (ecution of the method be) 259.34 352.33 P
0.51 (gins. This is perhaps a viable design choice,) 360.65 352.33 P
0.12 (though it may cause methods to require lar) 72 340.33 P
0.12 (ger stack frames, and may impose e) 243.47 340.33 P
0.12 (xtra initialization o) 387.06 340.33 P
0.12 (v) 463.26 340.33 P
0.12 (erhead on method) 468.11 340.33 P
(start-up. More to the point for this paper) 72 328.33 T
(, ho) 232.69 328.33 T
(we) 247.44 328.33 T
(v) 258.85 328.33 T
(er) 263.7 328.33 T
(, is that it is not the design choice made by Ja) 271.07 328.33 T
(v) 451.97 328.33 T
(a.) 456.72 328.33 T
1.4 (Another approach allo) 72 310.33 P
1.4 (ws control point dependencies, b) 163.98 310.33 P
1.4 (ut forbids control path dependencies. The stack map data) 300.76 310.33 P
0.64 (structure w) 72 298.33 P
0.64 (ould then ha) 117.25 298.33 P
0.64 (v) 167.78 298.33 P
0.64 (e to be rich enough to be able to map e) 172.63 298.33 P
0.64 (x) 333.89 298.33 P
0.64 (ecution points within a method to the layout map) 338.74 298.33 P
0.17 (appropriate for that e) 72 286.33 P
0.17 (x) 156.5 286.33 P
0.17 (ecution point. If collection may occur at an) 161.35 286.33 P
0.17 (y instruction in a method, these stack maps may be) 334.59 286.33 P
2.17 (v) 72 274.33 P
2.17 (oluminous, complicated, and/or time-consuming to process during collection. Most of these problems can be) 76.8 274.33 P
0.58 (a) 72 262.33 P
0.58 (v) 76.24 262.33 P
0.58 (oided by requiring that collections can occur only at a small set of) 81.04 262.33 P
2 F
0.58 (gc points) 354.88 262.33 P
0 F
0.58 (within each method. Then the stack) 394.92 262.33 P
0.23 (map data structure w) 72 250.33 P
0.23 (ould need only to associate a layout map with each gc point of the method, decreasing the stor-) 156.18 250.33 P
(age required, usually to a point where simpler and f) 72 238.33 T
(aster data structures can be used with reasonable storage costs.) 277.97 238.33 T
0.39 (W) 72 220.33 P
0.39 (e will not discuss in an) 80.64 220.33 P
0.39 (y detail ho) 173.83 220.33 P
0.39 (w a system may ensure that each method of each thread is stopped at a gc point) 216.59 220.33 P
0.11 (when collections occur) 72 208.33 P
0.11 (, e) 164.01 208.33 P
0.11 (xcept to note that se) 173.41 208.33 P
0.11 (v) 253.58 208.33 P
0.11 (eral techniques are kno) 258.43 208.33 P
0.11 (wn. W) 350.97 208.33 P
0.11 (e will discuss v) 376.93 208.33 P
0.11 (ery brie\337y the criteria for) 438.49 208.33 P
-0.19 (choosing rules that de\336ne gc points. First, all methods e) 72 196.33 P
-0.19 (x) 293.2 196.33 P
-0.19 (ecuting in a thread e) 298.05 196.33 P
-0.19 (xcept for the currently e) 378.23 196.33 P
-0.19 (x) 473.4 196.33 P
-0.19 (ecuting method) 478.25 196.33 P
0.8 (will be stopped at calls, implying that method call instructions should probably be gc points. Second, we\325) 72 184.33 P
0.8 (d lik) 505.71 184.33 P
0.8 (e to) 524.48 184.33 P
0.67 (ensure that when some thread) 72 172.33 P
2 F
0.67 (A) 196.71 172.33 P
0 F
0.67 (attempts an allocation that f) 205.99 172.33 P
0.67 (ails because a collection is necessary) 319.67 172.33 P
0.67 (, no thread) 469.84 172.33 P
2 F
0.67 (B) 516.84 172.33 P
0 F
0.67 (can) 526.12 172.33 P
0.88 (delay) 72 160.33 P
2 F
0.88 (A) 97.04 160.33 P
0 F
0.88 (by requiring arbitrarily long to come to a gc point. In our system, we mak) 106.52 160.33 P
0.88 (e e) 413.11 160.33 P
0.88 (v) 425.12 160.33 P
0.88 (ery backw) 429.97 160.33 P
0.88 (ards branch a gc) 472.12 160.33 P
(point, since such a branch may be part of a loop.) 72 148.33 T
1 14 Q
(3  Generating stackmaps f) 72 117.67 T
(or J) 227.97 117.67 T
(a) 251.48 117.67 T
(v) 258.13 117.67 T
(a) 264.99 117.67 T
0 10 Q
1.44 (\322Ja) 72 97.33 P
1.44 (v) 84.57 97.33 P
1.44 (a\323 is actually tw) 89.32 97.33 P
1.44 (o separable things that are sometimes con\337ated: the Ja) 158.26 97.33 P
1.44 (v) 386.8 97.33 P
1.44 (a language [4], and the Ja) 391.55 97.33 P
1.44 (v) 500.76 97.33 P
1.44 (a virtual) 505.51 97.33 P
0.47 (machine [5]. W) 72 85.33 P
0.47 (e are interested in the Ja) 134.62 85.33 P
0.47 (v) 233.13 85.33 P
0.47 (a virtual machine, an e) 237.88 85.33 P
0.47 (x) 330.43 85.33 P
0.47 (ecution en) 335.28 85.33 P
0.47 (vironment for Ja) 376.73 85.33 P
0.47 (v) 443.57 85.33 P
0.47 (a class \336les containing) 448.32 85.33 P
(methods e) 72 73.33 T
(xpressed in the machine-independent Ja) 112.68 73.33 T
(v) 271.89 73.33 T
(a \322byte code\323 instruction set.) 276.64 73.33 T
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "2" 2
%%Page: "3" 3
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 8 Q
0 X
0 0 0 1 0 0 0 K
(3) 304 34.17 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 10 Q
0.31 (The Ja) 72 713.33 P
0.31 (v) 98.49 713.33 P
0.31 (a virtual machine speci\336cation [4] lays out a set of rules de\336ning le) 103.24 713.33 P
0.31 (g) 375.61 713.33 P
0.31 (al Ja) 380.56 713.33 P
0.31 (v) 398.71 713.33 P
0.31 (a class \336les, along with a descrip-) 403.46 713.33 P
-0.21 (tion of a procedure \050the Ja) 72 701.33 P
-0.21 (v) 175.46 701.33 P
-0.21 (a \322byte code v) 180.21 701.33 P
-0.21 (eri\336er\323\051 for checking adherence to those rules. W) 236.92 701.33 P
-0.21 (e call one of these rules the) 432.38 701.33 P
2 F
0.43 (Gosling pr) 72 689.33 P
0.43 (operty) 115.04 689.33 P
0.43 (,) 140.04 689.33 P
0 F
0.43 (since James Gosling \336rst stated it e) 145.47 689.33 P
0.43 (xplicitly [3]. The Gosling property requires that if tw) 288.46 689.33 P
0.43 (o control) 503.74 689.33 P
0.07 (paths lead to a gi) 72 677.33 P
0.07 (v) 139.82 677.33 P
0.07 (en instruction) 144.67 677.33 P
2 F
0.07 (I) 202.03 677.33 P
0 F
0.07 (that uses some local \050) 207.94 677.33 P
2 F
0.07 (i.e) 294.33 677.33 P
0.07 (.,) 303.9 677.33 P
0 F
0.07 (stack-allocated\051 v) 311.48 677.33 P
0.07 (ariable) 382.11 677.33 P
2 F
0.07 (v) 411.9 677.33 P
0.07 (,) 415.6 677.33 P
0 F
0.07 (then) 420.67 677.33 P
2 F
0.07 (I) 440.46 677.33 P
0 F
0.07 (must be le) 446.37 677.33 P
0.07 (g) 487.48 677.33 P
0.07 (al assuming) 492.43 677.33 P
-0.15 (that the type of) 72 665.33 P
2 F
-0.15 (v) 134.15 665.33 P
0 F
-0.15 (is the) 140.94 665.33 P
2 F
-0.15 (mer) 164.52 665.33 P
-0.15 (g) 179.7 665.33 P
-0.15 (e) 184.6 665.33 P
0 F
-0.15 (of its types along the tw) 191.38 665.33 P
-0.15 (o control paths. The mer) 286.34 665.33 P
-0.15 (ge of tw) 383.58 665.33 P
-0.15 (o types is the least general type) 415.95 665.33 P
0.45 (that contains the tw) 72 653.33 P
0.45 (o types \050the least upper bound in the subtype lattice.\051 Such a type al) 151.31 653.33 P
0.45 (w) 427.61 653.33 P
0.45 (ays e) 434.73 653.33 P
0.45 (xists in the Ja) 455.31 653.33 P
0.45 (v) 510.64 653.33 P
0.45 (a type) 515.39 653.33 P
0.69 (system when the types being mer) 72 641.33 P
0.69 (ged are object types, since the class) 208.3 641.33 P
3 F
1.65 (java.lang.Object) 357.52 641.33 P
0 F
0.69 ( is a superclass of all) 453.52 641.33 P
-0.18 (classes, including array classes. Ho) 72 629.33 P
-0.18 (we) 212.12 629.33 P
-0.18 (v) 223.53 629.33 P
-0.18 (er) 228.38 629.33 P
-0.18 (, if one type is a reference type and the other is a primiti) 235.75 629.33 P
-0.18 (v) 457.04 629.33 P
-0.18 (e type such as) 461.89 629.33 P
3 F
-0.43 (int) 519.5 629.33 P
0 F
-0.18 (,) 537.5 629.33 P
0.09 (there is no common supertype. T) 72 617.33 P
0.09 (o mak) 203.29 617.33 P
0.09 (e the mer) 227.99 617.33 P
0.09 (ge operation well-de\336ned in such cases, a) 265.2 617.33 P
2 F
0.09 (top) 434.66 617.33 P
0 F
0.09 (type, called) 450.03 617.33 P
2 F
0.09 (con\337ict,) 498.8 617.33 P
0 F
0.09 ( is) 530.74 617.33 P
0.06 (added to the type lattice. An) 72 605.33 P
0.06 (y use of a v) 184.94 605.33 P
0.06 (ariable whose inferred type is) 231.05 605.33 P
2 F
0.06 (con\337ict) 352.18 605.33 P
0 F
0.06 (is ille) 384.18 605.33 P
0.06 (g) 406.05 605.33 P
0.06 (al; the v) 411 605.33 P
0.06 (ariable can be used only) 443.1 605.33 P
(after an assignment has reset its type to a non-) 72 593.33 T
2 F
(con\337ict) 256.69 593.33 T
0 F
(type.) 288.63 593.33 T
0.18 (The Gosling property implies that stack maps for le) 72 575.33 P
0.18 (g) 279.34 575.33 P
0.18 (al Ja) 284.29 575.33 P
0.18 (v) 302.32 575.33 P
0.18 (a methods do not need to consider control path dependen-) 307.07 575.33 P
0.54 (cies; the layout at a control point depends only on that control point, not ho) 72 563.33 P
0.54 (w it w) 380.1 563.33 P
0.54 (as reached. Further) 406.07 563.33 P
0.54 (, the bytecode) 483.11 563.33 P
0.1 (v) 72 551.33 P
0.1 (eri\336cation process gi) 76.85 551.33 P
0.1 (v) 160.13 551.33 P
0.1 (es us a model for ho) 164.98 551.33 P
0.1 (w to generate the stack maps. The part of v) 246.07 551.33 P
0.1 (eri\336cation that checks types is) 419.04 551.33 P
0.05 (a kind of) 72 539.33 P
2 F
0.05 (abstr) 110.19 539.33 P
0.05 (act interpr) 130.6 539.33 P
0.05 (etation.) 172.78 539.33 P
0 F
0.05 (An abstract interpretation is an e) 205.61 539.33 P
0.05 (x) 335.95 539.33 P
0.05 (ecution of a program that \322approximates\323 the v) 340.8 539.33 P
0.05 (al-) 529.45 539.33 P
-0.23 (ues of the program v) 72 527.33 P
-0.23 (ariables and the control \337o) 153.6 527.33 P
-0.23 (w) 259.1 527.33 P
-0.23 (. V) 265.67 527.33 P
-0.23 (alues are abstracted as elements of some lattice. The interpretation) 276.55 527.33 P
0.32 (k) 72 515.33 P
0.32 (eeps track of the set of possible v) 76.9 515.33 P
0.32 (alues of e) 211.94 515.33 P
0.32 (v) 250.66 515.33 P
0.32 (ery v) 255.51 515.33 P
0.32 (ariables at e) 275.85 515.33 P
0.32 (v) 324.01 515.33 P
0.32 (ery control point, represented as the least lattice ele-) 328.86 515.33 P
0.45 (ment that contains all the possible v) 72 503.33 P
0.45 (alues. All v) 217.78 503.33 P
0.45 (ariables are initialized with the) 264.26 503.33 P
2 F
0.45 (bottom) 392.33 503.33 P
0 F
0.45 (element of the lattice at each) 423.06 503.33 P
0.61 (control point, and the \336rst instruction of the method is mark) 72 491.33 P
0.61 (ed as) 317.14 491.33 P
2 F
0.61 (c) 341.13 491.33 P
0.61 (hang) 345.42 491.33 P
0.61 (ed.) 365.32 491.33 P
0 F
0.61 (The abstract interpreter then e) 380.37 491.33 P
0.61 (x) 502.61 491.33 P
0.61 (ecutes a) 507.46 491.33 P
0.53 (loop that picks a) 72 479.33 P
2 F
0.53 (c) 142.46 479.33 P
0.53 (hang) 146.75 479.33 P
0.53 (ed) 166.65 479.33 P
0 F
0.53 (instruction as long as one e) 179.12 479.33 P
0.53 (xists, remo) 290.23 479.33 P
0.53 (v) 334.5 479.33 P
0.53 (es the) 339.35 479.33 P
2 F
0.53 (c) 365.97 479.33 P
0.53 (hang) 370.26 479.33 P
0.53 (ed mark,) 390.16 479.33 P
0 F
0.53 (applies the operation repre-) 428.71 479.33 P
0.23 (sented by the instruction to yield a ne) 72 467.33 P
0.23 (w v) 223.05 467.33 P
0.23 (ector of v) 237.85 467.33 P
0.23 (ariable v) 276.37 467.33 P
0.23 (alues, and element-wise mer) 311.05 467.33 P
0.23 (ges this v) 425.42 467.33 P
0.23 (ector with the state) 463.5 467.33 P
0.44 (v) 72 455.33 P
0.44 (ectors of the control points that can follo) 76.85 455.33 P
0.44 (w the current instruction. If the mer) 242.19 455.33 P
0.44 (ge changes the state v) 387.14 455.33 P
0.44 (ector associated) 475.97 455.33 P
-0.13 (with an) 72 443.33 P
-0.13 (y of these successor instructions, then those instructions are mark) 101.44 443.33 P
-0.13 (ed) 361.84 443.33 P
2 F
-0.13 (c) 373.65 443.33 P
-0.13 (hang) 377.94 443.33 P
-0.13 (ed.) 397.84 443.33 P
0 F
-0.13 (Because the v) 412.16 443.33 P
-0.13 (alue space is a lat-) 467.19 443.33 P
(tice, which has no in\336nite ascending chains, this process must terminate.) 72 431.33 T
0.28 (In bytecode v) 72 413.33 P
0.28 (eri\336cation, the lattice contains primiti) 126.83 413.33 P
0.28 (v) 277.96 413.33 P
0.28 (e types and object types, augmented, as we sa) 282.81 413.33 P
0.28 (w) 467.61 413.33 P
0.28 (, with a) 474.17 413.33 P
2 F
0.28 (top) 507.22 413.33 P
0 F
0.28 (type) 522.78 413.33 P
2 F
0.28 (con\337ict) 72 401.33 P
0 F
0.28 (and a) 104.22 401.33 P
2 F
0.28 (bottom) 128.66 401.33 P
0 F
0.28 (type. F) 159.22 401.33 P
0.28 (or stack map generation, we can use an e) 187.13 401.33 P
0.28 (v) 352.67 401.33 P
0.28 (en coarser approximation, in which all object) 357.52 401.33 P
0.07 (types are lumped together as) 72 389.33 P
2 F
0.07 (r) 189.27 389.33 P
0.07 (ef) 192.79 389.33 P
0 F
0.07 (, and all non-reference \050primiti) 200.01 389.33 P
0.07 (v) 323.07 389.33 P
0.07 (e v) 327.92 389.33 P
0.07 (alue\051 types are coalesced as) 339.68 389.33 P
2 F
0.07 (val) 453.05 389.33 P
0 F
0.07 (. W) 465.27 389.33 P
0.07 (e need an addi-) 478.98 389.33 P
-0.22 (tional type) 72 377.33 P
2 F
-0.22 (uninit) 116.56 377.33 P
0 F
-0.22 ( representing an uninitialized v) 139.9 377.33 P
-0.22 (ariable since uses of such v) 262.64 377.33 P
-0.22 (ariables must be rejected, and a type) 370.42 377.33 P
2 F
-0.22 (pc) 516.62 377.33 P
0 F
-0.22 ( for) 526.06 377.33 P
(program counters since the Ja) 72 365.33 T
(v) 190.66 365.33 T
(a bytecode) 195.41 365.33 T
3 F
(jsr) 240.95 365.33 T
0 F
( pushes return addresses on the stack, yielding this lattice:) 258.95 365.33 T
-0.07 (T) 72 232.33 P
-0.07 (o start the abstract interpretation for a method, we set all v) 77.31 232.33 P
-0.07 (ariables at the entry point to) 309.56 232.33 P
2 F
-0.07 (uninit) 423.56 232.33 P
0 F
-0.07 (, since this corresponds) 446.9 232.33 P
-0.11 (to the starting condition during e) 72 220.33 P
-0.11 (x) 202.13 220.33 P
-0.11 (ecution. At all other points in the method, the v) 206.99 220.33 P
-0.11 (ariables ha) 394.91 220.33 P
-0.11 (v) 437.64 220.33 P
-0.11 (e the type) 442.49 220.33 P
2 F
-0.11 (bottom) 483.55 220.33 P
0 F
-0.11 ( so that) 511.33 220.33 P
-0.14 (an) 72 208.33 P
-0.14 (y other type \337o) 81.29 208.33 P
-0.14 (wing into such a point will result in the v) 141.43 208.33 P
-0.14 (ariable ha) 304.05 208.33 P
-0.14 (ving that type. Performing the abstract interpreta-) 342.85 208.33 P
0.38 (tion o) 72 196.33 P
0.38 (v) 95.29 196.33 P
0.38 (er this lattice with the speci\336ed starting conditions yields stack layouts for all the instructions of the method.) 100.14 196.33 P
0.71 (W) 72 184.33 P
0.71 (e can then choose those corresponding to gc points for permanent storage in a compact stack map data structure) 80.64 184.33 P
(associated with the method.) 72 172.33 T
1 14 Q
(4  The jsr pr) 72 141.67 T
(oblem) 146.41 141.67 T
0 10 Q
0.52 (Unfortunately) 72 121.33 P
0.52 (, we ha) 127.45 121.33 P
0.52 (v) 156.88 121.33 P
0.52 (e not yet told the complete story) 161.73 121.33 P
0.52 (. The Ja) 293.06 121.33 P
0.52 (v) 325.27 121.33 P
0.52 (a virtual machine e) 330.02 121.33 P
0.52 (xplicitly allo) 407.79 121.33 P
0.52 (ws one e) 458.89 121.33 P
0.52 (xception to) 494.76 121.33 P
0.17 (the Gosling property) 72 109.33 P
0.17 (. The Ja) 154.46 109.33 P
0.17 (v) 185.99 109.33 P
0.17 (a bytecode instruction set includes a pair of operations called) 190.74 109.33 P
3 F
0.41 (jsr) 439.08 109.33 P
0 F
0.17 ( and) 457.08 109.33 P
3 F
0.41 (ret) 476.86 109.33 P
0 F
0.17 (.) 494.86 109.33 P
0.17 (The) 503.78 109.33 P
3 F
0.41 (jsr) 522 109.33 P
0 F
-0.05 (instruction jumps to an address speci\336ed in the instruction and pushes a return address v) 72 97.33 P
-0.05 (alue on the operand stack) 423.78 97.33 P
0 8 Q
-0.04 (1) 525.22 101.33 P
0 10 Q
-0.05 ( of) 529.22 97.33 P
0.67 (the current method. The) 72 85.33 P
3 F
1.6 (ret) 173.25 85.33 P
0 F
0.67 ( instruction speci\336es a local v) 191.25 85.33 P
0.67 (ariable that must contain a return address, and jumps to) 312.93 85.33 P
(that return address.) 72 73.33 T
72 63 540 720 C
0 0 0 1 0 0 0 K
72 247 540 362 C
0 0 0 1 0 0 0 K
0 10 Q
0 X
0 0 0 1 0 0 0 K
(ref) 313.9 299.67 T
(v) 280.7 299.67 T
(al) 285.45 299.67 T
(pc) 249.46 299.67 T
(uninit) 340.5 299.67 T
308.25 340.5 254.75 306.75 2 L
0.5 H
2 Z
N
308.25 340.75 287.5 306.5 2 L
N
308.25 340.75 319.5 306.25 2 L
N
308.38 340.62 351.75 308 2 L
N
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
307.5 262.5 254 296.25 2 L
N
307.5 262.25 286.75 296.5 2 L
N
307.5 262.25 318.75 296.75 2 L
N
307.62 262.38 351 295 2 L
N
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(top/con\337ict) 285.5 343 T
(bottom/untouched) 271.06 255.06 T
0 0 0 1 0 0 0 K
72 63 540 720 C
0 0 612 792 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "3" 3
%%Page: "4" 4
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 8 Q
0 X
0 0 0 1 0 0 0 K
(4) 304 34.17 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 10 Q
(The intended use of these bytecodes is in the implementation of the) 72 713.33 T
3 8 Q
(try {) 108 697.67 T
4 F
(body) 136.8 697.67 T
3 F
( } finally) 156 697.67 T
( {) 204 697.67 T
4 F
(handler }) 218.4 697.67 T
0 10 Q
-0.11 (construct of the Ja) 72 680.33 P
-0.11 (v) 144.5 680.33 P
-0.11 (a language, in which) 149.25 680.33 P
4 F
-0.27 (handler) 234.06 680.33 P
0 F
-0.11 ( is e) 276.06 680.33 P
-0.11 (x) 291.79 680.33 P
-0.11 (ecuted no matter ho) 296.64 680.33 P
-0.11 (w) 375.2 680.33 P
4 F
-0.27 (body) 384.81 680.33 P
0 F
-0.11 (is e) 414.54 680.33 P
-0.11 (xited. The) 427.89 680.33 P
4 F
-0.27 (handler) 470.71 680.33 P
0 F
-0.11 ( w) 512.71 680.33 P
-0.11 (ould) 522.22 680.33 P
1.22 (be translated as a) 72 668.33 P
2 F
1.22 (jsr subr) 147.96 668.33 P
1.22 (outine) 179.57 668.33 P
0 F
1.22 (: a \322mini-method\323 within the method. Ev) 204.57 668.33 P
1.22 (ery instruction that e) 375.89 668.33 P
1.22 (xits) 461.89 668.33 P
4 F
2.92 (body) 480.05 668.33 P
0 F
1.22 (, such as) 503.4 668.33 P
3 F
-0.09 (return) 72 656.33 P
0 F
-0.04 ( or) 108 656.33 P
3 F
-0.09 (throw) 121.25 656.33 P
0 F
-0.04 ( statements or \322f) 151.25 656.33 P
-0.04 (alling of) 216.86 656.33 P
-0.04 (f the end\323, w) 250.18 656.33 P
-0.04 (ould be preceded in the translation by a) 301.62 656.33 P
3 F
-0.09 (jsr) 461.28 656.33 P
0 F
-0.04 ( to that subrou-) 479.28 656.33 P
0.13 (tine, which w) 72 644.33 P
0.13 (ould store the pushed return address in a local v) 126.32 644.33 P
0.13 (ariable, perform the w) 318.06 644.33 P
0.13 (ork of) 407.21 644.33 P
4 F
0.32 (handler) 434.14 644.33 P
0 F
0.13 (, then perform a) 475.73 644.33 P
3 F
1.45 (ret) 72 632.33 P
0 F
0.6 (. Although a jsr subroutine resembles a real method, there is a crucial dif) 90 632.33 P
0.6 (ference: it e) 388.38 632.33 P
0.6 (x) 436.64 632.33 P
0.6 (ecutes in the same stack) 441.49 632.33 P
(frame as its containing method and has access to all the local v) 72 620.33 T
(ariables of this method.) 322.82 620.33 T
0 (The Ja) 72 602.33 P
0 (v) 98.18 602.33 P
0 (a virtual machine speci\336cation for v) 102.93 602.33 P
0 (eri\336cation of jsr subroutines contains an e) 246.95 602.33 P
0 (xplicit e) 414.02 602.33 P
0 (xception to the Gosling) 446.38 602.33 P
1.07 (property [5] \050p. 136\051: the bytecode v) 72 590.33 P
1.07 (eri\336er permits an) 224.09 590.33 P
1.07 (y local v) 294.4 590.33 P
1.07 (ariable) 330.74 590.33 P
2 F
1.07 (v) 361.52 590.33 P
0 F
1.07 (that is neither read nor written in a jsr to) 369.53 590.33 P
(retains its type across a) 72 578.33 T
3 F
(jsr) 167.26 578.33 T
0 F
( to that subroutine.) 185.26 578.33 T
0.36 (This seemingly reasonable weak) 72 560.33 P
0.36 (ening of the Gosling property causes serious dif) 203.23 560.33 P
0.36 (\336culty for e) 396.85 560.33 P
0.36 (xact g) 444.08 560.33 P
0.36 (arbage collection.) 468.55 560.33 P
0.06 (Consider a case in which there are tw) 72 548.33 P
0.06 (o) 222.02 548.33 P
3 F
0.15 (jsr) 229.58 548.33 P
0 F
0.06 (\325) 247.58 548.33 P
0.06 (s to the same jsr subroutine. At one) 250.36 548.33 P
3 F
0.15 (jsr) 394.46 548.33 P
0 F
0.06 (, a local v) 412.06 548.33 P
0.06 (ariable) 450.88 548.33 P
2 F
0.06 (v) 480.65 548.33 P
0 F
0.06 (is being used) 487.65 548.33 P
0.15 (to hold an inte) 72 536.33 P
0.15 (ger) 129.81 536.33 P
0.15 (, and at the other) 142.18 536.33 P
0.15 (, it holds a reference. Should a g) 209.33 536.33 P
0.15 (arbage collection occur while a thread is in the jsr) 339.49 536.33 P
0.23 (subroutine, a control-point-dependent stack map is unable to determine if) 72 524.33 P
2 F
0.23 (v) 370.11 524.33 P
0 F
0.23 ( contains a reference, since the stack lay-) 374.55 524.33 P
-0.12 (out is no) 72 512.33 P
-0.12 (w control path dependent. Simply disallo) 105.95 512.33 P
-0.12 (wing g) 269.52 512.33 P
-0.12 (arbage collections for the duration of the jsr subroutine is not) 296.84 512.33 P
-0.25 (an option since) 72 500.33 P
3 F
-0.6 (try-finally) 134.31 500.33 P
0 F
-0.25 ( handlers can perform arbitrary computation, including calling methods that may e) 200.31 500.33 P
-0.25 (x) 527.38 500.33 P
-0.25 (e-) 532.23 500.33 P
(cute inde\336nitely and allocate an unbounded number of objects.) 72 488.33 T
1 14 Q
(5  P) 72 457.67 T
(ossible solutions) 94.27 457.67 T
0 10 Q
0.21 (There are se) 72 437.33 P
0.21 (v) 121.03 437.33 P
0.21 (eral possible solutions to this problem. An ob) 125.88 437.33 P
0.21 (vious one is to change the Ja) 308.88 437.33 P
0.21 (v) 424.37 437.33 P
0.21 (a virtual machine speci\336ca-) 429.12 437.33 P
0.03 (tion to remo) 72 425.33 P
0.03 (v) 120.81 425.33 P
0.03 (e the Gosling property e) 125.66 425.33 P
0.03 (xception for jsr subroutines. Not only w) 222.29 425.33 P
0.03 (ould this eliminate the problem for g) 382.09 425.33 P
0.03 (ar-) 528.9 425.33 P
-0.16 (bage collectors, it w) 72 413.33 P
-0.16 (ould also signi\336cantly simplify the v) 151.95 413.33 P
-0.16 (eri\336cation process. One of the main selling points of the Ja) 297.39 413.33 P
-0.16 (v) 530.81 413.33 P
-0.16 (a) 535.56 413.33 P
-0.16 (system is safe e) 72 401.33 P
-0.16 (x) 133.87 401.33 P
-0.16 (ecution of untrusted code; this guarantee relies on the correctness of the v) 138.72 401.33 P
-0.16 (eri\336er) 431.08 401.33 P
-0.16 (. The simpler the v) 454.4 401.33 P
-0.16 (er-) 528.9 401.33 P
0.33 (i\336er) 72 389.33 P
0.33 (, the more con\336dence we can ha) 87.71 389.33 P
0.33 (v) 218.05 389.33 P
0.33 (e in its correctness. On the other hand, there are some dra) 222.9 389.33 P
0.33 (wbacks to tightening) 456.01 389.33 P
0.61 (the v) 72 377.33 P
0.61 (eri\336er speci\336cation to enforce the Gosling principle e) 92.18 377.33 P
0.61 (v) 309.8 377.33 P
0.61 (erywhere. Ja) 314.64 377.33 P
0.61 (v) 365.59 377.33 P
0.61 (a compilers w) 370.34 377.33 P
0.61 (ould ha) 427.56 377.33 P
0.61 (v) 457.7 377.33 P
0.61 (e to be modi\336ed to) 462.55 377.33 P
0.32 (obe) 72 365.33 P
0.32 (y the ne) 86.29 365.33 P
0.32 (w rules. W) 118.34 365.33 P
0.32 (e belie) 161.78 365.33 P
0.32 (v) 188.23 365.33 P
0.32 (e that the original moti) 193.08 365.33 P
0.32 (v) 285.22 365.33 P
0.32 (ation for the e) 289.97 365.33 P
0.32 (xception w) 346.6 365.33 P
0.32 (as to k) 390.98 365.33 P
0.32 (eep the Gosling property from) 417.63 365.33 P
-0.13 (pre) 72 353.33 P
-0.13 (v) 84.52 353.33 P
-0.13 (enting \322natural\323 reuse of local v) 89.37 353.33 P
-0.13 (ariable slots. F) 216.51 353.33 P
-0.13 (or e) 274.72 353.33 P
-0.13 (xample, if a method) 289.71 353.33 P
2 F
-0.13 (m) 371.7 353.33 P
0 F
-0.13 (contains tw) 381.3 353.33 P
-0.13 (o sequential blocks, one that) 426.9 353.33 P
-0.04 (uses local v) 72 341.33 P
-0.04 (ariable slot) 118.32 341.33 P
2 F
-0.04 (s) 164.9 341.33 P
0 F
-0.04 (to hold an object of class) 171.24 341.33 P
2 F
-0.04 (A,) 273.2 341.33 P
0 F
-0.04 (and another that uses) 284.26 341.33 P
2 F
-0.04 (s) 370.74 341.33 P
0 F
-0.04 (to hold an object of class) 377.09 341.33 P
2 F
-0.04 (B,) 479.04 341.33 P
0 F
-0.04 (where) 490.11 341.33 P
2 F
-0.04 (A) 516.99 341.33 P
0 F
-0.04 (and) 525.56 341.33 P
2 F
0.38 (B) 72 329.33 P
0 F
0.38 (ha) 80.99 329.33 P
0.38 (v) 90.23 329.33 P
0.38 (e no common supertype other than) 95.08 329.33 P
3 F
0.91 (Object) 238.44 329.33 P
0 F
0.38 (, then there w) 274.44 329.33 P
0.38 (as a fear that) 329.91 329.33 P
3 F
0.91 (jsr) 384.73 329.33 P
0 F
0.38 (\325) 402.73 329.33 P
0.38 (s in the tw) 405.51 329.33 P
0.38 (o blocks to some com-) 447.93 329.33 P
-0.19 (mon jsr subroutine w) 72 317.33 P
-0.19 (ould pre) 156.05 317.33 P
-0.19 (v) 188.66 317.33 P
-0.19 (ent the reuse of the slot) 193.51 317.33 P
2 F
-0.19 (s,) 287.92 317.33 P
0 F
-0.19 (increasing the number of local v) 296.62 317.33 P
-0.19 (ariable slots required by Ja) 424.57 317.33 P
-0.19 (v) 530.81 317.33 P
-0.19 (a) 535.56 317.33 P
(methods. If this fear is justi\336ed in practice, then remo) 72 305.33 T
(ving the e) 285.99 305.33 T
(xception is problematical.) 325.28 305.33 T
-0.06 (Probably the most important dra) 72 287.33 P
-0.06 (wback to tightening the v) 201.06 287.33 P
-0.06 (eri\336er speci\336cation, ho) 302.34 287.33 P
-0.06 (we) 393.9 287.33 P
-0.06 (v) 405.32 287.33 P
-0.06 (er) 410.17 287.33 P
-0.06 (, is that it may in) 417.54 287.33 P
-0.06 (v) 484.08 287.33 P
-0.06 (alidate e) 488.83 287.33 P
-0.06 (xist-) 522.22 287.33 P
0.92 (ing Ja) 72 275.33 P
0.92 (v) 96.32 275.33 P
0.92 (a class \336les. There is already a v) 101.07 275.33 P
0.92 (ery lar) 236.74 275.33 P
0.92 (ge installed base of compiled Ja) 263.29 275.33 P
0.92 (v) 395.15 275.33 P
0.92 (a programs. Staging a change that) 399.9 275.33 P
-0.11 (potentially requires man) 72 263.33 P
-0.11 (y e) 168.84 263.33 P
-0.11 (xisting programs to be recompiled with a ne) 180.52 263.33 P
-0.11 (w compiler is, to say the least, logistically dif-) 355.88 263.33 P
(\336cult.) 72 251.33 T
0.79 (Another class of solution w) 72 233.33 P
0.79 (ould be to \322li) 185.05 233.33 P
0.79 (v) 239.67 233.33 P
0.79 (e with\323 the control path dependenc) 244.52 233.33 P
0.79 (y introduced by the Gosling property) 388.01 233.33 P
0.53 (e) 72 221.33 P
0.53 (xception. The stack map data structures and the analysis that creates them w) 76.29 221.33 P
0.53 (ould be enhanced to track) 387.2 221.33 P
3 F
1.27 (jsr) 495.09 221.33 P
0 F
0.53 ( return) 513.09 221.33 P
1.16 (v) 72 209.33 P
1.16 (alues, and use those return v) 76.75 209.33 P
1.16 (alues to help determine stack layouts. W) 195.6 209.33 P
1.16 (e \336nd this solution complicated, especially) 363.66 209.33 P
0.83 (when one considers nested) 72 197.33 P
3 F
1.99 (jsr) 184.73 197.33 P
0 F
0.83 ( subroutines, where it seems possible to construct pathological e) 202.73 197.33 P
0.83 (xamples requiring) 466.68 197.33 P
0.14 (e) 72 185.33 P
0.14 (xponential space in the stack map data structures. Ho) 76.29 185.33 P
0.14 (we) 289.62 185.33 P
0.14 (v) 301.03 185.33 P
0.14 (er) 305.88 185.33 P
0.14 (, such cases probably are rare, and we see no reason that) 313.25 185.33 P
(such solutions could not be made to w) 72 173.33 T
(ork with suf) 224.95 173.33 T
(\336cient skill and enthusiasm.) 273.03 173.33 T
-0.03 (The remaining class of solutions re) 72 155.33 P
-0.03 (write e) 211.88 155.33 P
-0.03 (xisting class \336les to eliminate violations of the Gosling property \050or at least) 239.2 155.33 P
0.74 (violations rele) 72 143.33 P
0.74 (v) 129.43 143.33 P
0.74 (ant to g) 134.18 143.33 P
0.74 (arbage collection.\051 Such solutions may be used as a long-term strate) 165.6 143.33 P
0.74 (gy) 444.74 143.33 P
0.74 (, or might be used to) 454.09 143.33 P
-0.24 (help stage the introduction of a tighter v) 72 131.33 P
-0.24 (eri\336er speci\336cation, by allo) 230.41 131.33 P
-0.24 (wing old-style class \336les to run with ne) 338.87 131.33 P
-0.24 (w-style vir-) 493.86 131.33 P
72 99 540 119 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
72 107 204 107 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 0 612 792 C
0 9 Q
0 X
0 0 0 1 0 0 0 K
0.52 (1.  F) 72 93 P
0.52 (or the present discussion, it is unnecessary to distinguish between stack frame slots holding operand stack v) 89.16 93 P
0.52 (alues and stack) 484.47 93 P
0.48 (frame slots holding local v) 72 82 P
0.48 (ariables: we think of them as tw) 169.7 82 P
0.48 (o separate sets of local v) 287.48 82 P
0.48 (ariables, one being addressed from the stack) 377.9 82 P
(frame base, the other being addressed from the top of stack pointer) 72 71 T
(.) 311.95 71 T
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "4" 4
%%Page: "5" 5
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 8 Q
0 X
0 0 0 1 0 0 0 K
(5) 304 34.17 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 10 Q
0.47 (tual machines. These solutions come in tw) 72 713.33 P
0.47 (o \337a) 244.4 713.33 P
0.47 (v) 262.17 713.33 P
0.47 (ors. One approach eliminates con\337icts caused by jsr subroutines by) 266.96 713.33 P
-0.06 (duplicating the subroutines. That is, if local v) 72 701.33 P
-0.06 (ariable) 252.74 701.33 P
2 F
-0.06 (v) 282.39 701.33 P
0 F
-0.06 (holds an inte) 289.27 701.33 P
-0.06 (ger at one) 340.12 701.33 P
3 F
-0.14 (jsr) 381.88 701.33 P
0 F
-0.06 ( to a jsr subroutine, and a reference) 399.88 701.33 P
0.05 (at another) 72 689.33 P
3 F
0.11 (jsr) 114.3 689.33 P
0 F
0.05 ( to the same subroutine, then the con\337ict for) 132.3 689.33 P
2 F
0.05 (v) 311.57 689.33 P
0 F
0.05 (within the jsr subroutine can be eliminated by duplicat-) 318.55 689.33 P
0.54 (ing the subroutine, and retar) 72 677.33 P
0.54 (geting one of the) 186.44 677.33 P
3 F
1.28 (jsr) 258.57 677.33 P
0 F
0.54 ( instructions to the ne) 276.57 677.33 P
0.54 (w cop) 364.57 677.33 P
0.54 (y of the subroutine. By e) 389.17 677.33 P
0.54 (xtension, all) 490.58 677.33 P
3 F
-0.15 (jsr) 72 665.33 P
0 F
-0.06 (\325) 90 665.33 P
-0.06 (s at which) 92.78 665.33 P
2 F
-0.06 (v) 135.65 665.33 P
0 F
-0.06 (holds a reference w) 142.53 665.33 P
-0.06 (ould go to one cop) 220.26 665.33 P
-0.06 (y) 294.36 665.33 P
-0.06 (, and all) 298.71 665.33 P
3 F
-0.15 (jsr) 332.97 665.33 P
0 F
-0.06 (\325) 350.97 665.33 P
-0.06 (s at which) 353.75 665.33 P
2 F
-0.06 (v) 396.61 665.33 P
0 F
-0.06 (holds a non-reference w) 403.49 665.33 P
-0.06 (ould go to) 499.56 665.33 P
(the other cop) 72 653.33 T
(y) 124.11 653.33 T
(.) 128.46 653.33 T
0.1 (W) 72 635.33 P
0.1 (e do not f) 80.64 635.33 P
0.1 (a) 118.9 635.33 P
0.1 (v) 123.14 635.33 P
0.1 (or this approach, either; e) 127.94 635.33 P
0.1 (v) 230.03 635.33 P
0.1 (en in this simple case it increases code size. W) 234.88 635.33 P
0.1 (orse, when one considers tw) 421.65 635.33 P
0.1 (o) 535 635.33 P
-0.2 (local v) 72 623.33 P
-0.2 (ariables and four) 98.49 623.33 P
3 F
-0.48 (jsr) 167.59 623.33 P
0 F
-0.2 ( instructions to a single jsr subroutines, it is not hard to see that four copies of the subrou-) 185.59 623.33 P
(tine might be required, and so on e) 72 611.33 T
(xponentially) 210.72 611.33 T
(.) 260.07 611.33 T
-0.07 (Instead, the solution we ha) 72 593.33 P
-0.07 (v) 178.46 593.33 P
-0.07 (e implemented re) 183.31 593.33 P
-0.07 (writes con\337icting local v) 252.35 593.33 P
-0.07 (ariables instead of duplicating code. It could be) 351.06 593.33 P
1.57 (vie) 72 581.33 P
1.57 (wed as \322splitting\323 a v) 83.97 581.33 P
1.57 (ariable into reference-containing and non-reference-containing halv) 176.08 581.33 P
1.57 (es, which ef) 454.49 581.33 P
1.57 (fecti) 505.41 581.33 P
1.57 (v) 522.93 581.33 P
1.57 (ely) 527.78 581.33 P
0.14 (undoes some of the local v) 72 569.33 P
0.14 (ariable slot reuse the compiler w) 179.39 569.33 P
0.14 (as allo) 310.26 569.33 P
0.14 (wed by the e) 335.98 569.33 P
0.14 (xception to the Gosling principle. The) 387.08 569.33 P
(ne) 72 557.33 T
(xt section describes our solution in detail.) 81.29 557.33 T
1 14 Q
(6  Bytecode r) 72 526.67 T
(ewriting to split con\337icting v) 149.9 526.67 T
(ariables) 320.09 526.67 T
0 10 Q
0.3 (Our \336rst step w) 72 506.33 P
0.3 (as to re\336ne the lattice used in the abstract interpretation that computes stack maps to record not only) 134.73 506.33 P
(that a con\337ict occurs b) 72 494.33 T
(ut also the kind of con\337ict.) 162.34 494.33 T
-0.19 (W) 72 308.83 P
-0.19 (e need this more detailed information because we resolv) 80.64 308.83 P
-0.19 (e con\337icts between references and uninitialized v) 303.94 308.83 P
-0.19 (alues \050) 499.74 308.83 P
2 F
-0.19 (r) 525.93 308.83 P
-0.19 (ef-) 529.45 308.83 P
(uninit) 72 296.83 T
0 F
(con\337icts\051 dif) 97.84 296.83 T
(ferently from con\337icts between references and non-reference v) 148.42 296.83 T
(alues \050) 399.46 296.83 T
2 F
(r) 425.84 296.83 T
(ef-nonr) 429.36 296.83 T
(ef) 458.43 296.83 T
0 F
(con\337icts\051:) 468.15 296.83 T
3 F
( \245) 72 279.83 T
2 F
(r) 85.75 279.83 T
(ef-uninit) 89.26 279.83 T
0 F
( con\337icts are eliminated by prepending code to the start of the method to initialize the v) 123.15 279.83 T
(ariables to null.) 472.86 279.83 T
3 F
( \245) 72 262.83 T
2 F
(r) 85.75 262.83 T
(ef-nonr) 89.26 262.83 T
(ef) 118.33 262.83 T
0 F
( con\337icts are eliminated by splitting the v) 125.56 262.83 T
(ariable.) 291.14 262.83 T
3 F
( \245) 72 245.83 T
2 F
(top) 85.75 245.83 T
0 F
( con\337icts are resolv) 98.53 245.83 T
(ed by a combination of the abo) 176.41 245.83 T
(v) 300.14 245.83 T
(e tw) 304.98 245.83 T
(o actions.) 321.83 245.83 T
-0.03 (The stack map computation for a method) 72 227.83 P
2 F
-0.03 (m) 238.68 227.83 P
0 F
-0.03 (is augmented as follo) 248.37 227.83 P
-0.03 (ws. The abstract interpretation and con\337ict elimina-) 333.29 227.83 P
0.13 (tion is iterated until all con\337icts ha) 72 215.83 P
0.13 (v) 211.46 215.83 P
0.13 (e been eliminated. A v) 216.31 215.83 P
0.13 (ariable) 306.83 215.83 P
2 F
0.13 (var) 336.66 215.83 P
0.13 (sT) 349.89 215.83 P
0.13 (oInit) 358.42 215.83 P
0 F
0.13 (holds a set of reference-containing v) 379.94 215.83 P
0.13 (ari-) 526.12 215.83 P
0.09 (ables requiring initialization. It is initially empty) 72 203.83 P
0.09 (. The abstract interpretation considers the v) 266.03 203.83 P
0.09 (ariables in the set to hold) 439.31 203.83 P
0.05 (initialized reference v) 72 191.83 P
0.05 (alues at the start of the method. Each iteration initializes a v) 159.05 191.83 P
0.05 (ariable) 398.81 191.83 P
2 F
0.05 (var) 428.57 191.83 P
0.05 (sT) 441.8 191.83 P
0.05 (oSplit) 450.33 191.83 P
0 F
0.05 (to the empty set) 476.23 191.83 P
0.44 (of v) 72 179.83 P
0.44 (ariables. This set will hold v) 88.01 179.83 P
0.44 (ariables that were found to hold a ref-nonref con\337ict when the) 203.27 179.83 P
0.44 (y were used. Finally) 455.74 179.83 P
0.44 (,) 537.5 179.83 P
(each iteration initializes a \337ag) 72 167.83 T
2 F
(con\337ictOccurr) 194.48 167.83 T
(ed,) 252.43 167.83 T
0 F
(indicating whether a con\337ict occurred, to f) 266.87 167.83 T
(alse.) 437.01 167.83 T
0.18 (The stack map computation then proceeds as described pre) 72 149.83 P
0.18 (viously) 308.7 149.83 P
0.18 (, e) 337.5 149.83 P
0.18 (xcept in its handling of con\337ict v) 346.97 149.83 P
0.18 (alues. A use of) 480.03 149.83 P
0.26 (a v) 72 137.83 P
0.26 (ariable whose v) 83.95 137.83 P
0.26 (alue in the abstract interpretation is the ref-uninit con\337ict v) 146.98 137.83 P
0.26 (alue causes the v) 384.86 137.83 P
0.26 (ariable to be added to) 452.87 137.83 P
2 F
0.85 (var) 72 125.83 P
0.85 (sT) 85.23 125.83 P
0.85 (oInit) 93.76 125.83 P
0 F
0.85 (. A use of a v) 112.65 125.83 P
0.85 (ariable holding the ref-nonref con\337ict v) 169.95 125.83 P
0.85 (alue in the interpretation adds the v) 331.95 125.83 P
0.85 (ariable to) 477.87 125.83 P
2 F
0.85 (var) 519.55 125.83 P
0.85 (s-) 532.78 125.83 P
(T) 72 113.83 T
(oSplit) 76.64 113.83 T
0 F
(. Either kind of con\337ict use sets the) 99.98 113.83 T
2 F
(con\337ictOccurr) 243.58 113.83 T
(ed) 301.53 113.83 T
0 F
(\337ag to true.) 313.47 113.83 T
-0.16 (At the end of an iteration,) 72 95.83 P
2 F
-0.16 (var) 176.32 95.83 P
-0.16 (sT) 189.55 95.83 P
-0.16 (oSplit) 198.08 95.83 P
0 F
-0.16 (is check) 223.76 95.83 P
-0.16 (ed. If it is non-empty) 255.99 95.83 P
-0.16 (, then each v) 338.88 95.83 P
-0.16 (ariable in it is) 388.7 95.83 P
2 F
-0.16 (split.) 445.29 95.83 P
0 F
-0.16 (T) 467.36 95.83 P
-0.16 (o split local v) 472.67 95.83 P
-0.16 (ari-) 526.12 95.83 P
-0.09 (able) 72 83.83 P
2 F
-0.09 (n,) 91.07 83.83 P
0 F
-0.09 (we increase the number of local v) 100.99 83.83 P
-0.09 (ariables allocated in stack frames for method) 235.17 83.83 P
2 F
-0.09 (m) 416.46 83.83 P
0 F
-0.09 (by one; let) 426.09 83.83 P
2 F
-0.09 (nn) 470.55 83.83 P
0 F
-0.09 (be the number) 482.96 83.83 P
0.25 (of ne) 72 71.83 P
0.25 (wly allocated local v) 92.27 71.83 P
0.25 (ariable. W) 175.82 71.83 P
0.25 (e then e) 216.92 71.83 P
0.25 (xamine the bytecodes for the method) 248.37 71.83 P
2 F
0.25 (m,) 400.41 71.83 P
0 F
0.25 (modifying them so that instruc-) 412.88 71.83 P
72 63 540 720 C
0 0 0 1 0 0 0 K
72 323.5 540 491 C
0 0 0 1 0 0 0 K
0 10 Q
0 X
0 0 0 1 0 0 0 K
(ref-nonref) 266.75 424.75 T
(ref-uninit) 325.25 424.75 T
(ref) 313.5 383.81 T
(v) 280.3 383.81 T
(al) 285.05 383.81 T
(pc) 249.06 383.81 T
(uninit) 340.1 383.81 T
307.85 465.89 287.1 431.64 2 L
0.5 H
2 Z
N
345.75 422.5 351.6 391.89 2 L
N
307.98 465.76 342.75 433.14 2 L
N
307.1 346.64 253.6 380.39 2 L
N
307.1 346.39 286.35 380.64 2 L
N
307.1 346.39 318.35 380.89 2 L
N
307.23 346.51 350.6 379.14 2 L
N
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(top) 301.35 469.39 T
(bottom) 292.91 339.2 T
345.69 422.56 319.56 390.25 2 L
N
286.06 420.31 285.85 390.2 2 L
N
286.06 420.62 254.75 390.06 2 L
N
286.12 420.5 319.38 390.19 2 L
N
0 0 0 1 0 0 0 K
72 63 540 720 C
0 0 612 792 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "5" 5
%%Page: "6" 6
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 8 Q
0 X
0 0 0 1 0 0 0 K
(6) 304 34.17 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 10 Q
-0.15 (tions that use the original v) 72 713.33 P
-0.15 (ariable) 179.62 713.33 P
2 F
-0.15 (n) 209.18 713.33 P
0 F
-0.15 (to hold references are unchanged, b) 216.53 713.33 P
-0.15 (ut non-reference uses are changed to use v) 357.75 713.33 P
-0.15 (ari-) 526.12 713.33 P
1.72 (able) 72 701.33 P
2 F
1.72 ( nn) 88.66 701.33 P
0 F
1.72 (instead \050the other choice, where reference uses of) 107.09 701.33 P
2 F
1.72 (n) 321.02 701.33 P
0 F
1.72 (are changed to use) 330.24 701.33 P
2 F
1.72 (nn) 413.74 701.33 P
0 F
1.72 (and non-reference uses are) 427.96 701.33 P
0.33 (unchanged, is equi) 72 689.33 P
0.33 (v) 147.11 689.33 P
0.33 (alent\051. It is a happ) 151.86 689.33 P
0.33 (y property of the Ja) 225 689.33 P
0.33 (v) 303.86 689.33 P
0.33 (a bytecode instruction set that instructions ha) 308.61 689.33 P
0.33 (v) 490.91 689.33 P
0.33 (e suf) 495.76 689.33 P
0.33 (\336cient) 515 689.33 P
0.24 (type information encoded in their opcodes to determine locally whether a gi) 72 677.33 P
0.24 (v) 377.93 677.33 P
0.24 (en instruction uses a local v) 382.78 677.33 P
0.24 (ariable as a) 494.54 677.33 P
-0.03 (reference, making the re) 72 665.33 P
-0.03 (writing f) 168.84 665.33 P
-0.03 (airly simple. There is one e) 203.43 665.33 P
-0.03 (xception to this property: the) 312.01 665.33 P
3 F
-0.07 (astore) 429.92 665.33 P
0 F
-0.03 ( instruction is usu-) 465.92 665.33 P
-0.01 (ally used to pop a reference \050and) 72 653.33 P
2 F
-0.01 (addr) 204.96 653.33 P
-0.01 (ess,) 223.48 653.33 P
0 F
-0.01 (hence the pre\336x letter) 240.7 653.33 P
2 F
-0.01 (a) 330.09 653.33 P
0 F
-0.01 (\051 from the operand stack and store it in a local v) 335.09 653.33 P
-0.01 (ari-) 526.12 653.33 P
2.04 (able, b) 72 641.33 P
2.04 (ut it may also be used to do the same with return addresses pushed on the stack by) 100.5 641.33 P
3 F
4.9 (jsr) 468.29 641.33 P
0 F
2.04 ( instructions.) 486.29 641.33 P
-0.21 (F) 72 629.33 P
-0.21 (ortunately) 77.41 629.33 P
-0.21 (, the abstract interpretation already maintains suf) 117.31 629.33 P
-0.21 (\336cient state to determine whether the operand stack top at) 311.06 629.33 P
(the point of the) 72 617.33 T
3 F
(astore) 135.33 617.33 T
0 F
( is such a return address, so this complication is easily circumv) 171.33 617.33 T
(ented.) 422.82 617.33 T
-0.09 (There is one more complication. Re) 72 599.33 P
-0.09 (writing instructions to reference dif) 214.61 599.33 P
-0.09 (ferent local v) 355.65 599.33 P
-0.09 (ariables may change the width of) 407.98 599.33 P
0.79 (those instructions. The Ja) 72 587.33 P
0.79 (v) 175.83 587.33 P
0.79 (a bytecode instruction set optimizes some important cases; operations that read or write) 180.58 587.33 P
-0.25 (local v) 72 575.33 P
-0.25 (ariables ha) 98.44 575.33 P
-0.25 (v) 141.03 575.33 P
-0.25 (e tw) 145.88 575.33 P
-0.25 (o forms, one that tak) 162.47 575.33 P
-0.25 (es a general v) 243.87 575.33 P
-0.25 (ariable number as an ar) 297.57 575.33 P
-0.25 (gument, and another) 389.69 575.33 P
-0.25 (, used for the \336rst) 470.73 575.33 P
0.04 (fe) 72 563.33 P
0.04 (w \050more precisely) 79.52 563.33 P
0.04 (, four\051 local v) 151.15 563.33 P
0.04 (ariables, that encodes the v) 205.44 563.33 P
0.04 (ariable being referenced in the opcode of the instruction.) 313.37 563.33 P
0.94 (Empirically) 72 551.33 P
0.94 (, the \336rst fe) 118.57 551.33 P
0.94 (w v) 166.68 551.33 P
0.94 (ariables are hea) 182.08 551.33 P
0.94 (vily used, so this optimization compacts the bytecodes and speeds their) 245.94 551.33 P
-0.16 (e) 72 539.33 P
-0.16 (x) 76.29 539.33 P
-0.16 (ecution. Ho) 81.14 539.33 P
-0.16 (we) 127.39 539.33 P
-0.16 (v) 138.8 539.33 P
-0.16 (er) 143.65 539.33 P
-0.16 (, when we change a one-byte) 151.02 539.33 P
3 F
-0.39 (astore_2) 268.61 539.33 P
0 F
-0.16 ( instruction to use local v) 316.61 539.33 P
-0.16 (ariable 10 instead of local v) 416.37 539.33 P
-0.16 (ari-) 526.12 539.33 P
0 (able 2, the ne) 72 527.33 P
0 (w instruction occupies tw) 125.08 527.33 P
0 (o bytes. Such changes require relocation of all follo) 227.49 527.33 P
0 (wing instructions, recalcu-) 433.62 527.33 P
2.55 (lation of relati) 72 515.33 P
2.55 (v) 133.51 515.33 P
2.55 (e jumps that cross the modi\336ed instruction, and adjustment of instructions, such as) 138.36 515.33 P
3 F
6.12 (switch) 504 515.33 P
0 F
0.09 (instructions, with internal alignment constraints. W) 72 503.33 P
0.09 (e will not describe this relocation process in detail, e) 276.94 503.33 P
0.09 (xcept to alert) 487.6 503.33 P
0.93 (readers to the potential complications. Our implementation includes a general bytecode relocator that solv) 72 491.33 P
0.93 (es these) 507.7 491.33 P
(problems.) 72 479.33 T
0.37 (If an) 72 461.33 P
0.37 (y uses of con\337ict v) 90.82 461.33 P
0.37 (ariables are detected, at least some are repaired by this v) 167.62 461.33 P
0.37 (ariable-splitting process or by addi-) 396.31 461.33 P
0.24 (tion to the) 72 449.33 P
2 F
0.24 (var) 115.78 449.33 P
0.24 (sT) 129.01 449.33 P
0.24 (oInit) 137.54 449.33 P
0 F
0.24 (set. The ne) 159.16 449.33 P
0.24 (xt iteration of the loop may still \336nd some con\337icts in the re) 203.09 449.33 P
0.24 (written code \050perhaps a) 445.7 449.33 P
0.59 (v) 72 437.33 P
0.59 (ariable has both ref-uninit and ref-v) 76.75 437.33 P
0.59 (alue con\337icts\051, causing another iteration, or it will detect no con\337icts and suc-) 221.89 437.33 P
(cessfully generate the stack maps.) 72 425.33 T
0.55 (The re) 72 407.33 P
0.55 (writing is not guaranteed to succeed. Allocating ne) 98.12 407.33 P
0.55 (w local v) 304.98 407.33 P
0.55 (ariables could e) 342.48 407.33 P
0.55 (xceed the limit on the number of) 406.19 407.33 P
0.14 (locals in a method, which is imposed by the bytecode instruction set. W) 72 395.33 P
0.14 (idening instructions could concei) 360.51 395.33 P
0.14 (v) 493.18 395.33 P
0.14 (ably cause) 497.93 395.33 P
-0.18 (a method to e) 72 383.33 P
-0.18 (xceed the maximum method size \050some Ja) 125.47 383.33 P
-0.18 (v) 293.62 383.33 P
-0.18 (a virtual machines limit method sizes to be less than or equal) 298.37 383.33 P
0.59 (to 65535 bytes, [5] pp. 136\051. In such cases, the virtual machine w) 72 371.33 P
0.59 (ould ha) 340.05 371.33 P
0.59 (v) 370.16 371.33 P
0.59 (e to someho) 375.01 371.33 P
0.59 (w indicate an error akin to a) 424.27 371.33 P
(v) 72 359.33 T
(eri\336cation error) 76.85 359.33 T
(. In practice, ho) 138.78 359.33 T
(we) 201.01 359.33 T
(v) 212.42 359.33 T
(er) 217.27 359.33 T
(, we e) 224.64 359.33 T
(xpect programs that violate these limits to be e) 248.09 359.33 T
(xtremely rare.) 434.59 359.33 T
-0.03 (In practice, the performance of the bytecode re) 72 341.33 P
-0.03 (writing is not a crucial issue since with the most commonly used com-) 258.7 341.33 P
0.31 (piler) 72 329.33 P
0.31 (, ja) 89.93 329.33 P
0.31 (v) 102.26 329.33 P
0.31 (ac, v) 107.01 329.33 P
0.31 (ery fe) 126.04 329.33 P
0.31 (w methods need re) 149.14 329.33 P
0.31 (writing. F) 225.07 329.33 P
0.31 (or e) 264.67 329.33 P
0.31 (xample, on a particular set of Ja) 280.1 329.33 P
0.31 (v) 409.2 329.33 P
0.31 (a programs, comprising se) 413.95 329.33 P
0.31 (v) 520.16 329.33 P
0.31 (eral) 525.01 329.33 P
1.4 (thousand lines of code, only three methods were re) 72 317.33 P
1.4 (written, as demonstrated by this \322v) 286.5 317.33 P
1.4 (erbose\323 run of our virtual) 432.77 317.33 P
(machine:) 72 305.33 T
3 8 Q
(Rewrote ref-uninit conflict in method sun/io/CharToByteConverter.convertAll \050115 bytes\051.) 108 289.67 T
(Rewrote ref-uninit conflict in method sun/io/ByteToCharConverter.convertAll \050115 bytes\051.) 108 279.67 T
(Rewrote ref-uninit conflict in method sun/tools/java/Parser.parseClassBody \050271 bytes\051.) 108 269.67 T
0 10 Q
0.77 (The abo) 72 252.33 P
0.77 (v) 105.11 252.33 P
0.77 (e three methods are too lar) 109.96 252.33 P
0.77 (ge to include here, b) 220.01 252.33 P
0.77 (ut we ha) 304.28 252.33 P
0.77 (v) 339.5 252.33 P
0.77 (e hand-written a short method with a ref-nonref) 344.35 252.33 P
(con\337ict and sho) 72 240.33 T
(w its bytecodes before and after re) 135.08 240.33 T
(writing:) 272.56 240.33 T
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "6" 6
%%Page: "7" 7
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 8 Q
0 X
0 0 0 1 0 0 0 K
(7) 304 34.17 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 14 Q
(7  Conclusions) 72 510.67 T
0 10 Q
0.34 (In summary) 72 490.33 P
0.34 (, we ha) 119.74 490.33 P
0.34 (v) 148.8 490.33 P
0.34 (e seen that e) 153.65 490.33 P
0.34 (xact g) 203.66 490.33 P
0.34 (arbage collection requires the computation of stack maps, data structures that) 228.1 490.33 P
0.73 (determine which slots in stack frames contain references and which do not. The Ja) 72 478.33 P
0.73 (v) 410.6 478.33 P
0.73 (a virtual machine speci\336cation) 415.35 478.33 P
0.37 (almost uni) 72 466.33 P
0.37 (v) 114.07 466.33 P
0.37 (ersally enforces a property we ha) 118.92 466.33 P
0.37 (v) 253.01 466.33 P
0.37 (e called the Gosling property) 257.86 466.33 P
0.37 (, which has the desirable consequence of) 374.78 466.33 P
0.62 (pre) 72 454.33 P
0.62 (v) 84.52 454.33 P
0.62 (enting stack frame layouts from ha) 89.37 454.33 P
0.62 (ving control-path dependencies, allo) 231.43 454.33 P
0.62 (wing simpler stack map data structures.) 378.57 454.33 P
-0.12 (Ho) 72 442.33 P
-0.12 (we) 83.97 442.33 P
-0.12 (v) 95.38 442.33 P
-0.12 (er) 100.23 442.33 P
-0.12 (, an e) 107.6 442.33 P
-0.12 (xception to the Gosling property w) 128.6 442.33 P
-0.12 (as made for jsr subroutines, which allo) 267.62 442.33 P
-0.12 (ws control-path dependencies) 421.37 442.33 P
0.76 (to creep back in. The \336rst contrib) 72 430.33 P
0.76 (ution of this paper is simply to point out that this problem e) 209.41 430.33 P
0.76 (xists, since we don\325) 456.23 430.33 P
0.76 (t) 537.22 430.33 P
(belie) 72 418.33 T
(v) 91.19 418.33 T
(e its e) 96.04 418.33 T
(xistence is widely appreciated.) 119.22 418.33 T
0.26 (The second contrib) 72 400.33 P
0.26 (ution of this paper is to identify the space of possible solutions. The purest approach w) 148.98 400.33 P
0.26 (ould be to) 499.47 400.33 P
1.42 (disallo) 72 388.33 P
1.42 (w an) 98.42 388.33 P
1.42 (y e) 118.85 388.33 P
1.42 (xceptions to the Gosling property) 132.05 388.33 P
1.42 (. This w) 270.95 388.33 P
1.42 (ould simplify e) 306.19 388.33 P
1.42 (xact g) 369.43 388.33 P
1.42 (arbage collection and, furthermore,) 394.96 388.33 P
-0.24 (remo) 72 376.33 P
-0.24 (v) 92.4 376.33 P
-0.24 (e a source of comple) 97.25 376.33 P
-0.24 (xity from the Ja) 178.9 376.33 P
-0.24 (v) 241.04 376.33 P
-0.24 (a bytecode v) 245.79 376.33 P
-0.24 (eri\336er) 295.71 376.33 P
-0.24 (. A simpler v) 319.04 376.33 P
-0.24 (eri\336er decreases the probability of security) 370.39 376.33 P
0.71 (holes, and perhaps e) 72 364.33 P
0.71 (v) 154.97 364.33 P
0.71 (en mak) 159.82 364.33 P
0.71 (es formal v) 189.59 364.33 P
0.71 (eri\336cation of their absence tractable. But if practical problems pre) 235.85 364.33 P
0.71 (v) 505.27 364.33 P
0.71 (ent this) 510.12 364.33 P
0.41 (approach, then we ha) 72 352.33 P
0.41 (v) 157.99 352.33 P
0.41 (e described a technique that re) 162.84 352.33 P
0.41 (writes methods that violate the Gosling property to a form that) 285.96 352.33 P
0.32 (respects it. This technique may be used as a permanent solution, or) 72 340.33 P
0.32 (, if the purer solution is adopted as the long term) 342.62 340.33 P
0.65 (strate) 72 328.33 P
0.65 (gy) 93.51 328.33 P
0.65 (, it may be used as a bridge to allo) 102.86 328.33 P
0.65 (w older class \336les to e) 245.08 328.33 P
0.65 (x) 336.76 328.33 P
0.65 (ecute on ne) 341.61 328.33 P
0.65 (wer virtual machines that enforce the) 388.2 328.33 P
(Gosling property uni) 72 316.33 T
(v) 155.08 316.33 T
(ersally) 159.93 316.33 T
(.) 185.94 316.33 T
1 F
1.19 (Ackno) 72 280.33 P
1.19 (wledgments) 99.68 280.33 P
0 F
1.19 (. The greatly simplifying realization that) 150.23 280.33 P
2 F
1.19 (r) 321.51 280.33 P
1.19 (ef) 325.03 280.33 P
0 F
1.19 ( and) 332.25 280.33 P
2 F
1.19 (nonr) 354.07 280.33 P
1.19 (ef) 372.59 280.33 P
0 F
1.19 ( uses of v) 379.81 280.33 P
1.19 (ariables can be distinguished) 421.17 280.33 P
0.37 (based only on the opcode of the using instruction, came about in a discussion with Boris Be) 72 268.33 P
0.37 (ylin, Ross Knippel, and) 444.71 268.33 P
-0 (Bob W) 72 256.33 P
-0 (ilson. John Rose e) 100.21 256.33 P
-0 (xplained to us the beha) 172.82 256.33 P
-0 (vior of the ja) 264.81 256.33 P
-0 (v) 315.98 256.33 P
-0 (ac compiler when translating the) 320.73 256.33 P
3 F
-0.01 (try-finally) 453.73 256.33 P
0 F
-0 ( con-) 519.73 256.33 P
(struct.) 72 244.33 T
1 14 Q
(Refer) 72 213.67 T
(ences) 105.17 213.67 T
0 9 Q
(1.) 72 194 T
2.06 (Bartlett, Joel F.) 90 194 P
2 F
2.06 (Mostly-Copying Collection Picks Up Generations and C++.) 153.94 194 P
0 F
2.06 ( Technical Report TN-12, DEC Western) 384.21 194 P
(Research Laboratory, October 1989.) 89.28 183 T
(2.) 72 169 T
-0.21 (Boehm, Hans Juergen and Weiser, Mark. Garbage Collection in an Uncooperative Environment.) 90 169 P
2 F
-0.21 (Software\321Practice & Expe-) 437.43 169 P
(rience,) 89.28 158 T
0 F
(18\0509\051, p. 807-820, September 1988.) 116.27 158 T
(3.) 72 144 T
0.04 (Gosling, James. Java Intermediate Bytecodes. In) 90 144 P
2 F
0.04 (Proceedings of ACM SIGPLAN Workshop on Intermediate Representations) 267.48 144 P
(\050IR\32595\051) 89.28 133 T
0 F
(, p. 111-118, January 1995. Published as) 115.77 133 T
2 F
(ACM SIGPLAN Notices) 264.01 133 T
0 F
( 30\0503\051, March 1995.) 350.51 133 T
(4.) 72 119 T
(Gosling, James, Joy, Bill, and Steele, Guy.) 90 119 T
2 F
(The Java Language Specification) 246.25 119 T
0 F
(, The Java Series, Addison-Wesley, 1996.) 366.49 119 T
(5.) 72 105 T
(Lindholm, Tim and Yellin, Frank.) 90 105 T
2 F
(The Java Virtual Machine Specification) 215 105 T
0 F
(. The Java Series, Addison-Wesley, 1996.) 358.49 105 T
0 8 Q
(Sun, Sun Microsystems, and Ja) 72 79.67 T
(v) 171.84 79.67 T
(a are trademarks or re) 175.64 79.67 T
(gistered trademarks of Sun Microsystems, Inc. in the United States and other countries.) 245.26 79.67 T
72 63 540 720 C
0 0 0 1 0 0 0 K
72 538 540 710 C
0 0 0 1 0 0 0 K
1 8 Q
0 X
0 0 0 1 0 0 0 K
(Method before rewriting) 113.5 701.17 T
3 F
(Method void refInt1\050\051) 113.5 691.17 T
(   0 iconst_3) 113.5 681.17 T
(   1 istore_0) 113.5 671.17 T
(   2 jsr 15) 113.5 661.17 T
(   5 iload_0) 113.5 651.17 T
(   6 pop) 113.5 641.17 T
(   7 aconst_null) 113.5 631.17 T
(   8 astore_0) 113.5 621.17 T
(   9 jsr 15) 113.5 611.17 T
(  12 aload_0) 113.5 601.17 T
(  13 pop) 113.5 591.17 T
(  14 return) 113.5 581.17 T
(  15 astore_1) 113.5 571.17 T
(  16 ret 1) 113.5 561.17 T
1 F
(Method after rewriting) 351.5 701.17 T
3 F
(Method void refInt1\050\051) 351.5 691.17 T
(0 iconst_3) 365.9 681.17 T
(   1) 351.5 671.17 T
5 F
(istore_2) 375.5 671.17 T
3 F
(   2 jsr 15) 351.5 661.17 T
(   5) 351.5 651.17 T
5 F
(iload_2) 375.5 651.17 T
3 F
(   6 pop) 351.5 641.17 T
(   7 aconst_null) 351.5 631.17 T
(   8 astore_0) 351.5 621.17 T
(   9 jsr 15) 351.5 611.17 T
(  12 aload_0) 351.5 601.17 T
(  13 pop) 351.5 591.17 T
(  14 return) 351.5 581.17 T
(  15 astore_1) 351.5 571.17 T
(  16 ret 1) 351.5 561.17 T
0 0 0 1 0 0 0 K
72 63 540 720 C
0 0 612 792 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "7" 7
%%Trailer
%%BoundingBox: 0 0 612 792
%%PageOrder: Ascend
%%Pages: 7
%%DocumentFonts: Times-Roman
%%+ Times-Bold
%%+ Times-Italic
%%+ Courier
%%+ Courier-Oblique
%%+ Courier-Bold
%%EOF
