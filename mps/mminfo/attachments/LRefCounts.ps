%!PS-Adobe-3.0%%Title: (LRefCounts.wrd)%%Creator: (Microsoft Word: LaserWriter 8 8.2)%%CreationDate: (4:46 PM Tuesday, December 6, 1994)%%For: (Henry Baker)%%Pages: 6%%DocumentFonts: Times-Roman Symbol Times-Italic Times-Bold Helvetica-Bold Helvetica Courier Courier-Oblique%%DocumentNeededFonts: Times-Roman Symbol Times-Italic Times-Bold Helvetica-Bold Helvetica Courier Courier-Oblique%%DocumentSuppliedFonts:%%DocumentData: Clean7Bit%%PageOrder: Ascend%%Orientation: Portrait%%DocumentMedia: Default 612 792 0 () ()%ADO_ImageableArea: 31 31 583 761%%EndCommentsuserdict begin/dscInfo 5 dict dup begin/Title(LRefCounts.wrd)def/Creator(Microsoft Word: LaserWriter 8 8.2)def/CreationDate(4:46 PM Tuesday, December 6, 1994)def/For(Henry Baker)def/Pages 1 defend def endsave /version23-manualfeedpatch where { pop false } { true }ifelse % we don't do an explicit 'get' since product and version MAY % be in systemdict or statusdict - this technique gets the lookup % without failurestatusdict begin  product (LaserWriter) eq        % true if LaserWriter  version cvr 23.0 eq             % true if version 23endand  % only install this patch if both are trueand  % true only if patch is not installed and is for this printer     % save object and boolean on stackdup { exch restore }if% either true OR saveobject falsedup{  /version23-manualfeedpatch true def  /oldversion23-showpage /showpage load def  /showpage       % this showpage will wait extra time if manualfeed is true  {%     statusdict /manualfeed known     {% manualfeed known in statusdict        statusdict /manualfeed get        {% if true then we loop for 5 seconds           usertime 5000 add       % target usertime           { % loop             dup usertime sub 0 lt             { exit }if           }loop           pop             % pop the usertime off the stac        }if     }if     oldversion23-showpage  }bind def}ifnot{ restore }if/md 153 dict def md begin/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if%%BeginFile: adobe_psp_basic%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved./bd{bind def}bind def/xdf{exch def}bd/xs{exch store}bd/ld{load def}bd/Z{0 def}bd/T/true/F/false/:L/lineto/lw/setlinewidth/:M/moveto/rl/rlineto/rm/rmoveto/:C/curveto/:T/translate/:K/closepath/:mf/makefont/gS/gsave/gR/grestore/np/newpath14{ld}repeat/$m matrix def/av 81 def/por true def/normland false def/psb-nosave{}bd/pse-nosave{}bd/us Z/psb{/us save store}bd/pse{us restore}bd/level2/languagelevel where{pop languagelevel 2 ge}{false}ifelsedef/featurecleanup{stoppedcleartomarkcountdictstack exch sub dup 0 gt{{end}repeat}{pop}ifelse}bd/noload Z/startnoload{{/noload save store}if}bd/endnoload{{noload restore}if}bdlevel2 startnoload/setjob{statusdict/jobname 3 -1 roll put}bd/setcopies{userdict/#copies 3 -1 roll put}bdlevel2 endnoload level2 not startnoload/setjob{1 dict begin/JobName xdf currentdict end setuserparams}bd/setcopies{1 dict begin/NumCopies xdf currentdict end setpagedevice}bdlevel2 not endnoload/pm Z/mT Z/sD Z/realshowpage Z/initializepage{/pm save store mT concat}bd/endp{pm restore showpage}def/$c/DeviceRGB def/rectclip where{pop/rC/rectclip ld}{/rC{np 4 2 roll:M1 index 0 rl0 exch rlneg 0 rl:Kclip np}bd}ifelse/rectfill where{pop/rF/rectfill ld}{/rF{gSnp4 2 roll:M1 index 0 rl0 exch rlneg 0 rlfillgR}bd}ifelse/rectstroke where{pop/rS/rectstroke ld}{/rS{gSnp4 2 roll:M1 index 0 rl0 exch rlneg 0 rl:KstrokegR}bd}ifelse%%EndFile%%BeginFile: adobe_psp_colorspace_level1%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved./G/setgray ld/:F/setrgbcolor ld%%EndFile%%BeginFile: adobe_psp_uniform_graphics%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved./@a{np :M 0 rl :L 0 exch rl 0 rl :L fill}bd/@b{np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill}bd/arct where{pop}{/arct{arcto pop pop pop pop}bd}ifelse/x1 Z/x2 Z/y1 Z/y2 Z/rad Z/@q{/rad xs/y2 xs/x2 xs/y1 xs/x1 xsnpx2 x1 add 2 div y1 :Mx2 y1 x2 y2 rad arctx2 y2 x1 y2 rad arctx1 y2 x1 y1 rad arctx1 y1 x2 y1 rad arctfill}bd/@s{/rad xs/y2 xs/x2 xs/y1 xs/x1 xsnpx2 x1 add 2 div y1 :Mx2 y1 x2 y2 rad arctx2 y2 x1 y2 rad arctx1 y2 x1 y1 rad arctx1 y1 x2 y1 rad arct:Kstroke}bd/@i{np 0 360 arc fill}bd/@j{gSnp:Tscale0 0 .5 0 360 arcfillgR}bd/@e{np0 360 arc:Kstroke}bd/@f{np$m currentmatrixpop:Tscale0 0 .5 0 360 arc:K$m setmatrixstroke}bd/@k{gSnp:T0 0 :M0 0 5 2 rollarc fillgR}bd/@l{gSnp:T0 0 :Mscale0 0 .5 5 -2 roll arcfillgR}bd/@m{nparcstroke}bd/@n{np$m currentmatrixpop:Tscale0 0 .5 5 -2 roll arc$m setmatrixstroke}bd%%EndFile%%BeginFile: adobe_psp_basic_text%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved./S/show ld/A{0.0 exch ashow}bd/R{0.0 exch 32 exch widthshow}bd/W{0.0 3 1 roll widthshow}bd/J{0.0 32 4 2 roll 0.0 exch awidthshow}bd/V{0.0 4 1 roll 0.0 exch awidthshow}bd/fcflg true def/fc{fcflg{vmstatus exch sub 50000 lt{(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store}if pop}if}bd/$f[1 0 0 -1 0 0]def/:ff{$f :mf}bd/MacEncoding StandardEncoding 256 array copy defMacEncoding 39/quotesingle putMacEncoding 96/grave put/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caronMacEncoding 128 128 getinterval astore poplevel2 startnoload/copyfontdict{findfont dup length dictbegin{1 index/FID ne{def}{pop pop}ifelse}forall}bdlevel2 endnoload level2 not startnoload/copyfontdict{findfont dup length dictcopybegin}bdlevel2 not endnoloadmd/fontname known not{/fontname/customfont def}if/Encoding Z/:mre{copyfontdict/Encoding MacEncoding deffontname currentdictenddefinefont :ff def}bd/:bsr{copyfontdict/Encoding Encoding 256 array copy defEncoding dup}bd/pd{put dup}bd/:esr{pop popfontname currentdictenddefinefont :ff def}bd/scf{scalefont def}bd/scf-non{$m scale :mf setfont}bd/ps Z/fz{/ps xs}bd/sf/setfont ld/cF/currentfont ld/mbf{/makeblendedfont where{popmakeblendedfont/ABlend exch definefont}{pop}ifelsedef}def%%EndFile/currentpacking where {pop sc_oldpacking setpacking}if end%%EndProlog%%BeginSetupmd begincountdictstack[{%%BeginFeature: *ManualFeed Falsestatusdict /manualfeed false put%%EndFeature}featurecleanupcountdictstack[{%%BeginFeature: *InputSlot Cassette%%EndFeature}featurecleanupcountdictstack[{%%BeginFeature: *PageRegion LetterSmalllettersmall%%EndFeature}featurecleanup(Henry Baker)setjob/mT[1 0 0 -1 31 761]def/sD 16 dict def300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse%%IncludeFont: Times-Roman%%IncludeFont: Symbol%%IncludeFont: Times-Italic%%IncludeFont: Times-Bold%%IncludeFont: Helvetica-Bold%%IncludeFont: Helvetica%%IncludeFont: Courier%%IncludeFont: Courier-Oblique/f0_1/Times-Roman:mre/f0_12 f0_1 12 scf/f0_10 f0_1 10 scf/f0_9 f0_1 9 scf/f1_1/Symbol:bsr240/apple pd:esr/f1_10 f1_1 10 scf/f2_1/Times-Italic:mre/f2_12 f2_1 12 scf/f2_10 f2_1 10 scf/f3_1/Times-Bold:mre/f3_12 f3_1 12 scf/f4_1/Helvetica-Bold:mre/f4_14 f4_1 14 scf/f5_1/Helvetica:mre/f5_10 f5_1 10 scf/f5_9 f5_1 9 scf/f6_1/Courier:mre/f6_10 f6_1 10 scf/f6_9 f6_1 9 scf/f7_1/Courier-Oblique:mre/f7_9 f7_1 9 scf/Courier findfont[10 0 0 -10 0 0]:mf setfont%%EndSetup%%Page: 1 1%%BeginPageSetupinitializepage(Henry Baker; page: 1 of 6)setjob%%EndPageSetupgS 0 0 552 730 rC41 18 :Mf0_12 sf.143 .014(ACM )Jf2_12 sf.2 .02(Sigplan Notices)Jf0_12 sf( )Sf3_12 sf.04(29)Af0_12 sf.137 .014(, 9 \(September 1994\), 38-43.)J41 723 :Mf0_10 sf.334 .033(Copyright \251 1993 by Nimble Computer Corporation)J287 723 :M(1)S482 723 :M.074(12/6/94)A75 52 :Mf4_14 sf2.604 .26(Minimizing Reference Count Updating with Deferred and)J100 66 :M2.421 .242(Anchored Pointers for Functional Data Structures)J244 88 :Mf5_10 sf-.146(Henry G. Baker)A41 108 :Mf5_9 sf.06 .006(Nimble Computer Corporation, 16231 Meadow Ridge Way, Encino, CA  91436\312\312\(818\) 501-4956\312\312\(818\) 986-1360 \(FAX\))J57 123 :Mf0_10 sf-.017(This material is based upon work supported by the National Science Foundation under Grant No. III-9261682.)A39 130 -1 1 515 129 1 39 129 @a41 143 :Mf2_10 sf-.01(Reference counting)Af0_10 sf-.01( can be an attractive form of dynamic storage management.  It recovers storage promptly and \(with)A41 154 :M.111 .011(a garbage stack instead of a free list\) it can be made "real-time"\321i.e., all accesses can be performed in constant time.)J41 165 :M.918 .092(Its major drawbacks are its inability to reclaim cycles, its count storage, and its count update overhead.  Update)J41 176 :M-.071(overhead is especially irritating for functional \(read-only\) data where updates may dirty pristine cache lines and pages.)A41 191 :M.395 .04(We show how reference count updating can be largely eliminated for functional data structures by using the "linear)J41 202 :M.224 .022(style" of programming that is inspired by Girard's linear logic, and by distinguishing normal pointers from )Jf2_10 sf.076(anchored)A41 213 :M.118(pointers)Af0_10 sf.385 .038(, which indicate not only the object itself, but also the depth of the stack frame that anchors the object.  An)J41 224 :Mf2_10 sf.096(anchor)Af0_10 sf.302 .03( for a pointer is essentially an enclosing data structure that is temporarily locked from being collected for the)J41 235 :M-.09(duration of the anchored pointer's existence by a deferred reference count.  An )Af2_10 sf-.098(anchored pointer)Af0_10 sf-.092( thus implies a reference)A41 246 :M-.065(count increment that has been deferred until it is either cancelled or performed.)A41 261 :M-.024(Anchored pointers are generalizations of "borrowed" pointers and "phantom" pointers.  Anchored pointers can provide)A41 272 :M-.005(a solution to the "derived pointer problem" in garbage collection.)A39 279 -1 1 515 278 1 39 278 @a41 293 :Mf5_10 sf-.24(INTRODUCTION)A41 308 :Mf0_10 sf.265 .026(Reference counting [Collins60] can be an attractive form of dynamic storage management for functional \(read-only\))J41 319 :M.978 .098(data structures because the cycles that cause trouble for reference counting do not exist in these data structures.)J41 330 :M.641 .064(Unfortunately, reference counting extracts a penalty not only when creating or destroying data structures, but also)J41 341 :M.426 .043(when simply traversing them.  For example, when the length of a list is computed, the counts of the cells along the)J41 352 :M.556 .056(list are each incremented and then decremented.  Although this traversal results in no net change to any count, the)J41 363 :M.707 .071(work to perform 2n count updates for a list of length n is substantial.  In a modern RISC architecture with a data)J41 374 :M.283 .028(cache, these count references may cause lines to be brought into the cache that would not otherwise be touched, and)J41 385 :M.033 .003(worse still, these lines are also "dirtied", requiring that they be rewritten\321even though the data eventually written out)J41 396 :M.149 .015(is identical to that brought in!  In a shared-memory multiprocessor system, updates to counts require synchronization)J41 407 :M.316 .032(in order to avoid losing or gaining counts due to conflicting reads and writes.  Thus, while reference count updating)J41 418 :M.008 .001(for the creation and deletion of structures may be tolerable, this continual updating for simple traversals is not.)J41 433 :M-.028(In a classical reference count system, the reference count on a node indicates the exact number of references\321whether)A41 444 :M.274 .027(from other nodes or local variables\321that currently point to the node.  The copying of a reference causes a reference)J41 455 :M-.053(count increment and the deletion of a reference causes a reference count decrement.  The "linear style" of programming)A41 466 :M.026 .003(inspired by linear logic \(see Appendix I\) helps to minimize the reference count updating that is caused by the copying)J41 477 :M-.015(and deletion of references from local variables.  In the linear style, the policy is that variable references are destructive)A41 488 :M.499 .05(reads\321i.e., )Jf6_9 sf.613 .061(cons\(a,b\) )Jf0_10 sf.319 .032(does not have to change the reference counts on )Jf6_9 sf.123(a)Af0_10 sf.057(,)Af6_9 sf.123(b)Af0_10 sf.401 .04( because these references have simply)J41 499 :M.608 .061(moved from local variables into storage.  The linear style makes the creation and deletion of references explicit\321)J41 510 :M.549 .055(duplicating a local reference requires calling the function )Jf6_9 sf.18(dup)Af0_10 sf.521 .052(, while deleting a local reference requires calling the)J41 521 :M1.369 .137(function )Jf6_9 sf.392(kill)Af0_10 sf.796 .08(.  The function )Jf6_9 sf.392(dup)Af0_10 sf1.066 .107( increments the reference count of the target object, while the function )Jf6_9 sf.523(kill)A41 532 :Mf0_10 sf-.041(decrements the reference count, and may also reclaim the object, recursively killing its component references.)A41 547 :M.309 .031(While the linear style can help organize and reduce reference count updating, it does not eliminate the updating that)J41 558 :M.153 .015(results from simple traversal.  Thus, a linear )Jf6_9 sf.059(length)Af0_10 sf.182 .018( function will still increment and decrement reference counts on)J41 569 :M-.041(every cell it traverses.  To understand this better, we show the code for a linear )Af6_9 sf-.058(length)Af0_10 sf(:)S41 583 :Mf6_9 sf-.403(\(defun length \(x\)                                           ; Length function in linear style.)A41 593 :M-.403(  \(if-null x \(progn \(kill x\) 0\)                                     ; Kill x reference to nil.)A41 603 :M-.403(    \(dlet* \(\(\(carx . cdrx\) x\)\)                                   ; Dissolve x into carx, cdrx.)A41 615 :M-.39(      \(kill carx\))Af0_9 sf0 -3 rm-.325(1)A0 3 rmf6_9 sf-.395(                                                   ; Kill reference to carx.)A41 625 :M-.403(      \(1+ \(length cdrx\)\)\)\)\)                      ; Our result is one more than length of cdrx.)A41 640 :Mf0_10 sf.25 .025(When )Jf6_9 sf.077(length)Af0_10 sf.185 .018( is entered, the reference count on )Jf6_9 sf.077(x)Af0_10 sf.17 .017( is almost certainly >1, or else )Jf6_9 sf.077(length)Af0_10 sf.237 .024( will consume its argument)J41 651 :M.109 .011(and return it to the freelist!  Let us assume that the reference count of the head of the list is 2 and the rest of the list is)J-4127 -4126 -1 1 -4125 -4126 1 -4127 -4127 @a41 669.24 -.24 .24 184.24 669 .24 41 669 @a41 684 :Mf0_9 sf(1)Sf0_10 sf0 3 rm-.038(Following logic languages, we could use syntax like )A0 -3 rmf6_9 sf0 3 rm-.051(dlet* \(\(\(_ . cdrx\) x\)\))A0 -3 rmf0_10 sf0 3 rm-.036( to immediately kill the )A0 -3 rmf6_9 sf0 3 rm-.051(car)A0 -3 rmf0_10 sf0 3 rm-.031( of )A0 -3 rmf6_9 sf0 3 rm-.051(x)A0 -3 rmf0_10 sf0 3 rm(.)S0 -3 rmendp%%Page: 2 2%%BeginPageSetupinitializepage(Henry Baker; page: 2 of 6)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.143 .014(ACM )Jf2_12 sf.2 .02(Sigplan Notices)Jf0_12 sf( )Sf3_12 sf.04(29)Af0_12 sf.137 .014(, 9 \(September 1994\), 38-43.)J72 754 :Mf0_10 sf.334 .033(Copyright \251 1993 by Nimble Computer Corporation)J318 754 :M(2)S513 754 :M.074(12/6/94)A72 81 :M-.081(unshared.  A standard )Af6_9 sf-.107(dlet* )Af0_10 sf-.078(adds references to )Af6_9 sf-.107(carx)Af0_10 sf-.049(, )Af6_9 sf-.107(cdrx)Af0_10 sf-.076( and then deletes the reference to )Af6_9 sf-.107(x)Af0_10 sf-.075(.  The reference to )Af6_9 sf-.142(carx)A72 92 :Mf0_10 sf.93 .093(is immediately killed, and the reference to )Jf6_9 sf.335(cdrx)Af0_10 sf.809 .081(, which now has a reference count of 2, is passed to a recursive)J72 103 :M.917 .092(invocation of )Jf6_9 sf.303(length)Af0_10 sf.655 .066(.  At list end, the extra reference from )Jf6_9 sf.303(x)Af0_10 sf.299 .03( to )Jf6_9 sf.303(nil)Af0_10 sf.565 .056( is killed, and )Jf6_9 sf.303(0)Af0_10 sf.612 .061( is returned.  Thus, )Jf6_9 sf.364(length)A72 114 :Mf0_10 sf-.028(performs 4n count updates \(each )Af2_10 sf-.03(element)Af0_10 sf-.025( of the list has its reference count updated twice\) for an n-element list.)A72 129 :M-.024(Since )Af6_9 sf-.031(length)Af0_10 sf-.023( eventually returns the reference counts to their initial state, what would happen if we simply avoided all)A72 140 :M.79 .079(updates?  A problem arises because the second and succeeding nodes on the list have reference counts of 1\321the)J72 151 :Mf6_9 sf.478(dlet*)Af0_10 sf1.285 .128('s will reclaim all of these nodes and put them onto the freelist!  We must therefore somehow suspend)J72 162 :M-.022(reclamation while )Af6_9 sf-.028(length)Af0_10 sf-.02( is in progress.  Suppose that we use )Af2_10 sf-.025(two)Af0_10 sf-.021( types of pointers\321a )Af2_10 sf-.025(normal)Af0_10 sf-.02( pointer and a )Af2_10 sf-.025(deferred)A72 173 :M.034(increment)Af0_10 sf.119 .012( pointer.  The normal pointer acts as we have described above, while the deferred increment pointer signals)J72 184 :M-.081(that reclamation has been turned off.  In other words, )Af2_10 sf-.084(a deferred increment pointer is a pointer with a deferred reference)A72 195 :M.458 .046(count increment)Jf0_10 sf.229 .023(.  If we copy a deferred increment pointer using )Jf6_9 sf.096(dup)Af0_10 sf.229 .023(, we simply copy the bits, because n copies of a)J72 206 :M-.02(deferred increment implies a deferred increment of n.  Similarly, if we delete a deferred increment pointer using )Af6_9 sf-.027(kill)Af0_10 sf(,)S72 217 :M.764 .076(we simply delete the reference, since the decrement associated with )Jf6_9 sf.254(kill)Af0_10 sf.758 .076( cancels the deferred increment.  When)J72 228 :Mf6_9 sf1.343 .134(cons\(x,y\) )Jf0_10 sf.624 .062(is performed on a )Jf2_10 sf.239(normal)Af0_10 sf.571 .057( pointer )Jf6_9 sf.269(x)Af0_10 sf.641 .064(, the reference count on )Jf6_9 sf.269(x)Af0_10 sf.646 .065( does not have to be adjusted since the)J72 239 :M-.036(reference is simply transferred from the local variable )Af6_9 sf(x)Sf0_10 sf-.037( to the cons cell.  However, when )Af6_9 sf-.05(cons\(x,y\) )Af0_10 sf-.042(is performed on)A72 250 :M-.081(a )Af2_10 sf-.099(deferred increment)Af0_10 sf-.087( pointer )Af6_9 sf-.126(x)Af0_10 sf-.09(, the reference count on )Af6_9 sf-.126(x)Af0_10 sf-.058( )Af2_10 sf-.107(does)Af0_10 sf-.096( have to be incremented, since a deferred reference means a)A72 261 :M.665 .066(deferred increment, and components of data structures have to be normal.  The treatment of )Jf6_9 sf.235(dlet*)Af0_10 sf.562 .056( for a deferred)J72 272 :M.488 .049(increment pointer )Jf6_9 sf.137(x)Af0_10 sf.347 .035( is also elegant: the deferred increment on )Jf6_9 sf.137(x)Af0_10 sf.315 .031( cancels with )Jf6_9 sf.137(dlet*)Af0_10 sf.347 .035('s decrement of )Jf6_9 sf.137(x)Af0_10 sf.323 .032(, and the local)J72 283 :M.592 .059(variables )Jf6_9 sf.166(carx)Af0_10 sf.128 .013(, )Jf6_9 sf.166(cdrx)Af0_10 sf.467 .047( are also deferred, so their increments are deferred.  So deferred increment pointers appear to)J72 294 :M-.098(elegantly achieve our goals\321executing )Af6_9 sf-.125(length)Af0_10 sf-.092( on a deferred increment pointer )Af6_9 sf-.125(x)Af0_10 sf-.098( performs no reference count updates!)A72 309 :M.252 .025(If deferred increment pointers are so efficient, why not eliminate normal pointers altogether?  The problem with this)J72 320 :M-.014(proposal is that no storage can )Af2_10 sf-.015(ever)Af0_10 sf-.014( be recovered with only deferred increment pointers\321i.e., we are back in the realm)A72 331 :M-.005(of tracing garbage collection.  Consider )Af6_9 sf-.007(kill\(cons\(x,y\)\))Af0_10 sf(.  If )Sf6_9 sf(cons)Sf0_10 sf-.005( returns a deferred increment pointer, then )Af6_9 sf(kill)S72 343 :Mf0_10 sf(does nothing, and the cons cell is lost.  Thus, )Sf6_9 sf(cons)Sf0_10 sf( itself must always return a normal \(non-deferred\) pointer.)Sf0_9 sf0 -3 rm(2)S0 3 rm72 359 :Mf0_10 sf.085 .009(We therefore propose a system of pointers that are dynamically typed as normal/deferred-increment.)Jf0_9 sf0 -3 rm(3)S0 3 rmf0_10 sf.084 .008(  Unfortunately,)J72 370 :M.032 .003(this system still does not quite work, as the )Jf6_9 sf.013(third)Af0_10 sf.056 .006( function demonstrates:)J72 384 :Mf6_9 sf-.403(\(defun third \(x\)                                   ; Linearly return the third cons in list x.)A72 394 :M-.403(  \(dlet* \(\(\(carx . cdrx\) x\)                                         ; Dissolve the first cons.)A72 404 :M-.403(          \(\(cadrx . cddrx\) cdrx\)\)                                  ; Dissolve the second cons.)A72 414 :M-.403(    \(kill carx\) \(kill cadrx\) cddrx\)\)            ; Kill first 2 elements, then return 3rd cons.)A72 429 :Mf0_10 sf.062 .006(If )Jf6_9 sf.048(third)Af0_10 sf.125 .013( is passed a deferred increment pointer )Jf6_9 sf(x)Sf0_10 sf.095 .009(, it will traverse the list )Jf6_9 sf(x)Sf0_10 sf.146 .015( without changing reference counts until it)J72 440 :M.007 .001(gets to the third cons cell.  It then returns a deferred increment pointer to this third cons cell.  Unfortunately, the caller)J72 451 :M.121 .012(to )Jf6_9 sf.082(third)Af0_10 sf.212 .021( can now kill the list, in which case the third cons will also be reclaimed, because the increment implied by)J72 462 :M.101 .01(the deferred pointer to it will never have been performed.  We can fix this bug by making the policy that )Jf2_10 sf.185 .018(only normal)J72 473 :M.229 .023(pointers can be returned from a function)Jf0_10 sf.181 .018(.  With this policy, the returned value from )Jf6_9 sf.076(third)Af0_10 sf.169 .017( will be coerced back to a)J72 485 :M1.181 .118(normal pointer by performing the increment implied by the deferred pointer.)Jf0_9 sf0 -3 rm.304(4)A0 3 rmf0_10 sf.959 .096(  This policy will work correctly,)J72 496 :M.501 .05(because it is somewhat more prompt than the correct "anchored pointer" scheme described below, but is also more)J72 507 :M-.002(expensive, because it does not defer reference count updates as long as possible.  However, if we have but one pointer)A72 518 :M.85 .085(bit to give to the cause, this normal/deferred scheme is still better than a classical reference count scheme\321e.g.,)J72 529 :M.093 .009(functions like )Jf6_9 sf.031(length)Af0_10 sf.093 .009( "win completely" with just a one-bit distinction.)J72 544 :M.401 .04(A reference count updating scheme lazier than deferred increment pointers can be obtained at the cost of additional)J72 555 :M.293 .029(pointer bits by means of )Jf2_10 sf.599 .06(anchored pointers)Jf0_10 sf.334 .033(.  An anchored pointer is a deferred increment pointer with an additional)J72 566 :M.39 .039(component which indicates its )Jf2_10 sf.104(anchor)Af0_10 sf.35 .035(.  One implementation might use an integer component indicating the level in)J72 577 :M.62 .062(the stack at which the object is )Jf2_10 sf.241(anchored)Af0_10 sf.695 .07(.  When a functional cell pointed at by a deferred increment pointer )Jf6_9 sf.275(x)Af0_10 sf.389 .039( is)J72 588 :M.515 .052(dissolved into its components, they each )Jf2_10 sf.121(inherit)Af0_10 sf.459 .046( the level number associated with )Jf6_9 sf.171(x)Af0_10 sf.441 .044(.  An anchored pointer not only)J72 599 :M-.004(indicates deferredness, but also indicates the extent during which this deferral is valid.  If a deferred increment pointer)A72 610 :M.173 .017(is returned from stack level n, it must have a level number that is strictly less than n.  In other words, when returning)J-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 637.24 -.24 .24 215.24 637 .24 72 637 @a72 652 :Mf0_9 sf-.083(2)Af0_10 sf0 3 rm-.079(The Deutsch-Bobrow reference count scheme [Deutsch76] [Deutsch80] does not count references from local variables,)A0 -3 rm72 666 :M-.038(and thereby avoids these count updates.  Their scheme requires a stack scan before reclaiming storage, however, which)A72 677 :M.036 .004(scan is nearly impossible to do on stacks formatted by optimizing compilers for modern RISC architectures.)J72 689 :Mf0_9 sf(3)Sf0_10 sf0 3 rm-.038(The )A0 -3 rmf2_10 sf0 3 rm-.041(normal)A0 -3 rmf0_10 sf0 3 rm(/)S0 -3 rmf2_10 sf0 3 rm-.035(deferred-increment )A0 -3 rmf0_10 sf0 3 rm-.031(distinction is essentially identical to the )A0 -3 rmf2_10 sf0 3 rm-.034(real)A0 -3 rmf0_10 sf0 3 rm(/)S0 -3 rmf2_10 sf0 3 rm-.042(phantom)A0 -3 rmf0_10 sf0 3 rm-.035( distinction of [Lema\224tre86] and)A0 -3 rm72 703 :M-.083(the )Af2_10 sf-.117(owned)Af0_10 sf-.062(/)Af2_10 sf-.109(borrowed)Af0_10 sf-.089( distinction of [Gelernter60].)A72 715 :Mf0_9 sf(4)Sf0_10 sf0 3 rm-.007([Lema\224tre86] calls this normalization operation "materialization".)A0 -3 rmendp%%Page: 3 3%%BeginPageSetupinitializepage(Henry Baker; page: 3 of 6)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.143 .014(ACM )Jf2_12 sf.2 .02(Sigplan Notices)Jf0_12 sf( )Sf3_12 sf.04(29)Af0_12 sf.137 .014(, 9 \(September 1994\), 38-43.)J72 754 :Mf0_10 sf.334 .033(Copyright \251 1993 by Nimble Computer Corporation)J318 754 :M(3)S513 754 :M.074(12/6/94)A72 81 :M.093 .009(a deferred increment pointer from stack level n+1, one first checks to see that the level is )JcFf1_10 sf.009<A3>Asf.093 .009(n, and if not, the pointer is)J72 92 :M-.065(coerced to normal\321i.e., the reference count increment is performed.)A72 107 :M-.03(The implementation of the anchored pointer scheme can be confined to a )Af6_9 sf-.039(dlet1)Af0_10 sf-.029( special form, which dissolves a single)A72 118 :M.203 .02(list cell and binds its components.  We identify the anchor level with the index of this )Jf6_9 sf.082(dlet1)Af0_10 sf.226 .023( in the stack\321i.e., each)J72 129 :Mf6_9 sf.076(dlet1)Af0_10 sf.157 .016( form has its own level number.  If )Jf6_9 sf.076(dlet1)Af0_10 sf.181 .018( is given a normal pointer, then it checks the reference count.  If the)J72 140 :M.077 .008(count is 1, then the cell is unshared, and )Jf6_9 sf.034(dlet1)Af0_10 sf.076 .008( has the only pointer to this cell.  The car and cdr are bound as normal)J72 151 :M.214 .021(pointers, and the cell is recycled.  If the count is >1, then the cell is shared, so the car and cdr are bound as anchored)J72 162 :M.207 .021(pointers with a level number being the current )Jf6_9 sf.076(dlet1)Af0_10 sf.157 .016( level.  Later, when )Jf6_9 sf.076(dlet1)Af0_10 sf.211 .021( must return values, these values are)J72 173 :M.125 .013(checked for deferral and normalized if their level numbers are )JcFf1_10 sf.013<B3>Asf.125 .013( the current level.  Finally, the reference count on the)J72 184 :M.177 .018(cell input to the )Jf6_9 sf.085(dlet1)Af0_10 sf.218 .022( is decremented.  The last case involves an anchored pointer input to )Jf6_9 sf.085(dlet1)Af0_10 sf.159 .016(.  In this case, the)J72 195 :M.396 .04(car and cdr bindings are also anchored with the same level number as their parent pointer.  Since the parent pointer)J72 206 :M.518 .052(must have been anchored at a level strictly less than the current level, the return values need not be checked at all,)J72 217 :M.031 .003(since they will either already be normal, or will not require normalization until a lower level.)J72 232 :M.379 .038(Working with anchored pointers can be extremely efficient.  In the Boyer Benchmark [Gabriel85], for example, the)J72 243 :M1.081 .108(\(functional\) database of rewrite rules is bound at "top-level"\321i.e., stack level 0.  Thus, traversals of these data)J72 254 :M-.007(structures can be performed entirely by anchored pointers without updating reference counts\321an extremely important)A72 265 :M-.007(characteristic for a shared-memory multiprocessor implementation of this benchmark, where multiple processors have)A72 276 :M-.093(to concurrently access these shared read-only rules.)A72 291 :M-.069(If our anchored pointer scheme is used in conjunction with a traditional tracing garbage collector, the deferred reference)A72 302 :M.079 .008(counts may give the collector fits.  In order for the reference accounting to balance, a cell bound by a deferred )Jf6_9 sf.039(dlet1)A72 313 :Mf0_10 sf(should be given a )Sf2_10 sf(negative)Sf0_10 sf-.002( deferred reference by the )Af6_9 sf(dlet1)Sf0_10 sf-.002(, and this negative deferred reference is finally normalized)A72 324 :M.346 .035(before the )Jf6_9 sf.135(dlet1)Af0_10 sf.346 .035( returns its values by causing its reference count to be decremented.  Only )Jf6_9 sf.135(dlet1)Af0_10 sf.367 .037( and the garbage)J72 335 :M-.14(collector ever see these negative deferred references, however.)A72 350 :M1.1 .11(The inclusion of a level number with every pointer in a local variable is probably prohibitive on today's 32-bit)J72 361 :M-.049(architectures, because the additional information would double the number of registers required to store local variables.)A72 372 :M1.536 .154(However, with the newer 64-bit architectures\321e.g., MIPS, DEC\321a 16-bit level number would not constrain)J72 383 :M1.019 .102(addressability, and would avoid the requirement for additional registers.  Checking and masking this level data,)J72 394 :M-.038(however, could present efficiency problems if the architecture is not organized for it.)A72 410 :Mf5_10 sf(')Sf6_10 sf-.111(WITH-ANCHORED-POINTER)Af5_10 sf-.124(' PROGRAMMING LANGUAGE CONSTRUCT)A72 425 :Mf0_10 sf.993 .099(The )Jf6_9 sf.416(dlet1)Af0_10 sf1.139 .114( special form described above works, but it may be more complex than strictly needed to solve the)J72 436 :M.14 .014(problem.  What we really need is a form that is given a normal pointer and provides an anchored pointer for use only)J72 447 :M.112 .011(within a dynamic context.  In other words, it puts the normal pointer into "escrow", and provides an anchored pointer)J72 458 :M.918 .092(for temporary use, and when the construct is exited and its values normalized, the escrowed pointer can then be)J72 469 :M-.097(dropped.  We suggest something like the )Af6_9 sf-.127(with-anchored-pointer)Af0_10 sf-.1( special form:)A72 483 :Mf6_9 sf-.403(\(with-anchored-pointer \(ap-name\) \(<expression>\)   ; binds ap-name to copy of expression value.)A72 493 :M-.407(  << use ap-name within this dynamic extent body >>)A72 503 :M-.412(  < returned-value-expression >\))A72 518 :Mf0_10 sf-.077(The )Af6_9 sf-.093(with-anchored-pointer)Af0_10 sf-.069( form evaluates )Af6_9 sf-.093(<expression>)Af0_10 sf-.069( to either a normal pointer or another anchored pointer.)A72 529 :M-.002(If it evaluates to an anchored pointer, then )Af6_9 sf(with-anchored-pointer)Sf0_10 sf( acts just like a )Sf6_9 sf(let)Sf0_10 sf(-expression.  However, if it)S72 540 :M.08 .008(evaluates to a normal pointer, then the pointer is saved internally, and an anchored pointer copy of the normal pointer)J72 551 :M-.07(is made and bound to the name )Af6_9 sf-.089(ap-name)Af0_10 sf-.064(.  The body of the )Af6_9 sf-.089(with-anchored-pointer)Af0_10 sf-.069( form is evaluated with this new)A72 562 :M.32 .032(binding, and the values returned by the body are normalized if they depend upon the escrowed pointer.  The normal)J72 573 :M-.022(pointer is killed just before the dynamic scope is exited, which involves decrementing its reference count.)A72 588 :M.742 .074(Constructs like )Jf6_9 sf.23(with-anchored-pointer)Af0_10 sf.654 .065( allow the introduction of anchored pointers into a static type system.)J72 599 :M.491 .049(Within the body of the construct, the name is bound to a value which is guaranteed to be anchored, and thus many)J72 610 :M-.011(run-time checks may be omitted.)A72 626 :Mf5_10 sf-.091(CONCLUSIONS AND PREVIOUS WORK)A72 641 :Mf0_10 sf.574 .057(Programmers have been using temporary pointers to objects without updating their associated reference counts for)J72 652 :M.639 .064(decades\321e.g., the Unix file system is reference counted, but it distinguishes between "hard" and "soft" links; soft)J72 663 :M-.01(links \(created by )Af6_9 sf-.014(ln\312-s)Af0_10 sf-.01(\) are uncounted.  [Gelernter60] uses the distinction of )Af2_10 sf-.013(owned)Af0_10 sf(/)Sf2_10 sf-.012(borrowed)Af0_10 sf-.011( pointers; [Lema\224tre86])A72 674 :M.195 .02(uses the concept of )Jf2_10 sf.402 .04(phantom pointers)Jf0_10 sf.251 .025(.  Our concept of anchored pointers, however, generalizes these techniques and)J72 685 :M.964 .096(makes more precise the situations under which they are safe.  Maclisp "PDL numbers" [Steele77] are similar to)J72 696 :M.084 .008(anchored pointers in that they encode a stack level and can be used safely only within a dynamic context.  Since PDL)J72 707 :M.623 .062(numbers have no explicit reference count, however, the only way to normalize them is by copying them, which is)J72 718 :M-.035(done whenever they are stored into a more global environment or returned as a value of a function.)Aendp%%Page: 4 4%%BeginPageSetupinitializepage(Henry Baker; page: 4 of 6)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.143 .014(ACM )Jf2_12 sf.2 .02(Sigplan Notices)Jf0_12 sf( )Sf3_12 sf.04(29)Af0_12 sf.137 .014(, 9 \(September 1994\), 38-43.)J72 754 :Mf0_10 sf.334 .033(Copyright \251 1993 by Nimble Computer Corporation)J318 754 :M(4)S513 754 :M.074(12/6/94)A72 85 :M.063 .006(Other schemes involving 1-bit reference counts include [Wise77] [Stoye84] [Chikayama87] [Inamura89] [Nishida90])J72 96 :M.217 .022(and [Wise92].  Anchored pointers can be particularly useful when a reference count cannot be incremented for some)J72 107 :M.436 .044(particular reason\321e.g., it has only 1 bit [Wise77] [Chikayama87] [Inamura89] [Nishida90].  Our linear scheme for)J72 118 :M.136 .014(avoiding reference count updates has goals similar to those of [Deutsch76] [Deutsch80] and especially [Barth77] and)J72 129 :M.019 .002([Park91].  In particular, our scheme defers reference count updating like Barth's and Park's in the hope of a decrement)J72 140 :M.19 .019(cancelling an increment, leaving no net change.  However, ours is simpler than theirs\321requiring only static linearity)J72 151 :M.019 .002(checking instead of global flow analysis.  Furthermore, linear style makes avoiding count updates more likely.)J72 166 :M.43 .043(Anchored pointers are similar to )Jf2_10 sf.662 .066(generational reference counts)Jf0_10 sf.432 .043( [Goldberg89] in that they both attempt to minimize)J72 177 :M.169 .017(count updates, both explicitly identify their generation and both use escape analysis.  However, anchored pointers do)J72 188 :M.13 .013(not require a count field, and can be slightly lazier than generational reference counts.  Anchored pointers are closely)J72 199 :M.486 .049(related to the schemes described in [Baker92CONS] and [Baker93Safe].  The scheme of [Baker93Safe], which has)J72 210 :M.215 .022(different goals and works for mutable data, stores its stack level numbers in the objects themselves rather than in the)J72 221 :M.907 .091(pointers to the objects.  Some reference count schemes [Deutsch76] [Deutsch80] avoid reference count updating)J72 232 :M.234 .023(overhead during traversal by never counting references from local variables on the stack.  Such schemes require that)J72 243 :M.522 .052(the stack be scanned before cells can be reclaimed.  It is becoming apparent, however, that scanning the stack of a)J72 254 :M.022 .002(compiled language like C [Yuasa90] or Ada [Baker93Safe] is becoming increasingly difficult, making stack-scanning)J72 265 :M-.041(schemes infeasible.)A72 280 :M.444 .044(Anchored pointers can also be used to improve the efficiency of tracing non-copying garbage collection.  In a real-)J72 291 :M-.133(time non-relocating garbage collector such as [Baker92Tread], )Af2_10 sf-.135(anchored pointers can be accessed without a read barrier)Af0_10 sf(.)S72 302 :M.858 .086(Furthermore, since an anchored pointer contains within it a proof that the target object is not garbage, )Jf2_10 sf.312(anchored)A72 313 :M.313 .031(pointers need not be traced by the garbage collector)Jf0_10 sf.268 .027(.  While tracing the pointer will reveal that the target object has)J72 324 :M.477 .048(already been marked, it is more efficient to not trace the pointer, so that the target never has to be paged into main)J72 335 :M.76 .076(memory or the cache.  Anchored pointers are similar to )Jf6_9 sf.285(object)Af0_10 sf.714 .071( declarations in )Jf2_10 sf1.172 .117(Kyoto Common Lisp)Jf0_10 sf1.23 .123( [Yuasa90],)J72 346 :M-.043(because )Af6_9 sf-.054(object)Af0_10 sf-.04( declarations are not traced by the garbage collector.  KCL )Af6_9 sf-.054(object)Af0_10 sf-.04( declarations are not safe, however,)A72 357 :M-.048(because they can refer to mutable data, and carry no proof of accessibility.)A72 372 :M.412 .041(Anchored pointers are similar to )Jf2_10 sf.629 .063(weak pointers)Jf0_10 sf.32 .032(, in that they are not traced by a garbage collector, but are used for a)J72 383 :M.29 .029(completely different purpose.  A weak pointer is expected to escape from the context in which its target is protected)J72 394 :M.084 .008(from reclamation, but when its target is reclaimed, the escaped pointer is cleared to )Jf6_9 sf.03(nil)Af0_10 sf.085 .008(, so the application will know)J72 405 :M.025 .003(that the object is gone.  Anchored pointers, on the other hand, are used primarily for improving efficiency, and should)J72 416 :M-.09(have no user-visible semantic differences except for improved performance.)A72 431 :M1.122 .112(Anchored pointers can also provide a solution to the garbage collection problems of )Jf2_10 sf1.784 .178(derived pointers)Jf0_10 sf1.402 .14( [Ellis88])J72 442 :M1.3 .13([Nilsen88] [Boehm91] [Diwan92]\321i.e., pointers into the interior of a large object such as an array.  [Ellis88])J72 453 :M-.002(suggests that a derived pointer have the form <base-ptr,derived-ptr>; a normal pointer to an array element would have)A72 464 :M2.79 .279(the form <base-ptr,index>.  A derived pointer can be normalized into a normal pointer by computing)J72 475 :M1.437 .144(index\312=\312\(derived-ptr\312-\312base-ptr\)/element-size.  Our anchored pointers and their use in a dynamic extent can be)J72 486 :M.038 .004(considered a generalization of the static scheme proposed in [Boehm91].  Our anchoring scheme avoids the tracing of)J72 497 :M-.045(derived pointers in a non-copying collector.)A72 512 :M-.04(Our reference count scheme is safe because it defers increments only within an extent where a cell cannot be reclaimed)A72 523 :M.276 .028(anyway.  The non-prompt incrementation of reference counts means that a garbage collection that restores reference)J72 534 :M.17 .017(counts may restore the reference counts improperly.  Our fix for this problem is to create )Jf2_10 sf.32 .032(negative references)Jf0_10 sf.143 .014( when a)J72 545 :M.257 .026(cons is dissolved by )Jf6_9 sf.102(dlet1)Af0_10 sf.277 .028(.  This negative reference is normalized when )Jf6_9 sf.102(dlet1)Af0_10 sf.28 .028( exits.  Negative references are also)J72 556 :M-.044(cleaned up when unwinding the stack\321e.g., for C's )Af6_9 sf-.057(setjmp)Af0_10 sf(/)Sf6_9 sf-.057(longjmp)Af0_10 sf-.044(, or for Common Lisp's )Af6_9 sf-.057(catch)Af0_10 sf(/)Sf6_9 sf-.057(throw)Af0_10 sf(.)S72 571 :M.506 .051(Our reference count scheme is intended to support the efficient implementation of functional \(read-only\) objects\321)J72 582 :M.376 .038(perhaps implemented by means of )Jf2_10 sf.527 .053(hash consing)Jf0_10 sf.394 .039( [Baker92BB] [Baker92LLL]\321and so there is no attempt to handle)J72 593 :M.154 .015(mutable objects or cycles.  The linear style of programming essentially requires functions to be )Jf2_10 sf.037(total)Af0_10 sf.189 .019(\321i.e., they must)J72 604 :M.241 .024(return with a value.  The explicit killing of references, and the normalization traps of anchored pointers requires that)J72 615 :M.081 .008(functions return in the normal way\321the )Jf6_9 sf.027(catch)Af0_10 sf(/)Sf6_9 sf.027(throw)Af0_10 sf.077 .008( of Common Lisp, the reified continuations of Scheme and the)J72 626 :Mf6_9 sf-.025(setjmp)Af0_10 sf(/)Sf6_9 sf-.025(longjmp)Af0_10 sf-.019( of C will all cause significant problems with this storage management scheme.)A72 642 :Mf5_10 sf.008(ACKNOWLEDGEMENTS)A72 657 :Mf0_10 sf.051 .005(Many thanks to David Wise and Kelvin Nilsen for their constructive criticisms on this paper.)J72 673 :Mf5_10 sf.074(REFERENCES)A72 687 :Mf0_10 sf.387 .039(Abramsky, S.  "Computational interpretations of linear logic".  )Jf2_10 sf.415 .042(Theor. Comp. Sci. 111)Jf0_10 sf.392 .039( \(1993\), 3-57.)J72 698 :M.421 .042(Baker, H.G.  "CONS Should not CONS its Arguments".  ACM )Jf2_10 sf.49 .049(Sigplan Not. 27)Jf0_10 sf.627 .063(,3 \(March\3121992\), 24-34.)J72 709 :M.222 .022(Baker, H.G.  "The Treadmill: Real-Time Garbage Collection without Motion Sickness".  )Jf2_10 sf.227 .023(Sigplan Not. 27)Jf0_10 sf.262 .026(,3 \(1992\).)Jendp%%Page: 5 5%%BeginPageSetupinitializepage(Henry Baker; page: 5 of 6)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.143 .014(ACM )Jf2_12 sf.2 .02(Sigplan Notices)Jf0_12 sf( )Sf3_12 sf.04(29)Af0_12 sf.137 .014(, 9 \(September 1994\), 38-43.)J72 754 :Mf0_10 sf.334 .033(Copyright \251 1993 by Nimble Computer Corporation)J318 754 :M(5)S513 754 :M.074(12/6/94)A72 81 :M.173 .017(Baker, H.G.  "The Boyer Benchmark at Warp Speed".  ACM )Jf2_10 sf.206 .021(Lisp Pointers V)Jf0_10 sf.271 .027(,3 \(July-Sept.\3121992\), 13-14.)J72 92 :M.293 .029(Baker, H.G.  "Lively Linear Lisp \321 'Look Ma, No Garbage!'".  ACM )Jf2_10 sf.513 .051(Sigplan Notices)Jf0_10 sf.046 .005( )Jf2_10 sf.102(27)Af0_10 sf.445 .044(,8 \(Aug.\3121992\), 89-98.)J72 103 :M.781 .078(Baker, H.G.  "Safe and Leakproof Resource Management using Ada83 Limited Types".  ACM )Jf2_10 sf.834 .083(Ada Letters XIII)Jf0_10 sf.385 .038(, 5)J89 114 :M.905 .09(\(Sep/Oct\3121993\), 32-42.)J72 125 :M.288 .029(Baker, H.G.  "Equal Rights for Functional Objects".  ACM )Jf2_10 sf.415 .041(OOPS Messenger 4)Jf0_10 sf.388 .039(,4 \(Oct.\3121993\), 2-27.)J72 136 :M.338 .034(Barth, J.  "Shifting garbage collection overhead to compile time".  )Jf2_10 sf.534 .053(CACM 20)Jf0_10 sf.507 .051(, 7 \(July\3121977\),513-518.)J72 147 :M.256 .026(Bekkers, Y., and Cohen, J., )Jf2_10 sf.079(eds)Af0_10 sf.058 .006(.  )Jf2_10 sf.458 .046(Memory Management: Proc. IWMM92)Jf0_10 sf.268 .027(  Springer LNCS 637, 1992.)J72 158 :M.168 .017(Berry, G., and Boudol, G.  "The chemical abstract machine".  )Jf2_10 sf.197 .02(Theor. Comp. Sci. 96)Jf0_10 sf.225 .023( \(1992\), 217-248.)J72 169 :M.436 .044(Boehm, H.-J.  "Simple GC-Safe Compilation".  GC Workshop at OOPSLA'91, Phoenix, AZ, Oct. 6, 1991.)J72 180 :M.82 .082(Chikayama, T., and Kimuar, Y.  "Multiple Reference Management in Flat GHC".  )Jf2_10 sf1.111 .111(Logic Programming, Proc. 4th)J89 191 :M.675 .068(Intl. Conf)Jf0_10 sf.606 .061(., MIT Press, 1987, 276-293.)J72 202 :M.558 .056(Chirimar, J., )Jf2_10 sf.421 .042(et al)Jf0_10 sf.565 .057(.  "Proving Memory Management Invariants for a Language Based on Linear Logic".  )Jf2_10 sf.914 .091(Proc. ACM)J89 213 :M.544 .054(Conf. Lisp & Funct. Prog)Jf0_10 sf.496 .05(., San Francisco, CA, June, 1992, also ACM )Jf2_10 sf.602 .06(Lisp Pointers V)Jf0_10 sf.77 .077(,1 \(Jan.-Mar.\3121992\), 139.)J72 224 :M.329 .033(Collins, G.E.  "A method for overlapping and erasure of lists".  )Jf2_10 sf.526 .053(CACM 3)Jf0_10 sf.562 .056(,12 \(Dec.\3121960\), 655-657.)J72 235 :M.278 .028(Deutsch, L.P., and Bobrow, D.G.  "An efficient incremental automatic garbage collector".  )Jf2_10 sf.398 .04(CACM 19)Jf0_10 sf.416 .042(,9 \(Sept.\3121976\).)J72 246 :M.383 .038(Deutsch, L.P.  "ByteLisp and its Alto Implementation".  )Jf2_10 sf.509 .051(Lisp Conf)Jf0_10 sf.432 .043(., Stanford, CA, Aug. 1980, 231-243.)J72 257 :M.524 .052(Diwan, A., )Jf2_10 sf.408 .041(et al)Jf0_10 sf.517 .052(.  "Compiler support for garbage collection in a statically typed language".  ACM )Jf2_10 sf.979 .098(PLDI'92, Sigplan)J89 268 :M.711 .071(Not. 27)Jf0_10 sf.938 .094(,6 \(June\3121992\), 273-282.)J72 279 :M.262 .026(Edelson, D.R.  "Smart pointers: They're smart but they're not pointers".  )Jf2_10 sf.294 .029(Proc. Usenix C++ Tech. Conf. 92)Jf0_10 sf.282 .028(, 1-19.)J72 290 :M.164 .016(Edelson, D.R.  "Precompiling C++ for Garbage Collection".  In [Bekkers92], 299-314.)J72 301 :M.241 .024(Ellis, J.R., )Jf2_10 sf.211 .021(et al)Jf0_10 sf.299 .03(.  "Real-time concurrent collection on stock multiprocessors".  ACM )Jf2_10 sf.089(PLDI'88)Af0_10 sf(.)S72 312 :M.231 .023(Friedman, D.P., and Wise, D.S.  "Aspects of applicative programming for parallel processing".  )Jf2_10 sf.322 .032(IEEE Trans. Comput.)J89 323 :M.168(C-27)Af0_10 sf.767 .077(,4 \(Apr.\3121978\), 289-296.)J72 334 :M.266 .027(Gabriel, R.P.  )Jf2_10 sf.41 .041(Performance and Evaluation of Lisp Systems)Jf0_10 sf.302 .03(.  MIT Press, Camb., MA 1985.)J72 345 :M.241 .024(Gelernter, H., )Jf2_10 sf.172 .017(et al)Jf0_10 sf.226 .023(.  "A Fortran-compiled list processing language".  )Jf2_10 sf.2 .02(J. ACM 7)Jf0_10 sf.273 .027( \(1960\), 87-101.)J72 356 :M.094 .009(Girard, J.-Y.  "Linear Logic".  )Jf2_10 sf.143 .014(Theoretical Computer Sci. 50)Jf0_10 sf.176 .018( \(1987\),1-102.)J72 367 :M1.549 .155(Goldberg, B.  "Generational Reference Counting: A Reduced-Communication Distributed Storage Reclamation)J89 378 :M.524 .052(Scheme".  ACM )Jf2_10 sf.634 .063(PLDI'89, Sigplan Not. 24)Jf0_10 sf.756 .076(,7 \(July\3121989\), 313-321.)J72 389 :M.807 .081(Inamura, Y., et al.  "Optimization Techniques Using the MRB and Their Evaluation on the Multi-PSI/V2".  )Jf2_10 sf.292(Logic)A89 400 :M.273 .027(Programming, Proc. North American Conf)Jf0_10 sf.212 .021(., MIT Press, 1989, 907-921.)J72 411 :M.088 .009(Kieburtz, R.B.  "Programming without pointer variables".  )Jf2_10 sf.096 .01(Proc. Conf. on Data: Abstraction, Definition and Structure,)J89 422 :M.372 .037(Sigplan Not. 11)Jf0_10 sf.356 .036( \(special issue 1976\), 95-107.)J72 433 :M.26 .026(Lafont, Y.  "The Linear Abstract Machine".  )Jf2_10 sf.304 .03(Theor. Comp. Sci. 59)Jf0_10 sf.348 .035( \(1988\), 157-180.)J72 444 :M.201 .02(Lema\224tre, M., )Jf2_10 sf.138 .014(et al)Jf0_10 sf.212 .021(.  "Mechanisms for Efficient Multiprocessor Combinator Reduction".  )Jf2_10 sf.196 .02(Lisp & Funct. Progr. 1986)Jf0_10 sf.059(,.)A72 455 :M.114 .011(Nilsen, K.  "Garbage collection of strings and linked data structures in real time".  )Jf2_10 sf.156 .016(SW\321Prac. & Exper. 18)Jf0_10 sf.168 .017(,7 \(1988\).)J72 466 :M.642 .064(Nishida, K., )Jf2_10 sf.486 .049(et al)Jf0_10 sf.704 .07(.  "Evaluation of MRB Garbage Collection on Parallel Logic Programming Architectures".  )Jf2_10 sf.238(Logic)A89 477 :M.436 .044(Programming, Proc. 7th Intl. Conf)Jf0_10 sf.371 .037(., MIT Press, 1990, 83-95.)J72 488 :M.356 .036(Park, Y.G., and Goldberg, B.  "Reference Escape Analysis: Optimizing Reference Counting based on the Lifetime of)J89 499 :M.177 .018(References".  )Jf2_10 sf.295 .029(Proc. PEPM'91)Jf0_10 sf.178 .018(, Yale Univ., June, 1991, 178-189.)J72 510 :M.097 .01(Shalit, A.  )Jf2_10 sf.218 .022(Dylan\252: An object-oriented dynamic language)Jf0_10 sf.156 .016(.  Apple Computer, Camb., MA, 1992.)J72 521 :M.437 .044(Steele, G.L.  "Fast Arithmetic in MacLisp".  AI Memo 421, MIT AI Lab., Camb., MA, Sept. 1977.)J72 532 :M.179 .018(Steele, G.L.  )Jf2_10 sf.274 .027(Common Lisp, The Language; 2nd Ed)Jf0_10 sf.228 .023(.  Digital Press, Bedford, MA, 1990.)J72 543 :M.207 .021(Stoye, W.R., )Jf2_10 sf.148 .015(et al)Jf0_10 sf.193 .019(.  "Some practical methods for rapid combinator reduction".  )Jf2_10 sf.208 .021(Lisp & Funct. Progr. Conf)Jf0_10 sf.218 .022(. 1984.)J72 554 :M.364 .036(Strom, R.E.  "Mechanisms for Compile-Time Enforcement of Security".  )Jf2_10 sf.38 .038(Proc. ACM POPL 10)Jf0_10 sf.309 .031(, Jan. 1983.)J72 565 :M.842 .084(Strom, R.E., and Yemini, S.  "Typestate: A Programming Language Concept for Enhancing Software Reliability".)J89 576 :Mf2_10 sf.539 .054(IEEE Trans. SW Engrg. SE-12)Jf0_10 sf.656 .066(,1 \(Jan.\3121986\), 157-171.)J72 587 :M.143 .014(Wadler, P.  "Is there a use for linear logic?".  )Jf2_10 sf.293 .029(Proc. ACM PEPM'91)Jf0_10 sf.214 .021(, New Haven, June 1991, 255-273.)J72 598 :M.969 .097(Wakeling, D., and Runciman, C.  "Linearity and Laziness".  )Jf2_10 sf1.155 .116(Proc. Funct. Progr. & Computer Arch.)Jf0_10 sf1.071 .107(, LNCS 523,)J89 609 :M.153 .015(Springer-Verlag, Aug. 1991, 215-240.)J72 620 :M.287 .029(Wise, D.S., and Friedman, D.P.  "The one-bit reference count".  )Jf2_10 sf.333 .033(BIT 17)Jf0_10 sf.441 .044(,3 \(Sept.\3121977\), 351-359.)J72 631 :M.15 .015(Wise, D.S.  "Stop-and-copy and One-bit Reference Counting".  TR-360, Indiana U., Bloomington, IN, Oct. 1992.)J72 642 :M.261 .026(Yuasa, T.  "Design and Implementation of Kyoto Common Lisp".  )Jf2_10 sf.231 .023(J. Info. Proc. 13)Jf0_10 sf.341 .034(,3 \(1990\), 284-295.)J72 658 :Mf5_10 sf.158 .016(APPENDIX I.\312\312A SHORT TUTORIAL ON "LINEAR" LISP)J72 673 :Mf0_10 sf.807 .081(Linear Lisp is a style of Lisp in which every bound name is referenced exactly once.  Thus, each parameter of a)J72 684 :M.317 .032(function is used just once, as is each name introduced via other binding constructs such as )Jf6_9 sf.119(let)Af0_10 sf.092 .009(, )Jf6_9 sf.119(let*)Af0_10 sf.227 .023(, etc.  A linear)J72 695 :M.255 .026(language requires work from the programmer to make explicit any copying or deletion, but he is paid back by better)J72 706 :M-.005(error checking during compilation and better utilization of resources \(time, space\) at run-time.  Unlike Pascal, Ada, C,)A72 717 :M-.099(and other languages providing explicit deletion, however, )Af2_10 sf-.103(a linear language cannot have dangling references)Af0_10 sf(.)Sendp%%Page: 6 6%%BeginPageSetupinitializepage(Henry Baker; page: 6 of 6)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.143 .014(ACM )Jf2_12 sf.2 .02(Sigplan Notices)Jf0_12 sf( )Sf3_12 sf.04(29)Af0_12 sf.137 .014(, 9 \(September 1994\), 38-43.)J72 754 :Mf0_10 sf.334 .033(Copyright \251 1993 by Nimble Computer Corporation)J318 754 :M(6)S513 754 :M.074(12/6/94)A72 85 :M-.036(The )Af6_9 sf-.043(identity)Af0_10 sf-.029( function is already linear, but )Af6_9 sf-.043(five)Af0_10 sf-.031( must dispose of its argument before returning the value )Af6_9 sf(5)Sf0_10 sf(:)S72 99 :Mf6_9 sf-.418(\(defun identity \(x\) x\))A72 109 :M-.403(\(defun five \(x\) \(kill x\) 5\)           ; a true Linear Lisp would use "x" instead of "\(kill x\)")A72 124 :Mf0_10 sf.163 .016(The )Jf6_9 sf.068(kill)Af0_10 sf.191 .019( function, which returns )Jf2_10 sf.063(no)Af0_10 sf.214 .021( values, provides an appropriate "boundary condition" for the parameter )Jf6_9 sf.068(x)Af0_10 sf.117 .012(.  The)J72 135 :M-.055(appearance of )Af6_9 sf-.071(kill)Af0_10 sf-.042( in )Af6_9 sf-.071(five)Af0_10 sf-.047( signifies )Af2_10 sf-.053(non-linearity)Af0_10 sf-.05(.  \(See below for a definition of )Af6_9 sf-.071(kill)Af0_10 sf-.077(\).)A72 150 :M-.036(The )Af6_9 sf-.043(square)Af0_10 sf-.031( function requires )Af2_10 sf-.038(two)Af0_10 sf-.032( occurrences of its argument, and is therefore also non-linear.  A second copy can be)A72 161 :M.707 .071(obtained by use of the )Jf6_9 sf.307(dup)Af0_10 sf.892 .089( function, which accepts one argument and returns )Jf2_10 sf.274(two)Af0_10 sf.86 .086( values\321i.e., two copies of its)J72 172 :M-.017(argument.  \(See below for a definition of )Af6_9 sf-.023(dup)Af0_10 sf-.015(\).  The )Af6_9 sf-.023(square)Af0_10 sf-.018( function follows:)A72 186 :Mf6_9 sf-.424(\(defun square \(x\))A72 196 :M-.403(  \(let* \(\(x x-prime \(dup x\)\)\)         ; Use Dylan-style syntax for multiple values [Shalit92].)A72 206 :M-.421(    \(* x x-prime\)\)\))A72 221 :Mf0_10 sf1.786 .179(Conditional expressions such as )Jf6_9 sf.532(if)Af0_10 sf1.472 .147(-expressions require a bit of sophistication.  Since only one "arm" of the)J72 233 :M.566 .057(conditional will be executed, we relax the "one-occurrence" linearity condition to allow a reference in both arms.)Jf0_9 sf0 -3 rm(5)S0 3 rm72 244 :Mf0_10 sf.294 .029(One should immediately see that linearity implies that an occurrence in one arm )Jf2_10 sf.221 .022(if and only if)Jf0_10 sf.278 .028( there is an occurrence)J72 255 :M.182 .018(in the other arm.  \(This condition is similar to that for )Jf2_10 sf.059(typestates)Af0_10 sf.34 .034( [Strom83] [Strom86]\).)J72 270 :M.087 .009(The boolean expression part of an )Jf6_9 sf.032(if)Af0_10 sf.105 .01(-expression requires more sophistication.  Strict linearity requires that any name)J72 281 :M-.037(used in the boolean part of an )Af6_9 sf-.051(if)Af0_10 sf-.039(-expression be counted as an occurrence.  However, many predicates are "shallow", in)A72 292 :M-.007(that they examine only a small \(i.e., shallow\) portion of their arguments \(e.g., )Af6_9 sf(null)Sf0_10 sf(, )Sf6_9 sf(zerop)Sf0_10 sf-.007(\), and therefore a modified)A72 303 :M.51 .051(policy is required.  We have not yet found the best syntax to solve this problem, but provisionally use several new)J72 314 :Mf6_9 sf-.037(if)Af0_10 sf-.026(-like expressions: )Af6_9 sf-.037(if-atom)Af0_10 sf(, )Sf6_9 sf-.037(if-null)Af0_10 sf(, )Sf6_9 sf-.037(if-zerop)Af0_10 sf-.024(, etc.  These )Af6_9 sf-.037(if)Af0_10 sf-.027(-like expressions require that the boolean part be a)A72 325 :M.686 .069(simple name, which does not count towards the "occur-once" linearity condition.  This modified rule allows for a)J72 337 :M-.001(shallow condition to be tested, and then the name can be reused within the arms of the conditional.)Af0_9 sf0 -3 rm(6)S0 3 rm72 352 :Mf0_10 sf-.026(We require a mechanism to )Af2_10 sf-.023(linearly)Af0_10 sf-.023( extract both components of a Lisp cons cell, since a use of )Af6_9 sf-.032(\(car\312x\))Af0_9 sf( )Sf0_10 sf-.027(precludes the)A72 363 :M.68 .068(use of )Jf6_9 sf.372(\(cdr\312x\))Af0_10 sf.921 .092(, and vice versa, due to the requirement for a single occurrence of )Jf6_9 sf.372(x)Af0_10 sf.971 .097(.  We therefore introduce a)J72 374 :M.883 .088("destructuring let" operation )Jf6_9 sf.246(dlet*)Af0_10 sf.593 .059(, which takes a series of binding pairs and a body, and binds the names in the)J72 385 :M.197 .02(binding pairs before executing the body.  Each binding pair consists of a pattern and an expression; the expression is)J72 396 :M.379 .038(evaluated to a value, and the result is matched to the pattern, which consists of list structure with embedded names.)J72 407 :M.285 .028(The list structure must match to the value, and the names are then bound to the portions of the list structure as if the)J72 418 :M.306 .031(pattern had been )Jf2_10 sf.083(unified)Af0_10 sf.304 .03( with the value.  Linearity requires that a name appear only once within a particular pattern.)J72 429 :M.569 .057(Linearity also requires that each name bound by a )Jf6_9 sf.213(dlet*)Af0_9 sf.081 .008( )Jf0_10 sf.607 .061(binding pair must occur either within an expression in a)J72 440 :M.611 .061(succeeding binding pair, or within the body of the )Jf6_9 sf.23(dlet*)Af0_9 sf.087 .009( )Jf0_10 sf.655 .065(itself.  Using these constructs, we can now program the)J72 451 :Mf6_9 sf-.183(append)Af0_10 sf-.124( and factorial \()Af6_9 sf-.183(fact)Af0_10 sf-.141(\) functions:)A72 465 :Mf6_9 sf-.403(\(defun lappend \(x y\)                                              ; append for "linear" lists.)A72 475 :M-.403(  \(if-null x \(progn \(kill x\) y\)                                                 ; trivial kill)A72 485 :M-.403(    \(dlet* \(\(\(carx . cdrx\) x\)\)                                  ; disassociate top-level cons.)A72 495 :M-.403(      \(cons carx \(lappend cdrx y\)\)\)\)\)     ; this cons will be optimized to reuse input cell x.)A72 509 :M-.427(\(defun fact \(n\))A72 519 :M-.403(  \(if-zerop n \(progn \(kill n\) 1\)                                               ; trivial kill.)A72 529 :M-.403(    \(let* \(\(n n-prime \(dup n\)\)\)                           ; Dylan-style multiple-value syntax.)A72 539 :M-.411(      \(* n \(fact \(1- n-prime\)\)\)\)\)\))A72 554 :Mf0_10 sf-.038(Below we show one way to program the )Af6_9 sf-.047(kill)Af0_10 sf-.034( and )Af6_9 sf-.047(dup)Af0_10 sf-.037( functions.)A72 568 :Mf6_9 sf-.399(\(defun kill \(x\)             ; Return )Af7_9 sf-.399(no)Af6_9 sf-.406( values.  Expensive way to decrement a reference count.)A72 578 :M-.415(  \(if-atom x \(kill-atom x\))A72 588 :M-.412(    \(dlet* \(\(\(carx . cdrx\) x\)\))A72 598 :M-.412(      \(kill carx\) \(kill cdrx\)\)\)\))A72 612 :M-.403(\(defun dup \(x\)               ; Return 2 values.  Expensive way to increment a reference count.)A72 622 :M-.415(  \(if-atom x \(dup-atom x\))A72 632 :M-.412(    \(dlet* \(\(\(carx . cdrx\) x\)\))A72 642 :M-.404(      \(let* \(\(carx carx-prime \(dup carx\)\) \(cdrx cdrx-prime \(dup cdrx\)\)\))A72 652 :M-.403(        \(share-if-possible \(cons carx cdrx\) \(cons carx-prime cdrx-prime\)\)\)\)\)\)   ; reuse input.)A-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 674.24 -.24 .24 215.24 674 .24 72 674 @a72 689 :Mf0_9 sf(5)Sf0_10 sf0 3 rm-.013(Any use of parallel or )A0 -3 rmf2_10 sf0 3 rm-.014(speculative)A0 -3 rmf0_10 sf0 3 rm-.014( execution of the arms of the conditional would require strict linearity, however.)A0 -3 rm72 704 :Mf0_9 sf.418(6)Af0_10 sf0 3 rm1.344 .134(Although this rule seems a bit messy, it is equivalent to having the shallow predicate return )J0 -3 rmf2_10 sf0 3 rm.447(two)A0 -3 rmf0_10 sf0 3 rm1.365 .136( values: the)J0 -3 rm72 718 :M(predicate itself and the unmodified argument.  This policy is completely consistent with linear semantics.)Sendp%%Trailerend%%EOF