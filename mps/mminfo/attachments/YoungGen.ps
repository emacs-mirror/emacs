%!PS-Adobe-3.0
%%Title: (YoungGen.word)
%%Creator: (Microsoft Word: LaserWriter 8 8.2)
%%CreationDate: (7:25 PM Tuesday, December 6, 1994)
%%For: (Henry Baker)
%%Pages: 3
%%DocumentFonts: Times-Roman Times-Italic Times-Bold Helvetica Symbol
%%DocumentNeededFonts: Times-Roman Times-Italic Times-Bold Helvetica Symbol
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%%DocumentMedia: Default 612 792 0 () ()
%ADO_ImageableArea: 31 31 583 761
%%EndComments
userdict begin/dscInfo 5 dict dup begin
/Title(YoungGen.word)def
/Creator(Microsoft Word: LaserWriter 8 8.2)def
/CreationDate(7:25 PM Tuesday, December 6, 1994)def
/For(Henry Baker)def
/Pages 1 def
end def end

save 
/version23-manualfeedpatch where { pop false } { true }ifelse
 % we don't do an explicit 'get' since product and version MAY
 % be in systemdict or statusdict - this technique gets the lookup
 % without failure
statusdict begin
  product (LaserWriter) eq        % true if LaserWriter
  version cvr 23.0 eq             % true if version 23
end

and  % only install this patch if both are true
and  % true only if patch is not installed and is for this printer
     % save object and boolean on stack
dup { exch restore }if
% either true OR saveobject false
dup
{
  /version23-manualfeedpatch true def
  /oldversion23-showpage /showpage load def
  /showpage       % this showpage will wait extra time if manualfeed is true
  {%
     statusdict /manualfeed known
     {% manualfeed known in statusdict
        statusdict /manualfeed get
        {% if true then we loop for 5 seconds
           usertime 5000 add       % target usertime
           { % loop
             dup usertime sub 0 lt
             { exit }if
           }loop
           pop             % pop the usertime off the stac
        }if
     }if
     oldversion23-showpage
  }bind def
}if
not{ restore }if

/md 148 dict def md begin/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 81 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if end
%%EndProlog
%%BeginSetup
md begin
countdictstack[{
%%BeginFeature: *ManualFeed False
statusdict /manualfeed false put
%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *InputSlot Cassette

%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *PageRegion LetterSmall
lettersmall
%%EndFeature
}featurecleanup
(Henry Baker)setjob
/mT[1 0 0 -1 31 761]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Times-Roman
%%IncludeFont: Times-Italic
%%IncludeFont: Times-Bold
%%IncludeFont: Helvetica
%%IncludeFont: Symbol
/f0_1/Times-Roman
:mre
/f0_12 f0_1 12 scf
/f0_10 f0_1 10 scf
/f0_9 f0_1 9 scf
/f1_1/Times-Italic
:mre
/f1_12 f1_1 12 scf
/f1_10 f1_1 10 scf
/f2_1/Times-Bold
:mre
/f2_12 f2_1 12 scf
/f3_1/Helvetica
:mre
/f3_14 f3_1 14 scf
/f3_12 f3_1 12 scf
/f3_9 f3_1 9 scf
/f4_1/Symbol
:bsr
240/apple pd
:esr
/f4_10 f4_1 10 scf
/f4_8 f4_1 8 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(Henry Baker; page: 1 of 3)setjob
%%EndPageSetup
gS 0 0 552 730 rC
41 19 :M
f0_12 sf
.442 .044(ACM )J
f1_12 sf
.618 .062(Sigplan Notices)J
f0_12 sf
.056 .006( )J
f2_12 sf
.122(28)A
f0_12 sf
.531 .053(,4 \(April\3121993\), 55-57.)J
41 722 :M
-.059(Copyright \251 1992 by Nimble Computer Corporation.)A
507 722 :M
(1)S
41 58 :M
f3_14 sf
.353 .035('Infant Mortality')J
f0_9 sf
0 -5 rm
(1)S
0 5 rm
f3_14 sf
.319 .032( and Generational Garbage Collection)J
41 81 :M
f3_12 sf
.099 .01(Henry G. Baker)J
41 98 :M
f3_9 sf
-.038(Nimble Computer Corporation, 16231 Meadow Ridge Way, Encino, CA  91436 \(818\) 501-4956\312\312\(818\) 986-1360 \(FAX\))A
39 102 -1 1 515 101 1 39 101 @a
41 116 :M
f0_12 sf
.572 .057(Generation-based garbage collection has been advocated by appealing to the intuitive but vague)J
41 128 :M
1.122 .112(notion that "young objects are more likely to die than old objects".  The intuition is, that if a)J
41 140 :M
-.031(generation-based garbage collection scheme focuses its effort on scanning recently created objects,)A
41 152 :M
-.061(then its scanning efforts will pay off more in the form of more recovered garbage, than if it scanned)A
41 164 :M
-.03(older objects.  In this note, we show a counterexample of a system in which "infant mortality" is as)A
41 176 :M
.275 .028(high as you please, but for which generational garbage collection is ineffective for improving the)J
41 188 :M
.924 .092(average mark/cons ratio.  Other benefits, such as better locality and a smaller number of large)J
41 200 :M
-.103(delays, may still make generational garbage collection attractive for such a system, however.)A
39 205 -1 1 515 204 1 39 204 @a
41 220 :M
f3_12 sf
.12(Introduction)A
41 237 :M
f0_12 sf
.832 .083(In the decade since generational garbage collection was first proposed in print [Lieberman and)J
41 249 :M
.281 .028(Hewitt 83], a number of papers \(including some of my own\) have introduced their discussions of)J
41 261 :M
.6 .06(generational garbage collection by statements such as "between 80 and 98 percent of all newly-)J
41 273 :M
.371 .037(allocated objects die within a few million instructions", or "most newly created cells die young".)J
41 285 :M
-.024(While this intuition is sometimes backed up by measurements which "prove" the effectiveness of a)A
41 297 :M
.071 .007(particular generational scheme, there are very few theoretical models by which we can reasonably)J
41 309 :M
-.096(compare one generational scheme with another, or with non-generational schemes.)A
41 326 :M
1.205 .12(We show via a counterexample that the quoted statements above are essentially meaningless,)J
41 338 :M
-.05(because a meaningful discussion of age-based garbage collection schemes requires the presentation)A
41 350 :M
.685 .069(of significantly more data in the form of complete object lifetime probability density functions,)J
41 362 :M
-.075(rather than the one or two data points usually proffered.)A
41 380 :M
f3_12 sf
1.059 .106(Generational Garbage Collection)J
41 397 :M
f0_12 sf
-.055(Traditional non-generational tracing garbage collection schemes require time for a single collection)A
41 409 :M
-.048(which is proportional to the number of cells still in use, with an additional \(usually negligible\) term)A
41 421 :M
.021 .002(proportional to the total amount of storage under management.  Depending upon the time between)J
41 433 :M
.238 .024(such "full" garbage collections, one may allocate a large number of cells and then recover a large)J
41 445 :M
.057 .006(number of garbage cells at the end of the collection.  Thus, to a first-order approximation, the cost)J
41 457 :M
.354 .035(of this traditional garbage collection scheme per cell allocated is proportional to the "mark/cons")J
41 469 :M
-.086(ratio\321the more marking we perform per cell allocated, the lower the fraction of execution time will)A
41 481 :M
-.093(be spent marking, but the larger the total amount of space will be required to support N live cells.)A
41 498 :M
-.024(Generational garbage collection schemes attempt to take advantage of the intuition that "most cells)A
41 510 :M
.7 .07(that die, die young" by separating the objects into different categories based on their age; these)J
41 522 :M
.646 .065(categories are called )J
f1_12 sf
.171(generations)A
f0_12 sf
.538 .054(.  If the intuition is correct, and if most tracing/marking can be)J
41 534 :M
.672 .067(focussed on the younger generations, then the categorical schemes can achieve a lower average)J
41 546 :M
1.453 .145(amount of tracing/marking work per object allocated and thereby achieve a net performance)J
41 558 :M
-.018(advantage over a non-categorical collector [DeTreville77].  In addition to these first-order savings,)A
41 570 :M
-.12(one can also achieve second-order savings of increased locality in the memory hierarchy because the)A
41 582 :M
1.153 .115(more localized tracing work is less likely to disrupt the residence of live objects in the faster)J
41 594 :M
-.108(memories/caches.)A
41 611 :M
-.129(To summarize, generational garbage collection has been advocated for at least three reasons:)A
41 623 :M
-.079(\312\245\312generational garbage collection can reduce the mark/cons ratio in some applications)A
41 635 :M
-.057(\312\245\312generational GC can improve the locality of reference over a non-generational GC)A
41 647 :M
-.001(\312\245\312generational GC has many small pauses instead of a few large pauses)A
-4127 -4126 -1 1 -4125 -4126 1 -4127 -4127 @a
41 667.24 -.24 .24 184.24 667 .24 41 667 @a
41 684 :M
f0_9 sf
(1)S
f0_10 sf
0 3 rm
.135 .013(Can't computer scientists come up with less grisly names for these concepts?)J
0 -3 rm
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(Henry Baker; page: 2 of 3)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.442 .044(ACM )J
f1_12 sf
.618 .062(Sigplan Notices)J
f0_12 sf
.056 .006( )J
f2_12 sf
.122(28)A
f0_12 sf
.531 .053(,4 \(April\3121993\), 55-57.)J
72 753 :M
-.059(Copyright \251 1992 by Nimble Computer Corporation.)A
538 753 :M
(2)S
72 87 :M
f3_12 sf
.296 .03("Radioactive Decay" Model of Object Lifetimes)J
72 104 :M
f0_12 sf
.606 .061(Let us consider an application whose objects die through a process analogous to the radioactive)J
72 116 :M
.096 .01(decay process found in unstable physical isotopes.  \(An application with these characteristics may)J
72 128 :M
.706 .071(not be prototypical of garbage-collected applications, but it does provide an ideal mathematical)J
72 140 :M
1.118 .112(model which can represent one end of a spectrum.\)  In such a process, the probability of any)J
72 152 :M
-.094(particular object decaying within a particular period of time is related to the length of the period, but)A
72 164 :M
.279 .028(not to the particular particle, or to the existing age of the particle.  In particular, such a process is)J
72 176 :M
.02 .002(oblivious to the age already achieved by a particle, but depends solely upon whether it has already)J
72 188 :M
.441 .044("decayed".  Such a decay process has but one parameter\321its "half life" )J
f4_10 sf
.107(t)A
f0_12 sf
.369 .037(, which is the period of)J
72 200 :M
1.133 .113(time during which half of its particles can be expected to decay, and therefore the number of)J
72 212 :M
.66 .066(particles likely to decay in any short period of time is proportional to the number of undecayed)J
72 224 :M
1.032 .103(particles still left.  Thus, if N)J
f0_9 sf
0 3 rm
.312(0)A
0 -3 rm
f0_12 sf
1.135 .113( is the number of particles at t=0, then the expected number of)J
72 239 :M
-.101(particles still undecayed at any time t>0 is a simple negative exponential function N)A
f0_9 sf
0 3 rm
-.096(0)A
0 -3 rm
f0_12 sf
-.108<A532>A
f0_9 sf
0 -4 rm
-.057(-t/)A
0 4 rm
f4_8 sf
0 -4 rm
-.075(t)A
0 4 rm
f0_12 sf
(.)S
72 257 :M
-.053(Now consider such an application in which new particles are continually being added/created at the)A
72 270 :M
-.003(same rate that particles are decaying.  The average number of particles is then constant over time.)A
f0_9 sf
0 -3 rm
(2)S
0 3 rm
72 282 :M
f0_12 sf
.377 .038(In this situation, the same propensity of an object to die independent of its achieved lifetime still)J
72 294 :M
-.046(holds.  In such a radioactive-like system, one will find it true that "most objects die young", and for)A
72 306 :M
.677 .068(any )J
f1_12 sf
.223(single)A
f0_12 sf
.768 .077( measurement of the form "only 2% of the objects survived 1 second", it is trivial to)J
72 318 :M
-.03(compute a "half life" consistent with this observation\321i.e., )A
f4_10 sf
(t)S
f0_12 sf
-.039(=177 msec.)A
72 335 :M
.204 .02(However, if one attempts to utilize a generational garbage collector for this application, one finds)J
72 347 :M
-.021(that no matter how the generations are chosen, the decay rate for each generation is proportional to)A
72 359 :M
1.308 .131(the size of the generation, not to its age, and therefore, the average mark/cons ratio for each)J
72 371 :M
-.115(generation is the same.  For such an application, a generational garbage collector cannot improve the)A
72 383 :M
-.079(average mark/cons ratio, and the additional overheads of generational collection may cause the total)A
72 395 :M
1.891 .189(amount of work to increase relative to a non-generational collector.  On the other hand, a)J
72 407 :M
.966 .097(generational garbage collector may show increased locality of reference, and/or better average)J
72 419 :M
1.733 .173(response, due to second-order effects.  Thus, it is very important for papers which provide)J
72 431 :M
.6 .06(measurements of garbage collection algorithms to document the mark/cons ratios, localities and)J
72 443 :M
-.106(other important parameters, in addition to total runtime and/or GC load.)A
72 461 :M
f3_12 sf
.266(Conclusions)A
72 478 :M
f0_12 sf
-.018(Generational garbage collection can often, within a given amount of storage, 1\) reduce the average)A
72 490 :M
-.088(mark/cons ratio, 2\) improve the locality of reference, and 3\) trade a small number of long pauses for)A
72 502 :M
.194 .019(many short pauses.  While the locality of reference improvement and the improved response time)J
72 514 :M
-.048(are available across a wide range of applications, a decreased load due to a reduced mark/cons time)A
72 526 :M
.314 .031(is less intuitively realized.  The statistics must be very far from equilibrium, the overheads of the)J
72 538 :M
.036 .004(generational scheme have to be very small, and the predictions of the generational scheme have to)J
72 550 :M
1.576 .158(be extremely good in order to produce any mark/cons benefit relative to a non-generational)J
72 562 :M
-.063(collector.  Furthermore, the vague appeals to intuition in the form "most objects die quickly" can be)A
72 574 :M
1.434 .143(shown to apply equally well to processes in which all generations produce exactly the same)J
72 586 :M
-.04(mark/cons ratios.)A
72 603 :M
1.216 .122(In the newest generation of microprocessors which incorporate a significant amount of cache)J
72 615 :M
.563 .056(memory, and for which a cache "miss" may cost more than 100 instructions, the "second order")J
72 627 :M
.774 .077(locality effects of generational garbage collection may be more important than the "first order")J
72 639 :M
-.1(effects of an improved mark/cons ratio.  For example, our stack-based "lazy allocation" generational)A
72 651 :M
-.027(scheme [Baker92] is highly integrated with the programming language implementation, and shares)A
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 676.24 -.24 .24 215.24 676 .24 72 676 @a
72 693 :M
f0_9 sf
(2)S
f0_10 sf
0 3 rm
.016 .002(We consider the simple situation in which a new particle is added/created )J
0 -3 rm
f1_10 sf
0 3 rm
(exactly)S
0 -3 rm
f0_10 sf
0 3 rm
.014 .001( when one decays.  The more likely)J
0 -3 rm
72 707 :M
.422 .042(situation in which only the )J
f1_10 sf
.717 .072(average rates)J
f0_10 sf
.458 .046( are equal leads to significant deviations from the constant number of live)J
72 718 :M
-.092(particles and to second-order effects, although the first-order effects are the same.)A
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(Henry Baker; page: 3 of 3)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.442 .044(ACM )J
f1_12 sf
.618 .062(Sigplan Notices)J
f0_12 sf
.056 .006( )J
f2_12 sf
.122(28)A
f0_12 sf
.531 .053(,4 \(April\3121993\), 55-57.)J
72 753 :M
-.059(Copyright \251 1992 by Nimble Computer Corporation.)A
538 753 :M
(3)S
72 81 :M
.388 .039(most of its work with the existing programming language parameter-passing and value-returning)J
72 93 :M
-.073(mechanisms, and therefore avoids gratuitous non-local behavior.)A
72 110 :M
-.032(Our personal belief is that the object lifetimes found in garbage collection measurements cannot be)A
72 122 :M
-.132(adequately modelled by traditional probability/statistics models which assume that distributions have)A
72 134 :M
-.085(finite "standard deviations", but will require )A
f1_12 sf
-.085(fractal)A
f0_12 sf
-.095( models [Mandelbrot83], which can have infinite)A
72 146 :M
-.022(second moments.)A
72 164 :M
f3_12 sf
.189(Acknowlegements)A
72 181 :M
f0_12 sf
1.495 .149(Many thanks to the participants of the International Workshop on Memory Management '92)J
72 193 :M
-.062([Bekkers92] for their interesting and inspirational discussions.)A
72 211 :M
f3_12 sf
(REFERENCES)S
72 234 :M
f0_10 sf
.331 .033(Appel, A.W.  "Simple Generational Garbage Collection and Fast Allocation".  )J
f1_10 sf
.291 .029(Soft. Prac. & Exper. 19)J
f0_10 sf
.48 .048(,2 \(Feb.\3121989\),)J
89 245 :M
.025(171-183.)A
72 256 :M
.329 .033(Baker, H.G.  "List Processing in Real Time on a Serial Computer".  )J
f1_10 sf
.562 .056(CACM 21)J
f0_10 sf
.444 .044(,4 \(April 1978\), 280-294.)J
72 267 :M
.476 .048(Baker, H.G.  "CONS Should not CONS its Arguments, or, a Lazy Alloc is a Smart Alloc".  ACM )J
f1_10 sf
.608 .061(Sigplan Not. 27)J
f0_10 sf
.256(,3)A
89 278 :M
.663 .066(\(March\3121992\), 24-34.)J
72 289 :M
1.03 .103(Bekkers, Y., and Cohen, J. )J
f1_10 sf
.322(eds)A
f0_10 sf
.236 .024(.  )J
f1_10 sf
1.535 .153(Memory Management: Proceedings of the International Workshop on Memory)J
89 300 :M
.113(Management)A
f0_10 sf
.325 .033(, St. Malo, France.  Springer LNCS 637, 1992.)J
72 311 :M
.382 .038(Clark, D.W., and Green, C.C.  "An Empirical Study of List Structure in LISP".  )J
f1_10 sf
.646 .065(CACM 20)J
f0_10 sf
.58 .058(,2 \(Feb. 1977\),78-87.)J
72 322 :M
.157 .016(DeTreville, John.  "Reducing the Cost of Garbage Collection".  Unpublished manuscript, May, 1977.)J
72 333 :M
.693 .069(Lieberman, H., and Hewitt, C.  "A Real-Time Garbage Collector Based on the Lifetimes of Objects".  )J
f1_10 sf
1.079 .108(CACM 26)J
f0_10 sf
.342(,6)A
89 344 :M
.172 .017(\(June 1983\), 419-429.)J
72 355 :M
.067 .007(Mandelbrot, B.  )J
f1_10 sf
.087 .009(The Fractal Geometry of Nature)J
f0_10 sf
.074 .007(.  W.H.Freeman & Co., New York, 1983.)J
72 366 :M
.744 .074(Moon, D.  "Garbage Collection in a Large Lisp System".  )J
f1_10 sf
.91 .091(ACM Symp. on Lisp and Functional Prog)J
f0_10 sf
.885 .088(., Austin, TX,)J
89 377 :M
.51 .051(1984, 235-246.)J
72 388 :M
.424 .042(Unger, D.  "Generation Scavenging: A non-disruptive, high performance storage reclamation algorithm".  )J
f1_10 sf
.537 .054(ACM Soft.)J
89 399 :M
.501 .05(Eng. Symp. on Prac. Software Dev. Envs., Sigplan Not. 19)J
f0_10 sf
.582 .058(,6 \(June 1984\), 157-167.)J
72 410 :M
.727 .073(Wilson, Paul R.  "Some Issues and Strategies in Heap Management and Memory Hierarchies".  )J
f1_10 sf
.957 .096(ACM Sigplan Not.)J
89 421 :M
.043(26)A
f0_10 sf
.161 .016(,3 \(March 1991\), 45-52.)J
endp
%%Trailer
end
%%EOF
