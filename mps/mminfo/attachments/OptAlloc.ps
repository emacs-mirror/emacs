%!PS-Adobe-3.0%%Title: (OptAlloc.wrd)%%Creator: (Microsoft Word: LaserWriter 8 8.2)%%CreationDate: (5:02 PM Tuesday, December 6, 1994)%%For: (Henry Baker)%%Pages: 3%%DocumentFonts: Times-Roman Times-Italic Times-Bold Helvetica Courier Symbol%%DocumentNeededFonts: Times-Roman Times-Italic Times-Bold Helvetica Courier Symbol%%DocumentSuppliedFonts:%%DocumentData: Clean7Bit%%PageOrder: Ascend%%Orientation: Portrait%%DocumentMedia: Default 612 792 0 () ()%ADO_ImageableArea: 31 31 583 761%%EndCommentsuserdict begin/dscInfo 5 dict dup begin/Title(OptAlloc.wrd)def/Creator(Microsoft Word: LaserWriter 8 8.2)def/CreationDate(5:02 PM Tuesday, December 6, 1994)def/For(Henry Baker)def/Pages 1 defend def endsave /version23-manualfeedpatch where { pop false } { true }ifelse % we don't do an explicit 'get' since product and version MAY % be in systemdict or statusdict - this technique gets the lookup % without failurestatusdict begin  product (LaserWriter) eq        % true if LaserWriter  version cvr 23.0 eq             % true if version 23endand  % only install this patch if both are trueand  % true only if patch is not installed and is for this printer     % save object and boolean on stackdup { exch restore }if% either true OR saveobject falsedup{  /version23-manualfeedpatch true def  /oldversion23-showpage /showpage load def  /showpage       % this showpage will wait extra time if manualfeed is true  {%     statusdict /manualfeed known     {% manualfeed known in statusdict        statusdict /manualfeed get        {% if true then we loop for 5 seconds           usertime 5000 add       % target usertime           { % loop             dup usertime sub 0 lt             { exit }if           }loop           pop             % pop the usertime off the stac        }if     }if     oldversion23-showpage  }bind def}ifnot{ restore }if/md 126 dict def md begin/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if%%BeginFile: adobe_psp_basic%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved./bd{bind def}bind def/xdf{exch def}bd/xs{exch store}bd/ld{load def}bd/Z{0 def}bd/T/true/F/false/:L/lineto/lw/setlinewidth/:M/moveto/rl/rlineto/rm/rmoveto/:C/curveto/:T/translate/:K/closepath/:mf/makefont/gS/gsave/gR/grestore/np/newpath14{ld}repeat/$m matrix def/av 81 def/por true def/normland false def/psb-nosave{}bd/pse-nosave{}bd/us Z/psb{/us save store}bd/pse{us restore}bd/level2/languagelevel where{pop languagelevel 2 ge}{false}ifelsedef/featurecleanup{stoppedcleartomarkcountdictstack exch sub dup 0 gt{{end}repeat}{pop}ifelse}bd/noload Z/startnoload{{/noload save store}if}bd/endnoload{{noload restore}if}bdlevel2 startnoload/setjob{statusdict/jobname 3 -1 roll put}bd/setcopies{userdict/#copies 3 -1 roll put}bdlevel2 endnoload level2 not startnoload/setjob{1 dict begin/JobName xdf currentdict end setuserparams}bd/setcopies{1 dict begin/NumCopies xdf currentdict end setpagedevice}bdlevel2 not endnoload/pm Z/mT Z/sD Z/realshowpage Z/initializepage{/pm save store mT concat}bd/endp{pm restore showpage}def/$c/DeviceRGB def/rectclip where{pop/rC/rectclip ld}{/rC{np 4 2 roll:M1 index 0 rl0 exch rlneg 0 rl:Kclip np}bd}ifelse/rectfill where{pop/rF/rectfill ld}{/rF{gSnp4 2 roll:M1 index 0 rl0 exch rlneg 0 rlfillgR}bd}ifelse/rectstroke where{pop/rS/rectstroke ld}{/rS{gSnp4 2 roll:M1 index 0 rl0 exch rlneg 0 rl:KstrokegR}bd}ifelse%%EndFile%%BeginFile: adobe_psp_colorspace_level1%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved./G/setgray ld/:F/setrgbcolor ld%%EndFile%%BeginFile: adobe_psp_basic_text%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved./S/show ld/A{0.0 exch ashow}bd/R{0.0 exch 32 exch widthshow}bd/W{0.0 3 1 roll widthshow}bd/J{0.0 32 4 2 roll 0.0 exch awidthshow}bd/V{0.0 4 1 roll 0.0 exch awidthshow}bd/fcflg true def/fc{fcflg{vmstatus exch sub 50000 lt{(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store}if pop}if}bd/$f[1 0 0 -1 0 0]def/:ff{$f :mf}bd/MacEncoding StandardEncoding 256 array copy defMacEncoding 39/quotesingle putMacEncoding 96/grave put/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caronMacEncoding 128 128 getinterval astore poplevel2 startnoload/copyfontdict{findfont dup length dictbegin{1 index/FID ne{def}{pop pop}ifelse}forall}bdlevel2 endnoload level2 not startnoload/copyfontdict{findfont dup length dictcopybegin}bdlevel2 not endnoloadmd/fontname known not{/fontname/customfont def}if/Encoding Z/:mre{copyfontdict/Encoding MacEncoding deffontname currentdictenddefinefont :ff def}bd/:bsr{copyfontdict/Encoding Encoding 256 array copy defEncoding dup}bd/pd{put dup}bd/:esr{pop popfontname currentdictenddefinefont :ff def}bd/scf{scalefont def}bd/scf-non{$m scale :mf setfont}bd/ps Z/fz{/ps xs}bd/sf/setfont ld/cF/currentfont ld/mbf{/makeblendedfont where{popmakeblendedfont/ABlend exch definefont}{pop}ifelsedef}def%%EndFile/currentpacking where {pop sc_oldpacking setpacking}if end%%EndProlog%%BeginSetupmd begincountdictstack[{%%BeginFeature: *ManualFeed Falsestatusdict /manualfeed false put%%EndFeature}featurecleanupcountdictstack[{%%BeginFeature: *InputSlot Cassette%%EndFeature}featurecleanupcountdictstack[{%%BeginFeature: *PageRegion LetterSmalllettersmall%%EndFeature}featurecleanup(Henry Baker)setjob/mT[1 0 0 -1 31 761]def/sD 16 dict def300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse%%IncludeFont: Times-Roman%%IncludeFont: Times-Italic%%IncludeFont: Times-Bold%%IncludeFont: Helvetica%%IncludeFont: Courier%%IncludeFont: Symbol/f0_1/Times-Roman:mre/f0_12 f0_1 12 scf/f0_10 f0_1 10 scf/f0_9 f0_1 9 scf/f1_1/Times-Italic:mre/f1_12 f1_1 12 scf/f1_10 f1_1 10 scf/f2_1/Times-Bold:mre/f2_12 f2_1 12 scf/f3_1/Helvetica:mre/f3_18 f3_1 18 scf/f4_1/Courier:mre/f4_10 f4_1 10 scf/f5_1/Symbol:bsr240/apple pd:esr/f5_12 f5_1 12 scf/Courier findfont[10 0 0 -10 0 0]:mf setfont%%EndSetup%%Page: 1 1%%BeginPageSetupinitializepage(Henry Baker; page: 1 of 3)setjob%%EndPageSetupgS 0 0 552 730 rC41 22 :Mf0_10 sf.398 .04(From )Jf1_10 sf.445 .044(Artificial Intelligence, An MIT Perspective, Vol. 2)Jf0_10 sf.305 .031(.  Winston & Brown, )Jf1_10 sf.11(eds)Af0_10 sf.398 .04(., MIT Press, 1979, pp. 391-396.)J287 722 :Mf0_12 sf(1)S41 63 :Mf3_18 sf-.115(Optimizing Allocation and Garbage Collection of Spaces)A41 94 :Mf0_12 sf.634 .063(Henry G. Baker, Jr.)J41 131 :Mf2_12 sf2.739 .274(Space Management Problems)J41 151 :Mf0_12 sf.766 .077(MACLISP, unlike some other implementations of LISP, allocates storage for different types of)J41 163 :M-.055(objects in noncontiguous areas called )Af1_12 sf-.061(spaces)Af0_12 sf-.053(.  These spaces partition the active storage into disjoint)A41 175 :M-.066(areas, each of which holds a different type of object.  For example, )Af1_12 sf-.056(list cells)Af0_12 sf-.068( are stored in one space,)A41 187 :Mf1_12 sf-.043(full-word integers)Af0_12 sf-.041( reside in another space, )Af1_12 sf-.044(full-word floating point numbers)Af0_12 sf-.044( in another, and so on.)A41 207 :M.246 .025(Allocating space in this manner has several advantages.  An object's type can easily be computed)J41 219 :M.205 .02(from a pointer to it, without any memory references to the object itself.  Thus, the LISP primitive)J41 231 :Mf4_10 sf-.094(ATOM\(x\) )Af0_12 sf-.075(can easily compute its result without even paging in )Af4_10 sf-.094(x)Af0_12 sf-.075(.  Another advantage is that the type)A41 243 :M.358 .036(of an object does not require any storage within the object, so that arithmetic with hardware data)J41 255 :M-.064(types such as full-word integers can use hardware instructions directly.)A41 275 :M-.012(There are problems associated with this method of storage and type management, however.  When)A41 287 :M.335 .033(all data types are allocated from the same heap, there is no problem with varying demand for the)J41 299 :M-.038(different data types; all data types require storage from the same pool, so that only the total amount)A41 311 :M-.084(of storage is important.  Once different data types must be allocated from different spaces, however,)A41 323 :M-.111(the relative sizes of the spaces becomes important.)A41 343 :M-.042(We would like to find optimal policies for deciding in what ratios the spaces should be allocated so)A41 355 :M.469 .047(that garbage collection is minimized.  Suppose, for example, that a program is in an equilibrium)J41 367 :M.833 .083(situation, where the rate of storage allocation for each data type is equal to the rate of garbage)J41 379 :M.162 .016(generation for that data type.  Suppose further that the rate r)Jf0_9 sf0 2 rm(1)S0 -2 rmf0_12 sf.122 .012( for data type 1 is twice the rate r)Jf0_9 sf0 2 rm(2)S0 -2 rmf0_12 sf.105 .011( of)J41 391 :M.231 .023(data type 2, and that the number of free words in both spaces is the same.  Then the program will)J41 403 :M-.015(continually run out of data type 1 before data type 2.  Suppose now that we halve the free words in)A41 415 :M.232 .023(space 2.  The user program will now run out of both kinds equally often, Furthermore, the timing)J41 427 :M.296 .03(and amount of garbage collection will be the same as before because the additional free words in)J41 439 :M-.026(space 2 were never used.)A41 459 :M-.137(This analysis gives the key to optimal allocation for an equilibrium situation: balance the free storage)A41 471 :M.018 .002(for each data type against the rate of use of that data type.  In other words, make all spaces run out)J41 483 :M-.075(of free words at the same time.)A41 503 :M-.131(The calculation of optimal space size is now simple algebra.  Let:)A177 523 :M-.073(r)Af0_9 sf0 2 rm(i)S0 -2 rmf0_12 sf-.086( be the rate of word usage for data type i;)A172 535 :M-.147(F)Af0_9 sf0 2 rm-.055(i)A0 -2 rmf0_12 sf-.103( be the free words available for data type i;)A169 547 :M-.097(F be the free words available to all data types.)A41 567 :M-.134(Then for optimal allocation,)A245 591 :M.331(F)Af0_9 sf0 2 rm.124(i)A0 -2 rmf0_12 sf.412 .041( = \(r)Jf0_9 sf0 2 rm.124(i)A0 -2 rmf0_12 sf.166(/)Af5_12 sf.353(S)Af0_12 sf.198(r)Af0_9 sf0 2 rm.124(j)A0 -2 rmf0_12 sf.53(\)F)A41 609 :Mf2_12 sf3.773 .377(Intelligent Allocation)J41 629 :Mf0_12 sf.211 .021(The question now is: "How can the rate of free storage usage for each data type be measured?" A)J41 641 :M-.02("cons-counter" could be implemented for each data type, which would count the cells allocated for)A41 653 :M.588 .059(that data type, but in MACLISP this measurement is better made by the garbage collector.  The)J41 665 :Mf4_10 sf-.086(gc-daemon)Af0_12 sf-.067( interrupt, which is triggered by each garbage collection, invokes the )Af4_10 sf-.086(gc-daemon)Af0_12 sf-.079( with an)A41 677 :M-.086(argument which associates with each space four quantities: the number of words free and the size of)Aendp%%Page: 2 2%%BeginPageSetupinitializepage(Henry Baker; page: 2 of 3)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 53 :Mf0_10 sf.398 .04(From )Jf1_10 sf.445 .044(Artificial Intelligence, An MIT Perspective, Vol. 2)Jf0_10 sf.305 .031(.  Winston & Brown, )Jf1_10 sf.11(eds)Af0_10 sf.398 .04(., MIT Press, 1979, pp. 391-396.)J318 753 :Mf0_12 sf(2)S72 81 :M1.367 .137(that space, both before and after the garbage collection.  This information, together with the)J72 93 :M-.08(information from the )Af4_10 sf-.098(gc-daemon)Af0_12 sf-.078( argument at the previous garbage collection, allows us to calculate)A72 105 :M1.205 .12(the average rates of free storage usage for each space since the last garbage collection.  This)J72 117 :M1.639 .164(information allows us to use the )Jf4_10 sf.584(ALLOC)Af0_12 sf1.669 .167( function to reallocate free storage to each space in)J72 129 :M-.028(proportion to its usage.)A72 149 :M-.095(PDP-10 MACLISP presents another problem when reallocating.  Since it does not use a compacting)A72 161 :M.543 .054(garbage collector, the spaces can he expanded, but never contracted.  Therefore, the )Jf4_10 sf.195(gc-daemon)A72 173 :Mf0_12 sf-.106(must be conservative in its reallocation strategy, because it can not back down on an allocation.)A72 193 :M.267 .027(Suppose that we wish to achieve an overall garbage collection efficiency of m words allocated to)J72 205 :M.356 .036(each word traced.  This means that if the total storage used by accessible structures consists of T)J72 217 :M1.046 .105(words, then we wish to have \(1+m\)T words allocated to the various spaces, in total.  In other)J72 229 :M-.02(words, F=mT words are free and should be divided among the spaces for their free areas.  Now we)A72 241 :M.372 .037(have determined that the free storage for each space should be proportional to the rate of storage)J72 253 :M-.099(allocation in that space.  Therefore,)A272 277 :M.189(F)Af0_9 sf0 2 rm.071(i)A0 -2 rmf0_12 sf.236 .024( = \(r)Jf0_9 sf0 2 rm.071(i)A0 -2 rmf0_12 sf.095(/)Af5_12 sf.202(S)Af0_12 sf.113(r)Af0_9 sf0 2 rm.071(j)A0 -2 rmf0_12 sf.293(\)mT)A72 298 :M.139 .014(Now since spaces can be expanded but not contracted, we need only make sure that space i has )Jf1_12 sf.077(at)A72 310 :M-.016(least)Af0_12 sf( F)Sf0_9 sf0 2 rm(i)S0 -2 rmf0_12 sf-.017( free words.  This is achieved through the )Af4_10 sf-.021(gcsize)Af0_12 sf(, )Sf4_10 sf-.021(gcmax)Af0_12 sf-.016(, and )Af4_10 sf-.021(gcmin)Af0_12 sf-.017( parameters of )Af4_10 sf-.021(ALLOC)Af0_12 sf(.)S72 330 :M.139 .014(In MACLISP, one can communicate one's intentions with regard to the management of a space to)J72 342 :M1.295 .129(the system by calling a function )Jf4_10 sf.463(ALLOC)Af0_12 sf1.159 .116( with the space name and 3 parameters.  The )Jf4_10 sf.556(gcsize)A72 354 :Mf0_12 sf.253 .025(parameter specifies how large the space is allowed to grow before the garbage collector is called.)J72 366 :Mf4_10 sf.328(Gcmax)Af0_12 sf.953 .095( specifies the maximum size the space may grow to before triggering the )Jf4_10 sf.361(gc-overflow)A72 378 :Mf0_12 sf1.282 .128(interrupt.  Finally, )Jf4_10 sf.434(gcmin)Af0_12 sf1.251 .125( specifies how much of the space should be free after performing a)J72 390 :M-.094(garbage collection; if the free storage is less than )Af4_10 sf-.126(gcmin)Af0_12 sf-.102(, the garbage collector immediately allocates)A72 402 :M.528 .053(more storage to the space.  \()Jf4_10 sf.209(Gcmin)Af0_12 sf.566 .057( may be specified as either an absolute number of words or a)J72 414 :M-.086(percentage\).)A72 434 :M.866 .087(We will make use in our )Jf4_10 sf.362(gc-daemon)Af0_12 sf.66 .066( of only the )Jf4_10 sf.362(gcsize)Af0_12 sf1.238 .124( allocation parameters of each space.)J72 446 :Mf4_10 sf.277(Gcmin)Af0_12 sf.596 .06( will be set to 0 \(or as small as possible\), and )Jf4_10 sf.277(gcmax)Af0_12 sf.618 .062( will be set to infinity \(or as large as)J72 458 :M.466 .047(possible\).  We ignore )Jf4_10 sf.164(gcmin)Af0_12 sf.468 .047( because the garbage collector uses it to to allocate space before the)J72 470 :Mf4_10 sf.136(gc-daemon)Af0_12 sf.323 .032( has had a chance to think things over.  Setting )Jf4_10 sf.136(gcmin)Af0_12 sf.286 .029( instead of )Jf4_10 sf.136(gcsize)Af0_12 sf.468 .047( would mean)J72 482 :M-.055(that any decision by the daemon would not take effect until after the next garbage collection, which)A72 494 :M-.072(would greatly reduce the responsiveness of the )Af4_10 sf-.089(gc-daemon)Af0_12 sf-.068( to the current situation.)A72 511 :Mf2_12 sf2.536 .254(The Garbage Collection Deamon)J72 531 :Mf0_12 sf-.054(The )Af4_10 sf-.06(gc-daemon)Af0_12 sf-.049( needs to be able to calculate two quantities for every space\321the current number of)A72 543 :M.389 .039(accessible words and the gross number of words allocated since the last garbage collection.  The)J72 555 :M.051 .005(current number of accessible words for a space can easily be calculated by subtracting the number)J72 567 :M-.108(of words free at the end of the current garbage collection from the size of the space at that time.  The)A72 579 :M.782 .078(gross number of words allocated since the previous garbage collection can be calculated as the)J72 591 :M-.038(difference between the number in use at the beginning of the current garbage collection\(size before)A72 603 :M-.109(minus free before\) and the number accessible at the end of the previous garbage collection.)A72 623 :M.331 .033(With these figures calculated for each space, it is easy to calculate the total number of accessible)J72 635 :M-.053(words and the differential rates of allocation.  Taking the total free storage to be a percentage of the)A72 647 :M1.849 .185(total accessible storage, we can divide up this free space among the spaces based on their)J72 659 :M-.099(differential rates of allocation.  MACLISP is informed of this decision by setting the )Af4_10 sf-.126(gcsize)Af0_12 sf-.114( of each)A72 671 :M1.156 .116(space to the sum of the accessible cells in that space plus the new free storage allotment just)J72 683 :M1.289 .129(calculated.  \(We also round )Jf4_10 sf.448(gcsize)Af0_12 sf1.147 .115( up to the next multiple of 512 because 512 words is the)J72 695 :M-.119(smallest unit of allocation in MACLISP\).)Aendp%%Page: 3 3%%BeginPageSetupinitializepage(Henry Baker; page: 3 of 3)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 53 :Mf0_10 sf.398 .04(From )Jf1_10 sf.445 .044(Artificial Intelligence, An MIT Perspective, Vol. 2)Jf0_10 sf.305 .031(.  Winston & Brown, )Jf1_10 sf.11(eds)Af0_10 sf.398 .04(., MIT Press, 1979, pp. 391-396.)J318 753 :Mf0_12 sf(3)S72 89 :M-.008(The system could be improved by varying the allocate/mark ratio as the total number of accessible)A72 101 :M.591 .059(words grew.  The idea is to garbage collect more to keep the working-set size small.  However,)J72 113 :M1.754 .175(since the paging depends so heavily on the current operating system load, one would need)J72 125 :M-.106(information from the operating system to make that decision properly.)A72 145 :M(The )Sf4_10 sf(gc-daemon)Sf0_12 sf.007 .001( tries to divide up the free storage among the various spaces based on their relative)J72 157 :M-.027(allocation histories.  This strategy hopes that the future will be like the near past\(since the previous)A72 169 :M-.046(garbage collection\).  However, in practice, programs go through phases, with one phase requiring a)A72 181 :M-.024(drastically different mix of cell types than another.  Therefore the )Af4_10 sf-.031(gc-daemon)Af0_12 sf-.027( can be wrong.  Since)A72 193 :M-.034(the costs of misallocation are larger with the larger spaces, and since storage can never be retracted)A72 205 :M-.005(from a space once allocated, the )Af4_10 sf-.006(gc-daemon)Af0_12 sf-.005( may wish to hedge its bets by giving the larger spaces)A72 217 :M-.123(only partial allocations.)A72 237 :M.283 .028(A )Jf4_10 sf.175(gc-daemon)Af0_12 sf.572 .057( having the characteristics described above is presented below in V. Pratt's CGOL)J72 249 :M-.088(input notation for LISP.  This daemon stores all the information about a space on the property list of)A72 261 :M2.36 .236(that space's name.  For example, the normalized rate of list consing can be accessed by)J72 273 :Mf4_10 sf1.123(\(GET\312'LIST\312'ALLOCRATE\))Af0_12 sf3.208 .321(.  Summary information is stored on the property list of)J72 285 :Mf4_10 sf.141(TOTAL-STORAGE)Af0_12 sf.397 .04(.  The only user-settable parameter is the variable )Jf4_10 sf.141(ALLOCMARKRATIO)Af0_12 sf.332 .033(.  This value)J72 297 :M.202 .02(must be a positive floating point number less than 5.0.  It is set initially to 1.0.  Making it smaller)J72 309 :M-.107(decreases working set size and increases garbage collection time.)A72 326 :Mf4_10 sf(define "GC-DAEMON" \(spacelist\);)S72 337 :M(  let totalaccessible = 0.0,)S72 348 :M(      totalconsed = 0.0;)S72 359 :M.005 .001(  % Go through spaces and accumulate consed and accessible information. %)J72 370 :M.003 0(  for element in spacelist                  % Argument is "alist" of spaces. %)J72 381 :M.003 0(      do \(let space = car\(element\),              % Give names to parameters. %)J72 392 :M.003 0(              freebefore = cadr\(element\),)J72 403 :M.003 0(              freeafter = caddr\(element\),)J72 414 :M.003 0(              sizebefore = cadddr\(element\),)J72 425 :M.003 0(              sizeafter = car\(cddddr\(element\)\);)J72 436 :M.004 0(          % Compute consed since last gc and accessible new for this space. %)J72 447 :M.005 0(          consed ofg space := sizebefore-freebefore-accessible ofg space;)J72 458 :M.004 0(          totalconsed := totalconsed + consed ofq space;)J72 469 :M.004 0(          accessible ofq space := sizeafter-freeafter;)J72 480 :M.004 0(          totalaccessible := totalaccessible + accessible ofq space\);)J72 491 :M.005 .001(  % Store total consed, total accessible and compute total free. %)J72 502 :M.006 .001(  consed ofq "TOTAL-STORAGE" := totalconsed;)J72 513 :M.007 .001(  accessible ofq "TOTAL-STORAGE" := totalaccessible;)J72 524 :M.006 .001(  let totalfree = allocmarkratio * totalaccessible;)J72 535 :M.006 .001(  free ofq "TOTAL-STORAGE" := totalfree;)J72 546 :M.005 .001(  % Go through spaces and reallocate where necessary. %)J72 557 :M(  for element in spacelist)S72 568 :M(      do \(let space = car element;)S72 579 :M.004 0(          allocrate ofq space := consed ofq space / totalconsed;)J72 590 :M.004 0(          free ofq space := fix\(totalfree * allocrate ofq space\);)J72 601 :M.004 0(          let spcsize = accessible ofq space + free ofq space + 511.;)J72 612 :M.004 0(              if spcsize>511. then alloc\([space,[spcsize,262143.,32.]]\)\))Jendp%%Trailerend%%EOF