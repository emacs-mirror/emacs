%!PS-Adobe-3.0
%%Title: (NoMotionGC.word)
%%Creator: (Microsoft Word: LaserWriter 8 8.2)
%%CreationDate: (2:55 PM Thursday, March 16, 1995)
%%For: (Henry Baker)
%%Pages: 5
%%DocumentFonts: Times-Italic Times-Bold Times-Roman Helvetica Courier
%%DocumentNeededFonts: Times-Italic Times-Bold Times-Roman Helvetica Courier
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%%DocumentMedia: Default 612 792 0 () ()
%ADO_ImageableArea: 31 31 583 761
%%EndComments
userdict begin/dscInfo 5 dict dup begin
/Title(NoMotionGC.word)def
/Creator(Microsoft Word: LaserWriter 8 8.2)def
/CreationDate(2:55 PM Thursday, March 16, 1995)def
/For(Henry Baker)def
/Pages 1 def
end def end

save 
/version23-manualfeedpatch where { pop false } { true }ifelse
 % we don't do an explicit 'get' since product and version MAY
 % be in systemdict or statusdict - this technique gets the lookup
 % without failure
statusdict begin
  product (LaserWriter) eq        % true if LaserWriter
  version cvr 23.0 eq             % true if version 23
end

and  % only install this patch if both are true
and  % true only if patch is not installed and is for this printer
     % save object and boolean on stack
dup { exch restore }if
% either true OR saveobject false
dup
{
  /version23-manualfeedpatch true def
  /oldversion23-showpage /showpage load def
  /showpage       % this showpage will wait extra time if manualfeed is true
  {%
     statusdict /manualfeed known
     {% manualfeed known in statusdict
        statusdict /manualfeed get
        {% if true then we loop for 5 seconds
           usertime 5000 add       % target usertime
           { % loop
             dup usertime sub 0 lt
             { exit }if
           }loop
           pop             % pop the usertime off the stac
        }if
     }if
     oldversion23-showpage
  }bind def
}if
not{ restore }if

/md 148 dict def md begin/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 81 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if end
%%EndProlog
%%BeginSetup
md begin
countdictstack[{
%%BeginFeature: *ManualFeed False
statusdict /manualfeed false put
%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *InputSlot Cassette

%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *PageRegion LetterSmall
lettersmall
%%EndFeature
}featurecleanup
(Henry Baker)setjob
/mT[1 0 0 -1 31 761]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Times-Italic
%%IncludeFont: Times-Bold
%%IncludeFont: Times-Roman
%%IncludeFont: Helvetica
%%IncludeFont: Courier
/f0_1/Times-Italic
:mre
/f0_12 f0_1 12 scf
/f0_10 f0_1 10 scf
/f1_1/Times-Bold
:mre
/f1_12 f1_1 12 scf
/f2_1/Times-Roman
:mre
/f2_12 f2_1 12 scf
/f2_10 f2_1 10 scf
/f2_9 f2_1 9 scf
/f3_1/Helvetica
:mre
/f3_18 f3_1 18 scf
/f3_12 f3_1 12 scf
/f4_1/Courier
:mre
/f4_10 f4_1 10 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(Henry Baker; page: 1 of 5)setjob
%%EndPageSetup
gS 0 0 552 730 rC
41 14 :M
f0_12 sf
.286 .029(ACM Sigplan Notices  )J
f1_12 sf
.095(27)A
f2_12 sf
.435 .044(,3 \(March 1992\),66-70.)J
41 717 :M
-.081(Copyright \251 1991 by Nimble Computer Corporation)A
467 717 :M
(1)S
41 55 :M
f3_18 sf
-.076(The Treadmill:)A
41 73 :M
-.099(Real-Time Garbage Collection Without Motion Sickness)A
41 97 :M
f3_12 sf
.099 .01(Henry G. Baker)J
41 120 :M
.489 .049(Nimble Computer Corporation, 16231 Meadow Ridge Way, Encino, CA  91436)J
41 133 :M
.556 .056(\(818\) 501-4956  \(818\) 986-1360 FAX)J
39 148 -1 1 511 147 1 39 147 @a
41 162 :M
f2_12 sf
-.122(A simple real-time garbage collection algorithm is presented which does not copy, thereby avoiding)A
41 174 :M
.518 .052(some of the problems caused by the asynchronous motion of objects.  This in-place "treadmill")J
41 186 :M
.193 .019(garbage collection scheme has approximately the same complexity as other non-moving garbage)J
41 198 :M
.652 .065(collectors, thus making it usable in a high-level language implementation where some pointers)J
41 210 :M
-.107(cannot be traced.  The treadmill is currently being used in a Lisp system built in Ada.)A
39 220 -1 1 511 219 1 39 219 @a
41 240 :M
f3_12 sf
-.089(INTRODUCTION)A
41 262 :M
f2_12 sf
-.016(In 1978, we presented a relatively simple storage management algorithm using garbage collection)A
41 274 :M
-.026(\("GC"\) which was "real-time" \("RT"\), in the sense that all of its operations could be bounded by a)A
41 286 :M
-.012(small constant, except for allocation, which was bounded by a small constant times the size of the)A
41 298 :M
.049 .005(object being allocated [Baker78].  Since initialization requires time proportional to the size of the)J
41 310 :M
.283 .028(new object, this algorithm was optimum, to within a constant factor.  The key ideas of the paper)J
41 322 :M
.322 .032(were the tricolor marking scheme and the use of the allocation pointer as a clock to measure the)J
41 334 :M
-.123("time" until the garbage collection must be finished.)A
41 351 :M
-.009(Our 1978 paper had two major goals\321to show that garbage collection could be done in real time,)A
41 363 :M
-.022(and to show a relatively practical algorithm.  After the discovery of the proof shown in that paper,)A
41 375 :M
.008 .001(and before the discovery of the particular algorithm shown in that paper, we considered a number)J
41 387 :M
-.055(of different strategies for implementing a real-time garbage collector.  The search space included a)A
41 399 :M
.746 .075(number of different dimensions, including copying v. non-copying, breadth-first v. depth-first,)J
41 411 :M
1.339 .134(mark-sweep v. non-mark-sweep.  The copying GC which appeared in the paper was chosen)J
41 423 :M
-.022(because 1\) it was space-efficient, which appeared to be important for an embedded computer with)A
41 435 :M
1.198 .12(all "real" \(non-virtual\) memory; 2\) it compacted by copying, which allowed for the simplest)J
41 447 :M
-.039(allocation strategy\321pointer incrementation; and 3\) it had a single phase, unlike the 2-phase mark-)A
41 459 :M
-.043(sweep algorithm.)A
41 476 :M
.676 .068(We have since learned that compile-time garbage collection should be used whenever possible)J
41 488 :M
.493 .049([Chase87] [Chase88] [Hederman88] [Baker90]; that stack allocation should be used more often)J
41 500 :M
1.294 .129([Baker91b]; that functional objects should be treated differently from non-functional objects)J
41 512 :M
.291 .029([Baker93]; that depth-first copying often causes fewer faults in a virtual memory and/or caching)J
41 524 :M
1.047 .105(environment [Moon84] [Andre86] [Wilson91]; that the asynchronous movement of objects is)J
41 536 :M
1.126 .113(detrimental to compiler optimization [Chase87] [Chase88]; and that more efficient allocation)J
41 548 :M
-.017(strategies exist [Brent89] [White90].  A "conservative" garbage collector [Boehm88] works much)A
41 560 :M
-.068(better without copying, since it can never be sure that all pointers to an object have been found and)A
41 572 :M
-.072(updated.  Due to the greater perceived costs of copying and due to the greater perceived benefits of)A
41 584 :M
.331 .033(not copying, it now seems worthwhile to revisit an algorithm which lost the initial real-time GC)J
41 596 :M
(face-off.)S
41 619 :M
f3_12 sf
-.221(TRICOLOR MARKING)A
41 642 :M
f2_12 sf
.665 .067(We use 3 colors to mark the nodes of a rooted directed graph\321white, grey and black.)J
f2_9 sf
0 -3 rm
.17(1)A
0 3 rm
f2_12 sf
.364 .036(  At the)J
41 654 :M
.314 .031(commencement of marking, all the nodes are white.  We then mark the root nodes grey.  At any)J
-4127 -4126 -1 1 -4125 -4126 1 -4127 -4127 @a
41 663.24 -.24 .24 184.24 663 .24 41 663 @a
41 681 :M
f2_9 sf
(1)S
f2_10 sf
0 3 rm
.013 .001(Given the date of this real-time GC algorithm \(1976\), we now wish that we had used the colors white, red and blue.)J
0 -3 rm
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(Henry Baker; page: 2 of 5)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 45 :M
f0_12 sf
.286 .029(ACM Sigplan Notices  )J
f1_12 sf
.095(27)A
f2_12 sf
.435 .044(,3 \(March 1992\),66-70.)J
72 748 :M
-.081(Copyright \251 1991 by Nimble Computer Corporation)A
498 748 :M
(2)S
72 81 :M
1.12 .112(point during the marking, we find a grey node, darken all of the nodes it points to, and then)J
72 93 :M
-.09(blacken it.  Marking terminates when there are no more grey nodes.)A
72 110 :M
1.255 .126(Real-time garbage collection overlaps marking and mutating \(user program execution\).  The)J
72 123 :M
-.081(mutator is never allowed to see a white node.  If this policy is ever in danger of being violated,)A
f2_9 sf
0 -3 rm
-.079(2)A
0 3 rm
f2_12 sf
-.103( the)A
72 135 :M
.569 .057(mutator marks the white node due to be accessed and continues.  Since a black node can never)J
72 147 :M
-.099(point directly to a white node without a grey node intervening, and since the mutator only sees grey)A
72 159 :M
2.068 .207(or black nodes, this marking by the mutator is not harmful.  When marking is done, we)J
72 171 :M
.2 .02(interchange the interpretation of the colors white and black \(at this point there are no grey cells\),)J
72 183 :M
-.077(mark the roots grey, and then restart the algorithm.)A
72 200 :M
-.043(The copying algorithm in the 1978 paper mapped white nodes into "fromspace" nodes, grey nodes)A
72 212 :M
.27 .027(into "tospace" nodes which had been copied but not yet scanned, and black nodes into "tospace")J
72 224 :M
-.042(nodes which had been both copied and scanned.  This is not the only possible mapping, however.)A
72 247 :M
f3_12 sf
-.039(IN-PLACE GARBAGE COLLECTION)A
72 269 :M
f2_12 sf
-.092(The only requirements of tricolor marking are: 1\) it is easy to enumerate free cells for allocation; 2\))A
72 281 :M
-.102(it is easy to enumerate grey cells; 3\) it is easy to determine the color of a cell; 4\) it is easy to change)A
72 293 :M
-.119(the color of a cell; and 5\) it is easy to interchange the interpretation of the colors white and black.)A
72 310 :M
f0_12 sf
.907 .091(Doubly-linked lists)J
f2_12 sf
.601 .06( [Knuth73,2.2.5] satisfy these requirements.  Consider a system of Lisp-like)J
72 322 :M
-.023(pairs which have two extra "hidden" pointer components.  Initially, the free-list is a doubly-linked)A
72 334 :M
.218 .022(list through these hidden pointer components.  When a cell is allocated \("consed"\), it is removed)J
72 346 :M
-.088(from the free-list doubly-linked list, and inserted into the non-free-list doubly-linked list.)A
72 363 :M
.007 .001(In a non-real-time system, marking begins when the free-list becomes empty.  All cells are on the)J
72 375 :M
.24 .024(non-free-list at this point; i.e., all cells are white.  Marking begins by making the root cells grey;)J
72 387 :M
.315 .031(i.e., transferring the root cells from the white list to a grey list, which is done by unsnapping the)J
72 399 :M
-.086(cells from the one list and snapping them into the other list.  Marking proceeds by unsnapping cells)A
72 411 :M
-.006(from the grey list and snapping them into an initially empty black list.  Since an empty grey list is)A
72 423 :M
-.047(easy to detect, the algorithm will terminate with all accessible cells on the black \(non-free\) list and)A
72 435 :M
-.091(all inaccessible cells on the white \(free\) list.  The mutator continues after the interpretation of white)A
72 447 :M
-.094(and black has been interchanged.)A
72 464 :M
.595 .059(A real-time collection system is obtained by overlapping marking and mutating, as in the 1978)J
72 476 :M
.224 .022(paper.  If the mutator attempts to access a white cell, it first darkens it by unsnapping it from the)J
72 488 :M
.206 .021(white list and snapping it into the grey list for the marker to process; i.e., the algorithm utilizes a)J
72 500 :M
-.051("read barrier".  The real-time system will require )A
f0_12 sf
-.055(four)A
f2_12 sf
-.056( colors, however, since unmarked white cells)A
72 513 :M
.122 .012(must be distinguished from cells on the free list;)J
f2_9 sf
0 -3 rm
(3)S
0 3 rm
f2_12 sf
.134 .013( i.e., unmarked white cells must use "off-white")J
72 525 :M
1.232 .123(\(ecru\) instead of the "dead white" of the free-list.  At the end of marking, the ecru cells are)J
72 538 :M
-.089(converted to dead white cells to form the new free list.)A
f2_9 sf
0 -3 rm
(4)S
0 3 rm
72 555 :M
f2_12 sf
-.077(It is easy to see that this "in-place" algorithm is real-time, since the basic operations of determining)A
72 567 :M
.569 .057(a cell's color, changing a cell's color \(including unsnapping and snapping its links\), etc., are all)J
72 579 :M
-.038(constant-time operations.  If we incrementally update the simple statistics required to calculate the)A
72 591 :M
.368 .037(appropriate "cons/mark" ratio [Baker78], then this in-place system is real-time if and only if the)J
72 603 :M
-.1(original copying system is real-time.)A
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 647.24 -.24 .24 215.24 647 .24 72 647 @a
72 665 :M
f2_9 sf
(2)S
f2_10 sf
0 3 rm
-.025(A "read barrier" checks for this violation.)A
0 -3 rm
72 682 :M
f2_9 sf
.082(3)A
f2_10 sf
0 3 rm
.265 .026([Kung77] also uses the same color scheme for his )J
0 -3 rm
f0_10 sf
0 3 rm
.072(parallel)A
0 -3 rm
f2_10 sf
0 3 rm
.284 .028( garbage collector, which uses the two phases mark and)J
0 -3 rm
72 696 :M
-.018(sweep; that collector does not meet our definition of real-time, however.)A
72 710 :M
f2_9 sf
(4)S
f2_10 sf
0 3 rm
-.04(This color change to dead white can be accomplished by brute force, as in "Ecru, Brut\216!")A
0 -3 rm
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(Henry Baker; page: 3 of 5)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 45 :M
f0_12 sf
.286 .029(ACM Sigplan Notices  )J
f1_12 sf
.095(27)A
f2_12 sf
.435 .044(,3 \(March 1992\),66-70.)J
72 748 :M
-.081(Copyright \251 1991 by Nimble Computer Corporation)A
498 748 :M
(3)S
72 87 :M
f3_12 sf
-.133(THE TREADMILL OPTIMIZATION)A
72 109 :M
f2_12 sf
-.036(A new \(1991\) optimization for this algorithm is obtained by linking )A
f0_12 sf
-.032(all)A
f2_12 sf
-.035( the cells into into the same)A
72 121 :M
1.961 .196(large cyclic doubly-linked list \(the treadmill "tread"\), while keeping the various colors in)J
72 133 :M
1.409 .141(contiguous subsequences of this list.  The four segments\321white, grey, black and ecru\321are)J
72 145 :M
-.018(delimited by four pointers\321)A
f4_10 sf
-.021(bottom)A
f2_12 sf
(, )S
f4_10 sf
-.021(top)A
f2_12 sf
(, )S
f4_10 sf
-.021(free)A
f2_12 sf
-.016( and )A
f4_10 sf
-.021(scan)A
f2_12 sf
-.018(.  We use the hidden links "forward" and)A
72 157 :M
-.034("backward" to orient this cyclic doubly-linked list.  We thus have the pointers and segments in the)A
72 169 :M
.893 .089(following cyclic order: )J
f4_10 sf
.256(bottom)A
f2_12 sf
.498 .05(, ecru, )J
f4_10 sf
.256(top)A
f2_12 sf
.508 .051(, grey, )J
f4_10 sf
.256(scan)A
f2_12 sf
.559 .056(, black, )J
f4_10 sf
.256(free)A
f2_12 sf
.569 .057(, white, )J
f4_10 sf
.256(bottom)A
f2_12 sf
.59 .059(.  When the)J
72 181 :M
-.059(mutator allocates a cell, the )A
f4_10 sf
-.079(free)A
f2_12 sf
-.064( pointer is moved one cell "forward", thus changing a white \(free\))A
72 193 :M
.019 .002(cell directly into a black \(allocated\) cell.  When the cell under the )J
f4_10 sf
(scan)S
f2_12 sf
.023 .002( pointer has been scanned,)J
72 205 :M
(the )S
f4_10 sf
-.016(scan)A
f2_12 sf
-.013( pointer is moved "backward", thus changing a grey cell into a black cell.  To scan a grey)A
72 217 :M
-.035(cell, its visible pointers must be checked.  If a scanned pointer is black or grey, we do nothing, but)A
72 229 :M
.139 .014(if the scanned pointer is ecru, it is unlinked from the ecru segment between )J
f4_10 sf
.05(bottom)A
f2_12 sf
.077 .008( and )J
f4_10 sf
.05(top)A
f2_12 sf
.138 .014(, and)J
72 241 :M
.936 .094(relinked into the grey area, either at the )J
f4_10 sf
.361(scan)A
f2_12 sf
1.087 .109( pointer\321for depth-first ordering, or at the )J
f4_10 sf
.541(top)A
72 253 :M
f2_12 sf
.006 .001(pointer\321for breadth-first ordering.  Notice that only one bit of color distinction must be stored in)J
72 265 :M
-.096(the cell\321whether or not it is ecru.)A
72 282 :M
-.067(When the )A
f4_10 sf
-.074(scan)A
f2_12 sf
-.057( pointer meets the )A
f4_10 sf
-.074(top)A
f2_12 sf
-.057( pointer, the collection cycle has finished, and when the )A
f4_10 sf
-.098(free)A
72 294 :M
f2_12 sf
1.471 .147(pointer meets the )J
f4_10 sf
.495(bottom)A
f2_12 sf
1.244 .124( pointer, we must "flip".  At this point, we have cells of only two)J
72 306 :M
-.053(colors\321black and ecru.  To flip, we make ecru into white and black into ecru; )A
f4_10 sf
-.065(bottom)A
f2_12 sf
-.051( and )A
f4_10 sf
-.065(top)A
f2_12 sf
-.064( are)A
72 318 :M
-.066(then exchanged.  The root pointers are now "scanned" by making them grey; the cells they point to)A
72 330 :M
-.082(are unlinked from the ecru region and linked into the grey region.\(between )A
f4_10 sf
-.102(scan)A
f2_12 sf
-.08( and )A
f4_10 sf
-.102(top)A
f2_12 sf
-.093(\).  We can)A
72 342 :M
-.071(restart the collector, as it now has grey cells to scan.)A
72 360 :M
.529 .053(The "treadmill" optimization eliminates the need to resnap links during mutator allocation)J
f2_9 sf
0 -3 rm
.11(5)A
0 3 rm
f2_12 sf
.383 .038( and)J
72 372 :M
-.041(when changing from grey to black.  However, we must still resnap links when changing from ecru)A
72 384 :M
-.103(to grey, since we need to separate the accessible ecru cells from the garbage ecru cells.)A
72 401 :M
-.046(In the exposition above, we explicitly "moved" cells from the ecru list to the grey list.  On a multi-)A
72 413 :M
-.012(processor system, however, we might rather move the cell directly from the white list to the black)A
72 425 :M
-.079(list, but also put it onto a marker stack.  In this modified scheme, a grey cell is a black cell which is)A
72 437 :M
-.027(also on the marker stack.  This optimization may be useful in reducing the latency in the mutator's)A
72 450 :M
-.008(read barrier.)A
f2_9 sf
0 -3 rm
(6)S
0 3 rm
72 473 :M
f3_12 sf
.416(COSTS)A
72 495 :M
f2_12 sf
-.005(We now compare the costs of the treadmill "in-place" algorithm to the 1978 "copying" algorithm.)A
72 507 :M
.442 .044(The in-place algorithm requires 2 additional pointers per CONS pair, but it does not require the)J
72 519 :M
-.016(additional "tospace".  Therefore, for CONS pairs, the space requirements are identical, and the in-)A
72 532 :M
.432 .043(place algorithm requires less space for larger objects.)J
f2_9 sf
0 -3 rm
.095(7)A
0 3 rm
f2_12 sf
.347 .035(  The cost of resnapping links is probably)J
72 544 :M
.497 .05(larger than that of copying for CONS pairs, but for larger objects the in-place algorithm should)J
72 557 :M
-.005(require less effort.)A
f2_9 sf
0 -3 rm
(8)S
0 3 rm
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 571.24 -.24 .24 215.24 571 .24 72 571 @a
72 589 :M
.228(5)A
f2_10 sf
0 3 rm
.846 .085(A real-time system may sometimes find it advantageous to increase the number of cells under management by)J
0 -3 rm
72 603 :M
.013 .001(allocating a cell external to the "tread" and snapping it in during a CONS.)J
72 617 :M
f2_9 sf
-.084(6)A
f2_10 sf
0 3 rm
-.078([Kung77] uses a queue with two ends \("dequeue"\) for the same purpose; the second end reduces conflicts between the)A
0 -3 rm
72 631 :M
.055 .006(mutator and the collector.  If cells greyed by the mutator were resnapped at the top pointer, while cells greyed by the)J
72 642 :M
-.043(collector were resnapped at the scan pointer, then we would have a close approximation to Kung's dequeue.)A
72 656 :M
f2_9 sf
.166(7)A
f2_10 sf
0 3 rm
.61 .061(We ignore here fragmentation, which has been called "storage erosion" in real-time systems.  Storage erosion is)J
0 -3 rm
72 670 :M
.047 .005(analogous to land erosion\321the land is still there, but has become so eroded as to be useless for cultivation.)J
72 684 :M
f2_9 sf
.082(8)A
f2_10 sf
0 3 rm
.277 .028(On a virtual memory system, however, one does not have to physically copy large objects even when one is using)J
0 -3 rm
72 698 :M
.734 .073(a "copying" garbage collector algorithm.  This is possible if large objects are always located on their own set of)J
72 709 :M
1.169 .117(pages, so that the algorithm need only diddle the page map instead of physically copying these objects.  This)J
72 720 :M
1.059 .106(optimization is especially valuable for large structures of raw bits, such as color bitmaps.  Therefore, one cost)J
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(Henry Baker; page: 4 of 5)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 45 :M
f0_12 sf
.286 .029(ACM Sigplan Notices  )J
f1_12 sf
.095(27)A
f2_12 sf
.435 .044(,3 \(March 1992\),66-70.)J
72 748 :M
-.081(Copyright \251 1991 by Nimble Computer Corporation)A
498 748 :M
(4)S
72 81 :M
-.015(If one uses a modern RISC architecture with a cache, and if both hidden links of an object occupy)A
72 93 :M
.388 .039(the same cache line, then link resnapping may not be nearly as expensive as a count of memory)J
72 105 :M
-.062(references would indicate.  To enhance locality in a dual \(mutator-collector\) processor system, one)A
72 117 :M
-.113(could separate the object into two pieces\321one piece holding the links visible to the mutator and the)A
72 129 :M
.344 .034(other holding the links visible to the collector; this separation would keep the cache consistency)J
72 141 :M
-.042(protocol from thrashing.)A
72 158 :M
-.022(The biggest potential cost of an in-place algorithm, and the factor which lost it a place in the 1978)A
72 170 :M
1.147 .115(paper, is the fact that the free-list must be searched if objects of different sizes are managed)J
72 182 :M
.734 .073([Baker89].  In other words, allocation is no longer a simple pointer-increment operation, but a)J
72 194 :M
.486 .049(search of a free-list for an amount of storage big enough to satisfy the allocation.  Thus, the in-)J
72 206 :M
-.104(place algorithm appears to be most useful when managing a homogeneous collection of objects.)A
72 223 :M
.021 .002(There are several possible solutions to this allocation problem.  Brent [Brent89] showed a first-fit)J
72 235 :M
-.057(technique for managing storage in which allocation could be performed in O\(log\()A
f4_10 sf
-.069(w)A
f2_12 sf
-.054(\)\) time, where )A
f4_10 sf
(w)S
72 247 :M
f2_12 sf
.779 .078(is the maximum number of words allocated dynamically.  Jon L. White's technique [White90])J
72 259 :M
-.028(utilizes a hierarchy of bit-vectors which achieves O\(log\()A
f4_10 sf
(s)S
f2_12 sf
-.027(\)\) allocation time, where )A
f4_10 sf
(s)S
f2_12 sf
-.031( is the amount)A
72 271 :M
-.084(of storage under management.)A
72 288 :M
-.117(Of course, these techniques only put off the inevitable fragmentation caused by immobile objects of)A
72 300 :M
.253 .025(different sizes [Robson74].  Bounds on the sizes of available memory blocks can be obtained by)J
72 312 :M
-.016(combinatorial arguments; these bounds are not good, but are worst-case, not average bounds.  We)A
72 324 :M
-.005(therefore have a situation with poor worst-case bounds, but good average-case behavior; this may)A
72 336 :M
.099 .01(be a trap for real-time systems designers, who should be preparing for the worst, not the average,)J
72 348 :M
-.02(case [Baker89].)A
72 365 :M
.954 .095(Brenda Baker [Baker85] has shown how a "buddy" storage system can be modified to "make)J
72 377 :M
1.23 .123(space" by moving objects when a large allocation request cannot be fulfilled normally.  Her)J
72 389 :M
1.151 .115(algorithm operates so long as memory is not already full, and the time to allocate a block is)J
72 401 :M
.52 .052(proportional to the size of the block.  All of these characteristics would make her scheme seem)J
72 413 :M
-.132(ideal, except that the original goal of a motionless garbage collector has not been achieved!)A
72 430 :M
.468 .047(Thus, it would appear that if the allocation problem of large immobile objects of different sizes)J
72 442 :M
-.12(could be solved, then our in-place real-time variant would be an attractive way to collect garbage.)A
72 465 :M
f3_12 sf
.3(CONCLUSIONS)A
72 487 :M
f2_12 sf
.173 .017(We have shown an elegant technique based on doubly-linked lists for in-place real-time memory)J
72 499 :M
.394 .039(management which is isomorphic to our original copying algorithm.  We are using this in-place)J
72 511 :M
1.352 .135(real-time garbage collector in a Lisp system built on top of the Ada programming language)J
72 523 :M
.485 .048([Baker91a].  Other authors [Yuasa90] [Beaudoing91] have shown in-place real-time algorithms)J
72 535 :M
.246 .025(based on the 2-phase mark-sweep algorithm, although [Queinnec89] has shown how to integrate)J
72 548 :M
.076 .008(the sweep phase with allocation.)J
f2_9 sf
0 -3 rm
(9)S
0 3 rm
f2_12 sf
.062 .006(  [Moss87] uses a similar doubly-linked list to manage the stack)J
72 560 :M
-.057(frames of Smalltalk.  Doubly-linked lists can also be used to convert generational copying garbage)A
72 572 :M
-.127(collectors [Lieberman83] into in-place algorithms.)A
72 595 :M
f3_12 sf
.089(ACKNOWLEDGEMENTS)A
72 617 :M
f2_12 sf
.975 .098(Many thanks to Hans Boehm, Eliot Moss, Paul Wilson and others at the GC'91 Workshop of)J
72 629 :M
-.101(Garbage Collection in Object-Oriented Systems for their suggestions and feedback on this paper.)A
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 665.24 -.24 .24 539.24 665 .24 72 665 @a
72 685 :M
f2_10 sf
.014 .001(associated with a relocating collector is saved; other costs remain, however, such as the costs of updating all pointers)J
72 696 :M
.013 .001(and foregoing some compiler optimizations.)J
72 710 :M
f2_9 sf
(9)S
f2_10 sf
0 3 rm
.025 .003(It is rumored that this idea goes back at least to Fitch and/or Norman at the U. of Bath???)J
0 -3 rm
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(Henry Baker; page: 5 of 5)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 45 :M
f0_12 sf
.286 .029(ACM Sigplan Notices  )J
f1_12 sf
.095(27)A
f2_12 sf
.435 .044(,3 \(March 1992\),66-70.)J
72 748 :M
-.081(Copyright \251 1991 by Nimble Computer Corporation)A
498 748 :M
(5)S
72 87 :M
f3_12 sf
(REFERENCES)S
72 109 :M
f2_10 sf
.158 .016(Andre, David L.  )J
f0_10 sf
.244 .024(Paging in Lisp Programs)J
f2_10 sf
.181 .018(.  M.S. Thesis, U. of Maryland, 1986.)J
72 120 :M
.29 .029(Appel, Andrew W., Ellis, John R., and Li, Kai.  "Real-time concurrent garbage collection on stock multiprocessors".)J
89 131 :M
f0_10 sf
.513 .051(Proc. ACM PLDI)J
f2_10 sf
.498 .05(, June 1988,11-20.)J
72 142 :M
2.159 .216(Baker, Brenda, )J
f0_10 sf
1.405 .14(et al)J
f2_10 sf
1.934 .193(.  "Algorithms for Resolving Conflicts in Dynamic Storage Allocation".  )J
f0_10 sf
1.788 .179(J. ACM 32)J
f2_10 sf
.903(,2)A
89 153 :M
.121(\(April\3121985\),327-343.)A
72 164 :M
.279 .028(Baker, Henry.  "List processing in real time on a serial computer".  )J
f0_10 sf
.488 .049(CACM 21)J
f2_10 sf
.615 .062(,4 \(April\3121978\),280-294.)J
72 175 :M
-.004(Baker, Henry.  "Garbage Collection in Ada".  Ada-9X Revision Request#643, Ada Joint Program Office, Oct., 1989.)A
72 186 :M
.589 .059(Baker, Henry.  "Unify and Conquer \(Garbage, Updating, Aliasing ...\) in Functional Languages".  )J
f0_10 sf
.732 .073(Proc. 1990 ACM)J
89 197 :M
.16 .016(Conf. on Lisp and Functional Programming)J
f2_10 sf
.157 .016(, Nice, France, June, 1990,218-226.)J
72 208 :M
.897 .09(Baker, Henry.  "Structured Programming with Limited Private Types in Ada: Nesting is for the Soaring Eagles".)J
89 219 :M
f0_10 sf
.587 .059(ACM Ada Letters XI,)J
f2_10 sf
1.045 .104(5 \(July/Aug.\3121991\),79-90.)J
72 230 :M
.703 .07(Baker, Henry.  "CONS Should not CONS its Arguments, or, A Lazy Alloc is a Smart Alloc".  )J
f0_10 sf
1.053 .105(ACM Sigplan Not.)J
89 241 :M
.117(27)A
f2_10 sf
.706 .071(,3 \(March\3121992\),24-34.)J
72 252 :M
.401 .04(Baker, Henry.  "Equal Rights for Functional Objects, or, The More Things Change, The More They Are the Same".)J
89 263 :M
.48 .048(ACM )J
f0_10 sf
.582 .058(OOPS Messenger 4)J
f2_10 sf
.544 .054(,4 \(Oct.\3121993\), 2-27.)J
72 274 :M
1.866 .187(Beaudoing, B., and Queinnec, C.  "Mark-DURING-Sweep: A Real-Time Garbage Collector".  Submitted to)J
89 285 :M
f0_10 sf
.279(PARLE'91)A
f2_10 sf
(.)S
72 296 :M
.316 .032(Boehm, Hans-J., and Demers, Alan.  "Garbage Collection in an Uncooperative Environment".  )J
f0_10 sf
.308 .031(Soft. Pract. & Exper.)J
89 307 :M
.197(18)A
f2_10 sf
1.166 .117(,9 \(Sept.\3121988\),807-820.)J
72 318 :M
.652 .065(Brent, R. P.  "Efficient Implementation of the First-Fit Strategy for Dynamic Storage Allocation".  )J
f0_10 sf
1.282 .128(ACM TOPLAS)J
89 329 :M
.185(11)A
f2_10 sf
1.087 .109(,3 \(July\3121989\),388-403.)J
72 340 :M
.139 .014(Chase, David.  )J
f0_10 sf
.225 .023(Garbage Collection and Other Optimizations)J
f2_10 sf
.148 .015(.  Ph.D. Thesis, Rice Univ., Aug. 1987.)J
72 351 :M
.17 .017(Chase, David.  "Safety considerations for storage allocation optimizations".  )J
f0_10 sf
.204 .02(Proc. ACM PLDI)J
f2_10 sf
.154 .015(, June 1988.)J
72 362 :M
.366 .037(Hederman, Lucy.  )J
f0_10 sf
.523 .052(Compile Time Garbage Collection)J
f2_10 sf
.319 .032(.  MS Thesis, Rice U. Comp. Sci. Dept., Sept. 1988.)J
72 373 :M
2.901 .29(Hickey, T., and Cohen, J.  "Performance Analysis of On-the-Fly Garbage Collection".  )J
f0_10 sf
4.229 .423(CACM 27)J
f2_10 sf
1.116(,11)A
89 384 :M
.133(\(Nov.\3121984\),1143-1154.)A
72 395 :M
.431 .043(Knuth, Donald E.  )J
f0_10 sf
.596 .06(The Art of Computer Programming Vol. I: Fundamental Algorithms, 2nd Ed)J
f2_10 sf
.691 .069(.  Addison-Wesley,)J
89 406 :M
.373 .037(Reading, MA, 1973,634p.)J
72 417 :M
.62 .062(Kung, H.T., and Song, S.W.  "A Parallel Garbage Collection Algorithm and its Correctness Proof".  Tech. Report,)J
89 428 :M
.24 .024(Computer Science Dept., Carnegie-Mellon Univ., May 1977,20p.)J
72 439 :M
.56 .056(Lieberman, H., and Hewitt, C.  "A Real-Time Garbage Collector Based on the Lifetimes of Objects".  )J
f0_10 sf
.872 .087(CACM 26)J
f2_10 sf
.276(,6)A
89 450 :M
.115(\(June\3121983\),419-429.)A
72 461 :M
1.824 .182(Moon, David.  "Garbage collection in a large Lisp system".  )J
f0_10 sf
2.037 .204(Proc. ACM Symp. on Lisp and Funct. Prog.)J
f2_10 sf
(,)S
89 472 :M
.056(1984,235-246.)A
72 483 :M
1.91 .191(Moss, J.E.B.  "Managing Stack Frames in Smalltalk".  )J
f0_10 sf
2.301 .23(Sigplan '87 Symp. on Interpreters and Interpretive)J
89 494 :M
.137(Techniques)A
f2_10 sf
.183 .018(, in )J
f0_10 sf
.536 .054(Sigplan Not. 22)J
f2_10 sf
.883 .088(,7 \(July\3121987\),229-240.)J
72 505 :M
.962 .096(Nilsen, K.  "Garbage Collection of Strings and Linked Data Structures in Real Time".  )J
f0_10 sf
.972 .097(SW Prac. & Exper. 18)J
f2_10 sf
.489(,7)A
89 516 :M
.15(\(July\3121988\),613-640.)A
72 527 :M
.18 .018(Queinnec, Christian, )J
f0_10 sf
.101 .01(et al)J
f2_10 sf
.13 .013(.  "Mark DURING Sweep, rather than Mark THEN Sweep".  )J
f0_10 sf
.241 .024(Proc. PARLE'89)J
f2_10 sf
(.)S
72 538 :M
3.352 .335(Robson, J.M.  "Bounds for Some Functions Concerning Dynamic Storage Allocation".  )J
f0_10 sf
4.305 .43(JACM 21)J
f2_10 sf
1.443(,3)A
89 549 :M
.15(\(July\3121974\),491-499.)A
72 560 :M
.298 .03(Robson, J.M.  "Storage Allocation is NP-Hard".  )J
f0_10 sf
.29 .029(Info. Proc. Let. 11)J
f2_10 sf
.538 .054(,3 \(1980\),119-125.)J
72 571 :M
.876 .088(White, Jon L.  "Three Issues in Object-Oriented Garbage Collection".  )J
f0_10 sf
1.484 .148(Proc. ECOOP/OOPSLA'90 Workshop on)J
89 582 :M
-.05(Garbage Collection)A
f2_10 sf
-.052(, 1990.)A
72 593 :M
.587 .059(Wilson, Paul R.  "Some Issues and Strategies in Heap Management and Memory Hierarchies".  )J
f0_10 sf
.773 .077(ACM Sigplan Not.)J
89 604 :M
.117(26)A
f2_10 sf
.706 .071(,3 \(March\3121991\),45-52.)J
72 615 :M
.252 .025(Yuasa, T.  "Real-Time Garbage Collection on General-Purpose Machines".  )J
f0_10 sf
.179 .018(J. Sys. Soft. 11)J
f2_10 sf
.382 .038( \(1990\),181-198.)J
72 626 :M
-.015(Zorn, Ben.  )A
f0_10 sf
-.015(Comparative performance evaluation of garbage collection algorithms)A
f2_10 sf
-.016(.  Ph.D. Thesis, UC Berkeley EECS)A
89 637 :M
.745 .074(Dept., 1989.)J
endp
%%Trailer
end
%%EOF
