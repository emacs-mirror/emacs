%!PS-Adobe-3.0
%%Title: (NFutures.wrd)
%%Creator: (Microsoft Word: LaserWriter 8 8.2)
%%CreationDate: (4:54 PM Tuesday, December 6, 1994)
%%For: (Henry Baker)
%%Pages: 5
%%DocumentFonts: Times-Italic Times-Roman Times-Bold Times-BoldItalic Courier Symbol
%%DocumentNeededFonts: Times-Italic Times-Roman Times-Bold Times-BoldItalic Courier Symbol
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%%DocumentMedia: Default 612 792 0 () ()
%ADO_ImageableArea: 31 31 583 761
%%EndComments
userdict begin/dscInfo 5 dict dup begin
/Title(NFutures.wrd)def
/Creator(Microsoft Word: LaserWriter 8 8.2)def
/CreationDate(4:54 PM Tuesday, December 6, 1994)def
/For(Henry Baker)def
/Pages 1 def
end def end

save 
/version23-manualfeedpatch where { pop false } { true }ifelse
 % we don't do an explicit 'get' since product and version MAY
 % be in systemdict or statusdict - this technique gets the lookup
 % without failure
statusdict begin
  product (LaserWriter) eq        % true if LaserWriter
  version cvr 23.0 eq             % true if version 23
end

and  % only install this patch if both are true
and  % true only if patch is not installed and is for this printer
     % save object and boolean on stack
dup { exch restore }if
% either true OR saveobject false
dup
{
  /version23-manualfeedpatch true def
  /oldversion23-showpage /showpage load def
  /showpage       % this showpage will wait extra time if manualfeed is true
  {%
     statusdict /manualfeed known
     {% manualfeed known in statusdict
        statusdict /manualfeed get
        {% if true then we loop for 5 seconds
           usertime 5000 add       % target usertime
           { % loop
             dup usertime sub 0 lt
             { exit }if
           }loop
           pop             % pop the usertime off the stac
        }if
     }if
     oldversion23-showpage
  }bind def
}if
not{ restore }if

/md 149 dict def md begin/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 81 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if end
%%EndProlog
%%BeginSetup
md begin
countdictstack[{
%%BeginFeature: *ManualFeed False
statusdict /manualfeed false put
%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *InputSlot Cassette

%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *PageRegion LetterSmall
lettersmall
%%EndFeature
}featurecleanup
(Henry Baker)setjob
/mT[1 0 0 -1 31 761]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Times-Italic
%%IncludeFont: Times-Roman
%%IncludeFont: Times-Bold
%%IncludeFont: Times-BoldItalic
%%IncludeFont: Courier
%%IncludeFont: Symbol
/f0_1/Times-Italic
:mre
/f0_9 f0_1 9 scf
/f1_1/Times-Roman
:mre
/f1_9 f1_1 9 scf
/f1_8 f1_1 8 scf
/f1_7 f1_1 7 scf
/f2_1/Times-Bold
:mre
/f2_9 f2_1 9 scf
/f2_8 f2_1 8 scf
/f3_1/Times-BoldItalic
:mre
/f3_14 f3_1 14 scf
/f3_8 f3_1 8 scf
/f4_1/Courier
:mre
/f4_9 f4_1 9 scf
/f5_1/Symbol
:bsr
240/apple pd
:esr
/f5_9 f5_1 9 scf
/f5_8 f5_1 8 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(Henry Baker; page: 1 of 5)setjob
%%EndPageSetup
gS 0 0 552 730 rC
41 17 :M
f0_9 sf
.913 .091(Proceedings of Symposium on AI and Programming Languages)J
f1_9 sf
.525 .052(, ACM )J
f0_9 sf
1.137 .114(Sigplan Notices)J
f1_9 sf
.102 .01( )J
f2_9 sf
.225(12)A
f1_9 sf
.793 .079(,8 \(Aug. 1977\), 55-59.)J
287 723 :M
(1)S
113 51 :M
f3_14 sf
4.342 .434(The Incremental Garbage Collection of Processes)J
211 76 :M
f1_9 sf
.298 .03(Henry G. Baker, Jr. and Carl Hewitt)J
204 86 :M
1.257 .126(Massachusetts Institute of Technology)J
227 96 :M
1.373 .137(Cambridge, Massachusetts)J
41 118 :M
f2_8 sf
2.625 .263(This paper investigates some problems associated with an)J
41 126 :M
.86 .086(argument evaluation order that we call "future' order, which is)J
41 134 :M
.991 .099(different from both call-by-name and call-by-value.  In call-by-)J
41 142 :M
.188 .019(future, each formal parameter of a function is bound to a separate)J
41 150 :M
1.529 .153(process \(called a "future"\) dedicated to the evaluation of the)J
41 158 :M
.057 .006(corresponding argument.  This mechanism allows the fully parallel)J
41 166 :M
1.28 .128(evaluation of arguments to a function, and has been shown to)J
41 174 :M
.178 .018(augment the expressive power of a language.)J
41 186 :M
.639 .064(We discuss an approach to a problem that arises in this context:)J
41 194 :M
2.143 .214(futures which were thought to be relevant when they were)J
41 202 :M
.85 .085(created become irrelevant through being ignored in the body of)J
41 210 :M
.243 .024(the expression where they were bound.  The problem of irrelevant)J
41 218 :M
.156 .016(processes also appears in multiprocessing problem-solving systems)J
41 226 :M
.615 .061(which start several processors working on the same problem but)J
41 234 :M
.067 .007(with different methods, and return with the solution which finishes)J
41 242 :M
.808 .081(first.  This )J
f3_8 sf
1.927 .193(parallel method)J
f2_8 sf
1.192 .119( strategy has the drawback that the)J
41 250 :M
1.546 .155(processes which are investigating the losing methods must be)J
41 258 :M
-.021(identified, stopped, and reassigned to more useful tasks.)A
41 270 :M
.212 .021(The solution we propose is that of garbage collection.  We propose)J
41 278 :M
2.868 .287(that the goal structure of the solution plan be explicitly)J
41 286 :M
.619 .062(represented in memory as part of the graph memory \(like Lisp's)J
41 294 :M
.815 .081(heap\) so that a garbage collection algorithm can discover which)J
41 302 :M
.45 .045(processes are performing useful work, and which can be recycled)J
41 310 :M
.18 .018(for a new task.)J
41 322 :M
1.179 .118(An incremental algorithm for the unified garbage collection of)J
41 330 :M
.14 .014(storage and processes is described.)J
41 342 :M
1.856 .186(Key Words and Phrases: garbage collection, multiprocessing)J
41 350 :M
2.994 .299(systems, processor scheduling, "lazy" evaluation, "eager")J
41 358 :M
-.055(evaluation.)A
41 370 :M
.229 .023(CR Categories: 3.60, 3.80, 4.13, 4.22, 4.32.)J
41 384 :M
f1_9 sf
3.342 .334(Copyright \251 1977 by the Association for Computing)J
41 394 :M
1.281 .128(Machinery, Inc.  Permission to make digital or hard copies)J
41 404 :M
1.29 .129(of part or all of this work for personal or classroom use is)J
41 414 :M
1.816 .182(granted without fee provided that copies are not made or)J
41 424 :M
.681 .068(distributed for profit or direct commercial advantage and that)J
41 434 :M
1.042 .104(copies show this notice on the first page or initial screen of)J
41 444 :M
2.816 .282(a display along with the full citation.  Copyrights for)J
41 454 :M
1.323 .132(components of this work owned by others than ACM must)J
41 464 :M
1.175 .118(be honored.  Abstracting with credit is permitted.  To copy)J
41 474 :M
1.057 .106(otherwise, to republish, to post on servers, to redistribute to)J
41 484 :M
1.35 .135(lists, or to use any component of this work in other works)J
41 494 :M
2.231 .223(whether directly or by incorporation via a link, requires)J
41 504 :M
1.154 .115(prior specific permission and/or a fee.  Permissions may be)J
41 514 :M
4.281 .428(requested from Publications Dept, ACM Inc., 1515)J
41 524 :M
1.428 .143(Broadway, New York, NY 10036 USA, fax +1 \(212\) 869-)J
41 534 :M
1.873 .187(0481, or permissions@acm.org.)J
41 548 :M
3.718 .372(This report describes research done at the Artificial)J
41 558 :M
2.292 .229(Intelligence Laboratory of the Massachusetts Institute of)J
41 568 :M
4.388 .439(Technology.  Support for the laboratory's artificial)J
41 578 :M
1.808 .181(intelligence research is provided in part by the Advanced)J
41 588 :M
2.16 .216(Research Projects Agency of the Department of Defense)J
41 598 :M
.678 .068(under Office of Naval Research contract N00014-75-C-0522.)J
284 121 :M
f2_9 sf
4.216 .422(1.  Introduction)J
284 135 :M
f1_9 sf
2.602 .26(Processors are becoming very cheap and there is good)J
284 145 :M
1.021 .102(evidence that this trend will continue in the next few years.)J
284 155 :M
1.382 .138(As a result, there has been considerable interest in how to)J
284 165 :M
2.505 .25(apply large numbers of processors to the solution of a)J
284 175 :M
.849 .085(single task [7].  Since efficient utilization of these hordes of)J
284 185 :M
4.029 .403(processors requires a lot of communication, sorting)J
284 195 :M
2.924 .292(networks have been devised [2,16] which allow every)J
284 205 :M
.766 .077(processor in an N-processor system to both send and receive)J
284 215 :M
2.504 .25(a message on every clock pulse, with only the highest)J
284 225 :M
4.701 .47(priority messages getting through, while providing)J
284 235 :M
3.19 .319(acknowledgement of success or failure to the sender.)J
284 245 :M
1.751 .175(Furthermore, the transit time through the network is only)J
284 255 :M
.69(O\(log)A
f1_7 sf
0 -2 rm
.575(2)A
0 2 rm
f1_9 sf
2.114 .211(N\) and the size of the network only O\(Nlog)J
f1_7 sf
0 -2 rm
.575(2)A
0 2 rm
f1_9 sf
.965(N\).)A
284 265 :M
2.557 .256(However, it is still not clear what all these processors)J
284 275 :M
.936 .094(should be communicating about.)J
284 289 :M
1.429 .143(Friedman and Wise [10] quite rightly note that applicative)J
284 299 :M
.966 .097(languages \(languages without side-effects, e.g. "pure" LISP\))J
284 309 :M
1.239 .124(are excellently suited for the purpose of representing many)J
284 319 :M
1.66 .166(algorithms intended for execution on a host of processors)J
284 329 :M
1.325 .133(since their lack of side-effects eliminates a great source of)J
284 339 :M
1.932 .193(complexity in parallel execution.  Thus, "Church-Rosser")J
284 349 :M
1.189 .119(theorems can be proved which ensure the invariance of the)J
284 359 :M
.924 .092(value of an applicative expression regardless of the order or)J
284 369 :M
1.864 .186(relative speed of evaluation.  However, we must keep in)J
284 379 :M
1.561 .156(mind that this kind of parallelism does not implement the)J
284 389 :M
2.128 .213(most general form of communication between processes.)J
284 399 :M
2.399 .24(For example, it is not possible to implement an airline)J
284 409 :M
2.557 .256(reservation system in such a language, due to its non-)J
284 419 :M
1.513 .151(determinate behavior.)J
284 433 :M
.835 .084(In this paper we consider an "eager beaver" evaluator for an)J
284 443 :M
1.746 .175(applicative programming language which starts evaluating)J
284 453 :M
1.99 .199(every subexpression as soon as possible, and in parallel.)J
284 463 :M
1.373 .137(This is done through the mechanism of )J
f0_9 sf
.371(futures)A
f1_9 sf
1.376 .138(, which are)J
284 473 :M
1.357 .136(roughly Algol-60 "thunks" which have their own evaluator)J
284 483 :M
1.497 .15(process \("thinks"?\).  \(Friedman and Wise [10] call futures)J
284 493 :M
2.446 .245("promises", while Hibbard [13] calls them "eventuals".\))J
284 503 :M
1.017 .102(When an expression is given to the evaluator by the user, a)J
284 513 :M
f0_9 sf
.316(future)A
f1_9 sf
1.09 .109( for that expression is returned which is a promise to)J
284 523 :M
.761 .076(deliver the value of that expression at some later time, if the)J
284 533 :M
1.234 .123(expression has a value.  A process is created for each new)J
284 543 :M
.689 .069(future which immediately starts to work evaluating the given)J
284 553 :M
.818 .082(expression.  When the value of a future is needed explicitly,)J
284 563 :M
1.625 .163(e.g. by the primitive function ")J
f4_9 sf
.649(+)A
f1_9 sf
1.962 .196(", the evaluation process)J
284 573 :M
.538 .054(may or may not have finished.  If it has finished, the value Is)J
284 583 :M
.774 .077(immediately made available; if not, the requesting process is)J
284 593 :M
.797 .08(forced to wait until it finishes.)J
284 607 :M
2.657 .266(Futures are created recursively in the evaluation of an)J
284 617 :M
4.076 .408(expression whenever our eager evaluator encounters)J
284 627 :M
1.925 .193(functional application.  A new future is created for each)J
284 637 :M
1.229 .123(argument, resulting in the parallel \(collateral\) evaluation of)J
284 647 :M
1.594 .159(those arguments, while the main evaluator process tackles)J
284 657 :M
1.468 .147(the function position.  We call the main evaluator process)J
284 667 :M
.91 .091(the )J
f0_9 sf
.377(parent)A
f1_9 sf
1.284 .128(, while any futures it directly creates become its)J
284 677 :M
f0_9 sf
.441(offspring)A
f1_9 sf
(.)S
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(Henry Baker; page: 2 of 5)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 48 :M
f0_9 sf
.913 .091(Proceedings of Symposium on AI and Programming Languages)J
f1_9 sf
.525 .052(, ACM )J
f0_9 sf
1.137 .114(Sigplan Notices)J
f1_9 sf
.102 .01( )J
f2_9 sf
.225(12)A
f1_9 sf
.793 .079(,8 \(Aug. 1977\), 55-59.)J
318 754 :M
(2)S
72 78 :M
1.249 .125(More precisely, a )J
f0_9 sf
.331(future)A
f1_9 sf
1.184 .118( is a 3-tuple \(process, cell, queue\),)J
72 88 :M
.956 .096(where )J
f0_9 sf
.248(process)A
f1_9 sf
.875 .088( is the virtual processor initialized to evaluate)J
72 98 :M
1.459 .146(this argument expression in its proper environment, )J
f0_9 sf
.308(cell)A
f1_9 sf
.651 .065( is)J
72 108 :M
1.088 .109(a writable location in memory which will save the value of)J
72 118 :M
4.179 .418(the argument after it has been computed to avoid)J
72 128 :M
.668 .067(recomputing it, and )J
f0_9 sf
.198(queue)A
f1_9 sf
.496 .05( is a list of the processes which are)J
72 138 :M
.75 .075(waiting for the value of this future.  A future's process starts)J
72 148 :M
1.322 .132(evaluating its expression in the given environment.  If any)J
72 158 :M
.824 .082(other process needs the value of this future, and the value is)J
72 168 :M
.865 .087(not yet ready, the requesting process enters the queue of the)J
72 178 :M
1.209 .121(future and goes to sleep.  When the value promised by the)J
72 188 :M
2.017 .202(future is ready, its process stores the value into its cell,)J
72 198 :M
2.644 .264(wakes up all processes waiting in its queue, and dies.)J
72 208 :M
.988 .099(Henceforth, any process needing this future's value can find)J
72 218 :M
.688 .069(it in the future's cell without waiting or further computation.)J
72 232 :M
1.043 .104(The main problem with our eager interpreter is that since it)J
72 242 :M
.694 .069(anticipates which values are going to be required to compute)J
72 252 :M
2.337 .234(the final result, it can be wasteful.  A process may be)J
72 262 :M
1.746 .175(assigned to the computation of a future whose value will)J
72 272 :M
1.812 .181(never be needed; in this case, we say that the process is)J
72 282 :M
f0_9 sf
.194(irrelevant)A
f1_9 sf
.709 .071(.  If there were no way of determining irrelevancy,)J
72 292 :M
.956 .096(irrelevant processes could tie up a significant amount of the)J
72 302 :M
2.037 .204(system computing power.  Furthermore, if a future were)J
72 312 :M
1.966 .197(caught in a non-terminating evaluation, its computational)J
72 322 :M
.729 .073(power would be lost to the system forever!  In the following)J
72 332 :M
1.413 .141(sections, we argue that the "garbage collection" of passive)J
72 342 :M
2.156 .216(storage can be extended to the reclamation of irrelevant)J
72 352 :M
1.347 .135(active processes.  Furthermore, this collection can be done)J
72 362 :M
1.367 .137(in an )J
f0_9 sf
.695(incremental)A
f1_9 sf
2.749 .275( manner, eliminating the long delays)J
72 372 :M
.844 .084(required for classical garbage collection.)J
72 387 :M
f2_9 sf
3.951 .395(2.  Garbage Collecting Irrelevant Futures)J
72 401 :M
f1_9 sf
1.683 .168(A classical garbage collector for passive storage proceeds)J
72 411 :M
2.241 .224(by marking the )J
f0_9 sf
.667(root)A
f1_9 sf
2.345 .234( of the heap, and then propagating)J
72 421 :M
.822 .082(marks from marked nodes to their offspring until there is no)J
72 431 :M
.759 .076(unmarked node with a marked parent.  Upon the termination)J
72 441 :M
1.729 .173(of this procedure, any unmarked nodes are not accessible)J
72 451 :M
.437 .044(from the root and are therefore returned to the free list.)J
72 465 :M
1.188 .119(The key to garbage collecting )J
f0_9 sf
1.966 .197(active processes)J
f1_9 sf
.865 .087( is that their)J
72 475 :M
1.993 .199(process-states are addressable as vectors of words in the)J
72 487 :M
1.634 .163(common address space of all the processors,)J
0 -3 rm
.474(1)A
0 3 rm
1.51 .151( but marked)J
72 497 :M
.99 .099(with a special type-code.  This vector stores the contents of)J
72 507 :M
2.047 .205(the registers of the process.  The top-level process \(that)J
72 517 :M
2.322 .232(assigned to the top-level future\) is kept always directly)J
72 527 :M
1.023 .102(accessible from the root of the heap.  Suppose now that we)J
72 537 :M
4.036 .404(stop all the processes at the beginning of garbage)J
72 547 :M
.994 .099(collection.  As our classical collector traces the heap, it can)J
72 557 :M
2.295 .229(recognize when it encounters a process.  By marking a)J
72 567 :M
1.512 .151(process, the collector proves that it is still relevant, hence)J
72 577 :M
1.349 .135(it can be restarted when the garbage collection is finished.)J
72 587 :M
1.757 .176(If a process is not marked, it is garbage collected, and a)J
72 597 :M
.897 .09(processor will not be reassigned to it.)J
72 611 :M
1.777 .178(What makes irrelevant processes go away during garbage)J
72 621 :M
.994 .099(collection is the fact that they are not accessible from static)J
72 631 :M
2.071 .207(data structure; i.e. from the root of the heap.  Since all)J
72 641 :M
1.576 .158(relevant futures are bound in the environment structure to)J
72 651 :M
1.386 .139(some program variable or temporary variable, they will be)J
72 661 :M
.331 .033(marked and retained.)J
72 675 :M
.545 .055(\(If "busy waiting" is used in an extended system having side-)J
72 685 :M
1.265 .127(effects, then a process which is synchronized through busy)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 697.24 -.24 .24 215.24 697 .24 72 697 @a
72 713 :M
.228(1)A
f1_8 sf
0 3 rm
.706 .071(We assume throughout this paper that all processors are embedded)J
0 -3 rm
72 724 :M
.346 .035(in a single, global, shared address space.)J
315 74 :M
f1_9 sf
.854 .085(waiting will be accessible as long as its parent is accessible,)J
315 84 :M
2.084 .208(regardless of whether any other process needs its result.)J
315 94 :M
.934 .093(Hence it may not be collected even if it becomes irrelevant.)J
315 104 :M
3.313 .331(This is one reason why busy waiting is not a good)J
315 114 :M
2.13 .213(synchronization method.\))J
315 128 :M
1.648 .165(Garbage collection is made incremental by using some of)J
315 138 :M
.655 .065(the ideas from an earlier paper [1], which in turn is based on)J
315 148 :M
1.175 .118(the work of Dijkstra [5,6] and Lamport [14,15].  The mark)J
315 158 :M
1.052 .105(phase of our incremental garbage collector process employs)J
315 168 :M
3.049 .305(three colors for every object\321)J
f0_9 sf
.754(white)A
f1_9 sf
.725 .072(, )J
f0_9 sf
.772(grey)A
f1_9 sf
1.467 .147(, and )J
f0_9 sf
.753(black)A
f1_9 sf
(.)S
315 178 :M
1.401 .14(Intuitively, )J
f0_9 sf
.299(white)A
f1_9 sf
.959 .096( nodes are not yet known to be accessible,)J
315 188 :M
f0_9 sf
.272(grey)A
f1_9 sf
.944 .094( nodes are known to be accessible, but whose offspring)J
315 198 :M
1.034 .103(have not yet been checked, and )J
f0_9 sf
.32(black)A
f1_9 sf
1.246 .125( nodes are accessible,)J
315 208 :M
4.2 .42(and have accessible offspring.  Initially, all nodes)J
315 218 :M
.844 .084(\(including processes\) are white.  A white node is made grey)J
315 228 :M
.605 .061(by )J
f0_9 sf
.285(shading)A
f1_9 sf
.752 .075( it; i.e. making it "at least grey" [5], while a grey)J
315 238 :M
1.438 .144(node is )J
f0_9 sf
.647(marked)A
f1_9 sf
1.917 .192( by shading its offspring and making the)J
315 248 :M
3.834 .383(node black\321both indivisible processes.  Marking is)J
315 258 :M
2.154 .215(initiated by stopping all processes and shading the root.)J
315 268 :M
2.81 .281(Marking proceeds by finding a grey node, shading its)J
315 278 :M
1.056 .106(offspring, then making that node black.  When there are no)J
315 288 :M
1.283 .128(more grey nodes, garbage collection is done; all still-white)J
315 298 :M
1.188 .119(nodes are then emancipated and the colors white and black)J
315 308 :M
2.197 .22(switch interpretations.)J
315 322 :M
1.549 .155(After garbage collection has begun, a user process can be)J
315 332 :M
1.217 .122(restarted as soon as it has been blackened by the collector.)J
315 342 :M
.936 .094(Since the top-level process is pointed at directly by the root)J
315 352 :M
.896 .09(of the heap, it is restarted almost immediately.  It should be)J
315 362 :M
1.332 .133(obvious that when a process first becomes black, it cannot)J
315 372 :M
1.691 .169(point directly at a white node.  We wish to preserve this)J
315 382 :M
1.431 .143(assertion.  Therefore, whenever a running black process is)J
315 392 :M
.997 .1(about to violate it\321by inserting into one of its registers the)J
315 402 :M
2.224 .222(white component of a node it is already pointing at\321it)J
315 412 :M
2.958 .296(immediately shades the white node before proceeding.)J
315 422 :M
1.545 .154(Furthermore, every new node the process needs is created)J
315 432 :M
1.404 .14(black.  The intuitive rationale behind these policies is that)J
315 442 :M
f0_9 sf
2.504 .25(so far as any black process is concerned, the garbage)J
315 452 :M
2.182 .218(collection has already finished. )J
f1_9 sf
2.103 .21( Furthermore, )J
f0_9 sf
2.629 .263(the nodes)J
315 462 :M
1.982 .198(which are found accessible by the garbage collector are)J
315 472 :M
.934 .093(exactly those which were accessible at the time the garbage)J
315 482 :M
.871 .087(collection was started)J
f1_9 sf
(.)S
315 496 :M
4.063 .406(We prove the correctness of this garbage collector)J
315 506 :M
1.319 .132(informally.  The garbage collector is given a head start on)J
315 516 :M
2.005 .201(all of the processes because they are stopped when it is)J
315 526 :M
2.781 .278(started.  When a process is restarted, it is black, and)J
315 536 :M
2.961 .296(everything it sees is at least grey, hence it is in the)J
315 546 :M
1.189 .119(collector's wake.  Whenever a process attempts to catch up)J
315 556 :M
.756 .076(to the collector by tracing an edge from a node it can access)J
315 566 :M
.973 .097(directly, that node is immediately shaded.  Therefore, it can)J
315 576 :M
1.28 .128(never pass or even catch the collector.  Since the collector)J
315 586 :M
1.399 .14(has already traced any node a process can get its registers)J
315 596 :M
1.358 .136(on, the process cannot affect the connectivity of the nodes)J
315 606 :M
.898 .09(that the collector sees.  Because white or grey processes are)J
315 616 :M
1.343 .134(not allowed to run, any created nodes are black, and since)J
315 626 :M
2.177 .218(nodes darken monotonically, the number of white nodes)J
315 636 :M
1.427 .143(must monotonically decrease, proving termination.)J
315 650 :M
3.333 .333(Our garbage collector has only one phase\321the mark)J
315 660 :M
2.216 .222(phase\321because it uses a compacting, copying algorithm)J
315 670 :M
2.788 .279([8,4] which marks and copies in one operation.  This)J
315 680 :M
2.532 .253(algorithm copies accessible list structures from an "old)J
315 690 :M
.637 .064(semispace" into a "new semispace".  As each node is copied.)J
315 700 :M
1.478 .148(a "forwarding address" is left at its old address in the old)J
315 710 :M
.79 .079(semispace.  If the Minsky copying algorithm is used [8], the)J
315 720 :M
1.085 .109(collector has its own stack to keep track of grey nodes; the)J
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(Henry Baker; page: 3 of 5)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 48 :M
f0_9 sf
.913 .091(Proceedings of Symposium on AI and Programming Languages)J
f1_9 sf
.525 .052(, ACM )J
f0_9 sf
1.137 .114(Sigplan Notices)J
f1_9 sf
.102 .01( )J
f2_9 sf
.225(12)A
f1_9 sf
.793 .079(,8 \(Aug. 1977\), 55-59.)J
318 754 :M
(3)S
72 74 :M
1.148 .115(Cheney algorithm [4] uses a "scan pointer" to linearly scan)J
72 84 :M
1.852 .185(the new semispace, while updating the pointers of newly)J
72 94 :M
2.352 .235(moved nodes by moving the nodes they point to.  The)J
72 104 :M
2.576 .258(correspondence between our coloring scheme and these)J
72 114 :M
.906 .091(algorithms is this: )J
f0_9 sf
.265(white)A
f1_9 sf
.829 .083( nodes are those which reside in the)J
72 124 :M
.788 .079(old semispace; )J
f0_9 sf
.199(grey)A
f1_9 sf
.675 .068( nodes are those which have been copied)J
72 134 :M
.854 .085(to the new semispace, but whose outgoing pointers have not)J
72 144 :M
1.017 .102(been updated to point into the new semispace \(i.e. have not)J
72 154 :M
2.086 .209(yet been encountered by the scan pointer in the Cheney)J
72 164 :M
.956 .096(algorithm\); and )J
f0_9 sf
.231(black)A
f1_9 sf
.777 .078( nodes are those which have been both)J
72 174 :M
.75 .075(moved and updated \(i.e. are behind the scan pointer\).  When)J
72 184 :M
1.151 .115(scanning is done \(i.e. there are no more grey nodes and all)J
72 194 :M
3.064 .306(accessible nodes have been copied\), the old and new)J
72 204 :M
1.216 .122(semispaces then interchange roles.  Reallocating processors)J
72 214 :M
2.731 .273(is simple; all processors are withdrawn at the start of)J
72 224 :M
.923 .092(garbage collection, and are allocated to each process as it is)J
72 234 :M
1.039 .104(blackened.  Thus, when the garbage collection has finished,)J
72 244 :M
.793 .079(all and only relevant processes have been restarted.)J
72 258 :M
2.676 .268(The restriction that white processes cannot run can be)J
72 268 :M
1.747 .175(relaxed under the condition that )J
f0_9 sf
1.743 .174(a white process may not)J
72 278 :M
1.193 .119(cause a black node to point to a white one)J
f1_9 sf
1.052 .105(.  This can only)J
72 288 :M
.721 .072(happen if the white process is trying to perform a side-effect)J
72 298 :M
1.442 .144(on a black node.  If operations of this type are suspended)J
72 308 :M
1.165 .116(until either the process either becomes black or is garbage-)J
72 318 :M
1.953 .195(collected, then proper garbage collector operation can be)J
72 328 :M
4.084 .408(ensured, and convergence guaranteed.  Under these)J
72 338 :M
.862 .086(conditions, white processes create only white cells.  When a)J
72 348 :M
1.974 .197(white process is encountered by the garbage collector, it)J
72 358 :M
2.839 .284(must stop and allow itself to be colored black before)J
72 368 :M
.425(continuing.)A
72 382 :M
.765 .076(The notion that processes must be marked as well as storage)J
72 392 :M
1.186 .119(may explain some of the trouble that Dijkstra and Lamport)J
72 402 :M
1.613 .161(had when trying to prove their parallel garbage collection)J
72 412 :M
1.837 .184(algorithm correct [5,6,14,15].  Since their algorithm does)J
72 422 :M
2.769 .277(not mark a user process by coloring it black \(thereby)J
72 432 :M
2.625 .263(prohibiting it from directly touching white nodes\), and)J
72 442 :M
2.505 .251(allows these white processes to run, the proof that the)J
72 452 :M
1.987 .199(algorithm collects only and all garbage is long and very)J
72 462 :M
.888 .089(subtle \(see [15]\).)J
72 477 :M
f2_9 sf
3.644 .364(3.  Coroutines and Generators)J
72 491 :M
f1_9 sf
.884 .088(One problem with our "eager beaver" evaluator is that some)J
72 501 :M
1.102 .11(expressions which have no finite values will continue to be)J
72 511 :M
3.105 .311(evaluated without mercy.  Consider, for example, the)J
72 521 :M
1.172 .117(infinite sequence of squares of integers 0,1,4,9,...  We give)J
72 531 :M
.613 .061(below a set of LISP-like functions for computing such a list.)J
72 543 :M
f1_8 sf
.221 .022(losq )J
f5_8 sf
.095<BA>A
f1_8 sf
.084 .008( \()J
f5_8 sf
.095(l)A
f1_8 sf
.19 .019(x. \(cons \(* x x\) \(losq \(+ x 1\)\)\)\))J
209 543 :M
.115 .011(; Compute an element.)J
72 559 :M
.396 .04(cons )J
f5_8 sf
.157<BA>A
f1_8 sf
.139 .014( \()J
f5_8 sf
.157(l)A
f1_8 sf
.229 .023(x y. \()J
f5_8 sf
.157(l)A
f1_8 sf
.282 .028(z. \(if \(= z 'car\) x y\)\)\))J
209 559 :M
.197 .02(; Define CONS function.)J
72 575 :M
.375 .037(car )J
f5_8 sf
.196<BA>A
f1_8 sf
.173 .017( \()J
f5_8 sf
.196(l)A
f1_8 sf
.477 .048(x. \(x 'car\)\))J
209 575 :M
.109 .011(; Ask for 1st component.)J
72 591 :M
.251 .025(cdr )J
f5_8 sf
.126<BA>A
f1_8 sf
.112 .011( \()J
f5_8 sf
.126(l)A
f1_8 sf
.312 .031(x. \(x 'cdr\)\))J
209 591 :M
.162 .016(; Ask for 2nd component.)J
72 607 :M
.279 .028(list-of-squares )J
f5_8 sf
.067<BA>A
f1_8 sf
.145 .014( \(losq 0\))J
209 607 :M
.223 .022(; Start the recursion.)J
72 621 :M
f1_9 sf
.741 .074(The evaluation of "\(losq\3120\)" wIll start off a future evaluating)J
72 631 :M
1.864 .186("\(cons\312\311\)", which will start up another future evaluating)J
72 641 :M
1.85 .185("\(losq\3121\)", and so forth.  Since this computation will not)J
72 651 :M
.713 .071(terminate, we might worry whether anything useful will ever)J
72 661 :M
.956 .096(get done.  One way to ensure that this computation will not)J
72 671 :M
1.574 .157(clog the system is to convert it into a "lazy" computation)J
72 681 :M
2.564 .256([9] by only allowing it to proceed past a point in the)J
72 691 :M
.902 .09(infinite list when someone forces it to go that far.  This can)J
72 701 :M
1.54 .154(be easily done by performing a lambda abstraction on the)J
72 711 :M
1.798 .18(expression whose evaluation is to be delayed.  Since our)J
315 76 :M
.713 .071(evaluator will not try to further evaluate a )J
f5_9 sf
.289(l)A
f1_9 sf
1.326 .133(-expression, this)J
315 87 :M
.681 .068(will protect its body from evaluation by our eager beavers.)J
315 99 :M
f1_8 sf
-.154(losq' )A
f5_8 sf
<BA>S
315 107 :M
f1_8 sf
.05 .005(  \()J
f5_8 sf
.075(l)A
f1_8 sf
.255 .025(x. \(cons)J
358 107 :M
.26 .026(\(* x x\))J
358 115 :M
.087<28>A
f5_8 sf
.144(l)A
f1_8 sf
.359 .036(z. \(\(losq' \(+ x 1\)\) z\)\)\)\) ; Protect from early evaluation.)J
315 129 :M
f1_9 sf
1.571 .157(However, this "hack" is not really necessary if we use an)J
315 139 :M
f0_9 sf
2.225 .222(exponential scheduler)J
f1_9 sf
1.18 .118( for the proportion of effort assigned)J
315 149 :M
2.137 .214(to each process.  This scheduler operates recursively by)J
315 159 :M
1.112 .111(assigning 100% of the system effort to the top-level future,)J
315 169 :M
1.716 .172(and whenever this future spawns new futures, it allocates)J
315 179 :M
1.841 .184(only 50% of its allowed effort to its offspring.  While a)J
315 189 :M
2.233 .223(process is in the waiting queue of a future, it lends its)J
315 199 :M
3.89 .389(processing effort to the computation of that future.)J
315 209 :M
.702 .07(However, a future which finishes returns its effort to helping)J
315 219 :M
1.015 .102(the system\321not its siblings.  Now the set of futures can be)J
315 229 :M
1.537 .154(ordered according to who created whom and this ordering)J
315 239 :M
.932 .093(forms a tree.  As a result of our exponential scheduling, the)J
315 249 :M
.613 .061(further down in this tree a future is from the top-level future,)J
315 259 :M
.907 .091(the lower its priority in scheduling.  Therefore, as our eager)J
315 269 :M
1.653 .165(beavers produce more squares, they become exponentially)J
315 279 :M
.616 .062(more discouraged.  But if other processes enter the queue for)J
315 289 :M
.852 .085(the square of a large number, they lend their encouragement)J
315 299 :M
1.515 .151(to its computation.)J
315 313 :M
2.003 .2(In an evaluator which uses call-by-future for CONS, the)J
315 323 :M
1.33 .133(obvious program for MAPCAR \(the LISP analog of APL's)J
315 333 :M
1.265 .126(parallel application of a function to a vector of arguments\))J
315 343 :M
2.284 .228(will automatically do all of the function applications in)J
315 353 :M
2.206 .221(parallel in a "pipe-lined" fashion.  However, due to the)J
315 363 :M
.752 .075(scheduler the values earlier In the list will be accorded more)J
315 373 :M
.879 .088(effort than the later ones.)J
315 387 :M
1.102 .11(Because this scheduler is not omniscient, system effort will)J
315 397 :M
1.81 .181(still have to be reallocated by the garbage collector as it)J
315 407 :M
1.675 .167(discovers irrelevant processes and returns their computing)J
315 417 :M
.989 .099(power to help with still relevant tasks.)J
315 432 :M
f2_9 sf
2.676 .268(4.  Time and Space)J
315 446 :M
f1_9 sf
1.325 .132("Lazy" evaluation [9] \(call-by-name\) using "evaluate-once")J
315 456 :M
2.505 .251(thunks is an optimal strategy for evaluating applicative)J
315 466 :M
2.315 .232(expressions on a single processor, in the sense that the)J
315 476 :M
1.198 .12(minumum number of reductions \(procedure calls\) are made)J
315 486 :M
3.502 .35([17,3].  However, when more than one processor is)J
315 496 :M
2.047 .205(available to evaluate the expression, it is not clear what)J
315 506 :M
1.429 .143(strategy would be optimal.  If nothing is known about the)J
315 516 :M
2.099 .21(particular expression being evaluated, we conjecture that)J
315 526 :M
1.167 .117(any reasonable strategy must allocate one processor to lazy)J
315 536 :M
2.862 .286(evaluation, with the other processors performing eager)J
315 546 :M
1.693 .169(evaluation.  We believe that our "eager beaver" evaluator)J
315 556 :M
1.451 .145(implements this policy, and unless the processors interfere)J
315 566 :M
1.78 .178(with one another excessively, a computation must always)J
315 576 :M
2.6 .26(run faster with an eager evaluator running on multiple)J
315 586 :M
3.25 .325(processors than a lazy evaluator running on a single)J
315 596 :M
1.776 .178(processor.  If there are not enough processors to allocate)J
315 606 :M
1.245 .124(one for every future, then we believe that our "exponential)J
315 616 :M
3.073 .307(scheduling" policy will dynamically allocate processor)J
315 626 :M
.444 .044(effort where it is most needed.)J
315 640 :M
.906 .091(Although the universal creation of futures should reduce the)J
315 650 :M
.59 .059(time necessary to evaluate an expression when an unbounded)J
315 660 :M
1.359 .136(number of processors are available, we must consider how)J
315 670 :M
1.488 .149(the space requirements of this method compare with other)J
315 680 :M
1.986 .199(methods.  The space requirements of futures are hard to)J
315 690 :M
2.84 .284(calculate because under certain schedules, future order)J
315 700 :M
2.652 .265(evaluation approximates call-by-value, while with other)J
315 710 :M
1.896 .19(schedules, it is equivalent to call-by-name \(but evaluated)J
315 720 :M
1.705 .171(only once\).  In the worst case, the space requirements of)J
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(Henry Baker; page: 4 of 5)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 48 :M
f0_9 sf
.913 .091(Proceedings of Symposium on AI and Programming Languages)J
f1_9 sf
.525 .052(, ACM )J
f0_9 sf
1.137 .114(Sigplan Notices)J
f1_9 sf
.102 .01( )J
f2_9 sf
.225(12)A
f1_9 sf
.793 .079(,8 \(Aug. 1977\), 55-59.)J
318 754 :M
(4)S
72 74 :M
1.474 .147(futures can be arbitrarily bad, depending upon the relative)J
72 84 :M
.937 .094(speed of the processors assigned to non-terminating futures.)J
72 99 :M
f2_9 sf
2.607 .261(5.  The Power of Futures)J
72 113 :M
f1_9 sf
1.778 .178(The intuitive semantics associated with a future is that it)J
72 123 :M
2.696 .27(runs asynchronously with its parent's evaluation.  This)J
72 133 :M
2.941 .294(effect can be achieved by either assigning a different)J
72 143 :M
.607 .061(processor to each future, or by multiplexing all of the futures)J
72 153 :M
1.436 .144(on a few processors.  Given one such implementation, the)J
72 163 :M
.901 .09(language can easily be extended with a construct having the)J
72 173 :M
3.246 .325(following form: "\(EITHER\312<e)J
f1_7 sf
0 2 rm
.488(1)A
0 -2 rm
f1_9 sf
.571(>\312<e)A
f1_7 sf
0 2 rm
.488(2)A
0 -2 rm
f1_9 sf
.642<3ECAC9CA3C65>A
f1_7 sf
0 2 rm
.488(n)A
0 -2 rm
f1_9 sf
2.864 .286(>\)" means)J
72 184 :M
.854 .085(evaluate the expressions <e)J
f1_7 sf
0 2 rm
.096(i)A
0 -2 rm
f1_9 sf
.623 .062(> in parallel and return the value)J
72 195 :M
1.64 .164(of "the first one that finishes".  Ward [18] shows how to)J
72 205 :M
1.729 .173(give a Scott-type lattice semantics for this construct.  He)J
72 215 :M
1.21 .121(starts with a power-set of the base domain and gives it the)J
72 225 :M
1.842 .184(usual subset lattice structure, then extends each primitive)J
72 235 :M
2.734 .273(function to operate on sets of elements from the base)J
72 245 :M
.932 .093(domain in the obvious way, and finally defines the result of)J
72 255 :M
.771 .077(the EITHER construct to be the )J
f0_9 sf
1.063 .106(least upper bound)J
f1_9 sf
.264 .026( \()J
f0_9 sf
.343(LUB)A
f1_9 sf
.593 .059(\) of)J
72 265 :M
.982 .098(all the <e)J
f1_7 sf
0 2 rm
.171(i)A
0 -2 rm
f1_9 sf
1.113 .111(> in the subset lattice.  The EITHER construct is)J
72 278 :M
.545(approximated)A
0 -3 rm
.595(2)A
0 3 rm
1.557 .156( by spawning futures for all the <e)J
f1_7 sf
0 2 rm
.257(i)A
0 -2 rm
f1_9 sf
1.988 .199(>, and)J
72 289 :M
2.332 .233(polling them with the parent process until the first one)J
72 299 :M
.715 .071(finishes.  At that point, its answer is returned as the value of)J
72 309 :M
2.192 .219(the "EITHER" expression, and the other futures become)J
72 319 :M
.848 .085(inaccessible from the root of the heap.)J
72 333 :M
1.585 .158(We give several examples of the power of the "EITHER")J
72 343 :M
.279(construct:)A
72 355 :M
f1_8 sf
(\(multiply x y\) )S
f5_8 sf
<BA>S
f1_8 sf
( \(EITHER)S
161 355 :M
.228 .023(\(if x=0 then 0 else )J
f5_8 sf
.139(^)A
f1_8 sf
<29>S
161 363 :M
.228 .023(\(if y=0 then 0 else )J
f5_8 sf
.139(^)A
f1_8 sf
<29>S
161 371 :M
.375 .038(\(* x y\)\))J
72 387 :M
.466 .047(\(integrate exp bvar\) )J
f5_8 sf
<BA>S
72 395 :M
f1_8 sf
.232 .023(  \(EITHER )J
161 395 :M
.836 .084(\(fast-heuristic-integrate exp bvar\))J
111 403 :M
.736 .074(\(Risch-integrate exp bvar\)\))J
72 417 :M
f1_9 sf
.697 .07(The first example is that of a numeric product routine whose)J
72 427 :M
1.07 .107(value is zero if either of its arguments are zero, even if the)J
72 437 :M
.999 .1(non-zero argument is undefined.  The second example is an)J
72 447 :M
2.83 .283(integration routine for use in a symbolic manipulation)J
72 457 :M
2.302 .23(language like Macsyma, where there is a relatively fast)J
72 467 :M
3.293 .329(heuristic integration routine which looks for common)J
72 477 :M
1.989 .199(special cases, and a general but slow decision procedure)J
72 487 :M
2.891 .289(called the Risch algorithm.  Since the values of both)J
72 497 :M
1.153 .115(methods are guaranteed to be the same \(assuming that they)J
72 507 :M
1.157 .116(perform integration properly\), we need not worry about the)J
72 517 :M
4.067 .407(possibility of non-determinacy of the value of this)J
72 527 :M
1.89 .189(expression \(i.e. non-singleton subsets of the base domain)J
72 537 :M
.633 .063(in Ward's lattice model\).)J
72 551 :M
.532 .053(One may ask what the power of such an "EITHER" construct)J
72 561 :M
.844 .084(is; i.e. does it increase the expressive power of the language)J
72 571 :M
1.06 .106(in which it is embedded?  A partial answer to this question)J
72 581 :M
1.979 .198(has been given with respect to "uninterpreted" schemata.)J
72 591 :M
4.472 .447(Uninterpreted schemata answer questions about the)J
72 601 :M
3.183 .318(expressive power of programming language constructs)J
72 611 :M
3.093 .309(which are implicit in the language, rather than being)J
72 621 :M
2.031 .203(simulated.  For example, one can compare the power of)J
72 631 :M
1.384 .138(recursion versus iteration in a context where stacks cannot)J
72 641 :M
1.591 .159(be simulated.  Hewitt and Patterson [11] have shown that)J
72 651 :M
1.073 .107(uninterpreted "parallel" schemata are strictly more powerful)J
72 661 :M
1.393 .139(than recursive schemata.  The essense of this difference is)J
72 671 :M
3.66 .366(that parallel schemata can simulate non-deterministic)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 697.24 -.24 .24 215.24 697 .24 72 697 @a
72 713 :M
(2)S
f1_8 sf
0 3 rm
.097 .01(This implementation is only an approximation because only singleton)J
0 -3 rm
72 724 :M
.397 .04(sets of elements of the base domain can ever be returned.)J
315 74 :M
f1_9 sf
1.183 .118(computation without bogging down in some infinite branch)J
315 84 :M
1.098 .11(by following all branches in parallel.)J
315 98 :M
1.854 .185(Also, Ward [18] has shown that the "EITHER" construct)J
315 110 :M
1.499 .15(strictly increases the power of the )J
f5_9 sf
.576(l)A
f1_9 sf
1.753 .175(-calculus in the sense)J
315 121 :M
1.633 .163(that there exist functions over the base domain which are)J
315 131 :M
5.124 .512(inexpressible without "EITHER", but are trivially)J
315 141 :M
1.48 .148(expressible with it.)J
315 156 :M
f2_9 sf
3.472 .347(6.  Shared Databases)J
315 170 :M
f1_9 sf
1.239 .124(The advantage that garbage collection has over the explicit)J
315 180 :M
3.69 .369(kiIling of processes becomes apparent when parallel)J
315 190 :M
.713 .071(processes have access to a shared database.  These databases)J
315 200 :M
.684 .068(are usually protected from inconsistency due to simultaneous)J
315 210 :M
1.63 .163(update by a mutual exclusion method.  However, if some)J
315 220 :M
.561 .056(process were to be killed while it was inside such a database,)J
315 230 :M
1.287 .129(the database would remain locked, and hence unresponsive)J
315 240 :M
.897 .09(to the other processes requesting access.)J
315 254 :M
.641 .064(The solution we propose is for the database to always keep a)J
315 264 :M
2.574 .257(list of pointers to the processes which it has currently)J
315 274 :M
1.099 .11(inside.  In this way, an otherwise irrelevant process will be)J
315 284 :M
2.047 .205(accessible so long as it is inside an accessible database.)J
315 294 :M
.827 .083(However, the moment it emerges, it will be forgotten by the)J
315 304 :M
1.316 .132(database, and subject to reclamation by garbage collection.)J
315 314 :M
1.362 .136(The )J
f0_9 sf
.509(crowds)A
f1_9 sf
1.268 .127( component of a )J
f0_9 sf
.399(serializer)A
f1_9 sf
2.108 .211(, a synchronization)J
315 324 :M
1.97 .197(construct designed to manage parallel access to a shared)J
315 334 :M
1.138 .114(database [12], automatically performs such bookkeeping.)J
315 349 :M
f2_9 sf
5.072 .507(7.  Conclusions)J
315 363 :M
f1_9 sf
.948 .095(We have presented a method for managing the allocation of)J
315 373 :M
1.632 .163(processors as well as storage to the subcomputations of a)J
315 383 :M
.728 .073(computation in a way that tries to minimize the elapsed time)J
315 393 :M
5.969 .597(required.  This is done by anticipating which)J
315 403 :M
1.464 .146(subcomputations will be needed and starting them running)J
315 413 :M
2.378 .238(in parallel, before the results they compute are needed.)J
315 423 :M
3.181 .318(Because of this anticipation, subcomputations may be)J
315 433 :M
1.443 .144(started whose results are not needed. and thus our method)J
315 443 :M
2.809 .281(identifies and revokes these allocations of storage and)J
315 453 :M
5.139 .514(processing power through an incremental garbage)J
315 463 :M
1.859 .186(collection method.)J
315 477 :M
.594 .059(The scheme presented here assumes that all of the processors)J
315 487 :M
2.54 .254(reside in a common, global address space, like that of)J
315 497 :M
1.401 .14(C.mmp [19].  Since networks of local address spaces look)J
315 507 :M
2.127 .213(promising for the future, methods for garbage collecting)J
315 517 :M
.778 .078(those systems need to be developed.)J
315 531 :M
.539 .054(There are currently no plans to implement this method due to)J
315 541 :M
.489 .049(the lack of access to suitable hardware.  However, it could be)J
315 551 :M
5.583 .558(implemented on systems like C.mmp [19] in a)J
315 561 :M
1.265 .126(straightforward manner.)J
315 576 :M
f2_9 sf
5.198 .52(8.  Acknowledgements)J
315 590 :M
f1_9 sf
1.709 .171(Some of the early thinking about call-by-future was done)J
315 600 :M
.706 .071(several years ago by J. Rumbaugh.)J
315 615 :M
f2_9 sf
4.178 .418(9.  References)J
315 625 :M
f1_9 sf
.711 .071(1.  Baker, H.G., Jr.  "List Processing in Real Time on a Serial)J
332 635 :M
1.278 .128(Computer".  AI Working Paper 139, MIT AI Lab., Feb.)J
332 645 :M
1.029 .103(1977, also )J
f0_9 sf
1.733 .173(CACM 21)J
f1_9 sf
1.369 .137(,4 \(April 1978\), 280-294.)J
315 655 :M
1.221 .122(2.  Batcher, K.E. "Sorting Networks and their Applications".)J
332 665 :M
f0_9 sf
1.727 .173(1968 SJCC)J
f1_9 sf
1.271 .127(, April 1968, 307-314.)J
315 675 :M
2.06 .206(3.  Berry, Gerard and Levy, Jean-Jacques.  "Minimal and)J
332 685 :M
1.863 .186(Optimal Computations of Recursive Programs".  ACM)J
332 695 :M
f0_9 sf
.382(POPL4)A
f1_9 sf
1.071 .107(, Jan. 1977, 215-226.)J
315 705 :M
3.896 .39(4.  Cheney, C.J.  "A Nonrecursive List Compacting)J
332 715 :M
1.107 .111(Algorithm".  )J
f0_9 sf
1.626 .163(CACM 13)J
f1_9 sf
1.331 .133(,11 \(Nov. 1970\), 677-678.)J
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(Henry Baker; page: 5 of 5)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 48 :M
f0_9 sf
.913 .091(Proceedings of Symposium on AI and Programming Languages)J
f1_9 sf
.525 .052(, ACM )J
f0_9 sf
1.137 .114(Sigplan Notices)J
f1_9 sf
.102 .01( )J
f2_9 sf
.225(12)A
f1_9 sf
.793 .079(,8 \(Aug. 1977\), 55-59.)J
318 754 :M
(5)S
72 74 :M
1.178 .118(5.  Dijkstra, E.W., Lamport, L., Martin, A.J., Scholten, C.S.,)J
89 84 :M
2.198 .22(Steffens, E.F.M.  "On-the-fly Garbage Collection: An)J
89 94 :M
1.364 .136(Exercise in Cooperation".  Dijkstra note EWD496, June)J
89 104 :M
.688(1975.)A
72 114 :M
1.902 .19(6.  Dijkstra, E. W.  "After Many a Sobering Experience".)J
89 124 :M
.944 .094(Dijkstra note EWD500.)J
72 134 :M
.604 .06(7.  Erman, L.D. and Lesser, V.R.  "A Multi-level Organization)J
89 144 :M
1.626 .163(for Problem Solving using Many, Diverse, Cooperating)J
89 154 :M
1.861 .186(Sources of Knowledge".  )J
f0_9 sf
2.979 .298(Proc. IJCAI-75)J
f1_9 sf
1.823 .182(, Sept. 1975,)J
89 164 :M
.536(483-490.)A
72 174 :M
1.531 .153(8.  Fenichel, R.R., and Yochelson, J.C.  "A LISP Garbage-)J
89 184 :M
3.911 .391(Collector for Virtual-Memory Computer Systems".)J
89 194 :M
f0_9 sf
1.719 .172(CACM 12)J
f1_9 sf
1.407 .141(,11 \(Nov. 1969\), 611-612.)J
72 204 :M
.852 .085(9.  Friedman, D. P. and Wise, D. S.  "Why CONS should not)J
89 214 :M
.923 .092(evaluate its arguments".  In S. Michaelson and R. Milner)J
89 224 :M
.747<28>A
f0_9 sf
.997(eds)A
f1_9 sf
1.736 .174(.\), )J
f0_9 sf
5.661 .566(Automata, Languages and Programming)J
f1_9 sf
(,)S
89 234 :M
1.169 .117(Edinburgh University Press, Edinburgh \(1976\), 257-284.)J
72 244 :M
2.581 .258(10.  Friedman, D. P. and Wise, D. S.  "The Impact of)J
89 254 :M
2.256 .226(Applicative Programming on Multiprocessing".  )J
f0_9 sf
.738(1976)A
89 264 :M
2.111 .211(International Conference on Parallel Processing)J
f1_9 sf
1.457 .146(, 263-)J
89 274 :M
.75(272.)A
72 284 :M
4.89 .489(11.  Hewitt, C. and Patterson, M.  "Comparative)J
89 294 :M
1.352 .135(Schematology".  )J
f0_9 sf
1.312 .131(Record of Project MAC Conference on)J
89 304 :M
3.004 .3(Concurrent Systems and Parallel Computation)J
f1_9 sf
2.065 .206(, June)J
89 314 :M
.688(1970.)A
72 324 :M
3.947 .395(12.  Hewitt, C. and Atkinson, R.  "Parallelism and)J
89 334 :M
1.227 .123(Synchronization in Actor Systems".  ACM )J
f0_9 sf
.424(POPL4)A
f1_9 sf
.981 .098(, Jan.)J
89 344 :M
1.6 .16(17-19, 1977, L.A., Cal., 267-280.)J
72 354 :M
1.756 .176(13.  Hibbard, P.  "Parallel Processing Facilities".  In )J
f0_9 sf
1.158(New)A
89 364 :M
2.12 .212(Directions in Algorithmic Languages)J
f1_9 sf
.592 .059(, \()J
f0_9 sf
.436(ed)A
f1_9 sf
1.523 .152(.\) Stephen A.)J
89 374 :M
.976 .098(Schuman, IRIA, 1976, 1-7.)J
72 384 :M
3.548 .355(14.  Lamport, L.  "Garbage Collection with Multiple)J
89 394 :M
1.974 .197(Processes: An Exercise in Parallelism".  Mass. Comp.)J
89 404 :M
1.658 .166(Associates, CA-7602-2511, Feb. 1976.)J
72 414 :M
.805 .081(15.  Lamport, L.  "On-the-fly Garbage Collection: Once More)J
89 424 :M
1.737 .174(with Rigor".  Mass. Comp. Associates, CA-7508-1611,)J
89 434 :M
1.449 .145(Aug. 1975.)J
72 444 :M
.527 .053(16.  Moravec, H. P.  "The Role of Raw Power in Intelligence".)J
89 454 :M
1.074 .107(Unpublished ms., Stanford, Cal., May 1976.)J
72 464 :M
1.097 .11(17.  Vuillemin, Jean.  "Correct and Optimal Implementations)J
89 474 :M
.679 .068(of Recursion in a Simple Programming Language".  )J
f0_9 sf
.293(JCSS)A
89 484 :M
.434(9)A
f1_9 sf
1.689 .169( \(1974\), 332-354.)J
72 494 :M
2.917 .292(18.  Ward, S. A.  "Functional Domains of Applicative)J
89 504 :M
1.826 .183(Languages".  MAC TR-136, Project MAC, MIT, Sept.)J
89 514 :M
.688(1974.)A
72 524 :M
.199 .02(19.  Wulf, W., )J
f0_9 sf
.212 .021(et al)J
f1_9 sf
.295 .03(.  "HYDRA: The Kernel of a Multiprocessor)J
89 534 :M
.986 .099(Operating System".  )J
f0_9 sf
1.399 .14(CACM 17)J
f1_9 sf
1.096 .11(,6 \(June 1974\), 337-345.)J
endp
%%Trailer
end
%%EOF
