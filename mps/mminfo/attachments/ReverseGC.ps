%!PS-Adobe-3.0
%%Title: (ReverseGC.word)
%%Creator: (Microsoft Word: LaserWriter 8 8.2)
%%CreationDate: (7:21 PM Tuesday, December 6, 1994)
%%For: (Henry Baker)
%%Pages: 13
%%DocumentFonts: Times-Italic Symbol Times-Roman Times-Bold Courier
%%DocumentNeededFonts: Times-Italic Symbol Times-Roman Times-Bold Courier
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%%DocumentMedia: Default 612 792 0 () ()
%ADO_ImageableArea: 31 31 583 761
%%EndComments
userdict begin/dscInfo 5 dict dup begin
/Title(ReverseGC.word)def
/Creator(Microsoft Word: LaserWriter 8 8.2)def
/CreationDate(7:21 PM Tuesday, December 6, 1994)def
/For(Henry Baker)def
/Pages 1 def
end def end

save 
/version23-manualfeedpatch where { pop false } { true }ifelse
 % we don't do an explicit 'get' since product and version MAY
 % be in systemdict or statusdict - this technique gets the lookup
 % without failure
statusdict begin
  product (LaserWriter) eq        % true if LaserWriter
  version cvr 23.0 eq             % true if version 23
end

and  % only install this patch if both are true
and  % true only if patch is not installed and is for this printer
     % save object and boolean on stack
dup { exch restore }if
% either true OR saveobject false
dup
{
  /version23-manualfeedpatch true def
  /oldversion23-showpage /showpage load def
  /showpage       % this showpage will wait extra time if manualfeed is true
  {%
     statusdict /manualfeed known
     {% manualfeed known in statusdict
        statusdict /manualfeed get
        {% if true then we loop for 5 seconds
           usertime 5000 add       % target usertime
           { % loop
             dup usertime sub 0 lt
             { exit }if
           }loop
           pop             % pop the usertime off the stac
        }if
     }if
     oldversion23-showpage
  }bind def
}if
not{ restore }if

/md 193 dict def md begin/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 81 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
%%BeginFile: adobe_psp_derived_styles
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/wi
version(23.0)eq
{
{
gS 0 0 0 0 rC stringwidth gR
}bind
}{
/stringwidth load
}ifelse
def
/$o 1. def
/gl{$o G}bd
/ms{:M S}bd
/condensedmtx[.82 0 0 1 0 0]def
/:mc
{
condensedmtx :mf def
}bd
/extendedmtx[1.18 0 0 1 0 0]def
/:me
{
extendedmtx :mf def
}bd
/basefont Z
/basefonto Z
/dxa Z
/dxb Z
/dxc Z
/dxd Z
/dsdx2 Z
/bfproc Z
/:fbase
{
dup/FontType get 0 eq{
dup length dict begin
dup{1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse}forall
/FDepVector exch/FDepVector get[exch/:fbase load forall]def
}/bfproc load ifelse
/customfont currentdict end definefont
}bd
/:mo
{
/bfproc{
dup dup length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse
}forall
/PaintType 2 def
/StrokeWidth .012 0 FontMatrix idtransform pop def
/customfont currentdict
end
definefont
8 dict begin
/basefonto xdf
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
basefont setfont
( )dup 0 4 -1 roll put
dup wi
setcharwidth
0 0 :M
gS
gl
dup show
gR
basefonto setfont
show
end
}def
}store :fbase
}bd
/:mso
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxa 1 ps div def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
1 index 0 ne
{
exch dxa add exch
}if
setcharwidth
dup 0 0 ms
dup dxa 0 ms
dup dxa dxa ms
dup 0 dxa ms
gl
dxa 2. div dup ms
end
end
}def
}store :fbase
}bd
/:ms
{
/bfproc{
dup dup length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse
}forall
/PaintType 2 def
/StrokeWidth .012 0 FontMatrix idtransform pop def
/customfont currentdict
end
definefont
8 dict begin
/basefonto xdf
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxb .05 def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
exch dup 0 ne
{
dxb add
}if
exch setcharwidth
dup dxb .01 add 0 ms
0 dxb :T
gS
gl
dup 0 0 ms
gR
basefonto setfont
0 0 ms
end
end
}def
}store :fbase
}bd
/:mss
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxc 1 ps div def
/dsdx2 .05 dxc 2 div add def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
exch dup 0 ne
{
dsdx2 add
}if
exch setcharwidth
dup dsdx2 .01 add 0 ms
0 .05 dxc 2 div sub :T
dup 0 0 ms
dup dxc 0 ms
dup dxc dxc ms
dup 0 dxc ms
gl
dxc 2 div dup ms
end
end
}def
}store :fbase
}bd
/:msb
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxd .03 def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
1 index 0 ne
{
exch dxd add exch
}if
setcharwidth
dup 0 0 ms
dup dxd 0 ms
dup dxd dxd ms
0 dxd ms
end
end
}def
}store :fbase
}bd
/italicmtx[1 0 -.212557 1 0 0]def
/:mi
{
italicmtx :mf def
}bd
/:v
{
[exch dup/FontMatrix get exch
dup/FontInfo known
{
/FontInfo get
dup/UnderlinePosition known
{
dup/UnderlinePosition get
2 index 0
3 1 roll
transform
exch pop
}{
.1
}ifelse
3 1 roll
dup/UnderlineThickness known
{
/UnderlineThickness get
exch 0 3 1 roll
transform
exch pop
abs
}{
pop pop .067
}ifelse
}{
pop pop .1 .067
}ifelse
]
}bd
/$t Z
/$p Z
/$s Z
/:p
{
aload pop
2 index mul/$t xs
1 index mul/$p xs
.012 mul/$s xs
}bd
/:m
{gS
0 $p rm
$t lw
0 rl stroke
gR
}bd
/:n
{
gS
0 $p rm
$t lw
0 rl
gS
gl
stroke
gR
strokepath
$s lw
/setstrokeadjust where{pop
currentstrokeadjust true setstrokeadjust stroke setstrokeadjust
}{
stroke
}ifelse
gR
}bd
/:o
{gS
0 $p rm
$t 2 div dup rm
$t lw
dup 0 rl
stroke
gR
:n
}bd
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if end
%%EndProlog
%%BeginSetup
md begin
countdictstack[{
%%BeginFeature: *ManualFeed False
statusdict /manualfeed false put
%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *InputSlot Cassette

%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *PageRegion LetterSmall
lettersmall
%%EndFeature
}featurecleanup
(Henry Baker)setjob
/mT[1 0 0 -1 31 761]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Times-Italic
%%IncludeFont: Symbol
%%IncludeFont: Times-Roman
%%IncludeFont: Times-Bold
%%IncludeFont: Courier
/f0_1/Times-Italic
:mre
/f0_12 f0_1 12 scf
/f0_10 f0_1 10 scf
/f1_1/Symbol
:bsr
240/apple pd
:esr
/f1_12 f1_1 12 scf
/f1_10 f1_1 10 scf
/f1_9 f1_1 9 scf
/f1_8 f1_1 8 scf
/f2_1 f1_1
:mi
/f2_12 f2_1 12 scf
/f2_10 f2_1 10 scf
/f3_1/Times-Roman
:mre
/f3_14 f3_1 14 scf
/f3_12 f3_1 12 scf
/f3_10 f3_1 10 scf
/f3_9 f3_1 9 scf
/f3_8 f3_1 8 scf
/f4_1/Times-Bold
:mre
/f4_12 f4_1 12 scf
/f4_10 f4_1 10 scf
/f5_1 f1_1
def
/f5_12 f5_1 12 scf
/f5_10 f5_1 10 scf
/f6_1 f3_1
:v def
/f7_1 f1_1
:v def
/f8_1/Courier
:mre
/f8_10 f8_1 10 scf
/f8_9 f8_1 9 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(Henry Baker; page: 1 of 13)setjob
%%EndPageSetup
gS 0 0 552 730 rC
41 19 :M
f0_12 sf
.384 .038(Proc. Int'l. Workshop on Memory Mgmt.)J
f3_12 sf
.328 .033(, St Malo, France, Sept. 1992, Springer LNCS 637.)J
41 722 :M
-.053(Copyright \251 1991, 1992 by Nimble Computer Corporation)A
467 722 :M
(1)S
41 46 :M
f3_14 sf
.664 .066(NREVERSAL of Fortune)J
f3_9 sf
0 -5 rm
.083(1)A
0 5 rm
f3_14 sf
.49 .049( \321 The Thermodynamics of Garbage Collection)J
41 63 :M
f3_12 sf
.214 .021(Henry G. Baker)J
41 80 :M
f3_10 sf
.412 .041(Nimble Computer Corp., 16231 Meadow Ridge Way, Encino, CA  91436 \(818\) 501-4956\312\312\312\(818\) 986-1360 \(FAX\))J
41 99 :M
f4_12 sf
.337(Abstract)A
41 116 :M
f3_10 sf
.546 .055(The need to )J
f0_10 sf
.194(reverse)A
f3_10 sf
.909 .091( a computation arises in many contexts\321debugging, editor undoing, optimistic concurrency)J
41 127 :M
1.521 .152(undoing, speculative computation undoing, trace scheduling, exception handling undoing, database recovery,)J
41 138 :M
-.001(optimistic discrete event simulations, subjunctive computing, etc.  The need to )A
f0_10 sf
(analyze)S
f3_10 sf
( a reversed computation arises)S
41 149 :M
.673 .067(in the context of static analysis\321liveness analysis, strictness analysis, type inference, etc.  Traditional means for)J
41 160 :M
.366 .037(restoring a computation to a previous state involve checkpoints; checkpoints require time to copy, as well as space)J
41 171 :M
.254 .025(to store, the copied material.  Traditional reverse abstract interpretation produces relatively poor information due to)J
41 182 :M
.132 .013(its inability to guess the previous values of assigned-to variables.)J
41 198 :M
.607 .061(We propose an abstract computer model and a programming language\321)J
f1_10 sf
.257(Y)A
f3_10 sf
.77 .077(-Lisp\321whose primitive operations are)J
41 209 :M
.859 .086(injective and hence reversible, thus allowing arbitrary undoing without the overheads of checkpointing.  Such a)J
41 220 :M
.119 .012(computer can be built from reversible conservative logic circuits, with the serendipitous advantage of dissipating far)J
41 231 :M
.287 .029(less heat than traditional Boolean AND/OR/NOT circuits.  Unlike functional languages, which have one "state" for)J
41 242 :M
.053 .005(all times, )J
f1_10 sf
(Y)S
f3_10 sf
.066 .007(-Lisp has at all times one "state", with unique predecessor and successor states.)J
41 258 :M
.984 .098(Compiling into a reversible pseudocode can have benefits even when targeting a traditional computer.  Certain)J
41 269 :M
-.004(optimizations, e.g., update-in-place, and compile-time garbage collection may be more easily performed, because the)A
41 280 :M
.62 .062(information may be elicited without the difficult and time-consuming iterative abstract interpretation required for)J
41 291 :M
-.022(most non-reversible models.)A
41 307 :M
2.069 .207(In a reversible machine, garbage collection for recycling storage can always be performed by a reversed)J
41 318 :M
.655 .066(\(sub\)computation.  While this "collection is reversed mutation" insight does not reduce space requirements when)J
41 329 :M
.921 .092(used for the computation as a whole, it does save space when used to recycle at finer scales.  This insight also)J
41 340 :M
-.043(provides an explanation for the fundamental importance of the push-down stack both for recognizing palindromes and)A
41 351 :M
-.023(for managing storage.)A
41 367 :M
-.076(Reversible computers are related to )A
f0_10 sf
-.088(Prolog)A
f3_10 sf
-.048(, )A
f0_10 sf
-.074(linear logic)A
f3_10 sf
-.074( and )A
f0_10 sf
-.082(chemical abstract machines)A
f3_10 sf
(.)S
41 386 :M
f4_12 sf
.425(Introduction)A
141 398 :M
f4_10 sf
2.181 .218(Those behind cried "Forward!")J
141 409 :M
2.246 .225(And those before cried "Back!")J
141 420 :M
f3_10 sf
.339 .034(T.B. Macaulay, )J
f0_10 sf
.31 .031(Lays of Ancient Rome \321 Horatius)J
f3_10 sf
.334 .033( \(1842\))J
41 436 :M
.549 .055(A physics revolution is brewing in computer science because many of the abstract models traditionally used have)J
41 447 :M
1.249 .125(failed to provide deep insight into parallel and distributed computation.  Discrete-time serial automata cannot)J
41 458 :M
1.386 .139(faithfully model a relativistic world in which communication is more expensive than computation.  Standard)J
41 469 :M
.331 .033(Boolean AND/OR/NOT logic found in all modern computers generates too much heat for use in high-performance)J
41 480 :M
-.004(3D logic circuits.  Parallel imperative programs have proved to be a nightmare to debug.  Lattice-based compile-time)A
41 491 :M
.898 .09(analysis has reached its limits, yet significant problems in "aliasing/sharing", "strictness/laziness" and "resource)J
41 502 :M
.179 .018(estimation" remain.)J
41 518 :M
1.915 .191(Physicists, on the other hand, routinely decide deep questions about physical systems\321e.g., they can talk)J
41 529 :M
.125 .012(intelligently about events that happened 15 billion years ago.  Computer scientists retort that computer programs are)J
41 540 :M
.575 .058(more complex than physical systems.  If this is true, then computer scientists should be embarrassed, considering)J
41 551 :M
-.027(the fact that computers and computer software are "cultural" objects\321they are purely a product of man's imagination,)A
41 563 :M
-.034(and may be changed as quickly as a man can change his mind.  Could God be a better hacker than man?)A
f3_9 sf
0 -3 rm
(2)S
0 3 rm
41 579 :M
f3_10 sf
1.415 .141(Computation has heretofor been based on )J
f0_10 sf
.346(writing)A
f3_10 sf
1.185 .119( metaphors, either the )J
f0_10 sf
.382(chalkboard)A
f3_10 sf
1.602 .16( metaphor\321e.g., the von)J
41 590 :M
.566 .057(Neumann model\321or the )J
f0_10 sf
.129(pen-and-paper)A
f3_10 sf
.494 .049( metaphor\321e.g., the functional/logical model, rather than the )J
f0_10 sf
.145(mechanical)A
41 601 :M
f3_10 sf
.499 .05(metaphor of physics.  The use of writing metaphors is curious, since a large fraction of computation is devoted to)J
41 612 :M
.26 .026(the simulation of physical systems!)J
41 628 :M
.029 .003(The property that makes the writing metaphor so attractive is that )J
f0_10 sf
.009(reading)A
f3_10 sf
.026 .003( has very little cost compared with )J
f0_10 sf
.008(writing)A
f3_10 sf
(;)S
41 639 :M
.574 .057(something can be read many times without alteration, and this property can be used to )J
f0_10 sf
.174(broadcast)A
f3_10 sf
.713 .071( information for)J
-4127 -4126 -1 1 -4125 -4126 1 -4127 -4127 @a
41 653.24 -.24 .24 184.24 653 .24 41 653 @a
41 666 :M
f3_9 sf
(1)S
f3_10 sf
0 3 rm
.182 .018(Apologies to Alan Dershowitz.)J
0 -3 rm
41 680 :M
f3_9 sf
.134(2)A
f3_10 sf
0 3 rm
.51 .051(E.g., none of the Ten Commandments is concerned with von Neumann's Machine, nor does Moses mention ever)J
0 -3 rm
41 694 :M
-.013(seeing von Neumann on the mountain where the Commandments were obtained.)A
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(Henry Baker; page: 2 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.384 .038(Proc. Int'l. Workshop on Memory Mgmt.)J
f3_12 sf
.328 .033(, St Malo, France, Sept. 1992, Springer LNCS 637.)J
72 753 :M
-.053(Copyright \251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(2)S
72 74 :M
f3_10 sf
1.025 .103(inexpensive reuse at a number of different times or locations.  This property allows physical simulations to be)J
72 85 :M
-.034(instrumented in discreet ways not allowed by Heisenberg's principle.)A
72 101 :M
.376 .038(Mechanical systems do not have the advantage of inexpensive copying, because mechanical objects can be in only)J
72 112 :M
.618 .062(one place at one time\321they are conserved.  While information can be recorded in an arrangement of mechanical)J
72 123 :M
.061 .006(objects and this arrangement can be copied into a similar arrangement of similar objects, the expense of this copying)J
72 134 :M
-.052(can be calculated and may be quite large.  The mechanical metaphor would thus seem to be at a hopeless disadvantage)A
72 145 :M
-.017(compared with the writing metaphor for general purpose computing.)A
72 161 :M
.073 .007(We have enjoyed the advantages of cheap copying so long, however, that we have difficulty perceiving its penalties.)J
72 172 :M
.587 .059(Its most apparent disadvantage is that software companies have a difficult time getting paid for their software\321a)J
72 183 :M
.88 .088(significant irritation, but not important enough to dramatically change the future of computing.  Illegal cloning,)J
72 194 :M
.594 .059(however, demonstrates a major problem with cheap copying\321which of the copies is the "real" one, and how can)J
72 205 :M
.323 .032(multiple copies be kept consistent?  "Object-oriented computing", a current major software trend, has at its core an)J
72 216 :M
.889 .089(assumption of )J
f0_10 sf
1.169 .117(object identity)J
f3_10 sf
.719 .072(, which is the ability of a software object to have an identity which distinguishes it)J
72 227 :M
.379 .038(from other objects.  In physical terms, the identity of an object must be )J
f0_10 sf
.128(conserved)A
f3_10 sf
.392 .039(, meaning that it has a particular)J
72 238 :M
.013 .001(location which is different from the locations of other objects.  According to Alan Kay [Kay77], it is no accident that)J
72 249 :M
.025 .003(object-oriented programming began with the )J
f0_10 sf
(Simula)S
f3_10 sf
.025 .002( language for \(physical\) simulation.)J
72 265 :M
.448 .045(A major problem in the programming of software simulations is in assuring that the simulations are faithful to the)J
72 276 :M
.349 .035("real" system\321i.e., whether the software model obeys the same conservation laws as the "real" system.  If the real)J
72 287 :M
.787 .079(system is a physical system, then the conservation laws are the laws of physics\321e.g., the conservation of mass,)J
72 298 :M
.54 .054(energy, etc., while if the real system is an economic one, then the conservation laws are the laws of economics\321)J
72 309 :M
1.222 .122(e.g., the conservation of money.  Much of the complexity of modern software systems can be traced to these)J
72 320 :M
.232 .023(requirements\321e.g., file backup and recovery, transaction models, type systems \(including those for physical units\),)J
72 331 :M
.164 .016(etc.  For example, if one physically removes a physical file from a physical filing cabinet, it no longer resides in the)J
72 342 :M
.337 .034(filing cabinet, so that there is no possibility of conflict.  The reading of a )J
f0_10 sf
.114(software)A
f3_10 sf
.304 .03( file, on the other hand, does )J
f0_10 sf
.168(not)A
72 353 :M
f3_10 sf
.318 .032(remove the file, so we must go to extra trouble to avoid conflicts with writers and other readers.  In short, we must)J
72 364 :M
.067 .007(use an lot of computing "machinery" to simulate an innately conservative "mechanical" system.)J
72 380 :M
-.015(Current computer )A
f0_10 sf
-.016(languages)A
f3_10 sf
-.016( are based on ideas from 3 models\321the von Neumann random-access memory, Church's)A
72 391 :M
.247 .025(lambda calculus, and Boolean logic networks.  The serial nature of von Neumann RAM's shows up in conditionals,)J
72 402 :M
.77 .077(goto's, and assignments; this model has been attacked by advocates of the functional/applicative/logic languages)J
72 413 :M
.834 .083(based loosely on a write-once policy, which allows for more parallel execution while preserving Church-Rosser)J
72 424 :M
.174 .017(determinism.  Boolean circuits can be claimed by both the functional/logical and the RAM communities, depending)J
72 435 :M
.62 .062(upon whether they are purely combinational or have feedback.  All of these models, however, assume 1\) that the)J
72 447 :M
f0_10 sf
.185(duplication)A
f3_10 sf
.523 .052( of information is free; and 2\) that the )J
f0_10 sf
.183(destruction)A
f3_10 sf
.631 .063( of information is free.)J
f3_9 sf
0 -3 rm
.201(3)A
0 3 rm
f3_10 sf
.522 .052(  A RAM reads a cell many)J
72 458 :M
.961 .096(times between writes, knowing that the value will always be that of the last write; the S combinator cheerfully)J
72 469 :M
.821 .082(copies; and Boolean circuit models may allow indefinite fanout.  A RAM write wipes out the previous memory)J
72 480 :M
.078 .008(contents; the K combinator knowingly kills; and Boolean AND's and OR's are not invertible.)J
72 496 :M
.282 .028(Physical circuits have never lived up to these ideals.  Physical storage \(cores,  DRAM's\) must be refreshed, fan-out)J
72 507 :M
.396 .04(is limited and too much heat is generated.  Yet the physical systems of which real computers are composed do not)J
72 518 :M
.248 .025(have these problems.  All microscopic physical processes are inherently )J
f0_10 sf
.062(conservative)A
f3_10 sf
.225 .022(, which means that in addition)J
72 529 :M
1.516 .152(to conserving mass, energy, momentum, etc., they also )J
f0_10 sf
2.602 .26(conserve information)J
f3_10 sf
1.427 .143(.  The fundamental theorem of)J
72 540 :M
.506 .051(mechanics states that "phase space is incompressible" [Penrose89], which means that two separate "states" cannot)J
72 551 :M
.402 .04(converge, nor can a single state diverge.  Of course, separate points which are initially "close" in phase space may)J
72 562 :M
.958 .096(become widely dispersed; this behavior has been termed )J
f0_10 sf
.238(chaotic)A
f3_10 sf
1 .1(, even though chaotic mechanical systems still)J
72 573 :M
.89 .089(conserve information.  It is this theorem that produces the limits on a Carnot heat engine, because for a Carnot)J
72 584 :M
.732 .073(engine to produce )J
f0_10 sf
.237(work)A
f3_10 sf
.62 .062(, it must somehow )J
f0_10 sf
.228(summarize)A
f3_10 sf
.758 .076( the information which describes the randomness in a high)J
72 595 :M
.233 .023(temperature reservoir using a smaller amount of energy in the lower temperature reservoir.  It is not the excess heat)J
72 606 :M
f0_10 sf
.031(energy)A
f3_10 sf
.1 .01( that must be exhausted into the lower temperature reservoir, but the excess )J
f0_10 sf
.029(information)A
f3_10 sf
.094 .009(!  Since the reliability)J
72 617 :M
.124 .012(of encoding this information is inversely proportional to the temperature, one can encode this information using less)J
72 629 :M
-.002(energy only when the exhaust temperature is lower.)A
f3_9 sf
0 -3 rm
(4)S
0 3 rm
72 645 :M
f3_10 sf
.278 .028(Electrical engineers spend a great deal of their time modelling traditional non-conservative two-state Boolean logic)J
72 656 :M
.208 .021(with reversible physical processes, which are most uncooperative.  Thus, one must switch hundreds or thousands of)J
72 667 :M
.43 .043(electrons, and give up hundreds or thousands of "kT's" to make sure that a single bit is transmitted reliably.  If we)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 684.24 -.24 .24 215.24 684 .24 72 684 @a
72 697 :M
f3_9 sf
.053(3)A
f3_10 sf
0 3 rm
.215 .021(The "garbage collector" can erase a "write-once" memory in functional systems without contradiction, because the)J
0 -3 rm
72 711 :M
-.019(memory has previously become inaccessible.)A
72 722 :M
f3_9 sf
(4)S
f3_10 sf
0 3 rm
-.004(Black holes seem to "eat" information; perhaps black holes are the "cooling fans" for the Biosphere of the universe.)A
0 -3 rm
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(Henry Baker; page: 3 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.384 .038(Proc. Int'l. Workshop on Memory Mgmt.)J
f3_12 sf
.328 .033(, St Malo, France, Sept. 1992, Springer LNCS 637.)J
72 753 :M
-.053(Copyright \251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(3)S
72 74 :M
f3_10 sf
.415 .041(want to utilize these devices to compute conservative computations, we must then spend hundreds or thousands of)J
72 86 :M
.954 .095(devices to reliably simulate conservatism.  In other words, we have given up factors of 10)J
f3_9 sf
0 -3 rm
.287(6)A
0 3 rm
f3_10 sf
.283(-10)A
f3_9 sf
0 -3 rm
.287(9)A
0 3 rm
f3_10 sf
.849 .085( in time and/or)J
72 97 :M
1.864 .186(energy dissipation for nothing!  Yet functional/logic programming, database programming and many other)J
72 108 :M
.901 .09(computations \(e.g., FFT's\) either are, or can readily be reorganized to be, conservative!  Biological information)J
72 119 :M
.168 .017(processing, for example, dissipates far less heat/information.  The processes used to copy DNA and transcribe RNA)J
72 130 :M
.647 .065(are mostly conservative, or else the heat dissipated during cell mitosis in an embryonic chicken would produce a)J
72 141 :M
-.224(hard-boiled egg!)A
72 157 :M
1.354 .135(If heat dissipation were the only problem with traditional computer models, the hardware circuits underlying)J
72 168 :M
.793 .079(individual functional units such as multipliers and caches could be re-implemented using conservative logic and)J
72 179 :M
1.162 .116(thereby eliminate 80-90% of the wasted heat.  We would then not need to change the abstraction seen by the)J
72 190 :M
.596 .06(programmer or compiler; after all, computer engineers have been hiding the physical truth from programmers for)J
72 201 :M
-.028(over 50 years.)A
72 217 :M
.562 .056(Yet it is actually at the )J
f0_10 sf
.215(highest)A
f3_10 sf
.851 .085( levels of computer usage where the traditional computer models are wearing the)J
72 228 :M
.245 .025(thinnest.  One finds it very difficult to ensure that an accounting system "conserves money", or to ensure that a sort)J
72 239 :M
.364 .036(program "conserves records", or that a file system "preserves information".  It is difficult to program a compiler to)J
72 250 :M
.203 .02(optimize the use of registers in the face of arbitrary control structures, or for parallel process to automatically "back)J
72 261 :M
1.832 .183(down" during an optimistic concurrency control.  Static analysis has failed to routinely produce important)J
72 272 :M
.79 .079(information, such as that needed for "escape analysis", "strictness analysis" and "aliasing/sharing analysis".  For)J
72 283 :M
.477 .048(example, Milner's elegant type inference algorithm is routinely used to statically decorate ML programs with type)J
72 294 :M
.627 .063(information, which is useful for partial correctness, but type information produces at most an order of magnitude)J
72 305 :M
.144 .014(performance improvement over a dynamically typed system.  Milner's algorithm can also be used to produce deeper)J
72 316 :M
.58 .058(structure sharing information [Baker90UC], but we conjecture that this usage will bring out the algorithm's latent)J
72 327 :M
1.149 .115(exponential behavior.  In short, static analysis techniques can produce interesting information only when their)J
72 338 :M
.197 .02(computational complexity is hopelessly exponential.)J
72 354 :M
-.023(As a result of these considerations, we advocate the use of models of computation which have more structure because)A
72 365 :M
.555 .056(they obey more laws and restrictions.  Strongly typed and functional systems are restrictive in their own way; we)J
72 376 :M
.03 .003(advocate restrictions which inherently conserve information\321i.e., copying is expensive, and information destruction)J
72 387 :M
.555 .055(is impossible.  Since information is conserved, these programs are )J
f0_10 sf
.139(reversible)A
f3_10 sf
.585 .059(; reversibility becomes a property as)J
72 398 :M
.697 .07(important as the determinacy guaranteed by the Church-Rosser theorem.  Because deciding reversibility for bulk)J
72 409 :M
1.683 .168(computations is generally unsolvable, we guarantee it instead by constructing computations from reversible)J
72 420 :M
-.03(primitives which are reversibly composed.)A
72 436 :M
.754 .075(While many computations are obviously reversible\321e.g., FFT's\321a skeptic might wonder how often this is true.)J
72 447 :M
1.206 .121(For example, a sorting algorithm apparently throws away at least n\245logn bits of information in the process of)J
72 458 :M
.219 .022(sorting n records.  However, if the input records are given "serial numbers", then the original order can be retrieved)J
72 469 :M
.428 .043(by resorting on the serial numbers.  Since the concatenation of serial numbers to the input records is conservative,)J
72 480 :M
.62 .062(we find that it is the )J
f0_10 sf
.273(erasure)A
f3_10 sf
.869 .087( of these serial numbers at the end of sorting that inhibits reversibility, and not the)J
72 491 :M
.605 .06(sorting operation itself.  The Newton iterative square root algorithm x)J
f3_8 sf
0 2 rm
.133(i+1)A
0 -2 rm
f3_10 sf
.172(=\(x)A
f3_8 sf
0 2 rm
.082(i)A
0 -2 rm
f3_10 sf
.191(+N/x)A
f3_8 sf
0 2 rm
.082(i)A
0 -2 rm
f3_10 sf
.56 .056(\)/2 exemplifies a large class of)J
72 503 :M
.547 .055(computations in which the output appears to be independent of the input, since the Newton iteration produces the)J
72 514 :M
1.154 .115(square root independent of the initial approximation.  Nevertheless, if this algorithm is run a fixed number of)J
72 526 :M
.372 .037(iterations on infinite precision rational numbers, and if x)J
f3_9 sf
0 3 rm
.103(0)A
0 -3 rm
f3_10 sf
cF
f1_10 sf
.028<B3>A
sf
.282 .028(sqrt\(N\), it is )J
f0_10 sf
.092(reversible)A
f3_10 sf
.076(!)A
f3_9 sf
0 -3 rm
.103(5)A
0 3 rm
f3_10 sf
.397 .04(  Newton's iteration essentially)J
72 539 :M
.156 .016(encodes the initial conditions into lower and lower order bits, until these bits become insignificant.  It is the )J
f0_10 sf
.056(erasure)A
72 550 :M
f3_10 sf
.013 .001(of these low order bits through rounding and/or truncation that dissipates the information needed for reversibility.  In)J
72 561 :M
-.038(a sense, Newton's iteration converges only because Newton's inverted iteration produces chaos.)A
72 577 :M
.873 .087(Many arithmetic operations such as increment and negate are invertible.  Multiplication, however, opens up the)J
72 588 :M
.294 .029(possibility of multiplying a number by zero and losing all information about the number.  In this instance, we must)J
72 599 :M
.899 .09(have a "multiplication by zero" exception which is analogous to "division by zero".  Although multiplication is)J
72 610 :M
.963 .096(mathematically commutative, we need check only one argument for zero, because we will then know the other)J
72 621 :M
-.047(argument was zero in the case of a zero product.)A
72 637 :M
f0_10 sf
.308 .031(Time warp)J
f3_10 sf
.233 .023( [Jefferson85] was the first general scheme for reversing an arbitrary distributed computation.  However,)J
72 648 :M
.417 .042(the primitive message-passing actors upon which time warp is based are traditional state machines; therefore, they)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 673.24 -.24 .24 215.24 673 .24 72 673 @a
72 686 :M
f3_9 sf
.188(5)A
f3_10 sf
0 3 rm
.682 .068(Curiously, inverting Newton's square root iteration itself requires taking a square root.  However, the inputs for)J
0 -3 rm
72 700 :M
.778 .078(these roots will always be )J
f0_10 sf
1.015 .102(rational perfect squares )J
f3_10 sf
.824 .082(if the initial forward approximation is rational.  If the initial)J
72 712 :M
.835 .083(approximation is chosen so that x)J
f3_8 sf
0 3 rm
.207(0)A
0 -3 rm
f3_9 sf
0 -3 rm
.232(2)A
0 3 rm
f3_10 sf
.441 .044(-N is )J
f0_10 sf
.22(not)A
f3_10 sf
.731 .073( a perfect square, then reversal can use this property as its stopping)J
72 725 :M
-.027(criterion, and the algorithm becomes reversible even without the requirement for a fixed number of iterations.)A
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(Henry Baker; page: 4 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.384 .038(Proc. Int'l. Workshop on Memory Mgmt.)J
f3_12 sf
.328 .033(, St Malo, France, Sept. 1992, Springer LNCS 637.)J
72 753 :M
-.053(Copyright \251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(4)S
72 74 :M
f3_10 sf
.34 .034(can only be "rolled back" if they have saved copies of previous states.  If, on the other hand, these primitive actors)J
72 85 :M
-.003(are all themselves reversible, then most of the clutter can be removed from this elegant scheme.)A
72 101 :M
.373 .037(It is no accident that there is a significant overlap between those working on garbage collection and those working)J
72 112 :M
1.934 .193(on "undoing" computations for purposes such as nondeterministic search, debugging, backup/recovery and)J
72 123 :M
.138 .014(concurrency control.  However, the approach previously taken has been to utilize garbage collection to help manage)J
72 134 :M
1.063 .106(the data structures used for "undoing".  Our approach is exactly the opposite\321)J
10 f6_1 :p
131.961 :m
1.215 .122(we propose using "undoing" to)J
72 146 :M
116.534 :m
1.796 .18(perform garbage collection)J
1.017 .102(.  In other words, the concept of reversibility is too important to be left to garbage)J
72 158 :M
1.112 .111(collection and storage management.  Garbage collection by undoing is more powerful than traditional garbage)J
72 169 :M
.201 .02(collection, because it can be used even for Actor systems in which the garbage may be quite active and thus hard to)J
72 180 :M
-.175(catch [Baker77].)A
72 199 :M
f4_12 sf
3.467 .347(Garbage Collection)J
72 216 :M
f3_10 sf
.122 .012(Garbage collection is a favorite topic of researchers; the number of published papers on this topic approaches 1,000.)J
72 227 :M
1.207 .121(Yet, the necessity for "garbage collection" in a symbolic processing system has troubled researchers from the)J
72 238 :M
.32 .032(beginning.  That the symbolic computations required in Artificial Intelligence \(AI\) applications generate "garbage")J
72 249 :M
.127 .013(which must be recycled, has long been a fundamental assumption; AI applications tend to "hypothesize and test", so)J
72 260 :M
-.02(the structures created during hypothesizing must somehow be recycled when the test is not successful.)A
72 276 :M
.494 .049(Despite its apparent popularity, garbage collection has never been a subfield of computer science in its own right,)J
72 287 :M
1.834 .183(because it is always seen as a semantics-preserving )J
f0_10 sf
3.409 .341(transparent optimization)J
f3_10 sf
2.027 .203( in a programming language)J
72 298 :M
.966 .097(implementation.  Since it is by definition "invisible" to the programmer, the topic itself continues to be "swept)J
72 309 :M
.361 .036(under the rug".  Unfortunately, the rug has developed a huge mound beneath it, because we cannot characterize on)J
72 320 :M
.125 .012(theoretical grounds the costs and benefits of various garbage collection algorithms, but must rely on relatively crude)J
72 331 :M
.058 .006(and )J
f0_10 sf
.081 .008(ad hoc)J
f3_10 sf
.078 .008( measurements.  For example, we have no theoretical model which can tell us that "generational" garbage)J
72 342 :M
.854 .085(collection is inherently better than non-generational garbage collection, even though a number of measurements)J
72 353 :M
.287 .029(seem to bear this out.)J
72 369 :M
.506 .051(Whether a computational object is "garbage" or not depends upon one's point of view.  From the point of view of)J
72 380 :M
.37 .037(the computation itself\321i.e., the "mutator"\321a garbage object becomes inaccessible and cannot influence the future)J
72 391 :M
.381 .038(course of the computation.  From the point of view of the system\321"mutator" plus "collector", however, the object)J
72 402 :M
.018 .002(is still accessible, and will be reclaimed by the collector.)J
72 418 :M
.114 .011(Since it is the mutator which "loses" objects, and the collector which "finds" them, we have another characterization)J
72 429 :M
.246 .025(of the mutator/collector interaction.  What do we mean by "losing an object"?  Clearly, the object is not completely)J
72 440 :M
1 .1(lost, because the collector can find it; however, the mutator has "lost track" of it.  More precisely, the mutator)J
72 451 :M
1.172 .117(destroys its )J
f0_10 sf
.348(information)A
f3_10 sf
.956 .096( about locating the object, and it is up to the collector to )J
f0_10 sf
.351(regenerate)A
f3_10 sf
1.513 .151( this information.)J
72 462 :M
.592 .059(Intuitively, the mutator is a "randomizing" influence, while the collector is an "ordering" influence.  Interestingly)J
72 473 :M
.042 .004(enough, the mutator and the collector must both be either dissipative, or both conservative; one cannot be dissipative)J
72 484 :M
.687 .069(while the other remains conservative.  If the collector is conservative and the mutator non-conservative, then the)J
72 495 :M
.372 .037(collector must somewhere dissipate the information it computes about which objects are garbage, since it creates a)J
72 506 :M
.584 .058(free-list with zero entropy/information.  Similarly, if the mutator is conservative, then it doesn't produce garbage,)J
72 517 :M
-.011(and the collector is trivially conservative.)A
72 533 :M
1.046 .105(The efficiency of a generational garbage collector comes from its ability to recover storage before the mutator)J
72 544 :M
.337 .034(dissipates the information.  It can do this because it can localize easily recovered garbage to a small fraction of the)J
72 555 :M
.347 .035(address space.  If the newest generation consists of 1/256'th of the cells, and if half of these cells are garbage, then)J
72 566 :M
.138 .014(the )J
f0_10 sf
.058(temperature)A
f3_10 sf
.195 .02( of this generation is the number of cells divided by the amount of information )J
cF
f1_10 sf
.02<BB>A
sf
.195 .02( \(N/256\)/\(N/256\) )J
cF
f1_10 sf
.195 .02<BB>J
sf
72 577 :M
.515 .051(1)J
cF
f1_10 sf
.051<B0>A
sf
.515 .051(.  The generational collector will have an input "temperature" of )J
cF
f1_10 sf
.051<BB>A
sf
.515 .051(1)J
cF
f1_10 sf
.051<B0>A
sf
.515 .051( and an exhaust "temperature" of )J
cF
f1_10 sf
.051<BB>A
sf
.515 .051(0.5)J
cF
f1_10 sf
.051<B0>A
sf
.515 .051(.  A)J
72 588 :M
1.84 .184(non-generational collector collecting the same amount of garbage would have an input "temperature" of )J
cF
f1_10 sf
1.84 .184<BB>J
sf
72 599 :M
.636 .064(\(N\)/\(.0204N\) )J
cF
f1_10 sf
.064<BB>A
sf
.636 .064( 49)J
cF
f1_10 sf
.064<B0>A
sf
.636 .064(, and an exhaust "temperature" of 511/512'th of that.  Thus, a generational collector would be)J
72 610 :M
.249 .025(operating at a temperature ratio of 2:1, while a non-generational collector would be operating at a temperature ratio)J
72 621 :M
.304 .03(of 1.002:1.  Since the efficiency of a "Carnot" GC is proportional to the ratio of input to exhaust temperatures, it is)J
72 632 :M
.881 .088(easy to see why the generational GC is more efficient.  \(Of course, no reasonable system would operate a non-)J
72 643 :M
.069 .007(generational collector with such a small temperature differential.\)  Thus, the effectiveness of a generational collector)J
72 654 :M
.325 .033(depends upon reclaiming a higher fraction of cells than a full GC\321i.e., a "dying" cell is statistically more likely to)J
72 665 :M
.194 .019(be young than old.  If this is not true, then generational GC will not be effective.)J
72 684 :M
f4_12 sf
2.627 .263(Reference Counting and Functional Programming)J
72 701 :M
f3_10 sf
.551 .055(The lambda calculus and combinators can be implemented using reference counting to collect "garbage", because)J
72 712 :M
-.016(these models do not require directed cycles.  Many implementations do use directed cycles, however, for "efficiency")A
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(Henry Baker; page: 5 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.384 .038(Proc. Int'l. Workshop on Memory Mgmt.)J
f3_12 sf
.328 .033(, St Malo, France, Sept. 1992, Springer LNCS 637.)J
72 753 :M
-.053(Copyright \251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(5)S
72 74 :M
f3_10 sf
1.161 .116(in implementing the Y combinator used to express recursion.  However, even with these Y combinator loops,)J
72 85 :M
-.043(reference counting can still be used to collect garbage, because the Y loops are well-structured [Peyton-Jones87].)A
72 101 :M
.686 .069(Functional languages cannot "overwrite" a storage location, because assignment is prohibited.  This property has)J
72 112 :M
.303 .03(been called the "write-once" property of functional languages, and this property is shared with "logic languages"\321)J
72 123 :M
.112 .011(e.g., Prolog.  Since storage is never overwritten, the entire history of the computation is captured, and it would seem)J
72 134 :M
.066 .007(that we are very close to Charles Bennett's original thermodynamically efficient Turing Machine [Bennett73], which)J
72 145 :M
.545 .054(kept track on a separate tape of all of its actions.  However, standard functional language implementations do not)J
72 156 :M
-.077(preserve the information regarding which branches were taken.)A
72 172 :M
1.814 .181(Interestingly, functional language implementations depend upon garbage collection to implement all of the)J
72 183 :M
.537 .054(optimizations which require "side-effects".  For example, MLNJ [Appel90] does frame allocation on the garbage-)J
72 194 :M
.633 .063(collected heap, so that all garbage normally recycled by "stack allocation" is performed by the garbage collector.)J
72 205 :M
-.001(Furthermore, the use of shallow binding for the implementation of functional arrays [Baker91SB] allows the garbage)A
72 216 :M
-.014(collector to perform the in-place "assignment" normally expected in an imperative language implementation.)A
72 232 :M
.611 .061(Since functional programming is a "good thing", and since reference counting is sufficient for these languages, it)J
72 243 :M
1.028 .103(would seem that little more can be said.  However, evidence is starting to mount that the lambda calculus and)J
72 254 :M
1.401 .14(combinators, which are pure models of )J
f0_10 sf
.337(substitution)A
f3_10 sf
.673 .067( and )J
f0_10 sf
.392(copying)A
f3_10 sf
1.135 .114(, may not be the best models for the highest)J
72 265 :M
.079 .008(performance parallel computers.  Although one reason for this is that )J
f0_10 sf
.023(copying)A
f3_10 sf
.074 .007( may be a very expensive operation for)J
72 276 :M
.457 .046(a physical computer, the major reason for the current interest in models which perform less copying\321e.g., "linear)J
72 287 :M
.628 .063(logic"\321is the fact that a system which copies in an unrestricted fashion also loses track of things, and requires a)J
72 298 :M
-.095(garbage collector.)A
72 317 :M
f4_12 sf
2.652 .265(Conservative Automata and Reversible Computation)J
72 334 :M
f3_10 sf
.181 .018(A number of researchers have been studying the ultimate limits to computation from a physical perspective in order)J
72 345 :M
.219 .022(to guide engineers in designing high performance computers.  In particular, these researchers have attacked a major)J
72 356 :M
.144 .014(problem for these computers\321the generation of heat.  As computers become faster and smaller, the removal of heat)J
72 367 :M
.2 .02(becomes a very difficult problem.  One of the limitations on the number of active devices on a chip, for example, is)J
72 378 :M
.145 .014(the ability of the chip package to remove the heat fast enough to keep the chip from immolating itself.)J
72 394 :M
.247 .025(It was long conjectured that heat was an essential byproduct of computation, but Bennett obliterated this conjecture)J
72 405 :M
-.036(by demonstrating a thermodynamically reversible computer [Bennett73].  Because it is thermodynamically reversible,)A
72 416 :M
-.021(any excess energy given off during one portion of the computation would be reabsorbed during another portion of the)A
72 427 :M
.166 .017(computation, leaving the entire computation energy and entropy neutral.  Bennett's results show that computation in)J
72 438 :M
-.044(and of itself does not generate waste heat, but any )A
f0_10 sf
-.05(erasure)A
f3_10 sf
-.047( of information must necessarily generate waste heat.)A
72 454 :M
.542 .054(Fredkin and his collaborators [Toffoli80] [Margolus88] are refining Bennett's work to show models for reversible)J
72 465 :M
.517 .052(logic which could be used on a thermodynamically-efficient logic chip.  They have exhibited techniques for logic)J
72 476 :M
.089 .009(design using )J
f0_10 sf
.145 .015(conservative logic)J
f3_10 sf
.089 .009(, which conserves entropy by remaining reversible.  They go on to show physics-like)J
72 487 :M
-.026(conservation principles, as well as logical analogues to )A
f0_10 sf
-.031(energy)A
f3_10 sf
(, )S
f0_10 sf
-.03(entropy)A
f3_10 sf
-.026( and )A
f0_10 sf
-.03(temperature)A
f3_10 sf
(.)S
72 503 :M
.085 .008(We were intrigued by their simulation of traditional AND/OR/NOT Boolean logic circuits using reversible logic.  In)J
72 514 :M
.217 .022(this simulation, each of the traditional gates is mapped into a configuration of reversible logic gates, but these gates)J
72 525 :M
1.392 .139(have a number of "garbage" outputs, in addition to the simulated outputs.  Bennett's key idea in making the)J
72 536 :M
.668 .067(emulation reversible is to mirror the mapped circuit with a reversed version of itself, with each "garbage output")J
72 547 :M
.196 .02(being connected to the mirror image wire thus becoming a "garbage input" for the reversed circuit.  So far, we have)J
72 558 :M
.56 .056("much ado about nothing", since the output of the reversed computation is exactly the same as the original input!)J
72 569 :M
(However, we can put additional reversible gates )S
f0_10 sf
(in between)S
f3_10 sf
( the mapped circuit and its reverse, which can "sense" the)S
72 580 :M
.525 .052(output to either affect some other computation, or to copy the final answer.  Thus, just as the reversible computer)J
72 591 :M
.35 .035(collects its garbage bits with a reversed computation\321after suitably summarizing the computation's result, we will)J
72 602 :M
-.044(utilize a reversed computation to recycle other kinds of resources\321e.g., storage and processors.)A
72 621 :M
f4_12 sf
2.768 .277(Reversible Pointer Automata)J
72 638 :M
f3_10 sf
.552 .055(A pointer automaton can be constructed from Fredkin's conservative logic using his universal simulation for non-)J
72 649 :M
.227 .023(conservative logic [Barton78] [Ressler81].  This simulation is not the most efficient use of logic or space, however.)J
72 660 :M
-.038(We describe a reversible pointer automaton which is a better model for a conservative higher level language.)A
72 676 :M
.434 .043(Our reversible pointer automata will retain the finite state control and pointer registers, but with some restrictions.)J
72 687 :M
-.027(We need to make sure that each instructions can be "undone", and must therefore retain enough information about the)A
72 698 :M
1.021 .102(previous state.  All of the instructions are )J
f0_10 sf
.353(exchanges)A
f3_10 sf
1.624 .162(, conditional exchanges, and primitive arithmetic/logical)J
72 709 :M
.333 .033(operations.  Arithmetic/logical instructions only come in forms that are invertible; e.g., replace the pair of registers)J
72 720 :M
-.001(which encode a double-precision integer dividend by an integer quotient and an integer remainder, with no change in)A
endp
%%Page: 6 6
%%BeginPageSetup
initializepage
(Henry Baker; page: 6 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.384 .038(Proc. Int'l. Workshop on Memory Mgmt.)J
f3_12 sf
.328 .033(, St Malo, France, Sept. 1992, Springer LNCS 637.)J
72 753 :M
-.053(Copyright \251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(6)S
72 74 :M
f3_10 sf
.428 .043(the case of a zero divisor.  Since the double-precision dividend can be reconstituted from the divisor, quotient and)J
72 85 :M
.063 .006(remainder, the instruction is invertible.)J
72 101 :M
.986 .099(The following are primitive machine operations, where x,y,z,\311 denote distinct registers, x:y denotes a double-)J
72 112 :M
.748 .075(precision "register" constructed from the concatenation of x and y, and a,b,c,\311 denote distinct constants.  Some)J
72 123 :M
.977 .098(operations have additional constraints which cause them to "stick" in the same state.  Arithmetic operations on)J
72 136 :M
-.051("integers" are performed modulo 2)A
f8_9 sf
0 -4 rm
-.065(w)A
0 4 rm
f3_10 sf
-.048(, where )A
f8_10 sf
-.072(w)A
f3_10 sf
-.048( is the word size.)A
72 158 :M
.108 .011(x <-> y; exchange x and y.)J
72 169 :M
.052 .005(x <-> CAR\(y\); exchange x and CAR\(y\).)J
72 180 :M
.052 .005(x <-> CDR\(y\); exchange x and CDR\(y\).)J
72 191 :M
.371 .037(y := CONS\(x,y\) & x := nil; push x onto y and set x to nil.)J
72 202 :M
-.026(if x=nil then swap\(y,z\); conditional exchange operation.)A
72 213 :M
.052 .005(inc\(x,y\), semantics: x:=x+y; inverse is dec\(x,y\).)J
72 224 :M
-.004(dec\(x,y\), semantics: x:=x-y; inverse is inc\(x,y\).)A
72 235 :M
.209 .021(minus\(x\), semantics: x:=-x; inverse is minus\(x\).)J
72 246 :M
.275 .028(mpy\(x,y,z\), 0)J
cF
f1_10 sf
.028<A3>A
sf
.275 .028(x<z, semantics: x:y:=y*z+x; inverse is div\(x,y,z\).)J
72 257 :M
.086 .009(div\(x,y,z\), 0)J
cF
f1_10 sf
.009<A3>A
sf
.086 .009(x<z, semantics: x:=\(x:y\) mod z || y:=\(\(x:y\)-\(\(x:y\) mod z\)\)/z; inv. is mpy\(x,y,z\).)J
72 268 :M
.086 .009(rot\(x,c\) rotates the bit pattern in x by c bits; inverse is rot\(x,-c\)=rot\(x,w-c\).)J
72 279 :M
.182 .018(xor\(x,y\), x,y distinct registers, has the semantics x:=x xor y; inverse is xor\(x,y\).)J
72 290 :M
-.039(reverse\(x\) reverses the bits in register x; inverse is reverse\(x\).)A
72 301 :M
-.14(macro for push\(r1,r2\): {car\(free\)<->r1; r2<->cdr\(free\); r2<->free;})A
72 312 :M
-.061(macro for pop\(r2,r1\):)A
72 323 :M
-.062(\312\312if consp\(r2\) and null\(r1\) then {r2<->free; r2<->cdr\(free\); car\(free\)<->r1;})A
72 334 :M
-.091(macro for push\(r\): {push\(r,stack\);})A
72 345 :M
-.103(macro for pop\(r\): {pop\(stack,r\);})A
72 361 :M
.23 .023(This machine language is carefully designed in such a way that all operations are invertible.  This property requires)J
72 372 :M
.68 .068(restrictions on the topology of the program flowchart.  We can "test" a value in a register, but the value must be)J
72 383 :M
.127 .013(preserved during, or restored after, the operations depending upon the test, so that when the program is reversed, we)J
72 394 :M
.664 .066(can test it again to reverse the appropriate arm of the conditional.  Suitably structured programs can be statically)J
72 405 :M
.349 .035(checked for proper topology.  Suzuki has proved [Suzuki82] that under these conditions 1\) all reference counts are)J
72 416 :M
.723 .072(preserved, and 2\) garbage cannot be created.  Since all cons cells on the free list start out with a unity reference)J
72 427 :M
.667 .067(count, they always have a unity reference count\321i.e., we have a Linear Lisp.  Overall reversibility thus depends)J
72 438 :M
-.021(upon reversible primitives reversibly composed.)A
72 457 :M
f4_12 sf
3.347 .335(Programming Style)J
72 474 :M
f3_10 sf
1.53 .153(An operation P will have a "right" inverse when there exists an inverse operation P' which undoes the first)J
72 485 :M
.148 .015(operation\321i.e., P\245P'=I \(the identity\).  For example, )J
f8_10 sf
.053(COPY)A
f3_10 sf
.068 .007( and )J
f8_10 sf
.053(EQUAL)A
f3_10 sf
.126 .013( are essentially inverses of one another, as are)J
72 496 :M
.442 .044("destructuring bind" and "backquote".  We may not be able to execute P' in an arbitrary state, however, because it)J
72 507 :M
.262 .026(may have conditions on it which cannot be satisfied.  When P' is attempted in a situation in which its preconditions)J
72 518 :M
.297 .03(fail, we say that P' )J
f0_10 sf
.103(sticks)A
f3_10 sf
.401 .04(, without doing anything else.  Unlike most models, we do not map sticking states into an)J
72 529 :M
.289 .029(overall computational )J
f0_10 sf
.051(failure)A
f3_10 sf
.195 .02(, because failure loses all information about what failed and how it failed, which is the)J
72 540 :M
-.017(whole point of reversible computation used for debugging.)A
72 556 :M
1.403 .14(The strangeness of the reversible programming style is due mainly to our lack of experience with it.  Every)J
72 567 :M
1.232 .123(subcomputation must be reversible, which means that no information is destroyed within the subcomputation.)J
72 578 :M
.275 .027(Loops in which the number of iterations is )J
f0_10 sf
.336 .034(a priori)J
f3_10 sf
.27 .027( fixed are trivial to reverse; other loops may require a counter to)J
72 589 :M
-.01(remember the number of iterations.)A
72 605 :M
1.591 .159(The hardest part of inverting an iterative program is to arrange that the loop iterations themselves preserve)J
72 616 :M
.215 .021(information.  While a loop can always store its information in the form of a "trail" \(analogous to the Prolog "trail"\),)J
72 627 :M
.614 .061(the amount of storage required may grow quite rapidly.  )J
10 f6_1 :p
232.125 :m
.703 .07(The ability to summarize the information within a fixed)J
72 639 :M
435.958 :m
1.53 .153(number of "state variables" is the reversible computer's analogue to the "tail recursion optimization")J
1.631 .163(, which)J
72 651 :M
-.02(transforms recursive functional programs into iterative imperative programs.)A
72 667 :M
.475 .048(A reversible computer can utilize the following optimization for loops.  Most loop tests rarely succeed, and hence)J
72 678 :M
.613 .061(produce little "information"; they cannot be dispensed with, however, else the loop would never terminate.  On a)J
72 689 :M
.406 .041(reversible computer the loop body can be iteratively doubled in size, and when it has exceeded the final value, the)J
72 700 :M
.467 .047(loop can be backed up to the correct point.  This scheme involves only O\(logn\) tests instead of O\(n\), but the non-)J
72 711 :M
.221 .022(test work may double.  As a result, it is useful only if the test is expensive relative to the body.)J
endp
%%Page: 7 7
%%BeginPageSetup
initializepage
(Henry Baker; page: 7 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.384 .038(Proc. Int'l. Workshop on Memory Mgmt.)J
f3_12 sf
.328 .033(, St Malo, France, Sept. 1992, Springer LNCS 637.)J
72 753 :M
-.053(Copyright \251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(7)S
72 79 :M
f3_10 sf
1.676 .168(Input is handled by saving the input stream as in many other reversible and functional systems [Barton78])J
72 90 :M
.616 .062([Jefferson85].  Output could conceivably be "taken back" when reversed, as in pure )J
f0_10 sf
.917 .092(Time Warp)J
f3_10 sf
.728 .073( [Jefferson85], or)J
72 101 :M
.071 .007(saved until there is no further possibility of reversing, and then output, as in standard )J
f0_10 sf
.118 .012(Time Warp)J
f3_10 sf
(.)S
72 115 :M
f5_10 sf
1.325(Y)A
f4_10 sf
3.213 .321(-Lisp \321 Reversible Linear Lisp)J
f3_9 sf
0 -3 rm
(6)S
0 3 rm
72 131 :M
f3_10 sf
.322 .032(In a companion paper [Baker92LL], we introduced )J
f0_10 sf
.406 .041(Linear Lisp)J
f3_10 sf
.234 .023(, which is a variant of Lisp in which every cons cell)J
72 142 :M
.404 .04(has a unity reference count.  In this section, we introduce a variant of Linear Lisp called )J
f1_10 sf
.238(Y)A
f3_10 sf
.542 .054(-Lisp which looks very)J
72 153 :M
.497 .05(much like traditional Lisp, but all of its programs are reversible.  The primitive operations of )J
f1_10 sf
.272(Y)A
f3_10 sf
.531 .053(-Lisp are many of)J
72 164 :M
.96 .096(the operations discussed in previous sections.  We make extensive use of swapping operations, as they are self)J
72 175 :M
-.033(inverses.)A
72 191 :M
1.169 .117(Lambda-expressions in )J
f1_10 sf
.409(Y)A
f3_10 sf
.809 .081(-Lisp appear identical to those in traditional Lisp; they have a "lambda-list" of formal)J
72 202 :M
.608 .061(parameters, and a "body" consisting of a sequence of expressions.  There are differences, however.  The lambda-)J
72 213 :M
.41 .041(expression is considered to have a single "argument" which is a list "destructured" by the given lambda-list, in the)J
72 224 :M
.296 .03(manner of ML.  All of the variable names appearing in the lambda-list must be distinct, and any reference to a free)J
72 235 :M
(variable inside a )S
f1_10 sf
(Y)S
f3_10 sf
(-Lisp lambda-expression is the )S
f0_10 sf
(only)S
f3_10 sf
-.001( reference to the variable to avoid violations of linearity.)A
72 251 :M
.191 .019(The interpretation of a )J
f1_10 sf
.106(Y)A
f3_10 sf
.228 .023(-Lisp lambda-expression is that the "variables" occurring in its lambda-list are "new" local)J
72 262 :M
.418 .042(variables distinct from any other variables which are bound to the respective portions of the argument list, and the)J
72 273 :M
.425 .042(cons cells from the argument list itself are returned to the free list during destructuring.  The binding of these new)J
72 284 :M
.259 .026(variables is reversible, since each is a new variable which had no previous value, and the original argument list can)J
72 295 :M
.193 .019(be trivially recovered from the values of the distinct variables.  The body of the lambda-expression consists of a list)J
72 306 :M
-.026(of )A
f1_10 sf
-.057(Y)A
f3_10 sf
-.029(-Lisp expressions, each of which is individually reversible, and which can be reversed by reversing the execution)A
72 317 :M
.427 .043(of each of the computations in the reversed list.  Any changes to the values of the lambda-list variables during the)J
72 328 :M
-.032(execution of the body will be reversed during reversed execution, thus reconstituting their values.)A
72 344 :M
10 f6_1 :p
465.445 :m
.299 .03(It is an error if any lambda-list variable still has a value at the end of the execution of the lambda-expression body)J
(,)S
72 356 :M
.539 .054(because linearity promises that every variable will be accessed )J
f0_10 sf
.742 .074(exactly once)J
f3_10 sf
.466 .047( within the body, and any such access)J
72 367 :M
.629 .063(returns the variable to its unbound state.  In other words, )J
228.768 :m
.832 .083(the argument list to a lambda-expression is completely)J
72 379 :M
132 :m
1.126 .113(consumed during its evaluation)J
.744 .074(; the list itself is consumed during binding, and each of the bound values is then)J
72 391 :M
.329 .033(consumed during the execution of the body.  This property, along with the other properties of )J
f1_10 sf
.177(Y)A
f3_10 sf
.342 .034(-Lisp, allows us to)J
72 402 :M
.213 .021(conclude that )J
411.188 :m
.2 .02(all of the information necessary for the reverse execution of the lambda expression is encoded into its)J
72 414 :M
69.982 :m
.73 .073(returned value\(s\))J
.4 .04(.  Similarly, it is an error if any expression in the body\321except for the last\321returns a value; i.e.,)J
72 426 :M
.322 .032(these expressions must all be operations with only side-effects, but not values.  Of course, these side-effects are all)J
72 437 :M
.15 .015(completely local, since linearity forces each free variable to belong to only one closure; i.e., any "local" variables of)J
72 448 :M
-.011(an enclosing lambda which are referenced by a subsidiary lambda closure can no longer be accessed by the enclosing)A
72 459 :M
-.156(lambda.)A
72 475 :M
.211 .021(A )J
f8_10 sf
.156(let)A
f3_10 sf
.468 .047(-expression evaluates an expression and destructures it to bind several new distinct variables \(destructuring)J
72 486 :M
.825 .083(means never having to say )J
f8_10 sf
.346(CAR)A
f3_10 sf
.321 .032( or )J
f8_10 sf
.346(CDR)A
f3_10 sf
.573 .057( again\).  The body of a )J
f8_10 sf
.346(let)A
f3_10 sf
.885 .089( expression is a sequence of expressions, in)J
72 497 :M
.439 .044(which only the last can return a value.  Like a lambda-expression, it is an error for a )J
f8_10 sf
.209(let)A
f3_10 sf
.783 .078(-expression to terminate)J
72 508 :M
.09 .009(while its bound variables still have values.  These rules allow the reverse execution of a )J
f8_10 sf
.038(let)A
f3_10 sf
.115 .012(-expression in the same)J
72 519 :M
-.048(way they allow the reverse execution of a lambda-expression.)A
72 535 :M
.235 .024(Nested expressions have an interesting interpretation.  In general, a particular variable may "occur" only once.  The)J
72 546 :M
-.05(values of sub-expressions are conceptually bound to new intermediate variables, so we could have decomposed nested)A
72 557 :M
1.504 .15(expressions into an equivalent nest of )J
f8_10 sf
.585(let)A
f3_10 sf
1.511 .151(-expressions.  The values of all of the intermediate variables are)J
72 568 :M
.867 .087(immediately consumed by the expression in which they are nested, so that they satisfy the restrictions on )J
f8_10 sf
.341(let)A
f3_10 sf
(-)S
72 579 :M
.615 .062(expressions.  A nested expression is thus executed in a manner analogous to a dataflow architecture in which the)J
72 590 :M
-.018(values \("tokens"\) flow through the variables \("wires"\) and into the application nodes \("operators"\); a variable without)A
72 601 :M
.033 .003(a value is analogous to a wire without a token.  Multiple arguments may be evaluated in parallel [Baker92LL].)J
72 617 :M
1.627 .163(The most difficult and interesting case is that of the if-then-else expression.  This expression has 4\(!\) sub-)J
72 628 :M
.072 .007(expressions\321a Boolean test expression, a Boolean predicate, and two arms, a then-arm and an else-arm.  If we were)J
72 639 :M
.743 .074(to execute the test expression in the normal fashion, then any arguments passed to it would be consumed, and it)J
72 650 :M
-.008(would be difficult to remember the direction of the evaluation during execution reversal.  Therefore, we will evaluate)A
72 661 :M
1.05 .105(the test expression somewhat differently from the expressions of the arms.  We evaluate the test expression to)J
72 672 :M
.809 .081(determine the direction of the execution, and then )J
f0_10 sf
.704 .07(we undo the test expression to restore the values of any of its)J
72 683 :M
.082(variables)A
f3_10 sf
.315 .031( before executing the appropriate arm.  The variables referenced in the test expression must be referenced)J
72 694 :M
-.004(again in both arms, since otherwise they would not be consumed.  )A
202.213 :m
-.004(During reverse execution, the Boolean predicate is)A
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 709.24 -.24 .24 215.24 709 .24 72 709 @a
72 722 :M
f3_9 sf
(6)S
f3_10 sf
0 3 rm
-.026(Extra credit problem for the reader: why is it called )A
0 -3 rm
f1_10 sf
0 3 rm
-.054(Y)A
0 -3 rm
f3_10 sf
0 3 rm
-.035(-Lisp?)A
0 -3 rm
endp
%%Page: 8 8
%%BeginPageSetup
initializepage
(Henry Baker; page: 8 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.384 .038(Proc. Int'l. Workshop on Memory Mgmt.)J
f3_12 sf
.328 .033(, St Malo, France, Sept. 1992, Springer LNCS 637.)J
72 753 :M
-.053(Copyright \251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(8)S
72 74 :M
f3_10 sf
10 f6_1 :p
418.549 :m
-.02(applied to the value previously returned by the if-then-else expression to determine which arm to execute)A
-.019(.  In order to)A
72 86 :M
.503 .05(keep the programmer honest, this predicate is also applied to the value )J
f0_10 sf
.566 .057(to be returned)J
f3_10 sf
.427 .043(, to make sure that it returns)J
72 97 :M
.581 .058(true on the then arm, and false on the else arm.  To allow for more traditional programming styles, we allow this)J
72 108 :M
.604 .06(boolean predicate to push some state on a hidden conditional "history" stack during forwards execution, which is)J
72 119 :M
.323 .032(popped during reverse execution to remember the direction of the branch.  Since only a single bit of information is)J
72 130 :M
1.831 .183(being saved for a conditional expression, and only by )J
f0_10 sf
.627(some)A
f3_10 sf
1.899 .19( conditional expressions, this bit stack can be)J
72 141 :M
.148 .015(implemented very efficiently.  A clever optimizing compiler may be able to sometimes deduce the reverse predicate)J
72 152 :M
.48 .048(which doesn't use the bit stack; functions like these will operate with bounded history stacks and are analogous to)J
72 163 :M
(tail recursion.)S
72 179 :M
.207 .021(Here is a reversible version of the factorial function restricted to n>0 so as to be injective; the result is 1 if and only)J
72 190 :M
.004 0(if the "then" arm was taken, which forces n=1.)J
88 206 :M
f8_10 sf
.005 .001(\(defun fact \(n\) \(assert \(and \(integerp n\) \(> n 0\)\)\))J
88 217 :M
.004 0(  \(if \(onep n\) #'onep n \(* n \(fact \(1- n\)\)\)\)\))J
72 233 :M
f3_10 sf
.828 .083(Our interpretation so far is approximately consistent with an applicative/functional interpretation of the lambda-)J
72 244 :M
1.128 .113(expression.  We now give another, more operational, interpretation.  Parameters are not passed by copy or by)J
72 255 :M
.097 .01(reference, but by "swap-in, swap-out" [Harms91].  When a variable is referenced as an argument in an expression, it)J
72 266 :M
.23 .023(is swapped out of the variable and into the argument list structure, so that a side-effect of computing the expression)J
72 277 :M
.346 .035(is to make all of the referenced variables unbound!  This is why a variable should not appear more than once in an)J
72 288 :M
-.001(expression\321succeeding occurrence will be unbound.  Results are also returned by swapping, so that when a lambda-)A
72 299 :M
.032 .003(expression terminates, none of its local variables have any values.)J
72 315 :M
f1_10 sf
.286(Y)A
f3_10 sf
.53 .053(-Lisp )J
f8_10 sf
.215(EVAL)A
f3_10 sf
.279 .028( and )J
f8_10 sf
.215(APPLY)A
f3_10 sf
.599 .06( look similar to their traditional Lisp counterparts, and their familiar appearance masks)J
72 326 :M
.714 .071(their metacircular ability to run backwards.  There are some notable differences, however.  Since )J
f8_10 sf
.272(EVAL)A
f3_10 sf
.57 .057( must be)J
72 337 :M
1.393 .139(reversible given only its computed value\(s\), )J
f8_10 sf
.493(EVAL)A
f3_10 sf
1.288 .129( returns 3 values: the expression, the environment and the)J
72 348 :M
.212 .021(computed value.  )J
f8_10 sf
.084(APPLY)A
f3_10 sf
.212 .021( is more symmetrical\321it is given a function and an argument list, and returns the function)J
72 359 :M
1.209 .121(and its value\(s\).  Since many functions return multiple values, we make )J
f8_10 sf
.482(APPLY)A
f3_10 sf
2.043 .204( completely symmetrical\321it)J
72 370 :M
.645 .065(consumes an argument list and returns a value list, which must be destructured by its recipient.  We utilize these)J
72 381 :M
1.12 .112(additional returned values to eliminate the need for the interpreter itself to save state, although the interpreted)J
72 392 :M
.083 .008(program itself may do so.)J
72 408 :M
1.509 .151(The code for a recursive function is incrementally copied during a recursive evaluation in a Y-like manner.)J
72 419 :M
1.049 .105(Unfortunately, all of these copies become available at the end of the recursion and must be recycled.  A more)J
72 430 :M
.274 .027("efficient" scheme might keep multiple copies of the code on a separate "free list", so that they wouldn't have to be)J
72 441 :M
.916 .092(created during recursion.  Tail recursive functions can not only reuse their stack frame, but their code, as well!)J
72 452 :M
-.017(Linear Lisp [Baker92LL] utilizes a more efficient scheme \(similar to "copy on write"\) for managing copies.)A
72 471 :M
f4_12 sf
2.406 .241(Time and Space Complexity for a Reversible Garbage Collector)J
72 488 :M
f3_10 sf
.322 .032(If we make the reasonable assumption \(for a machine with a single level RAM memory\) that the inverse execution)J
72 499 :M
.562 .056(of each instruction takes exactly the same amount of time as its forward execution, then the total time required is)J
72 510 :M
-.023(exactly double that of the non-collected computation, plus whatever time is required to copy the answer.)A
72 526 :M
.568 .057(If the entire computation finishes before being reversed, then "garbage collection" has not helped at all.  One can)J
72 537 :M
.452 .045(reverse portions of the computation at finer scales, however, and achieve significant storage savings.  In this case,)J
72 548 :M
.476 .048(the "answer" which must be copied before the reversal is initiated is the summary of the computation "so far".  In)J
72 559 :M
.177 .018(other words, we must "save" this intermediate state for later mutation \(and reversal\) at a larger scale.  The saving of)J
72 570 :M
-.018(this intermediate state is equivalent to traditional marking!)A
72 586 :M
.412 .041(The value returned from a subprogram is a good example.  The "answer" can be copied, and a reversal initiated to)J
72 597 :M
-.007(collect any excess storage that the subprogram used, before the caller resumes "forward" motion again.  This reversal)A
72 608 :M
.39 .039(is equivalent to the popping of a classical stack frame.  In fact, our "collection is reverse mutation" hypothesis can)J
72 619 :M
-.013(simulate most standard garbage collection optimizations.)A
72 638 :M
f4_12 sf
3.42 .342(Reverse Execution Paging)J
72 655 :M
f3_10 sf
-.031(Researchers have found that garbage collection algorithms have much less reference locality than "normal" programs.)A
72 666 :M
-.062(Garbage collectors therefore page extensively, and many garbage collection improvements are aimed more at reducing)A
72 677 :M
-.014(the paging/caching costs than in reducing the number of instructions executed.)A
72 693 :M
1.098 .11(If we perform a "full" garbage collection, then every node and every link must be traced, requiring that every)J
72 704 :M
.162 .016(page/cache line be visited even if it has not otherwise been touched or modified since the last garbage collection.  If)J
72 715 :M
1.351 .135(we perform a "partial" garbage collection in a generational system, then optimizations exist to avoid visiting)J
endp
%%Page: 9 9
%%BeginPageSetup
initializepage
(Henry Baker; page: 9 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.384 .038(Proc. Int'l. Workshop on Memory Mgmt.)J
f3_12 sf
.328 .033(, St Malo, France, Sept. 1992, Springer LNCS 637.)J
72 753 :M
-.053(Copyright \251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(9)S
72 74 :M
f3_10 sf
.6 .06(otherwise untouched or unmodified pages.  On the other hand, even a generational garbage collector will have to)J
72 85 :M
-.046(spend some time tracing in the pages recently referenced or modified by the mutator.)A
72 101 :M
1.08 .108(If one believes the "garbage collection by reverse mutation" hypothesis, then the collector must visit the same)J
72 112 :M
.545 .055(pages/cache lines as the mutator, but does not bother with reversing a lot of extraneous computation not involved)J
72 123 :M
.849 .085(with pointers.  As a result, the collector will tend to page "more heavily" than the forward computation, simply)J
72 134 :M
.304 .03(because the reverse of the operations not causing page faults are irrelevant to the task of garbage collection!  Thus,)J
72 145 :M
.62 .062(although it may not visit any more pages than the forward computation, the collector appears to be less efficient,)J
72 156 :M
(because it has less to do on each page.)S
72 172 :M
.234 .023(If we know that collection is the reverse of mutation, we may be able to use this information to greatly improve the)J
72 183 :M
.736 .074(paging of the collector.  We first note that the last-in, first-out \(LIFO\) behavior of a stack works extremely well)J
72 194 :M
-.025(with the least-recently-used \(LRU\) page replacement algorithm; even very small stack caches have high hit rates with)A
72 205 :M
.458 .046(LRU.  It is also well known that the optimal paging algorithm \(OPT\) can be computed by submitting the reversed)J
72 216 :M
.332 .033(reference stream to an LRU algorithm.  But we have already submitted our mutator program to the LRU algorithm)J
72 227 :M
.065 .007(during forwards execution, so we can compute the information necessary to utilize the OPT paging algorithm during)J
72 238 :M
-.101(the reversed execution \(collection\) phase!)A
72 254 :M
.651 .065(Thus, while our garbage collection by reversed mutation would seem to exactly double the execution time of the)J
72 265 :M
.584 .058(mutator, we might reduce the collection time in the context of a paged implementation by utilizing the additional)J
72 276 :M
.332 .033(information generated during forward execution, and thereby achieve a running time only a fraction longer than an)J
72 288 :M
-.023(uncollected computation.)A
f3_9 sf
0 -3 rm
(7)S
0 3 rm
72 307 :M
f4_12 sf
2.495 .25(Implications for Real Hardware)J
72 324 :M
f3_10 sf
.221 .022(The biggest problem with an exchange-oriented architecture is the fact that it goes squarely against the grain of one)J
72 335 :M
1.351 .135(of the most universally-held assumptions about computation\321that copying by reference is free.  Conversely,)J
72 346 :M
.104 .01(exchanges are cheaper than copies, even though "everyone knows" that exchanges take 3 copies, and that exchanges)J
72 357 :M
-.003(on a bus require atomic \(i.e., slow\) back-to-back bus cycles.)A
72 373 :M
.885 .089(That exchanges are expensive seems to be an artifact of traditional Boolean\321i.e., irreversible\321logic.  One can)J
72 384 :M
1.189 .119(conceive of other types of logic in which the same connection could be used for signalling in both directions)J
72 395 :M
.696 .07(simultaneously\321e.g., optical fiber.  In fact, since all suitably small physical systems are reversible, it is actually)J
72 406 :M
2.946 .295(more difficult to build irreversible/non-exchange architectures out of small components than to build)J
72 417 :M
-.122(reversible/exchange architectures.)A
72 433 :M
.333 .033(Interestingly enough, one can find a precedent for exchange architecture in current )J
f0_10 sf
.543 .054(cache consistency)J
f3_10 sf
.333 .033( protocols for)J
72 444 :M
.223 .022(MIMD multiprocessors.  In order to cut down on the bus/network traffic in the case that multiple writers are active,)J
72 455 :M
.116 .012(some cache line may be )J
f0_10 sf
.045(owned)A
f3_10 sf
.118 .012( by a particular processor.  If another processor attempts to write to this line, then the)J
72 466 :M
.277 .028(ownership of the line may be transferred to the other processor, in which case the first processor no longer owns it.)J
72 477 :M
.517 .052(While the information going in the direction opposite to that of moving cache line is essentially a "hole", it is not)J
72 488 :M
.293 .029(difficult to conceive of a more productive exchange protocol which would allow them to immediately synchronize,)J
72 499 :M
-.048(for example.)A
72 515 :M
.469 .047(The restricted fan-in/fan-out of exchange architectures provides relief to the designer of a PRAM implementation,)J
72 526 :M
-.015(because the unlimited fan-in/fan-out of a CRCW PRAM architecture [Corman90] is very expensive to achieve.)A
72 545 :M
f4_12 sf
1.992 .199(What Makes the Free-List Free?)J
72 562 :M
f3_10 sf
.351 .035(Joseph Halpern, )J
f0_10 sf
.22 .022(et al)J
f3_10 sf
.29 .029(. [Halpern84], asked the question "what makes the free-list free?"  We believe that their paper)J
72 573 :M
.898 .09(could not properly answer the question, because it is a )J
f0_10 sf
.306(thermodynamic)A
f3_10 sf
.714 .071( question, not a )J
f0_10 sf
.284(semantic)A
f3_10 sf
.864 .086( question.  Our)J
72 584 :M
.447 .045(answer is that the free-list is free because it is storage that is in the highest state of availability; in thermodynamic)J
72 595 :M
.213 .021(terms, it is )J
f0_10 sf
.103(work)A
f3_10 sf
.293 .029(.  What is work?  Carnot's theorem tells us that work \(available energy\) can be produced from heat)J
72 606 :M
-.021(\(energy+randomness\), by removing the randomness into a cooler reservoir.  The free-list always has exactly the same)A
72 617 :M
.335 .034(configuration\321a semi-infinite sequence of cells \(list of nil's\)\321i.e., the structure of the free-list is isomorphic to )J
f1_10 sf
.142(w)A
f3_10 sf
(,)S
72 628 :M
.415 .041(the first infinite ordinal.  Since 1+)J
f1_10 sf
.203(w)A
f3_10 sf
.167(=)A
f1_10 sf
.203(w)A
f3_10 sf
.405 .04(, allocating a cell from the free-list does not change its structure.  Since the)J
72 639 :M
.224 .022(structure of the free-list is always the same, it has )J
f0_10 sf
.074(zero)A
f3_10 sf
.277 .028( entropy/information.  No other simple structure for the free-)J
72 650 :M
.18 .018(list would have as little entropy/information.)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 698.24 -.24 .24 215.24 698 .24 72 698 @a
72 711 :M
f3_9 sf
.062(7)A
f3_10 sf
0 3 rm
.231 .023(For example, the TI Explorer GC "learns" locality by letting the running program copy incrementally; this scheme)J
0 -3 rm
72 725 :M
-.017(seems to provide locality superior to that from any uniform \(depth-first or breadth-first\) copying strategy.)A
endp
%%Page: 10 10
%%BeginPageSetup
initializepage
(Henry Baker; page: 10 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.384 .038(Proc. Int'l. Workshop on Memory Mgmt.)J
f3_12 sf
.328 .033(, St Malo, France, Sept. 1992, Springer LNCS 637.)J
72 753 :M
-.053(Copyright \251 1991, 1992 by Nimble Computer Corporation)A
492 753 :M
(10)S
72 82 :M
f4_12 sf
3.104 .31(Conclusions and Previous Work)J
72 99 :M
f3_10 sf
.163 .016(We have advocated the use of reversible models of computation, and we have shown how a particular model can be)J
72 110 :M
.751 .075(programmed to perform interesting computations.  The property of reversibility is very strong, and should allow)J
72 121 :M
-.019(static analysis of programs to produce deeper information than is typically feasible with non-reversible models.)A
72 137 :M
.292 .029(Hoare's, Dijkstra's and Pratt's logics all consider the operation of a program in reverse, although to our amazement,)J
72 149 :M
.273 .027(no one seems to have taken up the retrospectively obvious line of attack we here propose.)J
f3_9 sf
0 -3 rm
.082(8)A
0 3 rm
f3_10 sf
.041 .004(  )J
f0_10 sf
.524 .052(Abstract interpretation)J
72 160 :M
f3_10 sf
(and )S
f0_10 sf
(type inference)S
f3_10 sf
.006 .001( often consider the retrograde execution of a program.  Computer architects find that the reverse of)J
72 171 :M
.557 .056(reference strings are an important concept in the study of memory hierarchies; e.g., the optimal page replacement)J
72 182 :M
-.043(algorithm is the least-recently-used algorithm running on the reversed reference string.)A
72 198 :M
.046 .005(Our )J
f1_10 sf
(Y)S
f3_10 sf
.066 .007(-Lisp bears much resemblance to dataflow architectures.  Its argument-consuming property neatly finesses the)J
72 209 :M
-.123(storage recovery problems addressed by [Inoue88].)A
72 225 :M
.443 .044(The Deutsch-Schorre-Waite "pointer-reversing" list tracing algorithm [Knuth73] is a paradigm of reference-count-)J
72 236 :M
.993 .099(conserving programming.  Binding tree "re-rooting" [Baker78b] is an even more sophisticated reference-count-)J
72 247 :M
1.852 .185(conserving algorithm.  Suzuki [Suzuki82] gives the fundamental properties of pointer exchange and rotate)J
72 258 :M
.183 .018(instructions; Common Lisp's )J
f8_10 sf
.054(rotatef)A
f3_10 sf
.15 .015( operation comes directly from this paper.)J
72 274 :M
.221 .022(The )J
f8_10 sf
.103(unwind-protect)A
f3_10 sf
.133 .013( and )J
f8_10 sf
.103(wind-unwind)A
f3_10 sf
.285 .028( operations of Common Lisp and Scheme, respectively, offer a form)J
72 285 :M
.658 .066(of "undoing" computation.  In fact, some implementations of )J
f8_10 sf
.241(wind-unwind)A
f3_10 sf
.643 .064( utilize the reversible "state space")J
72 296 :M
-.119(tree re-rooting [Baker78SB].)A
72 312 :M
.167 .017(The reverse execution abilities of )J
f0_10 sf
.048(Prolog)A
f3_10 sf
.171 .017( were initially touted, but never developed, and modern Prologs cannot run)J
72 323 :M
-.025(predicates backwards \(this is not the same as backtracking!\).  Subjunctive computing has been proposed as a valuable)A
72 334 :M
.604 .06(programming style [Zelkowitz73] [Nylin76] [Lafora84] [Heering85] [Leeman85] [Leeman86] [Strothotte87].  An)J
72 345 :M
1.974 .197(enormous literature has developed around reversibility for debugging [Balzer69] [Grishman70] [Archer84])J
72 356 :M
-.085([LeBlanc87] [Feldman88] [Pan88] [Wilson89] [Tolmach90] [Agrawal91].)A
72 372 :M
.565 .057(Hofstadter devotes a portion of his Pulitzer prize-winning book [Hafstadter79] to palindromes and "crab canons",)J
72 383 :M
.686 .069(which are musical pieces that simultaneously have same theme going in both the forward and reverse directions.)J
72 394 :M
-.019(One can conceive of the mutator process as playing a theme, while the collector process plays the retrograde theme.)A
72 410 :M
.816 .082(Bill Gosper was an early investigator [Beeler72] into the power of the Digital Equipment Corporation's PDP-10)J
72 421 :M
f8_10 sf
.083(EXCH)A
f3_10 sf
.212 .021( instruction, which we have appropriated for our reversible computer.  Swapping has been given new life as a)J
72 432 :M
.202 .02(fundamental synchronization primitive in shared-memory multiprocessor architectures in the form of the "compare-)J
72 443 :M
-.039(and-swap" operation, which Herlihy has proven to be powerful and universal [Herlihy91].)A
72 462 :M
f4_12 sf
.647(Acknowledgements)A
72 479 :M
f3_10 sf
.247 .025(We appreciate the discussions with Peter Deutsch, Richard Fateman, Richard Fujimoto, Bill Gosper, Robert Keller,)J
72 490 :M
.027 .003(Nori Suzuki, Tommaso Toffoli, and David Wise about these concepts.)J
72 509 :M
f4_12 sf
.672(References)A
72 526 :M
f3_10 sf
1.519 .152(Abadi, M. & Plotkin, G.D.  "A Logical View of Composition and Refinement".  )J
f0_10 sf
1.849 .185(Proc. ACM POPL 18)J
f3_10 sf
1.466 .147( \(Jan.)J
89 537 :M
.026(1991\),323-332.)A
72 548 :M
.094 .009(Agrawal, H. )J
f0_10 sf
.068 .007(et al)J
f3_10 sf
.101 .01(.  "An Execution-Backtracking Approach to Debugging".  )J
f0_10 sf
.112 .011(IEEE Software 8)J
f3_10 sf
.172 .017(,3 \(May\3121991\),21-26.)J
72 559 :M
2.31 .231(Appel, A.W.  "Simple Generational Garbage Collection and Fast Allocation".  )J
f0_10 sf
2.034 .203(Soft. Prac. & Exper. 19)J
f3_10 sf
1.021(,2)A
89 570 :M
1.173 .117(\(Feb.\3121989\), 171-183.)J
72 581 :M
.564 .056(Appel, A.W.  "A Runtime System".  )J
f0_10 sf
.676 .068(Lisp & Symbolic Comput. 3)J
f3_10 sf
.918 .092(,4 \(Nov. 1990\),343-380.)J
72 592 :M
.323 .032(Archer, J.E., )J
f0_10 sf
.243 .024(et al)J
f3_10 sf
.292 .029(.  "User recovery and reversal in interactive systems".  )J
f0_10 sf
.434 .043(ACM TOPLAS 6)J
f3_10 sf
.563 .056(,1 \(Jan.\3121984\),1-19.)J
72 603 :M
1.18 .118(Bacon, David F., )J
f0_10 sf
.917 .092(et al)J
f3_10 sf
1.405 .141(.  "Optimistic Parallelization of Communicating Sequential Processes".  )J
f0_10 sf
1.522 .152(Proc. 3rd ACM)J
89 614 :M
.534 .053(Sigplan PPOPP)J
f3_10 sf
.406 .041(, Williamsburg, VA, April, 1991,155-166.)J
72 625 :M
.449 .045(Baker, H.G.  "Shallow Binding in Lisp 1.5".  )J
f0_10 sf
.789 .079(CACM 21)J
f3_10 sf
.98 .098(,7 \(July\3121978\),565-569.)J
72 636 :M
.792 .079(Baker, H.G.  "Unify and Conquer \(Garbage, Updating, Aliasing, ...\) in Functional Languages".  )J
f0_10 sf
.994 .099(Proc. 1990 ACM)J
89 647 :M
.292 .029(Conf. on Lisp and Functional Progr.)J
f3_10 sf
.49 .049(, June\3121990,218-226.)J
72 658 :M
.149 .015(Baker, H.G.  "The Nimble Type Inferencer for Common Lisp-84".  Tech. Report, Nimble Computer, 1990.)J
72 669 :M
.957 .096(Baker, H.G.  "CONS Should not CONS its Arguments, or, A Lazy Alloc is a Smart Alloc".  )J
f0_10 sf
1.453 .145(ACM Sigplan Not.)J
89 680 :M
(27)S
f3_10 sf
.093 .009(,3 \(March 1992\),24-34.)J
72 691 :M
.288 .029(Baker, H.G.  "Equal Rights for Functional Objects".  ACM )J
f0_10 sf
.415 .041(OOPS Messenger 4)J
f3_10 sf
.388 .039(,4 \(Oct.\3121993\), 2-27.)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 709.24 -.24 .24 215.24 709 .24 72 709 @a
72 722 :M
f3_9 sf
(8)S
f3_10 sf
0 3 rm
.127 .013(Linearity, even without reversibility, elegantly eliminates the )J
0 -3 rm
f0_10 sf
0 3 rm
.028(aliasing)A
0 -3 rm
f3_10 sf
0 3 rm
.109 .011( problem which gives these logics fits!)J
0 -3 rm
endp
%%Page: 11 11
%%BeginPageSetup
initializepage
(Henry Baker; page: 11 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.384 .038(Proc. Int'l. Workshop on Memory Mgmt.)J
f3_12 sf
.328 .033(, St Malo, France, Sept. 1992, Springer LNCS 637.)J
72 753 :M
-.053(Copyright \251 1991, 1992 by Nimble Computer Corporation)A
492 753 :M
(11)S
72 74 :M
f3_10 sf
.373 .037(Baker, H.G.  "Cache-Conscious Copying Collectors".  )J
f0_10 sf
.55 .055(OOPSLA'91 GC Workshop)J
f3_10 sf
.314 .031(, Oct. 1991.)J
72 85 :M
.337 .034(Baker, H.G.  "Lively Linear Lisp \321 'Look Ma, No Garbage!'".  ACM )J
f0_10 sf
.417 .042(Sigplan Not. 27)J
f3_10 sf
.511 .051(,8 \(Aug.\3121992\), 89-98.)J
72 96 :M
.879 .088(Balzer, R.M.  "EXDAMS: Extendable Debugging and Monitoring System".  )J
f0_10 sf
.837 .084(Proc. AFIPS 1969 SJCC 34)J
f3_10 sf
.969 .097(, AFIPS)J
89 107 :M
.455 .045(Press, Montvale, NJ,567-580.)J
72 118 :M
.618 .062(Barghouti, N.S. & Kaiser, G.E.  "Concurrency Control in Advanced Database Applications".  )J
f0_10 sf
.814 .081(ACM Comput. Surv.)J
89 129 :M
.197(23)A
f3_10 sf
1.166 .117(,3 \(Sept.\3121991\),269-317.)J
72 140 :M
.322 .032(Barth, J.  "Shifting garbage collection overhead to compile time".  )J
f0_10 sf
.508 .051(CACM 20)J
f3_10 sf
.631 .063(,7 \(July\3121977\),513-518.)J
72 151 :M
.152 .015(Barth, Paul S., )J
f0_10 sf
.145 .014(et al.)J
f3_10 sf
.191 .019(  "M-Structures: Extending a Parallel, Non-strict, Functional Language with State".  )J
f0_10 sf
.277 .028(Proc. Funct.)J
89 162 :M
.248 .025(Progr. Langs. & Computer Arch.)J
f3_10 sf
.277 .028(, LNCS 523, Springer-Verlag, Aug. 1991,538-568.)J
72 173 :M
.229 .023(Barton, Ed.  Conservative Logic.  6.895 Term Paper, MIT, May, 1978.)J
72 184 :M
.38 .038(Bawden, Alan.  "Connection Graphs".  )J
f0_10 sf
.382 .038(Proc. ACM Conf. Lisp & Funct. Progr.)J
f3_10 sf
.385 .038(, Camb., MA, Aug. 1986.)J
72 195 :M
.727 .073(Beeler, M., Gosper, R.W, and Schroeppel, R.  "HAKMEM".  AI Memo 239, MIT AI Lab., Feb. 1972.  Important)J
89 206 :M
.685 .068(items: 102, 103, 104, 149, 150, 161, 166, 172.)J
72 217 :M
.814 .081(Benioff, Paul.  "Quantum Mechanical Hamiltonian Models of Discrete Processes that Erase Their Own Histories:)J
89 228 :M
.309 .031(Application to Turing Machines".  )J
f0_10 sf
.267 .027(Int'l. J. Theor. Phys. 21)J
f3_10 sf
.5 .05( \(1982\),177-201.)J
72 239 :M
.343 .034(Bennett, Charles.  "Logical Reversibility of Computation".  )J
f0_10 sf
.299 .03(IBM J. Res. Develop. 6)J
f3_10 sf
.541 .054( \(1973\),525-532.)J
72 250 :M
.256 .026(Bennett, Charles.  "Thermodynamics of Computation".  )J
f0_10 sf
.202 .02(Int'l. J. Theor. Phys. 21)J
f3_10 sf
.377 .038( \(1982\),905-940.)J
72 261 :M
.315 .031(Bennett, Charles.  "Notes on the History of Reversible Computation".  )J
f0_10 sf
.309 .031(IBM J. Res. Develop. 32)J
f3_10 sf
.52 .052(,1 \(1988\),16-23.)J
72 272 :M
.35 .035(Bennett, Charles.  "Time/Space Trade-offs for Reversible Computation".  )J
f0_10 sf
.35 .035(SIAM J. Computing 18)J
f3_10 sf
.489 .049(,4 \(Aug.\3121989\).)J
72 283 :M
.247 .025(Berry, G., and Boudol, G.  "The Chemical Abstract Machine".  )J
f0_10 sf
.328 .033(ACM POPL 17)J
f3_10 sf
.262 .026(, San Francisco, CA, Jan. 1990.)J
72 294 :M
.313 .031(Chase, David.  "Garbage Collection and Other Optimizations".  PhD Thesis, Rice U., Nov.\3121987.)J
72 305 :M
.212 .021(Chen, W., and Udding, J.T.  "Program Inversion: More than Fun!".  )J
f0_10 sf
.238 .024(Sci. of Computer Progr. 15)J
f3_10 sf
.344 .034( \(1990\),1-13.)J
72 316 :M
.43 .043(Chen, W.  "A formal approach to program inversion".  )J
f0_10 sf
.503 .05(Proc. ACM 18th Comp. Sci. Conf.)J
f3_10 sf
.641 .064(, Feb., 1990,398-403.)J
72 327 :M
.495 .049(Cheney, C.J.  "A Nonrecursive List Compacting Algorithm".  )J
f0_10 sf
.701 .07(CACM 13)J
f3_10 sf
.917 .092(,11 \(Nov.\3121970\),677-678.)J
72 338 :M
.404 .04(Clarke, E.M.  "Synthesis of resource invariants for concurrent programs".  )J
f0_10 sf
.52 .052(ACM TOPLAS 2)J
f3_10 sf
.607 .061(,3 \(July\3121980\).)J
72 349 :M
.331 .033(Cohen, Jacques.  "Non-Deterministic Algorithms".  )J
f0_10 sf
.369 .037(Comput. Surveys 11)J
f3_10 sf
.375 .038(,2 \(June 1979\),79-94.)J
72 360 :M
.407 .041(Corman, T.H., )J
f0_10 sf
.267 .027(et al)J
f3_10 sf
.075 .007(.  )J
f0_10 sf
.533 .053(Introduction to Algorithms)J
f3_10 sf
.363 .036(.  MIT Press, Cambridge, MA, 1990.)J
72 371 :M
1.346 .135(Cousot, P., and Cousot, R.  "Abstract interpretation: a unified lattice model for static analysis of programs by)J
89 382 :M
.283 .028(construction or approximation of fixpoints".  )J
f0_10 sf
.289 .029(Proc. ACM POPL 4)J
f3_10 sf
.446 .045( \(1977\),238-252.)J
72 393 :M
.372 .037(Coveney, P.V. & Marcer, P.J.  "Irreversibility and computation".  )J
f0_10 sf
.311 .031(Specs. in Sci. & Tech. 14)J
f3_10 sf
.624 .062(,1 \(1991?\),51-55.)J
72 404 :M
.12 .012(DeWitt, B. & Graham, N., )J
f0_10 sf
.037(eds)A
f3_10 sf
.027 .003(.  )J
f0_10 sf
.186 .019(The Many-Worlds Interpretation of Quantum Mechanics)J
f3_10 sf
.117 .012(.  Princeton U. Press, 1973.)J
72 415 :M
.834 .083(Deutsch, D.  "Quantum Theory, the Church-Turing Hypothesis, and Universal Quantum Computers".  )J
f0_10 sf
1.021 .102(Proc. Roy.)J
89 426 :M
.123(Soc.)A
f3_10 sf
.539 .054( \(1985\).)J
72 437 :M
.242 .024(Dijkstra, E.W.  )J
f0_10 sf
.37 .037(A Discipline of Programming)J
f3_10 sf
.308 .031(.  Prentice-Hall, Englewood Cliffs, NJ, 1976.)J
72 448 :M
.355 .035(Dobkin, D.P., and Munro, J.I.  "Efficient Uses of the Past".  )J
f0_10 sf
.487 .049(Proc. ACM FOCS 21)J
f3_10 sf
.722 .072( \(1980\),200-206.)J
72 459 :M
.312 .031(Drescher, G.L.  "Demystifying Quantum Mechanics: A Simple Universe with Quantum Uncertainty".  )J
f0_10 sf
.437 .044(Complex Sys.)J
89 470 :M
(5)S
f3_10 sf
.193 .019( \(1991\),207-237.)J
72 481 :M
1.871 .187(Feldman, S., and Brown, C.  "IGOR: A System for Program Debugging via Reversible Execution".  )J
f0_10 sf
.648(Proc.)A
89 492 :M
.432 .043(Sigplan/Sigops WS on Parl & Distr. Debugging)J
f3_10 sf
.52 .052(, May 1988,112-123.)J
72 503 :M
.261 .026(Feynman, Richard P., )J
f0_10 sf
.174 .017(et al)J
f3_10 sf
.049 .005(.  )J
f0_10 sf
.248 .025(The Feynman Lectures on Physics, Vol. I.)J
f3_10 sf
.279 .028(  Addison-Wesley, Reading, MA, 1963.)J
72 514 :M
.216 .022(Feynman, Richard P.  "Quantum Mechanical Computers".  )J
f0_10 sf
.211 .021(Founds. of Physics 16)J
f3_10 sf
.338 .034(,6 \(1986\),507-531.)J
72 525 :M
2.202 .22(Fisher, J.  "Trace scheduling: A technique for global microcode compaction".  )J
f0_10 sf
2.548 .255(IEEE Tr.. Comps. C-30)J
f3_10 sf
1.038(,7)A
89 536 :M
.15(\(July\3121981\),478-490.)A
72 547 :M
.547 .055(Floyd, R.W.  "Nondeterministic Algorithms".  )J
f0_10 sf
.455 .045(J. ACM 14)J
f3_10 sf
.904 .09(,4 \(Oct.\3121967\),636-644.)J
72 558 :M
.26 .026(Fredkin, E., and Toffoli, T.  "Conservative Logic".  )J
f0_10 sf
.273 .027(Int'l. J. Theor. Physics 21)J
f3_10 sf
.51 .051(,3/4 \(1982\),219-253.)J
72 569 :M
.094 .009(Girard, J.-Y.  "Linear Logic".  )J
f0_10 sf
.143 .014(Theoretical Computer Sci. 50)J
f3_10 sf
.176 .018( \(1987\),1-102.)J
72 580 :M
.413 .041(Grishman, R.  "The debugging system AIDS".  )J
f0_10 sf
.487 .049(AFIPS 1970 SJCC 41)J
f3_10 sf
.506 .051(, AFIPS Press, Montvale, NJ 1193-1202.)J
72 591 :M
1.45 .145(Halpern, J.Y., )J
f0_10 sf
1.015 .102(et al)J
f3_10 sf
1.212 .121(.  "The Semantics of Local Storage, or What Makes the Free-List Free?".  )J
f0_10 sf
1.715 .172(ACM POPL 11)J
f3_10 sf
(,)S
89 602 :M
.056(1984,245-257.)A
72 613 :M
(Harel, David.  )S
f0_10 sf
(First Order Dynamic Logic)S
f3_10 sf
(.  Springer-Verlag LNCS 68, 1979.)S
72 624 :M
2.162 .216(Harms, D.E., and Weide, B.W.  "Copying and Swapping: Influences on the Design of Reusable Software)J
89 635 :M
.462 .046(Components".  )J
f0_10 sf
.428 .043(IEEE Trans. SW Engrg. 17)J
f3_10 sf
.782 .078(,5 \(May\3121991\),424-435.)J
72 646 :M
.772 .077(Harrison, P.G.  "Function Inversion".  In Jones, N., )J
f0_10 sf
.622 .062(et al)J
f3_10 sf
.222 .022(, )J
f0_10 sf
.237(eds)A
f3_10 sf
.174 .017(.  )J
f0_10 sf
1.014 .101(Proc. Workshop on Partial Evaluation and Mixed)J
89 657 :M
.032(Computation)A
f3_10 sf
.136 .014(, Gammel Avernaes, Denmark, Oct. 1987, North-Holland, 1988.)J
72 668 :M
.462 .046(Hederman, Lucy.  "Compile Time Garbage Collection".  MS Thesis, Rice U. Comp. Sci. Dept., Sept.\3121988.)J
72 679 :M
3.396 .34(Heering, J., and Klint, P.  "Towards monolingual programming environments".  )J
f0_10 sf
4.112 .411(ACM TOPLAS 7)J
f3_10 sf
1.481(,2)A
89 690 :M
.121(\(April\3121985\),183-213.)A
72 701 :M
.476 .048(Herlihy, Maurice.  "Wait-Free Synchronization".  )J
f0_10 sf
.562 .056(ACM TOPLAS 11)J
f3_10 sf
.754 .075(,1 \(Jan.\3121991\),124-149.)J
72 712 :M
-.036(Hofstadter, Douglas R.  )A
f0_10 sf
-.038(G\232del, Escher, Bach: an Eternal Golden Braid)A
f3_10 sf
-.039(.  Vintage Bks., Random House, NY, 1979.)A
endp
%%Page: 12 12
%%BeginPageSetup
initializepage
(Henry Baker; page: 12 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.384 .038(Proc. Int'l. Workshop on Memory Mgmt.)J
f3_12 sf
.328 .033(, St Malo, France, Sept. 1992, Springer LNCS 637.)J
72 753 :M
-.053(Copyright \251 1991, 1992 by Nimble Computer Corporation)A
492 753 :M
(12)S
72 74 :M
f3_10 sf
1.763 .176(Inoue, K., )J
f0_10 sf
1.501 .15(et al)J
f3_10 sf
1.882 .188(.  "Analysis of functional programs to detect run-time garbage cells".  )J
f0_10 sf
2.794 .279(ACM TOPLAS 10)J
f3_10 sf
.965(,4)A
89 85 :M
.136(\(Oct.\3121988\),555-578.)A
72 96 :M
.135 .014(Johnsson, T.  "Lambda lifting: transforming programs to recursive equations".  )J
f0_10 sf
.198 .02(Proc. FPCA)J
f3_10 sf
.153 .015(, Nancy, France, Springer)J
89 107 :M
.623 .062(LNCS 201, 1985,190-203.)J
72 118 :M
.382 .038(Kay, A.C.  "Microelectronics and the Personal Computer".  )J
f0_10 sf
.408 .041(Sci. Amer. 237)J
f3_10 sf
.698 .07(,3 \(Sept.\3121977\),230-244.)J
72 129 :M
.621 .062(Keller, Robert M., )J
f0_10 sf
.467 .047(et al)J
f3_10 sf
.703 .07(.  "An Architecture for a Loosely-Coupled Parallel Processor".  Tech. Rep. UUCS-78-105,)J
89 140 :M
.68 .068(Oct. 1978,50p.)J
72 151 :M
.58 .058(Kieburtz, Richard B.  "Programming without pointer variables".  )J
f0_10 sf
.629 .063(Proc. Conf. on Data: Abstraction, Definition and)J
89 162 :M
.259 .026(Structure, Sigplan Not. 11)J
f3_10 sf
.275 .027( \(special issue 1976\),95-107.)J
72 173 :M
.044 .004(Kieburtz, R. B.  "The G-machine: a fast, graph-reduction evaluator".  )J
f0_10 sf
.057 .006(Proc. IFIP FPCA)J
f3_10 sf
.051 .005(, Nancy, France, 1985.)J
72 184 :M
1.008 .101(Kieburtz, Richard B.  "A RISC Architecture for Symbolic Computation".  )J
f0_10 sf
1.015 .102(Proc. ASPLOS II, Sigplan Not. 22)J
f3_10 sf
.382(,10)A
89 195 :M
.2 .02(\(Oct. 1987\),146-155.)J
72 206 :M
.83 .083(Korth, H.F., )J
f0_10 sf
.625 .063(et al)J
f3_10 sf
.849 .085(.  "Formal approach to recovery by compensating transactions".  )J
f0_10 sf
.814 .081(Proc. 16th Int'l. Conf. on Very)J
89 217 :M
-.148(Large Databases)A
f3_10 sf
-.148(, 1990.)A
72 228 :M
.454 .045(Kung, H.T. & Robinson, J.T.  "On optimistic methods for concurrency control".  )J
f0_10 sf
.414 .041(ACM Trans. on DB Sys. 6)J
f3_10 sf
.543 .054(,2 \(June)J
89 239 :M
.034(1981\).)A
72 250 :M
.486 .049(Jefferson, David R.  "Virtual Time".  )J
f0_10 sf
.727 .073(ACM TOPLAS 7)J
f3_10 sf
1.027 .103(,3 \(July\3121985\),404-425.)J
72 261 :M
.151 .015(Lafont, Yves.  "The Linear Abstract Machine".  )J
f0_10 sf
.185 .018(Theor. Computer Sci. 59)J
f3_10 sf
.268 .027( \(1988\),157-180.)J
72 272 :M
.368 .037(Lafont, Yves.  "Interaction Nets".  )J
f0_10 sf
.499 .05(ACM POPL 17)J
f3_10 sf
.449 .045(, San Franciso, CA, Jan. 1990,95-108.)J
72 283 :M
.222 .022(Lafont, Yves.  "The Paradigm of Interaction \(Short Version\)".  Unpubl. manuscript, July 12, 1991, 18p.)J
72 294 :M
1.303 .13(Lafora, F, & Soffa, M.L.  "Reverse Execution in a Generalized Control Regime".  )J
f0_10 sf
1.566 .157(Comp. Lang. 9)J
f3_10 sf
1.943 .194(,3/4 \(1984\),)J
89 305 :M
.025(183-192.)A
72 316 :M
3.378 .338(Landauer, R.  "Dissipation and Noise Immunity in Computation and Communication".  )J
f0_10 sf
4.623 .462(Nature 335)J
89 327 :M
f3_10 sf
.136(\(Oct.\3121988\),779-784.)A
72 338 :M
.816 .082(LeBlanc, T.J., and Mellor-Crummey, J.M.  "Debugging parallel programs with Instant Replay".  )J
f0_10 sf
.924 .092(IEEE Tr. Comp.)J
89 349 :M
.065(36)A
f3_10 sf
.298 .03(,4 \(April 1987\),471-482.)J
72 360 :M
.307 .031(Leeman, G.B.  "Building undo/redo operations into the C language".  )J
f0_10 sf
.318 .032(Proc. IEEE 15th Annual Int'l. Symp. on Fault-)J
89 371 :M
.459 .046(Tolerant Computing)J
f3_10 sf
.416 .042(, 1985,410-415.)J
72 382 :M
.972 .097(Leeman, G.B.  "A Formal Approach to Undo Operations in Programming Languages".  )J
f0_10 sf
1.207 .121(ACM TOPLAS 8)J
f3_10 sf
.994 .099(,1 \(Jan.)J
89 393 :M
.031(1986\),50-87.)A
72 404 :M
.301 .03(Levy, E., )J
f0_10 sf
.288 .029(et al.)J
f3_10 sf
.393 .039(  "An Optimistic Commit Protocol for Distributed Transaction Management".  )J
f0_10 sf
.554 .055(Proc. ACM SIGMOD)J
f3_10 sf
(,)S
89 415 :M
.274 .027(Denver, CO, May 1991,88-97.)J
72 426 :M
2.773 .277(Lewis, H.R., & Papadimitriou, C.H.  "Symmetric Space-bounded Computation".  )J
f0_10 sf
2.584 .258(Theor. Comp. Sci. 19)J
89 437 :M
f3_10 sf
(\(1982\),161-187.)S
72 448 :M
.699 .07(Lieberman, H., & Hewitt, C.  "A Real-Time Garbage Collector Based on the Lifetimes of Objects".  )J
f0_10 sf
1.098 .11(CACM 26)J
f3_10 sf
.386 .039(, 6)J
89 459 :M
.115(\(June\3121983\),419-429.)A
72 470 :M
1.513 .151(Lindstrom, Gary.  "Efficiency in Nondeterministic Control through Non-Forgetful Backtracking".  Tech. Rep.)J
89 481 :M
.487 .049(UUCS-77-114, Oct. 1977,18p.)J
72 492 :M
.24 .024(MacLennan, B.J.  "Values and Objects in Programming Languages".  )J
f0_10 sf
.252 .025(Sigplan Not. 17)J
f3_10 sf
.415 .041(,12 \(Dec.\3121982\),70-79.)J
72 503 :M
2.687 .269(Manthey, M.J., & Moret, B.M.E.  "The Computational Metaphor and Quantum Physics".  )J
f0_10 sf
3.752 .375(CACM 26)J
f3_10 sf
1.188(,2)A
89 514 :M
.159(\(Feb.\3121983\),137-145.)A
72 525 :M
.105 .011(Margolus, Norman.  "Physics-Like Models of Computation".  Elsevier North-Holland, )J
f0_10 sf
.135 .013(Physica 10D)J
f3_10 sf
.138 .014( \(1984\),81-95.)J
72 536 :M
.302 .03(Margolus, Norman H.  )J
f0_10 sf
.471 .047(Physics and Computation)J
f3_10 sf
.394 .039(.  Ph.D. Thesis, MIT/LCS/TR-415, March 1988,188p.)J
72 547 :M
.298 .03(Mattson, R.L., )J
f0_10 sf
.201 .02(et al)J
f3_10 sf
.273 .027(.  "Evaluation Techniques for Storage Hierarchies".  )J
f0_10 sf
.212 .021(IBM Sys. J. 9)J
f3_10 sf
.464 .046(,2 \(1970\),78-117.)J
72 558 :M
.602 .06(McCarthy, John.  "The Inversion of Functions defined by Turing Machines".  In Shannon, C.E., and McCarthy, J.,)J
89 569 :M
f0_10 sf
.073(eds)A
f3_10 sf
.054 .005(.  )J
f0_10 sf
.445 .044(Automata Studies)J
f3_10 sf
.39 .039(, Princeton, 1956,177-181.)J
72 580 :M
3.611 .361(McDowell, C.E. & Helmbold, D.P.  "Debugging concurrent programs".  )J
f0_10 sf
3.87 .387(ACM Comput. Surv. 21)J
f3_10 sf
1.551(,4)A
89 591 :M
.101(\(Dec.\3121989\),593-622.)A
72 602 :M
1.502 .15(Miller, B.P. & Choi, J.-D.  "A mechanism for efficient debugging of parallel programs".  )J
f0_10 sf
2.146 .215(Proc. ACM PLDI,)J
89 613 :M
f3_10 sf
.056(1988,135-144.)A
72 624 :M
.392 .039(Morita, K.  "A Simple Construction Method of a Reversible Finite Automaton out of Fredkin Gates, and its Related)J
89 635 :M
.227 .023(Problem".  )J
f0_10 sf
.247 .025(Trans. IEICE E 73)J
f3_10 sf
.316 .032(, 6 \(1990\),978-984.)J
72 646 :M
3.837 .384(Nylin, W.C.Jr., and Harvill, J.B.  "Multiple Tense Computer Programming".  )J
f0_10 sf
4.078 .408(Sigplan Not. 11)J
f3_10 sf
1.427(,12)A
89 657 :M
.113(\(Dec.\3121976\),74-93.)A
72 668 :M
.538 .054(Pan, D.Z., and Linton, M.A.  "Supporting reverse execution of parallel programs".  )J
f0_10 sf
.757 .076(Proc. ACM Sigplan/Sigops WS)J
89 679 :M
.18 .018(on Par. & Distr. Debugging)J
f3_10 sf
.234 .023(, May 1988,112-123.)J
72 690 :M
.751 .075(Penrose, R.  )J
f0_10 sf
1.141 .114(The Emperor's New Mind: Concerning Computers, Minds, and the Laws of Physics)J
f3_10 sf
.878 .088(.  Penguin Bks,)J
89 701 :M
.178 .018(London, 1989.)J
72 712 :M
.163 .016(Peyton-Jones, S.L.  )J
f0_10 sf
.236 .024(The Implementation of Functional Programming Languages)J
f3_10 sf
.166 .017(.  Prentice-Hall, NY, 1987.)J
72 723 :M
.27 .027(Planck, Max.  )J
f0_10 sf
.52 .052(Treatise on Thermodynamics)J
f3_10 sf
.288 .029(.  Transl. Ogg, A., Dover Publ., NY, 1945.)J
endp
%%Page: 13 13
%%BeginPageSetup
initializepage
(Henry Baker; page: 13 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 50 :M
f0_12 sf
.384 .038(Proc. Int'l. Workshop on Memory Mgmt.)J
f3_12 sf
.328 .033(, St Malo, France, Sept. 1992, Springer LNCS 637.)J
72 753 :M
-.053(Copyright \251 1991, 1992 by Nimble Computer Corporation)A
492 753 :M
(13)S
72 74 :M
f3_10 sf
.628 .063(Ressler, A.L.  )J
f0_10 sf
.856 .086(The Design of a Conservative Logic Computer and a Graphical Editor Simulator)J
f3_10 sf
.602 .06(.  M.S. Th., MIT,)J
89 85 :M
.75 .075(1981, 128p.)J
72 96 :M
.372 .037(de Roever, Willem P.  "On Backtracking and Greatest Fixpoints".  In Neuhold, Erich J., )J
f0_10 sf
.138(Ed)A
f3_10 sf
.081 .008(.  )J
f0_10 sf
.56 .056(Formal Description of)J
89 107 :M
-.017(Programming Concepts)A
f3_10 sf
-.016(, North-Holland, Amsterdam, 1978.)A
72 118 :M
.185 .019(Romanenko, Alexander.  "Inversion and Metacomputation".  )J
f0_10 sf
.285 .028(ACM PEPM'91)J
f3_10 sf
.169 .017(, New Haven, CT, June 1991,12-22.)J
72 129 :M
.38 .038(Rosenschein, Stanley J.  "Plan Synthesis: A Logical Perspective".  )J
f0_10 sf
.609 .061(Proc. IJCAI-81)J
f3_10 sf
.452 .045(, Vancouver, Canada, Aug. 1981,)J
89 140 :M
.025(331-337.)A
72 151 :M
.304 .03(Ruggieri, C. & Murtagh, T. P.  "Lifetime analysis of dynamically allocated objects".  )J
f0_10 sf
.397 .04(ACM POPL '88)J
f3_10 sf
.096(,285-293.)A
72 162 :M
1.156 .116(Schorr, H., & Waite, W.M.  "An efficient machine-independent procedure for garbage collection in various list)J
89 173 :M
.401 .04(structures".  )J
f0_10 sf
.64 .064(CACM 10)J
f3_10 sf
.625 .063(,8 \(Aug. 1967\),501-506.)J
72 184 :M
.228 .023(Shoman, Y., and McDermott, D.V.  "Directed Relations and Inversion of Prolog Programs".  )J
f0_10 sf
.21 .021(Proc. Conf. of 5th Gen.)J
89 195 :M
1.436 .144(Comp. Sys.)J
f3_10 sf
1.121 .112(, ICOT, 1984.)J
72 206 :M
1.694 .169(Sleator, D.D. & Tarjan, R.E.  "Amortized Efficiency of List Update and Paging Rules".  )J
f0_10 sf
2.681 .268(CACM 28)J
f3_10 sf
2.052 .205(,2 \(Feb.)J
89 217 :M
.026(1985\),202-208.)A
72 228 :M
.649 .065(Smith, J.M., and Maguire, G.Q., Jr.  "Transparent concurrent execution of mutually exclusive alternatives".  )J
f0_10 sf
.212(Proc.)A
89 239 :M
.526 .053(9th Int'l. Conf. on Distr. Computer Sys.)J
f3_10 sf
.544 .054(, Newport Bch., CA, June 1989.)J
72 250 :M
.216 .022(Strom, R.E., )J
f0_10 sf
.159 .016(et al)J
f3_10 sf
.208 .021(.  "A recoverable object store".  IBM Watson Research Ctr., 1988.)J
72 261 :M
.222 .022(Strothotte, T.W., and Cormack, G.V.  "Structured Program Lookahead".  )J
f0_10 sf
.258 .026(Comput. Lang. 12)J
f3_10 sf
.346 .035(,2 \(1987\),95-108.)J
72 272 :M
.522 .052(Suzuki, N.  "Analysis of Pointer 'Rotation'".  )J
f0_10 sf
.87 .087(CACM 25,)J
f3_10 sf
1.147 .115(5 \(May\3121982\)330-335.)J
72 283 :M
.513 .051(Toffoli, T.  "Reversible Computing".  MIT/LCS/TM-151, Feb. 1980, 36p.)J
72 294 :M
.28 .028(Toffoli, T.  "Reversible Computing".  In De Bakker & van Leeuwen, )J
f0_10 sf
.083(eds)A
f3_10 sf
.061 .006(.  )J
f0_10 sf
.48 .048(Automata, Languages and Programming,)J
89 305 :M
f3_10 sf
-.048(Springer-Verlag \(1980\),632-644.)A
72 316 :M
.367 .037(Toffoli, T.  "Bicontinuous Extensions of Invertible Combinatorial Functions".  )J
f0_10 sf
.345 .035(Math. Sys. Theor. 14)J
f3_10 sf
.518 .052( \(1981\),13-23.)J
72 327 :M
.395 .04(Toffoli, T.  "Physics and Computation".  )J
f0_10 sf
.384 .038(Int'l. J. Theor. Phys. 21)J
f3_10 sf
.567 .057(, 3/4 \(1982\),165-175.)J
72 338 :M
1.051 .105(Tolmach, A.P., and Appel, A.W.  "Debugging Standard ML without Reverse Engineering".  )J
f0_10 sf
1.027 .103(Proc. ACM Lisp &)J
89 349 :M
.259 .026(Funct. Progr. Conf.)J
f3_10 sf
.228 .023(, Nice, France, June 1990,1-12.)J
72 360 :M
.042 .004(Turner, D.  "A New Implementation Technique for Applicative Languages".  )J
f0_10 sf
.078 .008(SW\321Pract.&Exper. 9)J
f3_10 sf
.061 .006( \(1979\),31-49.)J
72 371 :M
1.395 .14(Vitter, J.S.  "US&R: a new framework for redoing".  )J
f0_10 sf
1.583 .158(ACM Symp. on Pract. SW Dev. Envs)J
f3_10 sf
1.456 .146(., Pitts., PA, April)J
89 382 :M
.056(1984,168-176.)A
72 393 :M
.153 .015(Wadler, P.  "Views: A way for pattern matching to cohabit with data abstraction".  )J
f0_10 sf
.211 .021(ACM POPL 14)J
f3_10 sf
.289 .029( \(1987\),307-313.)J
72 404 :M
.143 .014(Wadler, P.  "Is there a use for linear logic?".  )J
f0_10 sf
.293 .029(Proc. ACM PEPM'91)J
f3_10 sf
.244 .024(, New Haven, June, 1991,255-273.)J
72 415 :M
.335 .034(Wakeling, D. & Runciman, C.  "Linearity and Laziness".  )J
f0_10 sf
.385 .039(Proc. Funct. Progr. & Comp. Arch.)J
f3_10 sf
.4 .04(, Springer LNCS 523,)J
89 426 :M
.056(1991,215-240.)A
72 437 :M
.328 .033(Wilson, P.R. & Moher, T.G.  "Demonic memory for process histories".  )J
f0_10 sf
.448 .045(Proc. Sigplan PLDI)J
f3_10 sf
.333 .033(, June 1989.)J
72 448 :M
.428 .043(Zelkowitz, M.V.  "Reversible Execution".  )J
f0_10 sf
.598 .06(CACM 16)J
f3_10 sf
.574 .057(,9 \(Sept. 1973\),566-566.)J
72 459 :M
.178 .018(Zurek, W.H., )J
f0_10 sf
.05(ed)A
f3_10 sf
.034 .003(.  )J
f0_10 sf
.2 .02(Complexity, Entropy and the Physics of Information)J
f3_10 sf
.201 .02(.  Addison-Wesley, Redwood City, 1990.)J
endp
%%Trailer
end
%%EOF
