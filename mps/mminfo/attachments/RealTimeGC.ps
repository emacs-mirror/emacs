%!PS-Adobe-3.0
%%Title: (RTGC.wrd)
%%Creator: (Microsoft Word: LaserWriter 8 8.2)
%%CreationDate: (5:04 PM Tuesday, December 6, 1994)
%%For: (Henry Baker)
%%Pages: 13
%%DocumentFonts: Times-Italic Symbol Times-Roman Times-Bold Times-BoldItalic Courier Courier-Oblique
%%DocumentNeededFonts: Times-Italic Symbol Times-Roman Times-Bold Times-BoldItalic Courier Courier-Oblique
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%%DocumentMedia: Default 612 792 0 () ()
%ADO_ImageableArea: 31 31 583 761
%%EndComments
userdict begin/dscInfo 5 dict dup begin
/Title(RTGC.wrd)def
/Creator(Microsoft Word: LaserWriter 8 8.2)def
/CreationDate(5:04 PM Tuesday, December 6, 1994)def
/For(Henry Baker)def
/Pages 1 def
end def end

save 
/version23-manualfeedpatch where { pop false } { true }ifelse
 % we don't do an explicit 'get' since product and version MAY
 % be in systemdict or statusdict - this technique gets the lookup
 % without failure
statusdict begin
  product (LaserWriter) eq        % true if LaserWriter
  version cvr 23.0 eq             % true if version 23
end

and  % only install this patch if both are true
and  % true only if patch is not installed and is for this printer
     % save object and boolean on stack
dup { exch restore }if
% either true OR saveobject false
dup
{
  /version23-manualfeedpatch true def
  /oldversion23-showpage /showpage load def
  /showpage       % this showpage will wait extra time if manualfeed is true
  {%
     statusdict /manualfeed known
     {% manualfeed known in statusdict
        statusdict /manualfeed get
        {% if true then we loop for 5 seconds
           usertime 5000 add       % target usertime
           { % loop
             dup usertime sub 0 lt
             { exit }if
           }loop
           pop             % pop the usertime off the stac
        }if
     }if
     oldversion23-showpage
  }bind def
}if
not{ restore }if

/md 190 dict def md begin/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 81 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
%%BeginFile: adobe_psp_derived_styles
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/wi
version(23.0)eq
{
{
gS 0 0 0 0 rC stringwidth gR
}bind
}{
/stringwidth load
}ifelse
def
/$o 1. def
/gl{$o G}bd
/ms{:M S}bd
/condensedmtx[.82 0 0 1 0 0]def
/:mc
{
condensedmtx :mf def
}bd
/extendedmtx[1.18 0 0 1 0 0]def
/:me
{
extendedmtx :mf def
}bd
/basefont Z
/basefonto Z
/dxa Z
/dxb Z
/dxc Z
/dxd Z
/dsdx2 Z
/bfproc Z
/:fbase
{
dup/FontType get 0 eq{
dup length dict begin
dup{1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse}forall
/FDepVector exch/FDepVector get[exch/:fbase load forall]def
}/bfproc load ifelse
/customfont currentdict end definefont
}bd
/:mo
{
/bfproc{
dup dup length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse
}forall
/PaintType 2 def
/StrokeWidth .012 0 FontMatrix idtransform pop def
/customfont currentdict
end
definefont
8 dict begin
/basefonto xdf
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
basefont setfont
( )dup 0 4 -1 roll put
dup wi
setcharwidth
0 0 :M
gS
gl
dup show
gR
basefonto setfont
show
end
}def
}store :fbase
}bd
/:mso
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxa 1 ps div def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
1 index 0 ne
{
exch dxa add exch
}if
setcharwidth
dup 0 0 ms
dup dxa 0 ms
dup dxa dxa ms
dup 0 dxa ms
gl
dxa 2. div dup ms
end
end
}def
}store :fbase
}bd
/:ms
{
/bfproc{
dup dup length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse
}forall
/PaintType 2 def
/StrokeWidth .012 0 FontMatrix idtransform pop def
/customfont currentdict
end
definefont
8 dict begin
/basefonto xdf
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxb .05 def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
exch dup 0 ne
{
dxb add
}if
exch setcharwidth
dup dxb .01 add 0 ms
0 dxb :T
gS
gl
dup 0 0 ms
gR
basefonto setfont
0 0 ms
end
end
}def
}store :fbase
}bd
/:mss
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxc 1 ps div def
/dsdx2 .05 dxc 2 div add def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
exch dup 0 ne
{
dsdx2 add
}if
exch setcharwidth
dup dsdx2 .01 add 0 ms
0 .05 dxc 2 div sub :T
dup 0 0 ms
dup dxc 0 ms
dup dxc dxc ms
dup 0 dxc ms
gl
dxc 2 div dup ms
end
end
}def
}store :fbase
}bd
/:msb
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxd .03 def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
1 index 0 ne
{
exch dxd add exch
}if
setcharwidth
dup 0 0 ms
dup dxd 0 ms
dup dxd dxd ms
0 dxd ms
end
end
}def
}store :fbase
}bd
/italicmtx[1 0 -.212557 1 0 0]def
/:mi
{
italicmtx :mf def
}bd
/:v
{
[exch dup/FontMatrix get exch
dup/FontInfo known
{
/FontInfo get
dup/UnderlinePosition known
{
dup/UnderlinePosition get
2 index 0
3 1 roll
transform
exch pop
}{
.1
}ifelse
3 1 roll
dup/UnderlineThickness known
{
/UnderlineThickness get
exch 0 3 1 roll
transform
exch pop
abs
}{
pop pop .067
}ifelse
}{
pop pop .1 .067
}ifelse
]
}bd
/$t Z
/$p Z
/$s Z
/:p
{
aload pop
2 index mul/$t xs
1 index mul/$p xs
.012 mul/$s xs
}bd
/:m
{gS
0 $p rm
$t lw
0 rl stroke
gR
}bd
/:n
{
gS
0 $p rm
$t lw
0 rl
gS
gl
stroke
gR
strokepath
$s lw
/setstrokeadjust where{pop
currentstrokeadjust true setstrokeadjust stroke setstrokeadjust
}{
stroke
}ifelse
gR
}bd
/:o
{gS
0 $p rm
$t 2 div dup rm
$t lw
dup 0 rl
stroke
gR
:n
}bd
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if end
%%EndProlog
%%BeginSetup
md begin
countdictstack[{
%%BeginFeature: *ManualFeed False
statusdict /manualfeed false put
%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *InputSlot Cassette

%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *PageRegion LetterSmall
lettersmall
%%EndFeature
}featurecleanup
(Henry Baker)setjob
/mT[1 0 0 -1 31 761]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Times-Italic
%%IncludeFont: Symbol
%%IncludeFont: Times-Roman
%%IncludeFont: Times-Bold
%%IncludeFont: Times-BoldItalic
%%IncludeFont: Courier
%%IncludeFont: Courier-Oblique
/f0_1/Times-Italic
:mre
/f0_9 f0_1 9 scf
/f1_1/Symbol
:bsr
240/apple pd
:esr
/f1_9 f1_1 9 scf
/f1_8 f1_1 8 scf
/f2_1 f1_1
:mi
/f2_9 f2_1 9 scf
/f3_1/Times-Roman
:mre
/f3_18 f3_1 18 scf
/f3_12 f3_1 12 scf
/f3_9 f3_1 9 scf
/f3_8 f3_1 8 scf
/f3_7 f3_1 7 scf
/f4_1/Times-Bold
:mre
/f4_9 f4_1 9 scf
/f5_1 f1_1
def
/f5_9 f5_1 9 scf
/f6_1/Times-BoldItalic
:mre
/f6_9 f6_1 9 scf
/f7_1 f5_1
:mi
/f7_9 f7_1 9 scf
/f8_1/Courier
:mre
/f8_9 f8_1 9 scf
/f9_1/Courier-Oblique
:mre
/f9_9 f9_1 9 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(Henry Baker; page: 1 of 13)setjob
%%EndPageSetup
gS 0 0 552 730 rC
35 13 :M
f0_9 sf
1.528 .153(Communications of the ACM)J
f3_9 sf
.164 .016( )J
f4_9 sf
.361(21)A
f3_9 sf
1.151 .115(, 4 \(April 1978\), 280-294.)J
281 723 :M
(1)S
35 43 :M
f3_18 sf
.319 .032(List Processing in Real Time on)J
35 61 :M
.291 .029(a Serial Computer)J
35 84 :M
f3_12 sf
.634 .063(Henry G. Baker, Jr.)J
35 96 :M
-.109(Massachusetts Institute of Technology)A
33 114 -1 1 270 113 1 33 113 @a
51 122 :M
f4_9 sf
4.142 .414(A real-time list processing system is one in)J
35 132 :M
3.549 .355(which the time required by the elementary list)J
35 142 :M
3.965 .397(operations \(e.g. CONS, CAR, COR, RPLACA,)J
35 152 :M
2.331 .233(RPLACD, EQ, and ATOM in LISP\) is bounded by a)J
35 162 :M
5.214 .521(\(small\) constant.  Classical implementations of)J
35 172 :M
4.977 .498(list processing systems lack this property)J
35 182 :M
3.666 .367(because allocating a list cell from the heap may)J
35 192 :M
4.561 .456(cause a garbage collection, which process)J
35 202 :M
3.723 .372(requires time proportional to the heap size to)J
35 212 :M
4.353 .435(finish.  A real-time list processing system is)J
35 222 :M
5.152 .515(presented which continuously reclaims garbage,)J
35 232 :M
4.797 .48(including directed cycles, while linearizing and)J
35 242 :M
5.291 .529(compacting the accessible cells into contiguous)J
35 252 :M
4.393 .439(locations to avoid fragmenting the free storage)J
35 262 :M
3.096 .31(pool.  The program is small and requires no)J
35 272 :M
4.641 .464(time-sharing interrupts, making it suitable for)J
35 282 :M
4.084 .408(microcode.  Finally, the system requires the)J
35 292 :M
3.266 .327(same average time, and not more than twice the)J
35 302 :M
4.579 .458(space, of a classical implementation, and those)J
35 312 :M
3.212 .321(space requirements can be reduced to)J
35 322 :M
5.534 .553(approximately classical proportions by compact)J
35 332 :M
4.062 .406(list representation.  Arrays of different sizes, a)J
35 342 :M
3.887 .389(program stack, and hash linking are simple)J
35 352 :M
4.375 .438(extensions to our system, and reference counting)J
35 362 :M
3.916 .392(is found to be inferior for many applications.)J
51 372 :M
3.721 .372(Key Words and Phrases: real-time,)J
35 382 :M
6.199 .62(compacting, garbage collection, list)J
35 392 :M
4.549 .455(processing, virtual memory, file or database)J
35 402 :M
5.415 .541(management, storage management, storage)J
35 412 :M
5.449 .545(allocation, LISP, CDR-coding, reference)J
35 422 :M
1.281(counting.)A
51 432 :M
5.489 .549(CR Categories: 3.50, 3.60, 3.73, 3.80, 4.13,)J
35 442 :M
6.157 .616(4.22, 4.32, 4.33, 4.35, 4.49)J
33 449 -1 1 270 448 1 33 448 @a
51 455 :M
f3_8 sf
.717 .072(Copyright \251 1978 by the Association for Computing Machinery,)J
35 463 :M
1.003 .1(Inc.  Permission to make digital or hard copies of part or all of this)J
35 471 :M
.301 .03(work for personal or classroom use is granted without fee provided that)J
35 479 :M
1.555 .155(copies are not made or distributed for profit or direct commercial)J
35 487 :M
.764 .076(advantage and that copies show this notice on the first page or initial)J
35 495 :M
1.983 .198(screen of a display along with the full citation.  Copyrights for)J
35 503 :M
.373 .037(components of this work owned by others than ACM must be honored.)J
35 511 :M
.137 .014(Abstracting with credit is permitted.  To copy otherwise, to republish, to)J
35 519 :M
.462 .046(post on servers, to redistribute to lists, or to use any component of this)J
35 527 :M
.996 .1(work in other works whether directly or by incorporation via a link,)J
35 535 :M
1.017 .102(requires prior specific permission and/or a fee.  Permissions may be)J
35 543 :M
1.156 .116(requested from Publications Dept, ACM Inc., 1515 Broadway, New)J
35 551 :M
6.019 .602(York, NY 10036 USA, fax +1 \(212\) 869-0481, or)J
35 559 :M
.023(permissions@acm.org.)A
51 567 :M
.848 .085(This research was supported by the Advanced Research Projects)J
35 575 :M
1.725 .172(Agency of the Department of Defense and was monitored by the)J
35 583 :M
.827 .083(Office of Naval Research under contract number N00014-75-C-0522.)J
35 591 :M
2.649 .265(Author's address: Computer Science Department, University of)J
35 599 :M
.349 .035(Rochester, Rochester, NY  14627.)J
282 45 :M
f4_9 sf
3.435 .344(1.  Introduction and Previous Work)J
298 60 :M
f3_9 sf
1.481 .148(List processing systems such as LISP [25] have slowly)J
282 70 :M
2.368 .237(gained popularity over the years in spite of some rather)J
282 80 :M
3.226 .323(severe handicaps.  First, they usually interpreted their)J
282 90 :M
1.989 .199(programs instead of compiling them, thus increasing their)J
282 100 :M
1.666 .167(running time by several orders of magnitude.  Second, the)J
282 110 :M
.713 .071(storage structures used in such systems were inefficient in the)J
282 120 :M
1.046 .105(use of storage; for example, compiling a program sometimes)J
282 130 :M
1.129 .113(halved the amount of storage it occupied.  Third, processing)J
282 140 :M
1.788 .179(had to be halted periodically to reclaim storage by a long)J
282 150 :M
2.816 .282(process known as garbage collection, which laboriously)J
282 160 :M
3.265 .327(traced and marked every accessible cell so that those)J
282 170 :M
.766 .077(inaccessible cells could be recycled.)J
298 180 :M
1.507 .151(That such inefficiencies were tolerated for so long is a)J
282 190 :M
4.564 .456(tribute to the elegance and productivity gained by)J
282 200 :M
1.12 .112(programming in these languages.  These languages freed the)J
282 210 :M
1.415 .141(programmer from a primary concern: )J
f0_9 sf
2.364 .236(storage management)J
f3_9 sf
(.)S
282 220 :M
.796 .08(The programmer had only to call CONS \(or its equivalent\) to)J
282 230 :M
1.92 .192(obtain a pointer to a fresh storage block; even better, the)J
282 240 :M
1.373 .137(programmer had only to relinquish all copies of the pointer)J
282 250 :M
1.513 .151(and the storage block would automatically be reclaimed by)J
282 260 :M
.707 .071(the tireless garbage collector.  The programmer no longer had)J
282 270 :M
1.071 .107(to worry about prematurely freeing a block of storage which)J
282 280 :M
.702 .07(was still in use by another part of the system.)J
298 290 :M
1.724 .172(The first problem was solved with the advent of good)J
282 300 :M
2.779 .278(compilers [27,32] and new languages such as SIMULA)J
282 310 :M
1.635 .163(especially designed for efficient compilation [1,5,14].  The)J
282 320 :M
2.95 .295(second was also solved to some extent by those same)J
282 330 :M
1 .1(compilers because the user programs could be removed from)J
282 340 :M
1.069 .107(the list storage area and freed from its inefficient constraints)J
282 352 :M
2.623 .262(on representation.)J
0 -3 rm
.513(1)A
0 3 rm
1.479 .148(  Other techniques such as compact list)J
282 362 :M
1.738 .174(representation \("CDR-coding"\) [12,19] have been proposed)J
282 372 :M
1.046 .105(which also offer partial solutions to this problem.)J
298 382 :M
1.805 .18(This paper presents a solution to the third problem of)J
282 392 :M
3.935 .393(classical list processing techniques and removes that)J
282 402 :M
.775 .078(roadblock to their more general use.  Using the method given)J
282 412 :M
1.426 .143(here, a computer could have list processing primitives built)J
282 422 :M
.86 .086(in as machine instructions and the programmer would still be)J
282 432 :M
1.977 .198(assured that each instruction would finish in a reasonable)J
282 442 :M
1.864 .186(amount of time.  For example, the interrupt handler for a)J
282 452 :M
2.161 .216(keyboard could store its characters on the same kinds of)J
282 462 :M
1.144 .114(lists\321and in the same storage area\321as the lists of the main)J
282 472 :M
1.391 .139(program.  Since there would be no long wait for a garbage)J
282 482 :M
1.794 .179(collection, response time could be guaranteed to be small.)J
282 492 :M
2.636 .264(Even an operating system could use these primitives to)J
282 502 :M
2.659 .266(manipulate its burgeoning databases.  Business database)J
282 512 :M
3.003 .3(designers no longer need shy away from pointer-based)J
282 522 :M
1.96 .196(systems for fear that their systems will be impacted by a)J
282 532 :M
3.007 .301(week-long garbage collection! As memory is becoming)J
282 544 :M
.337(cheaper,)A
0 -3 rm
.401(2)A
0 3 rm
1.366 .137( even microcomputers could be built having these)J
282 554 :M
1.549 .155(primitives, so that the prospect of controlling one's kitchen)J
282 564 :M
.598 .06(stove with LISP is not so far-fetched.)J
298 574 :M
.662 .066(A )J
f0_9 sf
.333(real-time)A
f3_9 sf
1.252 .125( list processing system has the property that)J
282 584 :M
1.941 .194(the time required by each of the elementary operations is)J
282 594 :M
.985 .099(bounded by a constant independent of the number of cells in)J
282 604 :M
1.145 .115(use.  This property does not guarantee that the constant will)J
282 614 :M
1.466 .147(be small enough for a particular application on a particular)J
282 624 :M
1.528 .153(computer, and hence has been called "pseudo-real-time" by)J
282 634 :M
3.495 .349(some.  However, since we are presenting the system)J
-4127 -4126 -1 1 -4125 -4126 1 -4127 -4127 @a
298 646.24 -.24 .24 441.24 646 .24 298 646 @a
298 658 :M
.248(1)A
0 3 rm
.719 .072(In many cases, a rarely used program is compiled not to)J
0 -3 rm
282 671 :M
2.341 .234(save time in its execution, but to save garbage-collected)J
282 681 :M
1.535 .154(storage space.)J
298 690 :M
.366(2)A
0 3 rm
1.194 .119(Work is progressing on 10)J
0 -3 rm
f3_7 sf
.285(6)A
f3_9 sf
0 3 rm
.955 .096( bit chips.)J
0 -3 rm
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(Henry Baker; page: 2 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
66 44 :M
f0_9 sf
1.528 .153(Communications of the ACM)J
f3_9 sf
.164 .016( )J
f4_9 sf
.361(21)A
f3_9 sf
1.151 .115(, 4 \(April 1978\), 280-294.)J
312 754 :M
(2)S
66 68 :M
.762 .076(independent of a particular computer and application, it is the)J
66 78 :M
2.657 .266(most that can be said.  In all but the most demanding)J
66 88 :M
1.669 .167(applications, the proper choice of hardware can reduce the)J
66 98 :M
1.258 .126(constants to acceptable values.)J
82 108 :M
2.947 .295(Except where explicitly stated, we will assume the)J
66 118 :M
.842 .084(classical Von Neumann serial computer architecture with real)J
66 128 :M
.847 .085(memory in this paper.  This model consists of a memory, i.e.)J
66 138 :M
1.972 .197(a one-dimensional array of words, each of which is large)J
66 148 :M
1.122 .112(enough to hold \(at least\) the representation of a nonnegative)J
66 158 :M
2.522 .252(integer which is an index into that array; and a central)J
66 168 :M
1.119 .112(processing unit, or CPU, which has a small fixed number of)J
66 178 :M
1.834 .183(registers the size of a word.  The CPU can perform most)J
66 188 :M
.421 .042(operations on a word in a fixed, bounded amount of time.  The)J
66 198 :M
1.075 .108(only operations we require are load, store, add, subtract, test)J
66 208 :M
1.736 .174(if zero, and perhaps some bit-testing.  It is hard to find a)J
66 218 :M
1.05 .105(computer today without these operations.)J
82 228 :M
.871 .087(As simple as these requirements are, they exclude virtual)J
66 238 :M
1.159 .116(memory computers.  These machines are interesting because)J
66 248 :M
.755 .076(they take advantage of the locality of reference effect, i.e. the)J
66 258 :M
1.403 .14(nonzero serial correlation of accesses to memory, to reduce)J
66 268 :M
2.522 .252(the amount of fast memory in a system without greatly)J
66 278 :M
2.677 .268(increasing the average access time.  However, the time)J
66 288 :M
.756 .076(required to load a particular word from virtual memory into a)J
66 298 :M
.43 .043(CPU register is not bounded because the primary memory may)J
66 308 :M
1.469 .147(have to fetch it from a lower level memory.  Since we are)J
66 318 :M
1.813 .181(more interested in tight upper bounds, rather than average)J
66 328 :M
.755 .076(performance, this class of machines is excluded.)J
82 338 :M
1.385 .139(Since the primary list processing language in use today)J
66 348 :M
2.52 .252(is LISP, and since most of the literature uses the LISP)J
66 358 :M
1.315 .131(paradigm when discussing these problems, we will continue)J
66 368 :M
1.021 .102(this tradition and center our discussion around it.  Due to its)J
66 378 :M
.803 .08(small cells, which consist of 2 pointers apiece, LISP is also a)J
66 388 :M
.716 .072(kind of worst case for garbage collection overhead.)J
82 398 :M
.406 .041(There are two fundamental kinds of data in LISP: )J
f0_9 sf
.489 .049(list cells)J
66 408 :M
f3_9 sf
.48 .048(and )J
f0_9 sf
.19(atoms)A
f3_9 sf
.474 .047(.  List cells are ordered pairs consisting of a )J
f0_9 sf
.176(car)A
f3_9 sf
.517 .052( and)J
66 418 :M
.915 .091(a )J
f0_9 sf
.703(cdr)A
f3_9 sf
2.785 .279(, while atoms are indecomposable.  ATOM\()J
f0_9 sf
.702(x)A
f3_9 sf
1.23 .123(\) is a)J
66 428 :M
.912 .091(predicate which is true if and only if )J
f0_9 sf
.326(x)A
f3_9 sf
.772 .077( is an atom \(i.e. if and)J
66 438 :M
.497 .05(only if )J
f0_9 sf
.214(x)A
f3_9 sf
.501 .05( is not a list cell\); EQ\()J
f0_9 sf
.214(x)A
f3_9 sf
.121(,)A
f0_9 sf
.214(y)A
f3_9 sf
.611 .061(\) is a predicate which is true)J
66 448 :M
.311 .031(if and only if )J
f0_9 sf
.139(x)A
f3_9 sf
.244 .024( and )J
f0_9 sf
.139(y)A
f3_9 sf
.448 .045( are the same object; CAR\()J
f0_9 sf
.139(x)A
f3_9 sf
.488 .049(\) and CDR\()J
f0_9 sf
.139(x)A
f3_9 sf
<29>S
66 458 :M
3.219 .322(return the car and cdr components of the list cell )J
f0_9 sf
1.101(x)A
f3_9 sf
(,)S
66 468 :M
1.144 .114(respectively; CONS\()J
f0_9 sf
.176(x)A
f3_9 sf
.099(,)A
f0_9 sf
.176(y)A
f3_9 sf
.471 .047(\) returns a new list cell \(not EQ to any)J
66 478 :M
1.243 .124(other accessible list cell\) whose car is initially )J
f0_9 sf
.387(x)A
f3_9 sf
1.353 .135( and whose)J
66 488 :M
1.34 .134(cdr is initially )J
f0_9 sf
.482(y)A
f3_9 sf
2.745 .275(; RPLACA\()J
f0_9 sf
.482(x)A
f3_9 sf
.271(,)A
f0_9 sf
.482(y)A
f3_9 sf
2.156 .216(\) and RPLACD\()J
f0_9 sf
.482(x)A
f3_9 sf
.271(,)A
f0_9 sf
.482(y)A
f3_9 sf
1.076 .108(\) store )J
f0_9 sf
(y)S
66 498 :M
f3_9 sf
.817 .082(into the car and cdr of )J
f0_9 sf
.337(x)A
f3_9 sf
1.148 .115(, respectively.  We assume here that)J
66 508 :M
.981 .098(these seven primitives are the only ones which can access or)J
66 518 :M
.932 .093(change the representation of a list cell.)J
82 528 :M
1.398 .14(There have been several attempts to tackle the problem)J
66 538 :M
3.158 .316(of real time list processing.  Knuth [22,p.422] credits)J
66 548 :M
1.381 .138(Minsky as the first to consider the problem, and sketches a)J
66 558 :M
1.962 .196(multiprogramming solution in which the garbage collector)J
66 568 :M
1.339 .134(shares time with the main list processing program.  Steele's)J
66 578 :M
3.549 .355(paper [30] was the first in a flurry of papers about)J
66 588 :M
f0_9 sf
1.036(multiprocessing)A
f3_9 sf
4.661 .466( garbage collection which included)J
66 598 :M
2.148 .215(contributions by [16,17] and [23,24].  [28] independently)J
66 608 :M
1.068 .107(detailed the Minsky-Knuth-Steele method, and both [28] and)J
66 618 :M
.399 .04([33] analyzed the time and storage required to make it work.)J
82 628 :M
3.373 .337(The Minsky-Knuth-Steele-Muller-Wadler \(MKSMW\))J
66 638 :M
1.853 .185(method for real-time garbage collection has two processes)J
66 648 :M
1.325 .133(running in parallel.  The list processor process is called the)J
66 658 :M
f0_9 sf
.491(mutator)A
f3_9 sf
1.446 .145( while the garbage collector is called the )J
f0_9 sf
.482(collector)A
66 668 :M
f3_9 sf
.668 .067(\(these terms are due to [16]\).  The mutator executes the user's)J
66 678 :M
.92 .092(program while the collector performs garbage collection over)J
66 688 :M
.726 .073(and over again.  The collector has three phases: )J
f0_9 sf
.27(mark)A
f3_9 sf
.219 .022(, )J
f0_9 sf
.257(sweep)A
f3_9 sf
(,)S
66 698 :M
.519 .052(and )J
f0_9 sf
.176(relocate)A
f3_9 sf
.605 .06(.  During the mark phase, all accessible storage is)J
66 708 :M
1.718 .172(marked as such, and any inaccessible storage is picked up)J
66 718 :M
3.057 .306(during the sweep phase.  The relocate phase relocates)J
313 68 :M
1.832 .183(accessible cells in such a way as to minimize the address)J
313 78 :M
.535 .054(space required.  Since the mutator continues running while the)J
313 88 :M
1.123 .112(mark and relocate phases proceed, the free list must be long)J
313 98 :M
2.192 .219(enough to keep the mutator from starvation.  During the)J
313 108 :M
1.098 .11(sweep phase, cells must be added to the free list )J
f0_9 sf
.322(faster)A
f3_9 sf
1.195 .12( than)J
313 118 :M
1.691 .169(they can be taken off, on the average, lest the net gain in)J
313 128 :M
.95 .095(cells from that garbage collection cycle be negative.)J
329 138 :M
3.743 .374(The behavior of this algorithm under equilibrium)J
313 148 :M
2.158 .216(conditions \(which is when a cell is let go for every cell)J
313 158 :M
.227 .023(CONSED, and when the rates of cell use by the mutator, and of)J
313 168 :M
1.728 .173(marking, sweeping, and relocating by the collector, are all)J
313 178 :M
.405 .04(constant\) was studied in [28] and [33].  If we let )J
f0_9 sf
.241(m)A
f3_9 sf
.378 .038( be the ratio)J
313 188 :M
.951 .095(of the rate of CONSING to that of marking, )J
f0_9 sf
.277(s)A
f3_9 sf
.755 .075( be the ratio of)J
313 198 :M
.422 .042(the rate of CONSING to that of sweeping, and )J
f0_9 sf
.118(r)A
f3_9 sf
.321 .032( be the ratio of)J
313 208 :M
.535 .054(the rate of CONSING to that of relocating, then we can derive)J
313 218 :M
3.192 .319(estimates of the size of storage needed to support an)J
313 228 :M
4.667 .467(accessible population of )J
f0_9 sf
1.727(N)A
f3_9 sf
4.653 .465( cells under equilibrium)J
313 240 :M
.222(conditions.)A
0 -3 rm
.276(3)A
0 3 rm
.867 .087(  Using these assumptions, we derive:)J
313 255 :M
-.025(Maximum MKSMW Storage Required)A
386 271 :M
cF
f1_9 sf
.008<A3>A
sf
.075 .008( )J
f0_9 sf
.075(N)A
f3_9 sf
( )S
f0_9 sf
0 -6 rm
.082(m)A
0 6 rm
f3_9 sf
0 -6 rm
.051(+\()A
0 6 rm
f0_9 sf
0 -6 rm
.082(m)A
0 6 rm
f3_9 sf
0 -6 rm
.049(+1\)\()A
0 6 rm
f0_9 sf
0 -6 rm
(r)S
0 6 rm
f3_9 sf
0 -6 rm
.079(+1\))A
0 6 rm
412 276 :M
.117(1-)A
f0_9 sf
.109(s)A
f3_9 sf
.094<28>A
f0_9 sf
.109(r)A
f3_9 sf
.196(+1\))A
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
401 267.24 -.24 .24 455.24 267 .24 401 267 @a
455 271 :M
.562 .056( + size of collector stack)J
329 291 :M
.818 .082(We note that )J
f0_9 sf
.255(r)A
f3_9 sf
.885 .089(=0 if there is no relocation \(i.e. it happens)J
313 301 :M
1.055 .106(instantaneously\), and we have the simpler expression:)J
313 316 :M
-.025(Maximum MKSMW Storage Required)A
418 332 :M
cF
f1_9 sf
.016<A3>A
sf
.164 .016( )J
f0_9 sf
.164(N)A
f3_9 sf
.056 .006( )J
0 -6 rm
.128(1+2)A
0 6 rm
f0_9 sf
0 -6 rm
(m)S
0 6 rm
438 337 :M
f3_9 sf
.343(1-)A
f0_9 sf
(s)S
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
433 328.24 -.24 .24 455.24 328 .24 433 328 @a
455 332 :M
f3_9 sf
.562 .056( + size of collector stack)J
329 352 :M
.528 .053(The collector stack seems to require depth )J
f0_9 sf
.232(N)A
f3_9 sf
.439 .044( to handle the)J
313 362 :M
1.022 .102(worst case lists that can arise, but each position on the stack)J
313 372 :M
2.688 .269(need only hold one pointer.  Since a LISP cell is two)J
313 382 :M
2.788 .279(pointers, the collector stack space requirement is 0.5)J
f0_9 sf
1.1(N)A
f3_9 sf
(.)S
313 392 :M
.488 .049(Thus, we arrive at the inequality:)J
313 413 :M
.275 .027(Maximum MKSMW Storage Required )J
cF
f1_9 sf
.027<A3>A
sf
.275 .027( )J
f0_9 sf
.091(N)A
f3_9 sf
( )S
0 -6 rm
.063(1.5+2)A
0 6 rm
f0_9 sf
0 -6 rm
.099(m)A
0 6 rm
f3_9 sf
0 -6 rm
.049(-.5)A
0 6 rm
f0_9 sf
0 -6 rm
(s)S
0 6 rm
486 418 :M
f3_9 sf
.343(1-)A
f0_9 sf
(s)S
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
470 409.24 -.24 .24 515.24 409 .24 470 409 @a
329 433 :M
f3_9 sf
3.176 .318(These estimates become bounds for nonequilibrium)J
313 443 :M
.639 .064(situations so long as the ratios of the rate of CONSING to the)J
313 453 :M
1.328 .133(rates of marking, sweeping, and relocating are constant; i.e.)J
313 463 :M
1.303 .13(we relativize the rates of marking, sweeping, and relocating)J
313 473 :M
.434 .043(with respect to a CONS counter rather than a clock.)J
329 483 :M
2.057 .206(The Dijkstra-Lamport \(DL\) method [16,17,23,24] also)J
313 493 :M
2.08 .208(has the mutator and collector running in parallel, but the)J
313 503 :M
1.211 .121(collector uses no stack.  It marks by scanning all of storage)J
313 513 :M
.842 .084(for a mark bit it can propagate to the marked cell's offspring.)J
313 523 :M
2.083 .208(This simple method of garbage collection was considered)J
313 533 :M
1.013 .101(because their concern was )J
f0_9 sf
.277(proving)A
f3_9 sf
.967 .097( that the collector actually)J
313 543 :M
1.452 .145(collected only and all garbage.  Due to its inefficiency, we)J
313 553 :M
.753 .075(will not consider the storage requirements of this method.)J
329 563 :M
.201 .02(Both the MKSMW and the DL methods have the drawback)J
313 573 :M
.804 .08(that they are parallel algorithms and as a result are incredibly)J
313 583 :M
1.272 .127(hard to analyze and prove correct.  By contrast, the method)J
313 593 :M
.833 .083(we present is serial, making analyses and proofs easy.)J
313 611 :M
f4_9 sf
2.909 .291(2.  The Method)J
329 626 :M
f3_9 sf
1.531 .153(Our method is based on the Minsky garbage collection)J
313 636 :M
1.297 .13(algorithm [26], used by Fenichel and Yochelson in an early)J
313 646 :M
1.23 .123(Multics LISP [18], elegantly refined in [11], and applied by)J
313 656 :M
.943 .094(Arnborg to SIMULA [1].  This method divides the list space)J
313 666 :M
2.121 .212(into two )J
f0_9 sf
.778(semispaces)A
f3_9 sf
2.272 .227(.  During the execution of the user)J
313 676 :M
1.443 .144(program, all list cells are located in one of the semispaces.)J
313 686 :M
1.392 .139(When garbage collection is invoked, all accessible cells are)J
313 696 :M
.536 .054(traced, and instead of simply being marked, they are moved to)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
329 709.24 -.24 .24 472.24 709 .24 329 709 @a
329 721 :M
.19(3)A
0 3 rm
.527 .053(Of course )J
0 -3 rm
f0_9 sf
0 3 rm
.148(s)A
0 -3 rm
f3_9 sf
0 3 rm
.556 .056(<1, or else the storage required is infinite.)J
0 -3 rm
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(Henry Baker; page: 3 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
66 44 :M
f0_9 sf
1.528 .153(Communications of the ACM)J
f3_9 sf
.164 .016( )J
f4_9 sf
.361(21)A
f3_9 sf
1.151 .115(, 4 \(April 1978\), 280-294.)J
312 754 :M
(3)S
66 68 :M
.952 .095(the other semispace.  A )J
f0_9 sf
2.059 .206(forwarding address)J
f3_9 sf
.698 .07( is left at the old)J
66 78 :M
1.454 .145(location, and whenever an edge is traced which points to a)J
66 88 :M
1.281 .128(cell containing a forwarding address, the edge is updated to)J
66 98 :M
2.819 .282(reflect the move.  The end of tracing occurs when all)J
66 108 :M
2.018 .202(accessible cells have been moved into the "to" semispace)J
66 118 :M
.16<28>A
f0_9 sf
.21(tospace)A
f3_9 sf
.672 .067(\) and all edges have been updated.  Since the tospace)J
66 128 :M
1.587 .159(now contains all accessible cells and the "from" semispace)J
66 138 :M
.394<28>A
f0_9 sf
.548(fromspace)A
f3_9 sf
1.875 .188(\) contains only garbage, the collection is done)J
66 148 :M
1.042 .104(and the computation can proceed with CONS now allocating)J
66 158 :M
.769 .077(cells in the former fromspace.)J
82 168 :M
1.022 .102(This method is simple and elegant because 1\) it requires)J
66 178 :M
1.413 .141(only one pass instead of three to both collect and compact,)J
66 188 :M
1.514 .151(and 2\) it requires no collector stack.  The stack is avoided)J
66 198 :M
.745 .074(through the use of two pointers, )J
f0_9 sf
.326(B)A
f3_9 sf
.415 .042( and )J
f0_9 sf
.267(S)A
f3_9 sf
.174 .017(.  )J
f0_9 sf
.326(B)A
f3_9 sf
.639 .064( points to the first)J
66 208 :M
.579 .058(free word \(the )J
f0_9 sf
.204(bottom)A
f3_9 sf
.538 .054(\) of the free area, which is always in the)J
66 218 :M
.456 .046(tospace.  )J
f0_9 sf
.223(B)A
f3_9 sf
.581 .058( is incremented by COPY, which transfers old cells)J
66 228 :M
1.633 .163(from the fromspace to the bottom of the free area, and by)J
66 238 :M
2.637 .264(CONS, which allocates new cells.  )J
f0_9 sf
.879(S)A
f3_9 sf
.399 .04( )J
f0_9 sf
.781(scans)A
f3_9 sf
1.917 .192( the cells in)J
66 248 :M
2.932 .293(tospace which have been moved, and updates them by)J
66 258 :M
1.559 .156(moving the cells they point to.  )J
f0_9 sf
.634(S)A
f3_9 sf
1.59 .159( is initialized to point to)J
66 268 :M
1.138 .114(the beginning of tospace at every flip of the semispaces and)J
66 278 :M
.512 .051(is incremented when the cell it points to has been updated.  At)J
66 288 :M
1.089 .109(all times, then, the cells between )J
f0_9 sf
.39(S)A
f3_9 sf
.606 .061( and )J
f0_9 sf
.476(B)A
f3_9 sf
1.271 .127( have been moved,)J
66 298 :M
1.307 .131(but their cars and cdrs have not been updated.  Thus, when)J
66 308 :M
f0_9 sf
.499(S)A
f3_9 sf
.563(=)A
f0_9 sf
.61(B)A
f3_9 sf
1.51 .151( all accessible cells have been moved into tospace and)J
66 318 :M
1.365 .136(their outgoing pointers have been updated.  This method of)J
66 328 :M
1.325 .132(pointer updating is equivalent to using a queue instead of a)J
66 338 :M
.892 .089(stack for marking, and therefore traces a spanning tree of the)J
66 348 :M
.928 .093(accessible cells in breadth-first order.)J
82 358 :M
2.258 .226(Besides solving the compaction problem for classical)J
66 368 :M
4.322 .432(LISP, the Minsky-Fenichel-Yochelson-Cheney-Arnborg)J
66 378 :M
3.522 .352(\(MFYCA\) method allows simple extensions to handle)J
66 388 :M
2.508 .251(nonuniformly sized arrays and CDR-coding because free)J
66 398 :M
1.656 .166(storage is kept in one large block.  Allocation is therefore)J
66 408 :M
2.463 .246(trivial; one simply adds )J
f0_9 sf
.828(n)A
f3_9 sf
2.153 .215( to the "free space pointer" to)J
66 418 :M
.685 .068(allocate a block of size )J
f0_9 sf
.273(n)A
f3_9 sf
(.)S
82 428 :M
2.83 .283(Copying garbage collectors have been dismissed by)J
66 438 :M
.657 .066(many as requiring too much storage for practical use \(because)J
313 68 :M
1.136 .114(they appear to use twice as much as classical LISP\), but we)J
313 78 :M
.819 .082(shall see that this judgement was, perhaps, premature.)J
329 88 :M
.853 .085(We present the MFYCA algorithm here in pseudo-Algol-)J
313 100 :M
1.292 .129(BCPL notation.  The notation ")J
f1_9 sf
.521(a)A
f3_9 sf
.275([)A
f1_9 sf
.453(b)A
f3_9 sf
1.269 .127(]" means the contents of)J
313 113 :M
.786 .079(the word whose address is the value of )J
f1_9 sf
.376(a)A
f3_9 sf
.616 .062( plus the value of )J
f1_9 sf
.327(b)A
f3_9 sf
(,)S
313 126 :M
1.019 .102(i.e. the contents of )J
f1_9 sf
.515(a)A
f3_9 sf
.29<CA2BCA>A
f1_9 sf
.448(b)A
f3_9 sf
.893 .089(.  If it appears on the left hand side)J
313 137 :M
.686 .069(of ":=", those contents are to be changed.  Thus, )J
f0_9 sf
.264(p)A
f3_9 sf
.176([)A
f0_9 sf
.147(i)A
f3_9 sf
.685 .068(] refers to)J
313 147 :M
2.144 .214(the )J
f0_9 sf
.567(i)A
f3_9 sf
2.79 .279(th component of the vector pointed to by )J
f0_9 sf
1.02(p)A
f3_9 sf
1.88 .188(.  The)J
313 157 :M
1.459 .146(function s)J
f0_9 sf
.279(ize\(p\))A
f3_9 sf
.858 .086( returns the size of the array pointed to by )J
f0_9 sf
.367(p)A
f3_9 sf
(.)S
313 169 :M
2.384 .238(The notation ")J
f1_9 sf
.891(a)A
f3_9 sf
.602<CA26CA>A
f1_9 sf
.775(b)A
f3_9 sf
1.732 .173(" is similar to the notation ")J
f1_9 sf
.891(a)A
f3_9 sf
.373<3BCA>A
f1_9 sf
.775(b)A
f3_9 sf
1.56 .156(" in)J
313 182 :M
.685 .068(that )J
f1_9 sf
.37(a)A
f3_9 sf
.456 .046( and )J
f1_9 sf
.322(b)A
f3_9 sf
.845 .085( are executed in order; however, ")J
f1_9 sf
.37(a)A
f3_9 sf
.25<CA26CA>A
f1_9 sf
.322(b)A
f3_9 sf
1.12 .112(" returns)J
313 195 :M
.911 .091(the value of )J
f1_9 sf
.497(a)A
f3_9 sf
.896 .09( rather than the value of )J
f1_9 sf
.433(b)A
f3_9 sf
.901 .09(.  Thus, ";" and "&")J
313 208 :M
.742 .074(are the duals of one another: ")J
f1_9 sf
.355(a)A
f3_8 sf
0 2 rm
.25(1)A
0 -2 rm
f3_9 sf
.247 .025(; )J
f1_9 sf
.355(a)A
f3_8 sf
0 2 rm
.25(2)A
0 -2 rm
f3_9 sf
.462 .046(; \311; )J
f1_9 sf
.355(a)A
f3_8 sf
0 2 rm
.25(n)A
0 -2 rm
f3_9 sf
.783 .078(" returns the last)J
313 221 :M
.284 .028(value \(that of )J
f1_9 sf
.144(a)A
f3_8 sf
0 2 rm
.102(n)A
0 -2 rm
f3_9 sf
.333 .033(\) whereas ")J
f1_9 sf
.144(a)A
f3_8 sf
0 2 rm
.102(1)A
0 -2 rm
f3_9 sf
.196 .02(& )J
f1_9 sf
.144(a)A
f3_8 sf
0 2 rm
.102(2)A
0 -2 rm
f3_9 sf
.28 .028(& \311& )J
f1_9 sf
.144(a)A
f3_8 sf
0 2 rm
.102(n)A
0 -2 rm
f3_9 sf
.322 .032(" returns the first)J
313 234 :M
.489 .049(value \(that of )J
f1_9 sf
.249(a)A
f3_8 sf
0 2 rm
.175(1)A
0 -2 rm
f3_9 sf
.23(\).)A
329 245 :M
1.212 .121(Our conventions are these: the user program has a bank)J
313 255 :M
.592 .059(of )J
f0_9 sf
.454(NR)A
f3_9 sf
.892 .089( registers )J
f0_9 sf
.435(R)A
f3_9 sf
.804 .08([1], \311, )J
f0_9 sf
.435(R)A
f3_9 sf
.237([)A
f0_9 sf
.454(NR)A
f3_9 sf
.321 .032(].  )J
f0_9 sf
1.204 .12(The user program may not)J
313 265 :M
.449 .045("squirrel away" pointers outside of the bank R during a call to)J
313 275 :M
.993(CONS)A
f3_9 sf
2.616 .262( because such pointers would become obsolete if)J
313 285 :M
.624 .062(garbage collection were to occur.  \(We will show later how to)J
313 295 :M
.418 .042(deal with a user program stack in such a way that the real-time)J
313 305 :M
.758 .076(properties of our system are not violated.\)  Pointers either are)J
313 315 :M
f0_9 sf
.314(atoms)A
f3_9 sf
.557 .056( or refer to )J
f0_9 sf
1.286 .129(cons cells)J
f3_9 sf
.858 .086( in fromspace or tospace.  A cons)J
313 325 :M
1.088 .109(cell )J
f0_9 sf
.428(c)A
f3_9 sf
1.284 .128( is represented by a 2-vector of pointers: )J
f0_9 sf
.428(car)A
f3_9 sf
.321<28>A
f0_9 sf
.428(c)A
f3_9 sf
.432(\)=)A
f0_9 sf
.428(c)A
f3_9 sf
.455([0],)A
313 335 :M
f0_9 sf
.829(cdr)A
f3_9 sf
.621<28>A
f0_9 sf
.828(c)A
f3_9 sf
.837(\)=)A
f0_9 sf
.828(c)A
f3_9 sf
1.375 .137([1].  )J
f0_9 sf
.984(FLIP)A
f3_9 sf
.777 .078(, )J
f0_9 sf
1.197(FROMSPACE)A
f3_9 sf
1.451 .145( and )J
f0_9 sf
1.14(TOSPACE)A
f3_9 sf
2.11 .211( are)J
313 345 :M
1.799 .18(implementation-dependent routines.  FLIP interchanges the)J
313 355 :M
.891 .089(roles of fromspace and tospace by causing CONS and COPY)J
313 365 :M
3.492 .349(to allocate in the other semispace and the predicates)J
313 375 :M
1.137 .114(FROMSPACE and TOSPACE to exchange roles.  FLIP also)J
313 385 :M
1.429 .143(has the responsibility of determining when the new tospace)J
313 395 :M
1.27 .127(is too small to hold everything from the fromspace plus the)J
313 405 :M
4.579 .458(newly consed cells.  Before flipping, it checks if)J
313 415 :M
f0_9 sf
.553(size)A
f3_9 sf
2.41 .241(\(fromspace\) is less than \(1+)J
f0_9 sf
1.064(m)A
f3_9 sf
.491(\)[)A
f0_9 sf
.553(size)A
f3_9 sf
.58(\(tospace\)-\()A
f0_9 sf
.82(T)A
f3_9 sf
.491(-)A
f0_9 sf
.901(B)A
f3_9 sf
.675(\)],)A
313 425 :M
2.332 .233(where )J
f0_9 sf
.77(T)A
f3_9 sf
1.797 .18( is the top of tospace, and if fromspace \(the new)J
313 435 :M
2.344 .234(tospace\) is too small, either it must be extended, or the)J
313 445 :M
.837 .084(system may later stop with a "memory overflow" indication.)J
64 452 -1 1 548 451 1 64 451 @a
66 465 :M
1.407 .141(% The Minsky-Fenichel-Yochelson-Cheney-Arnborg [26,18,11,1] Garbage Collector.)J
66 475 :M
f8_9 sf
-.399(pointer )A
f9_9 sf
-.399(B)A
f8_9 sf
(;)S
310 475 :M
f3_9 sf
.738 .074(% Bottom; points to bottom of free area.)J
66 485 :M
f8_9 sf
-.399(pointer )A
f9_9 sf
-.399(S)A
f8_9 sf
(;)S
310 485 :M
f3_9 sf
.649 .065(% Scan; points to first untraced cell.)J
66 495 :M
f8_9 sf
-.399(pointer )A
f9_9 sf
-.399(T)A
f8_9 sf
(;)S
310 495 :M
f3_9 sf
.854 .085(% Top; points to top of tospace.)J
310 505 :M
.66 .066(% Assertions: )J
f0_9 sf
.192(S)A
f3_9 sf
cF
f1_9 sf
.211<A3>A
sf
f0_9 sf
.235(B)A
f3_9 sf
cF
f1_9 sf
.211<A3>A
sf
f0_9 sf
.214(T)A
f3_9 sf
.299 .03( and )J
f0_9 sf
.214(T)A
f3_9 sf
.128(-)A
f0_9 sf
.235(B)A
f3_9 sf
.454 .045( is even.)J
66 517 :M
f8_9 sf
-.384(pointer procedure CONS\()A
f9_9 sf
-.384(x)A
f8_9 sf
-.384(,)A
f9_9 sf
-.384(y)A
f8_9 sf
-.384(\) )A
f1_9 sf
<BA>S
310 517 :M
f3_9 sf
.749 .075(% Allocate the list cell \()J
f0_9 sf
.261(x)A
f3_9 sf
.147(.)A
f0_9 sf
.261(y)A
f3_9 sf
<29>S
66 528 :M
f8_9 sf
-.465(  begin)A
66 538 :M
-.399(    if )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399( = )A
f9_9 sf
(T)S
310 538 :M
f3_9 sf
.302 .03(% If there is no more free space,)J
66 548 :M
f8_9 sf
-.443(      then)A
310 548 :M
f3_9 sf
.413 .041(%    collect all the garbage.)J
66 558 :M
f8_9 sf
-.432(        begin)A
310 558 :M
f3_9 sf
.855 .085(% This block is the "garbage collector".)J
66 568 :M
f8_9 sf
-.424(          flip\(\);)A
310 568 :M
f3_9 sf
1.092 .109(% Interchange semispaces.)J
66 578 :M
f8_9 sf
-.399(          for )A
f9_9 sf
-.399(i)A
f8_9 sf
-.399(=1 to )A
f9_9 sf
-.797(NR)A
310 578 :M
f3_9 sf
.418 .042(% Update all user registers.)J
66 588 :M
f8_9 sf
-.399(            do R[)A
f9_9 sf
-.399(i)A
f8_9 sf
-.399(]:=move\(R[)A
f9_9 sf
-.399(i)A
f8_9 sf
-.598(]\);)A
66 598 :M
-.399(          )A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(:=move\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(\); )A
f9_9 sf
-.399(y)A
f8_9 sf
-.399(:=move\()A
f9_9 sf
-.399(y)A
f8_9 sf
-.797(\);)A
310 598 :M
f3_9 sf
.2 .02(% Update our arguments.)J
66 608 :M
f8_9 sf
-.399(          while )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399(<)A
f9_9 sf
(B)S
310 608 :M
f3_9 sf
.561 .056(% Trace all accessible cells.)J
66 618 :M
f8_9 sf
-.42(            do begin)A
66 628 :M
-.399(                 )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399([0]:=move\()A
f9_9 sf
-.399(S)A
f8_9 sf
-.498([0]\);)A
310 628 :M
f3_9 sf
-.019(% Update the car and cdr.)A
66 638 :M
f8_9 sf
-.399(                 )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399([1]:=move\()A
f9_9 sf
-.399(S)A
f8_9 sf
-.498([1]\);)A
66 648 :M
-.399(                 )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(S)A
f8_9 sf
-.797(+2)A
310 648 :M
f3_9 sf
.574 .057(% Point to next untraced cell.)J
66 658 :M
f8_9 sf
-.422(               end)A
66 668 :M
-.432(         end;)A
66 678 :M
-.379(    if )A
f9_9 sf
-.379(B)A
f8_9 sf
cF
f1_9 sf
-.347<B3>A
sf
f9_9 sf
-.379(T)A
f8_9 sf
-.414( then error;)A
310 678 :M
f3_9 sf
.439 .044(% Memory is full.)J
66 688 :M
f8_9 sf
-.399(    )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399([0]:=)A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(; )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399([1]:=)A
f9_9 sf
-.399(y)A
f8_9 sf
(;)S
310 688 :M
f3_9 sf
.278 .028(% Create new cell at bottom of free area.)J
66 698 :M
f8_9 sf
-.399(    )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399( & \()A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(B)A
f8_9 sf
-.598(+2\))A
310 698 :M
f3_9 sf
.164 .016(% Return the current value of )J
f0_9 sf
(B)S
66 708 :M
f8_9 sf
-.478(  end;)A
310 708 :M
f3_9 sf
.596 .06(%   after stepping it to next cell.)J
66 720 :M
f8_9 sf
-.385(pointer procedure CAR\()A
f9_9 sf
-.385(x)A
f8_9 sf
-.385(\) )A
f1_9 sf
-.353<BA>A
f8_9 sf
-.385( )A
f9_9 sf
-.385(x)A
f8_9 sf
-.514([0];)A
310 720 :M
f3_9 sf
.401 .04(% A cell consists of 2 words:)J
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(Henry Baker; page: 4 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
66 44 :M
f0_9 sf
1.528 .153(Communications of the ACM)J
f3_9 sf
.164 .016( )J
f4_9 sf
.361(21)A
f3_9 sf
1.151 .115(, 4 \(April 1978\), 280-294.)J
312 754 :M
(4)S
66 70 :M
f8_9 sf
-.385(pointer procedure CDR\()A
f9_9 sf
-.385(x)A
f8_9 sf
-.385(\) )A
f1_9 sf
-.353<BA>A
f8_9 sf
-.385( )A
f9_9 sf
-.385(x)A
f8_9 sf
-.514([1];)A
310 70 :M
f3_9 sf
.215 .021(%   car is 1st; cdr is 2nd.)J
66 83 :M
f8_9 sf
-.385(procedure RPLACA\()A
f9_9 sf
-.385(x)A
f8_9 sf
-.385(,)A
f9_9 sf
-.385(y)A
f8_9 sf
-.385(\) )A
f1_9 sf
-.353<BA>A
f8_9 sf
-.385( )A
f9_9 sf
-.385(x)A
f8_9 sf
-.385([0]:=)A
f9_9 sf
-.385(y)A
f8_9 sf
(;)S
310 83 :M
f3_9 sf
.385 .039(% car\()J
f0_9 sf
.104(x)A
f3_9 sf
.157 .016(\) := )J
f0_9 sf
(y)S
66 96 :M
f8_9 sf
-.385(procedure RPLACD\()A
f9_9 sf
-.385(x)A
f8_9 sf
-.385(,)A
f9_9 sf
-.385(y)A
f8_9 sf
-.385(\) )A
f1_9 sf
-.353<BA>A
f8_9 sf
-.385( )A
f9_9 sf
-.385(x)A
f8_9 sf
-.385([1]:=)A
f9_9 sf
-.385(y)A
f8_9 sf
(;)S
310 96 :M
f3_9 sf
.228 .023(% cdr\()J
f0_9 sf
.06(x)A
f3_9 sf
.09 .009(\) := )J
f0_9 sf
(y)S
66 109 :M
f8_9 sf
-.385(boolean procedure EQ\()A
f9_9 sf
-.385(x)A
f8_9 sf
-.385(,)A
f9_9 sf
-.385(y)A
f8_9 sf
-.385(\) )A
f1_9 sf
-.353<BA>A
f8_9 sf
-.385( )A
f9_9 sf
-.385(x)A
f8_9 sf
-.385(=)A
f9_9 sf
-.385(y)A
f8_9 sf
(;)S
310 109 :M
f3_9 sf
.406 .041(% Are )J
f0_9 sf
.166(x)A
f3_9 sf
.093(,)A
f0_9 sf
.166(y)A
f3_9 sf
.56 .056( the same object?)J
66 122 :M
f8_9 sf
-.383(boolean procedure ATOM\()A
f9_9 sf
-.383(x)A
f8_9 sf
-.383(\) )A
f1_9 sf
<BA>S
310 122 :M
f3_9 sf
.197 .02(% Is )J
f0_9 sf
.106(x)A
f3_9 sf
.333 .033( an atom?)J
66 133 :M
f8_9 sf
-.399(  not tospace\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.797(\);)A
66 145 :M
-.383(pointer procedure MOVE\()A
f9_9 sf
-.383(p)A
f8_9 sf
-.383(\) )A
f1_9 sf
<BA>S
310 145 :M
f3_9 sf
.285 .029(% Move )J
f0_9 sf
.105(p)A
f3_9 sf
.298 .03( if not yet moved; return new address.)J
66 156 :M
f8_9 sf
-.399(  if not fromspace\()A
f9_9 sf
-.399(p)A
f8_9 sf
<29>S
310 156 :M
f3_9 sf
.399 .04(% We only need to move old ones.)J
66 166 :M
f8_9 sf
-.399(    then )A
f9_9 sf
(p)S
310 166 :M
f3_9 sf
.712 .071(% This happens a lot.)J
66 176 :M
f8_9 sf
-.429(    else begin)A
66 186 :M
-.399(           if not tospace\()A
f9_9 sf
-.399(p)A
f8_9 sf
-.532([0]\))A
310 186 :M
f3_9 sf
.127 .013(% We must move )J
f0_9 sf
(p)S
f3_9 sf
(.)S
66 196 :M
f8_9 sf
-.399(             then )A
f9_9 sf
-.399(p)A
f8_9 sf
-.399([0]:=copy\()A
f9_9 sf
-.399(p)A
f8_9 sf
-.797(\);)A
310 196 :M
f3_9 sf
.576 .058(% Copy it into the bottom of free area.)J
66 206 :M
f8_9 sf
-.399(           )A
f9_9 sf
-.399(p)A
f8_9 sf
-.598([0])A
310 206 :M
f3_9 sf
.067 .007(% Leave and return forwarding address.)J
66 216 :M
f8_9 sf
-.432(         end;)A
66 228 :M
-.383(pointer procedure COPY\()A
f9_9 sf
-.383(p)A
f8_9 sf
-.383(\) )A
f1_9 sf
<BA>S
310 228 :M
f3_9 sf
.271 .027(% Create a copy of a cell.)J
66 239 :M
f8_9 sf
-.465(  begin)A
310 239 :M
f3_9 sf
.421 .042(% Allocate space at bottom of free area.)J
66 249 :M
f8_9 sf
-.379(    if )A
f9_9 sf
-.379(B)A
f8_9 sf
cF
f1_9 sf
-.347<B3>A
sf
f9_9 sf
-.379(T)A
f8_9 sf
-.414( then error;)A
310 249 :M
f3_9 sf
.159 .016(% Memory full?)J
66 259 :M
f8_9 sf
-.399(    )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399([0]:=)A
f9_9 sf
-.399(p)A
f8_9 sf
-.399([0]; )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399([1]:=)A
f9_9 sf
-.399(p)A
f8_9 sf
-.532([1];)A
310 259 :M
f3_9 sf
.071 .007(% Each cell requires 2 words.)J
66 269 :M
f8_9 sf
-.399(    )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399( & \()A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(B)A
f8_9 sf
-.598(+2\))A
310 269 :M
f3_9 sf
.164 .016(% Return the current value of )J
f0_9 sf
(B)S
66 279 :M
f8_9 sf
-.478(  end;)A
310 279 :M
f3_9 sf
.517 .052(%   after moving it to next cell.)J
66 289 :M
.303 .03(%  TOSPACE, FROMSPACE test whether a pointer is in that semispace.)J
64 298 -1 1 548 297 1 64 297 @a
82 306 :M
1.426 .143(In order to convert MFYCA into a real-time algorithm,)J
66 316 :M
.82 .082(we force the mark ratio )J
f0_9 sf
.458(m)A
f3_9 sf
.967 .097( to be constant by changing CONS)J
66 326 :M
1.455 .146(so that it does )J
f0_9 sf
.626(k)A
f3_9 sf
2.257 .226( iterations of the garbage collection loop)J
66 336 :M
1.113 .111(before performing each allocation.  But this means that both)J
66 346 :M
1.617 .162(semispaces contain accessible cells at almost all times.  In)J
66 356 :M
1.591 .159(order to simplify the algorithm and the proof, )J
f0_9 sf
1.651 .165(we trick the)J
66 366 :M
1.126 .113(user program into believing that garbage collection ran and)J
66 376 :M
1.882 .188(finished at the time of the last flip)J
f3_9 sf
1.78 .178(; i.e. we assert that, as)J
66 386 :M
.711 .071(before, the user program sees addresses only in tospace.)J
82 396 :M
3.294 .329(Some slight effort must be made to keep up this)J
66 406 :M
1.432 .143(appearance.  When the semispaces are interchanged, all the)J
66 416 :M
1.02 .102(user program registers must be updated immediately to point)J
66 426 :M
2.294 .229(to tospace.  This gives the collector a head start on the)J
66 436 :M
1.84 .184(mutator.  Since the only operations that might violate our)J
66 446 :M
.276 .028(assertion are CAR and CDR, we make sure that CAR and CDR)J
313 306 :M
1.605 .161(cause forwarding addresses to be followed, and cells to be)J
313 316 :M
.66 .066(moved, when necessary.  This ensures that the mutator cannot)J
313 326 :M
1.224 .122(pass the collector.  It turns out that preserving our assertion)J
313 336 :M
4.682 .468(is much simpler than preserving the corresponding)J
313 346 :M
1.191 .119(assertions of DL [16,17,23,24].  In particular, RPLACA and)J
313 356 :M
.312 .031(RPLACD cannot cause any trouble at all!)J
329 366 :M
.996 .1(There is another problem caused by interleaving garbage)J
313 376 :M
2.194 .219(collection with normal list processing: the new cells that)J
313 386 :M
1.083 .108(CONS creates will be interleaved with those moved, thereby)J
313 396 :M
.812 .081(diluting the moved cells which must be traced by CONS.  Of)J
313 406 :M
1.054 .105(course, new cells have their cars and cdrs already in tospace)J
313 416 :M
.396 .04(and therefore do not need to be traced.  We avoid this waste of)J
313 426 :M
.99 .099(trace effort through the use of the pointer )J
f0_9 sf
.408(T)A
f3_9 sf
1.064 .106(, which points to)J
313 436 :M
.484 .048(the )J
f0_9 sf
.196(top)A
f3_9 sf
.533 .053( of the free area, and by allocating all )J
f0_9 sf
.247(new)A
f3_9 sf
.66 .066( cells there.)J
64 453 -1 1 548 452 1 64 452 @a
66 466 :M
.253 .025(% Serial Real-Time System \(SRT\).)J
66 476 :M
f8_9 sf
-.399(integer )A
f9_9 sf
-.399(k)A
f8_9 sf
(;)S
310 476 :M
f3_9 sf
.51 .051(% Global trace ratio parameter:)J
310 486 :M
.342 .034(%   the number of cells to trace per cons.)J
66 496 :M
f8_9 sf
-.399(pointer )A
f9_9 sf
-.399(T)A
f8_9 sf
(;)S
310 496 :M
f3_9 sf
.49 .049(% Top; Points to top of free area.)J
66 508 :M
f8_9 sf
-.384(pointer procedure CONS\()A
f9_9 sf
-.384(x)A
f8_9 sf
-.384(,)A
f9_9 sf
-.384(y)A
f8_9 sf
-.384(\) )A
f1_9 sf
<BA>S
310 508 :M
f3_9 sf
.955 .095(% Do some collection, then allocate \()J
f0_9 sf
.274(x)A
f3_9 sf
.154(.)A
f0_9 sf
.274(y)A
f3_9 sf
.359(\).)A
66 519 :M
f8_9 sf
-.465(  begin)A
66 529 :M
-.399(    if )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(=)A
f9_9 sf
(T)S
310 529 :M
f3_9 sf
.316 .032(% Check if free area is empty.)J
66 539 :M
f8_9 sf
-.425(      then begin)A
310 539 :M
f3_9 sf
.504 .05(% Switch semispaces.  Memory is full)J
66 549 :M
f8_9 sf
-.399(             if )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399(<)A
f9_9 sf
-.399(B)A
f8_9 sf
-.435( then error;)A
310 549 :M
f3_9 sf
.553 .055(%   if tracing is not finished.)J
66 559 :M
f8_9 sf
-.42(             flip\(\);)A
310 559 :M
f3_9 sf
1.019 .102(% Flip semispaces.)J
66 569 :M
f8_9 sf
-.399(             for )A
f9_9 sf
-.399(i)A
f8_9 sf
-.399(=1 to )A
f9_9 sf
-.797(NR)A
66 579 :M
f8_9 sf
-.399(               do R[)A
f9_9 sf
-.399(i)A
f8_9 sf
-.399(]:=move\(R[)A
f9_9 sf
-.399(i)A
f8_9 sf
-.598(]\);)A
310 579 :M
f3_9 sf
.249 .025(% Update user registers)J
66 589 :M
f8_9 sf
-.399(             )A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(:=move\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(\); )A
f9_9 sf
-.399(y)A
f8_9 sf
-.399(:=move\()A
f9_9 sf
-.399(y)A
f8_9 sf
-.797(\);)A
310 589 :M
f3_9 sf
.13 .013(%  and our arguments.)J
66 599 :M
f8_9 sf
-.427(           end;)A
66 609 :M
-.399(    for )A
f9_9 sf
-.399(i)A
f8_9 sf
-.399(=1 to )A
f9_9 sf
-.399(k)A
f8_9 sf
-.399( while )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399(<)A
f9_9 sf
(B)S
310 609 :M
f3_9 sf
.488 .049(% Do )J
f0_9 sf
.212(k)A
f3_9 sf
.66 .066( iterations of gc.)J
66 619 :M
f8_9 sf
-.429(      do begin)A
66 629 :M
-.399(           )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399([0]:=move\()A
f9_9 sf
-.399(S)A
f8_9 sf
-.498([0]\);)A
310 629 :M
f3_9 sf
-.06(% Update car and cdr.)A
66 639 :M
f8_9 sf
-.399(           )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399([1]:=move\()A
f9_9 sf
-.399(S)A
f8_9 sf
-.498([1]\);)A
66 649 :M
-.399(           )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(S)A
f8_9 sf
-.797(+2)A
310 649 :M
f3_9 sf
.37 .037(% Go on to next untraced cell.)J
66 659 :M
f8_9 sf
-.432(         end;)A
66 669 :M
-.399(    if )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(=)A
f9_9 sf
-.399(T)A
f8_9 sf
-.435( then error;)A
66 679 :M
-.399(    )A
f9_9 sf
-.399(T)A
f8_9 sf
-.399( := )A
f9_9 sf
-.399(T)A
f8_9 sf
-.598(-2;)A
310 679 :M
f3_9 sf
.425 .043(% Actually create the cell.)J
66 689 :M
f8_9 sf
-.399(    )A
f9_9 sf
-.399(T)A
f8_9 sf
-.399([0] := )A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(; )A
f9_9 sf
-.399(T)A
f8_9 sf
-.399([1]:=)A
f9_9 sf
-.399(y)A
f8_9 sf
(;)S
310 689 :M
f3_9 sf
.076 .008(% Move in car and cdr.)J
66 699 :M
f8_9 sf
-.399(    )A
f9_9 sf
(T)S
310 699 :M
f3_9 sf
.135 .013(% Return address of new cell.)J
66 709 :M
f8_9 sf
-.478(  end;)A
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(Henry Baker; page: 5 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
66 44 :M
f0_9 sf
1.528 .153(Communications of the ACM)J
f3_9 sf
.164 .016( )J
f4_9 sf
.361(21)A
f3_9 sf
1.151 .115(, 4 \(April 1978\), 280-294.)J
312 754 :M
(5)S
66 70 :M
f8_9 sf
-.389(pointer procedure CAR\()A
f9_9 sf
-.389(x)A
f8_9 sf
-.389(\) )A
f1_9 sf
-.356<BA>A
f8_9 sf
-.389( )A
f9_9 sf
-.389(x)A
f8_9 sf
-.389([0]:=move\()A
f9_9 sf
-.389(x)A
f8_9 sf
-.486([0]\);)A
310 70 :M
f3_9 sf
.317 .032(% Move, update and return )J
f0_9 sf
.096(x)A
f3_9 sf
.102([0].)A
66 83 :M
f8_9 sf
-.389(pointer procedure CDR\()A
f9_9 sf
-.389(x)A
f8_9 sf
-.389(\) )A
f1_9 sf
-.356<BA>A
f8_9 sf
-.389( )A
f9_9 sf
-.389(x)A
f8_9 sf
-.389([1]:=move\()A
f9_9 sf
-.389(x)A
f8_9 sf
-.486([1]\);)A
310 83 :M
f3_9 sf
.317 .032(% Move, update and return )J
f0_9 sf
.096(x)A
f3_9 sf
.102([1].)A
66 94 :M
.183 .018(% Procedures not redefined here are as before.)J
64 103 -1 1 548 102 1 64 102 @a
82 111 :M
.805 .08(The time required by all of the elementary list operations)J
66 121 :M
.978 .098(in this algorithm, with the exception of CONS, can easily be)J
66 131 :M
1.272 .127(seen to be bounded by a constant because they are straight-)J
66 141 :M
1.226 .123(line programs composed from primitives which are bounded)J
66 151 :M
1.205 .121(by constants.  CONS is also bounded by a constant because)J
66 161 :M
.531 .053(the number of mutator registers is a \(small\) fixed number \(e.g.)J
66 171 :M
1.996 .2(16\), and the parameter )J
f0_9 sf
.604(k)A
f3_9 sf
1.674 .167( is fixed.  In principle, given the)J
66 181 :M
1.923 .192(number of registers and the parameter )J
f0_9 sf
.542(k)A
f3_9 sf
1.482 .148(, the two loops in)J
66 191 :M
1.402 .14(CONS could be expanded into straight-line code; hence the)J
66 201 :M
.579 .058(time it requires is also bounded by a constant.)J
82 211 :M
3.099 .31(The proof that the incremental collector eventually)J
66 221 :M
1.796 .18(moves all accessible cells to tospace is an easy induction.)J
66 231 :M
2.665 .267(Upon system initialization there are no accessible cells,)J
66 241 :M
2.49 .249(hence none in tospace, and so we have a correct basis.)J
66 251 :M
1.213 .121(Suppose that at some point in the computation we have just)J
66 261 :M
2.467 .247(switched semispaces so that tospace is empty.  Suppose)J
66 271 :M
1.155 .115(further that there are )J
f0_9 sf
.575(N)A
f3_9 sf
1.473 .147( accessible cells in fromspace which)J
66 281 :M
2.322 .232(must be moved to tospace.  Now, every cell which was)J
66 291 :M
2.413 .241(accessible at the time of flipping eventually gets moved)J
66 301 :M
.568 .057(when it is traced, unless lost through RPLACA and RPLACD,)J
66 311 :M
.352 .035(and as a result appears between )J
f0_9 sf
.126(S)A
f3_9 sf
.196 .02( and )J
f0_9 sf
.154(B)A
f3_9 sf
.317 .032(.  Furthermore, a cell is)J
66 321 :M
.537 .054(moved only once, because when it is moved it leaves behind a)J
66 331 :M
2.527 .253(forwarding address which prevents it from being moved)J
66 341 :M
2.352 .235(again.  When the pointer )J
f0_9 sf
.873(S)A
f3_9 sf
2.172 .217( reaches a cell, its edges are)J
66 351 :M
1.466 .147(traced\321i.e. the cells they point to are moved, if necessary.)J
66 361 :M
.905 .09(Finally, only cells which have been moved appear between )J
f0_9 sf
(S)S
66 371 :M
f3_9 sf
.862 .086(and )J
f0_9 sf
.435(B)A
f3_9 sf
1.171 .117(.  Therefore, the number of those accessible, unmoved)J
66 381 :M
3.358 .336(cells in fromspace decreases monotonically, eventually)J
66 391 :M
1.407 .141(resulting in no accessible, unmoved cells in fromspace.  At)J
66 401 :M
1.177 .118(this point, the collector is done and can interchange the two)J
66 411 :M
.327(semispaces.)A
82 421 :M
1.867 .187(It should be easy to see why the other list operations)J
66 431 :M
.803 .08(cannot adversely affect the progress of the collector.  A CAR)J
66 441 :M
.448 .045(or CDR can move a cell before the collector has traced it.  But)J
66 451 :M
1.256 .126(since moving it increases )J
f0_9 sf
.49(B)A
f3_9 sf
.68 .068( but not )J
f0_9 sf
.401(S)A
f3_9 sf
.965 .097(, it will be traced later.)J
66 461 :M
.912 .091(RPLACA and RPLACD can affect connectivity, but since all)J
66 471 :M
1.249 .125(of their arguments are already in tospace, they have already)J
66 481 :M
.788 .079(been moved and may or may not have been traced.  Consider)J
66 491 :M
.261(RPLACA\()A
f0_9 sf
.214(p)A
f3_9 sf
.107(,)A
f0_9 sf
.214(q)A
f3_9 sf
.485 .049(\).  Suppose that )J
f0_9 sf
.214(p)A
f3_9 sf
.503 .05( has been traced and )J
f0_9 sf
.214(q)A
f3_9 sf
.513 .051( has not.)J
66 501 :M
.444 .044(But since )J
f0_9 sf
.167(q)A
f3_9 sf
.457 .046( has been moved but not traced, it must be between)J
66 511 :M
f0_9 sf
.322(S)A
f3_9 sf
.5 .05( and )J
f0_9 sf
.393(B)A
f3_9 sf
.838 .084( and will not be missed.  Suppose, on the other hand,)J
66 521 :M
.804 .08(that )J
f0_9 sf
.345(q)A
f3_9 sf
.812 .081( has been traced and )J
f0_9 sf
.345(p)A
f3_9 sf
.731 .073( has not.  Then when )J
f0_9 sf
.345(p)A
f3_9 sf
.887 .089( is traced,)J
66 531 :M
1.547 .155(the old CAR of )J
f0_9 sf
.666(p)A
f3_9 sf
1.459 .146( will not be traced.  But this is all right,)J
66 541 :M
.697 .07(because it may no longer be accessible.  If it still is the target)J
66 551 :M
1.375 .137(of an edge from some accessible cell, then it either already)J
66 561 :M
1.481 .148(has, or will be, traced through that edge.  Finally, if either)J
66 571 :M
.813 .081(both )J
f0_9 sf
.301(p)A
f3_9 sf
.467 .047( and )J
f0_9 sf
.301(q)A
f3_9 sf
.784 .078( have been traced or both have not been, there is)J
66 581 :M
1.69 .169(obviously no problem.)J
82 591 :M
.677 .068(This algorithm can also be proved correct by the methods)J
66 601 :M
2.427 .243(of DL [16,17,23,24], because this particular sequence of)J
66 611 :M
1.014 .101(interleaving collection with mutation is only one of the legal)J
66 621 :M
.711 .071(execution sequences of the DL algorithm on a serial machine.)J
66 631 :M
.935 .094(Therefore, if the DL algorithm is correct, then so is this one.)J
66 641 :M
2.243 .224(The correspondence is this: )J
f0_9 sf
.589(white)A
f3_9 sf
2.03 .203( nodes are those which)J
66 651 :M
2.506 .251(reside in fromspace, i.e. those which have not yet been)J
66 661 :M
.579 .058(moved; )J
f0_9 sf
.134(grey)A
f3_9 sf
.446 .045( nodes are those which have been moved but have)J
66 671 :M
1.633 .163(not yet been traced, i.e. those between )J
f0_9 sf
.58(S)A
f3_9 sf
.901 .09( and )J
f0_9 sf
.708(B)A
f3_9 sf
.99 .099(; and )J
f0_9 sf
.628(black)A
66 681 :M
f3_9 sf
.623 .062(nodes are those which have been moved and traced, and those)J
66 691 :M
1.107 .111(which have been allocated directly in tospace \(cells below )J
f0_9 sf
(S)S
66 701 :M
f3_9 sf
.568 .057(or above )J
f0_9 sf
.246(T)A
f3_9 sf
.606 .061(\).  Then the assertions are:)J
313 116 :M
.782 .078(A\) each node will only darken monotonically;)J
313 126 :M
.414 .041(B\) no edge will ever point from a black node to a white one;)J
313 136 :M
(and)S
313 146 :M
.581 .058(C\) the user program sees only grey or black nodes.)J
329 161 :M
1.526 .153(We can now see why the burden is on CAR and CDR)J
313 171 :M
.445 .045(rather than RPLACA and RPLACD\321the latter will not violate)J
313 181 :M
1.846 .185(B so long as the former does not violate C.  Using these)J
313 191 :M
.858 .086(assertions, we see that the mutator and the mark phase of the)J
313 201 :M
3.292 .329(collector are essentially doing the same thing: tracing)J
313 211 :M
1.92 .192(accessible cells.  The difference is that the collector goes)J
313 221 :M
1.274 .127(about it systematically whereas the mutator wanders.  Thus,)J
313 231 :M
2.602 .26(only the collector knows for sure when all the cells in)J
313 241 :M
.605 .06(fromspace have been traced so that the two semispaces can be)J
313 251 :M
2.01 .201(interchanged.  Assertion C also allows CAR and CDR to)J
313 261 :M
1.188 .119(update a cell in which a pointer to fromspace is found, thus)J
313 271 :M
1.564 .156(reducing pointer-chasing for cells which are accessed more)J
313 281 :M
1.587 .159(than once.)J
329 291 :M
2.919 .292(We must now analyze the storage required by this)J
313 301 :M
.895 .09(algorithm.  Suppose that at some flip of the semispaces there)J
313 311 :M
.941 .094(are )J
f0_9 sf
.597(N)A
f3_9 sf
1.245 .124( accessible nodes.  Then the collector will not have to)J
313 321 :M
1.863 .186(move or trace any more than )J
f0_9 sf
.933(N)A
f3_9 sf
1.612 .161( cells.  If it traces \(makes)J
313 331 :M
.993 .099(black\) exactly )J
f0_9 sf
.262(k)A
f3_9 sf
.862 .086( cells per CONS, then when the collector has)J
313 341 :M
1.656 .166(finished, the new semispace will contain )J
cF
f1_9 sf
1.656 .166<A3>J
sf
f0_9 sf
.662(N)A
f3_9 sf
.56(+)A
f0_9 sf
.662(N)A
f3_9 sf
.276(/)A
f0_9 sf
.441(k)A
f3_9 sf
.56(=)A
f0_9 sf
.662(N)A
f3_9 sf
.462(\(1+)A
f0_9 sf
.717(m)A
f3_9 sf
<29>S
313 351 :M
1.326 .133(cells, letting )J
f0_9 sf
.652(m)A
f3_9 sf
.404(=1/)A
f0_9 sf
.401(k)A
f3_9 sf
.654 .065(.  If only )J
f0_9 sf
.603(N)A
f3_9 sf
1.157 .116( of these are accessible, as in)J
313 361 :M
1.606 .161(equilibrium conditions, then the next cycle of the collector)J
313 371 :M
1.756 .176(will copy those )J
f0_9 sf
.847(N)A
f3_9 sf
1.808 .181( cells back to the first semispace, while)J
313 381 :M
.491 .049(performing )J
f0_9 sf
.151(Nm)A
f3_9 sf
.343 .034( CONSES.  Hence, we have the inequality:)J
313 396 :M
.206 .021(Maximum SRT Storage Required )J
cF
f1_9 sf
.021<A3>A
sf
.206 .021( )J
f0_9 sf
.077(N)A
f3_9 sf
.055(\(2+2)A
f0_9 sf
.083(m)A
f3_9 sf
.067 .007(\) = )J
f0_9 sf
.077(N)A
f3_9 sf
.05(\(2+2/)A
f0_9 sf
.051(k)A
f3_9 sf
<29>S
329 411 :M
2.253 .225(Therefore, for a program which has a maximum cell)J
313 421 :M
.964 .096(requirement of )J
f0_9 sf
.365(N)A
f3_9 sf
.851 .085( cells operating on a fixed-size real memory)J
313 431 :M
.681 .068(of 2)J
f0_9 sf
.501(M)A
f3_9 sf
.806 .081( cells, the parameter )J
f0_9 sf
.267(k)A
f3_9 sf
.722 .072( must be greater than )J
f0_9 sf
.402(N)A
f3_9 sf
.184(/\()A
f0_9 sf
.501(M)A
f3_9 sf
.2(-)A
f0_9 sf
.402(N)A
f3_9 sf
.63 .063(\) to)J
313 441 :M
.827 .083(guarantee that tracing is finished before every flip.)J
329 451 :M
.424 .042(If we compare the bound for our algorithm with the bound)J
313 461 :M
1.629 .163(for MKSMW, using the unlikely assumption that sweeping)J
313 471 :M
1.69 .169(and relocation take no time \()J
f0_9 sf
.453(s)A
f3_9 sf
.657(=)A
f0_9 sf
.453(r)A
f3_9 sf
1.57 .157(=0\), we find that they are)J
313 481 :M
.753 .075(quite similar in storage requirements.)J
313 496 :M
.133 .013(Maximum MKSMW Storage Required < )J
f0_9 sf
(N)S
f3_9 sf
.029(\(1.5+2)A
f0_9 sf
(m)S
f3_9 sf
<29>S
313 516 :M
.076 .008(Maximum SRT Storage Required )J
cF
f1_9 sf
.008<A3>A
sf
.076 .008( )J
f0_9 sf
(N)S
f3_9 sf
.02(\(2+2)A
f0_9 sf
(m)S
f3_9 sf
<29>S
329 531 :M
.488 .049(If )J
f0_9 sf
.5(m)A
f3_9 sf
1.189 .119(=1 \(which corresponds to one collector iteration per)J
313 541 :M
1 .1(CONS\), the two algorithms differ by only 1 part in 8, which)J
313 551 :M
1.659 .166(is insignificant given the gross assumptions we have made)J
313 561 :M
1.341 .134(about MKSMW's sweeping and relocation speeds.  It is not)J
313 571 :M
2.754 .275(likely that the storage requirements of a MKSMW-type)J
313 581 :M
1.931 .193(algorithm can be significantly improved because it cannot)J
313 591 :M
.661 .066(take advantage of techniques such as stack threading or CDR-)J
313 601 :M
1.239 .124(coding.  Stack threading cannot be done, because accessible)J
313 613 :M
.833 .083(cells have both their car and cdr in use.)J
0 -3 rm
.322(4)A
0 3 rm
1.101 .11(  CDR-coding using)J
313 623 :M
.975 .097(MKSMW is very awkward because CONS must )J
f0_9 sf
.243(search)A
f3_9 sf
.461 .046( for a)J
313 633 :M
1.445 .145(free cell of the proper size and location before allocating a)J
313 643 :M
1.183 .118(cell, since the free space is fragmented.  On the other hand,)J
313 653 :M
.906 .091(our algorithm can be easily modified to use CDR-coding and)J
313 663 :M
3.846 .385(thereby reduce storage requirements to approximately)J
313 673 :M
f0_9 sf
.334(N)A
f3_9 sf
.233(\(1+)A
f0_9 sf
.361(m)A
f3_9 sf
.291(\).)A
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
329 689.24 -.24 .24 472.24 689 .24 329 689 @a
329 701 :M
.595(4)A
0 3 rm
3.173 .317(The Deutsch-Schorr-Waite collector [22,p.417-418])J
0 -3 rm
313 714 :M
.944 .094("threads" the stack but temporarily reverses the list structure,)J
313 724 :M
.699 .07(thus locking out the mutator for the duration.)J
endp
%%Page: 6 6
%%BeginPageSetup
initializepage
(Henry Baker; page: 6 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
66 44 :M
f0_9 sf
1.528 .153(Communications of the ACM)J
f3_9 sf
.164 .016( )J
f4_9 sf
.361(21)A
f3_9 sf
1.151 .115(, 4 \(April 1978\), 280-294.)J
312 754 :M
(6)S
66 76 :M
f4_9 sf
2.706 .271(3.  The Parameter )J
f6_9 sf
1.532(m)A
f4_9 sf
1.652 .165( \(= 1/)J
f6_9 sf
.985(k)A
f4_9 sf
<29>S
82 91 :M
f3_9 sf
.93 .093(If )J
f0_9 sf
.586(k)A
f3_9 sf
1.744 .174( is a positive integer, then the parameter )J
f0_9 sf
.954(m)A
f3_9 sf
1.695 .169( \(=1/)J
f0_9 sf
.586(k)A
f3_9 sf
<29>S
66 101 :M
1.015 .102(will lie in the interval 0<)J
f0_9 sf
.569(m)A
f3_9 sf
cF
f1_9 sf
.106<A3>A
sf
1.065 .106(1.  Therefore, the factor of 1+)J
f0_9 sf
(m)S
66 111 :M
f3_9 sf
.77 .077(in our bounds must lie between 1 and 2.  This means that the)J
66 121 :M
2.45 .245(storage requirements for our method can be adjusted by)J
66 131 :M
.884 .088(varying )J
f0_9 sf
.214(k)A
f3_9 sf
.548 .055(, but they will not vary by more than a factor of 2 as)J
66 141 :M
1.566 .157(long as )J
f0_9 sf
.626(k)A
f3_9 sf
1.818 .182( is integral.  Now, the time to execute CONS is)J
66 151 :M
1.034 .103(proportional to )J
f0_9 sf
.266(k)A
f3_9 sf
.337(+)A
f0_9 sf
.266(c)A
f3_9 sf
.849 .085(, for some suitable constant )J
f0_9 sf
.266(c)A
f3_9 sf
.923 .092(.  Therefore,)J
66 161 :M
1.463 .146(one can trade off storage for CONS speed, but only within)J
66 171 :M
2.556 .256(this limited range.  Furthermore, as )J
f0_9 sf
.768(k)A
f3_9 sf
2.107 .211( rises above 4 the)J
66 181 :M
2.102 .21(storage savings become insignificant; e.g. doubling )J
f0_9 sf
.503(k)A
f3_9 sf
.839 .084( to 8)J
66 191 :M
2.003 .2(yields a storage savings of only 10%, yet almost doubles)J
66 201 :M
.428 .043(CONS time.  Of course, if storage is limited and response time)J
66 211 :M
.66 .066(need not be fast, larger )J
f0_9 sf
.234(k)A
f3_9 sf
.92 .092('s might be acceptable.)J
82 221 :M
2.072 .207(If the method is used for the management of a large)J
66 231 :M
1.772 .177(database residing on secondary storage, )J
f0_9 sf
.44(k)A
f3_9 sf
1.22 .122( could be made a)J
66 241 :M
1.82 .182(positive rational number less than 1, on the average.  For)J
66 251 :M
.921 .092(example, to achieve an average )J
f0_9 sf
.259(k)A
f3_9 sf
.885 .089(=1/3 \()J
f0_9 sf
.422(m)A
f3_9 sf
.968 .097(=3\), one could have)J
66 261 :M
1.239 .124(CONS perform an iteration of the collector only every third)J
66 271 :M
.482 .048(time it was called.  The result of this would double the storage)J
66 281 :M
.225 .022(required \()J
f0_9 sf
.083(m)A
f3_9 sf
.189 .019(+1=4\), but would reduce the average CONS time by)J
66 291 :M
1.209 .121(almost 2/3.  Of course, the worst case time performance for)J
66 301 :M
.33 .033(CONS would still be the same as though )J
f0_9 sf
.106(k)A
f3_9 sf
.282 .028( were 1.)J
82 311 :M
1.821 .182(This improvement is significant because each iteration)J
66 321 :M
1.565 .156(of the collector traces all the pointers of one record.  This)J
66 331 :M
1.019 .102(requires retrieving that record, updating all of its pointers by)J
66 341 :M
.624 .062(moving records if necessary, and then rewriting the record.  If)J
66 351 :M
1.134 .113(there are )J
f0_9 sf
.254(t)A
f3_9 sf
1.178 .118( pointers to be updated, then )J
f0_9 sf
.254(t)A
f3_9 sf
1.489 .149(+1 records must be)J
66 361 :M
1.632 .163(read and written.  This sounds like a lot of work, but this)J
66 371 :M
.701 .07(much work is done only when a record is created; if there are)J
66 381 :M
2.437 .244(no record creations, then with the exception of the first)J
66 391 :M
1.06 .106(access of a record via a pointer stored in another record, the)J
66 401 :M
1.629 .163(accessing and updating functions will be as fast as on any)J
66 411 :M
1.497 .15(other file management scheme.  Therefore, since secondary)J
66 421 :M
2.185 .218(storage is usually cheap but slow, choosing )J
f0_9 sf
.63(k)A
f3_9 sf
1.512 .151(<1 in a file)J
66 431 :M
2.337 .234(management system allows us to trade off storage space)J
66 441 :M
.833 .083(against average record creation time.)J
82 451 :M
.847 .085(With a little more effort, )J
f0_9 sf
.288(k)A
f3_9 sf
.728 .073( can even be made )J
f0_9 sf
.27(variable)A
f3_9 sf
.556 .056( in)J
66 461 :M
3.66 .366(our method, thus allowing a program to dynamically)J
66 471 :M
1.057 .106(optimize its space-time tradeoff.  For example, in a database)J
66 481 :M
2.524 .252(management system a program might set )J
f0_9 sf
.659(k)A
f3_9 sf
2.451 .245(=0 during an)J
66 491 :M
2.557 .256(initial load of the database because it knows that, even)J
313 68 :M
1.055 .105(though there are many records being created, none are being)J
313 78 :M
1.583 .158(let go, and therefore the continual copying of the collector)J
313 88 :M
1.683 .168(will achieve no compaction.  The function READ in LISP)J
313 98 :M
.761 .076(might want to exercise the same prerogative and for the same)J
313 108 :M
1.017 .102(reason.  Of course, any reduction of )J
f0_9 sf
.332(k)A
f3_9 sf
1.07 .107( should not take effect)J
313 118 :M
.905 .09(until the next flip to avoid overflowing storage before then.)J
313 136 :M
f4_9 sf
2.677 .268(4.  A User Program Stack)J
329 151 :M
f3_9 sf
1.636 .164(If the user program utilizes its own stack as well as a)J
313 161 :M
2.457 .246(bank of registers, the stack may \(in theory\) grow to an)J
313 171 :M
.736 .074(unbounded size and therefore cannot be wholly updated when)J
313 181 :M
.751 .075(the semispaces are flipped and still preserve a constant bound)J
313 191 :M
.807 .081(on the time for CONS.  This problem may be trivially solved)J
313 203 :M
3.587 .359(by simulating the stack in the heap \(i.e. PUSH\()J
f0_9 sf
1.074(x)A
f3_9 sf
1.175 .117(\) )J
f1_9 sf
<BA>S
313 216 :M
f3_9 sf
.207(CONS\()A
f0_9 sf
.153(x)A
f3_9 sf
.086(,)A
f0_9 sf
.142(stack)A
f3_9 sf
.414 .041(\) and POP\(\) )J
f1_9 sf
.19<BA>A
f3_9 sf
.608 .061( CDR\()J
f0_9 sf
.142(stack)A
f3_9 sf
.582 .058(\)\); this simulation will)J
313 227 :M
3.472 .347(satisfy the bounded-time constraints of classical stack)J
313 237 :M
1.313 .131(manipulation.  However, this simulation has the unfortunate)J
313 247 :M
2.488 .249(property that accessing items on the stack requires time)J
313 257 :M
1.049 .105(proportional to their distance from the top.)J
329 267 :M
1.975 .198(In order to maintain constant access time to elements)J
313 277 :M
3.69 .369(deep in the stack, we keep stack-like allocation and)J
313 287 :M
.944 .094(deallocation strategies but perform the tracing of the stack in)J
313 297 :M
2.18 .218(an incremental manner.  We first fix the stack accessing)J
313 307 :M
2.402 .24(routines so that the user program never sees pointers in)J
313 317 :M
.58 .058(fromspace.  This change requires that the MOVE routine must)J
313 327 :M
.878 .088(be applied to any pointers which are picked up from the user)J
313 337 :M
1.529 .153(stack.  We must then change CONS to save the user stack)J
313 347 :M
2.057 .206(pointer when the semispaces are flipped so that it knows)J
313 357 :M
.936 .094(which stack locations must be traced.  Finally, the user stack)J
313 367 :M
1.699 .17(POP routine must keep this saved pointer current to avoid)J
313 377 :M
.771 .077(tracing locations which are no longer on the user stack [28].)J
329 387 :M
3.885 .389(The only remaining question is how many stack)J
313 397 :M
.953 .095(locations are to be traced at every CONS.  To guarantee that)J
313 407 :M
1.467 .147(stack tracing will be finished before the next flip, we must)J
313 417 :M
3.031 .303(choose the stack tracing ratio )J
f0_9 sf
1.439 .144(k' )J
f3_9 sf
3.468 .347(\(the number of stack)J
313 427 :M
1.098 .11(locations traced per CONS\) so that the ratio )J
f0_9 sf
.254(k')A
f3_9 sf
.215(/)A
f0_9 sf
.343(k)A
f3_9 sf
.884 .088( is the same)J
313 437 :M
.755 .076(as the ratio of stack locations in use to cons cells in use.  We)J
313 447 :M
2.001 .2(recompute )J
f0_9 sf
.294(k')A
f3_9 sf
1.187 .119( at each flip, because the "in use" statistics are)J
313 457 :M
.784 .078(available then.  Due to this computation, a constant bound on)J
313 467 :M
1.577 .158(the time for CONS exists only if the ratio of stack size to)J
313 477 :M
.795 .079(heap size is bounded, and it is proportional to that ratio.)J
64 498 -1 1 548 497 1 64 497 @a
66 511 :M
.377 .038(% Serial Real-Time System with User Stack.)J
66 521 :M
.409 .041(% The user stack resides in the array "ustk" and grows upward from "ustk[0]".  The global variable )J
f0_9 sf
.159(SP)A
f3_9 sf
.369 .037( is the user stack pointer)J
66 531 :M
.59 .059(% and points to the current top of the user stack.  The global variable )J
f0_9 sf
.235(SS)A
f3_9 sf
.631 .063( scans the user stack and points to the highest stack)J
66 541 :M
.606 .061(% level which has not yet been traced by the collector.)J
66 551 :M
f8_9 sf
-.399(integer )A
f9_9 sf
-.399(SP)A
f8_9 sf
-.449( init\(0\);)A
309 551 :M
f3_9 sf
.707 .071(% User stack pointer.)J
66 561 :M
f8_9 sf
-.399(integer )A
f9_9 sf
-.399(SS)A
f8_9 sf
-.449( init\(0\);)A
309 561 :M
f3_9 sf
.51 .051(% User stack scanner.)J
66 573 :M
f8_9 sf
-.381(procedure USER_PUSH\()A
f9_9 sf
-.381(x)A
f8_9 sf
-.381(\) )A
f1_9 sf
<BA>S
309 573 :M
f3_9 sf
.478 .048(% Push )J
f0_9 sf
.175(x)A
f3_9 sf
.556 .056( onto user stack.)J
66 584 :M
f8_9 sf
-.465(  begin)A
309 584 :M
f3_9 sf
.54 .054(% Note: )J
f0_9 sf
.189(x)A
f3_9 sf
.58 .058( will not be in fromspace.)J
66 594 :M
f8_9 sf
-.399(    )A
f9_9 sf
-.399(SP)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(SP)A
f8_9 sf
-.598(+1;)A
66 604 :M
-.399(    ustk[)A
f9_9 sf
-.399(SP)A
f8_9 sf
-.399(]:=)A
f9_9 sf
(x)S
66 614 :M
f8_9 sf
-.478(  end;)A
66 626 :M
-.384(pointer procedure USER_POP\(\) )A
f1_9 sf
<BA>S
309 626 :M
f3_9 sf
.417 .042(% Pop top value from user stack.)J
66 637 :M
f8_9 sf
-.399(  move\(ustk[)A
f9_9 sf
-.399(SP)A
f8_9 sf
-.532(]\) &)A
309 637 :M
f3_9 sf
.508 .051(% Move value if necessary.)J
66 647 :M
f8_9 sf
-.465(  begin)A
66 657 :M
-.399(    )A
f9_9 sf
-.399(SP)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(SP)A
f8_9 sf
-.598(-1;)A
309 657 :M
f3_9 sf
.482 .048(%   then update stack pointer.)J
66 667 :M
f8_9 sf
-.399(    )A
f9_9 sf
-.399(SS)A
f8_9 sf
-.399(:=min\()A
f9_9 sf
-.399(SS)A
f8_9 sf
-.399(,)A
f9_9 sf
-.399(SP)A
f8_9 sf
<29>S
309 667 :M
f3_9 sf
.415 .041(% Keep stack scanner current.)J
66 677 :M
f8_9 sf
-.478(  end;)A
66 689 :M
-.385(pointer procedure USER_GET\()A
f9_9 sf
-.385(n)A
f8_9 sf
-.385(\) )A
f1_9 sf
<BA>S
309 689 :M
f3_9 sf
.4 .04(% Get )J
f0_9 sf
.187(n)A
f3_9 sf
.554 .055(th element from top of stack.)J
66 700 :M
f8_9 sf
-.399(  ustk[)A
f9_9 sf
-.399(SP)A
f8_9 sf
-.399(-)A
f9_9 sf
-.399(n)A
f8_9 sf
-.399(]:=move\(ustk[)A
f9_9 sf
-.399(SP)A
f8_9 sf
-.399(-)A
f9_9 sf
-.399(n)A
f8_9 sf
-.598(]\);)A
309 700 :M
f3_9 sf
.32 .032(% Move and update if necessary.)J
endp
%%Page: 7 7
%%BeginPageSetup
initializepage
(Henry Baker; page: 7 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
66 44 :M
f0_9 sf
1.528 .153(Communications of the ACM)J
f3_9 sf
.164 .016( )J
f4_9 sf
.361(21)A
f3_9 sf
1.151 .115(, 4 \(April 1978\), 280-294.)J
312 754 :M
(7)S
66 70 :M
f8_9 sf
-.384(pointer procedure CONS\()A
f9_9 sf
-.384(x)A
f8_9 sf
-.384(,)A
f9_9 sf
-.384(y)A
f8_9 sf
-.384(\) )A
f1_9 sf
<BA>S
309 70 :M
f3_9 sf
.983 .098(% Collect some, then allocate \()J
f0_9 sf
.283(x)A
f3_9 sf
.159(.)A
f0_9 sf
.283(y)A
f3_9 sf
.372(\).)A
66 81 :M
f8_9 sf
-.465(  begin)A
66 91 :M
-.399(    if )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(=)A
f9_9 sf
(T)S
309 91 :M
f3_9 sf
.316 .032(% Check if free area is empty.)J
66 101 :M
f8_9 sf
-.425(      then begin)A
309 101 :M
f3_9 sf
1.092 .109(% Interchange semispaces.)J
66 111 :M
f8_9 sf
-.399(             if )A
f9_9 sf
-.399(SS)A
f8_9 sf
-.399(>0 or )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399(<)A
f9_9 sf
(B)S
309 111 :M
f3_9 sf
.493 .049(% Check for memory overflow.)J
66 121 :M
f8_9 sf
-.415(               then error;)A
66 131 :M
-.399(             )A
f9_9 sf
-.399(N)A
f8_9 sf
-.449(:=flip\(\);)A
309 131 :M
f3_9 sf
.242 .024(% Set )J
f0_9 sf
.161(N)A
f3_9 sf
.29 .029( to number of cells in use.)J
66 141 :M
f8_9 sf
-.399(             )A
f9_9 sf
-.399(SS)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(SP)A
f8_9 sf
(;)S
309 141 :M
f3_9 sf
.582 .058(% Start stack scan at top of stack.)J
66 151 :M
f8_9 sf
-.399(             )A
f9_9 sf
-.399(k')A
f8_9 sf
-.399(:=ceil\()A
f9_9 sf
-.399(k)A
f8_9 sf
-.399(*)A
f9_9 sf
-.399(SS)A
f8_9 sf
-.399(/)A
f9_9 sf
-.399(N)A
f8_9 sf
-.797(\);)A
309 151 :M
f3_9 sf
.475 .047(% Calculate stack trace effort.)J
66 161 :M
f8_9 sf
-.399(             for )A
f9_9 sf
-.399(i)A
f8_9 sf
-.399(=1 to )A
f9_9 sf
-.797(NR)A
66 171 :M
f8_9 sf
-.399(               do R[)A
f9_9 sf
-.399(i)A
f8_9 sf
-.399(]:=move\(R[)A
f9_9 sf
-.399(i)A
f8_9 sf
-.598(]\);)A
309 171 :M
f3_9 sf
.249 .025(% Update user registers)J
66 181 :M
f8_9 sf
-.399(             )A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(:=move\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(\); )A
f9_9 sf
-.399(y)A
f8_9 sf
-.399(:=move\()A
f9_9 sf
-.399(y)A
f8_9 sf
-.797(\);)A
309 181 :M
f3_9 sf
.075 .007(%   and our arguments.)J
66 191 :M
f8_9 sf
-.427(           end;)A
66 201 :M
-.399(    for )A
f9_9 sf
-.399(i)A
f8_9 sf
-.399(=1 to )A
f9_9 sf
-.399(k')A
f8_9 sf
-.399( while )A
f9_9 sf
-.399(SS)A
f8_9 sf
-.797(>0)A
309 201 :M
f3_9 sf
.351 .035(% Move )J
f0_9 sf
.085(k')A
f3_9 sf
.399 .04( user stack elements and)J
66 211 :M
f8_9 sf
-.429(      do begin)A
309 211 :M
f3_9 sf
.347 .035(%   update scan pointer.)J
66 221 :M
f8_9 sf
-.399(           ustk[)A
f9_9 sf
-.399(SS)A
f8_9 sf
-.399(]:=move\(ustk[)A
f9_9 sf
-.399(SS)A
f8_9 sf
-.598(]\);)A
66 231 :M
-.399(           )A
f9_9 sf
-.399(SS)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(SS)A
f8_9 sf
-.797(-1)A
66 241 :M
-.432(         end;)A
66 251 :M
-.399(    for )A
f9_9 sf
-.399(i)A
f8_9 sf
-.399(=1 to )A
f9_9 sf
-.399(k)A
f8_9 sf
-.399( while )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399(<)A
f9_9 sf
(B)S
309 251 :M
f3_9 sf
.488 .049(% Do )J
f0_9 sf
.212(k)A
f3_9 sf
.66 .066( iterations of gc.)J
66 261 :M
f8_9 sf
-.429(      do begin)A
66 271 :M
-.399(           )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399([0]:=move\()A
f9_9 sf
-.399(S)A
f8_9 sf
-.498([0]\);)A
309 271 :M
f3_9 sf
-.044(% Trace and update car, cdr.)A
66 281 :M
f8_9 sf
-.399(           )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399([1]:=move\()A
f9_9 sf
-.399(S)A
f8_9 sf
-.498([1]\);)A
66 291 :M
-.399(           )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(S)A
f8_9 sf
-.797(+2)A
66 301 :M
-.432(         end;)A
66 311 :M
-.399(    if )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(=)A
f9_9 sf
-.399(T)A
f8_9 sf
-.435( then error;)A
66 321 :M
-.399(    )A
f9_9 sf
-.399(T)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(T)A
f8_9 sf
-.598(-2;)A
309 321 :M
f3_9 sf
.425 .043(% Actually create the cell.)J
66 331 :M
f8_9 sf
-.399(    )A
f9_9 sf
-.399(T)A
f8_9 sf
-.399([0]:=)A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(; )A
f9_9 sf
-.399(T)A
f8_9 sf
-.399([1]:=)A
f9_9 sf
-.399(y)A
f8_9 sf
(;)S
309 331 :M
f3_9 sf
.212 .021(% Install car and cdr.)J
66 341 :M
f8_9 sf
-.399(    )A
f9_9 sf
(T)S
309 341 :M
f3_9 sf
.135 .013(% Return address of new cell.)J
66 351 :M
f8_9 sf
-.478(  end;)A
64 360 -1 1 548 359 1 64 359 @a
82 368 :M
f3_9 sf
.887 .089(The preceding code exhibits these changes.)J
82 378 :M
5.003 .5(The complexity involved in this conversion is)J
66 388 :M
.858 .086(essentially that necessary to make the serial real-time method)J
66 398 :M
.623 .062(work for several different )J
f0_9 sf
.177(spaces)A
f3_9 sf
.468 .047( [27].  In such a system, each)J
66 408 :M
1.037 .104(space is a contiguous area in the address space disjoint from)J
66 418 :M
1.175 .117(the other spaces, and has its own representation conventions)J
66 428 :M
1.499 .15(and allocation \(and deallocation\) strategies.  The system of)J
66 438 :M
.925 .093(this section thus has two spaces, the heap and the user stack,)J
66 448 :M
.791 .079(which must be managed by cooperating routines.)J
66 466 :M
f4_9 sf
4.415 .441(5.  CDR-Coding \(Compact List Representation\))J
82 481 :M
f3_9 sf
3.512 .351(In this section, we discuss the interaction of our)J
66 491 :M
1.439 .144(algorithm with a partial solution to the second big problem)J
66 501 :M
1.02 .102(with list structures: their inefficient use of storage.  Whereas)J
66 511 :M
.926 .093(a list of 5 elements in a language like Fortran or APL would)J
66 521 :M
.903 .09(require only a 5 element array, such a list in LISP requires 5)J
66 531 :M
1.685 .168(cells having two pointers apiece.  So-called "CDR-coding")J
66 541 :M
1.011 .101([12,19] can reduce the storage cost of LISP lists by as much)J
66 551 :M
.545 .054(as 50%.  The idea is simple: memory is divided up into equal-)J
66 561 :M
1.024 .102(sized chunks called )J
f0_9 sf
.461(Q)A
f3_9 sf
.569 .057('s.  Each )J
f0_9 sf
.461(Q)A
f3_9 sf
.725 .073( is big enough to hold 2 bits)J
66 571 :M
.802 .08(plus a pointer )J
f0_9 sf
.317(p)A
f3_9 sf
.683 .068( to another )J
f0_9 sf
.458(Q)A
f3_9 sf
.721 .072(.  The 2 bits are decoded via the)J
66 581 :M
.402(table:)A
66 596 :M
-.055(00\321NORMAL;)A
145 596 :M
.379 .038(CAR of this node is )J
f0_9 sf
.162(p)A
f3_9 sf
.311 .031(; CDR is )J
f0_9 sf
.126(in)A
f3_9 sf
.366 .037( the)J
146 606 :M
1.218 .122(following )J
f0_9 sf
.425(Q)A
f3_9 sf
(.)S
66 616 :M
.085(01\321NIL;)A
145 616 :M
.183 .018(CAR of this rode is )J
f0_9 sf
.08(p)A
f3_9 sf
.215 .022(; CDR is NIL.)J
66 626 :M
-.07(10\321NEXT;)A
145 626 :M
.343 .034(CAR of this node is )J
f0_9 sf
.147(p)A
f3_9 sf
.319 .032(; CDR )J
f0_9 sf
.098(is)A
f3_9 sf
.332 .033( the)J
146 636 :M
1.218 .122(following )J
f0_9 sf
.425(Q)A
f3_9 sf
(.)S
66 646 :M
-.225(11\321EXTENDED;)A
145 646 :M
.663 .066(The cell extension located at )J
f0_9 sf
.227(p)A
f3_9 sf
.609 .061( holds the)J
146 658 :M
.319 .032(car and cdr for this node.)J
0 -3 rm
(5)S
0 3 rm
82 673 :M
.765 .077(CDR-coding can reduce by 50% the storage requirements)J
66 683 :M
1.339 .134(of a group of cells for which CDR is a 1-1 function whose)J
66 693 :M
1.464 .146(range excludes non-nil atoms.  This is a non-trivial saving,)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
82 709.24 -.24 .24 225.24 709 .24 82 709 @a
82 721 :M
.273(5)A
0 3 rm
1.005 .101(These conventions are slightly different from [19].)J
0 -3 rm
313 368 :M
.792 .079(as all "dotless" s-expressions read in by the LISP reader have)J
313 378 :M
1.526 .153(these properties.  In fact, it has been found [12] that, after)J
313 388 :M
1.013 .101(linearization, 98% of the non-NIL cdrs in several large LISP)J
313 398 :M
1.527 .153(programs referred to the following cell.  These savings are)J
313 408 :M
2.47 .247(due to the fact that CDR-coding takes advantage of the)J
313 418 :M
.652 .065(implicit linear ordering of addresses in address space.)J
329 428 :M
1.171 .117(What implications does this coding scheme have for the)J
313 438 :M
2.025 .202(elementary list operations of LISP? Most operations must)J
313 448 :M
2.381 .238(dispatch on the CDR code to compute their results, and)J
313 458 :M
.555 .055(RPLACD needs special handling.  Consider RPLACD\()J
f0_9 sf
.135(p)A
f3_9 sf
.068(,)A
f0_9 sf
.135(q)A
f3_9 sf
.189 .019(\).  If)J
313 468 :M
f0_9 sf
.115(p)A
f3_9 sf
.29 .029( has a CDR code of NIL or NEXT, then it must be changed to)J
313 480 :M
-.003(EXTENDED, and the result of CONS\(CAR\()A
f0_9 sf
(p)S
f3_9 sf
(\),)S
f0_9 sf
(q)S
f3_9 sf
(\) placed in )S
f0_9 sf
(p)S
f3_9 sf
(.)S
0 -3 rm
(6)S
0 3 rm
329 490 :M
2.318 .232(The number of memory references in the elementary)J
313 500 :M
2.484 .248(operations has been minimized by making the following)J
313 510 :M
2.022 .202(policies [20]: 1\) every EXTENDED cell has a NORMAL)J
313 520 :M
.838 .084(extension; 2\) the user program will never see a pointer to the)J
313 530 :M
.827 .083(extension of an EXTENDED cell; and 3\) when COPY copies)J
313 540 :M
.585 .058(an EXTENDED cell, it reconstitutes it without an extension.)J
329 550 :M
1.914 .191(CONS, CAR, CDR, RPLACA, and RPLACD must be)J
313 560 :M
2.146 .215(changed to preserve these assertions, but EQ and ATOM)J
313 570 :M
2.708 .271(require no changes from their non-CDR-coded versions.)J
313 580 :M
.081 .008(Since an EXTENDED cell cannot point to another EXTENDED)J
313 590 :M
2.071 .207(cell, the forwarding of EXTENDED pointers need not be)J
313 600 :M
.709 .071(iterated.  These policies seem to minimize memory references)J
313 610 :M
1.797 .18(because each cell has a constant \(between flips\) canonical)J
313 620 :M
3.378 .338(address, thereby avoiding normalization [30] by every)J
313 630 :M
1.88 .188(primitive list operation.)J
329 640 :M
1.528 .153(CDR-coding requires a compacting, linearizing garbage)J
313 650 :M
1.693 .169(collector if it is to keep allocation simple \(because it uses)J
313 660 :M
2.714 .271(two different cell sizes\) and take full advantage of the)J
313 670 :M
3.607 .361(sequential coding efficiency.  The MFYCA algorithm)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
329 679.24 -.24 .24 472.24 679 .24 329 679 @a
329 691 :M
.426(6)A
0 3 rm
1.321 .132(We note in this context that if RPLACD is commonly)J
0 -3 rm
313 704 :M
4.307 .431(used to destructively reverse a list\321e.g. by LISP's)J
313 714 :M
1.271 .127("NREVERSE"\321the system could also have a "PREVIOUS")J
313 724 :M
.216 .022(CDR-code so that RPLACD need not call CONS so often.)J
endp
%%Page: 8 8
%%BeginPageSetup
initializepage
(Henry Baker; page: 8 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
66 44 :M
f0_9 sf
1.528 .153(Communications of the ACM)J
f3_9 sf
.164 .016( )J
f4_9 sf
.361(21)A
f3_9 sf
1.151 .115(, 4 \(April 1978\), 280-294.)J
312 754 :M
(8)S
66 68 :M
1.013 .101(presented above compacts, but does not linearize cdrs due to)J
66 78 :M
1.251 .125(its breadth-first trace order.  However, the trace order of an)J
66 88 :M
1.586 .159(MFYCA collector can easily be modified at the cost of an)J
66 98 :M
1.181 .118(additional pointer, )J
f0_9 sf
.381(PB)A
f3_9 sf
.203 .02(.  )J
f0_9 sf
.381(PB)A
f3_9 sf
.9 .09( keeps track of the previous value)J
66 108 :M
.975 .098(of )J
f0_9 sf
.715(B)A
f3_9 sf
.891 .089( \(i.e. )J
f0_9 sf
.715(PB)A
f3_9 sf
1.522 .152( points to the last cell copied\), so that tracing)J
66 118 :M
.716 .072(the cdr of the cell at )J
f0_9 sf
.442(PB)A
f3_9 sf
.982 .098( will copy its successor into the next)J
66 128 :M
3.612 .361(consecutive location \()J
f0_9 sf
1.056(B)A
f3_9 sf
2.632 .263(\), thus copying whole lists into)J
66 138 :M
1.624 .162(successive contiguous locations.)J
82 148 :M
2.545 .255(The meaning of the scan pointer )J
f0_9 sf
.89(S)A
f3_9 sf
2.558 .256( is then changed)J
66 158 :M
1.746 .175(slightly so that it points to the next )J
f0_9 sf
.757(word)A
f3_9 sf
2.083 .208( which must be)J
313 68 :M
.821 .082(updated rather than the next )J
f0_9 sf
.205(cell)A
f3_9 sf
.718 .072(.  Finally, the trace routine is)J
313 78 :M
2.12 .212(modified so that tracing the cdr of )J
f0_9 sf
.991(PB)A
f3_9 sf
2.367 .237( has priority over)J
313 88 :M
1.345 .135(tracing the edge at )J
f0_9 sf
.531(S)A
f3_9 sf
1.353 .135( and the condition on the trace loop is)J
313 98 :M
1.587 .159(modified to amortize both the copying effort \(measured by)J
313 108 :M
3.574 .357(movements of )J
f0_9 sf
1.212(B)A
f3_9 sf
3.03 .303(\) and the tracing effort \(measured by)J
313 118 :M
.924 .092(movements of )J
f0_9 sf
.256(S)A
f3_9 sf
.827 .083(\) over all the CONSES.  These modifications)J
313 128 :M
.833 .083(do not result in a depth-first trace order, but they do result in)J
313 138 :M
1.782 .178(cdr-chains being traced to the end, with few interruptions.)J
313 148 :M
2.563 .256(Thus an MFYCA collector can minimize the amount of)J
313 158 :M
.387 .039(memory needed by CDR-coded lists.)J
64 165 -1 1 548 164 1 64 164 @a
66 178 :M
.365 .037(% Serial Real-Time System with CDR-Coding)J
66 188 :M
f8_9 sf
-.399(pointer )A
f9_9 sf
-.399(S)A
f8_9 sf
(;)S
311 188 :M
f3_9 sf
.402 .04(% Next cell whose car needs tracing.)J
66 198 :M
f8_9 sf
-.399(pointer )A
f9_9 sf
-.399(PB)A
f8_9 sf
(;)S
311 198 :M
f3_9 sf
.543 .054(% Pointer to previous value of )J
f0_9 sf
.243(B)A
f3_9 sf
(.)S
66 208 :M
f8_9 sf
-.399(pointer )A
f9_9 sf
-.399(L)A
f8_9 sf
-.399(,)A
f9_9 sf
-.399(H)A
f8_9 sf
(;)S
311 208 :M
f3_9 sf
.574 .057(% Low and high limits of tospace.)J
311 218 :M
.467 .047(% Assertion: )J
f0_9 sf
.158(L)A
f3_9 sf
cF
f1_9 sf
.156<A3>A
sf
f0_9 sf
.142(S)A
f3_9 sf
cF
f1_9 sf
.156<A3>A
sf
f0_9 sf
.173(PB)A
f3_9 sf
cF
f1_9 sf
.156<A3>A
sf
f0_9 sf
.173(B)A
f3_9 sf
cF
f1_9 sf
.156<A3>A
sf
f0_9 sf
.158(T)A
f3_9 sf
cF
f1_9 sf
.156<A3>A
sf
f0_9 sf
.205(H)A
f3_9 sf
(.)S
66 230 :M
f8_9 sf
-.384(pointer procedure CONS\()A
f9_9 sf
-.384(x)A
f8_9 sf
-.384(,)A
f9_9 sf
-.384(y)A
f8_9 sf
-.384(\) )A
f1_9 sf
<BA>S
311 230 :M
f3_9 sf
.318 .032(% Create a new cell in tospace with)J
66 241 :M
f8_9 sf
-.465(  begin)A
311 241 :M
f3_9 sf
.038 .004(%   car of )J
f0_9 sf
(x)S
f3_9 sf
.05 .005( and cdr of )J
f0_9 sf
(y)S
f3_9 sf
(.)S
66 251 :M
f8_9 sf
-.399(    if )A
f9_9 sf
-.399(T)A
f8_9 sf
-.399(-)A
f9_9 sf
-.399(B)A
f8_9 sf
-.797(<2)A
311 251 :M
f3_9 sf
.3 .03(% Flip when free area is exhausted.)J
66 261 :M
f8_9 sf
-.425(      then begin)A
311 261 :M
f3_9 sf
.347 .035(% This part is the same as usual.)J
66 271 :M
f8_9 sf
-.399(             if )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399(<)A
f9_9 sf
-.399(B)A
f8_9 sf
-.435( then error;)A
311 271 :M
f3_9 sf
.98 .098(% Interchance semispaces.)J
66 281 :M
f8_9 sf
-.42(             flip\(\);)A
66 291 :M
-.399(             for )A
f9_9 sf
-.399(i)A
f8_9 sf
-.399(=1 to )A
f9_9 sf
-.797(NR)A
66 301 :M
f8_9 sf
-.399(               do R[)A
f9_9 sf
-.399(i)A
f8_9 sf
-.399(]:=move\(R[)A
f9_9 sf
-.399(i)A
f8_9 sf
-.598(]\);)A
311 301 :M
f3_9 sf
.386 .039(% Update user registers.)J
66 311 :M
f8_9 sf
-.399(             )A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(:=move\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(\); )A
f9_9 sf
-.399(y)A
f8_9 sf
-.399(:=move\()A
f9_9 sf
-.399(y)A
f8_9 sf
<29>S
311 311 :M
f3_9 sf
.2 .02(% Update our arguments.)J
66 321 :M
f8_9 sf
-.427(           end;)A
66 331 :M
-.399(    while \()A
f9_9 sf
-.399(S)A
f8_9 sf
-.399(+)A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(\)/2-)A
f9_9 sf
-.399(L)A
f8_9 sf
-.399( < )A
f9_9 sf
-.399(k)A
f8_9 sf
-.399(*\()A
f9_9 sf
-.399(H)A
f8_9 sf
-.399(-)A
f9_9 sf
-.399(T)A
f8_9 sf
-.399(\) and )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399(<)A
f9_9 sf
(B)S
311 331 :M
f3_9 sf
.034 .003(% Trace and copy a measured amount.)J
66 341 :M
f8_9 sf
-.399(      do if )A
f9_9 sf
-.399(PB)A
f8_9 sf
-.399(<)A
f9_9 sf
(B)S
311 341 :M
f3_9 sf
.808 .081(% Extend current list, if possible.)J
66 351 :M
f8_9 sf
-.399(           then )A
f9_9 sf
-.399(PB)A
f8_9 sf
-.399(:=\()A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(&CDR\()A
f9_9 sf
-.399(PB)A
f8_9 sf
-.598(\)\);)A
311 351 :M
f3_9 sf
.198 .02(% CDR will trace this edge for us.)J
66 361 :M
f8_9 sf
-.419(           else begin)A
66 371 :M
-.399(                  )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399([0]:=move\()A
f9_9 sf
-.399(S)A
f8_9 sf
-.498([0]\);)A
311 371 :M
f3_9 sf
.318 .032(% Update this edge.)J
66 381 :M
f8_9 sf
-.399(                  )A
f9_9 sf
-.399(S)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(S)A
f8_9 sf
-.797(+1)A
311 381 :M
f3_9 sf
.352 .035(% Step )J
f0_9 sf
.153(S)A
f3_9 sf
.426 .043( over this word.)J
66 391 :M
f8_9 sf
-.42(                end;)A
66 401 :M
-.399(    if )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(=)A
f9_9 sf
-.399(T)A
f8_9 sf
-.435( then error;)A
311 401 :M
f3_9 sf
.493 .049(% Check for memory overflow.)J
66 411 :M
f8_9 sf
-.399(    )A
f9_9 sf
-.399(T)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(T)A
f8_9 sf
-.598(-1;)A
311 411 :M
f3_9 sf
.2 .02(% Create new cell at top of free area.)J
66 421 :M
f8_9 sf
-.399(    if )A
f9_9 sf
-.399(y)A
f8_9 sf
-.532(=nil)A
66 431 :M
-.399(      then code\()A
f9_9 sf
-.399(T)A
f8_9 sf
-.456(\):="NIL")A
311 431 :M
f3_9 sf
.33 .033(% If )J
f0_9 sf
.183(y)A
f3_9 sf
.553 .055( is special case,)J
66 441 :M
f8_9 sf
-.399(      else if )A
f9_9 sf
-.399(y)A
f8_9 sf
-.399(=)A
f9_9 sf
-.399(T)A
f8_9 sf
-.797(+1)A
311 441 :M
f3_9 sf
.289 .029(%   then create a short cell)J
66 451 :M
f8_9 sf
-.399(             then code\()A
f9_9 sf
-.399(T)A
f8_9 sf
-.449(\):="NEXT")A
311 451 :M
f3_9 sf
.324 .032(%   with appropriate cdr-code,)J
66 461 :M
f8_9 sf
-.417(             else begin)A
311 461 :M
f3_9 sf
.461 .046(% Otherwise, create a normal cell.)J
66 471 :M
f8_9 sf
-.399(                    if )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(=)A
f9_9 sf
-.399(T)A
f8_9 sf
-.435( then error;)A
311 471 :M
f3_9 sf
.036 .004(% Need more space for the cdr.)J
66 481 :M
f8_9 sf
-.399(                    )A
f9_9 sf
-.399(T)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(T)A
f8_9 sf
-.598(-1;)A
66 491 :M
-.399(                    code\()A
f9_9 sf
-.399(T)A
f8_9 sf
-.435(\):="NORMAL";)A
311 491 :M
f3_9 sf
-.041(% Set in "NORMAL" cdr-code.)A
66 501 :M
f8_9 sf
-.399(                    )A
f9_9 sf
-.399(T)A
f8_9 sf
-.399([1]:=)A
f9_9 sf
(y)S
311 501 :M
f3_9 sf
.227 .023(% Set in the cdr.)J
66 511 :M
f8_9 sf
-.418(                  end;)A
66 521 :M
-.399(    )A
f9_9 sf
-.399(T)A
f8_9 sf
-.399([0]:=)A
f9_9 sf
-.399(x)A
f8_9 sf
(;)S
311 521 :M
f3_9 sf
.308 .031(% Set the car in the new cell.)J
66 531 :M
f8_9 sf
-.399(    )A
f9_9 sf
(T)S
311 531 :M
f3_9 sf
.293 .029(% Return the new cell.)J
66 541 :M
f8_9 sf
-.478(  end;)A
66 553 :M
-.382(pointer procedure CAR\()A
f9_9 sf
-.382(x)A
f8_9 sf
-.382(\) )A
f1_9 sf
<BA>S
311 553 :M
f3_9 sf
.246 .025(% CAR must move cell it uncovered.)J
66 564 :M
f8_9 sf
-.399(  brplaca\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(,move\(bcar\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.532(\)\)\);)A
311 564 :M
f3_9 sf
.318 .032(% Update this edge.)J
66 576 :M
f8_9 sf
-.38(procedure RPLACA\()A
f9_9 sf
-.38(x)A
f8_9 sf
-.38(,)A
f9_9 sf
-.38(y)A
f8_9 sf
-.38(\) )A
f1_9 sf
<BA>S
311 576 :M
f3_9 sf
.354 .035(% )J
f0_9 sf
.174(x)A
f3_9 sf
.158([0]:=)A
f0_9 sf
.174(y)A
f3_9 sf
.582 .058(.  May require subtlety.)J
66 587 :M
f8_9 sf
-.399(  brplaca\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(,)A
f9_9 sf
-.399(y)A
f8_9 sf
-.797(\);)A
66 599 :M
-.383(pointer procedure BCAR\()A
f9_9 sf
-.383(x)A
f8_9 sf
-.383(\) )A
f1_9 sf
<BA>S
311 599 :M
f3_9 sf
.367 .037(% Basic car; dispatch on CDR-code.)J
66 610 :M
f8_9 sf
-.399(  if code\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.435(\)="EXTENDED")A
311 610 :M
f3_9 sf
-.139(% Type "EXTENDED" means)A
66 620 :M
f8_9 sf
-.399(    then \()A
f9_9 sf
-.399(x)A
f8_9 sf
-.465([0]\)[0])A
311 620 :M
f3_9 sf
.14 .014(%   indirect car.)J
66 630 :M
f8_9 sf
-.399(    else )A
f9_9 sf
-.399(x)A
f8_9 sf
-.532([0];)A
311 630 :M
f3_9 sf
.618 .062(% All other types have normal cars.)J
66 642 :M
f8_9 sf
-.385(pointer procedure BRPLACA\()A
f9_9 sf
-.385(p)A
f8_9 sf
-.385(,)A
f9_9 sf
-.385(q)A
f8_9 sf
-.385(\) )A
f1_9 sf
<BA>S
311 642 :M
f3_9 sf
.471 .047(% Basic rplaca; dispatch on CDR-code.)J
66 653 :M
f8_9 sf
-.399(  if code\()A
f9_9 sf
-.399(p)A
f8_9 sf
-.435(\)="EXTENDED")A
311 653 :M
f3_9 sf
.661 .066(% If extended cell, clobber indirectly.)J
66 663 :M
f8_9 sf
-.399(    then \()A
f9_9 sf
-.399(p)A
f8_9 sf
-.399([0]\)[0]:=)A
f9_9 sf
(q)S
66 673 :M
f8_9 sf
-.399(    else )A
f9_9 sf
-.399(p)A
f8_9 sf
-.465([0]:=q;)A
311 673 :M
f3_9 sf
.519 .052(% All others have normal car.)J
66 685 :M
f8_9 sf
-.382(pointer procedure CDR\()A
f9_9 sf
-.382(x)A
f8_9 sf
-.382(\) )A
f1_9 sf
<BA>S
311 685 :M
f3_9 sf
.234 .023(% CDR moves uncovered cell, but updates)J
66 696 :M
f8_9 sf
-.399(  brplacd\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(,move\(bcdr\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.532(\)\)\);)A
311 696 :M
f3_9 sf
.708 .071(%   only if still possible after move.)J
endp
%%Page: 9 9
%%BeginPageSetup
initializepage
(Henry Baker; page: 9 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
66 44 :M
f0_9 sf
1.528 .153(Communications of the ACM)J
f3_9 sf
.164 .016( )J
f4_9 sf
.361(21)A
f3_9 sf
1.151 .115(, 4 \(April 1978\), 280-294.)J
312 754 :M
(9)S
66 70 :M
f8_9 sf
-.38(procedure RPLACD\()A
f9_9 sf
-.38(x)A
f8_9 sf
-.38(,)A
f9_9 sf
-.38(y)A
f8_9 sf
-.38(\) )A
f1_9 sf
<BA>S
311 70 :M
f3_9 sf
.218 .022(% )J
f0_9 sf
.107(x)A
f3_9 sf
.097([1]:=)A
f0_9 sf
.107(y)A
f3_9 sf
.335 .033(.  May require brute force.)J
66 81 :M
f8_9 sf
-.465(  begin)A
66 91 :M
-.399(    if code\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(\)="NIL" or code\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.456(\)="NEXT")A
311 91 :M
f3_9 sf
.211 .021(% Test for screw cases.)J
66 101 :M
f8_9 sf
-.443(      then)A
311 101 :M
f3_9 sf
-.013(% EXTENDED case will fall through.)A
66 111 :M
f8_9 sf
-.399(        begin pointer )A
f9_9 sf
-.399(p)A
f8_9 sf
(;)S
311 111 :M
f3_9 sf
.438 .044(% Extend the cell )J
f0_9 sf
.154(x)A
f3_9 sf
(.)S
66 121 :M
f8_9 sf
-.399(          )A
f9_9 sf
-.399(p)A
f8_9 sf
-.399(:=CONS\(CAR\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.439(\),"DUMMY"\);)A
311 121 :M
f3_9 sf
.109 .011(% Construct guaranteed NORMAL cell.)J
66 131 :M
f8_9 sf
-.399(          )A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(:=move\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(\); )A
f9_9 sf
-.399(y)A
f8_9 sf
-.399(:=move\()A
f9_9 sf
-.399(y)A
f8_9 sf
-.797(\);)A
311 131 :M
f3_9 sf
.233 .023(% Update arguments in case CONS flipped.)J
66 141 :M
f8_9 sf
-.399(          )A
f9_9 sf
-.399(x)A
f8_9 sf
-.399([0]:=)A
f9_9 sf
-.399(p)A
f8_9 sf
(;)S
311 141 :M
f3_9 sf
.237 .024(% Leave forwarding address in old cell.)J
66 151 :M
f8_9 sf
-.399(          code\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.432(\):="EXTENDED")A
311 151 :M
f3_9 sf
.288 .029(% The old cell has now been extended.)J
66 161 :M
f8_9 sf
-.435(        end;)A
66 171 :M
-.399(    brplacd\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(,)A
f9_9 sf
-.399(y)A
f8_9 sf
<29>S
311 171 :M
f3_9 sf
.507 .051(% Finally replace the cdr.)J
66 181 :M
f8_9 sf
-.478(  end;)A
66 193 :M
-.383(pointer procedure BCDR\()A
f9_9 sf
-.383(x)A
f8_9 sf
-.383(\) )A
f1_9 sf
<BA>S
311 193 :M
f3_9 sf
.307 .031(% Basic cdr; dispatch on CDR-code.)J
66 204 :M
f8_9 sf
-.399(  if code\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(\)="NORMAL" then )A
f9_9 sf
-.399(x)A
f8_9 sf
-.598([1])A
311 204 :M
f3_9 sf
-.006(% NORMAL cells have a second word.)A
66 214 :M
f8_9 sf
-.399(  else if code\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.425(\)="NIL" then nil)A
311 214 :M
f3_9 sf
.01 .001(% Interpret NIL CDR-code.)J
66 224 :M
f8_9 sf
-.399(  else if code\()A
f9_9 sf
-.399(x)A
f8_9 sf
-.399(\)="NEXT" then )A
f9_9 sf
-.399(x)A
f8_9 sf
-.797(+1)A
311 224 :M
f3_9 sf
-.038(% Interpret NEXT CDR-code.)A
66 234 :M
f8_9 sf
-.399(  else \()A
f9_9 sf
-.399(x)A
f8_9 sf
-.456([0]\)[1];)A
311 234 :M
f3_9 sf
-.018(% EXTENDED cells point to NORMAL cells.)A
66 246 :M
f8_9 sf
-.385(pointer procedure BRPLACD\()A
f9_9 sf
-.385(p)A
f8_9 sf
-.385(,)A
f9_9 sf
-.385(q)A
f8_9 sf
-.385(\) )A
f1_9 sf
<BA>S
311 246 :M
f3_9 sf
(% Handle easy cases of RPLACD.)S
66 257 :M
f8_9 sf
-.399(  if code\()A
f9_9 sf
-.399(p)A
f8_9 sf
-.435(\)="EXTENDED")A
311 257 :M
f3_9 sf
.167 .017(% We have extended cell;)J
66 267 :M
f8_9 sf
-.399(    then \()A
f9_9 sf
-.399(p)A
f8_9 sf
-.399([0]\)[1]:=)A
f9_9 sf
(q)S
311 267 :M
f3_9 sf
.143 .014(%   clobber the NORMAL indirect.)J
66 277 :M
f8_9 sf
-.399(  else if code\()A
f9_9 sf
-.399(p)A
f8_9 sf
-.443(\)="NORMAL")A
311 277 :M
f3_9 sf
.407 .041(% The easiest case of all.)J
66 287 :M
f8_9 sf
-.399(         then )A
f9_9 sf
-.399(p)A
f8_9 sf
-.399([1]:=)A
f9_9 sf
(q)S
66 297 :M
f8_9 sf
-.399(  else )A
f9_9 sf
-.399(q)A
f8_9 sf
(;)S
311 297 :M
f3_9 sf
.258 .026(% In all cases, return )J
f0_9 sf
.109(q)A
f3_9 sf
.281 .028( as value.)J
66 309 :M
f8_9 sf
-.383(integer procedure SIZE\()A
f9_9 sf
-.383(p)A
f8_9 sf
-.383(\) )A
f1_9 sf
<BA>S
311 309 :M
f3_9 sf
.222 .022(% Find the size of )J
f0_9 sf
.102(p)A
f3_9 sf
.346 .035( from its CDR-code.)J
66 320 :M
f8_9 sf
-.399(  if code\()A
f9_9 sf
-.399(p)A
f8_9 sf
-.443(\)="NORMAL")A
311 320 :M
f3_9 sf
-.111(% "NIL", "NEXT" and "EXTENDED" all have)A
66 330 :M
f8_9 sf
-.422(    then 2 else 1;)A
311 330 :M
f3_9 sf
.229 .023(%   size\()J
f0_9 sf
.129(p)A
f3_9 sf
.142(\)=1.)A
66 342 :M
f8_9 sf
-.383(pointer procedure COPY\()A
f9_9 sf
-.383(p)A
f8_9 sf
-.383(\) )A
f1_9 sf
<BA>S
311 342 :M
f3_9 sf
.389 .039(% Copy the cell )J
f0_9 sf
.163(p)A
f3_9 sf
.512 .051(; append to current)J
66 353 :M
f8_9 sf
-.465(  begin)A
311 353 :M
f3_9 sf
.637 .064(%   train if possible.)J
66 363 :M
f8_9 sf
-.399(    if )A
f9_9 sf
-.399(PB)A
f8_9 sf
-.399(=)A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(-2 and bcdr\()A
f9_9 sf
-.399(PB)A
f8_9 sf
-.399(\)=)A
f9_9 sf
(p)S
311 363 :M
f3_9 sf
.157 .016(% See if we can hop this NEXT train.)J
66 373 :M
f8_9 sf
-.429(    then begin)A
66 383 :M
-.399(           code\()A
f9_9 sf
-.399(PB)A
f8_9 sf
-.443(\):="NEXT";)A
311 383 :M
f3_9 sf
-.006(% Convert NORMAL cell to NEXT cell.)A
66 393 :M
f8_9 sf
-.399(           )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(B)A
f8_9 sf
-.797(-1)A
311 393 :M
f3_9 sf
.49 .049(% Reuse extra space now available.)J
66 403 :M
f8_9 sf
-.432(         end;)A
66 413 :M
-.399(    if bcdr\()A
f9_9 sf
-.399(p)A
f8_9 sf
-.498(\)=nil)A
311 413 :M
f3_9 sf
.376 .038(% Create a NIL cell, if appropriate.)J
66 423 :M
f8_9 sf
-.399(      then code\()A
f9_9 sf
-.399(B)A
f8_9 sf
-.456(\):="NIL")A
66 433 :M
-.399(      else code\()A
f9_9 sf
-.399(B)A
f8_9 sf
-.435(\):="NORMAL";)A
311 433 :M
f3_9 sf
.158 .016(% Otherwise, all cells are NORMAL.)J
66 443 :M
f8_9 sf
-.399(    )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399([0]:=bcar\()A
f9_9 sf
-.399(p)A
f8_9 sf
-.797(\);)A
311 443 :M
f3_9 sf
.395 .04(% Copy over car;)J
66 453 :M
f8_9 sf
-.399(    brplacd\()A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(,bcdr\()A
f9_9 sf
-.399(p)A
f8_9 sf
-.598(\)\);)A
311 453 :M
f3_9 sf
.283 .028(%   and cdr too, if necessary.)J
66 463 :M
f8_9 sf
-.399(    )A
f9_9 sf
-.399(PB)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(B)A
f8_9 sf
(;)S
311 463 :M
f3_9 sf
(% )S
f0_9 sf
(PB)S
f3_9 sf
.006 .001( is end of current NEXT train.)J
66 473 :M
f8_9 sf
-.399(    )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(:=)A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(+size\()A
f9_9 sf
-.399(B)A
f8_9 sf
-.797(\);)A
311 473 :M
f3_9 sf
.372 .037(% Step )J
f0_9 sf
.197(B)A
f3_9 sf
.491 .049( over newly copied cell,)J
66 483 :M
f8_9 sf
-.399(    if )A
f9_9 sf
-.399(B)A
f8_9 sf
-.399(>)A
f9_9 sf
-.399(T)A
f8_9 sf
-.435( then error;)A
311 483 :M
f3_9 sf
.316 .032(%   check for memory overflow,)J
66 493 :M
f8_9 sf
-.399(    )A
f9_9 sf
-.797(PB)A
311 493 :M
f3_9 sf
.333 .033(%   and return pointer to new copy.)J
66 503 :M
f8_9 sf
-.478(  end;)A
66 513 :M
f3_9 sf
.183 .018(% Procedures not redefined here are as before.)J
64 522 -1 1 548 521 1 64 521 @a
82 530 :M
.89 .089(The size of the tospace needed for CDR-coding is \(1+)J
f0_9 sf
.423(m)A
f3_9 sf
<29>S
66 540 :M
.564 .056(times the amount of space actually used in fromspace.  With a)J
66 550 :M
.898 .09(coding efficiency improvement of )J
f0_9 sf
.21(e)A
f3_9 sf
.735 .073( over the classical storage)J
66 560 :M
.961 .096(of LISP cells, and under equilibrium conditions, we have the)J
66 570 :M
.251(inequality:)A
66 585 :M
.074 .007(Maximum SRTC Storage Required )J
cF
f1_9 sf
.007<A3>A
sf
.074 .007( )J
f0_9 sf
(Ne)S
f3_9 sf
.019(\(2+2)A
f0_9 sf
(m)S
f3_9 sf
<29>S
82 600 :M
1.467 .147(Since we have claimed that )J
f0_9 sf
.448(e)A
f3_9 sf
cF
f1_9 sf
.158<BB>A
sf
1.585 .158(.5, we get the following)J
66 610 :M
.314(estimate:)A
66 625 :M
-.007(SRTC Storage Required )A
cF
f1_9 sf
-.007<BB>A
sf
-.007( )A
f0_9 sf
(N)S
f3_9 sf
(\(1+)S
f0_9 sf
(m)S
f3_9 sf
(\) \(!\))S
82 640 :M
3.714 .371(But this latter expression is less than the bound)J
66 650 :M
.368 .037(computed for MKSMW.  Thus, CDR-coding has given us back)J
66 660 :M
.803 .08(the factor of 2 that the copying garbage collector took away.)J
82 670 :M
1.238 .124(The real-time properties of our algorithm have not been)J
66 680 :M
.878 .088(affected in the least by CDR-coding; in fact, good microcode)J
66 690 :M
1.069 .107(might be able to process CDR-coded lists faster than normal)J
66 700 :M
.438 .044(lists since fewer references to main memory are needed.)J
82 710 :M
3.153 .315(CDR-coding is not the final answer to the coding)J
66 720 :M
.812 .081(efficiency problems of list storage, because far more compact)J
313 530 :M
2.238 .224(codes can be devised to store LISP's s-expressions.  For)J
313 540 :M
1.553 .155(example, both the car and cdr of a cell could be coded by)J
313 550 :M
1.836 .184(relative offsets rather than full pointers [12].  However, a)J
313 560 :M
.765 .076(more compact code would represent some cells in so few bits)J
313 570 :M
1.113 .111(that the pointer we need for a forwarding address would not)J
313 580 :M
.818 .082(fit, rendering our scheme unworkable.  Part of the problem is)J
313 590 :M
1.391 .139(inherent in LISP's small cell size; small arrays can perform)J
313 600 :M
.962 .096(much better.)J
313 618 :M
f4_9 sf
2.997 .3(6.  Vectors and Arrays)J
329 633 :M
f3_9 sf
.571 .057(Arrays can be included quite easily into our framework of)J
313 643 :M
1.759 .176(incremental garbage collection by simply enclosing certain)J
313 653 :M
1.056 .106(parts of the collector program in loops which iterate through)J
313 663 :M
.607 .061(all the pointers in the array, not just the first and second.  The)J
313 673 :M
1.181 .118(convergence of the method with regard to storage space can)J
313 683 :M
.543 .054(also be proved and bounds derived.  However, the method can)J
313 693 :M
.495 .05(no longer claim to be )J
f0_9 sf
.166(real-time)A
f3_9 sf
.629 .063( because neither the time taken)J
313 703 :M
.553 .055(by the array allocation function \(ARRAY-CONS\) nor the time)J
313 713 :M
.599 .06(taken by the array element accessing function is bounded by a)J
313 723 :M
.819 .082(constant.  This unbounded behavior has two sources: copying)J
endp
%%Page: 10 10
%%BeginPageSetup
initializepage
(Henry Baker; page: 10 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
66 44 :M
f0_9 sf
1.528 .153(Communications of the ACM)J
f3_9 sf
.164 .016( )J
f4_9 sf
.361(21)A
f3_9 sf
1.151 .115(, 4 \(April 1978\), 280-294.)J
310 754 :M
1(10)A
66 68 :M
3.044 .304(an array and tracing all its pointers both require time)J
66 78 :M
1.538 .154(proportional to the length of the array.  Therefore, if these)J
66 88 :M
2.051 .205(operations are included in a computer as noninterruptable)J
66 98 :M
1.848 .185(primitive instructions, hard interrupt response time bounds)J
66 108 :M
.657 .066(for that computer will not exist.  However, an arbitrary bound)J
66 118 :M
.843 .084(\(say 10\), placed on the size of all arrays by either the system)J
66 128 :M
.539 .054(or the programmer, allows such bounds to be derived.)J
82 138 :M
1.083 .108(A scheme which overcomes some of these problems has)J
66 148 :M
1.193 .119(been devised [31].  In it, each vector is given a special link)J
66 158 :M
1.097 .11(word which holds either a forwarding pointer \(for vectors in)J
66 168 :M
.642 .064(fromspace which have been partially moved\), a backward link)J
66 178 :M
2.012 .201(\(for incomplete vectors in tospace\), or NIL \(for complete)J
66 188 :M
1.056 .106(vectors\).  MOVE no longer copies the whole array, but only)J
66 198 :M
1.284 .128(allocates space and installs the forward and backward links.)J
66 208 :M
1.76 .176(Any reference to an element of a moved but incompletely)J
66 218 :M
.589 .059(updated vector will follow the backward link to the fromspace)J
66 228 :M
1.164 .116(and access the corresponding element there.  When the scan)J
66 238 :M
1.172 .117(pointer in the tospace encounters such a vector, its elements)J
66 248 :M
3.671 .367(are incrementally updated by applying MOVE to the)J
66 258 :M
1.42 .142(corresponding elements of its old self; after the new one is)J
66 268 :M
2.945 .295(complete, its link is set to NIL.  Element accesses to)J
66 278 :M
1.394 .139(incomplete vectors compare the scan pointer to the element)J
66 288 :M
1.479 .148(address; access is made to the old \(new\) vector if the scan)J
66 298 :M
2.404 .24(pointer is less \(greater or equal\).  Tracing and updating)J
66 308 :M
2.403 .24(exactly )J
f0_9 sf
.612(k)A
f3_9 sf
.482<A5>A
f0_9 sf
.689(n)A
f3_9 sf
2.16 .216( vector elements \(not necessarily all from the)J
66 318 :M
1.533 .153(same vector\) upon every allocation of a vector of length )J
f0_9 sf
(n)S
66 328 :M
f3_9 sf
1.424 .142(guarantees convergence.)J
82 338 :M
1.927 .193(Steele's scheme has the following properties: the time)J
66 348 :M
.606 .061(for referencing an element of any cell or vector is bounded by)J
66 358 :M
.78 .078(a constant while the time to allocate a new object of size )J
f0_9 sf
.306(n)A
f3_9 sf
.468 .047( is)J
66 368 :M
.849 .085(bounded by )J
f0_9 sf
.236(c)A
f3_8 sf
0 2 rm
.237(1)A
0 -2 rm
f0_9 sf
.251(kn)A
f3_9 sf
.3(+)A
f0_9 sf
.236(c)A
f3_8 sf
0 2 rm
.237(2)A
0 -2 rm
f3_9 sf
.72 .072(, for some constants )J
f0_9 sf
.236(c)A
f3_8 sf
0 2 rm
.237(1)A
0 -2 rm
f3_9 sf
.414 .041( and )J
f0_9 sf
.236(c)A
f3_8 sf
0 2 rm
.237(2)A
0 -2 rm
f3_9 sf
.565 .057(.  Hence, a)J
66 379 :M
.781 .078(sequence of list and vector operations can be given tight time)J
66 389 :M
.292(bounds.)A
66 407 :M
f4_9 sf
2.89 .289(7.  Hash Tables and Hash Links)J
82 422 :M
f3_9 sf
1.938 .194(Some recent artificial intelligence programs written in)J
66 432 :M
1.969 .197(LISP have found it convenient to associate )J
f0_9 sf
2.958 .296(property lists)J
66 442 :M
f3_9 sf
1.641 .164(with list cells as well as symbolic atoms.  Since few cells)J
66 452 :M
2.681 .268(actually have property lists, it is a waste of storage to)J
66 462 :M
2.086 .209(allocate to every cell a pointer which points to the cell's)J
66 472 :M
1.412 .141(property list.  Therefore, it has been suggested [9] that one)J
66 482 :M
.662 .066(bit be set aside in every cell to indicate whether the cell has a)J
66 492 :M
.823 .082(property list.  If so, the property list can be found by looking)J
66 502 :M
.537 .054(in a hash table, using the )J
f0_9 sf
.205(address)A
f3_9 sf
.48 .048( of the list cell as the key.)J
82 512 :M
1.042 .104(Such a table requires special handling in systems having)J
66 522 :M
1.754 .175(a relocating garbage collector.  Our copying scheme gives)J
66 532 :M
.893 .089(each semispace its own hash table, and when a cell is copied)J
66 542 :M
1.573 .157(over into tospace, its property list pointer is entered in the)J
66 552 :M
.563 .056("to" table under the cell's new address.  Then when the copied)J
66 562 :M
1.928 .193(cell is encountered by the "scan" pointer, its property list)J
66 572 :M
2.121 .212(pointer is updated along with its normal components.  A)J
66 582 :M
1.488 .149("CDR-coding" system with two "scan" pointers should also)J
66 592 :M
2.37 .237(keep a third for tracing property list pointers to prevent)J
66 602 :M
1.19 .119(property lists from destroying chains of "next"-type cells.)J
66 620 :M
f4_9 sf
4.124 .412(8.  Reference Counting)J
82 635 :M
f3_9 sf
1.654 .165(In this section we consider whether reference counting)J
66 645 :M
1.577 .158(can be used as a method of storage reclamation to process)J
66 655 :M
2.374 .237(lists in real time; i.e. we try to answer the question "is)J
66 665 :M
.802 .08(reference counting worth the effort in a real-time system, and)J
66 675 :M
.741 .074(if so, under what conditions?")J
82 685 :M
.726 .073(A classical reference count system [13,34] keeps for each)J
66 695 :M
1.079 .108(cell a count of the number of pointers which point \(refer\) to)J
66 705 :M
.687 .069(that cell; i.e. its in-degree.  This )J
f0_9 sf
1.42 .142(reference count)J
f3_9 sf
.276 .028( \()J
f0_9 sf
.237(refcount)A
f3_9 sf
.546 .055(\) is)J
66 715 :M
1.78 .178(continually updated as pointers to the cell are created and)J
313 68 :M
1.468 .147(destroyed, and when it drops to zero, the cell is reclaimed.)J
313 78 :M
.906 .091(When reclaimed, the refcounts of any daughter cells it points)J
313 88 :M
2.33 .233(to are decremented, and are also reclaimed if zero, in a)J
313 98 :M
.977 .098(recursive manner.)J
329 108 :M
.822 .082(Reference counting appears to be unsuitable for real-time)J
313 118 :M
.767 .077(applications because a potentially unbounded amount of work)J
313 128 :M
.439 .044(must be done when a cell is let go.  However, if a )J
f0_9 sf
.765 .077(free stack)J
f3_9 sf
.303 .03( is)J
313 138 :M
.887 .089(used to keep track of freed objects instead of a )J
f0_9 sf
1.118 .112(free list)J
f3_9 sf
1.013 .101( [34],)J
313 148 :M
1.805 .18(the newly freed cell is simply pushed onto the free stack.)J
313 158 :M
.524 .052(When a cell is needed, it is popped off the stack, the refcounts)J
313 168 :M
.437 .044(of its daughters are decremented, and if zero, the daughters are)J
313 178 :M
.778 .078(pushed back onto the stack.  Then the cell which was popped)J
313 188 :M
1.716 .172(is returned.  In this way, only a bounded amount of work)J
313 198 :M
.716 .072(needs to be done on each allocation.)J
329 208 :M
.868 .087(We now consider the storage requirements of a reference)J
313 218 :M
.649 .065(counting \(RC\) system.  In addition to the memory for )J
f0_9 sf
.306(N)A
f3_9 sf
.669 .067( cells,)J
313 228 :M
1.464 .146(we also need room for )J
f0_9 sf
.765(N)A
f3_9 sf
1.459 .146( refcounts and a stack.  Since the)J
313 238 :M
.632 .063(refcounts can go as high as )J
f0_9 sf
.336(N)A
f3_9 sf
.907 .091(, they require approximately the)J
313 248 :M
.415 .041(same space as a pointer.  So we have:)J
313 263 :M
-.03(Maximum RC Space Required)A
413 273 :M
cF
f1_9 sf
.052<A3>A
sf
.521 .052( 1.5)J
f0_9 sf
.254(N)A
f3_9 sf
.441 .044( + the size of the "free stack")J
329 288 :M
1.086 .109(The worst case stack depth is )J
f0_9 sf
.546(N)A
f3_9 sf
1.274 .127(.  However, whenever a)J
313 298 :M
.899 .09(cell is on the stack, its refcount is zero, so we can thread the)J
313 308 :M
.428 .043(stack through the unused refcounts! So we now have:)J
313 323 :M
.034 .003(Maximum RC Space Required )J
cF
f1_9 sf
.003<A3>A
sf
.034 .003( 1.5 )J
f0_9 sf
(N)S
329 338 :M
f3_9 sf
.876 .088(Reference count systems have the drawback that directed)J
313 348 :M
.705 .07(cycles of pointers cannot be reclaimed.  It has been suggested)J
313 358 :M
1.763 .176([15,22] that refcounts be used as the "primary" method of)J
313 368 :M
2.408 .241(reclamation, using garbage collection \(GC\) as a fallback)J
313 378 :M
1.321 .132(method when that fails.  Since RC will not have to reclaim)J
313 388 :M
.768 .077(everything and since the average refcount is often very small,)J
313 398 :M
.469 .047(it has also been suggested that a truncated refcount \(a bounded)J
313 408 :M
1.411 .141(counter which sticks at its highest value if it overflows\) be)J
313 418 :M
.527 .053(used to save space.)J
329 428 :M
.629 .063(We say that garbage in a combination RC and GC system)J
313 438 :M
1.318 .132(is )J
f0_9 sf
.801(ref-degradable)A
f3_9 sf
2.138 .214( if and only if it can be reclaimed by)J
313 448 :M
1.32 .132(refcounts alone.  Cells whose truncated refcounts are struck)J
313 458 :M
.271 .027(are therefore )J
f0_9 sf
.075(non-ref-degradable)A
f3_9 sf
(.)S
329 468 :M
3.498 .35(What is the effect of a dual system in terms of)J
313 478 :M
.767 .077(performance? Whatever the RC system is able to recycle puts)J
313 488 :M
.989 .099(off flipping that much longer.  By the time a flip happens in)J
313 498 :M
1.359 .136(such a two level system, there is no ref-degradable garbage)J
313 508 :M
.97 .097(left in tospace.  Therefore, the )J
f0_9 sf
.317(turnover)A
f3_9 sf
1.008 .101( of the semispaces is)J
313 518 :M
.21(slowed.)A
329 528 :M
2.211 .221(How much memory does the dual system require? If)J
313 538 :M
.601 .06(truncated refcounts are used, the free stack cannot be threaded)J
313 548 :M
.947 .095(through a cell's refcount because it is not big enough to hold)J
313 558 :M
.916 .092(a pointer.  Therefore, using this method and assuming only a)J
313 568 :M
.389 .039(few bits worth of truncated refcount per cell, we have:)J
313 583 :M
-.06(Maximum SRT + RC Space Required)A
396 593 :M
cF
f1_9 sf
.016<A3>A
sf
.16 .016( )J
f0_9 sf
.161(N)A
f3_9 sf
.114(\(2+2)A
f0_9 sf
.174(m)A
f3_9 sf
.238 .024(\) + RC free stack )J
cF
f1_9 sf
.024<A3>A
sf
.238 .024( )J
f0_9 sf
.161(N)A
f3_9 sf
.106(\(2.5+2)A
f0_9 sf
.174(m)A
f3_9 sf
<29>S
329 608 :M
2.128 .213(So it appears that we have lost something by adding)J
313 618 :M
.705 .071(refcounts \(even tiny ones\), because we still need room for the)J
313 628 :M
1.015 .102(free stack.)J
329 638 :M
1.185 .119(Let us now examine more closely the average timing of)J
313 648 :M
.047 .005(CONS under a pure RC versus a pure SRT system.  The average)J
313 658 :M
2.193 .219(time for CONS under the RC system is the same as the)J
313 668 :M
1.625 .163(maximum time since there is no freedom in the algorithm.)J
313 678 :M
.952 .095(The time for CONS in SRT is )J
f0_9 sf
.34(c)A
f3_8 sf
0 2 rm
.34(1)A
0 -2 rm
f0_9 sf
.34(k)A
f3_9 sf
.354 .035( + )J
f0_9 sf
.34(c)A
f3_8 sf
0 2 rm
.34(2)A
0 -2 rm
f3_9 sf
.872 .087(, where )J
f0_9 sf
.34(c)A
f3_8 sf
0 2 rm
.34(1)A
0 -2 rm
f3_9 sf
.595 .059( and )J
f0_9 sf
.34(c)A
f3_8 sf
0 2 rm
.34(2)A
0 -2 rm
f3_9 sf
.865 .087( are)J
313 689 :M
.636 .064(constants.  Now )J
f0_9 sf
.195(c)A
f3_8 sf
0 2 rm
.195(2)A
0 -2 rm
f3_9 sf
.565 .056( is simply the time to allocate space from a)J
313 700 :M
1.51 .151(contiguous block of free storage.  Certainly incrementing a)J
313 710 :M
2.017 .202(pointer is much less complex than popping a cell from a)J
313 720 :M
1.918 .192(stack, following its pointers, decrementing their refcounts,)J
endp
%%Page: 11 11
%%BeginPageSetup
initializepage
(Henry Baker; page: 11 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
66 44 :M
f0_9 sf
1.528 .153(Communications of the ACM)J
f3_9 sf
.164 .016( )J
f4_9 sf
.361(21)A
f3_9 sf
1.151 .115(, 4 \(April 1978\), 280-294.)J
310 754 :M
1(11)A
66 68 :M
1.012 .101(and if zero, pushing them onto the stack.  Therefore, we can)J
66 80 :M
1.389 .139(choose )J
f0_9 sf
.346(k)A
f3_9 sf
1.326 .133( small enough)J
0 -3 rm
.39(7)A
0 3 rm
1.058 .106( so that the average time to perform)J
66 90 :M
.773 .077(CONS with our SRT method is smaller than the average time)J
66 102 :M
1.03 .103(to perform CONS in an RC system.)J
0 -3 rm
.333(8)A
0 3 rm
.853 .085(  This analysis does not)J
66 112 :M
1.273 .127(even count the additional time needed to keep the refcounts)J
66 122 :M
.959 .096(updated.  Of course, the storage required for our "pure" SRT)J
66 132 :M
.811 .081(system may be many times the storage of the RC system, but)J
66 142 :M
.275 .028(SRT will have a smaller average CONS time.)J
82 152 :M
1.266 .127(Since this seems counterintuitive, or at least reactionary)J
66 162 :M
3.322 .332(\(given the current penchant for recycling\), we give a)J
66 172 :M
2.028 .203(rationale for why it is so.  Reference counting traces the)J
66 182 :M
2.271 .227(garbage cells, while normal garbage collection traces the)J
66 192 :M
1.292 .129(accessible cells.  Once the number of garbage cells exceeds)J
66 202 :M
1.692 .169(the number of accessible cells in a region of storage, it is)J
66 212 :M
2.313 .231(faster to copy the accessible cells out of the region and)J
66 222 :M
1.826 .183(recycle it whole.  When )J
f0_9 sf
.998(m)A
f3_9 sf
2.848 .285(>1, reference counting cannot)J
66 232 :M
1.306 .131(compete timewise with garbage collection because RC must)J
66 242 :M
1.442 .144(trace a cell for every cell allocated while GC traces on the)J
66 252 :M
.645 .064(average only a fraction \(1/)J
f0_9 sf
.296(m)A
f3_9 sf
.521 .052(\) of a cell for every cell allocated.)J
82 262 :M
1.676 .168(On the other hand, if we wish to minimize storage by)J
66 272 :M
1.29 .129(making )J
f0_9 sf
.487(m)A
f3_9 sf
1.15 .115(<1, a dual scheme with truncated refcounts should)J
66 282 :M
.946 .095(reduce the average CONS time over that in the pure scheme.)J
66 292 :M
1.594 .159(However, CDR-coded lists and other variable sized objects)J
66 302 :M
.62 .062(cannot be easily managed with reference counting because the)J
66 312 :M
1.016 .102(object at the top of the free stack is not necessarily the right)J
66 322 :M
.757 .076(size for the current allocation.  Thus, CDR-coding can reduce)J
66 332 :M
1.354 .135(the storage requirement of a "pure" scheme below that of a)J
66 342 :M
1.255 .126("dual" system with the same )J
f0_9 sf
.609(m)A
f3_9 sf
.985 .098(.  But even on a system with)J
66 352 :M
3.284 .328(objects of uniform size, we are skeptical whether the)J
66 362 :M
1.453 .145(increased average efficiency of CONS in the "dual" system)J
66 372 :M
2.336 .234(will offset the increase in )J
f0_9 sf
.781(k)A
f3_9 sf
2.513 .251( needed to keep the storage)J
66 382 :M
1.534 .153(requirements the same as the "pure" system.  We conclude)J
66 392 :M
.894 .089(that, at least on a real memory computer, )J
f0_9 sf
1.83 .183(reference counting)J
66 402 :M
.879 .088(probably is not a good storage management technique unless)J
66 412 :M
.687 .069(one a\) has uniformly sized objects; b\) uses full counts; and c\))J
66 422 :M
.796 .08(guarantees no cycles)J
f3_9 sf
(.)S
82 432 :M
.801 .08(This is not to say that reference counts are not useful.  If)J
66 442 :M
.568 .057(the LISP language were extended with a function to return the)J
66 452 :M
1.692 .169(current refcount of an object, and suitably clean semantics)J
66 462 :M
.926 .093(were associated with this function, then one might be able to)J
66 472 :M
2.038 .204(make use of this information )J
f0_9 sf
2.506 .251(within the user program)J
f3_9 sf
1.174 .117( to)J
66 482 :M
2.378 .238(speed up certain algorithms, such as structure tracing or)J
66 492 :M
1.68 .168(backtracking, )J
f0_9 sf
.777 .078(\207 la)J
f3_9 sf
.996 .1( Bobrow and Wegbreit [8].  This author is)J
66 502 :M
2.149 .215(not aware of any language which makes this information)J
66 512 :M
2.507 .251(available; if it were available, good programmers would)J
66 522 :M
.525 .053(certainly find a use for it.)J
66 540 :M
f4_9 sf
3.743 .374(9.  The Costs of Real-Time List Processing)J
82 555 :M
f3_9 sf
1.174 .117(The amount of storage and time used by a real-time list)J
66 565 :M
2.382 .238(processing system can be compared with that used by a)J
66 575 :M
1.537 .154(classical list processing system using garbage collection on)J
66 585 :M
2.097 .21(tasks not requiring bounded response times.  The storage)J
66 595 :M
1.76 .176(required by a classical noncompacting garbage collector is)J
66 605 :M
f0_9 sf
.364(N)A
f3_9 sf
1.038 .104(\(1+)J
cF
f1_9 sf
.104(m)A
sf
1.038 .104(\), if the system uses the Deutsch-Schorr-Waite \(DSW\))J
66 615 :M
1.473 .147([22,p.417-418] marking algorithm, and )J
f0_9 sf
.482(N)A
f3_9 sf
.904 .09(\(1.5+)J
cF
f1_9 sf
.09(m)A
sf
.904 .09(\) if it uses a)J
66 625 :M
1.409 .141(normal stack, for some positive )J
cF
f1_9 sf
.141(m)A
sf
1.409 .141(.  If CDR-coding is used,)J
66 635 :M
2.883 .288(copying must be done; the storage requirement is then)J
66 645 :M
f0_9 sf
.328(Ne)A
f3_9 sf
1.041 .104(\(2+2)J
cF
f1_9 sf
.104(m)A
sf
1.041 .104(\), where )J
f0_9 sf
.262(e)A
f3_9 sf
.693 .069( is the efficiency of the coding.  Since )J
f0_9 sf
.262(e)A
f3_9 sf
.451 .045( is)J
66 655 :M
1.078 .108(near .5 [12], the requirement is about )J
f0_9 sf
.52(N)A
f3_9 sf
1.312 .131(\(1+)J
cF
f1_9 sf
.131(m)A
sf
1.312 .131(\), so that CDR-)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
82 667.24 -.24 .24 225.24 667 .24 82 667 @a
82 679 :M
.333(7)A
0 3 rm
1.054 .105(Section 3 deals with nonintegral )J
0 -3 rm
f0_9 sf
0 3 rm
.296(k)A
0 -3 rm
f3_9 sf
0 3 rm
.273('s.)A
0 -3 rm
82 691 :M
.882(8)A
0 3 rm
3.241 .324(We can discount the additional time occasionally)J
0 -3 rm
66 704 :M
2.631 .263(required by CAR and CDR in our method because any)J
66 714 :M
.728 .073(relocation and pointer updating done by them is work that we)J
66 724 :M
.36 .036(have charged to CONS, and does not have to be recounted.)J
313 68 :M
2.693 .269(coding requires approximately the same space as DSW.)J
313 78 :M
1.641 .164(Comparing these expressions with those derived earlier for)J
313 88 :M
1.288 .129(our real-time algorithms, we find that )J
f0_9 sf
1.766 .177(processing LISP lists)J
313 98 :M
2.005 .2(in real-time requires no more space than a non-real-time)J
313 108 :M
1.531 .153(system using DSW)J
f3_9 sf
1.209 .121(.  If larger non-uniform-sized objects like)J
313 118 :M
.561 .056(arrays must be managed, real-time capability requires no more)J
313 128 :M
1.237 .124(space than the MFYCA system, since a copying collector is)J
313 138 :M
.412 .041(already assumed.)J
329 148 :M
.595 .06(The )J
f0_9 sf
.212(average)A
f3_9 sf
.738 .074( time requirement for CONS in our real-time)J
313 158 :M
1.789 .179(system is virtually identical to that in a classical MFYCA)J
313 168 :M
2.6 .26(system using the same cell representation and the same)J
313 178 :M
.917 .092(amount of storage.  This is because 1\) a classical system can)J
313 188 :M
.479 .048(do )J
cF
f1_9 sf
.479 .048(m)J
sf
f0_9 sf
.245(N)A
f3_9 sf
.628 .063( CONSES after doing a garbage collection which marks)J
313 198 :M
f0_9 sf
.646(N)A
f3_9 sf
1.537 .154( nodes\321thus giving an average cons/mark ratio of )J
cF
f1_9 sf
.154(m)A
sf
1.537 .154( and)J
313 208 :M
.952 .095(allowing us to identify )J
cF
f1_9 sf
.095(m)A
sf
.952 .095( with )J
f0_9 sf
.516(m)A
f3_9 sf
1.446 .145(\321and 2\) garbage collection)J
313 218 :M
2.201 .22(in our real-time system is almost identical to that in the)J
313 228 :M
1.272 .127(MFYCA system, except that it is done incrementally during)J
313 238 :M
.643 .064(calls to CONS.  In other words, the user program pays for the)J
313 248 :M
1.153 .115(cost of a cell's reclamation at the time the cell is created by)J
313 258 :M
1.045 .105(tracing some other cell.)J
329 268 :M
1.312 .131(CAR and CDR are a bit slower, because they must test)J
313 278 :M
.46 .046(whether the value to be returned is in fromspace.  However, as)J
313 288 :M
1.517 .152(noted above, any cell movement done inside CAR or CDR)J
313 298 :M
1.613 .161(should not be charged to CAR or CDR because it is work)J
313 308 :M
.829 .083(which the collector would otherwise have to do and therefore)J
313 318 :M
1.985 .199(has already been accounted for in our analysis of CONS.)J
313 328 :M
.37 .037(Therefore, CAR and CDR are only slower by the time required)J
313 340 :M
.989 .099(for the semispace test.)J
0 -3 rm
(9)S
0 3 rm
329 350 :M
.175 .018(Since RPLACA, RPLACD, EQ, and ATOM are unchanged)J
313 360 :M
4.227 .423(from their classical versions, their timings are also)J
313 370 :M
.196(unchanged.)A
329 380 :M
2.107 .211(The overhead calculated for our serial system can be)J
313 390 :M
.736 .074(compared to that in the parallel system of [33].  According to)J
313 400 :M
3.092 .309(these calculations, a parallel garbage collector requires)J
313 410 :M
2.194 .219(significantly more total time than a nonparallel collector.)J
313 420 :M
1.18 .118(But this contradiction disappears when it is realized that the)J
313 430 :M
2.875 .287(author's parallel collector continues tracing even in the)J
313 440 :M
1.053 .105(absence of any cell creation activity.  Since our system keys)J
313 450 :M
.942 .094(collector activity to cell creation, the collector effort is about)J
313 460 :M
.753 .075(the same as on a non-real-time system.)J
313 478 :M
f4_9 sf
5.487 .549(10.  Applications)J
313 499 :M
3.512 .351(1\) A Fixed Size, Real Memory Computer.)J
329 509 :M
f3_9 sf
1.423 .142(This application covers the classical 7090 LISP [25] as)J
313 519 :M
.439 .044(well as a LISP for a microcomputer.  We conceive of even 16-)J
313 529 :M
2.635 .264(bit microcomputers utilizing this algorithm for real-time)J
313 539 :M
3.291 .329(process control or simulation tasks.  Each of the list)J
313 549 :M
2.864 .286(processing primitives is intended to run with interrupts)J
313 559 :M
.848 .085(inhibited, so that all interrupt processing can make use of list)J
313 569 :M
1.516 .152(storage for its buffers and other needs.  Multiple processes)J
313 579 :M
1.431 .143(may also use these primitives so long as CONS, CAR, and)J
313 589 :M
.613 .061(CDR are used by one process at a time; i.e. they are protected)J
313 599 :M
1.822 .182(by one system-wide lock.  Of course, the system must be)J
313 609 :M
.64 .064(aware of the registers of every process.)J
329 619 :M
1.59 .159(For these real memory applications, we want to put as)J
313 629 :M
1.359 .136(much of the available storage under the management of the)J
313 639 :M
1.214 .121(algorithm as possible.  Thus, both atoms \(here we mean the)J
313 649 :M
1.336 .134(whole LISP atom-complex, not just the print-name\) and list)J
313 659 :M
.869 .087(nodes are stored in the semispaces.  CDR-coding is usually a)J
313 669 :M
1.068 .107(good idea to save memory, but unless the bit testing is done)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
329 689.24 -.24 .24 472.24 689 .24 329 689 @a
329 701 :M
.345(9)A
0 3 rm
1.239 .124(In Greenblatt's LISP machine [19], the virtual memory)J
0 -3 rm
313 714 :M
.628 .063(map performs the semispace test as an integral part of address)J
313 724 :M
.433(translation.)A
endp
%%Page: 12 12
%%BeginPageSetup
initializepage
(Henry Baker; page: 12 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
66 44 :M
f0_9 sf
1.528 .153(Communications of the ACM)J
f3_9 sf
.164 .016( )J
f4_9 sf
.361(21)A
f3_9 sf
1.151 .115(, 4 \(April 1978\), 280-294.)J
310 754 :M
1(12)A
66 68 :M
.5 .05(in microcode, it may be faster to use normal cells and increase)J
66 78 :M
.853 .085(the parameter )J
f0_9 sf
.225(k)A
f3_9 sf
.682 .068( to keep the storage size small.)J
82 88 :M
.47 .047(The average CONS time is reduced by putting off flipping)J
66 98 :M
1.267 .127(until all of the free space in tospace is exhausted, i.e. )J
f0_9 sf
.61(B)A
f3_9 sf
.563(=)A
f0_9 sf
.555(T)A
f3_9 sf
(.)S
66 108 :M
3.097 .31(Thus, after all moving and tracing is done, i.e. )J
f0_9 sf
1.152(S)A
f3_9 sf
1.299(=)A
f0_9 sf
1.407(B)A
f3_9 sf
(,)S
66 118 :M
.69 .069(allocation is trivial until )J
f0_9 sf
.292(B)A
f3_9 sf
.269(=)A
f0_9 sf
.266(T)A
f3_9 sf
.616 .062(.  As a result, the average CONS)J
66 128 :M
1.735 .173(time in our real-time system is approximately the same as)J
66 138 :M
.949 .095(that in a classical system.  Of course, with a memory size of)J
66 148 :M
.177(2)A
f0_9 sf
.296(M)A
f3_9 sf
.54 .054(, the maximum number of cells that can be safely managed)J
66 158 :M
.996 .1(is still )J
f0_9 sf
.691(Mk)A
f3_9 sf
.331(/\()A
f0_9 sf
.481(k)A
f3_9 sf
.595(+1\).)A
66 174 :M
f4_9 sf
3.427 .343(2\) A Virtual Memory Computer.)J
82 184 :M
f3_9 sf
1.348 .135(The current epitome of this application is Multics LISP)J
66 194 :M
.912 .091(with an address space of 2)J
f3_8 sf
0 -3 rm
.293(36)A
0 3 rm
f3_9 sf
.936 .094( \()J
cF
f1_9 sf
.094<BB>A
sf
.936 .094(10)J
f3_8 sf
0 -3 rm
.293(11)A
0 3 rm
f3_9 sf
1.013 .101(\) 36-bit words, room for)J
66 204 :M
1.261 .126(billions of list cells.  The problem here is not in reclaiming)J
66 214 :M
1.108 .111(cells that are let go, but keeping accessible cells compact so)J
66 224 :M
1.528 .153(that they occupy as few pages of real memory as possible.)J
66 234 :M
1.746 .175(The MFYCA algorithm does this admirably and ours does)J
66 244 :M
.96 .096(almost as well.)J
82 254 :M
3.091 .309(Our scheme is still real-time on a virtual memory)J
66 264 :M
1.592 .159(computer, but the bounds on the elementary list operations)J
66 274 :M
2.831 .283(now have the order of magnitude of secondary storage)J
66 284 :M
.426(operations.)A
82 294 :M
1.929 .193(There are some problems, however.  Unlike MFYCA,)J
66 304 :M
2.446 .245(wherein both semispaces were used only during garbage)J
66 314 :M
1.198 .12(collection, our method requires that they both be active \(i.e.)J
66 324 :M
.912 .091(partially in real memory\) at all times.  This may increase the)J
66 334 :M
.474 .047(average working set size.  A careful analysis needs to be made)J
66 344 :M
1.514 .151(of our algorithm in order to estimate the additional cost of)J
66 354 :M
1.43 .143(incremental garbage collection.  Brief consideration tells us)J
66 364 :M
2.401 .24(that the active address space varies from a minimum of)J
66 374 :M
f0_9 sf
.239(N)A
f3_9 sf
.167(\(1+)A
f0_9 sf
.259(m)A
f3_9 sf
.361 .036(\) just before a flip to )J
f0_9 sf
.239(N)A
f3_9 sf
.17(\(2+2)A
f0_9 sf
.259(m)A
f3_9 sf
.376 .038(\) just after.  Since at a flip)J
66 384 :M
1.778 .178(the user program registers are updated in numerical order,)J
66 394 :M
2.013 .201(relatively constant pointers should be placed in the lower)J
66 404 :M
1.78 .178(numbered registers to keep the trace order of constant list)J
66 414 :M
1.953 .195(structure similar between flips.  If the average size of an)J
66 424 :M
1.093 .109(object is much larger than the size of a pointer, the working)J
66 434 :M
.441 .044(set may also be reduced by storing the forwarding addresses in)J
66 444 :M
.642 .064(a separate table instead of in the old objects in fromspace [7].)J
82 454 :M
2.423 .242(In a virtual memory environment, the active address)J
66 464 :M
1.347 .135(space will automatically expand and contract in response to)J
66 474 :M
.562 .056(changes in the number of accessible cells if 1\) FLIP re-adjusts)J
66 484 :M
1.299 .13(the size of fromspace to \(1+)J
f0_9 sf
.653(m)A
f3_9 sf
1.5 .15(\)[cells in tospace] just before)J
66 494 :M
1.732 .173(interchanging the semispaces; and 2\) flipping occurs when)J
66 504 :M
1.881 .188(tracing finishes rather than when )J
f0_9 sf
.723(B)A
f3_9 sf
1.241 .124( meets )J
f0_9 sf
.658(T)A
f3_9 sf
1.486 .149(.  This policy,)J
66 514 :M
1.542 .154(plus a smaller )J
f0_9 sf
.531(k)A
f3_9 sf
1.839 .184( than a real memory computer would use,)J
66 524 :M
1.649 .165(should give both a fast CONS and a tolerable working set)J
66 534 :M
1.373 .137(size.  The parameter )J
f0_9 sf
.445(k)A
f3_9 sf
1.529 .153( can also be dynamically adjusted to)J
66 544 :M
2.807 .281(optimize either running time \(including paging\) or cost)J
66 554 :M
1.769 .177(according to some pricing policy by following an analysis)J
66 564 :M
.875 .087(similar to that of Hoare and others [2,10,21].)J
66 580 :M
f4_9 sf
4.127 .413(3\) A Database Management System.)J
82 590 :M
f3_9 sf
2.584 .258(We conceive of a huge database having millions of)J
66 600 :M
1.383 .138(records, which may contain pointers to other records, being)J
66 610 :M
.686 .069(managed by our algorithm.  Examples of such databases are a)J
66 620 :M
3.026 .303(bill of materials database for the Apollo Project, or a)J
66 630 :M
1.238 .124(complete semantic dictionary and thesaurus of English for a)J
66 640 :M
2.442 .244(language understanding program.  Performing a classical)J
66 650 :M
1.511 .151(garbage collection on such a databank would be out of the)J
66 660 :M
1.441 .144(question, since it might require days or weeks to complete,)J
66 670 :M
1.277 .128(given current disk technology.)J
82 680 :M
.562 .056(Some of these large database systems currently depend on)J
66 690 :M
.874 .087(reference counts for storage reclamation, and so do not allow)J
66 700 :M
2.488 .249(directed cycles of pointers.  Since our method performs)J
66 710 :M
1.133 .113(general garbage collection, this restriction could be dropped.)J
66 720 :M
1.257 .126(Moreover, given enough space, our algorithm can take even)J
313 68 :M
f0_9 sf
.612 .061(less time)J
f3_9 sf
.514 .051( than a reference count system.  When compared with)J
313 78 :M
1.183 .118(a classical garbage collection system, our method would not)J
313 88 :M
.898 .09(save any )J
f0_9 sf
.257(total)A
f3_9 sf
1.115 .111( time in processing transactions against such a)J
313 98 :M
.81 .081(database, but it would avoid the catastrophic consequences of)J
313 108 :M
.518 .052(a garbage collection during a period of heavy demand.)J
329 118 :M
2.056 .206(This case is very much like case 1, the real memory)J
313 128 :M
1.333 .133(computer, because we assume that the database is orders of)J
313 138 :M
1.308 .131(magnitude too big to fit into primary memory and thus that)J
313 148 :M
.567 .057(there is little hope for a speedup from the locality of reference)J
313 158 :M
.808 .081(effect.  "Read memory" and "store memory" instructions here)J
313 168 :M
2.58 .258(apply to secondary storage; the constant bounds for the)J
313 178 :M
1.393 .139(elementary operations are now on the order of milliseconds)J
313 188 :M
1.19 .119(rather than microseconds.  Therefore, almost everything that)J
313 198 :M
1.635 .163(we say about real memory implementations also applies to)J
313 208 :M
1.171 .117(large database implementations, except that space is cheaper)J
313 218 :M
.293 .029(and time is more dear.)J
313 234 :M
f4_9 sf
3.702 .37(4\) A Totally New Computer Architecture.)J
329 244 :M
f3_9 sf
2.725 .273(We conceive of an architecture in which a CPU is)J
313 254 :M
2.336 .234(connected to a )J
f0_9 sf
3.9 .39(list memory)J
f3_9 sf
2.518 .252( instead of a random access)J
313 264 :M
3.169 .317(memory.  Machines of this architecture are similar to)J
313 274 :M
7.239 .724("linking automata" [22,p.462-463] and "storage)J
313 284 :M
1.582 .158(modification machines" [29].  At the interface between the)J
313 294 :M
.861 .086(CPU and the memory sits a bank of )J
f0_9 sf
1.664 .166(pointer registers)J
f3_9 sf
1.246 .125(, which)J
313 304 :M
1.034 .103(point at particular cells in the list memory.  Instead of a bus)J
313 314 :M
.568 .057(which communicates both addresses and values, with read and)J
313 324 :M
.629 .063(write commands, the memory would have only a data bus and)J
313 334 :M
.615 .062(commands like CAR, CDR, CONS, RPLACA, RPLACD, EQ,)J
313 344 :M
.45 .045(and ATOM, whose arguments and returned values would be in)J
313 354 :M
.922 .092(the pointer registers.  The CPU would not have access to the)J
313 364 :M
1.09 .109(bit strings stored in the pointer registers, except those which)J
313 374 :M
3.372 .337(pointed to atoms \(objects outside both fromspace and)J
313 384 :M
.927 .093(tospace\).  This restriction is necessary to keep the CPU from)J
313 394 :M
1.286 .129(depending upon memory addresses which might be changed)J
313 404 :M
.834 .083(by the management algorithm without the CPU's knowledge.)J
329 414 :M
2.526 .253(An advantage of such a system over random access)J
313 424 :M
1.766 .177(memory is the elimination of the huge address bus that is)J
313 434 :M
1.805 .18(normally needed between the CPU and the memory, since)J
313 444 :M
1.781 .178(addresses are not dealt with directly by the CPU.  As the)J
313 454 :M
1.656 .166(number of bits on a chip increases, the number of address)J
313 464 :M
.908 .091(lines and supporting logic becomes a critical factor.)J
329 474 :M
.65 .065(Our method of garbage collection can also be used with a)J
313 484 :M
1.973 .197(random access )J
f0_9 sf
.47(write-once)A
f3_9 sf
1.787 .179( memory by appending an extra)J
313 494 :M
1.29 .129(word to each cell which holds the forwarding address when)J
313 504 :M
.866 .087(that cell is eventually moved.  Using such a system, the cells)J
313 514 :M
.759 .076(in tospace cannot be updated until they are moved to the new)J
313 524 :M
1.01 .101(tospace after the )J
f0_9 sf
.297(next)A
f3_9 sf
.74 .074( flip.  In other words, )J
f0_9 sf
.293(three)A
f3_9 sf
1.693 .169( semispaces)J
313 534 :M
1.164 .116(need to be active at all times.  In addition to these changes,)J
313 544 :M
.976 .098(RPLACA and RPLACD must actually perform a CONS, just)J
313 554 :M
1.173 .117(like RPLACD occasionally does in our CDR-coding system.)J
313 564 :M
1.614 .161(Perhaps the write-once property can eliminate the need for)J
313 574 :M
1.013 .101(transaction journals and backup tapes.)J
313 592 :M
f4_9 sf
3.396 .34(11.  Conclusions and Future Work)J
329 607 :M
f3_9 sf
.925 .092(We have exhibited a method for doing list processing on)J
313 617 :M
1.173 .117(a serial computer in a real-time environment where the time)J
313 627 :M
2.18 .218(required by all of the elementary list operations must be)J
313 637 :M
.7 .07(bounded by a constant which is independent of the number of)J
313 647 :M
1.081 .108(list cells in use.  This algorithm was made possible through:)J
313 657 :M
1.367 .137(1\) a new proof of correctness of parallel garbage collection)J
313 667 :M
.63 .063(based on the assertion that the user program sees only marked)J
313 677 :M
2.103 .21(cells; 2\) the realization that the collection effort must be)J
313 687 :M
1.443 .144(proportional to new cell creation; and 3\) the belief that the)J
313 697 :M
.95 .095(complex interaction required by these policies makes parallel)J
313 707 :M
1.52 .152(collection unwieldy.  We have also exhibited extensions of)J
313 717 :M
3.102 .31(this algorithm to handle a user program stack, "CDR-)J
endp
%%Page: 13 13
%%BeginPageSetup
initializepage
(Henry Baker; page: 13 of 13)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
66 44 :M
f0_9 sf
1.528 .153(Communications of the ACM)J
f3_9 sf
.164 .016( )J
f4_9 sf
.361(21)A
f3_9 sf
1.151 .115(, 4 \(April 1978\), 280-294.)J
310 754 :M
1(13)A
66 68 :M
2.611 .261(coding," vectors of contiguous words, and hash linking.)J
66 78 :M
3.17 .317(Therefore, we consider our system to be an attractive)J
66 88 :M
3.563 .356(alternative to reference counting for real-time storage)J
66 98 :M
.961 .096(management and have shown that, given enough storage, our)J
66 108 :M
1.886 .189(method will outperform a reference count system, without)J
66 118 :M
1.222 .122(requiring the topological restrictions of that system.)J
82 128 :M
3.755 .376(Our real-time scheme is strikingly similar to the)J
66 138 :M
2.533 .253(incremental garbage collector proposed independently by)J
66 148 :M
1.12 .112(Barbacci for a microcoded LISP machine [3].  However, his)J
66 158 :M
1.087 .109(non-real-time proposal differs in the key points listed above.)J
66 168 :M
3.544 .354(Our system will itself appear in microcoded form in)J
66 178 :M
.821 .082(Greenblatt's LISP machine [19].)J
82 188 :M
1.351 .135(There is still some freedom in our algorithm which has)J
66 198 :M
.775 .078(not been explored.  The )J
f0_9 sf
.262(order)A
f3_9 sf
.715 .072( in which the cells are traced is)J
66 208 :M
2.262 .226(not important for the algorithm's correctness or real-time)J
66 218 :M
.773 .077(properties.  The average properties of the algorithm when run)J
66 228 :M
3.455 .345(on a virtual memory machine need to be extensively)J
66 238 :M
.355(investigated.)A
82 248 :M
.541 .054(The space required by our algorithm may be excessive for)J
66 258 :M
1.203 .12(some applications.  Perhaps a synthesis of the )J
f0_9 sf
.378(area)A
f3_9 sf
1.631 .163( concept)J
66 268 :M
.791 .079([6,7] with our method could reduce the memory requirements)J
66 278 :M
1.917 .192(of a list processing system while preserving the bounded-)J
66 288 :M
1.125 .112(time properties of the elementary operations.)J
82 298 :M
.684 .068(A garbage collection algorithm can be viewed as a means)J
66 308 :M
1.076 .108(for converting a Von Neumann-style random access memory)J
66 318 :M
1.326 .133(\(with "side-effects" [25]\) into a list memory \(without "side-)J
66 328 :M
.728 .073(effects"\).  Perhaps a list memory can be implemented directly)J
66 338 :M
1.587 .159(in hardware which uses considerably less energy by taking)J
66 348 :M
.774 .077(advantage of the lack of side-effects in list operations [4].)J
82 366 :M
f0_9 sf
1.08(Acknowledgments)A
f3_9 sf
2.442 .244(.  I wish to thank the people at)J
66 376 :M
1.012 .101(M.I.T.'s Artificial Intelligence Laboratory and Laboratory for)J
66 386 :M
2.182 .218(Computer Science \(formerly Project MAC\) for their time)J
66 396 :M
2.247 .225(discussing these ideas, and especially Peter Bishop, John)J
66 406 :M
1.706 .171(DeTreville, Richard Greenblatt, Carl Hewitt, Al Mok, Guy)J
66 416 :M
2.488 .249(Steele, and the referees for their copious comments and)J
66 426 :M
.94 .094(helpful suggestions after reading early versions of this paper.)J
66 436 :M
2.451 .245(I also wish to thank John McCarthy for ignoring David)J
66 446 :M
1.116 .112(Hilbert's advice about "leaving elegance to the tailors" when)J
66 456 :M
.339 .034(he created the LISP language.)J
66 469 :M
f3_8 sf
.339 .034(Received September 1976; revised May 1977)J
66 487 :M
f4_9 sf
1.004(References)A
66 497 :M
f3_9 sf
1.633 .163(1.  Arnborg, S.  Storage administration in a virtual memory)J
83 507 :M
.742 .074(SIMULA system.  )J
f0_9 sf
.77 .077(BIT 12)J
f3_9 sf
.872 .087( \(1972\), 125-141.)J
66 517 :M
.599 .06(2.  Arnborg, S.  Optimal memory management in a system with)J
83 527 :M
1.095 .11(garbage collection.  )J
f0_9 sf
1.184 .118(BIT 14)J
f3_9 sf
1.34 .134( \(1974\), 375-381.)J
66 537 :M
3.274 .327(3.  Barbacci, M.  A LISP Processor for C.ai.  Memo)J
83 547 :M
.985 .099(CMU-CS-71-103, Computer  Sci. Dept., Carnegie-Mellon.)J
83 557 :M
1.83 .183(Pittsburgh, Pa., 1971.)J
66 567 :M
1.221 .122(4.  Bennett, C.H.  Logical reversibility of computation.  )J
f0_9 sf
.763(IBM)A
83 577 :M
.704 .07(J.  Res.  Develop.  17)J
f3_9 sf
1.1 .11( \(1973\), 525.)J
66 587 :M
1.263 .126(5.  Birtwistle, G.M., DahI, O.-J., Myhrhaug, B, and Nygaard,)J
83 597 :M
.308 .031(K.  )J
f0_9 sf
1.226 .123(Simula Begin)J
f3_9 sf
.856 .086(.  Auerbach, Philadelphia, Pa., 1973.)J
66 607 :M
1.558 .156(6.  Bishop, P.B.  Garbage collection in a very large address)J
83 617 :M
2.117 .212(space.  Working Paper 111, M.I.T. A.I.  Lab., M.I.T.,)J
83 627 :M
2.126 .213(Sept. 1975.)J
66 637 :M
1.112 .111(7.  Bishop, P.B.  Computer systems with a very large address)J
83 647 :M
1.748 .175(space and garbage collection.  Ph.D. Th., TR-178, MIT)J
83 657 :M
2.087 .209(Lab. for Computer Sci., Cambridge, Mass., May 1977.)J
83 667 :M
.387(Forthcoming.)A
66 677 :M
2.271 .227(8.  Bobrow, D.G.  and Wegbreit, B.  A model and stack)J
83 687 :M
1.55 .155(implementation of multiple environments.  )J
f0_9 sf
2.379 .238(Comm. ACM)J
83 697 :M
.394(16)A
f3_9 sf
1.267 .127(, 10 \(Oct. 1973\), 591-603.)J
66 707 :M
.743 .074(9.  Bobrow, D.G.  A note on hash linking.  )J
f0_9 sf
1.33 .133(Comm. ACM 18)J
f3_9 sf
.548 .055(, 7)J
83 717 :M
1.754 .175(\(July 1975\), 413-415.)J
313 68 :M
.92 .092(10.  Campbell, J.A.  Optimal use of storage in a simple model)J
330 78 :M
1.813 .181(of garbage collection.  )J
f0_9 sf
2.491 .249(Inform. Processing Letters 3)J
f3_9 sf
1.052 .105(, 2)J
330 88 :M
1.649 .165(\(Nov. 1974\), 37-38.)J
313 98 :M
1.38 .138(11.  Cheney, C.J.  A nonrecursive list compacting algorithm.)J
330 108 :M
f0_9 sf
1.444 .144(Comm. ACM 13)J
f3_9 sf
1.178 .118(, 11 \(Nov. 1970\), 677-678.)J
313 118 :M
1.114 .111(12.  Clark, D.W., and Green, C.C.  An empirical study of list)J
330 128 :M
.633 .063(structure in LISP.  )J
f0_9 sf
1.013 .101(Comm. ACM 20)J
f3_9 sf
.727 .073(, 2 \(Feb. 1977\), 78-87.)J
313 138 :M
1.477 .148(13.  Collins, G.E.  A method for overlapping and erasure of)J
330 148 :M
.622 .062(lists.  )J
f0_9 sf
1.42 .142(Comm. ACM 3)J
f3_9 sf
1.414 .141(,12 \(Dec. 1960\), 655-657.)J
313 158 :M
.626 .063(14.  Dahl, 0.-J., and Nygaard, K.  SIMULA\321an ALGOL-based)J
330 168 :M
2.461 .246(simulation language.  )J
f0_9 sf
2.791 .279(Comm. ACM 9)J
f3_9 sf
2.03 .203(, 9 \(Sept. 1966\),)J
330 178 :M
.536(671-678.)A
313 188 :M
3.825 .383(15.  Deutsch, L.P., and Bobrow, D.G.  An efficient,)J
330 198 :M
1.757 .176(incremental, automatic garbage collector.  )J
f0_9 sf
2.776 .278(Comm. ACM)J
330 208 :M
.422(19)A
f3_9 sf
1.334 .133(, 9 \(Sept. 1976\), 522-526.)J
313 218 :M
1.799 .18(16.  Dijkstra, E.W., Lamport, L., Martin, A.J., Scholten, C.)J
330 228 :M
1.962 .196(S., Steffens, E.F.M.  On-the-fly garbage collection: An)J
330 238 :M
2.553 .255(exercise in cooperation.  E.W.Dijkstra note EWD496,)J
330 248 :M
1.582 .158(June 1975.)J
313 258 :M
1.159 .116(17.  Dijkstra, E.W.  After many a sobering experience.  E.W.)J
330 268 :M
.944 .094(Dijkstra note EWD500.)J
313 278 :M
1.862 .186(18.  Fenichel, R.R., and Yochelson, J.C.  A LISP garbage-)J
330 288 :M
1.582 .158(collector for virtual-memory computer systems.  )J
f0_9 sf
.622(Comm.)A
330 298 :M
1.532 .153(ACM 12)J
f3_9 sf
1.203 .12(, 11 \(Nov. 1969\), 611-612.)J
313 308 :M
.826 .083(19.  Greenblatt, R.  LISP Machine Progress Report memo 444.)J
330 318 :M
1.018 .102(A.I. Lab., M.I.T., Cambridge, Mass., Aug. 1977.)J
313 328 :M
.943 .094(20.  Greenblatt, R.  Private communication, Feb. 1977.)J
313 338 :M
1.932 .193(21.  Hoare, C.A.R.  Optimization of store size for garbage)J
330 348 :M
1.965 .197(collection.  )J
f0_9 sf
2.727 .273(Inform. Processing Letters 2)J
f3_9 sf
2.267 .227( \(1974\), 165-)J
330 358 :M
.75(166.)A
313 368 :M
.869 .087(22.  Knuth, D.E.  )J
f0_9 sf
1.452 .145(The Art of Computer Programming, Vol. I:)J
330 378 :M
4.036 .404(Fundamental Algorithms)J
f3_9 sf
2.657 .266(.  Addison-Wesley, Reading,)J
330 388 :M
2.383 .238(Mass., 1968.)J
313 398 :M
1.172 .117(23.  Lamport, L.  Garbage collection with multiple processes:)J
330 408 :M
3.814 .381(An exercise in parallelism.  CA-7602-2511, Mass.)J
330 418 :M
1.103 .11(Computer Associates, Wakefield, Mass., Feb. 1976.)J
313 428 :M
1.673 .167(24.  Lamport, L.  On-the-fly garbage collection: Once more)J
330 438 :M
1.611 .161(with rigor.  CA-7508-1611, Mass. Computer Associates,)J
330 448 :M
1.058 .106(Wakefield, Mass., Aug. 1975.)J
313 458 :M
1.715 .171(25.  McCarthy, J., )J
f0_9 sf
1.586 .159(et al)J
f3_9 sf
.443 .044(.  )J
f0_9 sf
3.018 .302(LISP 1.5 Programmer's Manual)J
f3_9 sf
(.)S
330 468 :M
1.067 .107(M.I.T.  Press, Cambridge, Mass., 1965.)J
313 478 :M
1.143 .114(26.  Minsky, M.L.  A LISP garbage collector algorithm using)J
330 488 :M
2.222 .222(serial secondary storage.  Memo 58, M.I.T. A.I. Lab.,)J
330 498 :M
1.237 .124(M.I.T., Cambridge, Mass., Oct. 1963.)J
313 508 :M
.528 .053(27.  Moon, D.A.  )J
f0_9 sf
1.329 .133(MACLISP Reference Manual)J
f3_9 sf
.721 .072(.  Project MAC,)J
330 518 :M
1.083 .108(M.I.T., Cambridge, Mass., December 1975.)J
313 528 :M
1.809 .181(28.  Muller, K.G.  On the feasibility of concurrent garbage)J
330 538 :M
2.964 .296(collection.  Ph.D. Th., Tech. Hogeschool Delft, The)J
330 548 :M
1.059 .106(Netherlands, March 1976 \(in English\).)J
313 558 :M
1.1 .11(29.  Schonhage, A.  Real-time simulation of multidimensional)J
330 568 :M
3.578 .358(Turing machines by storage modification machines.)J
330 578 :M
2.253 .225(TM-37, Project MAC, M.I.T., Cambridge, Mass., Dec.)J
330 588 :M
.688(1973.)A
313 598 :M
1.534 .153(30.  Steele, G.L. Jr.  Multiprocessing compactifying garbage)J
330 608 :M
1.064 .106(collection.  )J
f0_9 sf
1.513 .151(Comm. ACM 18)J
f3_9 sf
1.183 .118(, 9 \(Sept. 1975\), 495-508.)J
313 618 :M
.721 .072(31.  Steele, G.L.  Jr.  Private communication, March 1977.)J
313 628 :M
1.776 .178(32.  Teitelman, W., )J
f0_9 sf
1.554 .155(et al)J
f3_9 sf
.434 .043(.  )J
f0_9 sf
3.587 .359(INTERLISP Reference Manual)J
f3_9 sf
(.)S
330 638 :M
.77 .077(Xerox Palo Alto Res.  Ctr., Palo Alto, Calif, 1974.)J
313 648 :M
2.313 .231(33.  Wadler, P.L.  Analysis of an algorithm for real-time)J
330 658 :M
2.48 .248(garbage collection.  )J
f0_9 sf
3.156 .316(Comm. ACM 19)J
f3_9 sf
2.186 .219(, 9 \(Sept. 1976\),)J
330 668 :M
.536(491-500.)A
313 678 :M
1.017 .102(34.  Weizenbaum, J.  Symmetric list processor.  )J
f0_9 sf
2.103 .21(Comm. ACM)J
330 688 :M
.418(6)A
f3_9 sf
1.323 .132(, 9 \(Sept. 1963\), 524-544.)J
endp
%%Trailer
end
%%EOF
