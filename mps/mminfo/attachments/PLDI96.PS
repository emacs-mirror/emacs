%!PS-Adobe-3.0
%%Title: Npaper
%%Creator: boehm
%%CreationDate: March 28, 1996 12:32:17 pm PST
%%Pages: 10
%%DocumentFonts: unknown
%%EndComments
%%BeginProlog
% simple procedures (others defined as needed)
/width {stringwidth pop} bind def                   % stack: text
/rgb {setrgbcolor} bind def
/f {fill} bind def
/m {moveto} bind def
/l {lineto} bind def
/s {show} bind def
/v {m l stroke} bind def                            % stack: x y
/gs {gsave} bind def
/gr {grestore} bind def
/sf {setfont} bind def
/nsp {0 exch {32 eq {1 add} if} forall} bind def    % stack: txt -> #spaces
/try {dup where {exch get} {pop 0} ifelse} bind def % stack: value
%%EndProlog

%%page 1 1
gs
2834.646 2834.646 scale
gs
0.0254 dup matrix scale concat
0.013837 dup matrix scale concat
175.6806 668.97 m
/Times-Bold findfont 17.06375 scalefont
/font0 exch def
font0 sf
(Simple Garbage-Collector-Safety) s
266.9224 633.8387 m
/Times-Italic findfont 9.03375 scalefont
/font1 exch def
font1 sf
(Hans-J. Boehm) s
270.555 622.7974 m
/Times-Roman findfont 9.03375 scalefont
/font2 exch def
font2 sf
(Xerox PARC) s
296.25 611.7561 m
240.9183 600.715 m
/Courier findfont 9.03375 scalefont
/font3 exch def
font3 sf
(boehm@parc.xerox.com) s
54 536.9087 m
54 525.8675 m
/colwidth 239.6475 def
gs
/Times-Bold findfont 9.03375 scalefont
/font4 exch def

/execget {arindex get dup null eq {pop} {exec} ifelse} bind def
/mj {                                    % mixed justify
    /excess colwidth totwidth sub def
    0 1 npiece {
        /arindex exch def
        opsbef execget                   % exec any accumu before ops
        nspaces arindex get              % stack: nspaces
        dup 0 eq {                       % stack: nspaces
            pop texts arindex get        % stack: text
            s                            % stack: NULL
            }{ 
            weights arindex get          % stack: nspaces weight
            totwt div excess mul         % stack: nspaces share-excess
            exch div 0 32                % stack: spaceadd 0 32
            texts arindex get            % stack: spaceadd 0 32 text
            widthshow                    % stack: NULL
            } ifelse
        opsaft execget                   % exec any accumulated after ops
        } for
    /totwidth 0 def /totwt 0.0 def
    } bind def
/buf {                                   % stack: text npiece
    /npiece exch def                     % stack: text
    dup nsp /ns exch def                 % stack: text
    dup texts npiece 3 -1 roll put       % stack: text
    nspaces npiece ns put width          % stack: width
    totwidth add /totwidth exch def      % stack: NULL
    ns 0 ne {
       ( ) width ns mul                  % stack: weight
       dup totwt add /totwt exch def     % stack: weight
       weights npiece 3 -1 roll put      % stack: NULL
       } if
    } bind def
/texts 250 array def
/nspaces 250 array def
/weights 250 array def
/opsbef 250 array def
/opsaft 250 array def
/totwidth 0 def
/totwt 0.0 def

font4 sf
opsbef 0 {font4 sf} put
(Abstract.) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(  A conservative garbage collector can typically be) 1 buf
opsaft 1 null put
mj
gr
54 514.8261 m
gs

/j {                                     % stack: text (justify)
    dup nsp /ns exch def                 % stack: text
    ns 0 eq {s} {                        % stack: text
        dup width /totwidth try add      % stack: text width
        colwidth exch sub                % stack: text excess
        ns div                           % stack: text spaceadd
        0 32 4 -1 roll                   % stack: spaceadd 0 32 text
        widthshow /totwidth 0 def        % stack: NULL
        } ifelse
    } bind def

font2 sf
(used with conventionally compiled programs written in C or) j
gr
54 503.7848 m
gs
font2 sf
(C++.  But two safety issues must be considered.  First, the) j
gr
54 492.7436 m
gs
font2 sf
(source code must not hide pointers from the garbage) j
gr
54 481.7024 m
/colwidth 239.6475 def
gs
font2 sf
(collector.  This primarily requires stricter adherence to) j
gr
54 470.661 m
/colwidth 239.6475 def
gs
font2 sf
(existing restrictions in the language definition.  Second, we) j
gr
54 459.62 m
gs
font2 sf
(must ensure that the compiler will not perform) j
gr
54 448.5786 m
font2 sf
(transformations that invalidate this requirement.) s
54 419.6361 m
/colwidth 239.6474 def
gs
font2 sf
(We argue that the same technique can be used to address both) j
gr
54 408.595 m
/colwidth 239.6475 def
gs
font2 sf
(issues.  We present an algorithm for annotating source or) j
gr
54 397.5536 m
/colwidth 239.6474 def
gs
font2 sf
(intermediate code to either check the validity of pointer) j
gr
54 386.5124 m
/colwidth 239.6475 def
gs
font2 sf
(arithmetic in the source, or to guarantee that under minimal,) j
gr
54 375.4712 m
gs
font2 sf
(clearly defined assumptions about the compiler, the optimizer) j
gr
54 364.43 m
/colwidth 239.6475 def
gs
font2 sf
(cannot ``disguise'' pointers.  We discuss an implementation) j
gr
54 353.3886 m
/colwidth 239.6476 def
gs
font2 sf
(based on a preprocessor for the GNU C compiler \050gcc\051, and) j
gr
54 342.3472 m
font2 sf
(give some measurements of program slowdown.) s
54 313.4048 m
72.06749 284.4624 m
72.06749 255.5199 m
72.06749 226.5775 m
/colwidth 221.58 def
gs
/Symbol findfont 9.03375 scalefont
/font5 exch def
font2 sf
opsbef 0 {font2 sf} put
(Copyright ) 0 buf
opsaft 0 null put
font5 sf
opsbef 1 {font5 sf} put
(\323) 1 buf
opsaft 1 null put
font2 sf
opsbef 2 {font2 sf} put
( 1996 by the Association for Computing) 2 buf
opsaft 2 null put
mj
gr
54 215.5362 m
/colwidth 239.6475 def
gs
font2 sf
(Machinery, Inc.  Permission to make digital or hard copies of) j
gr
54 204.4948 m
/colwidth 239.6475 def
gs
font2 sf
(part or all of this work for personal or classroom use is) j
gr
54 193.4536 m
gs
font2 sf
(granted without fee provided that copies are not made or) j
gr
54 182.4124 m
/colwidth 239.6475 def
gs
font2 sf
(distributed for profit or commercial advanatage and that) j
gr
54 171.3711 m
/colwidth 239.6475 def
gs
font2 sf
(copies bear this notice and the full citation on the first page.) j
gr
54 160.3299 m
gs
font2 sf
(Copyrights for components of this work owned by others than) j
gr
54 149.2887 m
gs
font2 sf
(ACM must be honored.  Abstracting with credit is permitted.) j
gr
54 138.2474 m
/colwidth 239.6474 def
gs
font2 sf
(To copy otherwise, to republish, to post on severs, or to) j
gr
54 127.2062 m
/colwidth 239.6475 def
gs
font2 sf
(redistribute to lists, requires prior specific permission and/or) j
gr
54 116.1649 m
/colwidth 239.6475 def
gs
font2 sf
(a fee.  Request permissions from Publications Dept., ACM) j
gr
54 105.1237 m
gs
font2 sf
(Inc., fax +1 \050212\051 869-0481, or \050permissions@acm.org\051.  This) j
gr
54 94.08247 m
gs
font2 sf
opsbef 0 {font2 sf} put
(originally appeared in ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(Proceedings of the ACM SIGPLAN '96) 1 buf
opsaft 1 null put
mj
gr
54 83.04118 m
/colwidth 239.6475 def
gs
font1 sf
(Conference on Programming Language Design and) j
gr
54 71.99994 m
font1 sf
(Implementation SIGPLAN Notices ??) s
font2 sf
(, ?, pp. ??-??.) s
320.6476 536.9087 m
/Times-Bold findfont 11.04125 scalefont
/font6 exch def
font6 sf
(Garbage-Collector-Safety) s
338.715 515.7412 m
/colwidth 221.58 def
gs
font2 sf
(Automatic garbage collection can significantly simplify) j
gr
320.6476 504.7 m
/colwidth 239.6475 def
gs
font2 sf
(program development.  It can also help to isolate program) j
gr
320.6476 493.6586 m
/colwidth 239.6474 def
gs
font2 sf
(errors to one module by helping to ensure that no module can) j
gr
320.6476 482.6172 m
/colwidth 239.6475 def
gs
font2 sf
(invalidate a data structure maintained by another.  Though it) j
gr
320.6476 471.5761 m
/colwidth 239.6475 def
gs
font2 sf
(is hard to quantify this benefit, most expert guesses seem to) j
gr
320.6476 460.5348 m
/colwidth 239.6475 def
gs
font2 sf
(place it in the range of 30-40% of program development time) j
gr
320.6476 449.4935 m
/colwidth 239.6475 def
gs
font2 sf
(for programs that manipulate complex linked data structures) j
gr
320.6476 438.4524 m
gs
font2 sf
(\050cf. [Rovner85]\051.  Furthermore,  in our experience, garbage) j
gr
320.6476 427.411 m
gs
font2 sf
(collected programs tend to be based on higher level) j
gr
320.6476 416.3699 m
/colwidth 239.6475 def
gs
font2 sf
(abstractions where appropriate, and thus tend to have fewer) j
gr
320.6476 405.3286 m
gs
font2 sf
opsbef 0 {font2 sf} put
(arbitrary restrictions on functionality \050) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(e.g.) 1 buf
opsaft 1 null put
font2 sf
opsbef 2 {font2 sf} put
( input size) 2 buf
opsaft 2 null put
mj
gr
320.6476 394.2874 m
font2 sf
(limitations\051.) s
338.715 379.963 m
/colwidth 221.58 def
gs
font1 sf
opsbef 0 {font1 sf} put
(Tracing) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
( garbage collectors identify all accessible memory) 1 buf
opsaft 1 null put
mj
gr
320.6476 368.9216 m
/colwidth 239.6475 def
gs
font2 sf
(by starting at program pointer variables, and traversing all) j
gr
320.6476 357.8804 m
gs
font2 sf
opsbef 0 {font2 sf} put
(pointers through the heap.  ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(Conservative) 1 buf
opsaft 1 null put
font2 sf
opsbef 2 {font2 sf} put
( garbage collectors) 2 buf
opsaft 2 null put
mj
gr
320.6476 346.8393 m
/colwidth 239.6475 def
gs
font2 sf
(\050cf. [Bartlett88], [BoehmWeiser88], [Rovner85], [Boehm 95]\051) j
gr
320.6476 335.7979 m
/colwidth 239.6474 def
gs
font2 sf
(can do so even in the presence of incomplete information) j
gr
320.6476 324.7568 m
/colwidth 239.6476 def
gs
font2 sf
(about pointer identity by treating any bit pattern that might) j
gr
320.6476 313.7155 m
/colwidth 239.6475 def
gs
font2 sf
(represent the address  of a heap object as a pointer.  This may) j
gr
320.6476 302.6742 m
/colwidth 239.6475 def
gs
font2 sf
(result in some extra memory retention, but this is rarely) j
gr
320.6476 291.6329 m
gs
font2 sf
(significant [Boehm93].  This approach enables garbage) j
gr
320.6476 280.5916 m
/colwidth 239.6475 def
gs
font2 sf
(collectors to operate easily with conventional programming) j
gr
320.6476 269.5504 m
gs
font2 sf
(languages such as C and C++, and with minimal or no) j
gr
320.6476 258.5091 m
gs
font2 sf
(modification to existing compilers.  It has been used by many) j
gr
320.6476 247.4679 m
gs
font2 sf
(language implementations that use C as an intermediate code) j
gr
320.6476 236.4267 m
gs
font2 sf
(\050cf. [Bartlett89], [AtkinsonEtAl89], [Omohundro91],) j
gr
320.6476 225.3854 m
/colwidth 239.6475 def
gs
font2 sf
([RoseMuller92], [SchelterBallantyne88]\051 , and it facilitates) j
gr
320.6476 214.3441 m
/colwidth 239.6475 def
gs
font2 sf
(interoperation between C and higher level programming) j
gr
320.6476 203.3029 m
font2 sf
(languages.) s
338.715 188.9786 m
/colwidth 221.58 def
gs
font2 sf
(Although conservative garbage collectors require) j
gr
320.6476 177.9374 m
/colwidth 239.6475 def
gs
font2 sf
(minimal cooperation from the compiler, they do require some) j
gr
320.6476 166.8961 m
gs
font2 sf
(to guarantee correct operation.  For example, a conventional) j
gr
320.6476 155.8548 m
/colwidth 239.6474 def
gs
font2 sf
opsbef 0 {font2 sf} put
(C compiler may replace a final reference ) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(p[i-1000]) 1 buf
opsaft 1 null put
font2 sf
opsbef 2 {font2 sf} put
( to the) 2 buf
opsaft 2 null put
mj
gr
320.6476 144.8136 m
font2 sf
(heap character pointer p by the sequence:) s
320.6476 130.4893 m
font2 sf
33.87653 0 rmoveto
font3 sf
(p = p - 1000;) s
320.6476 119.448 m
font3 sf
33.87653 0 rmoveto
(... p[i]...) s
320.6476 108.4068 m
font2 sf
( ) s
338.715 94.08247 m
/colwidth 221.58 def
gs
font2 sf
(If a garbage collection is triggered between the) j
gr
320.6476 83.04124 m
/colwidth 239.6475 def
gs
font2 sf
opsbef 0 {font2 sf} put
(replacement of ) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(p) 1 buf
opsaft 1 null put
font2 sf
opsbef 2 {font2 sf} put
(, and the reference to ) 2 buf
opsaft 2 null put
font3 sf
opsbef 3 {font3 sf} put
(p[i]) 3 buf
opsaft 3 null put
font2 sf
opsbef 4 {font2 sf} put
(, there may be no) 4 buf
opsaft 4 null put
mj
gr
320.6476 72 m
gs
font2 sf
opsbef 0 {font2 sf} put
(recognizable pointer to the object referenced by ) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(p) 1 buf
opsaft 1 null put
font2 sf
opsbef 2 {font2 sf} put
(.  Thus such) 2 buf
opsaft 2 null put
mj
gr
gr
gr
showpage
%%page 2 2
gs
2834.646 2834.646 scale
gs
0.0254 dup matrix scale concat
0.013837 dup matrix scale concat
54 707.9137 m
/colwidth 239.6475 def
gs
/Times-Roman findfont 9.03375 scalefont
/font0 exch def
/Times-Italic findfont 9.03375 scalefont
/font1 exch def

/execget {arindex get dup null eq {pop} {exec} ifelse} bind def
/mj {                                    % mixed justify
    /excess colwidth totwidth sub def
    0 1 npiece {
        /arindex exch def
        opsbef execget                   % exec any accumu before ops
        nspaces arindex get              % stack: nspaces
        dup 0 eq {                       % stack: nspaces
            pop texts arindex get        % stack: text
            s                            % stack: NULL
            }{ 
            weights arindex get          % stack: nspaces weight
            totwt div excess mul         % stack: nspaces share-excess
            exch div 0 32                % stack: spaceadd 0 32
            texts arindex get            % stack: spaceadd 0 32 text
            widthshow                    % stack: NULL
            } ifelse
        opsaft execget                   % exec any accumulated after ops
        } for
    /totwidth 0 def /totwt 0.0 def
    } bind def
/buf {                                   % stack: text npiece
    /npiece exch def                     % stack: text
    dup nsp /ns exch def                 % stack: text
    dup texts npiece 3 -1 roll put       % stack: text
    nspaces npiece ns put width          % stack: width
    totwidth add /totwidth exch def      % stack: NULL
    ns 0 ne {
       ( ) width ns mul                  % stack: weight
       dup totwt add /totwt exch def     % stack: weight
       weights npiece 3 -1 roll put      % stack: NULL
       } if
    } bind def
/texts 250 array def
/nspaces 250 array def
/weights 250 array def
/opsbef 250 array def
/opsaft 250 array def
/totwidth 0 def
/totwt 0.0 def

font0 sf
opsbef 0 {font0 sf} put
(code is not ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(GC-safe) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(.  \050Here we assume the existence of) 2 buf
opsaft 2 null put
mj
gr
54 696.8724 m
/colwidth 239.6475 def
gs

/j {                                     % stack: text (justify)
    dup nsp /ns exch def                 % stack: text
    ns 0 eq {s} {                        % stack: text
        dup width /totwidth try add      % stack: text width
        colwidth exch sub                % stack: text excess
        ns div                           % stack: text spaceadd
        0 32 4 -1 roll                   % stack: spaceadd 0 32 text
        widthshow /totwidth 0 def        % stack: NULL
        } ifelse
    } bind def

font0 sf
(multiple threads of control.  Similar examples can be) j
gr
54 685.8312 m
gs
font0 sf
(constructed if the collector can only be invoked at function) j
gr
54 674.79 m
font0 sf
(call sites.\051) s
72.06749 646.093 m
/colwidth 221.58 def
gs
font0 sf
(Note that the fundamental problem is not the way in) j
gr
54 635.0518 m
/colwidth 239.6475 def
gs
/Courier findfont 9.03375 scalefont
/font2 exch def
font0 sf
opsbef 0 {font0 sf} put
(which ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(p[i-1000]) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( is computed, but the fact that the original) 2 buf
opsaft 2 null put
mj
gr
54 624.0106 m
/colwidth 239.6476 def
gs
font0 sf
(value of p is overwritten before the computation is complete.) j
gr
54 612.9692 m
/colwidth 239.6475 def
gs
font0 sf
(Thus the problem is to convince the compiler to preserve) j
gr
54 601.928 m
/colwidth 239.6476 def
gs
font0 sf
(some values longer than they appear to be needed, rather than) j
gr
54 590.8868 m
font0 sf
(to suppress specific optimizations. ) s
72.06749 562.1900 m
/colwidth 221.58 def
gs
font0 sf
(Similar problems may occur as a result of induction) j
gr
54 551.1486 m
/colwidth 239.6475 def
gs
font0 sf
(variable optimizations, or in the construction of a large) j
gr
54 540.1075 m
gs
font0 sf
(constant address displacement on a machine that provides) j
gr
54 529.0661 m
gs
font0 sf
(only a small signed displacement field in machine) j
gr
54 518.025 m
gs
font0 sf
(instructions.  Other examples can be found in) j
gr
54 506.9836 m
font0 sf
([BoehmChase92].) s
72.06749 478.2868 m
/colwidth 221.58 def
gs
font0 sf
(Such problems are in fact extremely rare with existing) j
gr
54 467.2456 m
/colwidth 239.6475 def
gs
font0 sf
(compilers.  Conservative garbage collection is commonly used) j
gr
54 456.2044 m
/colwidth 239.6475 def
gs
font0 sf
(with conventional unmodified optimizing compilers, and to) j
gr
54 445.163 m
gs
font0 sf
opsbef 0 {font0 sf} put
(our knowledge, the above problems have ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(only) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( been observed) 2 buf
opsaft 2 null put
mj
gr
54 434.122 m
/colwidth 239.6474 def
gs
font0 sf
(in examples contrived for the purpose.  This is in strong) j
gr
54 423.0806 m
/colwidth 239.6475 def
gs
font0 sf
(contrast to conventional optimization bugs in production) j
gr
54 412.0392 m
font0 sf
(compilers.) s
72.06749 383.3425 m
/colwidth 221.58 def
gs
font0 sf
(Nonetheless we would like to be able to generate GC-) j
gr
54 372.3012 m
/colwidth 239.6474 def
gs
font0 sf
(safe code to guarantee safety of the approach.  We would at) j
gr
54 361.26 m
/colwidth 239.6475 def
gs
font0 sf
(least like to be able to point to a practical alternative in case) j
gr
54 350.2188 m
gs
font0 sf
(such a problem is discovered.  And we would like to defend) j
gr
54 339.1774 m
/colwidth 239.6475 def
gs
font0 sf
(against future clever optimizations that may increase the) j
gr
54 328.1361 m
font0 sf
(frequency of such problems.) s
72.06749 299.4394 m
/colwidth 221.58 def
gs
font0 sf
(For most compilers, it is possible to guarantee GC-safety) j
gr
54 288.398 m
/colwidth 239.6474 def
gs
font0 sf
(by generating fully debuggable code.  If the values of all) j
gr
54 277.3567 m
/colwidth 239.6475 def
gs
font0 sf
(logically visible variables are explicitly stored for debugging) j
gr
54 266.3155 m
gs
font0 sf
(purposes at all program points, then they will also be available) j
gr
54 255.2742 m
gs
font0 sf
(for the garbage collector.  Unfortunately, performance) j
gr
54 244.233 m
gs
font0 sf
(considerations make such an approach \050and some other) j
gr
54 233.1918 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(solutions, ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(e.g.) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( involving frequent uses of ) 2 buf
opsaft 2 null put
font2 sf
opsbef 3 {font2 sf} put
(volatile) 3 buf
opsaft 3 null put
mj
gr
54 222.1506 m
font0 sf
(variables\051 unattractive.) s
72.06749 193.4536 m
/colwidth 221.58 def
gs
font0 sf
(Unfortunately, GC-safety is likely to introduce some) j
gr
54 182.4124 m
/colwidth 239.6475 def
gs
font0 sf
(runtime overhead, distinct from time spent in allocation and) j
gr
54 171.3711 m
/colwidth 239.6475 def
gs
font0 sf
(garbage collection routines. \050See, for example,) j
gr
54 160.3299 m
/colwidth 239.6475 def
gs
font0 sf
([OTooleNettles94], [DetlefsDosserZorn93], and) j
gr
54 149.2887 m
gs
font0 sf
([BoehmDemersShenker91] for some measurements of) j
gr
54 138.2474 m
gs
font0 sf
(conventional collector overhead.\051  Since the problem is) j
gr
54 127.2062 m
/colwidth 239.6475 def
gs
font0 sf
(essentially never observed in practice, there is some argument) j
gr
54 116.1649 m
/colwidth 239.6475 def
gs
font0 sf
(that the introduced overhead should be very small with) j
gr
54 105.1237 m
/colwidth 239.6475 def
gs
font0 sf
(``sufficiently good'' program analysis.  In particular all existing) j
gr
54 94.08247 m
/colwidth 239.6475 def
gs
font0 sf
(programs can theoretically be compiled on existing compilers) j
gr
54 83.04118 m
/colwidth 239.6474 def
gs
font0 sf
(as they are now.  Here we look at the performance of a rather) j
gr
54 71.99994 m
font0 sf
(simple, but decidedly imperfect analysis.) s
320.6476 707.9137 m
/Times-Bold findfont 11.04125 scalefont
/font3 exch def
font3 sf
(Source Checking) s
338.715 689.0953 m
/colwidth 221.58 def
gs
font0 sf
(A related problem is that of checking that the original) j
gr
320.6476 678.0541 m
font0 sf
(source code is safe for use with a garbage collector.) s
8.355224 0 rmoveto
338.715 665.609 m
gs
font0 sf
(Recall that the C language allows some arithmetic on) j
gr
320.6476 654.5676 m
/colwidth 239.6476 def
gs
font0 sf
(pointers.  However a value may be added to a pointer only if) j
gr
320.6476 643.5263 m
/colwidth 239.6475 def
gs
font0 sf
(the result and the original pointer are addresses within the) j
gr
320.6476 632.4852 m
/colwidth 239.6475 def
gs
font0 sf
(same object.  Either may also point one past the end of the) j
gr
320.6476 621.444 m
gs
font0 sf
(object, which we handle by allocating all heap objects with at) j
gr
320.6476 610.4028 m
/colwidth 239.6474 def
gs
font0 sf
(least one extra byte at the end.  We make some additional) j
gr
320.6476 599.3614 m
font0 sf
(assumptions about the input program:) s
338.715 586.9164 m
/colwidth 221.58 def
gs
font0 sf
(1\051 No integers are converted to heap pointers.  In fact,) j
gr
320.6476 575.875 m
/colwidth 239.6475 def
gs
font0 sf
(conversion of a pointer to an integer and back, without) j
gr
320.6476 564.834 m
/colwidth 239.6475 def
gs
font0 sf
(intervening arithmetic, is benign, as is the common practice of) j
gr
320.6476 553.7926 m
gs
font0 sf
(converting very small integers to pointers that are never) j
gr
320.6476 542.7514 m
/colwidth 239.6475 def
gs
font0 sf
(dereferenced.  Disguised pointer arithmetic is not.  Hashing) j
gr
320.6476 531.7100 m
gs
font0 sf
(on pointer values is no problem, since we effectively assume a) j
gr
320.6476 520.669 m
gs
font0 sf
(nonmoving garbage collector.  Our preprocessor issues) j
gr
320.6476 509.6276 m
gs
font0 sf
(warnings when nonpointer values are directly converted to) j
gr
320.6476 498.5864 m
gs
font0 sf
(pointers.  It could and should also issue warnings when the) j
gr
320.6476 487.5452 m
/colwidth 239.6475 def
gs
font0 sf
(same thing is accomplished by a cast between different) j
gr
320.6476 476.5040 m
font0 sf
(structure pointer types or the like.) s
338.715 464.0588 m
/colwidth 221.58 def
gs
font0 sf
(2\051 Pointers are not hidden from the garbage collector by) j
gr
320.6476 453.0175 m
/colwidth 239.6474 def
gs
font0 sf
(writing them to files and reading them back in, or by writing) j
gr
320.6476 441.9762 m
/colwidth 239.6475 def
gs
font0 sf
(them to collector invisible \050or misaligned\051 memory locations.) j
gr
320.6476 430.935 m
/colwidth 239.6475 def
gs
font0 sf
(To our knowledge, this is possible in a strictly conforming) j
gr
320.6476 419.8936 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(ANSI C program only via pointer input with either a ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(scanf) 1 buf
opsaft 1 null put
mj
gr
320.6476 408.8524 m
/colwidth 239.6474 def
gs
font0 sf
opsbef 0 {font0 sf} put
(variant and ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(%p) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( format or with ) 2 buf
opsaft 2 null put
font2 sf
opsbef 3 {font2 sf} put
(fread) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
( into a pointer-) 4 buf
opsaft 4 null put
mj
gr
320.6476 397.8113 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(containing type, or with a call to ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(memcpy) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( or ) 2 buf
opsaft 2 null put
font2 sf
opsbef 3 {font2 sf} put
(memmove) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
( with) 4 buf
opsaft 4 null put
mj
gr
320.6476 386.7701 m
/colwidth 239.6475 def
gs
font0 sf
(arguments whose types don't match.  Thus this should be) j
gr
320.6476 375.7288 m
font0 sf
(easily checkable, though we currently don't do so.) s
338.715 363.2838 m
/colwidth 221.58 def
gs
font0 sf
(Thus the practical issue in checking the safety of a) j
gr
320.6476 352.2424 m
/colwidth 239.6475 def
gs
font0 sf
(program is to ensure that the ANSI C requirements on) j
gr
320.6476 341.2012 m
/colwidth 239.6476 def
gs
font0 sf
(pointer arithmetic are satisfied.  Our main goals are to ensure) j
gr
320.6476 330.16 m
/colwidth 239.6475 def
gs
font0 sf
(that no objects are prematurely collected, and that garbage) j
gr
320.6476 319.1187 m
gs
font0 sf
(collector data structures are unlikely to be overwritten.  We) j
gr
320.6476 308.0774 m
gs
font0 sf
(restrict our attention to heap pointers, since that both ensures) j
gr
320.6476 297.0361 m
gs
font0 sf
(the first goal, and makes the overwriting of collector data) j
gr
320.6476 285.995 m
font0 sf
(structures much less likely.) s
338.715 273.55 m
/colwidth 221.58 def
gs
font0 sf
(Our garbage collector provides a facility for checking) j
gr
320.6476 262.5086 m
/colwidth 239.6475 def
gs
font0 sf
(whether two pointers reference the same heap object.  Hence) j
gr
320.6476 251.4675 m
/colwidth 239.6475 def
gs
font0 sf
(it suffices to check after each pointer arithmetic operation that) j
gr
320.6476 240.4262 m
gs
font0 sf
(the result still points to the original object.  We argue below) j
gr
320.6476 229.385 m
/colwidth 239.6475 def
gs
font0 sf
(that the program can be annotated with such checking calls in) j
gr
320.6476 218.3438 m
/colwidth 239.6475 def
gs
font0 sf
(exactly the same manner as annotating it for GC-safety.  In) j
gr
320.6476 207.3025 m
/colwidth 239.6475 def
gs
font0 sf
(fact, the checking calls ensure GC-safety, though not in a) j
gr
320.6476 196.2612 m
font0 sf
(performance-optimal fashion.) s
338.715 183.8162 m
/colwidth 221.58 def
gs
font0 sf
(Admittedly the annotated program will incur a) j
gr
320.6476 172.775 m
/colwidth 239.6475 def
gs
font0 sf
(significant performance loss, at least without substantially) j
gr
320.6476 161.7337 m
/colwidth 239.6475 def
gs
font0 sf
(more analysis than we perform.  We expect such checking to) j
gr
320.6476 150.6925 m
/colwidth 239.6474 def
gs
font0 sf
(be performed only during debugging, by analogy to the) j
gr
320.6476 139.6512 m
font0 sf
(current use of systems like Purify [HastingsJoyce92].) s
338.715 127.2062 m
/colwidth 221.58 def
gs
font0 sf
(Our checking is not completely accurate, since the) j
gr
320.6476 116.1649 m
/colwidth 239.6475 def
gs
font0 sf
(garbage collector rounds up object sizes.  But it is sufficient to) j
gr
320.6476 105.1237 m
/colwidth 239.6475 def
gs
font0 sf
(ensure that on a machine with typical RISC alignment) j
gr
320.6476 94.08247 m
gs
font0 sf
(restrictions at most unused memory can be accidentally) j
gr
320.6476 83.04124 m
gs
font0 sf
(referenced through an incorrectly computed heap pointer to a) j
gr
320.6476 72 m
/colwidth 239.6476 def
gs
font0 sf
(primitive type.  It is currently still possible to reference or) j
gr
gr
gr
showpage
%%page 3 3
gs
2834.646 2834.646 scale
gs
0.0254 dup matrix scale concat
0.013837 dup matrix scale concat
54 707.9137 m
/colwidth 239.6475 def
gs
/Times-Roman findfont 9.03375 scalefont
/font0 exch def

/j {                                     % stack: text (justify)
    dup nsp /ns exch def                 % stack: text
    ns 0 eq {s} {                        % stack: text
        dup width /totwidth try add      % stack: text width
        colwidth exch sub                % stack: text excess
        ns div                           % stack: text spaceadd
        0 32 4 -1 roll                   % stack: spaceadd 0 32 text
        widthshow /totwidth 0 def        % stack: NULL
        } ifelse
    } bind def

font0 sf
(overwrite other memory if C structures are accessed as a) j
gr
54 696.8724 m
/colwidth 239.6475 def
gs
font0 sf
(whole, e.g. if they are passed as parameters or assigned to) j
gr
54 685.8312 m
gs
font0 sf
(other structures.  This could be remedied at minimal cost with) j
gr
54 674.79 m
font0 sf
(the insertion of an additional check.) s
54 643.3878 m
/Times-Bold findfont 11.04125 scalefont
/font1 exch def
font1 sf
(Related Work) s
72.06749 624.0302 m
/colwidth 221.58 def
gs
font0 sf
(We extend, refine and implement the work presented in) j
gr
54 612.9891 m
font0 sf
([BoehmChase92] and [EllisDetlefs93].  ) s
72.06749 600.1129 m
gs
font0 sf
(Unlike [BoehmChase92] we start with the assumption) j
gr
54 589.0718 m
/colwidth 239.6476 def
gs
font0 sf
(that the garbage collector recognizes all pointers to the) j
gr
54 578.0302 m
/colwidth 239.6475 def
gs
font0 sf
(interior of an object, not just to the first byte of the object.) j
gr
54 566.9892 m
/colwidth 239.6475 def
gs
font0 sf
(Recent experience suggests that this is the right framework,) j
gr
54 555.948 m
gs
font0 sf
(particularly for typical C++ implementations which) j
gr
54 544.9068 m
/colwidth 239.6474 def
gs
font0 sf
(implicitly generate pointers to the interior of an object.  The) j
gr
54 533.8653 m
/colwidth 239.6475 def
gs
font0 sf
(techniques of [Boehm93] can greatly reduce the danger of) j
gr
54 522.8243 m
gs
font0 sf
(space leakage that we previously associated with this) j
gr
54 511.783 m
/colwidth 239.6475 def
gs
font0 sf
(approach.  This new assumption greatly simplifies our task.) j
gr
54 500.7416 m
/colwidth 239.6475 def
gs
font0 sf
(Unfortunately, it also usually invalidates assumption \050A\051 of) j
gr
54 489.7004 m
/colwidth 239.6475 def
gs
font0 sf
([BoehmChase92], so our correctness argument has to be) j
gr
54 478.659 m
font0 sf
(different.    ) s
72.06749 465.7832 m
/colwidth 221.58 def
gs
font0 sf
(An approach even more similar to ours here is presented) j
gr
54 454.742 m
font0 sf
(in [EllisDetlefs93], but not in a great amount of detail.) s
72.06749 441.8656 m
gs
font0 sf
(There has been much work on the generation and) j
gr
54 430.8245 m
/colwidth 239.6475 def
gs
font0 sf
(representation of object and stack layout information by the) j
gr
54 419.7833 m
gs
font0 sf
(compiler for the garbage collector.  Recent examples include) j
gr
54 408.742 m
/colwidth 239.6475 def
gs
font0 sf
([DiwanMossHudson92] [Goldberg91], and [Fradet94].  The) j
gr
54 397.7008 m
/colwidth 239.6475 def
gs
font0 sf
(idea is to generate static information \050either tables or traversal) j
gr
54 386.6596 m
gs
font0 sf
(functions\051 to communicate pointer locations to the garbage) j
gr
54 375.6182 m
/colwidth 239.6475 def
gs
font0 sf
(collector.  Thus these techniques also introduce minimal) j
gr
54 364.5769 m
/colwidth 239.6475 def
gs
font0 sf
(overhead into client code, while producing much more precise) j
gr
54 353.5357 m
/colwidth 239.6474 def
gs
font0 sf
(information for the garbage collector.  \050The overhead is often) j
gr
54 342.4944 m
/colwidth 239.6475 def
gs
font0 sf
(very similar to that described here, though the details will vary) j
gr
54 331.4531 m
gs
font0 sf
(depending on the expressiveness of the layout representation) j
gr
54 320.4119 m
/colwidth 239.6475 def
gs
font0 sf
(scheme.\051 The disadvantages of such an approach are that it is) j
gr
54 309.3707 m
/colwidth 239.6475 def
gs
font0 sf
(hard to accommodate code written in languages such as C or) j
gr
54 298.3294 m
/colwidth 239.6475 def
gs
font0 sf
(often code compiled by more than one compiler, table size) j
gr
54 287.2881 m
/colwidth 239.6475 def
gs
font0 sf
(and/or interpretation overhead may be a problem, and) j
gr
54 276.2469 m
gs
font0 sf
(typically garbage collections must be restricted to only be) j
gr
54 265.2056 m
/colwidth 239.6476 def
gs
font0 sf
(triggered at specific interruption points.  The last point may) j
gr
54 254.1644 m
/colwidth 239.6475 def
gs
font0 sf
(introduce other forms of overhead in some multithreaded) j
gr
54 243.123 m
font0 sf
(environments.) s
72.06749 230.247 m
/colwidth 221.58 def
gs
font0 sf
(To our knowledge, none of this work addresses the issue) j
gr
54 219.2059 m
/colwidth 239.6475 def
gs
font0 sf
(of run-time overhead required to keep pointers accessible,) j
gr
54 208.1646 m
/colwidth 239.6475 def
gs
font0 sf
(though [DiwanMossHudson92] does discuss the necessity for) j
gr
54 197.1233 m
font0 sf
(such overhead.) s
72.06749 184.2472 m
/colwidth 221.58 def
gs
font0 sf
(There have also been many proposals for completely) j
gr
54 173.206 m
/colwidth 239.6475 def
gs
font0 sf
(source-level implementation of garbage-collection using) j
gr
54 162.1648 m
/colwidth 239.6475 def
gs
font0 sf
(either the C++ constructor/destructor mechanism or Ada) j
gr
54 151.1235 m
gs
font0 sf
(9X ``finalization''.  These typically greatly increase the) j
gr
54 140.0823 m
gs
font0 sf
(number of memory references necessary for pointer) j
gr
54 129.0411 m
/colwidth 239.6475 def
gs
font0 sf
(assignments or pointer variable creation.  Hence they are not) j
gr
54 117.9998 m
/colwidth 239.6475 def
gs
font0 sf
(performance competitive with conservative collectors, though) j
gr
54 106.9586 m
/colwidth 239.6475 def
gs
font0 sf
(the expense may be unavoidable in hard real-time) j
gr
54 95.9173 m
font0 sf
(environments [Edelson91].) s
72.06749 83.04124 m
/colwidth 221.58 def
gs
font0 sf
(There has been a substantial amount of work on safer C) j
gr
54 72 m
/colwidth 239.6475 def
gs
font0 sf
(implementations \050cf. [HastingsJoyce92],) j
gr
320.6476 707.9137 m
gs
font0 sf
([AustinBreachSohi94], [JonesKelly95].\051  Most of these have) j
gr
320.6476 696.8724 m
/colwidth 239.6475 def
gs
font0 sf
(concentrated on detecting erroneous memory accesses, not) j
gr
320.6476 685.8312 m
gs
font0 sf
(erroneous pointer or subscript arithmetic.  Though the two) j
gr
320.6476 674.79 m
/colwidth 239.6475 def
gs
font0 sf
(are related, the distinction is important.  A common bug) j
gr
320.6476 663.7486 m
/colwidth 239.6475 def
gs
font0 sf
(\050sometimes referred to incorrectly as a ``technique''\051 in C code) j
gr
320.6476 652.7074 m
/colwidth 239.6475 def
gs
font0 sf
(is to represent an array as a pointer to one element before the) j
gr
320.6476 641.6660 m
/colwidth 239.6475 def
gs
font0 sf
(beginning of the array's memory.  This fails in a garbage) j
gr
320.6476 630.625 m
gs
font0 sf
(collected system.  It may also result in incorrect pointer) j
gr
320.6476 619.5836 m
font0 sf
(comparisons on segmented memory machines.) s
338.715 606.1428 m
/colwidth 221.58 def
gs
font0 sf
(Like Purify, but unlike [AustinBreachSohi94], our) j
gr
320.6476 595.1016 m
/colwidth 239.6475 def
gs
font0 sf
(checked code uses the same data structure layout as) j
gr
320.6476 584.0605 m
/colwidth 239.6474 def
gs
font0 sf
(unchecked code.  Hence it is possible, indeed trivial, to use) j
gr
320.6476 573.0193 m
/colwidth 239.6475 def
gs
font0 sf
(checked code with third party object-code-only libraries, or) j
gr
320.6476 561.9777 m
font0 sf
(with faster, unchecked modules.) s
338.715 548.5373 m
/colwidth 221.58 def
gs
font0 sf
(Our checked code is very similar in spirit to recent) j
gr
320.6476 537.4959 m
/colwidth 239.6475 def
gs
font0 sf
(independent work by Jones and Kelly [JonesKelly95].  The) j
gr
320.6476 526.4545 m
gs
font0 sf
(major differences are that we do not check references to) j
gr
320.6476 515.4133 m
/colwidth 239.6475 def
gs
font0 sf
(statically allocated and stack memory, we use the garbage) j
gr
320.6476 504.3721 m
gs
font0 sf
(collector's data structures to determine whether two pointers) j
gr
320.6476 493.3309 m
/colwidth 239.6476 def
gs
font0 sf
(reference the same object, and we take a different approach to) j
gr
320.6476 482.2895 m
/colwidth 239.6475 def
gs
font0 sf
(inserting the checking code.  The garbage-collector-based) j
gr
320.6476 471.2484 m
/colwidth 239.6475 def
gs
font0 sf
(check is probably somewhat more efficient, since it relies) j
gr
320.6476 460.2072 m
/colwidth 239.6475 def
gs
font0 sf
(primarily on mapping any address to the beginning of the) j
gr
320.6476 449.1659 m
gs
font0 sf
(corresponding object, an operation crucial to the collector's) j
gr
320.6476 438.1246 m
/colwidth 239.6475 def
gs
font0 sf
(performance.  \050Their fundamental data structure is a splay) j
gr
320.6476 427.0834 m
/colwidth 239.6474 def
gs
font0 sf
(tree of objects, we use a tree of fixed height 2 describing pages) j
gr
320.6476 416.0421 m
/colwidth 239.6476 def
gs
font0 sf
(of uniformly sized objects.\051  Hence both the allocator and) j
gr
320.6476 405.0009 m
/colwidth 239.6475 def
gs
font0 sf
(collector are tuned to make such lookups very fast.  Since we) j
gr
320.6476 393.9596 m
/colwidth 239.6475 def
gs
font0 sf
(use existing collector data structures, the checking can be) j
gr
320.6476 382.9184 m
gs
font0 sf
(implemented purely in a preprocessor.  Our  approach to) j
gr
320.6476 371.8772 m
gs
font0 sf
(inserting checking code is significantly different, in that we) j
gr
320.6476 360.8358 m
gs
font0 sf
(essentially treat pointer offset calculations as pointer) j
gr
320.6476 349.7945 m
gs
font0 sf
(arithmetic.  This appears to result in better checking of) j
gr
320.6476 338.7532 m
font0 sf
(structure accesses.) s
320.6476 306.6452 m
font1 sf
(Compiler Safety Problem Statement) s
338.715 286.5822 m
/colwidth 221.58 def
gs
font0 sf
(We are interested in compiling ANSI C [ANSI89],) j
gr
320.6476 275.541 m
/colwidth 239.6475 def
gs
font0 sf
(minimally restricted as defined above, such that the object) j
gr
320.6476 264.4998 m
/colwidth 239.6475 def
gs
font0 sf
(code resulting from a strictly conforming program is) j
gr
320.6476 253.4586 m
/colwidth 239.6475 def
gs
font0 sf
(guaranteed to operate correctly with a conservative garbage) j
gr
320.6476 242.4174 m
gs
/Times-Italic findfont 9.03375 scalefont
/font2 exch def

/execget {arindex get dup null eq {pop} {exec} ifelse} bind def
/mj {                                    % mixed justify
    /excess colwidth totwidth sub def
    0 1 npiece {
        /arindex exch def
        opsbef execget                   % exec any accumu before ops
        nspaces arindex get              % stack: nspaces
        dup 0 eq {                       % stack: nspaces
            pop texts arindex get        % stack: text
            s                            % stack: NULL
            }{ 
            weights arindex get          % stack: nspaces weight
            totwt div excess mul         % stack: nspaces share-excess
            exch div 0 32                % stack: spaceadd 0 32
            texts arindex get            % stack: spaceadd 0 32 text
            widthshow                    % stack: NULL
            } ifelse
        opsaft execget                   % exec any accumulated after ops
        } for
    /totwidth 0 def /totwt 0.0 def
    } bind def
/buf {                                   % stack: text npiece
    /npiece exch def                     % stack: text
    dup nsp /ns exch def                 % stack: text
    dup texts npiece 3 -1 roll put       % stack: text
    nspaces npiece ns put width          % stack: width
    totwidth add /totwidth exch def      % stack: NULL
    ns 0 ne {
       ( ) width ns mul                  % stack: weight
       dup totwt add /totwt exch def     % stack: weight
       weights npiece 3 -1 roll put      % stack: NULL
       } if
    } bind def
/texts 250 array def
/nspaces 250 array def
/weights 250 array def
/opsbef 250 array def
/opsaft 250 array def
/totwidth 0 def
/totwt 0.0 def

font0 sf
opsbef 0 {font0 sf} put
(collector, if we replace every call to the ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(malloc,) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( ) 2 buf
opsaft 2 null put
font2 sf
opsbef 3 {font2 sf} put
(calloc) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
( and) 4 buf
opsaft 4 null put
mj
gr
320.6476 231.3761 m
gs
font2 sf
opsbef 0 {font2 sf} put
(realloc) 0 buf
opsaft 0 null put
font0 sf
opsbef 1 {font0 sf} put
( functions by corresponding calls to a collecting) 1 buf
opsaft 1 null put
mj
gr
320.6476 220.3348 m
font0 sf
(allocator, and remove all calls to ) s
font2 sf
(free) s
font0 sf
(.) s
338.715 206.8941 m
/colwidth 221.58 def
gs
font0 sf
(We refer to the machine stack, registers, and statically) j
gr
320.6476 195.8529 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(allocated memory as ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(GC-roots) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(.  We assume that the garbage) 2 buf
opsaft 2 null put
mj
gr
320.6476 184.8117 m
/colwidth 239.6475 def
gs
font0 sf
(collector preserves every object that is reachable by following) j
gr
320.6476 173.7705 m
/colwidth 239.6475 def
gs
font0 sf
(pointers from a GC-root, and possibly through heap resident) j
gr
320.6476 162.7292 m
/colwidth 239.6475 def
gs
font0 sf
(pointers.  We assume that the garbage collector recognizes any) j
gr
320.6476 151.688 m
gs
font0 sf
(address corresponding to some place inside a heap allocated) j
gr
320.6476 140.6467 m
/colwidth 239.6475 def
gs
font0 sf
(object as a valid pointer.  \050[Boehm95] satisfies these) j
gr
320.6476 129.6055 m
font0 sf
(assumptions in its default configuration.\051) s
338.715 116.1648 m
/colwidth 221.58 def
gs
font0 sf
(It follows from our restrictions on C programs that every) j
gr
320.6476 105.1236 m
/colwidth 239.6475 def
gs
font0 sf
(heap object that may be accessed is accessible by following a) j
gr
320.6476 94.08234 m
/colwidth 239.6476 def
gs
font0 sf
(chain of pointers from program variables.  Some of these) j
gr
320.6476 83.0411 m
/colwidth 239.6475 def
gs
font0 sf
(pointers may point to the interior of the object they reference.) j
gr
320.6476 71.99982 m
gs
font0 sf
(We would like to guarantee that the generated object code) j
gr
gr
gr
showpage
%%page 4 4
gs
2834.646 2834.646 scale
gs
0.0254 dup matrix scale concat
0.013837 dup matrix scale concat
54 707.9137 m
/colwidth 239.6474 def
gs
/Times-Roman findfont 9.03375 scalefont
/font0 exch def

/j {                                     % stack: text (justify)
    dup nsp /ns exch def                 % stack: text
    ns 0 eq {s} {                        % stack: text
        dup width /totwidth try add      % stack: text width
        colwidth exch sub                % stack: text excess
        ns div                           % stack: text spaceadd
        0 32 4 -1 roll                   % stack: spaceadd 0 32 text
        widthshow /totwidth 0 def        % stack: NULL
        } ifelse
    } bind def

font0 sf
(satisfies the same property at every program point.  That is,) j
gr
54 696.8724 m
/colwidth 239.6476 def
gs
font0 sf
(there must be a path from the GC-roots, possibly through) j
gr
54 685.8312 m
/colwidth 239.6475 def
gs
font0 sf
(other heap objects, to every potentially accessible heap object.) j
gr
54 674.79 m
gs
font0 sf
(In particular, either program variables or equivalent compiler) j
gr
54 663.7486 m
gs
font0 sf
(temporaries, should be explicitly stored, possibly in a machine) j
gr
54 652.7074 m
/colwidth 239.6476 def
gs
font0 sf
(register, as long as heap objects they refer to may be accessed.) j
gr
54 641.6660 m
gs
font0 sf
(This suffices to ensure the correctness of a suitable) j
gr
54 630.625 m
font0 sf
(conservative garbage collector.) s
72.06749 617.069 m
/colwidth 221.58 def
gs
font0 sf
(Returning to our original example of compiling the) j
gr
54 606.0278 m
/colwidth 239.6475 def
gs
/Courier findfont 9.03375 scalefont
/font1 exch def

/execget {arindex get dup null eq {pop} {exec} ifelse} bind def
/mj {                                    % mixed justify
    /excess colwidth totwidth sub def
    0 1 npiece {
        /arindex exch def
        opsbef execget                   % exec any accumu before ops
        nspaces arindex get              % stack: nspaces
        dup 0 eq {                       % stack: nspaces
            pop texts arindex get        % stack: text
            s                            % stack: NULL
            }{ 
            weights arindex get          % stack: nspaces weight
            totwt div excess mul         % stack: nspaces share-excess
            exch div 0 32                % stack: spaceadd 0 32
            texts arindex get            % stack: spaceadd 0 32 text
            widthshow                    % stack: NULL
            } ifelse
        opsaft execget                   % exec any accumulated after ops
        } for
    /totwidth 0 def /totwt 0.0 def
    } bind def
/buf {                                   % stack: text npiece
    /npiece exch def                     % stack: text
    dup nsp /ns exch def                 % stack: text
    dup texts npiece 3 -1 roll put       % stack: text
    nspaces npiece ns put width          % stack: width
    totwidth add /totwidth exch def      % stack: NULL
    ns 0 ne {
       ( ) width ns mul                  % stack: weight
       dup totwt add /totwt exch def     % stack: weight
       weights npiece 3 -1 roll put      % stack: NULL
       } if
    } bind def
/texts 250 array def
/nspaces 250 array def
/weights 250 array def
/opsbef 250 array def
/opsaft 250 array def
/totwidth 0 def
/totwt 0.0 def

font0 sf
opsbef 0 {font0 sf} put
(expression ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(p[i-1000]) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(, our goal is to ensure that either the) 2 buf
opsaft 2 null put
mj
gr
54 594.9863 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(pointer ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(p) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(, or a pointer to someplace inside the array, is kept) 2 buf
opsaft 2 null put
mj
gr
54 583.9452 m
gs
font0 sf
(visible to the collector during the evaluation of the expression,) j
gr
54 572.9039 m
gs
font0 sf
opsbef 0 {font0 sf} put
(even if ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(p) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( is dead after the expression is evaluated.  Note that) 2 buf
opsaft 2 null put
mj
gr
54 561.8625 m
/colwidth 239.6475 def
gs
font0 sf
(this does not necessarily inhibit any traditional optimizations.) j
gr
54 550.8214 m
/colwidth 239.6475 def
gs
font0 sf
(It may require another register to preserve the original value) j
gr
54 539.78 m
gs
font0 sf
(of p, and thus conceivably add register spill code.  \050On) j
gr
54 528.7387 m
/colwidth 239.6475 def
gs
font0 sf
(machines with only two operand instructions, it may also) j
gr
54 517.6976 m
font0 sf
(directly add a small amount of additional code.\051) s
72.06749 504.1414 m
/colwidth 221.58 def
gs
font0 sf
(Our goal is to ensure that this property is satisfied with) j
gr
54 493.1 m
/colwidth 239.6476 def
gs
font0 sf
(minimal effect on the quality of compiler generated code, and) j
gr
54 482.0588 m
/colwidth 239.6475 def
gs
font0 sf
(in such a way that it can be retrofitted to existing) j
gr
54 471.0179 m
/colwidth 239.6475 def
gs
font0 sf
(programming language implementations.  We will describe) j
gr
54 459.9765 m
/colwidth 239.6475 def
gs
font0 sf
(our algorithm for ensuring garbage-collector-safety primarily) j
gr
54 448.935 m
gs
font0 sf
(as a source-to-source transformation on C code.  We use a) j
gr
54 437.894 m
/colwidth 239.6475 def
gs
font0 sf
(source-to-source transformation both because it provides a) j
gr
54 426.8526 m
/colwidth 239.6476 def
gs
font0 sf
(convenient vehicle for explanation, and because in the short) j
gr
54 415.8113 m
/colwidth 239.6475 def
gs
font0 sf
(term it appears to be an interesting implementation strategy.) j
gr
54 404.7701 m
/colwidth 239.6475 def
gs
font0 sf
(It makes it possible to provide for the GC-safety of some) j
gr
54 393.7288 m
/colwidth 239.6475 def
gs
font0 sf
(compilers without altering the compiler at all.  Since GC-) j
gr
54 382.6875 m
/colwidth 239.6474 def
gs
font0 sf
(safety is usually not an issue for unoptimized code, we expect) j
gr
54 371.6463 m
/colwidth 239.6475 def
gs
font0 sf
(that our prepass will generally be used only in conjunction) j
gr
54 360.6051 m
/colwidth 239.6474 def
gs
font0 sf
(with the optimizer, and hence the time required to run the) j
gr
54 349.5638 m
font0 sf
(prepass is less of an issue in this context.) s
72.06749 336.0078 m
/colwidth 221.58 def
gs
font0 sf
(We make the following assumptions about the target) j
gr
54 324.9667 m
font0 sf
(compiler, in addition to the expected correctness assumptions:) s
72.06749 311.4105 m
gs
font0 sf
(0\051 Every allocation call in the source results in a) j
gr
54 300.3692 m
/colwidth 239.6475 def
gs
font0 sf
(corresponding call to an allocation function in the object code.) j
gr
54 289.3279 m
gs
font0 sf
(Every store or load to/from the heap in the object code) j
gr
54 278.2868 m
/colwidth 239.6475 def
gs
font0 sf
(corresponds to an access of or assignment to the) j
gr
54 267.2455 m
/colwidth 239.6475 def
gs
font0 sf
(corresponding object in the source.  \050There may be fewer) j
gr
54 256.2042 m
font0 sf
(loads and stores in the object code.\051) s
72.06749 242.6482 m
/colwidth 221.58 def
gs
font0 sf
(1\051 It must be possible to define a macro) j
gr
54 231.607 m
/colwidth 239.6475 def
gs
/Times-Roman findfont 9.03375 scalefont
/font2 exch def
/Times-Italic findfont 9.03375 scalefont
/font3 exch def
font0 sf
opsbef 0 {font0 sf} put
(KEEP) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(_) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(LIVE\050) 2 buf
opsaft 2 null put
font3 sf
opsbef 3 {font3 sf} put
(e,y) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
(\051, with the following semantics:) 4 buf
opsaft 4 null put
mj
gr
54 220.5658 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(KEEP) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(_) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(LIVE\050) 2 buf
opsaft 2 null put
font3 sf
opsbef 3 {font3 sf} put
(e,y) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
(\051 evaluates to the value of the pointer) 4 buf
opsaft 4 null put
mj
gr
54 209.5244 m
gs
font0 sf
opsbef 0 {font0 sf} put
(expression ) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(e) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(, but with the added constraint that the value of) 2 buf
opsaft 2 null put
mj
gr
54 198.4831 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(the pointer variable ) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(y) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( must be visible to the garbage collector) 2 buf
opsaft 2 null put
mj
gr
54 187.442 m
/colwidth 239.6476 def
gs
font0 sf
(\050i.e. treated as live\051 until the expression is completely) j
gr
54 176.4008 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(evaluated, that is until the value of ) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(e) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( is visible to the garbage) 2 buf
opsaft 2 null put
mj
gr
54 165.3595 m
gs
font0 sf
(collector.  We will augment the source program with) j
gr
54 154.3183 m
gs
font0 sf
opsbef 0 {font0 sf} put
(KEEP) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(_) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(LIVE expressions to ensure that relevant pointers are) 2 buf
opsaft 2 null put
mj
gr
54 143.277 m
font0 sf
(kept visible by the compiler.) s
72.06749 129.7209 m
/colwidth 221.58 def
gs
font0 sf
(The use of the word ``macro'' here should not be take too) j
gr
54 118.6797 m
/colwidth 239.6476 def
gs
font0 sf
(literally.  The expansion may depend on the types of the) j
gr
54 107.6384 m
/colwidth 239.6475 def
gs
font0 sf
(expressions and involve additional temporary variables.  Since) j
gr
54 96.59722 m
gs
font0 sf
(we can generate the expansion explicitly, it does not need to) j
gr
54 85.55596 m
font0 sf
(be expressible as a C macro.) s
72.06749 71.99993 m
/colwidth 221.58 def
gs
font0 sf
opsbef 0 {font0 sf} put
(2\051 The value of a KEEP) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(_) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(LIVE expression must be) 2 buf
opsaft 2 null put
mj
gr
320.6476 707.9137 m
/colwidth 239.6475 def
gs
font0 sf
(treated as opaque, in the following sense: The value must be) j
gr
320.6476 696.8724 m
/colwidth 239.6474 def
gs
font0 sf
(explicitly and continuously stored in either a GC-root or the) j
gr
320.6476 685.8312 m
gs
font0 sf
(appropriate heap object\050s\051, provided the value is used directly) j
gr
320.6476 674.79 m
/colwidth 239.6475 def
gs
font0 sf
(\050without intervening pointer arithmetic\051 in a dereference) j
gr
320.6476 663.7486 m
/colwidth 239.6475 def
gs
font0 sf
(operation, or used as the second argument of another) j
gr
320.6476 652.7074 m
gs
font0 sf
opsbef 0 {font0 sf} put
(KEEP) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(_) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(LIVE expression.  It must be visible to the collector at) 2 buf
opsaft 2 null put
mj
gr
320.6476 641.6660 m
gs
font0 sf
opsbef 0 {font0 sf} put
(all points between the evaluation of the original KEEP) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(_) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(LIVE) 2 buf
opsaft 2 null put
mj
gr
320.6476 630.625 m
gs
font0 sf
opsbef 0 {font0 sf} put
(and the final use.   Thus, if we have ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(p = ) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(KEEP) 2 buf
opsaft 2 null put
font2 sf
opsbef 3 {font2 sf} put
(_) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
(LIVE\050...\051) 4 buf
opsaft 4 null put
font1 sf
opsbef 5 {font1 sf} put
(;) 5 buf
opsaft 5 null put
mj
gr
320.6476 619.5836 m
gs
font1 sf
opsbef 0 {font1 sf} put
(q = p;) 0 buf
opsaft 0 null put
font0 sf
opsbef 1 {font0 sf} put
( ...) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
(*q) 2 buf
opsaft 2 null put
font0 sf
opsbef 3 {font0 sf} put
(..., then the result of the KEEP) 3 buf
opsaft 3 null put
font2 sf
opsbef 4 {font2 sf} put
(_) 4 buf
opsaft 4 null put
font0 sf
opsbef 5 {font0 sf} put
(LIVE) 5 buf
opsaft 5 null put
mj
gr
320.6476 608.5424 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(expression must be explicitly stored until ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(*q) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( is retrieved.) 2 buf
opsaft 2 null put
mj
gr
320.6476 597.5011 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(However, the same is not required for ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(p =) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( KEEP) 2 buf
opsaft 2 null put
font2 sf
opsbef 3 {font2 sf} put
(_) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
(LIVE\050...\051) 4 buf
opsaft 4 null put
font1 sf
opsbef 5 {font1 sf} put
(;) 5 buf
opsaft 5 null put
mj
gr
320.6476 586.46 m
/colwidth 239.6475 def
gs
font1 sf
opsbef 0 {font1 sf} put
(q = p + 4;) 0 buf
opsaft 0 null put
font0 sf
opsbef 1 {font0 sf} put
( ...) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
(*q) 2 buf
opsaft 2 null put
font0 sf
opsbef 3 {font0 sf} put
(..., since the value of ) 3 buf
opsaft 3 null put
font1 sf
opsbef 4 {font1 sf} put
(p) 4 buf
opsaft 4 null put
font0 sf
opsbef 5 {font0 sf} put
( is not dereferenced) 5 buf
opsaft 5 null put
mj
gr
320.6476 575.4186 m
/colwidth 239.6475 def
gs
font0 sf
(directly, and the pointer addition might conceivably be) j
gr
320.6476 564.3774 m
gs
font0 sf
opsbef 0 {font0 sf} put
(subject to optimization.  We can force either ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(p) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( or ) 2 buf
opsaft 2 null put
font1 sf
opsbef 3 {font1 sf} put
(q) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
( to be) 4 buf
opsaft 4 null put
mj
gr
320.6476 553.336 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(explicitly visible at all times by writing: ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(p =) 1 buf
opsaft 1 null put
mj
gr
320.6476 542.2949 m
font0 sf
(KEEP) s
font2 sf
(_) s
font0 sf
(LIVE\050...\051) s
font1 sf
(; q =) s
font0 sf
( KEEP) s
font2 sf
(_) s
font0 sf
(LIVE\050) s
font1 sf
(p + 4, p) s
font0 sf
(\051; ...) s
font1 sf
(*q) s
font0 sf
(...,) s
338.715 529.7867 m
/colwidth 221.58 def
gs
font0 sf
opsbef 0 {font0 sf} put
(Informally, KEEP) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(_) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(LIVE has two effects; it causes ) 2 buf
opsaft 2 null put
font3 sf
opsbef 3 {font3 sf} put
(y) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
( to be) 4 buf
opsaft 4 null put
mj
gr
320.6476 518.7455 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(kept live during the evaluation of ) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(e) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(, and it causes the compiler) 2 buf
opsaft 2 null put
mj
gr
320.6476 507.704 m
/colwidth 239.6475 def
gs
font0 sf
(to lose all information about how the resulting value was) j
gr
320.6476 496.6626 m
/colwidth 239.6475 def
gs
font0 sf
(computed, thus preventing it from discarding the value and) j
gr
320.6476 485.6216 m
font0 sf
(subsequently recomputing it.) s
338.715 473.1132 m
/colwidth 221.58 def
gs
font0 sf
opsbef 0 {font0 sf} put
(One way to implement KEEP) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(_) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(LIVE\050) 2 buf
opsaft 2 null put
font3 sf
opsbef 3 {font3 sf} put
(e,y) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
(\051 is as a call to an) 4 buf
opsaft 4 null put
mj
gr
320.6476 462.072 m
/colwidth 239.6475 def
gs
font0 sf
(external function whose implementation is unavailable to the) j
gr
320.6476 451.0308 m
/colwidth 239.6474 def
gs
font0 sf
(compiler for analysis, but which actually just returns its first) j
gr
320.6476 439.9894 m
/colwidth 239.6476 def
gs
font0 sf
(argument.  In all environments of which we are aware, this) j
gr
320.6476 428.9483 m
/colwidth 239.6475 def
gs
font0 sf
(will force the value to be stored explicitly \050perhaps in a) j
gr
320.6476 417.907 m
gs
font0 sf
(register\051.  The value will continue to be explicitly available) j
gr
320.6476 406.8656 m
gs
font0 sf
opsbef 0 {font0 sf} put
(through a dereference or another KEEP) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(_) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(LIVE in the) 2 buf
opsaft 2 null put
mj
gr
320.6476 395.8246 m
font0 sf
(presence of all standard compiler optimizations.) s
338.715 383.3163 m
/colwidth 221.58 def
gs
font0 sf
opsbef 0 {font0 sf} put
(This implementation of KEEP) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(_) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(LIVE is, of course,) 2 buf
opsaft 2 null put
mj
gr
320.6476 372.275 m
/colwidth 239.6475 def
gs
font0 sf
(terribly inefficient.  More efficient implementations are) j
gr
320.6476 361.2338 m
font0 sf
(suggested in [BoehmChase92], and one is described below.) s
338.715 348.7255 m
/colwidth 221.58 def
gs
font0 sf
(Our problem then is to annotate the original expression) j
gr
320.6476 337.6842 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(by replacing a number of expressions ) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(e) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( with KEEP) 2 buf
opsaft 2 null put
font2 sf
opsbef 3 {font2 sf} put
(_) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
(LIVE\050) 4 buf
opsaft 4 null put
font3 sf
opsbef 5 {font3 sf} put
(e) 5 buf
opsaft 5 null put
font0 sf
opsbef 6 {font0 sf} put
(,) 6 buf
opsaft 6 null put
font3 sf
opsbef 7 {font3 sf} put
(y) 7 buf
opsaft 7 null put
font0 sf
opsbef 8 {font0 sf} put
(\051) 8 buf
opsaft 8 null put
mj
gr
320.6476 326.643 m
gs
font0 sf
(in such a way that the above rules guarantee that every heap) j
gr
320.6476 315.6019 m
gs
font0 sf
(object is accessible via an interior pointer chain from the time) j
gr
320.6476 304.5606 m
font0 sf
(of its allocation until its last access.) s
338.715 292.0522 m
/colwidth 221.58 def
gs
font0 sf
(We will assume that allocation functions return a result) j
gr
320.6476 281.0111 m
font0 sf
(that is \050treated as\051 the value of a KEEP) s
font2 sf
(_) s
font0 sf
(LIVE expression.) s
338.715 268.5029 m
gs
font0 sf
(In order to simplify the presentation, we will assume that) j
gr
320.6476 257.4616 m
/colwidth 239.6475 def
gs
font0 sf
(the following kinds of expressions either return nonpointers) j
gr
320.6476 246.4203 m
/colwidth 239.6474 def
gs
font0 sf
(or occur as the right side of an assignment to a local variable) j
gr
320.6476 235.3791 m
/colwidth 239.6475 def
gs
font0 sf
(that is not assigned elsewhere in the same expression.  In) j
gr
320.6476 224.3378 m
gs
font0 sf
(effect, we assume that temporaries have already been) j
gr
320.6476 213.2966 m
/colwidth 239.6475 def
gs
font0 sf
(introduced, so that we can name the results of these) j
gr
320.6476 202.2553 m
font0 sf
(subexpressions:) s
338.715 189.7471 m
font0 sf
(1\051 Pointer dereferences.) s
338.715 177.2389 m
font0 sf
(2\051 Function calls.) s
338.715 164.7308 m
font0 sf
(3\051 Conditional expressions.) s
338.715 152.2226 m
font0 sf
(We will refer to these as ) s
font3 sf
(generating) s
font0 sf
( expressions.) s
338.715 139.7144 m
/colwidth 221.58 def
gs
font0 sf
(Note that the introduction of the appropriate temporaries) j
gr
320.6476 128.6732 m
/colwidth 239.6475 def
gs
font0 sf
(at source level is slightly more complex than one might like,) j
gr
320.6476 117.6319 m
font0 sf
(but it is possible.) s
338.715 105.1237 m
/colwidth 221.58 def
gs
font0 sf
(We will also assume that the only pointer dereferences) j
gr
320.6476 94.08242 m
/colwidth 239.6476 def
gs
font0 sf
opsbef 0 {font0 sf} put
(are in expressions of the form *) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(e) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(, and dereferences occur as) 2 buf
opsaft 2 null put
mj
gr
320.6476 83.04118 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(late as possible with an explicit * operator.  The ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
([]) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( and ) 2 buf
opsaft 2 null put
font1 sf
opsbef 3 {font1 sf} put
(->) 3 buf
opsaft 3 null put
mj
gr
320.6476 71.99993 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(operators occur only inside an ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(&) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( operator.  Thus the) 2 buf
opsaft 2 null put
mj
gr
gr
gr
showpage
%%page 5 5
gs
2834.646 2834.646 scale
gs
0.0254 dup matrix scale concat
0.013837 dup matrix scale concat
54 707.9137 m
/colwidth 239.6475 def
gs
/Times-Roman findfont 9.03375 scalefont
/font0 exch def
/Times-Italic findfont 9.03375 scalefont
/font1 exch def
/Times-Italic findfont 7.02625 scalefont
/font2 exch def
/Courier findfont 9.03375 scalefont
/font3 exch def
/Helvetica-Oblique findfont 9.03375 scalefont
/font4 exch def

/execget {arindex get dup null eq {pop} {exec} ifelse} bind def
/mj {                                    % mixed justify
    /excess colwidth totwidth sub def
    0 1 npiece {
        /arindex exch def
        opsbef execget                   % exec any accumu before ops
        nspaces arindex get              % stack: nspaces
        dup 0 eq {                       % stack: nspaces
            pop texts arindex get        % stack: text
            s                            % stack: NULL
            }{ 
            weights arindex get          % stack: nspaces weight
            totwt div excess mul         % stack: nspaces share-excess
            exch div 0 32                % stack: spaceadd 0 32
            texts arindex get            % stack: spaceadd 0 32 text
            widthshow                    % stack: NULL
            } ifelse
        opsaft execget                   % exec any accumulated after ops
        } for
    /totwidth 0 def /totwt 0.0 def
    } bind def
/buf {                                   % stack: text npiece
    /npiece exch def                     % stack: text
    dup nsp /ns exch def                 % stack: text
    dup texts npiece 3 -1 roll put       % stack: text
    nspaces npiece ns put width          % stack: width
    totwidth add /totwidth exch def      % stack: NULL
    ns 0 ne {
       ( ) width ns mul                  % stack: weight
       dup totwt add /totwt exch def     % stack: weight
       weights npiece 3 -1 roll put      % stack: NULL
       } if
    } bind def
/texts 250 array def
/nspaces 250 array def
/weights 250 array def
/opsbef 250 array def
/opsaft 250 array def
/totwidth 0 def
/totwt 0.0 def

font0 sf
opsbef 0 {font0 sf} put
(expressions ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(e) 1 buf
opsaft 1 null put
font2 sf
opsbef 2 {font2 sf 0 -2.0075 rmoveto} put
(1) 2 buf
opsaft 2 null put
font3 sf
opsbef 3 {0 2.0075 rmoveto font3 sf} put
([) 3 buf
opsaft 3 null put
font1 sf
opsbef 4 {font1 sf} put
(e) 4 buf
opsaft 4 null put
font2 sf
opsbef 5 {font2 sf 0 -2.0075 rmoveto} put
(2) 5 buf
opsaft 5 null put
font3 sf
opsbef 6 {0 2.0075 rmoveto font3 sf} put
(].) 6 buf
opsaft 6 null put
font1 sf
opsbef 7 {font1 sf} put
(x, ) 7 buf
opsaft 7 null put
font3 sf
opsbef 8 {font3 sf} put
(\050*) 8 buf
opsaft 8 null put
font1 sf
opsbef 9 {font1 sf} put
(e) 9 buf
opsaft 9 null put
font3 sf
opsbef 10 {font3 sf} put
(\051) 10 buf
opsaft 10 null put
font4 sf
opsbef 11 {font4 sf} put
(.) 11 buf
opsaft 11 null put
font1 sf
opsbef 12 {font1 sf} put
(x.z) 12 buf
opsaft 12 null put
font0 sf
opsbef 13 {font0 sf} put
(, and ) 13 buf
opsaft 13 null put
font1 sf
opsbef 14 {font1 sf} put
(e) 14 buf
opsaft 14 null put
font0 sf
opsbef 15 {font0 sf} put
( ) 15 buf
opsaft 15 null put
font3 sf
opsbef 16 {font3 sf} put
(->) 16 buf
opsaft 16 null put
font0 sf
opsbef 17 {font0 sf} put
( ) 17 buf
opsaft 17 null put
font1 sf
opsbef 18 {font1 sf} put
(x) 18 buf
opsaft 18 null put
font0 sf
opsbef 19 {font0 sf} put
( have been) 19 buf
opsaft 19 null put
mj
gr
54 696.8724 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(replaced by ) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(*&\050) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
(e) 2 buf
opsaft 2 null put
font2 sf
opsbef 3 {font2 sf 0 -2.0075 rmoveto} put
(1) 3 buf
opsaft 3 null put
font3 sf
opsbef 4 {0 2.0075 rmoveto font3 sf} put
([) 4 buf
opsaft 4 null put
font1 sf
opsbef 5 {font1 sf} put
(e) 5 buf
opsaft 5 null put
font2 sf
opsbef 6 {font2 sf 0 -2.0075 rmoveto} put
(2) 6 buf
opsaft 6 null put
font3 sf
opsbef 7 {0 2.0075 rmoveto font3 sf} put
(].) 7 buf
opsaft 7 null put
font1 sf
opsbef 8 {font1 sf} put
(x) 8 buf
opsaft 8 null put
font3 sf
opsbef 9 {font3 sf} put
(\051) 9 buf
opsaft 9 null put
font0 sf
opsbef 10 {font0 sf} put
(,  ) 10 buf
opsaft 10 null put
font3 sf
opsbef 11 {font3 sf} put
(*&\050) 11 buf
opsaft 11 null put
font1 sf
opsbef 12 {font1 sf} put
(e) 12 buf
opsaft 12 null put
font0 sf
opsbef 13 {font0 sf} put
( ) 13 buf
opsaft 13 null put
font3 sf
opsbef 14 {font3 sf} put
(->) 14 buf
opsaft 14 null put
font0 sf
opsbef 15 {font0 sf} put
( ) 15 buf
opsaft 15 null put
font1 sf
opsbef 16 {font1 sf} put
(x) 16 buf
opsaft 16 null put
font4 sf
opsbef 17 {font4 sf} put
(.) 17 buf
opsaft 17 null put
font1 sf
opsbef 18 {font1 sf} put
(z) 18 buf
opsaft 18 null put
font3 sf
opsbef 19 {font3 sf} put
(\051) 19 buf
opsaft 19 null put
font0 sf
opsbef 20 {font0 sf} put
( and ) 20 buf
opsaft 20 null put
font3 sf
opsbef 21 {font3 sf} put
(*&\050) 21 buf
opsaft 21 null put
font1 sf
opsbef 22 {font1 sf} put
(e) 22 buf
opsaft 22 null put
font0 sf
opsbef 23 {font0 sf} put
( ) 23 buf
opsaft 23 null put
font3 sf
opsbef 24 {font3 sf} put
(->) 24 buf
opsaft 24 null put
font0 sf
opsbef 25 {font0 sf} put
( ) 25 buf
opsaft 25 null put
font1 sf
opsbef 26 {font1 sf} put
(x) 26 buf
opsaft 26 null put
font3 sf
opsbef 27 {font3 sf} put
(\051) 27 buf
opsaft 27 null put
mj
gr
54 685.8312 m
gs
font0 sf
opsbef 0 {font0 sf} put
(respectively.  We assume expressions of the form &*) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(e) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( have) 2 buf
opsaft 2 null put
mj
gr
54 674.79 m
font0 sf
(been simplified to ) s
font1 sf
(e) s
font0 sf
(.) s
72.06749 661.6692 m
/colwidth 221.58 def
gs

/j {                                     % stack: text (justify)
    dup nsp /ns exch def                 % stack: text
    ns 0 eq {s} {                        % stack: text
        dup width /totwidth try add      % stack: text width
        colwidth exch sub                % stack: text excess
        ns div                           % stack: text spaceadd
        0 32 4 -1 roll                   % stack: spaceadd 0 32 text
        widthshow /totwidth 0 def        % stack: NULL
        } ifelse
    } bind def

font0 sf
(Again, for the purposes of the presentation, we will) j
gr
54 650.628 m
/colwidth 239.6475 def
gs
font0 sf
(ignore some compexities that must be handled by a source) j
gr
54 639.5867 m
/colwidth 239.6475 def
gs
font0 sf
(level implementation.  For example, we ignore the fact that) j
gr
54 628.5455 m
/colwidth 239.6474 def
gs
font0 sf
opsbef 0 {font0 sf} put
(the C expression ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(e) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( ) 2 buf
opsaft 2 null put
font3 sf
opsbef 3 {font3 sf} put
(->) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
( ) 4 buf
opsaft 4 null put
font1 sf
opsbef 5 {font1 sf} put
(x) 5 buf
opsaft 5 null put
font0 sf
opsbef 6 {font0 sf} put
( will not actually involve a dereference) 6 buf
opsaft 6 null put
mj
gr
54 617.5043 m
font0 sf
(if the field ) s
font1 sf
(x) s
font0 sf
( has array type.) s
54 585.7959 m
/Times-Bold findfont 11.04125 scalefont
/font5 exch def
font5 sf
(An Algorithm) s
72.06749 566.1334 m
/colwidth 221.58 def
gs
font0 sf
opsbef 0 {font0 sf} put
(We inductively define BASE\050) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(e) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(\051, for pointer valued) 2 buf
opsaft 2 null put
mj
gr
54 555.0918 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(expressions ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(e) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(, to be the pointer variable from which the value) 2 buf
opsaft 2 null put
mj
gr
54 544.0507 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(of ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(e) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( is computed, or NIL if there is no such pointer variable;) 2 buf
opsaft 2 null put
mj
gr
54 533.0093 m
gs
font0 sf
opsbef 0 {font0 sf} put
(that is we define BASE\050) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(e) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(\051 such that ) 2 buf
opsaft 2 null put
font1 sf
opsbef 3 {font1 sf} put
(e) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
( and BASE\050) 4 buf
opsaft 4 null put
font1 sf
opsbef 5 {font1 sf} put
(e) 5 buf
opsaft 5 null put
font0 sf
opsbef 6 {font0 sf} put
(\051 are) 6 buf
opsaft 6 null put
mj
gr
54 521.968 m
gs
font0 sf
opsbef 0 {font0 sf} put
(guaranteed to point to the same object whenever ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(e) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( points to a) 2 buf
opsaft 2 null put
mj
gr
54 510.9268 m
font0 sf
(heap object.) s
72.06749 497.806 m
/colwidth 221.58 def
gs
font0 sf
opsbef 0 {font0 sf} put
(This is somewhat complicated by the presence of the ) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(&) 1 buf
opsaft 1 null put
mj
gr
54 486.7647 m
/colwidth 239.6475 def
gs
font0 sf
(\050address of\051 operator.  Thus we simultaneously define) j
gr
54 475.7235 m
font0 sf
(BASEADDR\050) s
font1 sf
(e) s
font0 sf
(\051 to be the possible base pointer for ) s
font3 sf
(&) s
font1 sf
(e) s
font0 sf
(.) s
54 464.6824 m
font0 sf
(  ) s
54 451.5614 m
font0 sf
(BASE\0500\051 = NIL) s
54 440.5203 m
font0 sf
(BASE\050) s
font1 sf
(x) s
font0 sf
(\051 = ) s
font1 sf
(x) s
54 429.4791 m
font0 sf
56.46087 0 rmoveto
(if ) s
font1 sf
(x) s
font0 sf
( is a variable and possible ) s
font1 sf
(heap) s
font0 sf
( pointer) s
54 418.4378 m
font0 sf
(BASE\050) s
font1 sf
(x) s
font0 sf
( ) s
font3 sf
(=) s
font0 sf
( ) s
font1 sf
(e) s
font0 sf
(\051 = ) s
font1 sf
(x) s
54 407.3965 m
font0 sf
56.46087 0 rmoveto
(if ) s
font1 sf
(x) s
font0 sf
( is a pointer variable ) s
54 396.3552 m
font0 sf
(BASE\050) s
font1 sf
(x) s
font0 sf
( ) s
font3 sf
(=) s
font0 sf
( ) s
font1 sf
(e) s
font0 sf
(\051 = BASE\050) s
font1 sf
(e) s
font0 sf
(\051) s
54 385.314 m
font0 sf
56.46087 0 rmoveto
(if ) s
font1 sf
(x) s
font0 sf
( is not a pointer variable) s
54 374.2728 m
font0 sf
(BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
( ) s
font3 sf
(+=) s
font0 sf
( ) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(2) s
0 2.0075 rmoveto
font0 sf
(\051 = BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051) s
54 363.2315 m
font0 sf
(BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
( ) s
font3 sf
(-=) s
font0 sf
( ) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(2) s
0 2.0075 rmoveto
font0 sf
(\051 = BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051) s
54 352.1902 m
font0 sf
(BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
( ) s
font3 sf
(++) s
font0 sf
(\051 = BASE\050) s
font3 sf
(++) s
font0 sf
( ) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051 = BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051) s
54 341.1489 m
font0 sf
(BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
( ) s
font3 sf
(--) s
font0 sf
(\051 = BASE\050) s
font3 sf
(--) s
font0 sf
( ) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051 = BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051) s
54 330.1077 m
font0 sf
(BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
( ) s
font3 sf
(+) s
font0 sf
( ) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(2) s
0 2.0075 rmoveto
/Times-Roman findfont 7.02625 scalefont
/font6 exch def
font6 sf
0 -2.0075 rmoveto
(\051) s
0 2.0075 rmoveto
font0 sf
( = BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051) s
54 319.0664 m
font0 sf
56.46087 0 rmoveto
(where ) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
( is the expression with pointer type) s
54 308.0252 m
font0 sf
(BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
( ) s
font3 sf
(-) s
font0 sf
( ) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(2) s
0 2.0075 rmoveto
font6 sf
0 -2.0075 rmoveto
(\051) s
0 2.0075 rmoveto
font0 sf
( = BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051) s
54 296.9839 m
font0 sf
(BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font3 sf
(,) s
font0 sf
( ) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(2) s
0 2.0075 rmoveto
font0 sf
(\051 = BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(2) s
0 2.0075 rmoveto
font0 sf
(\051) s
54 285.9426 m
font0 sf
(BASE\050) s
font3 sf
(&) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051 = BASEADDR\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051) s
54 274.9014 m
font0 sf
56.46087 0 rmoveto
54 263.8601 m
font0 sf
(BASEADDR\050) s
font1 sf
(x) s
font0 sf
(\051 = NIL) s
54 252.8189 m
font0 sf
56.46087 0 rmoveto
(if ) s
font1 sf
(x) s
font0 sf
( is a variable) s
54 241.7776 m
font0 sf
(BASEADDR\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font3 sf
([) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(2) s
0 2.0075 rmoveto
font3 sf
(]) s
font0 sf
(\051 = BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051) s
54 230.7364 m
font0 sf
56.46087 0 rmoveto
(if BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051 is not NIL) s
54 219.6951 m
font0 sf
(BASEADDR\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font3 sf
([) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(2) s
0 2.0075 rmoveto
font3 sf
(]) s
font0 sf
(\051 = BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(2) s
0 2.0075 rmoveto
font0 sf
(\051) s
54 208.6538 m
font0 sf
56.46087 0 rmoveto
(if BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051 is NIL) s
54 197.6126 m
font0 sf
(BASEADDR\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
( ) s
font3 sf
(->) s
font0 sf
( ) s
font1 sf
(x) s
font0 sf
(\051 = BASE\050) s
font1 sf
(e) s
font2 sf
0 -2.0075 rmoveto
(1) s
0 2.0075 rmoveto
font0 sf
(\051 ) s
54 186.5714 m
font0 sf
56.46087 0 rmoveto
56.46087 0 rmoveto
56.46087 0 rmoveto
56.46087 0 rmoveto
72.06749 173.4507 m
/colwidth 221.58 def
gs
font0 sf
(Note that BASE is not defined for generating) j
gr
54 162.4095 m
/colwidth 239.6475 def
gs
font0 sf
(expressions.  Generating expressions as subexpressions need) j
gr
54 151.3682 m
/colwidth 239.6476 def
gs
font0 sf
(not otherwise be considered, since they are assumed to fall) j
gr
54 140.3269 m
/colwidth 239.6474 def
gs
font0 sf
(into the first assignment case.  BASE is also not defined for) j
gr
54 129.2857 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(expressions with ) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
([]) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( or ) 2 buf
opsaft 2 null put
font3 sf
opsbef 3 {font3 sf} put
(->) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
( as the outermost operator, since) 4 buf
opsaft 4 null put
mj
gr
54 118.2445 m
/colwidth 239.6476 def
gs
font0 sf
opsbef 0 {font0 sf} put
(they always occur inside ) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(&) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(, and hence only BASEADDR is) 2 buf
opsaft 2 null put
mj
gr
54 107.2033 m
font0 sf
(relevant.) s
72.06749 94.08247 m
/colwidth 221.58 def
gs
font0 sf
(BASEADDR is again not defined for generating) j
gr
54 83.04124 m
/colwidth 239.6475 def
gs
font0 sf
(expressions, since they are not l-values, and thus their address) j
gr
54 72 m
/colwidth 239.6476 def
gs
font0 sf
(may not be taken.  \050Pointer dereferences are l-values, but have) j
gr
320.6476 707.9137 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(been transformed so they do not occur inside an ') 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(&) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(' operator.\051) 2 buf
opsaft 2 null put
mj
gr
320.6476 696.8724 m
/colwidth 239.6475 def
gs
font0 sf
(Similarly BASEADDR is not defined for other expressions) j
gr
320.6476 685.8312 m
gs
font0 sf
opsbef 0 {font0 sf} put
(that are not l-values, such as expressions with ) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(&) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( as the) 2 buf
opsaft 2 null put
mj
gr
320.6476 674.79 m
font0 sf
(outermost operator.) s
338.715 651.522 m
/colwidth 221.58 def
gs
font0 sf
(Our algorithm is now simple to state: replace every) j
gr
320.6476 640.4808 m
/colwidth 239.6476 def
gs
font0 sf
opsbef 0 {font0 sf} put
(pointer-valued expression ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(e) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( that occurs as the right side of an) 2 buf
opsaft 2 null put
mj
gr
320.6476 629.4395 m
/colwidth 239.6475 def
gs
font0 sf
(assignment, or as the argument of a dereferencing operation,) j
gr
320.6476 618.3984 m
/colwidth 239.6474 def
gs
font0 sf
(or as a function argument or result, by the expression) j
gr
320.6476 607.3571 m
/colwidth 239.6475 def
gs
/Times-Roman findfont 9.03375 scalefont
/font7 exch def
font0 sf
opsbef 0 {font0 sf} put
(KEEP) 0 buf
opsaft 0 null put
font7 sf
opsbef 1 {font7 sf} put
(_) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(LIVE\050) 2 buf
opsaft 2 null put
font1 sf
opsbef 3 {font1 sf} put
(e) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
(, BASE\050) 4 buf
opsaft 4 null put
font1 sf
opsbef 5 {font1 sf} put
(e) 5 buf
opsaft 5 null put
font0 sf
opsbef 6 {font0 sf} put
(\051\051.  C increment and decrement) 6 buf
opsaft 6 null put
mj
gr
320.6476 596.3158 m
font0 sf
(operators are treated as assignments.) s
320.6476 551.9238 m
font5 sf
(Correctness) s
338.715 519.5769 m
/colwidth 221.58 def
gs
font0 sf
(This argument is of necessity informal, since a formal) j
gr
320.6476 508.5356 m
/colwidth 239.6475 def
gs
font0 sf
(argument would need to be based on formal semantics of) j
gr
320.6476 497.4942 m
/colwidth 239.6475 def
gs
font0 sf
(both C and at least some aspects of the target machine) j
gr
320.6476 486.4532 m
/colwidth 239.6475 def
gs
font0 sf
(language.  But we claim that it's sufficiently precise that given) j
gr
320.6476 475.4118 m
font0 sf
(both of these it would not be hard to formalize.) s
338.715 452.144 m
/colwidth 221.58 def
gs
font0 sf
opsbef 0 {font0 sf} put
(Define an object to be ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(source-reachable) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( if a pointer to the) 2 buf
opsaft 2 null put
mj
gr
320.6476 441.1025 m
/colwidth 239.6475 def
gs
font0 sf
(object can be produced by a sequence of pointer dereferences,) j
gr
320.6476 430.0612 m
/colwidth 239.6475 def
gs
font0 sf
(and \050legal ANSI C\051 pointer addition operations starting from) j
gr
320.6476 419.02 m
/colwidth 239.6475 def
gs
font0 sf
(a program variable.  We claim that there is no way to access a) j
gr
320.6476 407.9788 m
/colwidth 239.6476 def
gs
font0 sf
(previously allocated object in a strictly conforming ANSI C) j
gr
320.6476 396.9375 m
font0 sf
(program meeting our restrictions if it is not source-reachable.) s
338.715 373.6698 m
/colwidth 221.58 def
gs
font0 sf
opsbef 0 {font0 sf} put
(We define an object to be ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(GC-reachable ) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(if it can be) 2 buf
opsaft 2 null put
mj
gr
320.6476 362.6285 m
/colwidth 239.6475 def
gs
font0 sf
(reached by following a chain of addresses starting with one) j
gr
320.6476 351.5873 m
/colwidth 239.6475 def
gs
font0 sf
(stored in a GC-root, and such that every subsequent address is) j
gr
320.6476 340.546 m
font0 sf
(stored in the heap object referenced by the preceding one.) s
338.715 317.2781 m
/colwidth 221.58 def
gs
font0 sf
(Observe that any pointer value which according to the) j
gr
320.6476 306.2368 m
/colwidth 239.6476 def
gs
font0 sf
(source semantics should be stored in a program variable or in) j
gr
320.6476 295.1956 m
/colwidth 239.6475 def
gs
font0 sf
(the heap is explicitly stored either in the GC-roots or in the) j
gr
320.6476 284.1544 m
gs
font0 sf
(corresponding heap object until its final access.  This follows) j
gr
320.6476 273.113 m
/colwidth 239.6475 def
gs
font0 sf
(from the fact that all pointer values are generated by) j
gr
320.6476 262.0718 m
font0 sf
(KEEP) s
font7 sf
(_) s
font0 sf
(LIVE expressions.) s
338.715 238.8039 m
/colwidth 221.58 def
gs
font0 sf
(Assume that at some point before the final access to) j
gr
320.6476 227.7627 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(object ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(P) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(, it becomes GC-unreachable.  Consider the path to ) 2 buf
opsaft 2 null put
font1 sf
opsbef 3 {font1 sf} put
(P) 3 buf
opsaft 3 null put
mj
gr
320.6476 216.7215 m
/colwidth 239.6475 def
gs
font0 sf
(along which the last access takes place.  Consider the first) j
gr
320.6476 205.6803 m
/colwidth 239.6476 def
gs
font0 sf
opsbef 0 {font0 sf} put
(object ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(Q) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( in this path to become GC-unreachable.  Since the) 2 buf
opsaft 2 null put
mj
gr
320.6476 194.639 m
gs
font0 sf
opsbef 0 {font0 sf} put
(last access to ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(Q) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( has not yet taken place, according to the) 2 buf
opsaft 2 null put
mj
gr
320.6476 183.5977 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(preceding observation, a pointer to ) 0 buf
opsaft 0 null put
font1 sf
opsbef 1 {font1 sf} put
(Q) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( must be source-) 2 buf
opsaft 2 null put
mj
gr
320.6476 172.5565 m
gs
font0 sf
(reachable.  Hence it must have been generated by a) j
gr
320.6476 161.5153 m
gs
font0 sf
opsbef 0 {font0 sf} put
(KEEP) 0 buf
opsaft 0 null put
font7 sf
opsbef 1 {font7 sf} put
(_) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(LIVE expression, and the result of this KEEP) 2 buf
opsaft 2 null put
font7 sf
opsbef 3 {font7 sf} put
(_) 3 buf
opsaft 3 null put
font0 sf
opsbef 4 {font0 sf} put
(LIVE) 4 buf
opsaft 4 null put
mj
gr
320.6476 150.474 m
/colwidth 239.6475 def
gs
font0 sf
(expression will be subsequently referenced.  Hence it should) j
gr
320.6476 139.4328 m
gs
font0 sf
(be explicitly stored in a GC-root or in the preceding heap) j
gr
320.6476 128.3916 m
font0 sf
(object along the chain.  Thus we obtain a contradiction.) s
338.715 105.1237 m
/colwidth 221.58 def
gs
font0 sf
(Hence objects remain GC-accessible until the final) j
gr
320.6476 94.08242 m
/colwidth 239.6475 def
gs
font0 sf
(access.  Since all accesses in the object code correspond to) j
gr
320.6476 83.04118 m
/colwidth 239.6476 def
gs
font0 sf
(accesses in the source, it follows  that the object code cannot) j
gr
320.6476 71.99993 m
font0 sf
(access collected objects.) s
gr
gr
showpage
%%page 6 6
gs
2834.646 2834.646 scale
gs
0.0254 dup matrix scale concat
0.013837 dup matrix scale concat
54 707.9137 m
/Times-Bold findfont 11.04125 scalefont
/font0 exch def
font0 sf
(Optimizations) s
72.06749 689.6682 m
/colwidth 221.58 def
gs
/Times-Roman findfont 9.03375 scalefont
/font1 exch def

/j {                                     % stack: text (justify)
    dup nsp /ns exch def                 % stack: text
    ns 0 eq {s} {                        % stack: text
        dup width /totwidth try add      % stack: text width
        colwidth exch sub                % stack: text excess
        ns div                           % stack: text spaceadd
        0 32 4 -1 roll                   % stack: spaceadd 0 32 text
        widthshow /totwidth 0 def        % stack: NULL
        } ifelse
    } bind def

font1 sf
(The above algorithm is somewhat deficient in several) j
gr
54 678.6272 m
font1 sf
(respects:) s
54 666.6405 m
font1 sf
(1.) s
2.27951 0 rmoveto
(It inserts many unnecessary ) s
/Courier findfont 9.03375 scalefont
/font2 exch def
font2 sf
(KEEP) s
/Times-Roman findfont 9.03375 scalefont
/font3 exch def
font3 sf
(_) s
font2 sf
(LIVE) s
font1 sf
( calls.  There is) s
60 655.5991 m
font1 sf
(clearly no reason to replace the assignment ) s
font2 sf
(p = q) s
font1 sf
( by ) s
font2 sf
(p =) s
60 644.5576 m
font2 sf
(KEEP) s
font3 sf
(_) s
font2 sf
(LIVE\050q, q\051) s
font1 sf
(. ) s
54 632.5714 m
font1 sf
9.033735 0 rmoveto
(This is primarily a problem of compilation speed and) s
60 621.53 m
font1 sf
(compactness of the intermediate representation. It can be) s
60 610.4889 m
font1 sf
(easily avoided by keeping track of whether or not an) s
60 599.4474 m
font1 sf
(expression result is statically known to be simply a copy of a) s
60 588.4063 m
font1 sf
(value logically stored elsewhere.  If it is, then condition \0502\051) s
60 577.365 m
font1 sf
(from the definition of ) s
font2 sf
(KEEP) s
font3 sf
(_) s
font2 sf
(LIVE) s
font1 sf
( guarantees that there is) s
60 566.3235 m
font1 sf
(no need to add the ) s
font2 sf
(KEEP) s
font3 sf
(_) s
font2 sf
(LIVE) s
font1 sf
(.) s
60 555.2824 m
font1 sf
9.033735 0 rmoveto
54 543.2957 m
font1 sf
(2.) s
2.27951 0 rmoveto
(Certain C expressions are difficult to transform at source) s
60 532.2545 m
font1 sf
(level.  In general, a pointer expression ) s
/Times-Italic findfont 9.03375 scalefont
/font4 exch def
font4 sf
(e) s
font2 sf
(++) s
font1 sf
( should be) s
60 521.2131 m
font1 sf
(transformed to  ) s
font2 sf
(\050tmp1 = &\050) s
font4 sf
(e) s
font2 sf
(\051, tmp2 = *tmp1,) s
60 510.1719 m
font2 sf
(*tmp1 = tmp2 + 1, tmp2\051) s
font1 sf
( before inserting) s
60 499.1308 m
font2 sf
(KEEP) s
font3 sf
(_) s
font2 sf
(LIVE) s
font1 sf
( calls.  But this should be optimized to \050) s
font2 sf
(tmp =) s
60 488.0895 m
font2 sf
(\050) s
font4 sf
(e) s
font2 sf
(\051) s
font1 sf
(, ) s
font2 sf
(\050) s
font4 sf
(e) s
font2 sf
(\051) s
font1 sf
( = ) s
font2 sf
(tmp) s
font1 sf
( + 1) s
font2 sf
(, tmp\051) s
font1 sf
( if  ) s
font4 sf
(e) s
font1 sf
( is a simple variable that) s
60 477.0482 m
font1 sf
(might be register allocated, to avoid forcing ) s
font4 sf
(e) s
font1 sf
( to memory.) s
60 466.007 m
font1 sf
(This problem is very likely to disappear if the) s
60 454.9657 m
font1 sf
(transformation is made on intermediate code.) s
54 442.9791 m
font1 sf
(3.) s
2.27951 0 rmoveto
(The choice of base pointer variables may significantly) s
60 431.9379 m
font1 sf
(impact the optimizations that can still be performed by the) s
60 420.8966 m
font1 sf
(compiler.  Consider the canonical string copying loop in C:) s
54 408.91 m
font2 sf
44.2653 0 rmoveto
(p = s; q = t;) s
54 397.8687 m
font2 sf
44.2653 0 rmoveto
(while \050*p++ = *q++\051;) s
54 385.882 m
font1 sf
9.033735 0 rmoveto
(After the above optimizations, we would transform the loop) s
60 374.841 m
font1 sf
(to:) s
54 362.8541 m
54 350.8675 m
font2 sf
44.2653 0 rmoveto
(while\050) s
11.06628 0 rmoveto
(*\050tmpa = p,) s
54 339.8262 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(  p = KEEP) s
font3 sf
(_) s
font2 sf
(LIVE\050tmpa+1,) s
54 328.785 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(  ) s
33.19898 0 rmoveto
(        tmpa\051,) s
54 317.7437 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(  tmpa\051) s
54 306.7024 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(= *\050tmpb = q,) s
54 295.6613 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(    q = KEEP) s
font3 sf
(_) s
font2 sf
(LIVE\050tmpb +1,) s
54 284.62 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(    ) s
22.13263 0 rmoveto
44.2653 0 rmoveto
(  tmpb\051,) s
54 273.5786 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(    tmpb\051\051;) s
54 262.5373 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
44.2653 0 rmoveto
44.2653 0 rmoveto
54 250.5508 m
font1 sf
9.033735 0 rmoveto
(This is correct, and really specifies the same operations as) s
60 239.5096 m
font1 sf
(the original, though less concisely.  But it forces the values of) s
60 228.4684 m
font2 sf
(p) s
font1 sf
( and ) s
font2 sf
(q) s
font1 sf
( to explicitly appear in a register.  This prevents the) s
60 217.427 m
font1 sf
(C optimizer from translating the pointer arithmetic back to) s
60 206.3858 m
font1 sf
(indexed loads based on ) s
font2 sf
(s) s
font1 sf
( and ) s
font2 sf
(t) s
font1 sf
(, which is profitable on some) s
60 195.3446 m
font1 sf
(machines that allow a free addition in the load instruction) s
60 184.3034 m
font1 sf
(\050) s
font4 sf
(e.g.) s
font1 sf
( SPARC\051.) s
54 172.3166 m
font1 sf
9.033735 0 rmoveto
(A good heuristic appears to be to replace base pointers in) s
60 161.2755 m
font1 sf
(KEEP) s
font3 sf
(_) s
font1 sf
(LIVE expressions by equivalent, but less rapidly) s
60 150.2342 m
font1 sf
(varying base pointers, especially if those are likely to be live) s
60 139.193 m
font1 sf
(in any case.  With a small amount of analysis we can) s
60 128.1517 m
font1 sf
(generate the following less constraining code instead:) s
60 117.1104 m
font1 sf
9.033735 0 rmoveto
54 105.1238 m
font2 sf
44.2653 0 rmoveto
(while\050) s
11.06628 0 rmoveto
(*\050tmpa =) s
( ) s
(p) s
(,) s
54 94.08257 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(  ) s
(p) s
( = ) s
(KEEP) s
font3 sf
(_) s
font2 sf
(LIVE\050tmpa+1,) s
54 83.04132 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(  ) s
33.19898 0 rmoveto
44.2653 0 rmoveto
(s\051,) s
54 72.00006 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(  tmpa\051) s
320.6476 707.9137 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(= ) s
(*\050) s
(tmpb =) s
( ) s
(q) s
(,) s
320.6476 696.8724 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(    ) s
(q) s
( = ) s
(KEEP) s
font3 sf
(_) s
font2 sf
(LIVE\050tmpb +1) s
(,) s
320.6476 685.8312 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(    ) s
22.13263 0 rmoveto
44.2653 0 rmoveto
(  ) s
(t\051,) s
320.6476 674.79 m
font2 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(    tmpb\051\051;) s
320.6476 650.4849 m
320.6476 626.1795 m
font1 sf
(4.) s
2.27951 0 rmoveto
(So far, all transformations are safe in a multi-threaded) s
326.6476 615.138 m
font1 sf
(environment, with an asynchronously triggered collector.  If) s
326.6476 604.0968 m
font1 sf
(we know that garbage collections can be triggered only at) s
326.6476 593.0556 m
font1 sf
(procedure calls, the number of ) s
font2 sf
(KEEP) s
font3 sf
(_) s
font2 sf
(LIVE) s
font1 sf
( invocations) s
326.6476 582.0142 m
font1 sf
(could often be reduced dramatically.) s
320.6476 536.3256 m
font0 sf
(Debugging Applications) s
338.715 502.6819 m
gs

/execget {arindex get dup null eq {pop} {exec} ifelse} bind def
/mj {                                    % mixed justify
    /excess colwidth totwidth sub def
    0 1 npiece {
        /arindex exch def
        opsbef execget                   % exec any accumu before ops
        nspaces arindex get              % stack: nspaces
        dup 0 eq {                       % stack: nspaces
            pop texts arindex get        % stack: text
            s                            % stack: NULL
            }{ 
            weights arindex get          % stack: nspaces weight
            totwt div excess mul         % stack: nspaces share-excess
            exch div 0 32                % stack: spaceadd 0 32
            texts arindex get            % stack: spaceadd 0 32 text
            widthshow                    % stack: NULL
            } ifelse
        opsaft execget                   % exec any accumulated after ops
        } for
    /totwidth 0 def /totwt 0.0 def
    } bind def
/buf {                                   % stack: text npiece
    /npiece exch def                     % stack: text
    dup nsp /ns exch def                 % stack: text
    dup texts npiece 3 -1 roll put       % stack: text
    nspaces npiece ns put width          % stack: width
    totwidth add /totwidth exch def      % stack: NULL
    ns 0 ne {
       ( ) width ns mul                  % stack: weight
       dup totwt add /totwt exch def     % stack: weight
       weights npiece 3 -1 roll put      % stack: NULL
       } if
    } bind def
/texts 250 array def
/nspaces 250 array def
/weights 250 array def
/opsbef 250 array def
/opsaft 250 array def
/totwidth 0 def
/totwt 0.0 def

font1 sf
opsbef 0 {font1 sf} put
(The above annotation scheme inserts a KEEP) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(_) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
(LIVE call) 2 buf
opsaft 2 null put
mj
gr
320.6476 491.6404 m
/colwidth 239.6475 def
gs
font1 sf
(around every pointer arithmetic expression.  In order to check) j
gr
320.6476 480.5991 m
/colwidth 239.6474 def
gs
font1 sf
(that a pointer never leaves the object to which it points, it) j
gr
320.6476 469.5577 m
/colwidth 239.6475 def
gs
font1 sf
(suffices to ensure that the expression \050the first argument to) j
gr
320.6476 458.5166 m
gs
font1 sf
opsbef 0 {font1 sf} put
(KEEP) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(_) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
(LIVE\051 always points to the same object as the base) 2 buf
opsaft 2 null put
mj
gr
320.6476 447.4754 m
/colwidth 239.6476 def
gs
font1 sf
opsbef 0 {font1 sf} put
(pointer \050the second argument to KEEP) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(_) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
(LIVE\051.  \050If we use a) 2 buf
opsaft 2 null put
mj
gr
320.6476 436.434 m
/colwidth 239.6475 def
gs
font1 sf
opsbef 0 {font1 sf} put
(single KEEP) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(_) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
(LIVE call around more than one arithmetic) 2 buf
opsaft 2 null put
mj
gr
320.6476 425.3929 m
gs
font1 sf
(operation, the intermediate results may not be valid.  But the) j
gr
320.6476 414.3516 m
/colwidth 239.6476 def
gs
font1 sf
opsbef 0 {font1 sf} put
(equivalent program with KEEP) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(_) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
(LIVE calls will still be safe in) 2 buf
opsaft 2 null put
mj
gr
320.6476 403.3103 m
font1 sf
(the presence of a collector.\051) s
338.715 379.005 m
/colwidth 221.58 def
gs
font1 sf
(Thus we can convert our GC-safety preprocessor to a) j
gr
320.6476 367.9636 m
/colwidth 239.6475 def
gs
font1 sf
(pointer arithmetic checker by simply replacing the) j
gr
320.6476 356.9224 m
/colwidth 239.6476 def
gs
font1 sf
opsbef 0 {font1 sf} put
(KEEP) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(_) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
(LIVE call with a function call that does the) 2 buf
opsaft 2 null put
mj
gr
320.6476 345.8812 m
/colwidth 239.6475 def
gs
font1 sf
opsbef 0 {font1 sf} put
(appropriate checking.  For example, assuming ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(p) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
( is a character) 2 buf
opsaft 2 null put
mj
gr
320.6476 334.84 m
/colwidth 239.6475 def
gs
font1 sf
opsbef 0 {font1 sf} put
(pointer, the expression ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(p + 1) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
( will be transformed by the) 2 buf
opsaft 2 null put
mj
gr
320.6476 323.7986 m
font1 sf
(debugging mode preprocessor to) s
320.6476 299.4934 m
font2 sf
(   \050char \050*\051\051 GC_same_obj\050\050void *\051\050\050p+1\051\051,) s
320.6476 288.452 m
font2 sf
(   ) s
27.6658 0 rmoveto
44.2653 0 rmoveto
44.2653 0 rmoveto
(  \050void *\051\050p\051\051\051) s
320.6476 277.4109 m
font2 sf
(   ) s
338.715 253.1055 m
/colwidth 221.58 def
gs
font1 sf
opsbef 0 {font1 sf} put
(Here ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(GC) 1 buf
opsaft 1 null put
font3 sf
opsbef 2 {font3 sf} put
(_) 2 buf
opsaft 2 null put
font2 sf
opsbef 3 {font2 sf} put
(same) 3 buf
opsaft 3 null put
font3 sf
opsbef 4 {font3 sf} put
(_) 4 buf
opsaft 4 null put
font2 sf
opsbef 5 {font2 sf} put
(obj ) 5 buf
opsaft 5 null put
font1 sf
opsbef 6 {font1 sf} put
(is a real function which takes the) 6 buf
opsaft 6 null put
mj
gr
320.6476 242.0642 m
/colwidth 239.6475 def
gs
font1 sf
opsbef 0 {font1 sf} put
(place of KEEP) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(_) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
(LIVE.  It checks that both arguments point to) 2 buf
opsaft 2 null put
mj
gr
320.6476 231.023 m
gs
font1 sf
(the same object, and the returns the first argument.  Since the) j
gr
320.6476 219.9818 m
/colwidth 239.6475 def
gs
font1 sf
(definition of this function is not available to the compiler, The) j
gr
320.6476 208.9405 m
/colwidth 239.6475 def
gs
font1 sf
opsbef 0 {font1 sf} put
(call to ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(GC_same_obj) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
( will simultaneously have the intended) 2 buf
opsaft 2 null put
mj
gr
320.6476 197.8993 m
font1 sf
(effect of the KEEP) s
font3 sf
(_) s
font1 sf
(LIVE call.) s
338.715 173.5941 m
/colwidth 221.58 def
gs
font1 sf
(Our pointer arithmetic checking is not dependent on the) j
gr
320.6476 162.5528 m
/colwidth 239.6475 def
gs
font1 sf
opsbef 0 {font1 sf} put
(exact type of a pointer.  If we cast a ``) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(struct A *) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
('' to) 2 buf
opsaft 2 null put
mj
gr
320.6476 151.5115 m
/colwidth 239.6476 def
gs
font1 sf
opsbef 0 {font1 sf} put
(``) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(struct B *) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
('', accesses to fields of the resulting pointer) 2 buf
opsaft 2 null put
mj
gr
320.6476 140.4702 m
/colwidth 239.6475 def
gs
font1 sf
(will be checked to verify that they are within the allocated) j
gr
320.6476 129.429 m
gs
font1 sf
(object.  \050As mentioned above, the only possible exception at) j
gr
320.6476 118.3878 m
/colwidth 239.6475 def
gs
font1 sf
opsbef 0 {font1 sf} put
(this stage is an access to an entire substructure of ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(B) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
( that is only) 2 buf
opsaft 2 null put
mj
gr
320.6476 107.3465 m
/colwidth 239.6475 def
gs
font1 sf
(partially within the allocated object.  That would need) j
gr
320.6476 96.30527 m
font1 sf
(additional checking code.\051 ) s
320.6476 71.99994 m
gr
gr
showpage
%%page 7 7
gs
2834.646 2834.646 scale
gs
0.0254 dup matrix scale concat
0.013837 dup matrix scale concat
54 707.9137 m
/Times-Bold findfont 11.04125 scalefont
/font0 exch def
font0 sf
(An Implementation) s
72.06749 689.285 m
/colwidth 221.58 def
gs
/Times-Roman findfont 9.03375 scalefont
/font1 exch def

/j {                                     % stack: text (justify)
    dup nsp /ns exch def                 % stack: text
    ns 0 eq {s} {                        % stack: text
        dup width /totwidth try add      % stack: text width
        colwidth exch sub                % stack: text excess
        ns div                           % stack: text spaceadd
        0 32 4 -1 roll                   % stack: spaceadd 0 32 text
        widthshow /totwidth 0 def        % stack: NULL
        } ifelse
    } bind def

font1 sf
(We have built a GC-safe compiler for ANSI C \050plus) j
gr
54 678.2439 m
/colwidth 239.6475 def
gs
font1 sf
(some GNU extensions\051 by writing a C-to-C preprocessor that) j
gr
54 667.2025 m
/colwidth 239.6475 def
gs
font1 sf
(annotates the input program as described in the previous) j
gr
54 656.1613 m
/colwidth 239.6474 def
gs
font1 sf
(sections.  The output for GC-safety is initially specific to gcc,) j
gr
54 645.12 m
/colwidth 239.6476 def
gs
font1 sf
(i.e. the resulting code is safe only when compiled by gcc.  Gcc) j
gr
54 634.0787 m
/colwidth 239.6475 def
gs
font1 sf
(dependencies are highly localized, so it should be possible to) j
gr
54 623.0375 m
/colwidth 239.6476 def
gs
font1 sf
(accommodate other compilers in the future.  It should be) j
gr
54 611.9961 m
/colwidth 239.6475 def
gs
font1 sf
(possible to make the output in source-code-checking mode) j
gr
54 600.955 m
font1 sf
(usable with any ANSI C compiler.) s
72.06749 588.6616 m
/colwidth 221.58 def
gs
font1 sf
(The preprocessor could conceivably be used directly with) j
gr
54 577.6202 m
/colwidth 239.6475 def
gs
font1 sf
(a C++ implementation that first translates to C.  Or a similar) j
gr
54 566.5789 m
gs
font1 sf
(strategy could be applied at the intermediate code level inside) j
gr
54 555.5379 m
font1 sf
(a C++ compiler.) s
72.06749 543.2444 m
/colwidth 221.58 def
gs
/Courier findfont 9.03375 scalefont
/font2 exch def
/Times-Roman findfont 9.03375 scalefont
/font3 exch def

/execget {arindex get dup null eq {pop} {exec} ifelse} bind def
/mj {                                    % mixed justify
    /excess colwidth totwidth sub def
    0 1 npiece {
        /arindex exch def
        opsbef execget                   % exec any accumu before ops
        nspaces arindex get              % stack: nspaces
        dup 0 eq {                       % stack: nspaces
            pop texts arindex get        % stack: text
            s                            % stack: NULL
            }{ 
            weights arindex get          % stack: nspaces weight
            totwt div excess mul         % stack: nspaces share-excess
            exch div 0 32                % stack: spaceadd 0 32
            texts arindex get            % stack: spaceadd 0 32 text
            widthshow                    % stack: NULL
            } ifelse
        opsaft execget                   % exec any accumulated after ops
        } for
    /totwidth 0 def /totwt 0.0 def
    } bind def
/buf {                                   % stack: text npiece
    /npiece exch def                     % stack: text
    dup nsp /ns exch def                 % stack: text
    dup texts npiece 3 -1 roll put       % stack: text
    nspaces npiece ns put width          % stack: width
    totwidth add /totwidth exch def      % stack: NULL
    ns 0 ne {
       ( ) width ns mul                  % stack: weight
       dup totwt add /totwt exch def     % stack: weight
       weights npiece 3 -1 roll put      % stack: NULL
       } if
    } bind def
/texts 250 array def
/nspaces 250 array def
/weights 250 array def
/opsbef 250 array def
/opsaft 250 array def
/totwidth 0 def
/totwt 0.0 def

font1 sf
opsbef 0 {font1 sf} put
(We implement the ``) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(KEEP) 1 buf
opsaft 1 null put
font3 sf
opsbef 2 {font3 sf} put
(_) 2 buf
opsaft 2 null put
font2 sf
opsbef 3 {font2 sf} put
(LIVE) 3 buf
opsaft 3 null put
font1 sf
opsbef 4 {font1 sf} put
('' primitive by taking) 4 buf
opsaft 4 null put
mj
gr
54 532.2034 m
/colwidth 239.6475 def
gs
font1 sf
(advantage of gcc's flexible syntax for inline assembly code.) j
gr
54 521.1622 m
/colwidth 239.6476 def
gs
font1 sf
(Assembly code can reference the value of a C expression,) j
gr
54 510.1207 m
/colwidth 239.6474 def
gs
font1 sf
(which may be requested to be available in a register or) j
gr
54 499.0796 m
/colwidth 239.6475 def
gs
font1 sf
opsbef 0 {font1 sf} put
(memory location.  Thus ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(KEEP) 1 buf
opsaft 1 null put
font3 sf
opsbef 2 {font3 sf} put
(_) 2 buf
opsaft 2 null put
font2 sf
opsbef 3 {font2 sf} put
(LIVE) 3 buf
opsaft 3 null put
font1 sf
opsbef 4 {font1 sf} put
( generates an empty) 4 buf
opsaft 4 null put
mj
gr
54 488.0382 m
/colwidth 239.6475 def
gs
font1 sf
(assembly code sequence, depending on both arguments.  It) j
gr
54 476.997 m
/colwidth 239.6475 def
gs
font1 sf
(requests that the first argument be assigned the same location) j
gr
54 465.9555 m
font1 sf
(as the result.  See below for details.) s
72.06749 453.6625 m
/colwidth 221.58 def
gs
font1 sf
(Only optimizations \0501\051 and \0502\051 from above are) j
gr
54 442.6212 m
/colwidth 239.6476 def
gs
font1 sf
(implemented.  However we do expand certain C constructs,) j
gr
54 431.58 m
/colwidth 239.6475 def
gs
font1 sf
(particularly increment and decrement operations, in more) j
gr
54 420.5387 m
/colwidth 239.6476 def
gs
font1 sf
opsbef 0 {font1 sf} put
(specialized ways than suggested above.  For example, if ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(p) 1 buf
opsaft 1 null put
font1 sf
opsbef 2 {font1 sf} put
( is a) 2 buf
opsaft 2 null put
mj
gr
54 409.4975 m
/colwidth 239.6475 def
gs
font1 sf
(character pointer, then in debugging mode the expression) j
gr
54 398.4562 m
font2 sf
(++p ) s
font1 sf
(is expanded to) s
54 387.415 m
font1 sf
(  ) s
54 375.1216 m
font2 sf
( \050\050char \050*\051\051) s
54 364.0805 m
font2 sf
(     GC_pre_incr\050&\050p\051,) s
54 353.0392 m
font2 sf
( ) s
38.73214 0 rmoveto
44.2653 0 rmoveto
( sizeof\050char\051*\050+\0501\051\051\051\051) s
54 341.998 m
font2 sf
(  ) s
72.06749 329.7047 m
/colwidth 221.58 def
gs
font1 sf
opsbef 0 {font1 sf} put
(Here ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(GC) 1 buf
opsaft 1 null put
font3 sf
opsbef 2 {font3 sf} put
(_) 2 buf
opsaft 2 null put
font2 sf
opsbef 3 {font2 sf} put
(pre) 3 buf
opsaft 3 null put
font3 sf
opsbef 4 {font3 sf} put
(_) 4 buf
opsaft 4 null put
font2 sf
opsbef 5 {font2 sf} put
(incr) 5 buf
opsaft 5 null put
font1 sf
opsbef 6 {font1 sf} put
( is a function performing the) 6 buf
opsaft 6 null put
mj
gr
54 318.6634 m
/colwidth 239.6475 def
gs
font1 sf
(equivalent of a pre-increment operation which also checks) j
gr
54 307.6222 m
font1 sf
(that the result points to the original object.) s
72.06749 295.329 m
/colwidth 221.58 def
gs
font1 sf
(It is highly desirable to run this preprocessor between the) j
gr
54 284.2876 m
/colwidth 239.6475 def
gs
font1 sf
(normal C preprocessor \050macro-expander\051 and the C compiler.) j
gr
54 273.2464 m
/colwidth 239.6475 def
gs
font1 sf
(In this way arbitrary macros are handled correctly and the) j
gr
54 262.2051 m
/colwidth 239.6475 def
gs
font1 sf
(preprocessor is not normally visible during debugging.  Hence) j
gr
54 251.164 m
gs
font2 sf
opsbef 0 {font2 sf} put
(KEEP) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(_) 1 buf
opsaft 1 null put
font2 sf
opsbef 2 {font2 sf} put
(LIVE) 2 buf
opsaft 2 null put
font1 sf
opsbef 3 {font1 sf} put
( is not generated as a macro call; instead its) 3 buf
opsaft 3 null put
mj
gr
54 240.1227 m
font1 sf
(expansion is generated directly. ) s
72.06749 227.8294 m
/colwidth 221.58 def
gs
font1 sf
(Our preprocessor maintains a copy of the input file) j
gr
54 216.7883 m
/colwidth 239.6475 def
gs
font1 sf
(\050including the source line information generated by the C) j
gr
54 205.747 m
/colwidth 239.6475 def
gs
font1 sf
(preprocessor\051.  It parses and partially type-checks the source.) j
gr
54 194.7056 m
/colwidth 239.6475 def
gs
font1 sf
(In the process it generates a list of insertions and deletions,) j
gr
54 183.6644 m
/colwidth 239.6475 def
gs
font1 sf
(sorted by character position in the original source string.) j
gr
54 172.6232 m
gs
font1 sf
(After parsing is complete,  the insertions and deletions are) j
gr
54 161.582 m
gs
font1 sf
(applied to the original source.  The yacc/bison grammar and) j
gr
54 150.5407 m
font1 sf
(scanner were derived from their gcc equivalents.) s
72.06749 138.2474 m
/colwidth 221.58 def
gs
font1 sf
(We do not actually transform dereference operators as) j
gr
54 127.2062 m
/colwidth 239.6475 def
gs
font1 sf
opsbef 0 {font1 sf} put
(described above.  Instead we defer generating ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(KEEP) 1 buf
opsaft 1 null put
font3 sf
opsbef 2 {font3 sf} put
(_) 2 buf
opsaft 2 null put
font2 sf
opsbef 3 {font2 sf} put
(LIVE) 3 buf
opsaft 3 null put
font1 sf
opsbef 4 {font1 sf} put
(s) 4 buf
opsaft 4 null put
mj
gr
54 116.1649 m
/colwidth 239.6476 def
gs
font1 sf
(until enough of the context has been seen to determine the) j
gr
54 105.1237 m
/colwidth 239.6475 def
gs
font1 sf
(correct transformation.  This again introduces complexity) j
gr
54 94.08247 m
/colwidth 239.6475 def
gs
font1 sf
(which is solely the result of the source level implementation,) j
gr
54 83.04118 m
gs
font1 sf
(and wouldn't be necessary if the transformation were done at) j
gr
54 71.99994 m
font1 sf
(a lower level.) s
338.715 707.9137 m
/colwidth 221.58 def
gs
font1 sf
(We have not attempted to tune the performance of the) j
gr
320.6476 696.8724 m
/colwidth 239.6474 def
gs
font1 sf
(preprocessor to reduce compile time.  But for our purposes) j
gr
320.6476 685.8312 m
/colwidth 239.6475 def
gs
font1 sf
(that hasn't been a significant issue.  \050In fact we have yet to) j
gr
320.6476 674.79 m
/colwidth 239.6475 def
gs
font1 sf
(compile the preprocessor with optimization enabled or) j
gr
320.6476 663.7486 m
gs
font1 sf
(assertion checking disabled.\051  It should be much faster than) j
gr
320.6476 652.7074 m
font1 sf
(the rest of the compilation process, and certainly is no slower.) s
320.6476 621.3051 m
font0 sf
(Performance) s
338.715 601.948 m
/colwidth 221.58 def
gs
font1 sf
(We measured a small collection of small-to-medium-) j
gr
320.6476 590.9068 m
/colwidth 239.6476 def
gs
font1 sf
(sized C programs, mostly drawn from the Zorn benchmark) j
gr
320.6476 579.8653 m
/colwidth 239.6475 def
gs
font1 sf
(suite[DetlefsDosserZorn93].  All of these programs are very) j
gr
320.6476 568.8242 m
font1 sf
(pointer and allocation intensive.) s
338.715 555.948 m
/colwidth 221.58 def
gs
font1 sf
(Standard C libraries were not preprocessed.  This is) j
gr
320.6476 544.9068 m
/colwidth 239.6474 def
gs
font1 sf
(probably not unrealistic since the critical pieces are likely to) j
gr
320.6476 533.8653 m
gs
font1 sf
(be either hand assembly coded, or manually checked for GC-) j
gr
320.6476 522.8243 m
/colwidth 239.6476 def
gs
font1 sf
(safety or, failing that, thoroughly tested for GC-safety of the) j
gr
320.6476 511.783 m
font1 sf
(normally optimized version.) s
338.715 498.907 m
font1 sf
(The programs measured were:) s
320.6476 486.0308 m
/Times-Bold findfont 9.03375 scalefont
/font4 exch def
font4 sf
(cordtest) s
font1 sf
(: 5 Iterations of the test normally distributed with our) s
326.6476 474.9895 m
font1 sf
(``cord'' string package.  This was run with our garbage) s
326.6476 463.9484 m
font1 sf
(collector.   The string package and the test program were) s
326.6476 452.907 m
font1 sf
(processed.  No part of the garbage collector itself was.  We) s
326.6476 441.8656 m
font1 sf
(uncovered and fixed one benign pointer arithmetic bug in) s
326.6476 430.8245 m
font1 sf
(the measurement process.  \0502100 lines, excluding the) s
326.6476 419.7833 m
font1 sf
(collector\051 ) s
320.6476 406.9072 m
font4 sf
(cfrac) s
font1 sf
(: A factoring program.  The smallest member \0506000 lines\051) s
326.6476 395.8659 m
font1 sf
(of Ben Zorn's benchmark collection.  It was run with the) s
326.6476 384.8246 m
font1 sf
(second largest input supplied by Zorn, and linked with the) s
326.6476 373.7833 m
font1 sf
(default malloc/free implementation.  Hence pointer) s
326.6476 362.7422 m
font1 sf
(arithmetic checking was not operational.  \050The numbers for) s
326.6476 351.701 m
font1 sf
(unoptimized program execution are not included, since the) s
326.6476 340.6596 m
font1 sf
(program makes use of explicit function inlining in a way that) s
326.6476 329.6184 m
font1 sf
(does not appear to be immediately compatible with) s
326.6476 318.5772 m
font1 sf
(unoptimized compilation by gcc 2.5.8.\051) s
320.6476 305.7012 m
font4 sf
(gawk) s
font1 sf
(: Version 2.11 of the GNU awk interpreter.  This is the) s
326.6476 294.6598 m
font1 sf
(second smallest member of the Zorn benchmark suite \0508500) s
326.6476 283.6184 m
font1 sf
(lines\051.  It was linked with the default malloc/free) s
326.6476 272.5773 m
font1 sf
(implementation and run with the second largest input) s
326.6476 261.5361 m
font1 sf
(supplied by Zorn.  \050We also ran this linked against our) s
326.6476 250.4947 m
font1 sf
(garbage collector in an attempt to get a another data point) s
326.6476 239.4535 m
font1 sf
(for the cost of pointer arithmetic checking.  It ran correctly) s
326.6476 228.4123 m
font1 sf
(without checking.  With checking enabled, it immediately) s
326.6476 217.371 m
font1 sf
(and correctly detected a pointer arithmetic error which was) s
326.6476 206.3298 m
font1 sf
(also an array access error.  After fixing that and uncovering) s
326.6476 195.2884 m
font1 sf
(two more abuses of pointer arithmetic we gave up.  Some of) s
326.6476 184.2473 m
font1 sf
(these problems would have been avoided with a more recent) s
326.6476 173.2061 m
font1 sf
(version of gawk.  It did however serve to test the pointer) s
326.6476 162.1648 m
font1 sf
(arithmetic checking code.\051 ) s
320.6476 149.2887 m
font4 sf
(gs) s
font1 sf
(: Ghostscript, as distributed with the Zorn benchmark suite) s
326.6476 138.2475 m
font1 sf
(\05029500 lines\051.  This was linked to use our garbage collector.) s
326.6476 127.2062 m
font1 sf
(\050In the SPARCstation 2 tests, only the version with pointer) s
326.6476 116.1649 m
font1 sf
(arithmetic checking used the garbage collector.\051  The) s
326.6476 105.1237 m
font1 sf
(Ghostscript custom allocator was disabled.  It was run with) s
326.6476 94.08247 m
font1 sf
(the second largest supplied input file.  No pointer arithmetic) s
326.6476 83.04124 m
font1 sf
(errors were found.  This is probably due to a combination of) s
326.6476 72 m
font1 sf
(an unusually clean coding style and the fact that most heap) s
gr
gr
showpage
%%page 8 8
gs
2834.646 2834.646 scale
gs
0.0254 dup matrix scale concat
0.013837 dup matrix scale concat
60 712.9361 m
/Times-Roman findfont 9.03375 scalefont
/font0 exch def
font0 sf
(objects have prepended standard headers.  Thus a pointer to) s
60 701.8947 m
font0 sf
(one before the body of the object would not be discovered.) s
60 690.8536 m
font0 sf
(It also could not confuse the garbage collector.) s
72.06749 678.3643 m
/colwidth 221.58 def
gs

/j {                                     % stack: text (justify)
    dup nsp /ns exch def                 % stack: text
    ns 0 eq {s} {                        % stack: text
        dup width /totwidth try add      % stack: text width
        colwidth exch sub                % stack: text excess
        ns div                           % stack: text spaceadd
        0 32 4 -1 roll                   % stack: spaceadd 0 32 text
        widthshow /totwidth 0 def        % stack: NULL
        } ifelse
    } bind def

font0 sf
(All programs were compiled with gcc 2.5.8 and timed on) j
gr
54 667.323 m
/colwidth 239.6475 def
gs
font0 sf
(a Weitek-processor SPARCstation 2 running SunOS 4.1.4, a) j
gr
54 656.2817 m
gs
font0 sf
(SPARCStation 10 running Solaris 2.5, and a Pentium 90) j
gr
54 645.2407 m
/colwidth 239.6475 def
gs
font0 sf
(running Linux 1.81.  \050The SPARCStation 2 tests were run) j
gr
54 634.1992 m
/colwidth 239.6474 def
gs
font0 sf
(with a slightly older version of the preprocessor, but should be) j
gr
54 623.1579 m
/colwidth 239.6476 def
gs
font0 sf
(comparable.\051  We give slowdown percentages relative to the) j
gr
54 612.1166 m
/colwidth 239.6475 def
gs
font0 sf
(unpreprocessed optimized version for the same code) j
gr
54 601.0755 m
gs
font0 sf
(preprocessed for GC-safety, the fully debuggable \050and hence) j
gr
54 590.0344 m
/colwidth 239.6475 def
gs
font0 sf
(probably guaranteed safe\051 code, and debuggable code) j
gr
54 578.993 m
font0 sf
(preprocessed to insert pointer arithmetic checks:) s
54 567.9516 m
font0 sf
(  ) s
54 555.4624 m
font0 sf
(SPARCstation 2:) s
54 544.4211 m
font0 sf
56.46087 0 rmoveto
/Times-Italic findfont 9.03375 scalefont
/font1 exch def
font1 sf
(-O, safe) s
font0 sf
27.08014 0 rmoveto
font1 sf
(-g) s
font0 sf
48.83339 0 rmoveto
(-) s
font1 sf
(g, checked) s
54 533.3798 m
/Times-Bold findfont 9.03375 scalefont
/font2 exch def
font2 sf
(cordtest) s
font0 sf
25.39687 0 rmoveto
(9%) s
45.1687 0 rmoveto
(54%) s
40.65182 0 rmoveto
(514%) s
54 522.3384 m
font2 sf
(cfrac) s
font0 sf
37.25363 0 rmoveto
(17%) s
40.65182 0 rmoveto
/Times-Roman findfont 7.02625 scalefont
/font3 exch def
font3 sf
(<needs modifications due to inlining>) s
54 511.2973 m
font2 sf
(gawk) s
font0 sf
36.70256 0 rmoveto
(8%) s
45.1687 0 rmoveto
(25%) s
40.65182 0 rmoveto
font3 sf
(<fails>) s
54 500.2561 m
font2 sf
(gs) s
font0 sf
48.27933 0 rmoveto
(0%) s
45.1687 0 rmoveto
(33%) s
40.65182 0 rmoveto
(205%) s
54 489.2148 m
font0 sf
(  ) s
54 476.7254 m
font0 sf
(SPARC 10:) s
54 465.6842 m
font0 sf
56.46087 0 rmoveto
font1 sf
(-O2, safe) s
font0 sf
22.56326 0 rmoveto
font1 sf
(-g) s
font0 sf
48.83339 0 rmoveto
(-) s
font1 sf
(g, checked) s
54 454.6429 m
font2 sf
(cordtest) s
font0 sf
25.39687 0 rmoveto
(9%) s
45.1687 0 rmoveto
(56%) s
40.65182 0 rmoveto
(529%) s
54 443.6016 m
font2 sf
(cfrac) s
font0 sf
37.25363 0 rmoveto
(8%) s
45.1687 0 rmoveto
(-) s
font3 sf
53.35028 0 rmoveto
(-) s
54 432.5604 m
font2 sf
(gawk) s
font0 sf
36.70256 0 rmoveto
(8%) s
45.1687 0 rmoveto
(48%) s
40.65182 0 rmoveto
(-) s
54 421.5192 m
font2 sf
(gs) s
font0 sf
48.27933 0 rmoveto
(5%) s
45.1687 0 rmoveto
(37%) s
40.65182 0 rmoveto
(366%) s
54 410.4778 m
font0 sf
(  ) s
54 397.9885 m
font0 sf
(Pentium 90: ) s
54 385.4992 m
font0 sf
56.46087 0 rmoveto
font1 sf
(-O2, safe) s
font0 sf
22.56326 0 rmoveto
font1 sf
(-g) s
font0 sf
48.83339 0 rmoveto
(-) s
font1 sf
(g, checked) s
54 374.4578 m
font2 sf
(cordtest) s
font0 sf
25.39687 0 rmoveto
(12%) s
40.65182 0 rmoveto
(28%) s
40.65182 0 rmoveto
(510%) s
54 363.4166 m
font2 sf
(cfrac) s
font0 sf
37.25363 0 rmoveto
(11%) s
40.65182 0 rmoveto
(-) s
53.35028 0 rmoveto
(-) s
54 352.3754 m
font2 sf
(gawk) s
font0 sf
36.70256 0 rmoveto
(9%) s
45.1687 0 rmoveto
(41%) s
40.65182 0 rmoveto
(-) s
54 341.3341 m
font2 sf
(gs) s
font0 sf
48.27933 0 rmoveto
(6%) s
45.1687 0 rmoveto
(17%) s
40.65182 0 rmoveto
(279%) s
72.06749 328.8448 m
72.06749 316.3555 m
/colwidth 221.58 def
gs
font0 sf
(Early attempts at measurement suggest that all such) j
gr
54 305.3143 m
/colwidth 239.6475 def
gs
font0 sf
(timing results are somewhat suspect due to cache effects.  At) j
gr
54 294.273 m
gs
font0 sf
(one point, while measuring a dynamically linked executable) j
gr
54 283.2317 m
gs
font0 sf
(on a SPARCStation 10, we saw a consistent factor of 2) j
gr
54 272.1905 m
gs
font0 sf
(difference between two copies of the same executable.  We) j
gr
54 261.1492 m
gs
font0 sf
(subsequently attempted to minimize such effects. For) j
gr
54 250.1079 m
/colwidth 239.6475 def
gs
font0 sf
(example, the SPARCStation 10 and Pentium 90 numbers) j
gr
54 239.0667 m
gs
font0 sf
(refer to an average of several runs of several copies of the) j
gr
54 228.0253 m
/colwidth 239.6475 def
gs
font0 sf
(executable, with the highest running time discarded.  We) j
gr
54 216.9842 m
gs
font0 sf
(avoided dynamic libraries on the SPARCStation 10, which) j
gr
54 205.9428 m
gs
font0 sf
(seemed to add significant variation.  The resulting average) j
gr
54 194.9016 m
/colwidth 239.6475 def
gs
font0 sf
(execution times appear to be reproducible to within 1 or 2%,) j
gr
54 183.8605 m
/colwidth 239.6475 def
gs
font0 sf
(though individual execution times still occasionally varied by) j
gr
54 172.8192 m
/colwidth 239.6475 def
gs
font0 sf
(more than 10%.  The measurements remained more or less) j
gr
54 161.7779 m
gs
font0 sf
(constant through the last several rounds of bug fixes to the) j
gr
54 150.7367 m
font0 sf
(preprocessor.) s
54 139.6954 m
gs
font0 sf
(  To obtain a more robust, though perhaps less relevant) j
gr
54 128.6542 m
gs
font0 sf
(measure, we also measured SPARC object code expansions) j
gr
54 117.613 m
/colwidth 239.6475 def
gs
font0 sf
(with and without preprocessing.  These numbers include only) j
gr
54 106.5717 m
/colwidth 239.6475 def
gs
font0 sf
(the code that was actually processed, not the standard) j
gr
54 95.53043 m
font0 sf
(libraries:) s
54 84.48921 m
font0 sf
(    ) s
54 71.99985 m
font1 sf
56.46087 0 rmoveto
(-O2, safe) s
font0 sf
22.56326 0 rmoveto
font1 sf
(-g) s
font0 sf
48.83339 0 rmoveto
(-) s
font1 sf
(g, checked) s
320.6476 707.9137 m
font2 sf
(cordtest) s
font0 sf
25.39687 0 rmoveto
(9%) s
45.1687 0 rmoveto
(69%) s
40.65182 0 rmoveto
(130%) s
320.6476 696.8724 m
font2 sf
(cfrac) s
font0 sf
37.25363 0 rmoveto
(6%) s
font3 sf
45.1687 0 rmoveto
(-) s
54.0415 0 rmoveto
(-) s
320.6476 685.8312 m
font2 sf
(gawk) s
font0 sf
36.70256 0 rmoveto
(15%) s
40.65182 0 rmoveto
(68%) s
font3 sf
40.65182 0 rmoveto
(-) s
320.6476 674.79 m
font2 sf
(gs) s
font0 sf
48.27933 0 rmoveto
(19%) s
40.65182 0 rmoveto
(73%) s
40.65182 0 rmoveto
(160%) s
320.6476 663.7486 m
font0 sf
(  ) s
338.715 651.5523 m
/colwidth 221.58 def
gs
font0 sf
(Note that the first two columns could be expected to be) j
gr
320.6476 640.5108 m
/colwidth 239.6475 def
gs
font0 sf
(somewhat indicative of execution times outside of libraries.) j
gr
320.6476 629.4698 m
gs
font0 sf
(The last column, on the other hand, grossly understates) j
gr
320.6476 618.4286 m
gs
font0 sf
(dynamic instruction counts, since additional procedure calls) j
gr
320.6476 607.3871 m
font0 sf
(are introduced.) s
320.6476 576.8342 m
/Times-Bold findfont 11.04125 scalefont
/font4 exch def
font4 sf
(Analysis ) s
338.715 558.3265 m
/colwidth 221.58 def
gs
font0 sf
(To understand the reasons for the performance cost, it is) j
gr
320.6476 547.2851 m
font0 sf
(instructive to look at a very simple C function:) s
320.6476 535.0886 m
/Courier findfont 9.03375 scalefont
/font5 exch def
font5 sf
33.87653 0 rmoveto
(char f\050char *x\051) s
320.6476 524.0474 m
font5 sf
33.87653 0 rmoveto
({) s
320.6476 513.0062 m
font5 sf
33.87653 0 rmoveto
(    return\050x[1]\051;) s
320.6476 501.9649 m
font5 sf
33.87653 0 rmoveto
(}) s
338.715 489.7684 m
gs
font0 sf
(The body is translated by our preprocessor to the) j
gr
320.6476 478.7272 m
/colwidth 239.6475 def
gs
font0 sf
(following code, which is not normally intended for human) j
gr
320.6476 467.6857 m
font0 sf
(consumption:) s
320.6476 455.4894 m
font5 sf
(    return\050\050*\050{ typeof\050char \051 * ) s
/Times-Roman findfont 9.03375 scalefont
/font6 exch def
font6 sf
(__) s
font5 sf
(result;;) s
320.6476 444.448 m
font5 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(asm\050\042 \042: \042=r\042 \050) s
font6 sf
(__) s
font5 sf
(result\051 :) s
320.6476 433.4068 m
font5 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(    \0420\042 \050&\050x[1]\051\051,) s
320.6476 422.3654 m
font5 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(    \042rfmi\042 \050x\051\051;) s
320.6476 411.3243 m
font5 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
font6 sf
(__) s
font5 sf
(result;}\051\051\051; ) s
320.6476 400.283 m
font5 sf
44.2653 0 rmoveto
44.2653 0 rmoveto
(   ) s
338.715 388.0864 m
/colwidth 221.58 def
gs
font0 sf
(This uses a gcc specific extension to introduce an) j
gr
320.6476 377.0454 m
/colwidth 239.6475 def
gs

/execget {arindex get dup null eq {pop} {exec} ifelse} bind def
/mj {                                    % mixed justify
    /excess colwidth totwidth sub def
    0 1 npiece {
        /arindex exch def
        opsbef execget                   % exec any accumu before ops
        nspaces arindex get              % stack: nspaces
        dup 0 eq {                       % stack: nspaces
            pop texts arindex get        % stack: text
            s                            % stack: NULL
            }{ 
            weights arindex get          % stack: nspaces weight
            totwt div excess mul         % stack: nspaces share-excess
            exch div 0 32                % stack: spaceadd 0 32
            texts arindex get            % stack: spaceadd 0 32 text
            widthshow                    % stack: NULL
            } ifelse
        opsaft execget                   % exec any accumulated after ops
        } for
    /totwidth 0 def /totwt 0.0 def
    } bind def
/buf {                                   % stack: text npiece
    /npiece exch def                     % stack: text
    dup nsp /ns exch def                 % stack: text
    dup texts npiece 3 -1 roll put       % stack: text
    nspaces npiece ns put width          % stack: width
    totwidth add /totwidth exch def      % stack: NULL
    ns 0 ne {
       ( ) width ns mul                  % stack: weight
       dup totwt add /totwt exch def     % stack: weight
       weights npiece 3 -1 roll put      % stack: NULL
       } if
    } bind def
/texts 250 array def
/nspaces 250 array def
/weights 250 array def
/opsbef 250 array def
/opsaft 250 array def
/totwidth 0 def
/totwt 0.0 def

font0 sf
opsbef 0 {font0 sf} put
(expression local variable ) 0 buf
opsaft 0 null put
font6 sf
opsbef 1 {font6 sf} put
(__) 1 buf
opsaft 1 null put
font5 sf
opsbef 2 {font5 sf} put
(result,) 2 buf
opsaft 2 null put
font0 sf
opsbef 3 {font0 sf} put
( and then inserts an) 3 buf
opsaft 3 null put
mj
gr
320.6476 366.004 m
gs
font0 sf
(empty assembly instruction with the constraint that the) j
gr
320.6476 354.9628 m
gs
font0 sf
opsbef 0 {font0 sf} put
(address ) 0 buf
opsaft 0 null put
font5 sf
opsbef 1 {font5 sf} put
(&\050x[1]\051) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( must occupy the same location as the) 2 buf
opsaft 2 null put
mj
gr
320.6476 343.9216 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(output operand ) 0 buf
opsaft 0 null put
font6 sf
opsbef 1 {font6 sf} put
(__) 1 buf
opsaft 1 null put
font5 sf
opsbef 2 {font5 sf} put
(result) 2 buf
opsaft 2 null put
font0 sf
opsbef 3 {font0 sf} put
(.  The assembly instruction has an) 3 buf
opsaft 3 null put
mj
gr
320.6476 332.8803 m
/colwidth 239.6475 def
gs
font0 sf
opsbef 0 {font0 sf} put
(unused second argument ) 0 buf
opsaft 0 null put
font5 sf
opsbef 1 {font5 sf} put
(x) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(, which may be stored anywhere.) 2 buf
opsaft 2 null put
mj
gr
320.6476 321.839 m
font0 sf
(Finally ) s
font6 sf
(__) s
font5 sf
(result) s
font0 sf
( is dereferenced.) s
338.715 309.6424 m
/colwidth 221.58 def
gs
font0 sf
(The SPARC code generated by gcc -O2 for the return) j
gr
320.6476 298.6012 m
font0 sf
(expression is:) s
320.6476 287.56 m
font0 sf
(   ) s
320.6476 275.3635 m
font5 sf
44.2653 0 rmoveto
(add %o0,1,%g2) s
320.6476 264.3223 m
font5 sf
44.2653 0 rmoveto
(! empty assembly instruction here) s
320.6476 253.2809 m
font5 sf
44.2653 0 rmoveto
(ldsb [%g2],%o0 ) s
320.6476 242.2397 m
font5 sf
(   ) s
320.6476 230.0432 m
font0 sf
(    In contrast, the normal optimized code is simply) s
320.6476 219.002 m
font0 sf
(    ) s
320.6476 206.8054 m
font5 sf
44.2653 0 rmoveto
(ldsb [%o0+1],%o0 ) s
320.6476 195.7641 m
font5 sf
44.2653 0 rmoveto
338.715 183.5677 m
gs
font0 sf
(Note that both versions are perfectly safe in the presence) j
gr
320.6476 172.5264 m
/colwidth 239.6475 def
gs
font0 sf
(of a garbage collector.  The problem is that the empty) j
gr
320.6476 161.4852 m
/colwidth 239.6475 def
gs
font0 sf
(assembly instruction introduced an explicit program point at) j
gr
320.6476 150.4439 m
gs
font0 sf
(which the pointer addition must have been completed, but the) j
gr
320.6476 139.4027 m
/colwidth 239.6475 def
gs
font0 sf
(load instruction cannot have been completed, since the) j
gr
320.6476 128.3614 m
/colwidth 239.6475 def
gs
font0 sf
(compiler views it as depending on the result of the assembly) j
gr
320.6476 117.3202 m
/colwidth 239.6476 def
gs
font0 sf
(instruction.  Hence there is no way to take advantage of the) j
gr
320.6476 106.279 m
gs
font0 sf
(index arithmetic in the load instruction.  Similar problems) j
gr
320.6476 95.2377 m
/colwidth 239.6475 def
gs
font0 sf
(occur with pure pointer arithmetic.  Together these account) j
gr
320.6476 84.19642 m
font0 sf
(for a majority of the overhead.) s
338.715 71.99994 m
/colwidth 221.58 def
gs
font0 sf
(This observation is consistent with the measurements) j
gr
gr
gr
showpage
%%page 9 9
gs
2834.646 2834.646 scale
gs
0.0254 dup matrix scale concat
0.013837 dup matrix scale concat
54 707.9137 m
/colwidth 239.6476 def
gs
/Times-Roman findfont 9.03375 scalefont
/font0 exch def

/j {                                     % stack: text (justify)
    dup nsp /ns exch def                 % stack: text
    ns 0 eq {s} {                        % stack: text
        dup width /totwidth try add      % stack: text width
        colwidth exch sub                % stack: text excess
        ns div                           % stack: text spaceadd
        0 32 4 -1 roll                   % stack: spaceadd 0 32 text
        widthshow /totwidth 0 def        % stack: NULL
        } ifelse
    } bind def

font0 sf
(from the preceding section.  If the overhead were primarily) j
gr
54 696.8724 m
/colwidth 239.6475 def
gs
font0 sf
(due to additional register pressure and hence register spills,) j
gr
54 685.8312 m
gs
font0 sf
(one would have expected much more substantial performance) j
gr
54 674.79 m
gs
font0 sf
(degradation on the Intel Pentium machine, which has) j
gr
54 663.7486 m
font0 sf
(substantially fewer registers than the SPARC-based machines.) s
72.06749 651.0655 m
/colwidth 221.58 def
gs
font0 sf
(Thus it is safe to assume that most of the slowdown is) j
gr
54 640.0244 m
/colwidth 239.6475 def
gs
font0 sf
(caused by our somewhat naive implementation, and is not an) j
gr
54 628.983 m
/colwidth 239.6475 def
gs
font0 sf
(inherent cost of garbage-collector-safety.  The next section) j
gr
54 617.942 m
/colwidth 239.6475 def
gs
font0 sf
(explores the possibility of eliminating much of this spurious) j
gr
54 606.9007 m
gs
font0 sf
(overhead, and thus getting better bounds on the unavoidable) j
gr
54 595.8596 m
font0 sf
(overhead.) s
54 564.6984 m
/Times-Bold findfont 11.04125 scalefont
/font1 exch def
font1 sf
(A Postprocessor ) s
72.06749 545.5828 m
/colwidth 221.58 def
gs
font0 sf
(The above suggests that much of the decrease in object) j
gr
54 534.5414 m
/colwidth 239.6475 def
gs
font0 sf
(code performance could be eliminated with some peephole) j
gr
54 523.5 m
gs
font0 sf
(optimizations.  To test this hypothesis, we built a simple) j
gr
54 512.459 m
/colwidth 239.6475 def
gs
font0 sf
(peephole optimizer that operates on the SPARC assembly) j
gr
54 501.4178 m
/colwidth 239.6476 def
gs
font0 sf
(code level.  \050The code was derived from a simple SPARC 1/2) j
gr
54 490.3765 m
/colwidth 239.6475 def
gs
font0 sf
(instruction scheduler [Boehm94].\051 It first performs a simple) j
gr
54 479.3352 m
gs
font0 sf
(global, intraprocedural analysis that allows us to identify) j
gr
54 468.2940 m
/colwidth 239.6474 def
gs
font0 sf
(possible uses of register values.  It subsequently looks for one) j
gr
54 457.2527 m
/colwidth 239.6475 def
gs
font0 sf
(of the following three patterns inside each basic block and) j
gr
54 446.2113 m
font0 sf
(transforms them appropriately:) s
54 433.5283 m
font0 sf
(1\051) s
54 422.4872 m
/Courier findfont 9.03375 scalefont
/font2 exch def
font2 sf
33.87653 0 rmoveto
(add  x,y,z) s
12.42133 0 rmoveto
(==>) s
17.27701 0 rmoveto
(...) s
54 411.446 m
font2 sf
33.87653 0 rmoveto
(...) s
17.27701 0 rmoveto
33.87653 0 rmoveto
33.87653 0 rmoveto
(ld [x+y]) s
54 400.4048 m
font2 sf
33.87653 0 rmoveto
(ld    [z], ...) s
54 389.3634 m
54 378.322 m
font2 sf
(2\051) s
54 367.2807 m
font2 sf
33.87653 0 rmoveto
(mov  x,z) s
23.48767 0 rmoveto
(==>) s
17.27701 0 rmoveto
(...) s
54 356.2396 m
font2 sf
33.87653 0 rmoveto
(...) s
17.27701 0 rmoveto
33.87653 0 rmoveto
33.87653 0 rmoveto
(...x...) s
54 345.1983 m
font2 sf
33.87653 0 rmoveto
(...z...) s
54 334.1571 m
54 323.1158 m
font2 sf
(3\051) s
54 312.0746 m
font2 sf
33.87653 0 rmoveto
(add  x,y,z) s
12.42133 0 rmoveto
(==>) s
17.27701 0 rmoveto
(...) s
54 301.0333 m
font2 sf
33.87653 0 rmoveto
(...) s
17.27701 0 rmoveto
33.87653 0 rmoveto
33.87653 0 rmoveto
(add x,y,w) s
54 289.992 m
font2 sf
33.87653 0 rmoveto
(mov  z,w) s
54 278.9508 m
font2 sf
33.87653 0 rmoveto
72.06749 266.2679 m
/colwidth 221.58 def
gs
font0 sf
(Not all of the safety constraints are listed here.  An) j
gr
54 255.2267 m
/colwidth 239.6475 def
gs

/execget {arindex get dup null eq {pop} {exec} ifelse} bind def
/mj {                                    % mixed justify
    /excess colwidth totwidth sub def
    0 1 npiece {
        /arindex exch def
        opsbef execget                   % exec any accumu before ops
        nspaces arindex get              % stack: nspaces
        dup 0 eq {                       % stack: nspaces
            pop texts arindex get        % stack: text
            s                            % stack: NULL
            }{ 
            weights arindex get          % stack: nspaces weight
            totwt div excess mul         % stack: nspaces share-excess
            exch div 0 32                % stack: spaceadd 0 32
            texts arindex get            % stack: spaceadd 0 32 text
            widthshow                    % stack: NULL
            } ifelse
        opsaft execget                   % exec any accumulated after ops
        } for
    /totwidth 0 def /totwt 0.0 def
    } bind def
/buf {                                   % stack: text npiece
    /npiece exch def                     % stack: text
    dup nsp /ns exch def                 % stack: text
    dup texts npiece 3 -1 roll put       % stack: text
    nspaces npiece ns put width          % stack: width
    totwidth add /totwidth exch def      % stack: NULL
    ns 0 ne {
       ( ) width ns mul                  % stack: weight
       dup totwt add /totwt exch def     % stack: weight
       weights npiece 3 -1 roll put      % stack: NULL
       } if
    } bind def
/texts 250 array def
/nspaces 250 array def
/weights 250 array def
/opsbef 250 array def
/opsaft 250 array def
/totwidth 0 def
/totwt 0.0 def

font0 sf
opsbef 0 {font0 sf} put
(important one is that the register ) 0 buf
opsaft 0 null put
font2 sf
opsbef 1 {font2 sf} put
(z) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
( should have no other uses.) 2 buf
opsaft 2 null put
mj
gr
54 244.1854 m
/colwidth 239.6474 def
gs
/Times-Roman findfont 9.03375 scalefont
/font3 exch def
font0 sf
opsbef 0 {font0 sf} put
(For this purpose, we arranged for the KEEP) 0 buf
opsaft 0 null put
font3 sf
opsbef 1 {font3 sf} put
(_) 1 buf
opsaft 1 null put
font0 sf
opsbef 2 {font0 sf} put
(LIVE expansion) 2 buf
opsaft 2 null put
mj
gr
54 233.1442 m
/colwidth 239.6476 def
gs
font0 sf
(to introduce a use of the second argument right after the) j
gr
54 222.1028 m
/colwidth 239.6475 def
gs
font0 sf
(evaluation of the first argument.  \050It generated a special) j
gr
54 211.0616 m
/colwidth 239.6475 def
gs
font0 sf
(comment understood by the peephole optimizer.\051  The) j
gr
54 200.0204 m
font0 sf
(arguments that these preserve GC safety are as follows:) s
54 187.3374 m
font0 sf
(1\051 If the other safety constraints for this transformation are) s
60 176.2962 m
font0 sf
(obeyed, then ) s
font2 sf
(x) s
font0 sf
( and ) s
font2 sf
(y) s
font0 sf
( remain where they were originally) s
60 165.2549 m
font0 sf
(live.  The transformation could not apply if ) s
font2 sf
(z) s
font0 sf
( were originally) s
60 154.2137 m
font0 sf
(mentioned as the second argument of a KEEP) s
font3 sf
(_) s
font0 sf
(LIVE.  All) s
60 143.1724 m
font0 sf
(other values remain live in the same ranges as before.) s
60 132.1312 m
font0 sf
(Hence we cannot invalidate KEEP) s
font3 sf
(_) s
font0 sf
(LIVE semantics. ) s
54 119.4483 m
font0 sf
(2\051 The same values remain live at all program points,) s
60 108.407 m
font0 sf
(assuming the already necessary safety constraint that ) s
font2 sf
(x) s
font0 sf
( is not) s
60 97.36577 m
font0 sf
(overridden. ) s
54 84.68282 m
font0 sf
(3\051 The same argument as \0501\051. ) s
72.06749 71.99991 m
/colwidth 221.58 def
gs
font0 sf
(We do not reassign registers or reschedule the resulting) j
gr
320.6476 707.9137 m
font0 sf
(code.) s
338.715 685.5996 m
gs
font0 sf
(On a SPARC 10, the execution time and code size) j
gr
320.6476 674.5585 m
/colwidth 239.6475 def
gs
font0 sf
(degradations from the fully optimized normally compiled) j
gr
320.6476 663.5172 m
font0 sf
(code were reduced to:) s
320.6476 652.4758 m
font0 sf
(  ) s
320.6476 630.1618 m
font0 sf
56.46087 0 rmoveto
/Times-Italic findfont 9.03375 scalefont
/font4 exch def
font4 sf
(running time) s
font0 sf
7.797607 0 rmoveto
font4 sf
(code size) s
320.6476 619.1207 m
/Times-Bold findfont 9.03375 scalefont
/font5 exch def
font5 sf
(cordtest) s
font0 sf
25.39687 0 rmoveto
(4%) s
45.1687 0 rmoveto
(3%) s
320.6476 608.0793 m
font5 sf
(cfrac) s
font0 sf
37.25363 0 rmoveto
(2%) s
45.1687 0 rmoveto
(3%) s
320.6476 597.038 m
font5 sf
(gawk) s
font0 sf
36.70256 0 rmoveto
(1%) s
45.1687 0 rmoveto
(7%) s
320.6476 585.9967 m
font5 sf
(gs) s
font0 sf
48.27933 0 rmoveto
(2%) s
45.1687 0 rmoveto
(7%) s
320.6476 574.9556 m
font0 sf
(  ) s
338.715 552.6415 m
/colwidth 221.58 def
gs
font0 sf
(Based on manual inspection of the remaining code, it) j
gr
320.6476 541.6 m
/colwidth 239.6475 def
gs
font0 sf
(appears that this is still significantly worse than what could be) j
gr
320.6476 530.5588 m
gs
font0 sf
(done with a more precise analysis.  It appeared that many of) j
gr
320.6476 519.5176 m
gs
font0 sf
(the remaining source of overhead were still basically of the) j
gr
320.6476 508.4762 m
/colwidth 239.6475 def
gs
font0 sf
(above form, but had been transformed sufficiently by the) j
gr
320.6476 497.435 m
gs
font0 sf
(optimizer that they were not as easily recognizable, often) j
gr
320.6476 486.3938 m
font0 sf
(because that would have required more global analysis.) s
320.6476 443.194 m
font1 sf
(Extensions) s
338.715 412.0392 m
/colwidth 221.58 def
gs
font0 sf
(It is possible to extend this approach to a collector which) j
gr
320.6476 400.998 m
/colwidth 239.6475 def
gs
font0 sf
(considers interior pointers as valid only if they originate from) j
gr
320.6476 389.9565 m
/colwidth 239.6476 def
gs
font0 sf
(the stack or registers \050another possible operating mode of our) j
gr
320.6476 378.9155 m
/colwidth 239.6475 def
gs
font0 sf
(collector\051.  This requires asserting that the client program) j
gr
320.6476 367.8742 m
/colwidth 239.6476 def
gs
font0 sf
(stores only pointers to the base of an object in the heap or in) j
gr
320.6476 356.8329 m
/colwidth 239.6475 def
gs
font0 sf
(statically allocated variables.  It would again be possible to) j
gr
320.6476 345.7916 m
gs
font0 sf
(insert dynamic checks to verify this.  This avoids some) j
gr
320.6476 334.7504 m
gs
font0 sf
(complications with allocating large objects as discussed in) j
gr
320.6476 323.7091 m
/colwidth 239.6475 def
gs
font0 sf
([Boehm93].  However it interacts suboptimally with C++) j
gr
320.6476 312.6679 m
/colwidth 239.6475 def
gs
font0 sf
(compilers that use interior pointers as part of their multiple) j
gr
320.6476 301.6267 m
font0 sf
(inheritance implementation.) s
320.6476 258.4268 m
font1 sf
(Acknowledgements) s
338.715 227.272 m
/colwidth 221.58 def
gs
font0 sf
(Some of this grew out of prior work with David Chase) j
gr
320.6476 216.2308 m
font0 sf
(and extensive discussion with John Ellis.) s
338.715 193.9167 m
gs
font0 sf
(Rhonda Reese made an earlier version of gcc GC-safe,) j
gr
320.6476 182.8755 m
/colwidth 239.6475 def
gs
font0 sf
(based on a much earlier approach.  That effort convinced me) j
gr
320.6476 171.8343 m
/colwidth 239.6475 def
gs
font0 sf
(that a source-level approach was interesting, at least in the) j
gr
320.6476 160.793 m
font0 sf
(short-term.) s
338.715 138.4789 m
/colwidth 221.58 def
gs
font0 sf
(Extensive news group discussions, primarily with Henry) j
gr
320.6476 127.4377 m
/colwidth 239.6474 def
gs
font0 sf
(Baker, helped to persuade me to pursue this issue more) j
gr
320.6476 116.3964 m
font0 sf
(aggressively.) s
338.715 94.08234 m
/colwidth 221.58 def
gs
font0 sf
(The reviewers provided many useful comments.  Much) j
gr
320.6476 83.0411 m
/colwidth 239.6475 def
gs
font0 sf
(of this would not have been possible without the availability) j
gr
320.6476 71.99985 m
font0 sf
(of the GNU C compiler.) s
gr
gr
showpage
%%page 10 10
gs
2834.646 2834.646 scale
gs
0.0254 dup matrix scale concat
0.013837 dup matrix scale concat
54 707.9137 m
/Times-Bold findfont 11.04125 scalefont
/font0 exch def
font0 sf
(References) s
54 689.7575 m
/Times-Roman findfont 9.03375 scalefont
/font1 exch def
font1 sf
([ANSI89] ) s
/Times-Italic findfont 9.03375 scalefont
/font2 exch def
font2 sf
(Standard X3.159-1989,  American National) s
76.58438 678.7162 m
font2 sf
(Standard for Information Systems - Programming) s
76.58438 667.675 m
font2 sf
(Language - C) s
font1 sf
(,  American National Standards Institute,) s
76.58438 656.6337 m
font1 sf
(Inc.) s
54 644.7183 m
font1 sf
([AtkinsonEtAl89] Atkinson, Russ, Alan Demers, Carl Hauser,) s
76.58438 633.677 m
font1 sf
(Christian Jacobi, Peter Kessler, and Mark Weiser,) s
76.58438 622.6359 m
font1 sf
(``Experiences Creating a Portable Cedar'', ) s
font2 sf
(Proceedings) s
76.58438 611.5946 m
font2 sf
(of the ACM SIGPLAN '89 Conference on Programming) s
76.58438 600.5532 m
font2 sf
(Language Design and Implementation, SIGPLAN) s
76.58438 589.5122 m
font2 sf
(Notices 24) s
font1 sf
(, 7 \050July 1989\051, pp. 322-329.) s
54 577.5968 m
font1 sf
([AustinBreachSohi94]  Austin, Todd M., Scott E. Breach, and) s
76.58438 566.5556 m
font1 sf
(Gurindar S. Sohi, ``Efficient Detection of all Pointer) s
76.58438 555.5142 m
font1 sf
(and Array Access Errors'', ) s
font2 sf
(Proceedings of the ACM) s
76.58438 544.473 m
font2 sf
(SIGPLAN '94 Conference on Programming Language) s
76.58438 533.4318 m
font2 sf
(Design and Implementation) s
font1 sf
(,  ) s
font2 sf
(SIGPLAN Notices 29) s
font1 sf
(, 6) s
76.58438 522.3906 m
font1 sf
(\050June 1994\051, pp. 290-301.) s
54 510.475 m
font1 sf
([Bartlett88] Bartlett, Joel F. ``Compacting garbage collection) s
76.58438 499.434 m
font1 sf
(with ambiguous roots'',) s
76.58438 488.3929 m
font1 sf
( ) s
font2 sf
(Lisp Pointers 1) s
font1 sf
(, 6 \050April-June 1988\051, pp. 3-12.) s
54 476.4772 m
font1 sf
([Bartlett89] Bartlett, Joel F., ) s
font2 sf
(Scheme --> C a Portable Scheme-) s
76.58438 465.4361 m
font2 sf
(to-C Compiler) s
font1 sf
(,  WRL Research Report 89/1, Digital) s
76.58438 454.3947 m
font1 sf
(Equipment Corporation Western Research Laboratory,) s
76.58438 443.3537 m
font1 sf
(January 1989.) s
54 431.4384 m
font1 sf
([Boehm93]  Boehm, Hans-J., ``Space Efficient Conservative) s
76.58438 420.397 m
font1 sf
(Garbage Collection'', ) s
font2 sf
(Proceedings of the ACM) s
76.58438 409.356 m
font2 sf
(SIGPLAN '93 Conference on Programming Language) s
76.58438 398.3146 m
font2 sf
(Design and Implementation) s
font1 sf
(,  ) s
font2 sf
(SIGPLAN Notices 28) s
font1 sf
(, 6) s
76.58438 387.2733 m
font1 sf
(\050June 1993\051, pp. 197-206. ) s
54 375.358 m
font1 sf
([Boehm94]  The SPARC scheduler is available from) s
76.58438 364.3167 m
font1 sf
(parcftp.xerox.com:pub/gc/sched.tar.Z.  It also operates) s
76.58438 353.2755 m
font1 sf
(in a GC-safe mode, along the lines of [BoehmChase92].) s
54 341.3603 m
font1 sf
([Boehm95]  An overview of our conservative garbage collector) s
76.58438 330.319 m
font1 sf
(along with the source code can be accessed from) s
76.58438 319.2778 m
font1 sf
(ftp://parcftp.xerox.com/pub/gc/gc.html.) s
54 307.3623 m
font1 sf
([BoehmChase92]  Boehm, Hans-J., and David Chase, A) s
76.58438 296.3211 m
font1 sf
(Proposal for GC-Safe C Compilation,  ) s
font2 sf
(The Journal of C) s
76.58438 285.2799 m
font2 sf
(Language Translation 4) s
font1 sf
(, 2 \050December , 1992\051, pp.) s
76.58438 274.2387 m
font1 sf
(126-141.  Also available \050with the publishers) s
76.58438 263.1974 m
font1 sf
(permission\051 from) s
76.58438 252.1561 m
font1 sf
(parcftp.xerox.com:pub/gc/boecha.ps.Z.) s
54 240.2408 m
font1 sf
([BoehmDemersShenker91]  Boehm, H., A. Demers, and S.) s
76.58438 229.1996 m
font1 sf
(Shenker,``Mostly Parallel Garbage Collection'',) s
76.58438 218.1584 m
font2 sf
(Proceedings of the ACM SIGPLAN '91 Conference on) s
76.58438 207.1171 m
font2 sf
(Programming Language Design and Implementation,) s
76.58438 196.0759 m
font2 sf
(SIGPLAN Notices 26) s
font1 sf
(, 6 \050June 1991\051, pp. 157-164.) s
54 184.1606 m
font1 sf
([BoehmWeiser88] Boehm, Hans-J. and Mark Weiser,) s
76.58438 173.1194 m
font1 sf
(``Garbage collection in an uncooperative) s
76.58438 162.0781 m
font1 sf
( environment'', ) s
font2 sf
(Software Practice & Experience 18) s
font1 sf
(, 9) s
76.58438 151.0368 m
font1 sf
(\050Sept. 1988\051,  pp. 807-820.) s
54 139.1216 m
font1 sf
([DiwanMossHudson92] Diwan, Amer, Eliot Moss, Richard) s
76.58438 128.0804 m
font1 sf
(Hudson, ``Compiler Support for Garbage Collection in) s
76.58438 117.0391 m
font1 sf
(a Statically Typed Language'', ) s
font2 sf
(ACM SIGPLAN '92) s
76.58438 105.9978 m
font2 sf
(Conference on Programming Language Design and) s
76.58438 94.95658 m
font2 sf
(Implementation) s
font1 sf
(,  ) s
font2 sf
(SIGPLAN Notices 27) s
font1 sf
(, 7 \050July 1992\051,) s
76.58438 83.91534 m
font1 sf
(pp. 273-282.) s
54 72.00005 m
font1 sf
([DetlefsDosserZorn93]  Detlefs, David, Al Dosser, and) s
343.2319 707.9137 m
font1 sf
(Benjamin Zorn, ``Memory Allocation Costs in Large C) s
343.2319 696.8724 m
font1 sf
(and C++ Programs'', University of Colorado, Boulder) s
343.2319 685.8312 m
font1 sf
(Technical Report CU-CS-665-93.  Available for ftp) s
343.2319 674.79 m
font1 sf
(from cs.colorado.edu:pub/techreports/zorn/CU-) s
343.2319 663.7486 m
font1 sf
(CS-665-93.ps.Z.) s
320.6476 652.5553 m
font1 sf
([Edelson91] Edelson, Daniel, ``A Mark-and-Sweep Collector) s
343.2319 641.5139 m
font1 sf
(for C++'', ) s
font2 sf
(Conference Record of the  Nineteenth) s
343.2319 630.4727 m
font2 sf
(Annual ACM SIGPLAN-SIGACT Symposium on) s
343.2319 619.4314 m
font2 sf
(Principles of Programming Languages) s
font1 sf
(, Albuquerque,) s
343.2319 608.3903 m
font1 sf
(New Mexico, January 1992, pp. 51-58.) s
320.6476 597.1967 m
font1 sf
([EllisDetlefs93] Ellis, John R., and David L. Detlefs, \042Safe) s
343.2319 586.1556 m
font1 sf
(Efficient Garbage Collection for C++'',  Xerox PARC) s
343.2319 575.1142 m
font1 sf
(Technical Report CSL-93-4, September 1993.  Also) s
343.2319 564.0732 m
font1 sf
(available from parcftp.xerox.com:pub/ellis/gc/gc.ps.) s
320.6476 552.8795 m
font1 sf
([Fradet94]  Fradet, Pascal, ``Collecting More Garbage'',) s
343.2319 541.8382 m
font2 sf
(Proceedings of the 1994 ACM Conference on Lisp and) s
343.2319 530.7969 m
font2 sf
(Functional Programming) s
font1 sf
(, pp. 24-33.) s
320.6476 519.6038 m
font1 sf
([Goldberg91]  Goldberg, Benjamin, ``Tag-Free Garbage) s
343.2319 508.5625 m
font1 sf
(Collection for Strongly Typed Programming) s
343.2319 497.5211 m
font1 sf
(Languages'', ) s
font2 sf
(ACM SIGPLAN '91 Conference on) s
343.2319 486.48 m
font2 sf
(Programming Language Design and Implementation) s
font1 sf
(,) s
343.2319 475.4386 m
font2 sf
(SIGPLAN Notices 26) s
font1 sf
(, 6 \050June 1991\051, pp. 165-176.) s
320.6476 464.2453 m
font1 sf
([HastingsJoyce92] Hastings, Reed, and Bob Joyce, ``Fast) s
343.2319 453.2039 m
font1 sf
(Detection of Memory Leaks and Access Errors'',) s
343.2319 442.1628 m
font2 sf
(Proceedings of the Winter '92 USENIX conference) s
font1 sf
(, pp.) s
343.2319 431.1214 m
font1 sf
(125-136.) s
320.6476 419.9278 m
font1 sf
([JonesKelly95]  Jones, Richard, and Paul Kelly, ``Bounds) s
343.2319 408.8868 m
font1 sf
(Checking for C'', http://www-) s
343.2319 397.8454 m
font1 sf
(ala.doc.ic.ac.uk/~phjk/BoundsChecking.html.) s
320.6476 386.652 m
font1 sf
([Omohundro91] Omohundro, Stephen M., ) s
font2 sf
(The Sather) s
343.2319 375.6107 m
font2 sf
(Language) s
font1 sf
(, ICSI, Berkeley, 1991.) s
320.6476 364.4172 m
font1 sf
([OTooleNettles94] O'Toole, James, and Scott Nettles,) s
343.2319 353.376 m
font1 sf
(``Concurrent Replicating Garbage Collection'',) s
343.2319 342.3347 m
font2 sf
(Proceedings of the 1994 ACM Conference on Lisp and) s
343.2319 331.2935 m
font2 sf
(Functional Programming) s
font1 sf
(, pp. 34-42.) s
320.6476 320.1 m
font1 sf
([RoseMuller92] Rose, John R., and Hans Muller, ``Integrating) s
343.2319 309.0588 m
font1 sf
(the Scheme and C languages'',  ) s
font2 sf
(Proceedings of the 1992) s
343.2319 298.0176 m
font2 sf
(ACM Conference on Lisp and Functional Programming) s
font1 sf
(,) s
343.2319 286.9762 m
font1 sf
(pp. 247-259.) s
320.6476 275.7828 m
font1 sf
([Rovner85] Rovner, Paul, ``On Adding Garbage Collection) s
343.2319 264.7416 m
font1 sf
(and Runtime Types to a Strongly-Typed) s
343.2319 253.7003 m
font1 sf
(Statically Checked, Concurrent Language'', Technical) s
343.2319 242.6591 m
font1 sf
(Report CSL-84-7, Xerox Palo Alto Research Center,) s
343.2319 231.6178 m
font1 sf
(Palo Alto, CA, July 1985.) s
320.6476 220.4244 m
font1 sf
([SchelterBallantyne88] Schelter, W. F., and M. Ballantyne,) s
343.2319 209.3832 m
font1 sf
(``Kyoto Common Lisp'',  ) s
font2 sf
(AI Expert 3) s
font1 sf
(, 3 \0501988\051, pp.) s
343.2319 198.3419 m
font1 sf
(75-77.) s
gr
gr
showpage

%%Trailer
%%Pages: 10

