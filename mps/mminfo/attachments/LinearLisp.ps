%!PS-Adobe-3.0
%%Title: (LinearLisp.word)
%%Creator: (Microsoft Word: LaserWriter 8 8.2)
%%CreationDate: (6:56 PM Tuesday, December 6, 1994)
%%For: (Henry Baker)
%%Pages: 10
%%DocumentFonts: Times-Roman Times-Italic Times-Bold Courier Symbol Courier-Oblique Courier-Bold
%%DocumentNeededFonts: Times-Roman Times-Italic Times-Bold Courier Symbol Courier-Oblique Courier-Bold
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%%DocumentMedia: Default 612 792 0 () ()
%ADO_ImageableArea: 31 31 583 761
%%EndComments
userdict begin/dscInfo 5 dict dup begin
/Title(LinearLisp.word)def
/Creator(Microsoft Word: LaserWriter 8 8.2)def
/CreationDate(6:56 PM Tuesday, December 6, 1994)def
/For(Henry Baker)def
/Pages 1 def
end def end

save 
/version23-manualfeedpatch where { pop false } { true }ifelse
 % we don't do an explicit 'get' since product and version MAY
 % be in systemdict or statusdict - this technique gets the lookup
 % without failure
statusdict begin
  product (LaserWriter) eq        % true if LaserWriter
  version cvr 23.0 eq             % true if version 23
end

and  % only install this patch if both are true
and  % true only if patch is not installed and is for this printer
     % save object and boolean on stack
dup { exch restore }if
% either true OR saveobject false
dup
{
  /version23-manualfeedpatch true def
  /oldversion23-showpage /showpage load def
  /showpage       % this showpage will wait extra time if manualfeed is true
  {%
     statusdict /manualfeed known
     {% manualfeed known in statusdict
        statusdict /manualfeed get
        {% if true then we loop for 5 seconds
           usertime 5000 add       % target usertime
           { % loop
             dup usertime sub 0 lt
             { exit }if
           }loop
           pop             % pop the usertime off the stac
        }if
     }if
     oldversion23-showpage
  }bind def
}if
not{ restore }if

/md 186 dict def md begin/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 81 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
%%BeginFile: adobe_psp_derived_styles
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/wi
version(23.0)eq
{
{
gS 0 0 0 0 rC stringwidth gR
}bind
}{
/stringwidth load
}ifelse
def
/$o 1. def
/gl{$o G}bd
/ms{:M S}bd
/condensedmtx[.82 0 0 1 0 0]def
/:mc
{
condensedmtx :mf def
}bd
/extendedmtx[1.18 0 0 1 0 0]def
/:me
{
extendedmtx :mf def
}bd
/basefont Z
/basefonto Z
/dxa Z
/dxb Z
/dxc Z
/dxd Z
/dsdx2 Z
/bfproc Z
/:fbase
{
dup/FontType get 0 eq{
dup length dict begin
dup{1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse}forall
/FDepVector exch/FDepVector get[exch/:fbase load forall]def
}/bfproc load ifelse
/customfont currentdict end definefont
}bd
/:mo
{
/bfproc{
dup dup length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse
}forall
/PaintType 2 def
/StrokeWidth .012 0 FontMatrix idtransform pop def
/customfont currentdict
end
definefont
8 dict begin
/basefonto xdf
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
basefont setfont
( )dup 0 4 -1 roll put
dup wi
setcharwidth
0 0 :M
gS
gl
dup show
gR
basefonto setfont
show
end
}def
}store :fbase
}bd
/:mso
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxa 1 ps div def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
1 index 0 ne
{
exch dxa add exch
}if
setcharwidth
dup 0 0 ms
dup dxa 0 ms
dup dxa dxa ms
dup 0 dxa ms
gl
dxa 2. div dup ms
end
end
}def
}store :fbase
}bd
/:ms
{
/bfproc{
dup dup length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse
}forall
/PaintType 2 def
/StrokeWidth .012 0 FontMatrix idtransform pop def
/customfont currentdict
end
definefont
8 dict begin
/basefonto xdf
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxb .05 def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
exch dup 0 ne
{
dxb add
}if
exch setcharwidth
dup dxb .01 add 0 ms
0 dxb :T
gS
gl
dup 0 0 ms
gR
basefonto setfont
0 0 ms
end
end
}def
}store :fbase
}bd
/:mss
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxc 1 ps div def
/dsdx2 .05 dxc 2 div add def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
exch dup 0 ne
{
dsdx2 add
}if
exch setcharwidth
dup dsdx2 .01 add 0 ms
0 .05 dxc 2 div sub :T
dup 0 0 ms
dup dxc 0 ms
dup dxc dxc ms
dup 0 dxc ms
gl
dxc 2 div dup ms
end
end
}def
}store :fbase
}bd
/:msb
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxd .03 def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
1 index 0 ne
{
exch dxd add exch
}if
setcharwidth
dup 0 0 ms
dup dxd 0 ms
dup dxd dxd ms
0 dxd ms
end
end
}def
}store :fbase
}bd
/italicmtx[1 0 -.212557 1 0 0]def
/:mi
{
italicmtx :mf def
}bd
/:v
{
[exch dup/FontMatrix get exch
dup/FontInfo known
{
/FontInfo get
dup/UnderlinePosition known
{
dup/UnderlinePosition get
2 index 0
3 1 roll
transform
exch pop
}{
.1
}ifelse
3 1 roll
dup/UnderlineThickness known
{
/UnderlineThickness get
exch 0 3 1 roll
transform
exch pop
abs
}{
pop pop .067
}ifelse
}{
pop pop .1 .067
}ifelse
]
}bd
/$t Z
/$p Z
/$s Z
/:p
{
aload pop
2 index mul/$t xs
1 index mul/$p xs
.012 mul/$s xs
}bd
/:m
{gS
0 $p rm
$t lw
0 rl stroke
gR
}bd
/:n
{
gS
0 $p rm
$t lw
0 rl
gS
gl
stroke
gR
strokepath
$s lw
/setstrokeadjust where{pop
currentstrokeadjust true setstrokeadjust stroke setstrokeadjust
}{
stroke
}ifelse
gR
}bd
/:o
{gS
0 $p rm
$t 2 div dup rm
$t lw
dup 0 rl
stroke
gR
:n
}bd
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if end
%%EndProlog
%%BeginSetup
md begin
countdictstack[{
%%BeginFeature: *ManualFeed False
statusdict /manualfeed false put
%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *InputSlot Cassette

%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *PageRegion LetterSmall
lettersmall
%%EndFeature
}featurecleanup
(Henry Baker)setjob
/mT[1 0 0 -1 31 761]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Times-Roman
%%IncludeFont: Times-Italic
%%IncludeFont: Times-Bold
%%IncludeFont: Courier
%%IncludeFont: Symbol
%%IncludeFont: Courier-Oblique
%%IncludeFont: Courier-Bold
/f0_1/Times-Roman
:mre
/f0_18 f0_1 18 scf
/f0_12 f0_1 12 scf
/f0_10 f0_1 10 scf
/f0_9 f0_1 9 scf
/f1_1/Times-Italic
:mre
/f1_12 f1_1 12 scf
/f1_10 f1_1 10 scf
/f2_1/Times-Bold
:mre
/f2_12 f2_1 12 scf
/f2_10 f2_1 10 scf
/f3_1 f0_1
:v def
/f4_1 f1_1
:v def
/f5_1/Courier
:mre
/f5_10 f5_1 10 scf
/f6_1/Symbol
:bsr
240/apple pd
:esr
/f6_10 f6_1 10 scf
/f7_1/Courier-Oblique
:mre
/f7_10 f7_1 10 scf
/f8_1/Courier-Bold
:mre
/f8_10 f8_1 10 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(Henry Baker; page: 1 of 10)setjob
%%EndPageSetup
gS 0 0 552 730 rC
41 18 :M
f0_12 sf
.611 .061(ACM )J
f1_12 sf
.854 .085(Sigplan Notices)J
f0_12 sf
.077 .008( )J
f2_12 sf
.169(27)A
f0_12 sf
.984 .098(,8 \(Aug.\3121992\),89-98.)J
41 722 :M
-.05(\251 1991, 1992 by Nimble Computer Corporation)A
467 722 :M
(1)S
41 59 :M
f0_18 sf
.45 .045(Lively Linear Lisp \321 'Look Ma, No Garbage!')J
f0_9 sf
0 -3 rm
(1)S
0 3 rm
41 81 :M
f0_12 sf
.214 .021(Henry G. Baker)J
41 97 :M
f1_10 sf
.295 .029(Nimble Computer Corporation, 16231 Meadow Ridge Way, Encino, CA  91436)J
41 108 :M
1.22 .122(\(818\) 501-4956\312\312\312\(818\) 986-1360 \(FAX\))J
41 124 :M
f2_10 sf
.543(Abstract)A
41 139 :M
f0_10 sf
.216 .022(Linear logic has been proposed as one solution to the problem of garbage collection and providing efficient "update-)J
41 150 :M
.337 .034(in-place" capabilities within a more functional language.  Linear logic conserves accessibility, and hence provides a)J
41 161 :M
f1_10 sf
1.361 .136(mechanical metaphor)J
f0_10 sf
.756 .076( which is more appropriate for a distributed-memory parallel processor in which copying is)J
41 172 :M
.04 .004(explicit.  However, linear logic's lack of sharing may introduce significant inefficiencies of its own.)J
41 187 :M
-.005(We show an efficient implementation of linear logic called )A
f1_10 sf
-.005(Linear Lisp)A
f0_10 sf
-.005( that runs within a constant factor of non-linear)A
41 198 :M
.601 .06(logic.  This Linear Lisp allows RPLACX operations, and manages storage as safely as a non-linear Lisp, but does)J
41 209 :M
1.344 .134(not need a garbage collector.  Since it offers assignments but no sharing, it occupies a twilight zone between)J
41 220 :M
.627 .063(functional languages and imperative languages.  Our Linear Lisp Machine offers many of the same capabilities as)J
41 231 :M
-.013(combinator/graph reduction machines, but without their copying and garbage collection problems.)A
41 247 :M
f2_10 sf
.506(Introduction)A
91 262 :M
2.099 .21(Neither a borrower nor a lender be;)J
91 273 :M
1.806 .181(For loan oft loses both itself and friend ...)J
f0_10 sf
2.238 .224( [Shakespeare, )J
f1_10 sf
.632(Hamlet)A
f0_10 sf
1.178 .118(, I. iii 75])J
41 288 :M
.148 .015(The sharing of data structures can be efficient, because sharing can substitute for copying, but it creates ambiguity as)J
41 299 :M
.824 .082(to who is responsible for their management.  This ambiguity is difficult to statically remove [Barth77] [Bloss89])J
41 310 :M
1.481 .148([Chase87] [Hederman88] [Inoue88] [Jones89] [Ruggieri88], and we have shown [Baker90] that static sharing)J
41 321 :M
1.633 .163(analysis\321even for pure functional languages\321may be as hard as ML type inference, which is known to be)J
41 333 :M
.66 .066(exponential [Mairson90].)J
f0_9 sf
0 -3 rm
.099(2)A
0 3 rm
f0_10 sf
.283 .028(  We show here that a system which takes advantage of )J
f1_10 sf
.088(incidental)A
f0_10 sf
.253 .025(, rather than )J
f1_10 sf
.097(necessary)A
f0_10 sf
(,)S
41 344 :M
-.012(sharing can provide efficiency without the ambiguity normally associated with sharing.)A
41 359 :M
.282 .028(Linear logic was invented by Girard [Girard87] as a way to deal with objects which should not be blithely shared or)J
41 370 :M
.255 .025(copied.  Wadler [Wadler91] has proposed the use of data structures with unity reference counts in order to avoid the)J
41 381 :M
.384 .038(problems of garbage collection and provide for O\(1\) array update.  Wakeling [Wakeling91] has implemented linear)J
41 392 :M
.669 .067(logic and found that it is extremely slow, due to its requirement for laborious copying.  Our Linear Lisp Machine)J
41 403 :M
2.019 .202(implements unity reference count data structures more efficiently than Wakeling's machine, and should be)J
41 414 :M
-.01("competitive" with traditional implementations of combinator/graph reduction machines.)A
41 430 :M
f2_10 sf
2.858 .286(A Linear Lisp Machine)J
41 445 :M
f0_10 sf
.571 .057(In this section we introduce an automata-theoretic model of a Lisp Machine in which all cons cells have reference)J
41 456 :M
1.223 .122(counts of exactly 1, which implies that all data structures are )J
f1_10 sf
.338(trees)A
f0_10 sf
1.21 .121(\321i.e., they have no sharing or cycles.  For)J
41 467 :M
.251 .025(example, in our Linear Lisp, )J
f5_10 sf
.102(NREVERSE)A
f0_10 sf
.204 .02( is isomorphic to )J
f5_10 sf
.102(REVERSE)A
f0_10 sf
(.)S
41 482 :M
.291 .029(Our machine consists of a finite state control and n pointer registers which can hold either )J
f1_10 sf
.097(atoms)A
f0_10 sf
.211 .021( or pointers to )J
f1_10 sf
.124(cons)A
41 493 :M
f0_10 sf
.192 .019(cells.  An )J
f1_10 sf
.097(atom)A
f0_10 sf
.175 .018( is either )J
f5_10 sf
.117(NIL)A
f0_10 sf
.109 .011( or a )J
f1_10 sf
.092(symbol)A
f0_10 sf
.253 .025(.  One of the registers\321)J
f5_10 sf
.117(fr)A
f0_10 sf
.312 .031(\321is distinguished as the "free list" register, and)J
41 504 :M
.102 .01(is initialized to point to an infinite list of )J
f5_10 sf
.051(NIL)A
f0_10 sf
.144 .014('s.  Another register\321)J
f5_10 sf
.051(sp)A
f0_10 sf
.148 .015(\321is designated as the "stack pointer" register.)J
41 519 :M
-.013(The machine can execute any of the following atomic operations:)A
57 534 :M
f5_10 sf
.003 0(r1<->r2;          /* swap r1,r2. */)J
57 545 :M
.006 .001(r1<->CAR\(r2\);     /* r1,r2 distinct; precondition\(not ATOM\(r2\)\) */)J
57 556 :M
.006 .001(r1<->CDR\(r2\);     /* r1,r2 distinct; precondition\(not ATOM\(r2\)\) */)J
57 567 :M
.004 0(NULL\(r1\);         /* predicate for r1=NIL */)J
57 578 :M
.004 0(ATOM\(r1\);         /* predicate for r1=NIL or symbolp\(r1\) */)J
57 589 :M
.004 0(EQ\(r1,r2\);        /* defined only for )J
f7_10 sf
(atomic)S
f5_10 sf
( r1,r2; see [Baker93ER] */)S
57 600 :M
.005 0(r1:='foo;         /* precondition\(ATOM\(r1\) and ATOM\('foo\)\) constant 'foo */)J
57 611 :M
.004 0(r1:=r2;           /* precondition\(ATOM\(r1\) and ATOM\(r2\)\) */)J
57 626 :M
.005 .001(CONS\(r1,r2\):      /* r1,r2 distinct; r2<-CONS\(r1,r2\) and set r1=NIL */)J
57 637 :M
.01 .001({r1<->CAR\(fr\); r2<->fr; fr<->CDR\(r2\);};)J
-4127 -4126 -1 1 -4125 -4126 1 -4127 -4127 @a
41 657.24 -.24 .24 184.24 657 .24 41 657 @a
41 670 :M
f0_9 sf
(1)S
f0_10 sf
0 3 rm
-.032(Obscure reference to old Proctor & Gamble television advertisement for )A
0 -3 rm
f1_10 sf
0 3 rm
-.033(Crest)A
0 -3 rm
f0_10 sf
0 3 rm
-.032( toothpaste.)A
0 -3 rm
41 684 :M
f0_9 sf
(2)S
f0_10 sf
0 3 rm
-.012(We have conjectured that sharing analysis [Baker90] utilizing ML type inference will elicit its exponential behavior.)A
0 -3 rm
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(Henry Baker; page: 2 of 10)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 49 :M
f0_12 sf
.611 .061(ACM )J
f1_12 sf
.854 .085(Sigplan Notices)J
f0_12 sf
.077 .008( )J
f2_12 sf
.169(27)A
f0_12 sf
.984 .098(,8 \(Aug.\3121992\),89-98.)J
72 753 :M
-.05(\251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(2)S
88 85 :M
f5_10 sf
.004 0(PUSH\(r1,r2\):      /* r1,r2 distinct; Push r1 onto r2 and set r1=NIL */)J
88 96 :M
(CONS\(r1,r2\);)S
88 111 :M
.004 0(POP\(r1,r2\):       /* r1,r2 distinct; Pop CAR\(r2\) into r1 if r1=NIL */)J
88 122 :M
(if NULL\(r1\) and not ATOM\(r2\))S
88 133 :M
.006 .001(   then {fr<->CDR\(r2\); r2<->fr; r1<->CAR\(fr\);})J
88 144 :M
(   else die;)S
72 159 :M
f0_10 sf
10 f3_1 :p
53.095 :m
-.04(Proposition 1)A
-.038(.  List cell reference counts are conserved and are always identically 1.)A
72 175 :M
.298 .03(Proof by induction [Suzuki82,s.4].  All cons cells start out with unity reference counts, and are only manipulated by)J
72 186 :M
-.093(exchanges which preserve reference counts.  QED)A
72 201 :M
53.969 :m
.156 .016(Proposition 2)J
.09 .009(.  All list cells are always accessible\321i.e. )J
f1_10 sf
.024(live)A
f0_10 sf
.095 .009(, and no garbage is created.)J
72 217 :M
.2 .02(Proof by induction [Suzuki82,s.5].  Storage could "leak" only if we performed r)J
f1_10 sf
(i)S
f0_10 sf
.061(<->)A
f5_10 sf
.075(CXR)A
f0_10 sf
.042(\(r)A
f1_10 sf
(i)S
f0_10 sf
.151 .015(\), but we do not allow the)J
72 228 :M
.191 .019(swapping of a register with a portion of its own contents.  QED)J
72 243 :M
.199 .02(Programming Note: The only way to "clear" a register which points to a list is to decompose the list stored there and)J
72 255 :M
.321 .032(put it back onto the free list.)J
f0_9 sf
0 -3 rm
(3)S
0 3 rm
88 270 :M
f5_10 sf
.002 0(FREE\(r1\):                                /* Essentially the K combinator! */)J
88 281 :M
(if not NULL\(r1\) then)S
88 292 :M
(   if ATOM\(r1\) then r1:='NIL;)S
88 303 :M
(   else)S
88 314 :M
-.006(    {PUSH\(r2,sp\); POP\(r2,r1\);            /* temporary r2)A
cF
f6_10 sf
-.006<B9>A
sf
-.006(r1. */)A
88 326 :M
.018 .002(     FREE\(r1\);)J
f0_9 sf
0 -3 rm
(4)S
0 3 rm
f5_10 sf
.012 .001(                          /* free the cdr of the cell. */)J
88 337 :M
.003 0(     r2<->r1; FREE\(r1\);                  /* free the car of the cell. */)J
88 348 :M
(     POP\(r2,sp\);})S
72 363 :M
f0_10 sf
.14 .014(We can copy, but only by destroying the original list and creating two new lists.)J
88 378 :M
f5_10 sf
.004 0(COPY\(r1,r2\):            /* assert\(r2=NIL\).  Essentially the S combinator! */)J
88 389 :M
(if not NULL\(r1\) then)S
88 400 :M
(   if ATOM\(r1\) then r2:=r1;)S
88 411 :M
(   else)S
88 422 :M
(    {PUSH\(t1,sp\); PUSH\(t2,sp\);)S
88 433 :M
(     POP\(t1,r1\); COPY\(r1,r2\);)S
88 444 :M
.005 0(     t1<->r1; t2<->r2; COPY\(r1,r2\);)J
88 455 :M
.005 .001(     t1<->r1; t2<->r2; PUSH\(t1,r1\); PUSH\(t2,r2\);)J
88 466 :M
(     POP\(t2,sp\); POP\(t1,sp\);})S
72 481 :M
f0_10 sf
.647 .065(Finally, we can program recursive )J
f5_10 sf
.234(EQUAL)A
f0_10 sf
.55 .055( by destroying and recreating both lists.  \(We switch to Lisp notation in)J
72 492 :M
.019 .002(order to utilize the capabilities of )J
f5_10 sf
(prog1)S
f0_10 sf
(.\))S
88 507 :M
f5_10 sf
.007 .001(EQUAL\(r1,r2\): /* Recursive list equality. */)J
88 518 :M
.005 0(\(or \(and \(ATOM r1\) \(ATOM r2\) \(EQ r1 r2\)\))J
88 529 :M
.004 0(    \(and \(not \(ATOM r1\)\) \(not \(ATOM r2\)\))J
88 540 :M
.003 0(         \(progn \(PUSH t1 sp\) \(PUSH t2 sp\) \(POP t1 r1\) \(POP t2 r2\))J
88 551 :M
(          \(prog1)S
88 562 :M
(           \(and \(EQUAL r1 r2\))S
88 573 :M
.002 0(                \(progn \(<-> t1 r1\) \(<-> t2 r2\))J
88 584 :M
.002 0(                 \(prog1 \(EQUAL r1 r2\))J
88 595 :M
.002 0(                  \(<-> t1 r1\) \(<-> t2 r2\)\)\)\))J
88 606 :M
.003 0(           \(PUSH t1 r1\) \(PUSH t2 r2\) \(POP t2 sp\) \(POP t1 sp\)\)\)\)\))J
72 621 :M
f0_10 sf
1.506 .151(Using these definitions, it should be clear that we can program a traditional Lisp interpreter \(see Appendix\).)J
72 632 :M
.078 .008(However, this interpreter will be inefficient, due to the extra expense of copying.  The one minor problem to be faced)J
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 655.24 -.24 .24 215.24 655 .24 72 655 @a
72 668 :M
f0_9 sf
(3)S
f0_10 sf
0 3 rm
-.015(One could use the Weizenbaum lazy recycling trick [Weizenbaum63] and put garbage onto the free list; this trick has)A
0 -3 rm
72 682 :M
.74 .074(also been advocated by [Wise85].  Putting garbage onto the free list moves work from the point of freeing to the)J
72 693 :M
.471 .047(point of allocation; this may smooth out the work, but does not decrease its amount, unless the program terminates)J
72 704 :M
.104 .01(with a dirty free list.)J
72 715 :M
f0_9 sf
(4)S
f0_10 sf
0 3 rm
-.015(There are implicit "old-PC" stack operations involved with recursive calls, but we leave those details to the reader.)A
0 -3 rm
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(Henry Baker; page: 3 of 10)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 49 :M
f0_12 sf
.611 .061(ACM )J
f1_12 sf
.854 .085(Sigplan Notices)J
f0_12 sf
.077 .008( )J
f2_12 sf
.169(27)A
f0_12 sf
.984 .098(,8 \(Aug.\3121992\),89-98.)J
72 753 :M
-.05(\251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(3)S
72 81 :M
f0_10 sf
.707 .071(is how to handle recursive functions, since we cannot create cycles.  We suggest the following trick based on the)J
72 92 :M
-.059(lambda calculus Y combinator [Gabriel88]:)A
88 107 :M
f5_10 sf
.004 0(\(defun fact \(f n\) \(if \(zerop n\) 1 \(* n \(funcall f f \(1- n\)\)\)\)\))J
88 122 :M
.006 .001(\(defun factorial \(n\) \(fact #'fact n\)\))J
72 138 :M
f2_10 sf
2.857 .286(A Linear Lisp Machine with )J
f8_10 sf
1.068(FREE)A
f2_10 sf
.742 .074(, )J
f8_10 sf
1.068(COPY)A
f2_10 sf
.742 .074(, )J
f8_10 sf
1.068(EQUAL)A
f2_10 sf
3.722 .372( and Assignment)J
72 153 :M
f0_10 sf
1.73 .173(In the previous section, we described a Linear Lisp Machine in which )J
f5_10 sf
.697(FREE)A
f0_10 sf
.484 .048(, )J
f5_10 sf
.697(COPY)A
f0_10 sf
.904 .09( and )J
f5_10 sf
.697(EQUAL)A
f0_10 sf
1.167 .117( had to be)J
72 164 :M
.569 .057(programmed.  Now that we have seen how to implement these three functions, we will describe a new machine in)J
72 175 :M
.283 .028(which they are primitive operations\321e.g., they are implemented in microcode.  This revision will not provide much)J
72 186 :M
-.002(additional efficiency, but it will provide a more traditional set of primitive operations.)A
88 201 :M
f5_10 sf
.002 0(r1:=r2:                            /* r1, r2 cannot be the same register. */)J
88 212 :M
({FREE\(r1\); COPY\(r2,r1\);})S
88 227 :M
.003 0(r1:=CAR\(r2\):                       /* r1, r2 cannot be the same register. */)J
88 238 :M
.01 .001({r3<->CAR\(r2\); r1:=r3; r3<->CAR\(r2\);})J
88 253 :M
.003 0(r1:=CDR\(r2\):                       /* r1, r2 cannot be the same register. */)J
88 264 :M
.01 .001({r3<->CDR\(r2\); r1:=r3; r3<->CDR\(r2\);})J
88 279 :M
.004 0(RPLACA\(r1,r2\):       /* CAR\(r1\):=r2.  r1, r2 cannot be the same register. */)J
88 290 :M
.01 .001({r3<->CAR\(r1\); r3:=r2; r3<->CAR\(r1\);})J
88 305 :M
.004 0(RPLACD\(r1,r2\):       /* CDR\(r1\):=r2.  r1, r2 cannot be the same register. */)J
88 316 :M
.01 .001({r3<->CDR\(r1\); r3:=r2; r3<->CDR\(r1\);})J
72 331 :M
f0_10 sf
1.013 .101(Using this new set of operations, we can now program our Lisp interpreter in the traditional way, although this)J
72 342 :M
.138 .014(interpreter will now be slower unless we have taken precautions to avoid extraneous copying.  This interpreter is still)J
72 353 :M
f1_10 sf
.022(linear)A
f0_10 sf
.076 .008( logic, in which there is no sharing, however, so operations like )J
f5_10 sf
.033(RPLACX)A
f0_10 sf
.09 .009( cannot create loops.)J
72 369 :M
f2_10 sf
3.989 .399(Dataflow-like Producer/Consumer )J
f8_10 sf
1.106(EVAL)A
72 384 :M
f0_10 sf
2.058 .206(Before showing how to make )J
f5_10 sf
.791(FREE)A
f0_10 sf
.549 .055(, )J
f5_10 sf
.791(COPY)A
f0_10 sf
1.025 .102( and )J
f5_10 sf
.791(EQUAL)A
f0_10 sf
1.817 .182( more efficient, it is instructive to show a natural)J
72 395 :M
1.004 .1(programming metaphor for Linear Lisp.  The natural metaphor for Linear Lisp is quantum mechanics, in which)J
72 406 :M
-.048(objects interact, and every interaction with an object\321including reading\321affects the object.)A
72 421 :M
.287 .029(Linear Lisp calls for the mechanical interpretation of a function as a "black box" which )J
f1_10 sf
.095(consumes)A
f0_10 sf
.303 .03( its arguments and)J
72 432 :M
f1_10 sf
.054(produces)A
f0_10 sf
.168 .017( its result, while returning the black box to its quiescent state. Since an argument to a function is consumed,)J
72 443 :M
.764 .076(the function can reference it only once, after which the formal parameter binding becomes unbound!  In fact, the)J
72 454 :M
.205 .02(requirement to return the box to its quiescent state means that )J
10 f3_1 :p
219.911 :m
.255 .025(every parameter and local variable must be referenced)J
72 466 :M
f1_10 sf
10 f4_1 :p
50.762 :m
.488 .049(exactly once)J
f0_10 sf
10 f3_1 :p
421.237 :m
.289 .029(, since it is a run-time error to return from the function so long as any parameters or local variables still)J
72 479 :M
58.258 :m
1.059 .106(have bindings)J
.109(.)A
f0_9 sf
0 -3 rm
.196(5)A
0 3 rm
f0_10 sf
.566 .057(  In order to utilize a value more than once, it must be explicitly copied.  We relax the "reference-)J
72 491 :M
1.355 .135(once" requirement in the case of multiple-arm conditionals.  Since the execution of one arm implies the non-)J
72 502 :M
.184 .018(execution of the other arms, the single use of the variable within each arm is sufficient to guarantee that single use is)J
72 514 :M
.793 .079(dynamically satisfied.)J
f0_9 sf
0 -3 rm
.13(6)A
0 3 rm
f0_10 sf
.345 .035(  In fact, the best policy is to reference exactly the same set of variables in all of the arms of)J
72 525 :M
-.024(the conditional.  The exactly-one-reference policy can be checked syntactically at compile-time in a manner analogous)A
72 536 :M
-.069(to the "occurs free" predicate of the lambda calculus.)A
72 551 :M
.756 .076(The following technique should make the programming of certain predicates more efficient.  A value passed to a)J
72 562 :M
.545 .055(predicate is often subsequently used in the arm of a conditional, yet in many of these cases, the predicate does not)J
72 573 :M
.416 .042(depend upon any deep property of the value.  The cost of copying and then consuming the )J
f1_10 sf
.115(entire)A
f0_10 sf
.443 .044( value is therefore)J
72 584 :M
.166 .017(wasted.  For such a "shallow" predicate, one might rather program it to return \(a list of\) two values\321the value of the)J
72 595 :M
.831 .083(predicate and its reconstituted arguments, which is then bound to new parameters and \(re\)used in the subsequent)J
72 606 :M
.046(computation.)A
72 621 :M
.775 .077(Since the argument to )J
f5_10 sf
.32(CAR)A
f0_10 sf
.296 .03( or )J
f5_10 sf
.32(CDR)A
f0_10 sf
.816 .082( is completely consumed, how can one gain access to both components?  The)J
72 632 :M
1.383 .138(natural model for binding in Linear Lisp is that of a )J
f1_10 sf
2.88 .288(destructuring bind)J
f0_10 sf
1.654 .165(, which binds a number of variables)J
72 643 :M
1.358 .136("simultaneously", while recycling the backbone of the value-containing list structure.  This destructuring bind)J
72 654 :M
-.03(eliminates the need for separate )A
f5_10 sf
-.046(CAR)A
f0_10 sf
-.03( and )A
f5_10 sf
-.046(CDR)A
f0_10 sf
-.032( functions.)A
-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a
72 677.24 -.24 .24 215.24 677 .24 72 677 @a
72 690 :M
f0_9 sf
.052(5)A
f0_10 sf
0 3 rm
.148 .015(I.e., no values can be "left on base at the end of an inning", to provide a baseball analogy.  This error can usually be)J
0 -3 rm
72 704 :M
-.078(checked at compile-time.)A
72 715 :M
f0_9 sf
(6)S
f0_10 sf
0 3 rm
-.007(Copying is still required if speculative execution of an arm is performed.)A
0 -3 rm
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(Henry Baker; page: 4 of 10)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 49 :M
f0_12 sf
.611 .061(ACM )J
f1_12 sf
.854 .085(Sigplan Notices)J
f0_12 sf
.077 .008( )J
f2_12 sf
.169(27)A
f0_12 sf
.984 .098(,8 \(Aug.\3121992\),89-98.)J
72 753 :M
-.05(\251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(4)S
72 85 :M
f0_10 sf
-.007(Nested functional composition has the obvious mechanical interpretation, since the intermediate results are utilized by)A
72 96 :M
.029 .003(exactly one consumer.  The mechanical metaphor also shows that parallel execution of subexpressions is possible and)J
72 107 :M
.66 .066(correct \(so long as the primitive )J
f5_10 sf
.287(CONS)A
f0_10 sf
.749 .075( itself\321the creator of argument )J
f1_10 sf
.154(lists)A
f0_10 sf
.942 .094(\321evaluates its arguments in parallel\),)J
72 118 :M
.715 .072(since there is no mechanism whereby the subexpressions can communicate.  Thus, collateral argument evaluation)J
72 129 :M
.336 .034([Baker77] can be considered the norm, and on this machine there are no garbage collection problems because every)J
72 140 :M
.556 .056(callee is required to "clean up" after itself.  Unfortunately, the hash consing technique described later requires that)J
72 151 :M
f5_10 sf
.29(CONS)A
f0_10 sf
.66 .066( be \(transitively\) strict in both of its arguments.  As a result, only variable binding itself can be lazy, which)J
72 162 :M
-.012(isn't nearly lazy enough for most interesting applications of laziness; lazy "futures" [Baker77] cannot be supported.)A
72 177 :M
.034 .003(The analogy with a dataflow machine [Arvind87] is quite close.  Values are )J
f1_10 sf
.01(tokens)A
f0_10 sf
.035 .003( which are consumed by a function)J
72 188 :M
1.385 .139(to produce a new token/value.  The implementation of the token metaphor on our Swapping Lisp Machine is)J
72 199 :M
.196 .02(straightforward.  In addition to programmer-visible values, we also have "holes", which are the bindings of variables)J
72 210 :M
.471 .047(when they are "unbound".  Argument passing is accomplished by "swap-in, swap-out" \(reminiscent of [Harms91]\),)J
72 221 :M
.45 .045(and "holes" flow backwards relative to values.  When implemented in this way \(see Appendix\), )J
f5_10 sf
.171(EVAL)A
f0_10 sf
.464 .046( avoids most)J
72 232 :M
-.012(copying, and should be reasonably efficient even without the hash consing scheme discussed in the next section.)A
72 248 :M
f2_10 sf
3.35 .335(Reconstituting Trees from Fresh Frozen Concentrate)J
72 263 :M
f0_10 sf
1.014 .101(We will now show how to implement a linear machine with the instructions )J
f5_10 sf
.404(CONS)A
f0_10 sf
.28 .028(, )J
f5_10 sf
.404(CAR)A
f0_10 sf
.28 .028(, )J
f5_10 sf
.404(CDR)A
f0_10 sf
.28 .028(, )J
f5_10 sf
.404(COPY)A
f0_10 sf
.28 .028(, )J
f5_10 sf
.404(EQUAL)A
f0_10 sf
(,)S
72 274 :M
f5_10 sf
.203(RPLACA)A
f0_10 sf
.141 .014(, )J
f5_10 sf
.203(RPLACD)A
f0_10 sf
.141 .014(, )J
f5_10 sf
.203(NULL)A
f0_10 sf
.141 .014(, )J
f5_10 sf
.203(ATOM)A
f0_10 sf
.263 .026( and )J
f5_10 sf
.203(EQ)A
f0_10 sf
.459 .046( in such a way that all of these instructions operate in O\(1\) average time.)J
72 285 :M
.217 .022(In other words, our machine will be as fast as a machine based on "hash consing" [Goto74], except that our machine)J
72 296 :M
-.019(can also execute )A
f5_10 sf
-.029(RPLACX)A
f0_10 sf
(.)S
72 311 :M
.441 .044(Our machine will operate on a "virtual heap", and the real heap will be separated from the CPU by a "read barrier")J
72 322 :M
.776 .078([Moon84].  More precisely, the cons cells pointed at directly by the machine registers will operate in the fashion)J
72 333 :M
1.198 .12(described above, but any cons cells which are not directly pointed at by machine registers may be represented)J
72 344 :M
.46 .046(differently.  In particular, any cons cells which are not directly pointed at by machine registers are represented in a)J
72 355 :M
.085 .008(hidden hash table which is built in such a way that list structures which are )J
f5_10 sf
.038(EQUAL)A
f0_10 sf
.093 .009( will be represented by exactly the)J
72 366 :M
.564 .056(same cell in this hash table.  This "hash cons" table is built inductively from cells having atomic )J
f5_10 sf
.245(CAR)A
f0_10 sf
.38 .038('s and )J
f5_10 sf
.245(CDR)A
f0_10 sf
.232('s)A
72 377 :M
1.396 .14(by hashing the addresses of non-atomic )J
f5_10 sf
.517(CAR)A
f0_10 sf
.802 .08('s and )J
f5_10 sf
.517(CDR)A
f0_10 sf
1.283 .128('s; this scheme is called "hash consing" and under the)J
72 388 :M
1.312 .131(appropriate circumstances the cost of a "hash cons" operation averages O\(1\).  Furthermore, these cells can be)J
72 399 :M
.185 .018(dereferenced for )J
f5_10 sf
.06(CAR)A
f0_10 sf
.056 .006( or )J
f5_10 sf
.06(CDR)A
f0_10 sf
.136 .014( in O\(1\) time.  These cells cannot be side-effected, however, so that )J
f5_10 sf
.06(RPLACX)A
f0_10 sf
.142 .014( cannot be)J
72 410 :M
.08 .008(used directly on these hash-consed cells.  We will manage this hash table using reference counts, since we intend that)J
72 421 :M
-.033(cells stored in this table are capable of being shared.)A
72 436 :M
.367 .037(We now analyze the operation of the read barrier.  If the CPU attempts to read the )J
f5_10 sf
.169(CAR)A
f0_10 sf
.156 .016( or )J
f5_10 sf
.169(CDR)A
f0_10 sf
.372 .037( of a cell referenced)J
72 447 :M
.292 .029(directly by a machine register, then the read barrier causes the cell in the hash table to be copied \("unshared"\) into a)J
72 458 :M
.493 .049(normal cell, and the reference count of the cell in the hash table is decremented.  Similarly, if the CPU attempts to)J
72 469 :M
.107 .011(write the )J
f5_10 sf
.051(CAR)A
f0_10 sf
.047 .005( or )J
f5_10 sf
.051(CDR)A
f0_10 sf
.112 .011( of a cell referenced directly by a machine register, then the cell is copied into the hash table by)J
72 480 :M
.758 .076("hash consing" \(including incrementing the reference counter\) and the copied pointer is stored into the )J
f5_10 sf
.28(CAR)A
f0_10 sf
.13(/)A
f5_10 sf
.42(CDR)A
72 491 :M
f0_10 sf
-.118(instead.)A
72 506 :M
.388 .039(Since there are never more than )J
f1_10 sf
.138(n)A
f0_10 sf
.371 .037( "normal" cells which can be seen by the CPU, because there are only )J
f1_10 sf
.138(n)A
f0_10 sf
.536 .054( registers,)J
72 517 :M
.542 .054(and because none of these normal cells can be shared, we can eliminate the expense of allocating and deallocating)J
72 528 :M
.272 .027(these cells, and associate one of these normal cells with each machine register.  Thus, all storage management effort)J
72 539 :M
-.009(is concentrated in the hash cons table.)A
72 554 :M
.713 .071(Another optimization is that of keeping a "hidden" pointer in each normal cell to the entry in the hash table from)J
72 565 :M
.72 .072(which it was copied; if it is newly consed, then this pointer is empty.  This pointer is used as a "hint" when hash)J
72 576 :M
.22 .022(consing, so that no searching will be necessary to share the cell in the hash consed heap.  Of course, any side-effects)J
72 587 :M
.708 .071(to this normal cell will cause its "hint" pointer to be cleared, since we will now require a hash lookup in order to)J
72 598 :M
-.019(share the cell in the hash consed heap.)A
72 613 :M
.156 .016(Since the free list seen by the CPU is an infinite list of )J
f5_10 sf
.081(NIL)A
f0_10 sf
.157 .016('s, we can represent it as a special )J
f1_10 sf
.054(circular)A
f0_10 sf
.143 .014( list of one cell)J
72 624 :M
.212 .021(in the hash table whose reference count is not modified.  In this case, the free list register is identical in nature to the)J
72 635 :M
.554 .055(other registers in the CPU; the only difference is in the hash table pointer stored in the )J
f5_10 sf
.25(CDR)A
f0_10 sf
.438 .044( of the first cell on the)J
72 646 :M
.319(list.)A
72 661 :M
.47 .047(Of course, there is a real "free list" which is hidden from the CPU which is used to provide cells for the hash table)J
72 672 :M
.447 .045(when a never-before-hashed <)J
f5_10 sf
.128(CAR)A
f0_10 sf
.053(,)A
f5_10 sf
.128(CDR)A
f0_10 sf
.328 .033(> configuration is seen.  This "free list" is refreshed whenever the reference)J
72 683 :M
.316 .032(count of a table entry drops to zero.  Depending upon our time/space tradeoff, we can either recycle hash table cells)J
72 694 :M
(aggressively or lazily.  If we recycle aggressively, then we may have to recycle an unbounded number of nodes at one)S
72 705 :M
-.001(time, which can create an unbounded delay.  Alternatively, we can recycle lazily, in which case the )A
f5_10 sf
(CAR)S
f0_10 sf
( and )S
f5_10 sf
(CDR)S
f0_10 sf
( of a)S
72 716 :M
.403 .04(recycled cell are only marked as deleted, but not actually reclaimed, at the time that the reference count for the cell)J
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(Henry Baker; page: 5 of 10)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 49 :M
f0_12 sf
.611 .061(ACM )J
f1_12 sf
.854 .085(Sigplan Notices)J
f0_12 sf
.077 .008( )J
f2_12 sf
.169(27)A
f0_12 sf
.984 .098(,8 \(Aug.\3121992\),89-98.)J
72 753 :M
-.05(\251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(5)S
72 81 :M
f0_10 sf
.787 .079(drops to zero.  Notice, though, that any sublists of this "garbage" list are still hashable by the hash table and can)J
72 92 :M
.62 .062(become non-garbage at any time.  Thus, the garbage is not really garbage, although it can only be used for a very)J
72 103 :M
-.055(special purpose until recycled for general use.)A
72 118 :M
.686 .069(We can now describe the operation of our "fast" machine.  All primitive operations, with the exception of )J
f5_10 sf
.277(FREE)A
f0_10 sf
(,)S
72 129 :M
f5_10 sf
.077(COPY)A
f0_10 sf
.099 .01( and )J
f5_10 sf
.077(EQUAL)A
f0_10 sf
.165 .016(, operate exactly as if the CPU were operating on a "real heap" rather than a "virtual heap".  )J
f5_10 sf
.102(COPY)A
72 140 :M
f0_10 sf
.205 .021(copies only the top-level cons cell, and "copies" the sublists by simply incrementing the reference counts of the )J
f5_10 sf
.121(CAR)A
72 151 :M
f0_10 sf
.079 .008(and )J
f5_10 sf
.039(CDR)A
f0_10 sf
.065 .006( cells in the hash table.  )J
f5_10 sf
.039(EQUAL)A
f0_10 sf
.103 .01( compares only the top-level cons cell, and simply compares the addresses of)J
72 162 :M
.331 .033(the )J
f5_10 sf
.189(CAR)A
f0_10 sf
.293 .029('s and )J
f5_10 sf
.189(CDR)A
f0_10 sf
.379 .038('s for their locations in the hash table.  Thus, )J
f5_10 sf
.189(COPY)A
f0_10 sf
.245 .024( and )J
f5_10 sf
.189(EQUAL)A
f0_10 sf
.397 .04( are both O\(1\) operations.  If we)J
72 173 :M
.07 .007(utilize lazy recycling for hash table entries, then )J
f5_10 sf
.028(FREE)A
f0_10 sf
.065 .006( is also an O\(1\) operation.)J
72 189 :M
f2_10 sf
2.626 .263(Linear Lisp )J
f8_10 sf
1.273(EVAL)A
72 204 :M
f0_10 sf
.71 .071(It is interesting to analyze the operation of a traditional Lisp interpreter written for this Linear Lisp Machine \(see)J
72 215 :M
.645 .065(Appendix\).  Since traditional Lisp utilizes "applicative order" evaluation, an argument used multiple times is only)J
72 226 :M
-.029(evaluated once.  The traditional problem in "call-by-need" evaluation has been the shared flag variable which indicates)A
72 237 :M
.35 .035(that the argument has already been computed; Linear Lisp utilizes its arguments exactly once, with an explicit copy)J
72 248 :M
.552 .055(required for additional uses, so the applicative-order/normal-order issue is moot and the shared flag variable is not)J
72 259 :M
.048 .005(necessary.  Our use of hash consing requires transitive strictness on both of its arguments; otherwise )J
f5_10 sf
.019(EQUAL)A
f0_10 sf
.061 .006('ity could)J
72 270 :M
.628 .063(be decided prior to the determination of a lazy value, since )J
f5_10 sf
.272(EQUAL)A
f0_10 sf
.352 .035( and )J
f5_10 sf
.272(EQ)A
f0_10 sf
.642 .064( are equivalent for hash conses.  Thus,)J
72 281 :M
.309 .031(parallel evaluation of arguments can be supported, but not laziness.  On the other hand, the implicit synchronization)J
72 292 :M
-.063(required to strictly resolve a "future" [Baker77] can be efficiently performed with a swapping operation [Herlihy91].)A
72 307 :M
.332 .033(Since the association list of variable bindings must be destroyed in order to search it anyway, the "shallow binding")J
72 318 :M
-.007(technique utilizing "rerooting" [Baker78] is essentially optimal.)A
72 333 :M
1.06 .106(We )J
f1_10 sf
.405(can)A
f0_10 sf
1.499 .15( destroy the Lisp program during evaluation in the manner of combinator/graph reduction [Turner79])J
72 344 :M
1.367 .137([Kieburtz85] [Kieburtz87] [Johnsson85] [Johnsson91]; indeed, we )J
f1_10 sf
.298(must)A
f0_10 sf
.898 .09( destroy it, since we cannot reference it)J
72 355 :M
-.035(otherwise, as all of its reference counts are one!)A
72 371 :M
f2_10 sf
4.108 .411(Implications for Real Multiprocessors)J
72 386 :M
f0_10 sf
-.001(Linear Lisp can be used in a "shared-heap-memory" multiprocessing configuration, in which the memory to be shared)A
72 397 :M
.049 .005(is actually the hash consed heap.  Each CPU operates independently, with its "normal nodes" acting like a local cache)J
72 408 :M
.618 .062(into the heap.  The read barrier logic is the "cache consistency protocol" for this hashed memory, which is simple)J
72 419 :M
.816 .082(because there is no visible sharing among CPU's.  This parallel configuration can be used, e.g., for the collateral)J
72 430 :M
-.006(evaluation of arguments.)A
72 445 :M
1.232 .123(Hardware swapping has been advocated as a synchronization mechanism [Herlihy91].  However, even without)J
72 456 :M
-.044(hardware swaps, modern RISC compilers can optimize register-register swaps, while write-back caches reduce the cost)A
72 467 :M
-.036(of register-memory swaps; swaps should thus be relatively cheap even on a traditional load/store architecture.)A
72 483 :M
f2_10 sf
3.535 .353(Conclusions and Previous Work)J
72 498 :M
f0_10 sf
.037 .004(Some have suggested that garbage collection not be done at all [White80] or after the program has finished [Moon84])J
72 509 :M
.803 .08(\(comment on the Boyer benchmark\).  Linear Lisp provides a hyper-clean environment in which garbage is never)J
72 520 :M
-.095(produced, and therefore garbage collection is not necessary.)A
72 535 :M
.77 .077(Hash consing was invented by Ershov for the detection of common subexpressions in a compiler [Ershov58] and)J
72 546 :M
.375 .037(popularized by Goto for use in a Lisp-based symbolic algebra systems [Goto74] [Goto76] [Goto80].  While a hash-)J
72 557 :M
.223 .022(consing system with reference count management can be used to implement a functional \(applicative\) subset of Lisp)J
72 568 :M
.51 .051(with the same efficiency shown here, we believe that our Linear Lisp Machine is the first efficient implementation)J
72 579 :M
.738 .074(which allows for \(linear\) side-effects such as )J
f5_10 sf
.285(RPLACX)A
f0_10 sf
.708 .071(.  See [Baker92] for a "warp speed" implementation of the)J
72 590 :M
-.025(Gabriel "Boyer" benchmark using hash consing.)A
72 605 :M
.278 .028(Linear Lisp is an ideal environment for symbolic algebra, since it provides the efficiencies of sharing, including fast)J
72 616 :M
.621 .062(copying and fast equality checking [Goto76], without the problems.  For example, the Macsyma symbolic algebra)J
72 628 :M
.408 .041(system can represent the symbolic determinant of an nxn matrix with O\(n)J
f0_9 sf
0 -3 rm
.113(3)A
0 3 rm
f0_10 sf
.404 .04(\) cons cells, even though this expression)J
72 639 :M
.537 .054(prints out with O\(n!\) terms.  Furthermore, Linear Lisp allows for destructive operations on expressions, which can)J
72 650 :M
-.036(sometimes be more efficient [Gabriel85] [Fateman91], yet these destructive operations are completely safe.)A
72 665 :M
.221 .022(While our Linear Lisp cannot support laziness, because )J
f5_10 sf
.08(CONS)A
f0_10 sf
.197 .02( is transitively strict in both arguments, it does support)J
72 676 :M
-.013(a mild form of side-effects.  Linear Lisp )A
f5_10 sf
-.02(RPLACX)A
f0_10 sf
-.014( cannot be used to produce \(visible\) sharing, and hence requirements)A
72 687 :M
.368 .037(for "object identity" expressed in [Baker93ER] are vacuously met for cons cells.  These cells live in a twilight zone)J
72 698 :M
-.025(between functional and non-functional data; any "side-effects" to the data are not really "side"-effects because they are)A
72 709 :M
.354 .035(not visible through any other pointer alias.  [Myers84] describes a scheme for implementing certain imperative data)J
endp
%%Page: 6 6
%%BeginPageSetup
initializepage
(Henry Baker; page: 6 of 10)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 49 :M
f0_12 sf
.611 .061(ACM )J
f1_12 sf
.854 .085(Sigplan Notices)J
f0_12 sf
.077 .008( )J
f2_12 sf
.169(27)A
f0_12 sf
.984 .098(,8 \(Aug.\3121992\),89-98.)J
72 753 :M
-.05(\251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(6)S
72 81 :M
f0_10 sf
.373 .037(structures efficiently using applicative data structures.  We believe that the implementation of side-effects in Linear)J
72 92 :M
.349 .035(Lisp )J
f1_10 sf
.109(automatically)A
f0_10 sf
.442 .044( produces the efficiency claimed by his scheme, without translating the program into applicative)J
72 103 :M
.017(form.)A
72 118 :M
-.06([Harms91] discusses the advantages of unity reference count data structures and swapping for efficient programming of)A
72 129 :M
.843 .084(abstract data types, although he utilizes notions as "unshared" or "non-aliased" instead of unity reference counts.)J
72 140 :M
.829 .083([Kieburtz76] also advocates the use of hidden \(unity reference count\) pointers.  Pointer swapping can be used to)J
72 151 :M
1.25 .125(minimize reference count overflows in systems with limited counts [Wise77], and to avoid appearing multiply)J
72 162 :M
.812 .081(referenced [Deutsch76].  Memory-to-memory swapping is a superior form of synchronization [Herlihy91], so we)J
72 173 :M
-.037(expect to see efficient swapping operations implemented on future shared-memory multiprocessors.)A
72 188 :M
.504 .05(Our Linear Lisp Machine )J
f1_10 sf
.15(consumes)A
f0_10 sf
.44 .044( the programs it interprets, therefore requiring a private copy of the code in the)J
72 199 :M
.152 .015(manner of a combinator reduction machine.  The Linear Lisp )J
f5_10 sf
.059(COPY)A
f0_10 sf
.15 .015( is more efficient, however, than the real copying)J
72 210 :M
.46 .046(utilized in combinator reduction machines.  A machine which consumes its programs provides new insight into the)J
72 221 :M
-.029(mechanisms of instruction caches \(see also [Kieburtz87]\) and "index registers".  Since index registers were invented in)A
72 232 :M
-.027(order to avoid side-effecting code, and since all modern CPU's utilize instruction caches, the index register is obsolete!)A
72 243 :M
.764 .076(Linear logic provides a firm semantics for an unshared instruction stream, which could be destructively modified)J
72 254 :M
.128 .013(without causing havoc.)J
72 269 :M
-.036(Other approaches to "linear-like" logic include )A
f1_10 sf
-.039(connection graphs)A
f0_10 sf
-.04( [Bawden86], )A
f1_10 sf
-.039(chemical abstract machines)A
f0_10 sf
-.04( [Berry90],)A
72 280 :M
f1_10 sf
-.112(linear abstract machines)A
f0_10 sf
-.11( [Lafont88] and )A
f1_10 sf
-.106(interaction nets)A
f0_10 sf
-.119( [Lafont90].)A
72 295 :M
.506 .051(We have not yet integrated arrays into our Linear Lisp, so we cannot perform imperative array updates.  However,)J
72 306 :M
.991 .099([Baker91SB] shows an efficient O\(1\) implementation of array updates for "single-threaded" programs.  Another)J
72 317 :M
-.049(approach would be to incorporate )A
f1_10 sf
-.047(I-Structures)A
f0_10 sf
-.049( [Arvind89] into Linear Lisp.)A
72 333 :M
f2_10 sf
.683(Acknowledgements)A
72 348 :M
f0_10 sf
.447 .045(We appreciate the helpful discussions with Peter Deutsch, Richard Fateman, Robert Keller, Nori Suzuki and David)J
72 359 :M
-.012(Wise about these concepts.)A
72 375 :M
f2_10 sf
.597(References)A
72 390 :M
f0_10 sf
1.331 .133(Abadi, M., and Plotkin, G.D.  "A Logical View of Composition and Refinement".  )J
f1_10 sf
1.596 .16(Proc. ACM POPL 18)J
f0_10 sf
1.266 .127( \(Jan.)J
89 401 :M
.026(1991\),323-332.)A
72 412 :M
.69 .069(Arvind, and Nikhil, R.S.  "Executing a program on the MIT tagged-token dataflow architecture".  )J
f1_10 sf
.781 .078(PARLE'87, v. II)J
f0_10 sf
(,)S
89 423 :M
.461 .046(Springer LNCS 259, 1987, 1-29.)J
72 434 :M
.654 .065(Arvind, and Nikhil, R.S., and Pingali K.K.  "I-Structures: Data Structures for Parallel Computing".  )J
f1_10 sf
1.278 .128(ACM TOPLAS)J
89 445 :M
.172(11)A
f0_10 sf
1.012 .101(,4 \(Oct.\3121989\),598-632.)J
72 456 :M
.383 .038(Baker, H.G., and Hewitt, C.  "The Incremental Garbage Collection of Processes".  )J
f1_10 sf
.373 .037(Proc. ACM Symp. on AI & Progr.)J
89 467 :M
.721 .072(Langs., Sigplan Not. 12)J
f0_10 sf
1.175 .118(,8 \(Aug.\3121977\),55-59.)J
72 478 :M
.449 .045(Baker, H.G.  "Shallow Binding in Lisp 1.5".  )J
f1_10 sf
.789 .079(CACM 21)J
f0_10 sf
.98 .098(,7 \(July\3121978\),565-569.)J
72 489 :M
.937 .094(Baker, H.G.  "Unify and Conquer \(Garbage, Updating, Aliasing, ...\) in Functional Languages".  )J
f1_10 sf
1.177 .118(Proc. 1990 ACM)J
89 500 :M
.292 .029(Conf. on Lisp and Functional Progr.)J
f0_10 sf
.49 .049(, June\3121990,218-226.)J
72 511 :M
.288 .029(Baker, H.G.  "Equal Rights for Functional Objects".  ACM )J
f1_10 sf
.415 .041(OOPS Messenger 4)J
f0_10 sf
.388 .039(,4 \(Oct.\3121993\), 2-27.)J
72 522 :M
.395 .04(Baker, H.G.  "Shallow Binding Makes Functional Arrays Fast".  )J
f1_10 sf
.433 .043(ACM Sigplan Not. 26)J
f0_10 sf
.748 .075(,8 \(Aug.\3121991\),145-147.)J
72 533 :M
.151 .015(Baker, H.G.  "The Boyer Benchmark at Warp Speed".  ACM )J
f1_10 sf
.179 .018(Lisp Pointers V)J
f0_10 sf
.229 .023(,3 \(Jul-Sep\3121992\), 13-14.)J
72 544 :M
.322 .032(Barth, J.  "Shifting garbage collection overhead to compile time".  )J
f1_10 sf
.508 .051(CACM 20)J
f0_10 sf
.631 .063(,7 \(July\3121977\),513-518.)J
72 555 :M
.265 .026(Barth, Paul S., )J
f1_10 sf
.235 .023(et al)J
f0_10 sf
.332 .033(.  "M-Structures: Extending a Parallel, Non-strict, Functional Language with State".  )J
f1_10 sf
.481 .048(Proc. Funct.)J
89 566 :M
.248 .025(Progr. Langs. & Computer Arch.)J
f0_10 sf
.277 .028(, LNCS 523, Springer-Verlag, Aug. 1991,538-568.)J
72 577 :M
.364 .036(Bawden, Alan.  "Connection Graphs".  )J
f1_10 sf
.348 .035(Proc. ACM Conf. on Lisp & Funct. Progr.)J
f0_10 sf
.441 .044(, Camb., MA, Aug. 1986,258-265.)J
72 588 :M
.864 .086(Beeler, M., Gosper, R.W, and Schroeppel, R.  "HAKMEM".  AI Memo 239, MIT AI Lab., Feb. 1972.  Important)J
89 599 :M
.685 .068(items: 102, 103, 104, 149, 150, 161, 166, 172.)J
72 610 :M
.239 .024(Berry, G., and Boudol, G.  "The Chemical Abstract Machine".  )J
f1_10 sf
.317 .032(ACM POPL 17)J
f0_10 sf
.284 .028(, San Francisco, CA, Jan. 1990,81-94.)J
72 621 :M
.206 .021(Bloss, A.  "Update Analysis and the Efficient Implementation of Functional Aggregates".  )J
f1_10 sf
.206 .021(4'th Conf. on Funct. Progr.)J
89 632 :M
.651 .065(& Comp. Arch.)J
f0_10 sf
.602 .06(, London, Sept. 1989, 26-38.)J
72 643 :M
.382 .038(Chase, David.  "Garbage Collection and Other Optimizations".  PhD Thesis, Rice U. Comp. Sci. Dept., Nov.\3121987.)J
72 654 :M
.313 .031(Collins, G.E.  "A method for overlapping and erasure of lists".  )J
f1_10 sf
.501 .05(CACM 3)J
f0_10 sf
.696 .07(,12 \(Dec.\3121960\),655-657.)J
72 665 :M
1.359 .136(Ershov, A.P.  "On Programming of Arithmetic Operations".  )J
f1_10 sf
1.563 .156(Doklady, AN USSR 118)J
f0_10 sf
1.869 .187(,3 \(1958\),427-430, transl.)J
89 676 :M
.858 .086(Friedman, M.D., )J
f1_10 sf
.981 .098(CACM 1)J
f0_10 sf
1.227 .123(,8 \(Aug.\3121958\),3-6.)J
72 687 :M
.289 .029(Fateman, Richard J.  "Endpaper: FRPOLY: A Benchmark Revisited".  )J
f1_10 sf
.287 .029(Lisp & Symbolic Comput. 4)J
f0_10 sf
.454 .045( \(1991\),155-164.)J
72 698 :M
.227 .023(Gabriel, R.P.  )J
f1_10 sf
.35 .035(Performance and Evaluation of Lisp Systems)J
f0_10 sf
.237 .024(.  MIT Press, 1985.)J
72 709 :M
.364 .036(Gabriel, R.P.  "The Why of Y".  )J
f1_10 sf
.539 .054(ACM Lisp Pointers 2)J
f0_10 sf
.948 .095(,2 \(Oct.-Dec.\3121988\),15-25.)J
endp
%%Page: 7 7
%%BeginPageSetup
initializepage
(Henry Baker; page: 7 of 10)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 49 :M
f0_12 sf
.611 .061(ACM )J
f1_12 sf
.854 .085(Sigplan Notices)J
f0_12 sf
.077 .008( )J
f2_12 sf
.169(27)A
f0_12 sf
.984 .098(,8 \(Aug.\3121992\),89-98.)J
72 753 :M
-.05(\251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(7)S
72 81 :M
f0_10 sf
.094 .009(Girard, J.-Y.  "Linear Logic".  )J
f1_10 sf
.143 .014(Theoretical Computer Sci. 50)J
f0_10 sf
.176 .018( \(1987\),1-102.)J
72 92 :M
.657 .066(Goto, Eiichi.  "Monocopy and Associative Algorithms in an Extended Lisp".  Tech. Rep. 74-03, Info. Sci. Lab., U.)J
89 103 :M
.483 .048(Tokyo, April 1974.)J
72 114 :M
1.504 .15(Goto, Eiichi, and Kanada, Yasumasa.  "Hashing Lemmas on Time Complexities with Applications to Formula)J
89 125 :M
.804 .08(Manipulation".  )J
f1_10 sf
1.098 .11(Proc. ACM SYMSAC'76)J
f0_10 sf
.78 .078(, Yorktown Hgts., NY, 1976.)J
72 136 :M
.415 .042(Goto, E., )J
f1_10 sf
.376 .038(et al)J
f0_10 sf
.467 .047(.  "Parallel Hashing Algorithms".  )J
f1_10 sf
.459 .046(Info. Proc. Let. 6)J
f0_10 sf
.89 .089(,1 \(Feb.\3121977\),8-13.)J
72 147 :M
.367 .037(Goto, E., )J
f1_10 sf
.356 .036(et al.)J
f0_10 sf
.349 .035(  "Design of a Lisp Machine \321 FLATS".  )J
f1_10 sf
.467 .047(Proc. ACM Lisp & Funct. Progr. Conf.)J
f0_10 sf
.752 .075(, 1982,208-215.)J
72 158 :M
2.323 .232(Harms, D.E., and Weide, B.W.  "Copying and Swapping: Influences on the Design of Reusable Software)J
89 169 :M
.462 .046(Components".  )J
f1_10 sf
.428 .043(IEEE Trans. SW Engrg. 17)J
f0_10 sf
.782 .078(,5 \(May\3121991\),424-435.)J
72 180 :M
1.445 .145(Hederman, Lucy.  "Compile Time Garbage Collection".  MS Thesis, Rice University Computer Science Dept.,)J
89 191 :M
.372(Sept.\3121988.)A
72 202 :M
.476 .048(Herlihy, Maurice.  "Wait-Free Synchronization".  )J
f1_10 sf
.562 .056(ACM TOPLAS 11)J
f0_10 sf
.754 .075(,1 \(Jan.\3121991\),124-149.)J
72 213 :M
1.092 .109(Inoue, K., )J
f1_10 sf
.929 .093(et al)J
f0_10 sf
1.165 .117(.  "Analysis of functional programs to detect run-time garbage cells".  )J
f1_10 sf
1.73 .173(ACM TOPLAS 10)J
f0_10 sf
1.418 .142(,4 \(Oct.)J
89 224 :M
.352 .035(1988\), 555-578.)J
72 235 :M
.891 .089(Johnsson, T.  "Efficient compilation of lazy evaluation".  )J
f1_10 sf
1.023 .102(Proc. 1984 ACM Conf. on Compiler Constr.)J
f0_10 sf
1.272 .127(, Montreal,)J
89 246 :M
.125(1984.)A
72 257 :M
.278 .028(Johnsson, T.  "Lambda lifting: transforming programs to recursive equations".  )J
f1_10 sf
.409 .041(Proc. FPCA)J
f0_10 sf
.315 .031(, Nancy, France, Springer)J
89 268 :M
.623 .062(LNCS 201, 1985,190-203.)J
72 279 :M
.724 .072(Johnsson, T.  "Parallel Evaluation of Functional Programs: The <v,G>-machine approach".  )J
f1_10 sf
.696 .07(Proc. PARLE'91, v. I.)J
f0_10 sf
(,)S
89 290 :M
.371 .037(Springer LNCS 505, Berlin, 1991, 1-5.)J
72 301 :M
.381 .038(Jones, S.B., and Le Metayer, D.  "Compile-time garbage collection by sharing analysis".  )J
f1_10 sf
.495 .049(ACM Funct. Progr. Langs.)J
89 312 :M
.803 .08(& Comp. Arch.)J
f0_10 sf
.733 .073(, 1989, 54-74.)J
72 323 :M
.728 .073(Kieburtz, Richard B.  "Programming without pointer variables".  )J
f1_10 sf
.79 .079(Proc. Conf. on Data: Abstraction, Definition and)J
89 334 :M
.259 .026(Structure, Sigplan Not. 11)J
f0_10 sf
.275 .027( \(special issue 1976\),95-107.)J
72 345 :M
-.011(Kieburtz, Richard B.  "The G-machine: a fast, graph-reduction evaluator".  )A
f1_10 sf
-.013(Proc. IFIP FPCA)A
f0_10 sf
-.012(, Nancy, France, 1985.)A
72 356 :M
1.155 .115(Kieburtz, Richard B.  "A RISC Architecture for Symbolic Computation".  )J
f1_10 sf
1.164 .116(Proc. ASPLOS II, Sigplan Not. 22)J
f0_10 sf
.438(,10)A
89 367 :M
.2 .02(\(Oct. 1987\),146-155.)J
72 378 :M
1.12 .112(Knight, Tom.  "An Architecture for Mostly Functional Languages".  )J
f1_10 sf
1.05 .105(Proc. ACM Conf. on Lisp & Funct. Progr.)J
f0_10 sf
(,)S
89 389 :M
.507 .051(MIT, Aug. 1986,105-112.)J
72 400 :M
.151 .015(Lafont, Yves.  "The Linear Abstract Machine".  )J
f1_10 sf
.185 .018(Theor. Computer Sci. 59)J
f0_10 sf
.268 .027( \(1988\),157-180.)J
72 411 :M
.368 .037(Lafont, Yves.  "Interaction Nets".  )J
f1_10 sf
.499 .05(ACM POPL 17)J
f0_10 sf
.449 .045(, San Franciso, CA, Jan. 1990,95-108.)J
72 422 :M
.222 .022(Lafont, Yves.  "The Paradigm of Interaction \(Short Version\)".  Unpubl. manuscript, July 12, 1991, 18p.)J
72 433 :M
.607 .061(Lieberman, H., and Hewitt, C.  "A Real-Time Garbage Collector Based on the Lifetimes of Objects".  )J
f1_10 sf
.945 .094(CACM 26)J
f0_10 sf
.332 .033(, 6)J
89 444 :M
.115(\(June\3121983\),419-429.)A
72 455 :M
.243 .024(MacLennan, B.J.  "Values and Objects in Programming Languages".  )J
f1_10 sf
.255 .025(Sigplan Not. 17)J
f0_10 sf
.41 .041(,2 \(Dec.\3121982\),70-79.)J
72 466 :M
.49 .049(Mairson, H.G.  "Deciding ML Typability is Complete for Deterministic Exponential Time".  )J
f1_10 sf
.601 .06(17'th ACM POPL)J
f0_10 sf
.399 .04(, Jan.)J
89 477 :M
.51 .051(1990, 382-401.)J
72 488 :M
.277 .028(Mason, Ian A.  )J
f1_10 sf
.459 .046(The Semantics of Destructive Lisp)J
f0_10 sf
.319 .032(.  Ctr. for the Study of Lang. & Info., Stanford, CA, 1986.)J
72 499 :M
.744 .074(Moon, D.  "Garbage Collection in a Large Lisp System".  )J
f1_10 sf
.915 .091(ACM Symp. on Lisp and Functional Prog.)J
f0_10 sf
.871 .087(, Austin, TX,)J
89 510 :M
.51 .051(1984, 235-246.)J
72 521 :M
.266 .027(Morris, J.M.  "A proof of the Schorr-Waite algorithm".  In Broy, M., and Schmidt, G., )J
f1_10 sf
.094(Eds)A
f0_10 sf
.061 .006(.  )J
f1_10 sf
.584 .058(Theoretical Foundations)J
89 532 :M
.121 .012(of Programming Methodology)J
f0_10 sf
.077 .008(.  NATA Advanced Study Inst., D. Reidel, 1982,43-51.)J
72 543 :M
.323 .032(Myers, Eugene W.  "Efficient Applicative Data Types".  )J
f1_10 sf
.405 .041(ACM POPL 11)J
f0_10 sf
.324 .032(, Salt Lake City, UT, Jan. 1984,66-75.)J
72 554 :M
.136 .014(Peyton-Jones, S.L.  )J
f1_10 sf
.198 .02(The Implementation of Functional Programming Languages)J
f0_10 sf
.14 .014(.  Prentice-Hall, New York, 1987.)J
72 565 :M
.916 .092(Rees, J. and Clinger, W., )J
f1_10 sf
.795 .079(et al)J
f0_10 sf
1.041 .104(.  "Revised Report on the Algorithmic Language Scheme".  )J
f1_10 sf
1.355 .136(Sigplan Notices 21)J
f0_10 sf
.426(,12)A
89 576 :M
.113(\(Dec.\3121986\),37-79.)A
72 587 :M
1.169 .117(Ruggieri, Cristina; and Murtagh, Thomas P.  "Lifetime analysis of dynamically allocated objects".  )J
f1_10 sf
2.007 .201(ACM POPL)J
89 598 :M
.043('88)A
f0_10 sf
.051(,285-293.)A
72 609 :M
1.045 .105(Schorr, H., and Waite, W.M.  "An efficient machine-independent procedure for garbage collection in various list)J
89 620 :M
.401 .04(structures".  )J
f1_10 sf
.64 .064(CACM 10)J
f0_10 sf
.625 .063(,8 \(Aug. 1967\),501-506.)J
72 631 :M
.216 .022(Strom, R.E., )J
f1_10 sf
.159 .016(et al)J
f0_10 sf
.208 .021(.  "A recoverable object store".  IBM Watson Research Ctr., 1988.)J
72 642 :M
.522 .052(Suzuki, N.  "Analysis of Pointer 'Rotation'".  )J
f1_10 sf
.87 .087(CACM 25,)J
f0_10 sf
1.147 .115(5 \(May\3121982\)330-335.)J
72 653 :M
.148 .015(Terashima, M., and Goto, E.  "Genetic Order and Compactifying Garbage Collectors".  )J
f1_10 sf
.135 .013(IPL 7)J
f0_10 sf
.25 .025(,1 \(Jan.\3121978\),27-32.)J
72 664 :M
.042 .004(Turner, D.  "A New Implementation Technique for Applicative Languages".  )J
f1_10 sf
.078 .008(SW\321Pract.&Exper. 9)J
f0_10 sf
.061 .006( \(1979\),31-49.)J
72 675 :M
.181 .018(Wadler, Philip.  "Linear types can change the world!".  )J
f1_10 sf
.208 .021(IFIP TC2 Conf. on Progr. Concepts & Meths.)J
f0_10 sf
.202 .02(, April 1990.)J
72 686 :M
.165 .016(Wadler, Philip.  "Is there a use for linear logic?".  )J
f1_10 sf
.316 .032(Proc. ACM PEPM'91)J
f0_10 sf
.264 .026(, New Haven, June, 1991,255-273.)J
72 697 :M
.969 .097(Wakeling, D., and Runciman, C.  "Linearity and Laziness".  )J
f1_10 sf
1.155 .116(Proc. Funct. Progr. & Computer Arch.)J
f0_10 sf
1.071 .107(, LNCS 523,)J
89 708 :M
.091 .009(Springer-Verlag, Aug. 1991,215-240.)J
endp
%%Page: 8 8
%%BeginPageSetup
initializepage
(Henry Baker; page: 8 of 10)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 49 :M
f0_12 sf
.611 .061(ACM )J
f1_12 sf
.854 .085(Sigplan Notices)J
f0_12 sf
.077 .008( )J
f2_12 sf
.169(27)A
f0_12 sf
.984 .098(,8 \(Aug.\3121992\),89-98.)J
72 753 :M
-.05(\251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(8)S
72 81 :M
f0_10 sf
.437 .044(Weizenbaum, J.  "Symmetric List Processor".  )J
f1_10 sf
.59 .059(CACM 6)J
f0_10 sf
.803 .08(,9 \(Dec.\3121963\),524-544.)J
72 92 :M
.231 .023(White, Jon L.  "Address/Memory Management for a Gigantic LISP Environment, or GC Considered Harmful".  )J
f1_10 sf
.074(Proc.)A
89 103 :M
.694 .069(1980 Lisp Conf.)J
f0_10 sf
.838 .084(, Stanford U., Aug.\3121980,119-127.)J
72 114 :M
.308 .031(Wilson, Paul R.  )J
f1_10 sf
.576 .058(Two comprehensive virtual copy mechanisms)J
f0_10 sf
.362 .036(.  Master's Thesis, U. Ill. @ Chicago, 1988.)J
72 125 :M
.284 .028(Wilson, P.R., and Moher, T.G.  "Demonic memory for process histories".  )J
f1_10 sf
.382 .038(Proc. Sigplan PLDI)J
f0_10 sf
.284 .028(, June 1989.)J
72 136 :M
.727 .073(Wilson, Paul R.  "Some Issues and Strategies in Heap Management and Memory Hierarchies".  )J
f1_10 sf
.957 .096(ACM Sigplan Not.)J
89 147 :M
.117(26)A
f0_10 sf
.706 .071(,3 \(March\3121991\),45-52.)J
72 158 :M
.269 .027(Wise, D.S., and Friedman, D.P.  "The one-bit reference count".  )J
f1_10 sf
.313 .031(BIT 17)J
f0_10 sf
.539 .054(,3 \(Sept.\3121977\),351-359.)J
72 169 :M
.217 .022(Wise, David S.  "Design for a Multiprocessing Heap with On-board Reference Counting".  )J
f1_10 sf
.265 .027(Proc. Funct. Progr. Langs)J
89 180 :M
.456 .046(& Computer Arch.)J
f0_10 sf
.417 .042(, Nancy, France, LNCS 201, Springer, Sept., 1985,289-304.)J
72 196 :M
f2_10 sf
2.635 .264(Appendix.  A Metacircular Linear Lisp Interpreter)J
88 211 :M
f5_10 sf
.006 .001(\(defmacro free \(x\) `\(setq ,x nil\)\) ; just for testing...)J
88 226 :M
(\(defmacro mif \(be te ee\))S
88 237 :M
(  \(let \(\(vs \(car \(freevars be\)\)\)\))S
88 248 :M
(    `\(if-function)S
88 259 :M
(       #'\(lambda \(\) ,be\))S
88 270 :M
(       #'\(lambda ,vs ,te\))S
88 281 :M
(       #'\(lambda ,vs ,ee\)\)\)\))S
88 296 :M
(\(defun if-function \(be te ee\))S
88 307 :M
.005 .001(  \(dlet* \(\(\(pval . stuff\) \(funcall be\)\)\))J
88 318 :M
.004 0(    \(if pval \(apply te stuff\) \(apply ee stuff\)\)\)\))J
88 333 :M
(\(defmacro mcond \(&rest clauses\))S
88 344 :M
.005 .001(  \(dlet* \(\(\(\(be . rest\) . clauses\) clauses\)\))J
88 355 :M
(    \(if \(eq be 't\) `\(progn ,@rest\))S
88 366 :M
(      `\(mif ,be \(progn ,@rest\))S
88 377 :M
(         \(mcond ,@clauses\)\)\)\)\))S
88 392 :M
(\(defun matom \(x\) `\(,\(atom x\) ,x\)\))S
88 407 :M
(\(defun meq \(x y\) `\(,\(eq x y\) ,x\)\))S
88 422 :M
.005 0(\(defun meq2 \(x y\) `\(,\(eq x y\) ,x ,y\)\))J
88 437 :M
.006 .001(\(defun msymbolp \(x\) `\(,\(symbolp x\) ,x\)\))J
88 452 :M
(\(defun mnull \(x\) `\(,\(null x\) ,x\)\))S
88 467 :M
.007 .001(\(defun mcopy \(x\) ; Pedagogical non-primitive copy function.)J
88 478 :M
.005 0(  \(mif \(matom x\) `\(,x ,@x\) ; primitive is allowed to copy symbol refs.)J
88 489 :M
(    \(dlet* \(\(\(carx . cdrx\) x\))S
88 500 :M
.003 0(            \(\(ncar1 . ncar2\) \(mcopy carx\)\))J
88 511 :M
.003 0(            \(\(ncdr1 . ncdr2\) \(mcopy cdrx\)\)\))J
88 522 :M
.005 0(      `\(\(,ncar1 ,@ncdr1\) . \(,ncar2 ,@ncdr2\)\)\)\)\))J
88 537 :M
.005 .001(\(defun massoc \(x e\) ; return binding, else nil.)J
88 548 :M
.005 0(  \(mif \(mnull e\) \(progn \(free x\) `\(nil ,@e\)\))J
88 559 :M
.004 0(    \(dlet* \(\(\(\(var . val\) . reste\) e\)\))J
88 570 :M
.004 0(      \(mif \(meq2 x var\) \(progn \(free x\) `\(\(,var ,@val\) ,@reste\)\))J
88 581 :M
.004 0(        \(dlet* \(\(\(nbinding . nreste\) \(massoc x reste\)\)\))J
88 592 :M
.004 0(          `\(,nbinding . \(\(,var ,@val\) ,@nreste\)\)\)\)\)\)\))J
88 607 :M
(\(defun mevprogn \(xl e\))S
88 618 :M
(  \(dlet* \(\(\(x . xl\) xl\)\))S
88 629 :M
.004 0(    \(mif \(mnull xl\) \(progn \(assert \(null xl\)\) \(meval x e\)\))J
88 640 :M
.004 0(      \(dlet* \(\(\(xval . ne\) \(meval x e\)\))J
88 651 :M
.003 0(              \(\(xlval . nne\) \(mevprogn xl ne\)\)\))J
88 662 :M
(        \(free xval\))S
88 673 :M
(        `\(,xlval ,@nne\)\)\)\)\))S
endp
%%Page: 9 9
%%BeginPageSetup
initializepage
(Henry Baker; page: 9 of 10)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 49 :M
f0_12 sf
.611 .061(ACM )J
f1_12 sf
.854 .085(Sigplan Notices)J
f0_12 sf
.077 .008( )J
f2_12 sf
.169(27)A
f0_12 sf
.984 .098(,8 \(Aug.\3121992\),89-98.)J
72 753 :M
-.05(\251 1991, 1992 by Nimble Computer Corporation)A
498 753 :M
(9)S
88 85 :M
f5_10 sf
(\(defun meval \(x e\))S
88 96 :M
(  \(mcond)S
88 107 :M
.005 0(   \(\(msymbolp x\) \(dlet* \(\(\(\(var . val\) . ne\) \(massoc x e\)\)\))J
88 118 :M
(                   \(free var\))S
88 129 :M
(                   `\(,val ,@ne\)\)\))S
88 140 :M
(   \(\(matom x\) `\(,x ,@e\)\))S
88 151 :M
(   \(t \(dlet* \(\(fn . args\) x\)\))S
88 162 :M
(        \(mcond)S
88 173 :M
.004 0(         \(\(meq fn 'progn\) \(free fn\) \(mevprogn args e\)\))J
88 184 :M
.003 0(         \(\(meq fn 'function\) \(free fn\))J
88 195 :M
(          \(dlet* \(\(\(lambda\) args\))S
88 206 :M
.003 0(                  \(\(nlambda . lambda\) \(mcopy lambda\)\))J
88 217 :M
.003 0(                  \(\(fvars . bvars\) \(freevars `\(function ,nlambda\) nil nil\)\))J
88 228 :M
.002 0(                  \(\(e1 . e2\) \(split fvars e\)\)\))J
88 239 :M
.003 0(            `\(\(funarg ,lambda ,e1\) ,@e2\)\)\))J
88 250 :M
.003 0(         \(\(meq fn 'funcall\) \(free fn\))J
88 261 :M
.004 0(          \(dlet* \(\(\(\(nfn . nargs\) . ne\) \(mevlis args e\)\)\))J
88 272 :M
.003 0(            `\(,\(mapply nfn nargs\) ,@ne\)\)\))J
88 283 :M
.004 0(         \(t \(dlet* \(\(\(nargs . ne\) \(mevlis args e\)\)\))J
88 294 :M
.004 0(              `\(,\(mapply \(symbol-function fn\) nargs\) ,@ne\)\)\)\)\)\)\)\))J
88 309 :M
(\(defun mapply \(fn args\))S
88 320 :M
(  \(mif \(matom fn\) \(apply fn args\))S
88 331 :M
(    \(dlet* \(\(\(ffn . rfn\) fn\)\))S
88 342 :M
(      \(mcond)S
88 353 :M
.004 0(       \(\(meq ffn 'lambda\) \(free ffn\))J
88 364 :M
.003 0(        \(dlet* \(\(\(bvlist . body\) rfn\))J
88 375 :M
.003 0(                \(\(v . ne\) \(mevprogn body \(mpairlis bvlist args nil\)\)\)\))J
88 386 :M
(          \(assert \(null ne\)\))S
88 397 :M
(          v\)\))S
88 408 :M
.004 0(       \(\(meq ffn 'funarg\) \(free ffn\))J
88 419 :M
.004 0(        \(dlet* \(\(\(\(lambda bvlist . body\) ce\) rfn\))J
88 430 :M
.003 0(                \(\(v . ne\) \(mevprogn body \(mpairlis bvlist args ce\)\)\)\))J
88 441 :M
.003 0(          \(free lambda\) \(assert \(null ne\)\))J
88 452 :M
(          v\)\))S
88 463 :M
.004 0(       \(t \(error "mapply: bad fn ~S" fn\)\)\)\)\)\))J
88 478 :M
(\(defun mpairlis \(vars vals e\))S
88 489 :M
.005 .001(  \(mif \(mnull vars\) \(progn \(assert \(null vals\)\) e\))J
88 500 :M
(    \(dlet* \(\(\(var . vars\) vars\))S
88 511 :M
(            \(\(val . vals\) vals\)\))S
88 522 :M
.004 0(      `\(\(,var ,@val\) ,@\(mpairlis vars vals e\)\)\)\)\))J
88 537 :M
(\(defun mevlis \(args e\))S
88 548 :M
.005 .001(  \(mif \(mnull args\) \(progn \(assert \(null args\)\) `\(nil ,@e\)\))J
88 559 :M
(    \(dlet* \(\(\(x . args\) args\))S
88 570 :M
.002 0(            \(\(xval . e\) \(meval x e\)\))J
88 581 :M
.003 0(            \(\(argvals . e\) \(mevlis args e\)\)\))J
88 592 :M
(      `\(\(,xval ,@argvals\) ,@e\)\)\)\))S
88 607 :M
.005 .001(\(defun split \(vars e\) ; split env. into 2 segments.)J
88 618 :M
.005 .001(  \(mif \(mnull vars\) \(progn \(assert \(null vars\)\) `\(nil ,@e\)\))J
88 629 :M
(    \(dlet* \(\(\(var . nvars\) vars\))S
88 640 :M
.003 0(            \(\(binding . ne\) \(massoc var e\)\))J
88 651 :M
.003 0(            \(\(e1 . e2\) \(split nvars ne\)\)\))J
88 662 :M
(      `\(\(,binding ,@e1\) ,@e2\)\)\)\))S
endp
%%Page: 10 10
%%BeginPageSetup
initializepage
(Henry Baker; page: 10 of 10)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
72 49 :M
f0_12 sf
.611 .061(ACM )J
f1_12 sf
.854 .085(Sigplan Notices)J
f0_12 sf
.077 .008( )J
f2_12 sf
.169(27)A
f0_12 sf
.984 .098(,8 \(Aug.\3121992\),89-98.)J
72 753 :M
-.05(\251 1991, 1992 by Nimble Computer Corporation)A
492 753 :M
(10)S
88 85 :M
f5_10 sf
.005 .001(\(defun mmember \(x ls\) ; return truth value & rest of list.)J
88 96 :M
.005 0(  \(mif \(mnull ls\) \(progn \(free x\) `\(nil ,@ls\)\))J
88 107 :M
(    \(dlet* \(\(\(carls . ls\) ls\)\))S
88 118 :M
.004 0(      \(mif \(meq2 x carls\) \(progn \(free x\) `\(,carls ,@ls\)\))J
88 129 :M
.004 0(        \(dlet* \(\(\(tval . rest\) \(mmember x ls\)\)\))J
88 140 :M
.004 0(          `\(,tval . \(,carls ,@rest\)\)\)\)\)\)\))J
88 155 :M
.005 .001(\(defun freevars \(x bvars fvars\) ; return new fvars and new bvars.)J
88 166 :M
(  \(mcond)S
88 177 :M
(   \(\(msymbolp x\))S
88 188 :M
(    \(dlet* \(\(\(x1 . x2\) \(mcopy x\)\))S
88 199 :M
(            \(\(x2 . x3\) \(mcopy x2\)\))S
88 210 :M
.003 0(            \(\(p1val . nbvars\) \(mmember x1 bvars\)\))J
88 221 :M
.003 0(            \(\(p2val . nfvars\) \(mmember x2 fvars\)\)\))J
88 232 :M
.004 0(      \(mif p1val \(progn \(free x3\) `\(,nfvars ,@nbvars\)\))J
88 243 :M
.004 0(        \(mif p2val \(progn \(free x3\) `\(,nfvars ,@nbvars\)\))J
88 254 :M
.004 0(          `\(\(,x ,@nfvars\) ,@nbvars\)\)\)\)\))J
88 265 :M
.005 0(   \(\(matom x\) \(free x\) `\(,fvars ,@bvars\)\))J
88 276 :M
(   \(t \(dlet* \(\(\(fn . args\) x\)\))S
88 287 :M
(        \(mcond)S
88 298 :M
.003 0(         \(\(meq fn 'function\) \(free fn\))J
88 309 :M
.004 0(          \(dlet* \(\(\(\(lambda bvlist . body\)\) args\)\))J
88 320 :M
(            \(free lambda\))S
88 331 :M
.004 0(            \(freelistvars body `\(,@bvlist ,@bvars\) fvars\)\)\))J
88 342 :M
.004 0(         \(t \(freelistvars `\(,fn ,@args\) bvars fvars\)\)\)\)\)\)\))J
88 357 :M
.007 .001(\(defun freelistvars \(xl bvars fvars\))J
88 368 :M
.005 .001(  \(mif \(mnull xl\) \(progn \(assert \(null xl\)\) `\(,fvars ,@bvars\)\))J
88 379 :M
(    \(dlet* \(\(\(x . xl\) xl\))S
88 390 :M
.004 0(            \(\(nfvars . nbvars\) \(freelistvars xl bvars fvars\)\)\))J
88 401 :M
.004 0(      \(freevars x nbvars nfvars\)\)\)\))J
endp
%%Trailer
end
%%EOF
