%!PS-Adobe-3.0 EPSF-2.0%%Creator: Windows PSCRIPT%%Title: Microsoft Word - GC-NODOT.DOC%%BoundingBox: 18 9 593 784%%DocumentNeededResources: (atend)%%DocumentSuppliedResources: (atend)%%Pages: 0%%BeginResource: procset Win35Dict 3 1/Win35Dict 290 dict def Win35Dict begin/bd{bind def}bind def/in{72mul}bd/ed{exch def}bd/ld{load def}bd/tr/translate ld/gs/gsave ld/gr/grestore ld/M/moveto ld/L/lineto ld/rmt/rmoveto ld/rlt/rlineto ld/rct/rcurveto ld/st/stroke ld/n/newpath ld/sm/setmatrix ld/cm/currentmatrixld/cp/closepath ld/ARC/arcn ld/TR{65536 div}bd/lj/setlinejoin ld/lc/setlinecap ld/ml/setmiterlimit ld/sl/setlinewidth ld/scignore falsedef/sc{scignore{pop pop pop}{0 index 2 index eq 2 index 4 index eqand{pop pop 255 div setgray}{3{255 div 3 1 roll}repeat setrgbcolor}ifelse}ifelse}bd/FC{bR bG bB sc}bd/fC{/bB ed/bG ed/bR ed}bd/HC{hR hG hB sc}bd/hC{/hB ed/hG ed/hR ed}bd/PC{pR pG pB sc}bd/pC{/pB ed/pG ed/pR ed}bd/sMmatrix def/PenW 1 def/iPen 5 def/mxF matrix def/mxE matrix def/mxUEmatrix def/mxUF matrix def/fBE false def/iDevRes 72 0 matrix defaultmatrixdtransform dup mul exch dup mul add sqrt def/fPP false def/SS{fPP{/SV save def}{gs}ifelse}bd/RS{fPP{SV restore}{gr}ifelse}bd/EJ{gsaveshowpage grestore}bd/#C{userdict begin/#copies ed end}bd/FEbuf 2 stringdef/FEglyph(G  )def/FE{1 exch{dup 16 FEbuf cvrs FEglyph exch 1 exchputinterval 1 index exch FEglyph cvn put}for}bd/SM{/iRes ed/cyP ed/cxPg ed/cyM ed/cxM ed 72 100 div dup scale dup 0 ne{90 eq{cyM exch0 eq{cxM exch tr -90 rotate -1 1 scale}{cxM cxPg add exch tr +90 rotate}ifelse}{cyPcyM sub exch 0 ne{cxM exch tr -90 rotate}{cxM cxPg add exch tr -90rotate 1 -1 scale}ifelse}ifelse}{pop cyP cyM sub exch 0 ne{cxM cxPgadd exch tr 180 rotate}{cxM exch tr 1 -1 scale}ifelse}ifelse 100 iResdiv dup scale 0 0 transform .25 add round .25 sub exch .25 add round.25 sub exch itransform translate}bd/SJ{1 index 0 eq{pop pop/fBE falsedef}{1 index/Break ed div/dxBreak ed/fBE true def}ifelse}bd/ANSIVec[16#0/grave 16#1/acute 16#2/circumflex 16#3/tilde 16#4/macron 16#5/breve16#6/dotaccent 16#7/dieresis 16#8/ring 16#9/cedilla 16#A/hungarumlaut16#B/ogonek 16#C/caron 16#D/dotlessi 16#27/quotesingle 16#60/grave16#7C/bar 16#82/quotesinglbase 16#83/florin 16#84/quotedblbase 16#85/ellipsis 16#86/dagger 16#87/daggerdbl 16#88/circumflex 16#89/perthousand16#8A/Scaron 16#8B/guilsinglleft 16#8C/OE 16#91/quoteleft 16#92/quoteright16#93/quotedblleft 16#94/quotedblright 16#95/bullet 16#96/endash 16#97/emdash 16#98/tilde 16#99/trademark 16#9A/scaron 16#9B/guilsinglright16#9C/oe 16#9F/Ydieresis 16#A0/space 16#A1/exclamdown 16#A4/currency16#A5/yen 16#A6/brokenbar 16#A7/section 16#A8/dieresis 16#A9/copyright16#AA/ordfeminine 16#AB/guillemotleft 16#AC/logicalnot 16#AD/hyphen16#AE/registered 16#AF/macron 16#B0/degree 16#B1/plusminus 16#B2/twosuperior16#B3/threesuperior 16#B4/acute 16#B5/mu 16#B6/paragraph 16#B7/periodcentered16#B8/cedilla 16#B9/onesuperior 16#BA/ordmasculine 16#BB/guillemotright16#BC/onequarter 16#BD/onehalf 16#BE/threequarters 16#BF/questiondown16#C0/Agrave 16#C1/Aacute 16#C2/Acircumflex 16#C3/Atilde 16#C4/Adieresis16#C5/Aring 16#C6/AE 16#C7/Ccedilla 16#C8/Egrave 16#C9/Eacute 16#CA/Ecircumflex 16#CB/Edieresis 16#CC/Igrave 16#CD/Iacute 16#CE/Icircumflex16#CF/Idieresis 16#D0/Eth 16#D1/Ntilde 16#D2/Ograve 16#D3/Oacute 16#D4/Ocircumflex 16#D5/Otilde 16#D6/Odieresis 16#D7/multiply 16#D8/Oslash16#D9/Ugrave 16#DA/Uacute 16#DB/Ucircumflex 16#DC/Udieresis 16#DD/Yacute16#DE/Thorn 16#DF/germandbls 16#E0/agrave 16#E1/aacute 16#E2/acircumflex16#E3/atilde 16#E4/adieresis 16#E5/aring 16#E6/ae 16#E7/ccedilla 16#E8/egrave 16#E9/eacute 16#EA/ecircumflex 16#EB/edieresis 16#EC/igrave16#ED/iacute 16#EE/icircumflex 16#EF/idieresis 16#F0/eth 16#F1/ntilde16#F2/ograve 16#F3/oacute 16#F4/ocircumflex 16#F5/otilde 16#F6/odieresis16#F7/divide 16#F8/oslash 16#F9/ugrave 16#FA/uacute 16#FB/ucircumflex16#FC/udieresis 16#FD/yacute 16#FE/thorn 16#FF/ydieresis ] def/reencdict12 dict def/IsChar{basefontdict/CharStrings get exch known}bd/MapCh{dupIsChar not{pop/bullet}if newfont/Encoding get 3 1 roll put}bd/MapDegree{16#b0/degree IsChar{/degree}{/ring}ifelse MapCh}bd/MapBB{16#a6/brokenbarIsChar{/brokenbar}{/bar}ifelse MapCh}bd/ANSIFont{reencdict begin/newfontnameed/basefontname ed FontDirectory newfontname known not{/basefontdictbasefontname findfont def/newfont basefontdict maxlength dict def basefontdict{exchdup/FID ne{dup/Encoding eq{exch dup length array copy newfont 3 1 rollput}{exch newfont 3 1 roll put}ifelse}{pop pop}ifelse}forall newfont/FontName newfontname put 127 1 159{newfont/Encoding get exch/bulletput}for ANSIVec aload pop ANSIVec length 2 idiv{MapCh}repeat MapDegreeMapBB newfontname newfont definefont pop}if newfontname end}bd/SB{FC/ULlen ed/str ed str length fBE not{dup 1 gt{1 sub}if}if/cbStr ed/dxGdi ed/y0 ed/x0 ed str stringwidth dup 0 ne{/y1 ed/x1 ed y1 y1mul x1 x1 mul add sqrt dxGdi exch div 1 sub dup x1 mul cbStr div exchy1 mul cbStr div}{exch abs neg dxGdi add cbStr div exch}ifelse/dyExtraed/dxExtra ed x0 y0 M fBE{dxBreak 0 BCh dxExtra dyExtra str awidthshow}{dxExtradyExtra str ashow}ifelse fUL{x0 y0 M dxUL dyUL rmt ULlen fBE{Breakadd}if 0 mxUE transform gs rlt cyUL sl [] 0 setdash st gr}if fSO{x0y0 M dxSO dySO rmt ULlen fBE{Break add}if 0 mxUE transform gs rlt cyULsl [] 0 setdash st gr}if n/fBE false def}bd/font{/name ed/Ascent ed0 ne/fT3 ed 0 ne/fSO ed 0 ne/fUL ed/Sy ed/Sx ed 10.0 div/ori ed -10.0div/esc ed/BCh ed name findfont/xAscent 0 def/yAscent Ascent def/ULescesc def ULesc mxUE rotate pop fT3{/esc 0 def xAscent yAscent mxUE transform/yAscent ed/xAscent ed}if [Sx 0 0 Sy neg xAscent yAscent] esc mxErotate mxF concatmatrix makefont setfont [Sx 0 0 Sy neg 0 Ascent] mxUEmxUF concatmatrix pop fUL{currentfont dup/FontInfo get/UnderlinePositionknown not{pop/Courier findfont}if/FontInfo get/UnderlinePosition get1000 div 0 exch mxUF transform/dyUL ed/dxUL ed}if fSO{0 .3 mxUF transform/dySO ed/dxSO ed}if fUL fSO or{currentfont dup/FontInfo get/UnderlineThicknessknown not{pop/Courier findfont}if/FontInfo get/UnderlineThickness get1000 div Sy mul/cyUL ed}if}bd/min{2 copy gt{exch}if pop}bd/max{2 copylt{exch}if pop}bd/CP{/ft ed{{ft 0 eq{clip}{eoclip}ifelse}stopped{currentflat1 add setflat}{exit}ifelse}loop}bd/patfont 10 dict def patfont begin/FontType 3 def/FontMatrix [1 0 0 -1 0 0] def/FontBBox [0 0 16 16]def/Encoding StandardEncoding def/BuildChar{pop pop 16 0 0 0 16 16setcachedevice 16 16 false [1 0 0 1 .25 .25]{pat}imagemask}bd end/p{/pat 32 string def{}forall 0 1 7{dup 2 mul pat exch 3 index put dup2 mul 1 add pat exch 3 index put dup 2 mul 16 add pat exch 3 indexput 2 mul 17 add pat exch 2 index put pop}for}bd/pfill{/PatFont patfontdefinefont setfont/ch(AAAA)def X0 64 X1{Y1 -16 Y0{1 index exch M chshow}for pop}for}bd/vert{X0 w X1{dup Y0 M Y1 L st}for}bd/horz{Y0 wY1{dup X0 exch M X1 exch L st}for}bd/fdiag{X0 w X1{Y0 M X1 X0 sub duprlt st}for Y0 w Y1{X0 exch M Y1 Y0 sub dup rlt st}for}bd/bdiag{X0 wX1{Y1 M X1 X0 sub dup neg rlt st}for Y0 w Y1{X0 exch M Y1 Y0 sub dupneg rlt st}for}bd/AU{1 add cvi 15 or}bd/AD{1 sub cvi -16 and}bd/SHR{pathbboxAU/Y1 ed AU/X1 ed AD/Y0 ed AD/X0 ed}bd/hfill{/w iRes 37.5 div rounddef 0.1 sl [] 0 setdash n dup 0 eq{horz}if dup 1 eq{vert}if dup 2 eq{fdiag}ifdup 3 eq{bdiag}if dup 4 eq{horz vert}if 5 eq{fdiag bdiag}if}bd/F{/fted fm 256 and 0 ne{gs FC ft 0 eq{fill}{eofill}ifelse gr}if fm 1536and 0 ne{SHR gs HC ft CP fm 1024 and 0 ne{/Tmp save def pfill Tmp restore}{fm15 and hfill}ifelse gr}if}bd/S{PenW sl PC st}bd/m matrix def/GW{iRes12 div PenW add cvi}bd/DoW{iRes 50 div PenW add cvi}bd/DW{iRes 8 divPenW add cvi}bd/SP{/PenW ed/iPen ed iPen 0 eq iPen 6 eq or{[] 0 setdash}ifiPen 1 eq{[DW GW] 0 setdash}if iPen 2 eq{[DoW GW] 0 setdash}if iPen3 eq{[DW GW DoW GW] 0 setdash}if iPen 4 eq{[DW GW DoW GW DoW GW] 0setdash}if}bd/E{m cm pop tr scale 1 0 moveto 0 0 1 0 360 arc cp m sm}bd/AG{/sy ed/sx ed sx div 4 1 roll sy div 4 1 roll sx div 4 1 roll sydiv 4 1 roll atan/a2 ed atan/a1 ed sx sy scale a1 a2 ARC}def/A{m cmpop tr AG m sm}def/P{m cm pop tr 0 0 M AG cp m sm}def/RRect{n 4 copyM 3 1 roll exch L 4 2 roll L L cp}bd/RRCC{/r ed/y1 ed/x1 ed/y0 ed/x0ed x0 x1 add 2 div y0 M x1 y0 x1 y1 r arcto 4{pop}repeat x1 y1 x0 y1r arcto 4{pop}repeat x0 y1 x0 y0 r arcto 4{pop}repeat x0 y0 x1 y0 rarcto 4{pop}repeat cp}bd/RR{2 copy 0 eq exch 0 eq or{pop pop RRect}{2copy eq{pop RRCC}{m cm pop/y2 ed/x2 ed/ys y2 x2 div 1 max def/xs x2y2 div 1 max def/y1 exch ys div def/x1 exch xs div def/y0 exch ys divdef/x0 exch xs div def/r2 x2 y2 min def xs ys scale x0 x1 add 2 divy0 M x1 y0 x1 y1 r2 arcto 4{pop}repeat x1 y1 x0 y1 r2 arcto 4{pop}repeatx0 y1 x0 y0 r2 arcto 4{pop}repeat x0 y0 x1 y0 r2 arcto 4{pop}repeatm sm cp}ifelse}ifelse}bd/PP{{rlt}repeat}bd/OB{gs 0 ne{7 3 roll/y ed/x ed x y translate ULesc rotate x neg y neg translate x y 7 -3 roll}ifsc B fill gr}bd/B{M/dy ed/dx ed dx 0 rlt 0 dy rlt dx neg 0 rlt cp}bd/CB{B clip n}bd/ErrHandler{errordict dup maxlength exch length gtdup{errordict begin}if/errhelpdict 12 dict def errhelpdict begin/stackunderflow(operand stack underflow)def/undefined(this name is not defined in a dictionary)def/VMerror(you have used up all the printer's memory)def/typecheck(operator was expecting a different type of operand)def/ioerror(input/output error occured)def end{end}if errordict begin/handleerror{$error begin newerror{/newerror false def showpage 7272 scale/x .25 def/y 9.6 def/Helvetica findfont .2 scalefont setfontx y moveto(Offending Command = )show/command load{dup type/stringtypene{(max err string)cvs}if show}exec/y y .2 sub def x y moveto(Error = )showerrorname{dup type dup( max err string )cvs show( : )show/stringtypene{( max err string )cvs}if show}exec errordict begin errhelpdict errornameknown{x 1 add y .2 sub moveto errhelpdict errorname get show}if end/y y .4 sub def x y moveto(Stack =)show ostack{/y y .2 sub def x 1add y moveto dup type/stringtype ne{( max err string )cvs}if show}forallshowpage}if end}def end}bd end%%EndResource/SVDoc save def%%EndProlog%%BeginSetupWin35Dict beginErrHandler/fPP true def%%EndSetupSS0 0 25 11 798 1100 300 SM32 0 0 58 58 0 0 0 54 /Times-Bold /font29 ANSIFont font0 0 0 fC375 570 1056 (Safe, Efficient Garbage Collection for C++) 1056 SB32 0 0 50 50 0 0 0 45 /Times-Roman /font32 ANSIFont font375 739 677 (John R. Ellis and David L. Detlefs) 677 SB375 823 279 (June 10, 1993) 279 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 2161 1469 (John R. Ellis is a member of the research staff of the Xerox Palo Alto Research Center.) 1469 SB375 2388 181 (Copyright ) 181 SB32 0 0 42 42 0 0 0 42 /Symbol fontgs 589 3231 0 0 CB556 2384 33 (\343) 33 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font589 2388 1100 ( 1993 by Digital Equipment Corporation and Xerox Corporation.) 1100 SB375 2516 1553 (This work may not be copied or reproduced in whole or in part for any commercial purpose.) 1553 SB375 2566 1448 (Permission to copy in whole or in part without payment of fee is granted for nonprofit) 1448 SB375 2616 1548 (educational and research purposes provided that all such whole or partial copies include the) 1548 SB375 2666 1625 (following: a notice that such copying is by permission of the Systems Research Center of Digital) 1625 SB375 2716 1595 (Equipment Corporation and the Palo Alto Research Center of Xerox Corporation, both in Palo) 1595 SB375 2766 1629 (Alto, California; an acknowledgment of the authors and individual contributors to the work; and) 1629 SB375 2816 1567 (all applicable portions of the copyright notice. Copying, reproducing, or republishing for any) 1567 SB375 2866 1570 (other purpose shall require a license with payment of fee to the Systems Research Center and) 1570 SB375 2916 452 (Xerox. All rights reserved.) 452 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC525 428 185 (Abstract) 185 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font525 512 1292 (We propose adding safe, efficient garbage collection to C++, eliminating the) 1292 SB525 562 1273 (possibility of storage-management bugs and making the design of complex,) 1273 SB525 612 1326 (object-oriented systems much easier. This can be accomplished with almost no) 1326 SB525 662 1079 (change to the language itself and only small changes to existing) 1079 SB525 712 1278 (implementations, while retaining compatibility with existing class libraries.) 1278 SB585 762 1098 (Our proposal is the first to take a holistic, system-level approach,) 1098 SB525 812 587 (integrating four technologies. The ) 587 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1112 812 319 (language interface) 319 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1431 812 237 ( specifies how) 237 SB525 862 1266 (programmers access garbage collection through the language. An optional ) 1266 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1791 862 68 (safe) 68 SB525 912 105 (subset) 105 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font630 912 1151 ( of the language automatically enforces the safe-use rules of garbage) 1151 SB525 962 862 (collection and precludes storage bugs. A variety of ) 862 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1387 962 361 (collection algorithms) 361 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1748 962 63 ( are) 63 SB525 1012 1309 (compatible with the language interface, but some are easier to implement and) 1309 SB525 1062 1168 (more compatible with existing C++ and C implementations. Finally, ) 1168 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1693 1062 94 (code-) 94 SB525 1112 287 (generator safety ) 287 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font812 1112 958 (ensures that compilers generate correct code for use with) 958 SB525 1162 172 (collectors.) 172 SB1200 1262 581 (John R. Ellis and David L. Detlefs) 581 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 269 192 (Contents) 192 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 378 268 (1. Introduction) 268 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font649 378 352 (................................) 352 SB1001 378 352 (................................) 352 SB1353 378 352 (................................) 352 SB1705 378 143 (.............) 143 SB1854 378 21 (1) 21 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 428 251 (2. Constraints) 251 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font627 428 352 (................................) 352 SB979 428 352 (................................) 352 SB1331 428 352 (................................) 352 SB1683 428 165 (...............) 165 SB1854 428 21 (3) 21 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 478 300 (3. Previous work) 300 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font682 478 352 (................................) 352 SB1034 478 352 (................................) 352 SB1386 478 352 (................................) 352 SB1738 478 110 (..........) 110 SB1854 478 21 (6) 21 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 528 772 (4. Language interface to garbage collection) 772 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font1155 528 352 (................................) 352 SB1507 528 341 (...............................) 341 SB1854 528 21 (9) 21 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 578 669 (5. Object clean-up and weak pointers) 669 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font1045 578 352 (................................) 352 SB1397 578 352 (................................) 352 SB1749 578 77 (.......) 77 SB1833 578 42 (12) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 628 155 (6. Safety) 155 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font539 628 352 (................................) 352 SB891 628 352 (................................) 352 SB1243 628 352 (................................) 352 SB1595 628 231 (.....................) 231 SB1833 628 42 (18) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 678 241 (7. Safe subset) 241 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font616 678 352 (................................) 352 SB968 678 352 (................................) 352 SB1320 678 352 (................................) 352 SB1672 678 154 (..............) 154 SB1833 678 42 (22) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 728 573 (8. Suitable collection algorithms) 573 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font957 728 352 (................................) 352 SB1309 728 352 (................................) 352 SB1661 728 165 (...............) 165 SB1833 728 42 (37) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 778 167 (9. Unions) 167 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font550 778 352 (................................) 352 SB902 778 352 (................................) 352 SB1254 778 352 (................................) 352 SB1606 778 220 (....................) 220 SB1833 778 42 (40) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 828 363 (10. Interior pointers) 363 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font748 828 352 (................................) 352 SB1100 828 352 (................................) 352 SB1452 828 352 (................................) 352 SB1804 828 22 (..) 22 SB1833 828 42 (42) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 878 461 (11. Code-generator safety) 461 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font836 878 352 (................................) 352 SB1188 878 352 (................................) 352 SB1540 878 286 (..........................) 286 SB1833 878 42 (44) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 928 352 (12. Standardization) 352 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font737 928 352 (................................) 352 SB1089 928 352 (................................) 352 SB1441 928 352 (................................) 352 SB1793 928 33 (...) 33 SB1833 928 42 (48) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 978 727 (13. Summary of implementation changes) 727 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font1111 978 352 (................................) 352 SB1463 978 352 (................................) 352 SB1815 978 11 (.) 11 SB1833 978 42 (50) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1028 261 (14. Conclusion) 261 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font638 1028 352 (................................) 352 SB990 1028 352 (................................) 352 SB1342 1028 352 (................................) 352 SB1694 1028 132 (............) 132 SB1833 1028 42 (51) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1078 327 (Acknowledgments) 327 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font704 1078 352 (................................) 352 SB1056 1078 352 (................................) 352 SB1408 1078 352 (................................) 352 SB1760 1078 66 (......) 66 SB1833 1078 42 (51) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1128 197 (References) 197 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font572 1128 352 (................................) 352 SB924 1128 352 (................................) 352 SB1276 1128 352 (................................) 352 SB1628 1128 198 (..................) 198 SB1833 1128 42 (52) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1178 744 (Appendix A: Restricting interior pointers) 744 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font1122 1178 352 (................................) 352 SB1474 1178 352 (................................) 352 SB1833 1178 42 (55) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1228 871 (Appendix B: Why tagged unions aren't practical) 871 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font1254 1228 352 (................................) 352 SB1606 1228 220 (....................) 220 SB1833 1228 42 (57) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1278 383 (Appendix C: Array.h) 383 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font759 1278 352 (................................) 352 SB1111 1278 352 (................................) 352 SB1463 1278 352 (................................) 352 SB1815 1278 11 (.) 11 SB1833 1278 42 (58) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1328 354 (Appendix D: Text.h) 354 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font737 1328 352 (................................) 352 SB1089 1328 352 (................................) 352 SB1441 1328 352 (................................) 352 SB1793 1328 33 (...) 33 SB1833 1328 42 (67) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1378 411 (Appendix E: Variant.h) 411 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font792 1378 352 (................................) 352 SB1144 1378 352 (................................) 352 SB1496 1378 330 (..............................) 330 SB1833 1378 42 (68) 42 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1428 506 (Appendix F: WeakPointer.h) 506 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font891 1428 352 (................................) 352 SB1243 1428 352 (................................) 352 SB1595 1428 231 (.....................) 231 SB1833 1428 42 (71) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 419 25 (1) 25 SB400 419 298 (. Introduction) 298 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 503 1519 (We propose adding safe, efficient garbage collection to C++, eliminating the possibility of) 1519 SB375 553 1554 (storage-management bugs and making the design of complex, object-oriented systems much) 1554 SB375 603 1573 (easier. This can be accomplished with almost no change to the language itself and only small) 1573 SB375 653 1613 (changes to existing implementations, while retaining compatibility with existing class libraries.) 1613 SB435 703 1373 (C++ programmers spend large chunks of their time designing for explicit storage) 1373 SB375 753 1649 (management and tracking down storage bugs, and products are routinely shipped with many such) 1649 SB375 803 1640 (bugs. Dangling pointers, storage leaks, memory smashes, and out-of-bounds array indices are the) 1640 SB375 853 1600 (bane of the C++ programmer and his customers. Some of the most complicated aspects of C++) 1600 SB375 903 1631 (arise from using constructors and destructors to make up for the lack of garbage collection. Even) 1631 SB375 953 1518 (worse, the need for explicit deallocation of objects cramps the design of modular, reusable) 1518 SB375 1003 1009 (interfaces, especially in object-oriented languages like C++.) 1009 SB435 1053 1412 (Despite over a decade of experience using garbage collection for serious application) 1412 SB375 1103 1512 (programming in languages like Cedar, Clu, and Modula-2+, many C++ programmers are) 1512 SB375 1153 1628 (skeptical of garbage collection's practicality, and C++ vendors are already daunted by the task of) 1628 SB375 1203 1623 (efficiently implementing a complicated language that is still evolving. To be successful, garbage) 1623 SB375 1253 1642 (collection will have to be introduced slowly and incrementally, in a way that is highly compatible) 1642 SB375 1303 1543 (with existing language implementations and class libraries. Programmers, vendors, and the) 1543 SB375 1353 1646 (ANSI C++ standards committee will resist any design that requires significant language changes,) 1646 SB375 1403 1589 (non-trivial modification of existing class libraries, or global changes to C++ implementations.) 1589 SB435 1453 1470 (Previous attempts at C++ garbage collection have been variously flawed, and they have) 1470 SB375 1503 1547 (tended to focus on narrow aspects of the problem. Some have proposed unrealistic language) 1547 SB375 1553 1604 (extensions, while others have avoided any modifications of the language or compilers. They all) 1604 SB375 1603 1576 (restrict compatibility with existing class libraries and completely ignore safety, assuming that) 1576 SB375 1653 1649 (\223safe C++\224 is an oxymoron. But safety is an essential ingredient for eliminating bugs and making) 1649 SB375 1703 1048 (garbage collection more usable by the practicing programmer.) 1048 SB435 1753 1483 (Our proposal is the first to take a holistic, system-level approach and the first to provide) 1483 SB375 1803 798 (complete safety. It integrates four technologies:) 798 SB525 1878 30 (a ) 30 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font555 1878 319 (language interface) 319 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font874 1878 1144 ( specifying how programmers access garbage collection through the) 1144 SB525 1928 165 (language;) 165 SB525 2003 201 (an optional ) 201 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font726 2003 184 (safe subset) 184 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font910 2003 1076 ( of the language that precludes storage bugs and ensures correct) 1076 SB525 2053 330 (use of the collector;) 330 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 2128 361 (collection algorithms) 361 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font886 2128 972 ( already shown to be compatible with existing C++ and C) 972 SB525 2178 367 (implementations; and) 367 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 2253 370 (code-generator safety) 370 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font895 2253 1113 ( that ensures compilers generate correct code for use with garbage) 1113 SB525 2303 172 (collectors.) 172 SB375 2378 1335 (We recognize the reality of the C++ world. The use of garbage collection is not) 1335 SB375 2428 1567 (required\227programmers decide which classes should be garbage collected. The one language) 1567 SB375 2478 515 (change is a new type specifier ) 515 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font890 2483 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font940 2478 1055 ( that enables compatibility with existing libraries; the specifier) 1055 SB375 2530 1606 (is easily implemented and has no effect on the type-checking rules. A program can use garbage) 1606 SB375 2580 1624 (collection without being written in the safe subset\227the programmer decides which parts, if any,) 1624 SB375 2630 1557 (of the program should get the automatic protection from bugs. The safe subset consists of 10) 1557 SB375 2680 1527 (compile-time restrictions and 6 run-time checks; these are easily implemented as localized) 1527 SB375 2730 1518 (changes to the front ends of current compilers, and the run-time checks can be disabled in) 1518 SB375 2780 1533 (production code. The collection algorithms are almost completely compatible with existing) 1533 SB375 2830 1586 (implementations, requiring just a small change to code generators to ensure correct operation.) 1586 SB1219 3069 21 (1) 21 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 1494 (This proposal is deliberately a paper design\227it is not yet implemented. There have been) 1494 SB375 319 1611 (decades of experience with garbage collection, including systems programming and application) 1611 SB375 369 1635 (programming languages, and many researchers have built prototype collectors for C++. No more) 1635 SB375 419 1546 (\223research\224 is required\227it is now time to consolidate and build consensus on as many of the) 1546 SB375 469 1605 (actual details as possible. A prototype implementation will be necessary to test and polish these) 1605 SB375 519 1504 (details and present a proposal to the ANSI standards committee, but it won't reveal much) 1504 SB375 569 1191 (significant new insight in how to use or implement garbage collection.) 1191 SB375 694 1557 (A note about language definitions: The ANSI standards committee has not yet finished their) 1557 SB375 744 1509 (standard definition of C++, so we've based our proposal on the current de facto standard, ) 1509 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1884 744 63 (The) 63 SB375 794 592 (Annotated C++ Reference Manual) 592 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font967 794 527 ( [Ellis 91], hereafter called the ) 527 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1494 794 87 (ARM) 87 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1581 794 311 (. Judging from the) 311 SB375 844 1494 (partially completed draft standard and the issues the committee has still to resolve, we're) 1494 SB375 894 1365 (confident that our proposal will be compatible with the final language definition.) 1365 SB1219 3069 21 (2) 21 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 25 (2) 25 SB400 319 275 (. Constraints) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 1611 (To be useful for commercial programming, C++ garbage collection should satisfy the following) 1611 SB375 453 196 (constraints:) 196 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 528 306 (Minimal changes:) 306 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font831 528 1189 ( Too many or too severe changes to the language, its implementations,) 1189 SB525 578 1349 (or programming styles will impede acceptance of garbage collection by the C++) 1349 SB525 628 201 (community.) 201 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 703 219 (Coexistence:) 219 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font744 703 1099 ( Program components using garbage collection must coexist with) 1099 SB525 753 416 (components not using it.) 416 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 828 118 (Safety:) 118 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font643 828 1345 ( The rules for correct use of garbage collection should be explicitly defined, and) 1345 SB525 878 1435 (the language and its implementation should provide optional automatic enforcement.) 1435 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 953 197 (Portability:) 197 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font722 953 1075 ( A program using garbage collection should run correctly on all) 1075 SB525 1003 424 (implementations of C++.) 424 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 1078 185 (Efficiency:) 185 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font710 1078 1284 ( The more efficient garbage collection is, the more likely it will be accepted.) 1284 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1178 53 (2.1) 53 SB428 1178 329 (. Minimal changes) 329 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1253 1645 (It will be years before garbage collection is widely accepted by the C++ community, and the more) 1645 SB375 1303 1584 (changes made to the language or required of its implementations, the longer it will take to get) 1584 SB375 1353 1524 (those changes accepted and the less likely C++ garbage collection will succeed. The ANSI) 1524 SB375 1403 1619 (standards committee is swamped by hundreds of proposals to \223improve\224 C++, and the simpler a) 1619 SB375 1453 1548 (proposed change, the more likely it might be accepted by the committee, by vendors, and by) 1548 SB375 1503 418 (practicing programmers.) 418 SB435 1553 1555 (C++ vendors are more likely to accept garbage collection if their implementations require at) 1555 SB375 1603 1640 (most small changes. They'll resist changes requiring significant changes to the compiler or to the) 1640 SB375 1653 636 (representations of objects and classes.) 636 SB435 1703 1562 (Programmers are more likely to accept garbage collection if they have to make at most small) 1562 SB375 1753 1644 (changes to their programming methodology and style. Programmers tend to be quite conservative) 1644 SB375 1803 1070 (and resist change unless they can see immediate, clear benefits.) 1070 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1903 53 (2.2) 53 SB428 1903 233 (. Coexistence) 233 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1978 1574 (Any practical design for C++ garbage collection must allow libraries written without garbage) 1574 SB375 2028 1637 (collection or written in other languages such as C or Fortran. A team of programmers wanting to) 1637 SB375 2078 1624 (use garbage collection will likely be using libraries written by other teams or companies, and it's) 1624 SB375 2128 1504 (unrealistic to expect that all those libraries would be written using both C++ and garbage) 1504 SB375 2178 1316 (collection or that the programmers would have access to the libraries' sources.) 1316 SB435 2228 1550 (Making all objects garbage-collected, including objects allocated by existing libraries, is not) 1550 SB375 2278 1589 (feasible. First, those libraries may not follow the safe-use rules of the collector, and there is no) 1589 SB375 2328 1561 (way to verify safety without access to sources. Even with access, client programmers can't be) 1561 SB375 2378 1619 (expected to verify the safety of large libraries. Second, the libraries may not have been compiled) 1619 SB375 2428 1518 (by collector-safe code generators, and the chances for problems would lessen if they didn't) 1518 SB375 2478 633 (allocate collected objects \(see section ) 633 SB1008 2478 74 (11.2) 74 SB1082 2478 906 (\). Finally, making all objects garbage-collected would) 906 SB375 2528 1457 (change the semantics of destructors, since the collector destroys unreachable objects at) 1457 SB375 2578 1581 (unpredictable times. Existing libraries using destructors would break in subtle ways, and C++) 1581 SB375 2628 1247 (programmers and vendors would likely view such a change as too radical.) 1247 SB435 2678 1573 (Experience with systems-programming languages with integrated garbage collection, such as) 1573 SB375 2728 1642 (Cedar and Modula-2+, shows that, compatibility issues aside, it is often useful to have two heaps,) 1642 SB375 2778 1574 (one for collected objects and one for non-collected objects. The non-collected heap is used for) 1574 SB375 2828 1571 (code with ultra-critical performance requirements or, with copying collectors, for objects that) 1571 SB375 2878 739 (can't be relocated for one reason or another.) 739 SB1219 3069 21 (3) 21 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 1584 (Thus, a practical design should provide two logical heaps, a collected heap and the traditional) 1584 SB375 319 1580 (C++ non-collected heap. It should be possible to pass collected objects to unmodified libraries) 1580 SB375 369 1472 (written without collection or in another language, and a single library should be able to) 1472 SB375 419 1587 (manipulate both collected and non-collected objects. In particular, objects in the non-collected) 1587 SB375 469 1618 (heap should be able to point at objects in the collected heap, and vice versa. That is, a pointer of) 1618 SB375 519 81 (type ) 81 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font456 524 50 (T*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font506 519 759 ( should be able to reference an object of type ) 759 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1265 524 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1290 519 417 ( allocated in either heap.) 417 SB435 571 1504 (For example, suppose a programmer wishes to write a new X Windows application using) 1504 SB375 621 1614 (garbage collection. He'd like to use an X user-interface library written in C by another company) 1614 SB375 671 1605 (that doesn't use garbage collection. The library requires \223client data\224 to be passed and stored in) 1605 SB375 721 1629 (the library's objects. The library itself doesn't interpret the client data, but it holds on to it for the) 1629 SB375 771 1639 (client and passes it back as arguments to call-back functions. The programmer would like to pass) 1639 SB375 821 1595 (collected objects as client data to the unmodified library, without fear that the objects would be) 1595 SB375 871 310 (prematurely freed.) 310 SB435 921 1572 (These constraints preclude extensions to the type system identifying which pointers reference) 1572 SB375 971 1549 (collected objects. Such extensions would require existing libraries to be modified and would) 1549 SB375 1021 1482 (effectively prevent libraries from manipulating both collected and non-collected objects.) 1482 SB435 1071 1583 (Note that implementations may represent the collected and non-collected heaps using a single) 1583 SB375 1121 1375 (internal heap, with only collected objects being considered for garbage collection.) 1375 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1221 53 (2.3) 53 SB428 1221 134 (. Safety) 134 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1296 1628 (Every garbage collector has a set of safe-use rules that must be followed for its correct operation.) 1628 SB375 1346 1610 (For example, a program shouldn't disguise a pointer by xor-ing it with another pointer, because) 1610 SB375 1396 1047 (the collector wouldn't be able to identify the pointer's referent.) 1047 SB435 1446 1579 (In standard C++, violating the language's safe-use rules can create hard-to-debug messes. For) 1579 SB375 1496 1618 (example, prematurely freeing an object can cause obscure bugs. Garbage collectors dramatically) 1618 SB375 1546 1594 (reduce the occurrence of such bugs. But if programmers accidentally violate the safe-use rules,) 1594 SB375 1596 1614 (the resulting mess can be even harder to debug than without garbage collection, since collectors) 1614 SB375 1646 852 (can scramble the heap when the rules are violated.) 852 SB435 1696 1590 (Ideally, the safe-use rules should be enforced automatically by the language, the compiler, and) 1590 SB375 1746 1582 (the run-time implementation, with as many rules statically checked as possible. If some of the) 1582 SB375 1796 1570 (rules require run-time checks \(such as array-subscript checks\), those checks should be cheap.) 1570 SB375 1846 1636 (However, because storage bugs are so costly to detect and fix, many programmers will gladly pay) 1636 SB375 1896 1401 (some amount of run-time overhead for early detection of bugs during development.) 1401 SB435 1947 1077 (However, the automatic static and run-time checking should be ) 1077 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font1512 1946 145 (optional) 145 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1657 1947 318 (, easily disabled by) 318 SB375 1997 1543 (the programmer at any point during development. Projects with rigorous design and testing) 1543 SB375 2047 1562 (methodologies may reasonably decide to trade a marginal bit of safety in production code for) 1562 SB375 2097 1609 (increased performance. Also, many old-time C and C++ programmers resist any restrictions on) 1609 SB375 2147 1647 (their \223freedom\224 without considering whether such restrictions will improve the final product, and) 1647 SB375 2197 1583 (we'd like to encourage such programmers at least to use garbage collection, even if they're not) 1583 SB375 2247 688 (willing to use automatic safety checking.) 688 SB435 2297 1579 (The compiler must cooperate in following the safe-use rules. In particular, it must ensure that) 1579 SB375 2347 1548 (every object reachable from source-level pointers indeed has at least one object-code pointer) 1548 SB375 2397 1646 (referencing it, if only in a register or stack temporary. Unfortunately, traditional optimization can) 1646 SB375 2447 1544 (generate code in which there is no pointer pointing at or into a reachable object, fooling the) 1544 SB375 2497 903 (garbage collector into prematurely freeing it. Section ) 903 SB1278 2497 42 (11) 42 SB1320 2497 690 ( discusses code-generator safety and how) 690 SB375 2547 994 (compilers must be modified slightly for garbage collection.) 994 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2647 53 (2.4) 53 SB428 2647 215 (. Portability) 215 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2722 1648 (The definition of C++ garbage collection should allow programmers to write programs easily that) 1648 SB375 2772 1605 (yield the same results on any correct C++ implementation. That is, the garbage-collection safe-) 1605 SB375 2822 886 (use rules should be independent of implementations.) 886 SB1219 3069 21 (4) 21 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 1575 (Portability conflicts with efficiency and minimal changes. For example, C++ allows a pointer) 1575 SB375 319 1512 (to be cast to a sufficiently large integer and back again, yielding the same pointer. Totally) 1512 SB375 369 1528 (conservative garbage collectors can handle such casting, since they interpret every word in) 1528 SB375 419 1571 (memory as a potential pointer. But if we want to allow implementations the freedom of using) 1571 SB375 469 1611 (potentially more efficient algorithms \(such as partially conservative or copying collectors\), then) 1611 SB375 519 1645 (the safe-use rules must encompass those algorithms by restricting the use of certain C++ features.) 1645 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 619 53 (2.5) 53 SB428 619 203 (. Efficiency) 203 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 694 1617 (Inefficient implementations of garbage collection will impede its acceptance as surely as any set) 1617 SB375 744 1615 (of radical language changes. To be successful, garbage collection needn't be quite as efficient as) 1615 SB375 794 1605 (programmer-written deallocation, since many programmers would gladly sacrifice a little extra) 1605 SB375 844 1605 (run time or memory to eliminate storage bugs quickly and reliably. Though programmers often) 1605 SB375 894 1614 (delude themselves into thinking that they can easily eliminate storage bugs, consider how many) 1614 SB375 944 1567 (programs are shipped with storage bugs and how many months, sometimes years, it takes for) 1567 SB375 994 389 (those bugs to get fixed.) 389 SB435 1044 1425 (Recent measurements by Zorn indicate that garbage collectors can often be as fast as) 1425 SB375 1094 1601 (programmer-written deallocation, sometimes even faster [Zorn 92]. Just as many programmers) 1601 SB375 1144 1601 (think they can eliminate all storage bugs, they also think they can fine-tune the performance of) 1601 SB375 1194 1619 (their memory allocators. But in fact, any project has a finite amount of programming effort, and) 1619 SB375 1244 1552 (many, if not most, programs are shipped with imperfectly tuned memory management. This) 1552 SB375 1294 930 (makes garbage collection more competitive in practice.) 930 SB435 1344 1472 (Efficiency conflicts with minimizing language changes and enabling coexistence. Most) 1472 SB375 1394 1628 (previous approaches to garbage collection have relied on non-trivial language support to achieve) 1628 SB375 1444 1601 (acceptable performance. In languages such as Cedar, Modula-2+, and Modula-3, programmers) 1601 SB375 1494 1602 (must declare which pointers point at collected objects\227a collected pointer can't point at a non-) 1602 SB375 1544 1631 (collected object, and vice versa. Garbage collectors have relied on such support to scan the heaps) 1631 SB375 1594 1583 (more efficiently, to implement generational collection, or to implement reference counting. In) 1583 SB375 1644 1551 (general, any language design requiring declaration of pointers to collected objects will often) 1551 SB375 1694 1618 (require source modification of existing libraries, which as discussed above makes coexistence of) 1618 SB375 1744 742 (collected and non-collected libraries harder.) 742 SB435 1794 1505 (Fortunately, recent advances in garbage collection for hostile environments let us strike a) 1505 SB375 1844 735 (practical balance among our goals. Section ) 735 SB1110 1844 21 (8) 21 SB1131 1844 887 ( discusses technology for implementing generational) 887 SB375 1894 1587 (collection and efficient scanning of the heaps without requiring enhanced pointer declarations) 1587 SB375 1944 466 (and sacrificing coexistence.) 466 SB1219 3069 21 (5) 21 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 25 (3) 25 SB400 319 210 (. Previous) 210 SB32 0 0 58 58 0 0 0 54 /Times-Bold /font29 ANSIFont font610 311 15 ( ) 15 SB32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font625 319 109 (work) 109 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 1465 (No previous proposal or implemented technology meets the constraints outlined above.) 1465 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 503 53 (3.1) 53 SB428 503 317 (. Other languages) 317 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 578 1601 (Languages like Lisp and Smalltalk have provided safe garbage collection for over two decades.) 1601 SB375 628 1436 (Lisp especially has demonstrated how much safe collection can improve programmer) 1436 SB375 678 1463 (productivity. But other characteristics of those languages have discouraged widespread) 1463 SB375 728 275 (commercial use.) 275 SB435 778 1546 (In the last decade, collection has been successfully integrated into more traditional systems-) 1546 SB375 828 1636 (programming languages like Cedar [Rovner 85a], Modula-2+ [Rovner 85b, DeTreville 90b], and) 1636 SB375 878 1620 (more recently, Modula-3 [Nelson 91]. Unlike C++, these languages were designed with garbage) 1620 SB375 928 1631 (collection in mind, and they refined the notions of garbage-collection safety and providing a safe) 1631 SB375 978 1606 (subset within a larger, unsafe language. But many practicing programmers think the languages) 1606 SB375 1028 1535 (are too restrictive, and their implementations prohibit or restrict interoperability with other) 1535 SB375 1078 1405 (languages. The C++ subset presented here is noticeably less restrictive \(see section ) 1405 SB1780 1078 21 (7) 21 SB1801 1078 25 (\).) 25 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1178 53 (3.2) 53 SB428 1178 509 (. Mark-and-sweep collectors) 509 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1253 1612 (Boehm et al. have implemented a family of conservative mark-and-sweep collectors suitable for) 1612 SB375 1303 971 (use with C++ and C [Boehm 91]. The collectors redefine ) 971 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1346 1308 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1421 1303 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1505 1308 150 (malloc) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1655 1303 249 ( at link time to) 249 SB375 1355 1533 (allocate from the collected heap. The collectors require no changes to the language and are) 1533 SB375 1405 1597 (mostly compatible with current programming styles. The collectors are highly compatible with) 1597 SB375 1455 1577 (existing implementations, but they require compiler implementation of code-generator safety,) 1577 SB375 1505 1633 (which no compilers currently provide\227programmers are on their own to guard against incorrect) 1633 SB375 1555 1581 (optimizations, often by disabling optimization entirely. Coexistence is compromised, since all) 1581 SB375 1605 1645 (C++ objects are allocated in the collected heap. Safety is not checked\227programmers must ensure) 1645 SB375 1655 1531 (their programs follow the collector's safe-use rules. Though they are fully conservative, the) 1531 SB375 1705 1550 (collectors are surprisingly efficient and quite competitive with explicit, programmer-written) 1550 SB375 1755 1529 (deallocation [Zorn 92]. However, there are as yet no comprehensive measurements of their) 1529 SB375 1805 1641 (behavior in long-running programs with large heaps, and unsubstantiated folk wisdom maintains) 1641 SB375 1855 958 (that in practice copying collectors may be more efficient.) 958 SB435 1905 1547 (Codewright Toolworks has recently started selling a conservative mark-and-sweep collector) 1547 SB375 1955 689 (suitable for C and C++ [Codewright 93].) 689 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2055 53 (3.3) 53 SB428 2055 353 (. Copying collectors) 353 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2130 1641 (Bartlett et al. have implemented partially conservative copying collectors for C and C++ [Bartlett) 1641 SB375 2180 1598 (89, Detlefs 90, Yip 91]. The collectors require no language changes and are mostly compatible) 1598 SB375 2230 1624 (with current programming styles, but programmers must write scanning methods for every class) 1624 SB375 2280 1606 (identifying the location of pointers within instances of the class. As with the Boehm mark-and-) 1606 SB375 2330 1536 (sweep collectors, programmers must guard against compiler optimizations violating safety.) 1536 SB375 2380 1587 (Though the Bartlett collectors provide both collected and uncollected heaps, it isn't possible to) 1587 SB375 2430 1551 (pass collected objects to uncollected libraries directly or store pointers to collected objects in) 1551 SB375 2480 1541 (uncollected objects\227programmers must write interface stubs that store argument objects in) 1541 SB375 2530 1533 (\223escape lists\224 before passing them on to the libraries. But programmers can make mistakes) 1533 SB375 2580 1550 (writing these stubs, causing dangling references and storage leaks; often it's very difficult to) 1550 SB375 2630 1527 (know when an object can be removed from an escape list. There is no safety checking, and) 1527 SB375 2680 1642 (Bartlett collectors require more rules to be followed than Boehm collectors. Programmers mustn't) 1642 SB375 2730 1618 (depend on objects having fixed addresses, and they must write correct scanning methods. While) 1618 SB375 2780 1621 (writing scanning methods for classes is easy, it's not hard to make a mistake in very large, long-) 1621 SB375 2830 1565 (lived, evolving systems maintained by dozens of programmers, and the resulting bugs can be) 1565 SB375 2880 1650 (tedious to track down. Finally, though the Bartlett collectors haven't been measured as thoroughly) 1650 SB1219 3069 21 (6) 21 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 1612 (as the Boehm collectors, the measurements that have been made are promising [Detlefs 90, Yip) 1612 SB375 319 67 (91].) 67 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 419 53 (3.4) 53 SB428 419 290 (. Smart pointers) 290 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 494 1409 (A number of researchers have investigated so-called \223smart pointers\224 as a means of) 1409 SB375 544 1557 (implementing garbage collection purely at the source-language level, without changes to the) 1557 SB375 594 1580 (language or implementations [Edelson 91, Edelson 92, Detlefs 92, Ginter 91]. Using operator) 1580 SB375 644 1599 (overloading and template classes or preprocessors, the collectors get notified whenever a smart) 1599 SB375 694 1436 (pointer is created, destroyed, or assigned. But smart pointers don't entirely mimic the) 1436 SB375 744 788 (functionality of standard pointers. Given class ) 788 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1163 749 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1188 744 239 ( derived from ) 239 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1427 749 25 (S) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1452 744 332 (, a smart pointer to ) 332 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1784 749 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1809 744 139 ( can't be) 139 SB375 796 509 (assigned to a smart pointer to ) 509 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font884 801 25 (S) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font909 796 979 (. Such widening casts are an essential feature of C++, and) 979 SB375 848 1541 (prohibiting them wouldn't be practical. Using a preprocessor to work around this limitation) 1541 SB375 898 1616 (effectively changes both the language and its compilers. Since pointers to collected objects must) 1616 SB375 948 1593 (be explicitly declared as smart pointers, coexistence with existing libraries is precluded. Smart) 1593 SB375 998 1550 (pointers provide no automatic safety checking, and they can't prevent unsafe code-generator) 1550 SB375 1048 1649 (optimizations without doubling the size of pointers, adding run-time overhead, and relying on the) 1649 SB375 1098 685 (implementation-dependent semantics of ) 685 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1060 1103 200 (volatile) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1260 1098 762 ( [Detlefs 92]. Ginter proposes some language) 762 SB375 1150 1591 (changes that would make smart pointers feasible, but that defeats the original goal of avoiding) 1591 SB375 1200 1339 (language changes [Ginter 91]. In sum, smart pointers are actually rather dumb.) 1339 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1300 53 (3.5) 53 SB428 1300 384 (. Pointer declarations) 384 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1375 1636 (Samples has recently proposed adding two new type qualifiers to C++ that declare in which heap) 1636 SB375 1425 1616 (an object should be allocated and that identify which pointers may point at collected objects and) 1616 SB375 1475 1540 (which may point into the middle of objects [Samples 92]. The proposal involves non-trivial) 1540 SB375 1525 1587 (changes to the language's type-checking rules. Though the proposal would be compatible with) 1587 SB375 1575 1592 (conservative and partially conservative collectors, realizing the efficiency gains enabled by the) 1592 SB375 1625 1570 (declarations would require changing the object representations used by current compilers. As) 1570 SB375 1675 344 (discussed in section ) 344 SB719 1675 53 (2.2) 53 SB772 1675 1241 (, requiring declaration of pointers to collected objects inhibits coexistence) 1241 SB375 1725 1578 (with existing libraries, since the libraries would need source changes to coexist with collected) 1578 SB375 1775 1566 (objects. Though the static type checking rules help enforce safety, there is no complete safety) 1566 SB375 1825 1002 (checking\227Samples believed that wasn't feasible with C++.) 1002 SB435 1875 1577 (Samples's proposal is designed to allow a wide range of collection algorithms, including non-) 1577 SB375 1925 1596 (conservative algorithms. With sufficient compiler support and changes to the representation of) 1596 SB375 1975 1560 (objects, the declarations can help the collector identify which pointers may point at collected) 1560 SB375 2025 1563 (objects and of those, which may address the interiors of objects. This support may reduce the) 1563 SB375 2075 1154 (collector's cost of following pointers during a collection \(see section ) 1154 SB1529 2075 42 (10) 42 SB1571 2075 25 (\).) 25 SB435 2125 1388 (As yet there are no detailed measurements indicating how much efficiency pointer) 1388 SB375 2175 1630 (declarations would buy, though Zorn's measurements of the totally conservative Boehm collector) 1630 SB375 2225 1458 (suggest that even without declarations, collectors can compete with traditional explicit) 1458 SB375 2275 1605 (deallocation [Zorn 92]. Presumably, a version of the Boehm collector using precise scanning of) 1605 SB375 2325 1636 (heap objects \(via type maps\) would be even more efficient. Thus, pointer declarations most likely) 1636 SB375 2375 946 (aren't required to provide acceptably efficient collectors.) 946 SB435 2425 1532 (In summary, Samples's proposal may allow for somewhat more efficient garbage collectors) 1532 SB375 2475 1546 (but at the cost of non-trivial language and compiler changes, and of sacrificing coexistence.) 1546 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2575 53 (3.6) 53 SB428 2575 348 (. Development tools) 348 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2650 1521 (Tools such as CenterLine [CenterLine 92] and Purify [Pure 92] detect storage bugs during) 1521 SB375 2700 1537 (development. CenterLine provides an interpreter that can catch almost all such bugs, while) 1537 SB375 2750 1629 (Purify uses link-time code modification to catch most heap-storage bugs \(but not stack- or static-) 1629 SB375 2800 1518 (storage bugs\). Since the tools slow down programs considerably when providing full error) 1518 SB375 2850 1638 (detection \(CenterLine by a factor of 50, Purify by a factor of two to four\) and use noticeably more) 1638 SB375 2900 1593 (heap memory, they are most appropriate for testing programs where execution speed is not too) 1593 SB1219 3069 21 (7) 21 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 1600 (important. The tools are too slow for many kinds of CPU-intensive testing or use in production) 1600 SB375 319 143 (releases.) 143 SB435 369 1560 (While such tools are very useful, programmers must still spend considerable time designing,) 1560 SB375 419 1551 (implementing, and debugging explicit memory deallocation. Safe garbage collection greatly) 1551 SB375 469 1619 (reduces that design and debugging time, and it can be used throughout development and release) 1619 SB375 519 1572 (with little or no sacrifice in performance. More importantly, garbage collection simplifies the) 1572 SB375 569 1000 (interfaces of complicated systems and enhances reusability.) 1000 SB1219 3069 21 (8) 21 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 25 (4) 25 SB400 319 890 (. Language interface to garbage collection) 890 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 1591 (The language interface specifies how programmers access garbage collection through the C++) 1591 SB375 453 1644 (language. The complete specification of the language interface appears first, followed by a design) 1644 SB375 503 185 (discussion.) 185 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 603 53 (4.1) 53 SB428 603 253 (. Specification) 253 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 678 1581 (Objects may be allocated in one of two logical heaps, the collected heap and the non-collected) 1581 SB375 728 102 (heap. ) 102 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font477 728 294 (Collected objects) 294 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font771 728 1177 (, objects allocated in the collected heap, will be automatically garbage) 1177 SB375 778 1037 (collected when they are no longer accessible by the program; ) 1037 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1412 778 362 (non-collected objects) 362 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1774 778 137 (, objects) 137 SB375 828 1224 (allocated in the non-collected heap, must be explicitly deallocated using ) 1224 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1599 833 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1749 828 263 (. Objects in one) 263 SB375 880 922 (heap may contain pointers to objects in the other heap.) 922 SB435 930 528 (A new kind of type specifier, a ) 528 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font963 930 239 (heap specifier) 239 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1202 930 103 (, tells ) 103 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1305 935 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1380 930 637 ( in which heap it should allocate. The) 637 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 987 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font425 982 684 ( specifier selects the collected heap, and ) 684 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1109 987 100 (nogc) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 982 811 ( \(the default\) selects the non-collected heap. For) 811 SB375 1034 154 (example:) 154 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1107 425 (gc class A {...};) 425 SB525 1152 550 (typedef gc char B[10];) 550 SB525 1197 475 (nogc class C {...};) 475 SB525 1242 425 (typedef int D[5];) 425 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1314 283 (The expressions ) 283 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font658 1319 125 (new A) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font783 1314 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font867 1319 125 (new B) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font992 1314 864 ( allocate in the collected heap, and the expressions ) 864 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1856 1319 125 (new C) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1366 73 (and ) 73 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font448 1371 125 (new D) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font573 1366 589 ( allocate in the non-collected heap.) 589 SB435 1418 1536 (Like a storage-class specifier, a heap specifier applies to the object or name being declared.) 1536 SB375 1468 495 (For example, the declaration ) 495 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font870 1473 325 (gc char a[10]) 325 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1195 1468 159 ( declares ) 159 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1354 1473 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1379 1468 571 ( to be a garbage-collected array of) 571 SB375 1520 943 (characters, not an array of garbage-collected characters.) 943 SB435 1570 174 (The types ) 174 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font609 1575 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font634 1570 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font718 1575 100 (gc T) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font818 1570 840 ( are two different types, but an expression of type ) 840 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1658 1575 100 (gc T) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1758 1570 206 ( can be used) 206 SB375 1622 533 (wherever an expression of type ) 533 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font908 1627 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font933 1622 1064 ( is allowed, and vice versa; thus, an expression of type \223pointer) 1064 SB375 1674 43 (to ) 43 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font418 1679 100 (gc T) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font518 1674 961 (\224 can be used wherever an expression of type \223pointer to ) 961 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1479 1679 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1504 1674 520 (\224 is allowed, and vice versa. In) 520 SB375 1726 472 (particular, a pointer of type ) 472 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font847 1731 50 (T*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font897 1726 520 ( may point at an object of type ) 520 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1417 1731 100 (gc T) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1517 1726 382 (, and an object of type ) 382 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1899 1731 100 (gc T) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1778 850 (can be declared static or automatic \(in which case ) 850 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1225 1783 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1275 1778 204 ( is ignored\).) 204 SB435 1830 1387 (The heap specifier is included in the type-safe linkage of a name, ensuring that all) 1387 SB375 1880 697 (occurrences of it have the same meaning.) 697 SB435 1930 1165 (A declaration of a non-class type without a heap specifier defaults to ) 1165 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1600 1935 100 (nogc) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1700 1930 220 (. Similarly, a) 220 SB375 1982 1271 (declaration of a class with no base classes and no heap specifier defaults to ) 1271 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1646 1987 100 (nogc) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1746 1982 112 (. But a) 112 SB375 2034 1638 (declaration of a derived class with no heap specifier inherits the heap specifier of its base classes,) 1638 SB375 2084 1623 (and it is an error if the heap specifications of the base classes conflict. An explicit heap specifier) 1623 SB375 2134 1403 (always overrides the specifiers of the base classes \(even if they conflict\). Examples:) 1403 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2207 350 (gc class A {};) 350 SB525 2252 275 (class B {};) 275 SB525 2304 625 (gc class C: B {};     /* ) 625 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1150 2299 41 (ok) 41 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1191 2304 75 ( */) 75 SB525 2356 625 (class D: A, B {};     /* ) 625 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1150 2351 83 (error) 83 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1233 2356 75 ( */) 75 SB525 2408 625 (gc class E: A, B {};  /* ) 625 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1150 2403 41 (ok) 41 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1191 2408 75 ( */) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2480 41 (A ) 41 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font416 2485 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font466 2480 406 ( class may not overload ) 406 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font872 2485 300 (operator new) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1172 2480 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1229 2485 375 (operator delete) 375 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1604 2480 227 (; an inherited) 227 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2537 300 (operator new) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font675 2532 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font732 2537 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font882 2532 190 ( is ignored.) 190 SB435 2584 283 (The expressions ) 283 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font718 2589 125 (new T) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font843 2584 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font927 2589 200 (new T[e]) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1127 2584 545 ( allocate in the heap selected by ) 545 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1672 2589 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1697 2584 280 ('s heap specifier.) 280 SB435 2636 637 (Regardless of which heap is selected, ) 637 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1072 2641 125 (new T) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1197 2636 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1281 2641 200 (new T[e]) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1481 2636 135 ( invoke ) 135 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1616 2641 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1641 2636 348 ('s constructors in the) 348 SB375 2688 234 (standard way.) 234 SB435 2738 1565 (When the garbage collector discovers that a collected object is inaccessible to the program, it) 1565 SB375 2788 1641 (will invoke the object's destructor before recycling its storage. This allows programmers to define) 1641 SB375 2838 1512 (clean-up actions that release the resources of unused objects. The destructor will be called) 1512 SB1219 3069 21 (9) 21 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 1272 (asynchronously with respect to execution of the main program. See section ) 1272 SB1647 269 21 (5) 21 SB1668 269 250 ( and appendix ) 250 SB1918 269 23 (F) 23 SB1941 269 59 ( for) 59 SB375 319 953 (the precise semantics of clean-up and a design rationale.) 953 SB435 369 38 (If ) 38 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font473 374 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font498 369 715 ( points to a collected object, the statement ) 715 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1213 374 200 (delete e) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1413 369 516 ( invokes the object's destructor) 516 SB375 421 1649 (immediately, returning after it finishes, and the collector won't invoke the destructor later when it) 1649 SB375 471 1589 (collects the object. Deleting a collected object is a hint to the implementation that it may reuse) 1589 SB375 521 1620 (the object's storage, but implementations can ignore the hint. As with non-collected objects, it is) 1620 SB375 571 1646 (illegal to reference a deleted collected object, though implementations aren't required to check for) 1646 SB375 621 76 (that.) 76 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 721 53 (4.2) 53 SB428 721 194 (. Rationale) 194 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 796 1639 (The design of the language interface provides coexistence of collected and non-collected libraries) 1639 SB375 846 1274 (using the smallest possible change to the language. As discussed in section ) 1274 SB1649 846 53 (2.2) 53 SB1702 846 301 (, coexistence with) 301 SB375 896 1623 (existing libraries requires two logical heaps and some way for the programmer to select between) 1623 SB375 946 1541 (them, and adding heap specifiers to the language is about the simplest way to do that. Heap) 1541 SB375 996 1603 (specifiers don't affect the language's type-checking rules, so collected and non-collected objects) 1603 SB375 1046 1607 (can be freely intermixed, and collected objects can be passed to existing non-collected libraries.) 1607 SB435 1096 1149 (Some critics have suggested using the placement syntax of operator ) 1149 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1584 1101 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1659 1096 320 ( to control whether) 320 SB375 1148 1556 (objects are collected or not. This would require no language changes, but it would push onto) 1556 SB375 1198 1543 (clients the responsibility for deciding where objects should get allocated by default. Given a) 1543 SB375 1248 275 (collectible class ) 275 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font650 1253 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font675 1248 131 (, either:) 131 SB525 1325 165 (clients of ) 165 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font690 1330 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font715 1325 644 ( must always remember to specify the ) 644 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1359 1330 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1409 1325 476 ( placement when they write ) 476 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1885 1330 125 (new T) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font2010 1325 12 (;) 12 SB525 1377 35 (or) 35 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1457 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 1452 1462 ( must provide static member functions for creating new single instances and new array) 1462 SB525 1504 166 (instances.) 166 SB375 1579 1601 (With the first option, clients can easily forget to specify placement, and it is also more verbose,) 1601 SB375 1629 223 (for example, ) 223 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font598 1634 250 (new \(gc\) T) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font848 1629 11 (.) 11 SB435 1681 1507 (The second option is counter to the design of C++, in which clients are expected to write ) 1507 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1942 1686 75 (new) 75 SB375 1738 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font400 1733 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font484 1738 200 (new T[e]) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font684 1733 375 ( to create instances of ) 375 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1059 1738 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1084 1733 799 ( and the language provides the implementor of ) 799 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1883 1738 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1908 1733 86 ( with) 86 SB375 1785 897 (mechanisms for properly initializing instances when ) 897 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1272 1790 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1347 1785 586 ( is invoked. The option would give) 586 SB375 1837 1596 (collectible classes a different look and feel from non-collectible classes, and that might impede) 1596 SB375 1887 620 (the acceptance of garbage collection.) 620 SB435 1937 1426 (Further, whether an object is collectible affects the semantics of its destructors, since) 1426 SB375 1987 1591 (collector-invoked destructors run asynchronously. An implementor of a class with a destructor) 1591 SB375 2037 1536 (would like some way to communicate to clients whether instances of the class can be safely) 1536 SB375 2087 1574 (collectible. In our proposal, the heap specifier allows the class implementor to provide clients) 1574 SB375 2137 1637 (with the correct default placement. If the language provides no heap specifier, then clients are on) 1637 SB375 2187 708 (their own for using the correct placement.) 708 SB435 2237 1570 (Heap specifiers provide programmers with some ability to adapt old code to use the collector.) 1570 SB375 2287 473 (Given a non-collected class ) 473 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font848 2292 25 (C) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font873 2287 268 (, an instance of ) 268 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1141 2292 25 (C) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1166 2287 806 ( can be allocated in the collected heap using the) 806 SB375 2339 190 (expression ) 190 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font565 2344 200 (new gc C) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font765 2339 474 ( or by defining a type name:) 474 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2414 425 (typedef gc C CGC;) 425 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2486 429 (and using the expression ) 429 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font804 2491 175 (new CGC) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font979 2486 979 (. Thus, if a program must import a library that doesn't use) 979 SB375 2538 1510 (garbage collection, the program can still create collected instances of the library's classes.) 1510 SB435 2588 1376 (The program can also derive a collected class from a library's non-collected class ) 1376 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1811 2593 25 (C) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1836 2588 12 (:) 12 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2663 500 (gc class D: C {...};) 500 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2735 295 (Note that if class ) 295 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font670 2740 25 (C) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font695 2735 978 ( has a destructor, the situation is more complicated, since ) 978 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1673 2740 25 (C) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1698 2735 285 ('s destructor may) 285 SB375 2787 1173 (unexpectedly be invoked asynchronously by the collector \(see section ) 1173 SB1548 2787 53 (5.2) 53 SB1601 2787 25 (\).) 25 SB435 2837 1151 (Unlike traditional garbage-collected languages, our proposal allows ) 1151 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1586 2842 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1736 2837 270 ( to be applied to) 270 SB375 2889 1617 (collected objects. We believe that almost all C++ code written from scratch will have no need to) 1617 SB1209 3069 42 (10) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 66 (use ) 66 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font441 274 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font591 269 1404 (; indeed, the safe subset prohibits its use, since it is inherently unsafe. But there are) 1404 SB375 321 603 (two important reasons for allowing ) 603 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font978 326 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1128 321 341 ( of collected objects.) 341 SB435 373 1589 (First, programmers adapting old code may want to use garbage collection as a backup to catch) 1589 SB375 423 1410 (existing storage leaks, while making as few changes as possible. This suggests that ) 1410 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1785 428 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 475 1608 (applied to a collected object should, at a minimum, invoke the object's destructors immediately.) 1608 SB435 525 1274 (Second, programmers writing new garbage-collected code may want to use ) 1274 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1709 530 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1859 525 76 ( as a) 76 SB375 577 1496 (performance hint for the collector, suggesting that some particular objects can be deleted) 1496 SB375 627 1580 (immediately. Depending on the implementation, this may significantly reduce the load on the) 1580 SB375 677 1565 (collector. Implementing immediate deletion is easy with mark-and-sweep algorithms, but we) 1565 SB375 727 1338 (don't know how copying algorithms might take advantage of the deletion hints.) 1338 SB435 777 1519 (Allowing explicit deletion of collected objects lets programmers optimize resource-critical) 1519 SB375 827 1510 (sections of their systems. Often, large systems have small, circumscribed sections that are) 1510 SB375 877 1563 (responsible for large fractions of total storage allocated, and while it may be hard to identify ) 1563 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1938 877 45 (all) 45 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 927 1544 (objects that can be safely deleted, it's often easy to identify many or most objects which can.) 1544 SB375 977 1594 (Programmers can use explicit deletion to make the easy safe optimizations, relying on garbage) 1594 SB375 1027 1343 (collection to catch any leftover objects that were missed or hard to delete safely.) 1343 SB435 1077 407 (In both these scenarios, ) 407 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font842 1082 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font992 1077 995 ( is inherently unsafe and its use requires care to avoid bugs) 995 SB375 1129 1531 (that can't be detected at compile time or run-time. The program may prematurely delete an) 1531 SB375 1179 1601 (object, creating dangling pointers. Also, when adapting old code, the programmer must realize) 1601 SB375 1229 1620 (that the collector will invoke the destructors of collected objects asynchronously and that the old) 1620 SB375 1279 578 (code may not be prepared for that.) 578 SB435 1329 1394 (Despite these problems, we think that allowing deletion of collected objects will be) 1394 SB375 1379 1641 (sufficiently useful that it shouldn't be outlawed. It's very easy to implement \(collectors can simply) 1641 SB375 1429 1501 (ignore the deletion hint\). It also follows the spirit of C++, providing programmers with a) 1501 SB375 1479 1622 (dangerous power tool; those programmers who don't want to cut their hands off can use our safe) 1622 SB375 1529 573 (subset, which prohibits the use of ) 573 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font948 1534 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1098 1529 11 (.) 11 SB435 1581 524 (Finally, declaring a class to be ) 524 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font959 1586 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1009 1581 924 ( in effect supplies the class with the garbage collector's) 924 SB375 1633 1120 (allocation and deallocation methods. Thus, there's no reason for a ) 1120 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1495 1638 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1545 1633 355 ( class also to have an) 355 SB375 1685 195 (overloaded ) 195 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font570 1690 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font645 1685 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font702 1690 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font852 1685 1003 (, and any attempt to do so must be a programming mistake.) 1003 SB1209 3069 42 (11) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 25 (5) 25 SB400 319 771 (. Object clean-up and weak pointers) 771 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 504 (Two closely related facilities, ) 504 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font879 403 263 (object clean-up) 263 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1142 403 84 ( and ) 84 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1226 403 234 (weak pointers) 234 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1460 403 526 (, allow programs to track when) 526 SB375 453 1542 (unreachable objects are freed by the garbage collector. Object clean-up lets the programmer) 1542 SB375 503 1507 (specify actions to be taken when an object is no longer accessible and about to be garbage) 1507 SB375 553 1618 (collected. Weak pointers enable the construction of caches of objects that don't require clients to) 1618 SB375 603 895 (indicate when they are finished using cached objects.) 895 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 703 53 (5.1) 53 SB428 703 308 (. Object clean-up) 308 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 778 1628 (When an object is no longer used by the program and is about to be freed, it is often necessary to) 1628 SB375 828 1645 (clean up the object by releasing resources it holds or removing it from a global data structure. For) 1645 SB375 878 1640 (example, if an object contains an open file handle, the object's clean-up might close the file. Or if) 1640 SB375 928 1597 (an object contains a window handle, the clean-up might release the handle back to the window) 1597 SB375 978 1518 (system. In general, if an object contains some resource controlled by another program, the) 1518 SB375 1028 1621 (operating system, or a non-collected library, a clean-up action can release the resource when the) 1621 SB375 1078 453 (object is garbage collected.) 453 SB435 1128 1108 (C++ supports clean-up with destructors\227when an object of class ) 1108 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1543 1133 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1568 1128 404 ( is about to be freed, the) 404 SB375 1180 239 (destructors of ) 239 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font614 1185 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font639 1180 1334 ( and its base classes are applied to the object. Automatic objects are freed when) 1334 SB375 1232 1581 (their scope is exited; static objects are freed when the program terminates; and heap-allocated) 1581 SB375 1282 387 (objects are freed when ) 387 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font762 1287 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font912 1282 964 ( is called on the object. \(Note that storage allocated by an) 964 SB375 1334 195 (overloaded ) 195 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font570 1339 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font645 1334 628 ( should be released by an overloaded ) 628 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1273 1339 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1423 1334 360 (, not by a destructor.\)) 360 SB435 1386 1445 (In our proposal, garbage-collected objects are also cleaned up using destructors. If the) 1445 SB375 1436 500 (programmer wants objects of ) 500 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font875 1441 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font925 1436 103 ( class ) 103 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1028 1441 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1053 1436 870 ( to be cleaned up when they are about to be garbage) 870 SB375 1488 544 (collected, he writes a destructor ) 544 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font919 1493 100 (~T\(\)) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1019 1488 995 ( that performs the clean-up. When the collector determines) 995 SB375 1540 1627 (that an object is unreachable by the program, it calls the object's destructor before freeing it. The) 1627 SB375 1590 1584 (collector considers an object unreachable if it can't be accessed by following a path of pointers) 1584 SB375 1640 1200 (starting from static variables or automatic variables of active functions.) 1200 SB435 1690 308 (If collected object ) 308 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font743 1695 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font768 1690 584 ( is reachable from collected object ) 584 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1352 1695 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1377 1690 107 (, then ) 107 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1484 1695 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1509 1690 473 ('s destructor will be invoked) 473 SB375 1742 115 (before ) 115 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font490 1747 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font515 1742 525 ('s destructor. This ensures that ) 525 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1040 1747 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1065 1742 899 ('s destructors will see a fully formed, non-cleaned up ) 899 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1964 1747 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1989 1742 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1799 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font400 1794 500 ( will be cleaned up only after ) 500 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font900 1799 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font925 1794 391 ( has been collected. \(If ) 391 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1316 1799 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1341 1794 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1425 1799 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1450 1794 484 ( form a cycle, neither will be) 484 SB375 1846 412 (cleaned up or collected.\)) 412 SB435 1896 507 (An explicit clean-up function ) 507 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font942 1901 25 (f) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font967 1896 528 ( can be registered for an object ) 528 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1495 1901 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1520 1896 136 ( of type ) 136 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1656 1901 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1681 1896 322 ( using the standard) 322 SB375 1948 158 (interface ) 158 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font533 1953 175 (CleanUp) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font708 1948 12 (:) 12 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2023 675 (CleanUp<T, void>::Set\(t, f\)) 675 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2095 1632 (\(The default clean-up function for an object simply calls its destructor.\) Clean-up for a particular) 1632 SB375 2145 1184 (object can be disabled entirely by setting the clean-up function to null:) 1184 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2218 675 (CleanUp<T, void>::Set\(t, 0\)) 675 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2290 1477 (Programmers can force an object's clean-up to be invoked immediately either by calling) 1477 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2363 625 (CleanUp<T, void>::Call\(t\)) 625 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2435 46 (or ) 46 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font421 2440 225 (delete t ) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font646 2435 495 (\(whose implementation calls ) 495 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1141 2440 325 (CleanUp::Call) 325 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1466 2435 528 (\). An object's clean-up is called) 528 SB375 2487 957 (at most once, unless it is explicitly re-enabled by calling ) 957 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1332 2492 300 (CleanUp::Set) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1632 2487 11 (.) 11 SB435 2539 1522 (There is no guarantee that the collector will detect every unreachable object and invoke its) 1522 SB375 2589 1629 (destructors. Conservative collection algorithms find almost all unreachable objects, but not all of) 1629 SB375 2639 1623 (them, and any algorithm likely to be used for C++ in the next several years will almost certainly) 1623 SB375 2689 1607 (use a conservative scan of stacks and registers. Thus, programmers should treat object clean-up) 1607 SB375 2739 1554 (as a mechanism for improving resource usage, and they should not rely on having clean-ups) 1554 SB375 2789 547 (applied to 100% of their objects.) 547 SB435 2839 1542 (Finally, if programmers need some action to occur on heap objects when the program exits,) 1542 SB375 2889 1450 (they should use a termination service like that described by Stroustrup [91, page 466].) 1450 SB1209 3069 42 (12) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 1583 (Termination actions are not the same as destructors\227the destructor of a heap-allocated object) 1583 SB375 319 868 (won't necessarily be called when the program exits.) 868 SB435 369 829 (The precise semantics of object clean-up and the ) 829 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1264 374 175 (CleanUp) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1439 369 438 ( interface are presented in) 438 SB375 421 166 (appendix ) 166 SB541 421 23 (F) 23 SB564 421 11 (.) 11 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 521 53 (5.2) 53 SB428 521 403 (. Clean-up asynchrony) 403 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 596 1598 (Because the collector may run at arbitrary times, a collected object's destructor may be invoked) 1598 SB375 646 1472 (asynchronously with respect to the main thread of execution. This isn't a problem if the) 1472 SB375 696 1584 (destructor side-effects data that is reachable only from the object, since by definition when the) 1584 SB375 746 1530 (destructor is invoked, no other parts of the program can access the object. But sometimes a) 1530 SB375 796 1521 (destructor must access global data or other objects that are still accessible to the rest of the) 1521 SB375 846 1303 (program, and in these cases such access must be synchronized to avoid races.) 1303 SB435 896 1533 ( In multi-threaded environments, synchronizing concurrent access is straightforward using) 1533 SB375 946 1632 (well-understood techniques. In general, programmers must synchronize access to all global data,) 1632 SB375 996 877 (so synchronizing destructors takes little extra effort.) 877 SB435 1046 1520 (But in a traditional single-threaded environment, programmers usually assume there is no) 1520 SB375 1096 1528 (concurrency, and a naively programmed destructor could access inconsistent data. In these) 1528 SB375 1146 1535 (environments, destructors can synchronize using queues provided by the standard interface) 1535 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1201 175 (CleanUp) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 1196 982 (. You can declare a clean-up queue for instances of a type ) 982 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1532 1201 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1557 1196 12 (:) 12 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1271 650 (CleanUp<T, void>::Queue q;) 650 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1343 137 (Calling ) 137 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font512 1348 200 (q.Set\(t\)) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font712 1343 489 ( tells the collector that when ) 489 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1201 1348 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1226 1343 765 ( becomes unreachable it should enqueue it on) 765 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1400 25 (q) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font400 1395 932 ( instead of calling its destructor. The program can poll ) 932 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1332 1400 25 (q) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1357 1395 620 ( periodically at safe points by calling) 620 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1452 200 (q.Call\(\)) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font575 1447 1293 (. Each such call removes the first object from the queue and calls the object's) 1293 SB375 1499 191 (destructor; ) 191 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font566 1504 200 (q.Call\(\)) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font766 1499 275 ( does nothing if ) 275 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1041 1504 25 (q) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1066 1499 928 ( is empty. An example of this technique is presented in) 928 SB375 1551 129 (section ) 129 SB504 1551 53 (5.4) 53 SB557 1551 11 (.) 11 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1651 53 (5.3) 53 SB428 1651 358 (. Clean-up rationale) 358 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1726 1599 (Advocates and critics of C++ garbage collection have been gnashing teeth over object clean-up) 1599 SB375 1776 1580 (and destructors. Two issues arise: should there be object clean-up at all, and if so, how should) 1580 SB375 1826 609 (clean-ups be specified syntactically?) 609 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font375 1901 788 (Should the collector provide object clean-up? ) 788 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1163 1901 791 (There's been over a decade of experience using) 791 SB375 1951 1610 (garbage-collected languages such as Lisp, Cedar, Smalltalk, Clu, and Modula-2+ to build long-) 1610 SB375 2001 1568 (lived applications, servers, and operating systems. In these environments, programmers have) 1568 SB375 2051 1568 (found object clean-up indispensable for managing in-memory caches of objects and releasing) 1568 SB375 2101 1570 (resources provided by other programs, servers, operating systems, and non-collected libraries) 1570 SB375 2151 1647 ([Hayes 92]. There's every reason to expect that object clean-up would be equally useful in systems) 1647 SB375 2201 261 (built with C++.) 261 SB435 2251 408 (In the second edition of ) 408 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font843 2251 582 (The C++ Programming Language) 582 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1425 2251 454 ( [Stroustrup 91, page 466],) 454 SB375 2301 1599 (Stroustrup provides widely quoted arguments against collector-based clean-up. First, he argues) 1599 SB375 2351 1627 (that garbage collection simulates an infinite memory from which objects never get deleted; since) 1627 SB375 2401 1636 (the objects are never deleted from the \(simulated\) infinite memory, the collector shouldn't invoke) 1636 SB375 2451 1604 (their destructors. This argues by analogy without considering whether the analogy is valid, and) 1604 SB375 2501 1610 (like most such arguments it fails to address the basic question: What is most useful for building) 1610 SB375 2551 1510 (systems? In fact, most programmers using collector-based languages view the collector as) 1510 SB375 2601 333 (automating calls to ) 333 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font708 2606 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font858 2601 1131 (, and under this analogy, it's quite sensible for those calls to invoke) 1131 SB375 2653 172 (clean-ups.) 172 SB435 2703 1458 (Stroustrup suggests that destructors \(clean-ups\) should only be invoked as the result of) 1458 SB375 2753 268 (explicit calls to ) 268 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font643 2758 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font793 2753 1207 (. But in general this requires programmers to determine when an object) 1207 SB375 2805 1581 (is no longer being used before invoking their clean-ups. Such a requirement defeats the major) 1581 SB375 2855 1591 (purpose of garbage collection, removing that burden from programmers. \(Note that our design) 1591 SB375 2905 1334 (allows the programmer to force immediate invocation of destructors by calling ) 1334 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1709 2910 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1859 2905 25 (.\)) 25 SB1209 3069 42 (13) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 1540 (Stroustrup then implies that program-termination actions can replace most collector-driven) 1540 SB375 319 1639 (clean-up actions. \(Termination actions are registered functions that get applied to an object when) 1639 SB375 369 1544 (the program terminates.\) But of course, termination actions are different from timely clean-) 1544 SB375 419 1492 (up\227they have different purposes, and programmers want both. Clean-up actions release) 1492 SB375 469 1558 (resources in a timely manner during program execution, whereas termination actions ensure) 1558 SB375 519 354 (some action is taken ) 354 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font729 519 84 (only ) 84 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font813 519 1129 (when the program exits. \(Note that programs such as servers never) 1129 SB375 569 88 (exit.\)) 88 SB435 619 1580 (Many critics are discomfited by asynchronous clean-ups. Stroustrup argues that asynchronous) 1580 SB375 669 1496 (collector-driven clean-up is \223hard to program correctly and less useful than is sometimes) 1496 SB375 719 616 (imagined\224. But we show in sections ) 616 SB991 719 53 (5.2) 53 SB1044 719 84 ( and ) 84 SB1128 719 53 (5.4) 53 SB1181 719 693 ( how to program asynchronous clean-ups) 693 SB375 769 1533 (correctly with no fuss or muss, even in traditional single-threaded C++ environments. And) 1533 SB375 819 1583 (programmers in those other collector-based languages would certainly dispute the implication) 1583 SB375 869 508 (that clean-up isn't very useful.) 508 SB435 919 1460 (Note that destructors may be applied at unexpected times even in standard C++. In the) 1460 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1895 919 98 ( ARM) 98 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1993 919 11 (,) 11 SB375 969 1641 (the exact point at which destructors of temporary objects are called is implementation-dependent.) 1641 SB375 1019 1587 (The ANSI standards committee is currently wrestling with the problem of when destructors of) 1587 SB375 1069 1613 (automatic objects should be invoked, and no matter what they decide, this issue will continue to) 1613 SB375 1119 931 (hold subtle surprises for the unsuspecting programmer.) 931 SB435 1169 1481 (Interestingly, most examples illustrating problems with C++ destructors involve freeing) 1481 SB375 1219 1640 (storage. The most common use of destructors is to free storage, and garbage collection eliminates) 1640 SB375 1269 1541 (the need for such destructors. Based on experience with other collected languages, very few) 1541 SB375 1319 1522 (collected classes will need explicit clean-up actions. Thus in practice, introducing garbage) 1522 SB375 1369 1211 (collection will eliminate most uses of destructors and simplify their use.) 1211 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font375 1444 846 (How should the syntax of clean-ups be specified? ) 846 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1221 1444 795 (There are two choices for specifying clean-ups:) 795 SB375 1494 1582 (functions explicitly registered with the collector, or C++ destructors. We think destructors are) 1582 SB375 1544 1261 (somewhat better, though explicitly registered functions would be adequate.) 1261 SB435 1594 1590 (In languages such as Cedar and Modula-3, programmers write clean-up functions and register) 1590 SB375 1644 1616 (them with the collector. Since this requires no syntactic support from the language, some critics) 1616 SB375 1694 865 (suggest this is the best way of specifying clean-ups.) 865 SB435 1744 1496 (But registered clean-up functions require non-trivial programmer conventions to support) 1496 SB375 1794 838 (modularity and class derivation. Consider a class ) 838 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1213 1799 25 (U) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1238 1794 239 ( derived from ) 239 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1477 1799 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1502 1794 499 (, with both classes desiring to) 499 SB375 1846 1021 (clean up their private members. Any convention must allow ) 1021 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1396 1851 25 (U) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1421 1846 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1505 1851 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1530 1846 337 ( to register clean-up) 337 SB375 1898 1295 (functions independently in their respective constructors, while ensuring that ) 1295 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1670 1903 25 (U) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1695 1898 330 ('s clean-up is called) 330 SB375 1950 115 (before ) 115 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font490 1955 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font515 1950 1376 ('s. Further, each class's clean-up function must also remember to call its members) 1376 SB375 2002 195 (destructors.) 195 SB435 2052 1539 (In light of this, perhaps the best convention would put the clean-up actions for a class in its) 1539 SB375 2102 1258 (destructor and register a clean-up function that simply calls the destructor:) 1258 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2175 300 (class T: S {) 300 SB525 2220 225 (    T\(\) {) 225 SB525 2265 1300 (        CleanUp<T, void>::Set\(this, CallDestructor\);) 1300 SB525 2310 325 (        ...};) 325 SB525 2355 1175 (    static void CallDestructor\(void* d, T* t\) {) 1175 SB525 2400 550 (        t->T::~T\(\); };) 550 SB525 2452 250 (    ~T\(\) {) 250 SB825 2452 75 (/* ) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font900 2447 345 (clean-up actions for ) 345 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1245 2452 100 (T */) 100 SB525 2497 300 (        ...}) 300 SB525 2542 200 (    ....) 200 SB525 2587 150 (    };) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2659 506 (As long as the base classes of ) 506 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font881 2664 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font906 2659 977 ( also follow this convention, their clean-up actions will be) 977 SB375 2711 573 (invoked in the proper order, after ) 573 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font948 2716 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font973 2711 943 ('s clean-up actions. Even if the base classes also register) 943 SB375 2763 499 (clean-ups, all objects of class ) 499 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font874 2768 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font899 2763 668 ( will end up with the clean-up function ) 668 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1567 2768 425 (T::CallDestructor) 425 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1992 2763 11 (,) 11 SB375 2815 97 (since ) 97 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font472 2820 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font497 2815 865 ('s constructor runs after its base-class constructors. ) 865 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1362 2820 425 (T::CallDestructor) 425 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1787 2815 88 ( calls) 88 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2872 175 (T::~T\(\)) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 2867 1259 (, which calls the destructors of the base classes after executing the body of ) 1259 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1809 2872 100 (~T\(\)) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1909 2867 11 (.) 11 SB1209 3069 42 (14) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 1548 (Compared to our design that registers destructors automatically, this convention has several) 1548 SB375 319 1561 (minor disadvantages. First, programmers can make clerical mistakes, forgetting to register a) 1561 SB375 369 1632 (clean-up function in every constructor of class. Such mistakes may be more likely in classes with) 1632 SB375 419 1642 (many constructors or when new constructors are added to an old class by a programmer who isn't) 1642 SB375 469 482 (the original author. Second, ) 482 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font857 474 300 (CleanUp::Set) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1157 469 782 ( may be called several times during an object's) 782 SB375 521 1633 (construction, whereas one call is sufficient. In a typical implementation, the runtime cost of each) 1633 SB375 571 1568 (extra call could be non-trivial, roughly the same as the cost of the allocation itself. Third, the) 1568 SB375 621 1498 (construction of static, automatic, or non-collected heap instances of such classes will call) 1498 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 676 300 (CleanUp::Set) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font675 671 264 ( unnecessarily \() 264 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font939 676 300 (CleanUp::Set) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1239 671 704 ( would do nothing if passed non-collected) 704 SB375 723 1603 (objects\). Finally, the convention is more verbose, and programmers would get annoyed that the) 1603 SB375 773 1602 (language doesn't register the destructors automatically. Destructors get called automatically for) 1602 SB375 823 1399 (static, automatic, and non-collected heap objects, so why exclude collected objects?) 1399 SB435 873 1532 (Some critics \(reportedly including Stroustrup\) say that having the garbage collector invoke) 1532 SB375 923 1640 (destructors asynchronously changes the semantics of the language, and thus existing applications) 1640 SB375 973 1538 (would break. This argument assumes a different model for adding garbage collection to the) 1538 SB375 1023 176 (language: ) 176 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font551 1028 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font626 1023 527 ( would be redefined to allocate ) 527 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1153 1023 56 (all ) 56 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 1023 721 (objects from the collected heap. Under this) 721 SB375 1075 1592 (design, existing code would indeed sometimes break, since such code often depends on having) 1592 SB375 1125 1150 (destructors invoked synchronously at somewhat well-defined points.) 1150 SB435 1175 979 (However, our design is different: We've argued in section ) 979 SB1414 1175 53 (2.2) 53 SB1467 1175 423 ( that, for several reasons,) 423 SB375 1225 1594 (coexistence with existing libraries requires both collected and non-collected heaps, and that by) 1594 SB375 1275 127 (default ) 127 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font502 1280 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font577 1275 1437 ( continues to allocate from the non-collected heap. Thus, the semantics of destructors) 1437 SB375 1327 462 (for non-collected objects is ) 462 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font837 1327 54 (not) 54 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font891 1327 1124 ( changed, and existing code continues to execute correctly side-by-) 1124 SB375 1377 1645 (side with new code written to use garbage collection. We've optimized our design for writing new) 1645 SB375 1427 1362 (code to use garbage collection, while retaining strict compatibility with old code.) 1362 SB435 1477 485 (Note that if a collected class ) 485 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font920 1482 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font945 1477 638 ( is derived from a non-collected class ) 638 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1583 1482 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1608 1477 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1630 1482 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1655 1477 368 ('s destructor could get) 368 SB375 1529 729 (invoked asynchronously when instances of ) 729 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1104 1534 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1129 1529 745 ( are collected, and the destructor may not be) 745 SB375 1581 1617 (prepared for that. In this case, the behavior of non-collected objects hasn't been affected, though) 1617 SB375 1631 697 (the behavior of the collected instances of ) 697 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1072 1636 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1097 1631 920 ( is less than ideal. We weren't willing to flatly prohibit) 920 SB375 1683 1598 (deriving a collected class from a non-collected class with a destructor, since we thought that in) 1598 SB375 1733 1608 (many cases that could be useful, and that this situation would arise only when trying to allocate) 1608 SB375 1783 1608 (collected instances of a non-collected class exported by an existing library. The compiler can of) 1608 SB375 1833 1581 (course give a warning, and the programmer can use clean-up queues to control the invocation) 1581 SB375 1883 1511 (points of the destructors or he can override the destructor with his own clean-up function.) 1511 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1983 53 (5.4) 53 SB428 1983 285 (. Weak pointers) 285 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2058 1617 (Weak pointers allow a class to track which objects are being used by other parts of the program.) 1617 SB375 2108 1544 (The collector ignores weak pointers when tracing reachable objects, so a weak pointer to an) 1544 SB375 2158 1623 (object won't prevent the object from getting collected. The most common use of weak pointers is) 1623 SB375 2208 1637 (to build caches of objects in which cached objects are automatically deleted by the collector when) 1637 SB375 2258 1630 (clients no longer reference them. In contrast to the traditional way of implementing such caches,) 1630 SB375 2308 1583 (clients of weak-pointer caches need not tell the caches when they are finished using an object.) 1583 SB435 2358 1523 (For example, suppose a window server contains a cache of in-memory fonts, keyed by font) 1523 SB375 2408 1627 (name. Fonts consume a lot of memory, so when clients of the window server no longer reference) 1627 SB375 2458 1561 (a font, it should be deleted automatically from the cache, without requiring notification from) 1561 SB375 2508 121 (clients.) 121 SB435 2558 567 (Weak pointers are defined by the ) 567 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1002 2563 275 (WeakPointer) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1277 2558 439 ( template class \(appendix ) 439 SB1716 2558 23 (F) 23 SB1739 2558 206 (\); no special) 206 SB375 2610 1378 (language support is needed. A weak pointer is constructed from a normal pointer ) 1378 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1753 2615 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1778 2610 136 ( of type ) 136 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1914 2615 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2662 367 (using the constructor:) 367 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2735 525 (WeakPointer<T> wp\(t\);) 525 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2807 77 (The ) 77 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font452 2812 175 (Pointer) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font627 2807 1005 ( method translates a weak pointer back to a normal pointer:) 1005 SB1209 3069 42 (15) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font0 0 0 fC525 267 550 ( T* t1 = wp.Pointer\(\);) 550 SB375 344 175 (Pointer) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 339 898 ( returns the original pointer, unless the weak pointer ) 898 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1448 344 50 (wp) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1498 339 168 ( has been ) 168 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1666 339 196 (deactivated) 196 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1862 339 56 (, in) 56 SB375 391 1611 (which case it returns null. The collector deactivates a weak pointer when it garbage-collects the) 1611 SB375 441 1634 (referenced object; that is, when the object becomes unreachable by paths of normal pointers from) 1634 SB375 491 995 (static variables and automatic variables of active functions.) 995 SB435 541 1522 (In our example of a window server's font cache, the server could implement the cache as a) 1522 SB375 591 1577 (table of pairs <font name, weak pointer to font>. Because the table uses only weak pointers to) 1577 SB375 641 1586 (reference its fonts, it won't cause those fonts to be retained in memory by the collector\227a font) 1586 SB375 691 956 (will remain uncollected only if a client still references it.) 956 SB435 741 370 (Here's a sketch of the ) 370 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font805 746 225 (FontCache) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1030 741 12 (:) 12 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 816 275 (class Font;) 275 SB525 906 425 (class FontCache {) 425 SB525 951 1075 (    Table<char*, WeakPointer<Font> > table;) 1075 SB525 996 175 (public:) 175 SB525 1041 800 (    Font* Get\(char* fontName\); }) 800 SB525 1131 500 (FontCache fontCache;) 500 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1203 77 (The ) 77 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font452 1208 75 (Get) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font527 1203 510 ( method returns a font named ) 510 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1037 1208 200 (fontName) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1237 1203 781 (, reading it into memory from disk if it isn't in) 781 SB375 1255 685 (the cache. Its implementation looks like:) 685 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1328 800 (FontCache::Get\(char* fontName\) {) 800 SB525 1373 625 (    WeakPointer<Font> wp;) 625 SB525 1418 850 (    if \(table.Get\(fontName, wp\)\) {) 850 SB525 1463 850 (        Font* font = wp.Pointer\(\);) 850 SB525 1508 925 (        if \(font != 0\) return font; }) 925 SB525 1553 1150 (    Font* font = Font::ReadFromDisk\(fontName\);) 1150 SB525 1598 1225 (    table.Put\(fontName, WeakPointer<Font>\(font\)\);) 1225 SB525 1643 425 (    return font;}) 425 SB375 1720 75 (Get) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1715 677 ( looks in the table for an entry keyed by ) 677 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1127 1720 200 (fontName) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1327 1715 646 (. If there is such an entry, and the font) 646 SB375 1767 1224 (referenced by the entry's weak pointer hasn't yet been garbage collected, ) 1224 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1599 1772 300 (wp.Pointer\(\)) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1899 1767 76 ( will) 76 SB375 1819 300 (return a non-null ) 300 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font675 1824 125 (Font*) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font800 1819 588 (, which is returned to the client. If ) 588 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1388 1824 300 (wp.Pointer\(\)) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1688 1819 295 ( returns null, that) 295 SB375 1871 1616 (means that clients no longer reference the corresponding font and it has been garbage collected.) 1616 SB375 1921 825 (In this case, and in the case of no entry at all for ) 825 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1200 1926 200 (fontName) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1400 1921 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1422 1926 75 (Get) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1497 1921 487 ( reads the font from disk and) 487 SB375 1973 686 (installs it in the table before returning it.) 686 SB435 2023 1462 (Note that, over time, the table could fill up with entries whose fonts have been garbage) 1462 SB375 2073 1572 (collected. Often, programmers can ignore this problem, since the table entries themselves are) 1572 SB375 2123 1574 (small and there often aren't that many entries. If it is a problem, though, there are a couple of) 1574 SB375 2173 434 (straightforward solutions.) 434 SB435 2223 100 (First, ) 100 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font535 2228 75 (Get) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font610 2223 1414 ( could scan the table whenever it fills up, deleting entries whose weak pointers have) 1414 SB375 2275 304 (been deactivated \() 304 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font679 2280 425 (wp.Pointer\(\) == 0) 425 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1104 2275 889 (\). Assuming the table is a dynamically growing hash) 889 SB375 2327 1397 (table, this would increase the time cost of the hash table by a small constant factor.) 1397 SB435 2377 1503 (Alternatively, the table can use object clean-up of fonts. A font's destructor can delete the) 1503 SB375 2427 611 (corresponding entry from the cache:) 611 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2500 975 (Font::~Font\(\) {fontCache.Delete\(this\);}) 975 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2572 1597 (However, the collector may call the destructor during the execution of some other operation on) 1597 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2627 225 (fontCache) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font600 2622 1172 (, creating a race condition. So we must use a clean-up queue \(section ) 1172 SB1772 2622 53 (5.2) 53 SB1825 2622 73 (\) for) 73 SB375 2674 282 (synchronization:) 282 SB1209 3069 42 (16) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font0 0 0 fC525 267 425 (class FontCache {) 425 SB525 312 825 (    CleanUp<Font, void>::Queue q;) 825 SB525 357 225 (    ...};) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 429 112 (When ) 112 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font487 434 75 (Get) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font562 429 553 ( adds a font to the cache, it calls ) 553 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1115 434 275 (q.Set\(font\)) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1390 429 528 (, telling the collector that when) 528 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 486 100 (font) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font475 481 1116 ( becomes unreachable by normal pointers, it should enqueue it on ) 1116 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1591 486 25 (q) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1616 481 359 ( rather than invoking) 359 SB375 533 449 (its destructor. In addition, ) 449 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font824 538 75 (Get) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font899 533 99 ( calls ) 99 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font998 538 200 (q.Call\(\)) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1198 533 754 ( before doing its cache look-up, invoking the) 754 SB375 585 840 (destructors of any inaccessible fonts enqueued on ) 840 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1215 590 25 (q) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1240 585 749 (, thereby removing them from the table. The) 749 SB375 637 171 (enhanced ) 171 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font546 642 75 (Get) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font621 637 186 ( looks like:) 186 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 712 800 (FontCache::Get\(char* fontName\) {) 800 SB32 0 0 42 42 0 0 0 36 /Courier-Bold /font9 ANSIFont font525 762 525 (    while \(q.Call\(\)\);) 525 SB1125 762 75 (/* ) 75 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font1200 759 75 (call ) 75 SB32 0 0 42 42 0 0 0 36 /Courier-Bold /font9 ANSIFont font1275 762 175 (~Font\(\)) 175 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font1450 759 264 ( in a safe place) 264 SB32 0 0 42 42 0 0 0 36 /Courier-Bold /font9 ANSIFont font1714 762 75 ( */) 75 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 811 625 (    WeakPointer<Font> wp;) 625 SB525 856 850 (    if \(table.Get\(fontName, wp\)\) {) 850 SB525 901 850 (        Font* font = wp.Pointer\(\);) 850 SB525 946 900 (        if \(font != 0\) return font;}) 900 SB525 991 1150 (    Font* font = Font::ReadFromDisk\(fontName\);) 1150 SB525 1036 1225 (    table.Put\(fontName, WeakPointer<Font>\(font\)\);) 1225 SB32 0 0 42 42 0 0 0 36 /Courier-Bold /font9 ANSIFont font525 1086 400 (    q.Set\(font\);) 400 SB1050 1086 75 (/* ) 75 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font1125 1083 67 (Set ) 67 SB32 0 0 42 42 0 0 0 36 /Courier-Bold /font9 ANSIFont font1192 1086 100 (font) 100 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font1292 1083 308 ('s clean-up queue) 308 SB32 0 0 42 42 0 0 0 36 /Courier-Bold /font9 ANSIFont font1600 1086 75 ( */) 75 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1135 425 (    return font;}) 425 SB525 1180 500 (FontCache fontCache;) 500 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1252 1613 (The precise semantics of weak pointers and their interaction with object clean-up is specified in) 1613 SB375 1302 166 (appendix ) 166 SB541 1302 23 (F) 23 SB564 1302 11 (.) 11 SB1209 3069 42 (17) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 25 (6) 25 SB400 319 159 (. Safety) 159 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 1614 (Any proposal for C++ garbage collection must define the language rules programs must obey to) 1614 SB375 453 1348 (ensure the correct use of garbage collection. A program following these rules is ) 1348 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1723 453 151 (GC-safe.) 151 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 503 1607 (Programmers and C++ implementors need a precise language definition of GC-safety to ensure) 1607 SB375 553 1627 (that programs can run on any conforming C++ implementation \(subject to memory availability\).) 1627 SB375 603 1562 (That is, the GC-safe rules provide a standard interface between the program and the garbage) 1562 SB375 653 1357 (collector, allowing many different programs to run with many different collector) 1357 SB375 703 293 (implementations.) 293 SB435 753 1554 (Our definition of GC-safety is broad enough to encompass all the major families of collector) 1554 SB375 803 1616 (algorithms, yet simple enough for working programmers. To write a portable GC-safe program,) 1616 SB375 853 1619 (the programmer need only follow the usual C++ portability rules plus one additional restriction.) 1619 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 953 53 (6.1) 53 SB428 953 446 (. Definition of GC-Safety) 446 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1028 1597 (We've adopted Owicki's approach to defining GC-safety [Owicki 81]. The specification of GC-) 1597 SB375 1078 1630 (safety is a promise to the program: if all the program's actions are \223legitimate\224, then the garbage) 1630 SB375 1128 1624 (collector will remain \223invisible\224 to the program. A garbage collector is invisible if it doesn't free) 1624 SB375 1178 1610 (any objects still in use by the program and it doesn't make invalid changes to those objects. The) 1610 SB375 1228 951 (rest of this section defines \223legitimate\224 program actions.) 951 SB435 1278 1534 (Legitimate program actions must maintain three general properties: separation of memory,) 1534 SB375 1328 1519 (visibility of collected pointers, and visibility of assignments. \(In what follows, a \223collected) 1519 SB375 1378 1564 (pointer\224 is a pointer to a collected object. Also, by \223pointer\224 we mean both C++ pointers and) 1564 SB375 1428 283 (C++ references.\)) 283 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font375 1503 397 (Separation of memory. ) 397 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font772 1503 1113 (The program shouldn't change memory locations belonging to the) 1113 SB375 1553 1638 (collector. If it did, say by overwriting structures used to maintain the collected heap, the collector) 1638 SB375 1603 1590 (might accidentally reuse the storage of an object still in use, or it might relocate just part of an) 1590 SB375 1653 110 (object.) 110 SB435 1703 1445 (Further, the program should create new collected objects or new non-collected objects) 1445 SB375 1753 1104 (containing collected pointers only by declarations or by invoking ) 1104 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1479 1758 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1554 1753 423 (. If the program acquired) 423 SB375 1805 1525 (new memory through some mechanism unknown to the collector and then stored collected) 1525 SB375 1855 1539 (pointers in that memory, the collector might not be able to find those pointers, and it might) 1539 SB375 1905 451 (prematurely free an object.) 451 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font375 1980 533 (Visibility of collected pointers. ) 533 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font908 1980 1085 (All collected pointers should be visible at all times. That is, they) 1085 SB375 2030 1598 (should be stored in variables, members, or array elements declared with type \223pointer\224, or they) 1598 SB375 2080 1612 (should be the results of expressions whose type is \223pointer\224. The locations of pointers within an) 1612 SB375 2130 1204 (object are fixed by its declared type \(the declaration or the argument to ) 1204 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1579 2135 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1654 2130 25 (\).) 25 SB435 2182 1589 (A garbage collector needs to know exactly where all collected pointers are located at all times,) 1589 SB375 2232 1553 (so that it can determine which objects are still in use and possibly relocate those objects. If a) 1553 SB375 2282 1584 (pointer is hidden, say, by casting it to an integer or storing it in a location not declared to be a) 1584 SB375 2332 1611 (pointer, then the collector may be fooled into thinking its referent object is no longer in use and) 1611 SB375 2382 1588 (freeing it prematurely. Even if some other visible pointer also points at the object, a relocating) 1588 SB375 2432 1303 (collector couldn't correctly update the hidden pointer after moving the object.) 1303 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font375 2507 424 (Visibility of assignments.) 424 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font799 2507 1147 ( All assignments of collected pointers must be visible to the garbage) 1147 SB375 2557 1613 (collector. That is, if a variable, member, or array element currently contains a collected pointer,) 1613 SB375 2607 1453 (or if its value is to be changed to a collected pointer, then it must be changed either by) 1453 SB375 2657 1555 (initialization to a pointer value or by an assignment expression in which both the lvalue and) 1555 SB375 2707 1515 (rvalue have type \223pointer\224. Some incremental collector algorithms rely on the compiler to) 1515 SB375 2757 1504 (generate special code for pointer assignments. Changing collected pointers through some) 1504 SB375 2807 1367 (mechanism other than a pointer-typed initialization or assignment \(for example, ) 1367 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1742 2812 150 (memcpy) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1892 2807 128 (\) would) 128 SB375 2859 1483 (hide the assignment from the collector, perhaps causing it to prematurely free the object) 1483 SB375 2909 416 (referenced by the rvalue.) 416 SB1209 3069 42 (18) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 344 1463 (For the purposes of determining safety, we assume that all overloaded assignment and ) 1463 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1838 349 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 396 1624 (operators have been expanded to their definitions and that all assignments of whole objects have) 1624 SB375 446 1069 (been expanded into their equivalent member-wise assignments.) 1069 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 546 53 (6.2) 53 SB428 546 669 (. Writing portable GC-safe programs) 669 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 621 1488 (The purpose of GC-safety is to provide a set of rules that let programmers write portable) 1488 SB375 671 1594 (programs that run correctly on many different collector implementations. Despite the apparent) 1594 SB375 721 1588 (complexity of the definition of GC-safety, it's straightforward to write a portable GC-safe C++) 1588 SB375 771 1605 (program. The programmer need only follow the usual C++ portability rules plus one additional) 1605 SB375 821 183 (restriction.) 183 SB435 871 1068 (A program is guaranteed to be GC-safe if it follows these rules:) 1068 SB525 946 1012 (It doesn't execute any of the constructs listed below that the ) 1012 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1537 946 87 (ARM) 87 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1624 946 370 ( labels \223undefined\224 or) 370 SB525 996 501 (\223implementation-dependent\224.) 501 SB525 1071 1420 (It doesn't cast an integer to a pointer, unless the integer resulted from casting a non-) 1420 SB525 1121 1494 (collected pointer and the referent of the pointer is still allocated at the time the integer is) 1494 SB525 1171 369 (cast back to a pointer.) 369 SB375 1246 1611 (\(A program that doesn't follow these rules may still be GC-safe on particular implementations.\)) 1611 SB435 1296 1410 (The following undefined or implementation-dependent constructs could, perhaps in) 1410 SB375 1346 1581 (combination, violate GC-safety on some implementations. The constructs are labeled with the) 1581 SB375 1396 488 (corresponding section of the ) 488 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font863 1396 87 (ARM) 87 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font950 1396 12 (:) 12 SB525 1471 1133 (accessing an uninitialized variable, member, or array element \(8.4\)) 1133 SB525 1521 1420 (accessing a union member after a value has been stored in a different member of the) 1420 SB600 1571 221 (union \(5.2.4\)) 221 SB525 1621 470 (dereferencing a null pointer) 470 SB525 1671 818 (accessing a dangling pointer or reference \(5.3.4\)) 818 SB525 1721 158 (applying ) 158 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font683 1726 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font833 1721 527 ( to a pointer not obtained from ) 527 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1360 1726 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1435 1721 124 ( \(5.3.4\)) 124 SB525 1773 1402 (illegal pointer arithmetic\227adding to a pointer not referencing an array element, or) 1402 SB600 1823 1411 (arithmetic resulting in a pointer outside the bounds of the array \(except for one past) 1411 SB600 1873 372 (the last element\) \(5.7\)) 372 SB525 1923 1375 (a subscript expression whose equivalent in pointer arithmetic is undefined \(5.2.1\)) 1375 SB525 1973 1448 (all casts to types containing pointers, references, and functions, except legal widening) 1448 SB600 2023 1418 (casts \(\223up-casts\224\), legal narrowing casts \(\223down-casts\224\), casts between pointer types) 1418 SB600 2073 73 (and ) 73 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font673 2078 125 (void*) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font798 2073 1036 (, and the casts from integers to pointers described above \(5.4\)) 1036 SB525 2125 597 (casting a pointer to an integer \(5.4\)) 597 SB525 2175 911 (exiting a value-returning function without an explicit ) 911 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1436 2180 150 (return) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1586 2175 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1643 2180 125 (throw) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1768 2175 124 ( \(6.6.3\)) 124 SB525 2227 848 (using variadic functions \(ellipsis\) incorrectly \(8.3\)) 848 SB375 2302 1581 (By definition, it's impossible to know the behavior of undefined or implementation-dependent) 1581 SB375 2352 1623 (constructs without reference to a particular implementation. Thus, a programmer writing a truly) 1623 SB375 2402 1638 (portable program must avoid such constructs regardless of whether he's using garbage collection.) 1638 SB435 2452 1547 (Obviously, some of the constructs have well-defined behavior on some implementations. To) 1547 SB375 2502 1593 (decide whether they are GC-safe on a particular implementation, a programmer would have to) 1593 SB375 2552 1413 (refer to the general definition of GC-safety and any \223specifications\224 provided by the) 1413 SB375 2602 1574 (implementation's vendor. For example, with a fully conservative mark-and-sweep collector, a) 1574 SB375 2652 1511 (program could safely hide collected pointers by casting them to integers and it could copy) 1511 SB375 2702 250 (pointers using ) 250 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font625 2707 150 (memcpy) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font775 2702 11 (.) 11 SB435 2754 1468 (Casting an integer to a pointer could, in general, violate pointer visibility by hiding the) 1468 SB375 2804 1628 (pointer as an integer. If the resulting pointer is invalid, dereferencing it could overwrite memory) 1628 SB375 2854 1235 (locations belonging to the collector, thus violating separation of memory.) 1235 SB1209 3069 42 (19) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 1270 (Casting a pointer to an integer yields an implementation-dependent result \() 1270 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1705 269 98 (ARM ) 98 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1803 269 207 (section 5.4\),) 207 SB375 319 1544 (but programmers often assume that repeated casting of the same pointer will yield the same) 1544 SB375 369 1609 (integer. Of course, this is no longer true with a relocating collector, so programmers wishing to) 1609 SB375 419 1639 (write portable programs should avoid depending on the results of such casts. Though technically,) 1639 SB375 469 1602 (these casts don't violate GC-safety, they violate the spirit of \223invisibility\224 of garbage collection.) 1602 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 569 53 (6.3) 53 SB428 569 300 (. Pointer validity) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 644 1597 (Our definition of GC-safety allows pointer variables to contain invalid values such as dangling) 1597 SB375 694 329 (pointers created by ) 329 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font704 699 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font854 694 1089 ( or pointers fabricated by illegal casting. This definition requires) 1089 SB375 746 1621 (collectors to check the validity of every pointer discovered in a variable or object as the collector) 1621 SB375 796 1590 (traces out all live objects. Also, invalid pointers may cause excess storage to be retained by the) 1590 SB375 846 1188 (collector if they happen to point at storage reused for collected objects.) 1188 SB435 896 1500 (Some have suggested a stronger requirement, that all pointer-valued variables, members,) 1500 SB375 946 1589 (elements, and expressions should evaluate to valid pointers to allocated objects. Most previous) 1589 SB375 996 1560 (garbage-collected languages have required this stronger pointer validity. Pointer validity has) 1560 SB375 1046 1590 (some appeal, since if collectors could assume every pointer followed is valid, they might avoid) 1590 SB375 1096 1570 (some validity checks and the structures needed to support them, and invalid pointers couldn't) 1570 SB375 1146 572 (accidentally retain excess storage.) 572 SB435 1196 1515 (There are several counter-arguments to the stronger requirement of pointer validity. First,) 1515 SB375 1246 1511 (pointer validity won't in fact save the overhead of validity checks. As we argue in section ) 1511 SB1886 1246 53 (2.2) 53 SB1939 1246 41 (, a) 41 SB375 1296 1508 (practical language proposal must allow for arbitrary interior pointers with no special type) 1508 SB375 1346 1520 (declarations, and it cannot use type declarations to distinguish between collected and non-) 1520 SB375 1396 1637 (collected pointer values. The data structures needed to handle interior pointers and to distinguish) 1637 SB375 1446 1632 (between collected and non-collected objects suffice for checking pointer validity, and the validity) 1632 SB375 1496 1595 (checks will cost at most an extra instruction per pointer followed \(compared to the ten or more) 1595 SB375 1546 1246 (instructions needed to map interior pointers to base pointers\227see section ) 1246 SB1621 1546 74 (10.1) 74 SB1695 1546 25 (\).) 25 SB435 1596 1566 (Second, pointer validity won't cause less excess storage to be retained. Regardless of whether) 1566 SB375 1646 1635 (pointer validity is required, programmers must null out all pointers to unused collected objects to) 1635 SB375 1696 1648 (ensure the objects will be freed. If the programmer forgets to null out pointers, excess storage will) 1648 SB375 1746 197 (be retained.) 197 SB435 1796 1527 (Third, pointer validity would prohibit coexistence with a fair amount of existing C++ code) 1527 SB375 1846 1610 (that leaves large numbers of invalid pointers lying around, unused. For example, some libraries) 1610 SB375 1896 261 (use overloaded ) 261 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font636 1901 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font711 1896 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font795 1901 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font945 1896 1048 ( to deallocate a huge collection of objects simultaneously, thus) 1048 SB375 1948 1644 (creating large numbers of dangling pointers that are never subsequently dereferenced. As another) 1644 SB375 1998 1579 (example, low-level code often creates pointers that don't appear to reference allocated objects.) 1579 SB435 2048 829 (Fourth, pointer validity requires the argument to ) 829 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1264 2053 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1414 2048 604 ( be the last remaining pointer to the) 604 SB375 2100 1591 (object being deleted. Maintaining this property would complicate destructors for non-collected) 1591 SB375 2150 1640 (circularly linked structures, requiring re-engineering of existing code and awkward constructions) 1640 SB375 2200 244 (in future code.) 244 SB435 2250 1019 (Dangling pointers to collected objects wouldn't be created if ) 1019 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1454 2255 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1604 2250 405 ( didn't allow the storage) 405 SB375 2302 1576 (occupied by collected objects to be reused immediately. However, we think garbage collection) 1576 SB375 2352 1628 (will be much more palatable to product engineers if they have the option of optimizing resource-) 1628 SB375 2402 697 (critical parts of their systems via explicit ) 697 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1072 2407 175 (delete') 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1247 2402 725 (s that free storage immediately \(see section) 725 SB375 2454 53 (4.2) 53 SB428 2454 25 (\).) 25 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2554 53 (6.4) 53 SB428 2554 259 (. Type validity) 259 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2629 1041 (Our definition of GC-safety allows a collected pointer of type ) 1041 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1416 2634 50 (T*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1466 2629 470 ( to be stored in a variable of) 470 SB375 2681 220 (another type ) 220 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font595 2686 50 (U*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font645 2681 147 (, even if ) 147 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font792 2686 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font817 2681 343 ( is not derived from ) 343 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1160 2686 25 (U) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1185 2681 805 (. GC-safety requires only that collected pointers) 805 SB375 2733 1384 (be stored in variables, members, and elements declared to have some pointer type.) 1384 SB435 2783 1559 (This weak type validity imposes one requirement on collectors: collected storage returned by) 1559 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2838 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2833 1550 ( must always be aligned to the largest possible alignment of any type \(typically 32- or 64-bit) 1550 SB375 2885 1559 (alignment\), regardless of the actual type being allocated. This requirement ensures that if an) 1559 SB1209 3069 42 (20) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 723 (address is truncated by an assignment of a ) 723 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1098 274 50 (T*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1148 269 118 ( into a ) 118 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1266 274 50 (U*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1316 269 686 ( \(such as on a word-addressed machine\),) 686 SB375 321 1070 (the truncated address still refers to the original collected object.) 1070 SB435 371 652 (Most, perhaps all, implementations of ) 652 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1087 376 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1162 371 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1246 376 150 (malloc) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1396 371 567 ( already behave this way. Though) 567 SB375 423 63 (the ) 63 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font438 423 87 (ARM) 87 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font525 423 1417 ( is silent on the issue, returning maximally aligned storage is required to implement) 1417 SB375 473 255 (overloading of ) 255 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font630 478 300 (operator new) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font930 473 11 (.) 11 SB435 525 1195 (A stronger notion of type validity would require that a variable of type ) 1195 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1630 530 50 (T*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1680 525 313 ( contains a pointer) 313 SB375 577 299 (to a value of type ) 299 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font674 582 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font699 577 407 ( or a class derived from ) 407 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1106 582 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1131 577 878 (. We know of only one garbage-collection technique) 878 SB375 629 1537 (that benefits from strong type validity. This technique uses the declared types of pointers to) 1537 SB375 679 1615 (determine the types of objects in the heap rather than tagging the objects themselves, saving the) 1615 SB375 729 1512 (space overhead of the tags. But this technique doesn't fully extend to languages with class) 1512 SB375 779 1620 (inheritance\227objects of class types still need to be tagged. As far as we know, this technique has) 1620 SB375 829 1582 (never been implemented, and its space savings for typical C++ programs would be negligible.) 1582 SB435 879 1534 (Further, like pointer validity, strong type validity would restrict compatibility with existing) 1534 SB375 929 175 (C++ code.) 175 SB1209 3069 42 (21) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 25 (7) 25 SB400 319 263 (. Safe subset) 263 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 1624 (The safe subset is just that: a true subset of the C++ language [Ellis 91], requiring no extensions) 1624 SB375 453 1586 (or changes. Programmers are assured that code written in the safe subset is GC-safe, that is, it) 1586 SB375 503 1608 (follows the safe-use rules of the garbage collector. More importantly, they are assured that code) 1608 SB375 553 1537 (written in the safe subset cannot be responsible for storage-related bugs caused by dangling) 1537 SB375 603 1544 (pointers or references, memory smashes, null-pointer dereferences, or invalid array indices.) 1544 SB375 653 1609 (Programmers mark safe code with a pragma, and the compiler ensures that such code uses only) 1609 SB375 703 1609 (the safe subset. It also generates some run-time checks to ensure safe use of particular language) 1609 SB375 753 1631 (features\227a program attempting to use an invalid pointer will halt with an error. Code written in) 1631 SB375 803 1544 (the safe subset can be ported without change to C++ implementations that don't provide the) 1544 SB375 853 114 (subset.) 114 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font435 903 1280 (Programmers need not write in the safe subset to use garbage collection) 1280 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1715 904 223 (, but then the) 223 SB375 954 1594 (responsibility is on them to ensure GC-safety and to avoid storage bugs. Experience with other) 1594 SB375 1004 1546 (garbage-collected languages shows that automatic-enforcement of the safe-use rules is quite) 1546 SB375 1054 1644 (important, since collectors tend to scramble the heap arbitrarily when the rules are violated. Even) 1644 SB375 1104 1517 (when some parts of a program can't be written in the safe subset, using it in the rest of the) 1517 SB375 1154 1624 (program reduces the potential for mistakes\227when tracking down storage bugs, the programmer) 1624 SB375 1204 814 (can safely rule out all code written in the subset.) 814 SB435 1254 1452 (The run-time checks are designed to have fairly low overhead so that they can be used) 1452 SB375 1304 1639 (throughout development and even in production. However, programmers can disable them at any) 1639 SB375 1354 571 (time, trading safety for efficiency.) 571 SB435 1404 1566 (The safe subset ensures portability among different implementations of garbage collection by) 1566 SB375 1454 1609 (enforcing implementation-independent safe-use rules. An unsafe program may work with some) 1609 SB375 1504 1551 (collectors but not others; for example, an unsafe program may work with a mark-and-sweep) 1551 SB375 1554 740 (collector but break with a copying collector.) 740 SB435 1604 1578 (The design of the safe subset is based on long experience with languages like Cedar, Modula-) 1578 SB375 1654 1476 (2+, Modula-3, and Ada [Rovner 85a, Rovner 85b, Nelson 91]. The safe subsets of these) 1476 SB375 1704 1595 (languages are expressive enough for applications and all but the lowest-level systems code and) 1595 SB375 1754 1646 (run-time facilities \(such as device drivers\). This C++ safe subset is noticeably less restrictive than) 1646 SB375 1804 1531 (the subsets of those languages, however. In particular, a non-collected object can point at a) 1531 SB375 1854 1611 (collected object, a pointer may address the interior of another object, and pointers may be freely) 1611 SB375 1904 769 (passed to libraries written in other languages.) 769 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2004 53 (7.1) 53 SB428 2004 317 (. Subset summary) 317 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2079 501 (The subset enforces safety by:) 501 SB525 2154 1444 (enforcing at run-time what's already illegal in C++ but current implementations don't) 1444 SB525 2204 137 (prevent,) 137 SB525 2279 1343 (replacing built-in arrays with safe arrays provided by standard template classes,) 1343 SB525 2354 778 (preventing fabrication of invalid pointers, and) 778 SB525 2429 755 (preventing dangling pointers and references.) 755 SB375 2504 1614 (To prevent dangling addresses of automatic variables, the subset prohibits pointers to automatic) 1614 SB375 2554 1222 (variables and storing references to automatic variables into heap objects.) 1222 SB435 2604 191 (A pragma, ) 191 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font626 2609 300 (#pragma safe) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font926 2604 1059 (, declares source files and blocks as safe. The compiler ensures) 1059 SB375 2654 963 (that only safe constructs are used in safe files and blocks.) 963 SB435 2704 1406 (The following features are disallowed in safe code by the compiler at compile-time:) 1406 SB525 2779 304 (pointer arithmetic) 304 SB525 2829 304 (array subscripting) 304 SB525 2879 484 (converting arrays to pointers) 484 SB1209 3069 42 (22) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC525 269 974 (passing arguments to formal parameters of type \223array of ) 974 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1499 274 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1524 269 44 (\224 \() 44 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1568 274 75 (T[]) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1643 269 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1700 274 100 (T[c]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1800 269 193 (\) unless the) 193 SB600 321 287 (formal is of type ) 287 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font887 326 175 (T\(&\)[c]) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1062 321 350 ( \(\223reference to array ) 350 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1412 326 75 ([c]) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1487 321 55 ( of ) 55 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1542 326 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1567 321 383 (\224\) or the argument is a) 383 SB600 373 209 (string literal) 209 SB525 423 1447 (all casts to types containing pointers, references, and functions, except widening casts) 1447 SB600 473 487 (and checked narrowing casts) 487 SB525 523 949 (union types containing pointers, references, or functions) 949 SB525 573 211 (overloading ) 211 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font736 578 300 (operator new) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font525 625 744 (uninitialized pointer variables and members) 744 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 680 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font675 675 536 ( and explicit calls to destructors) 536 SB525 725 525 (functions declared with ellipsis) 525 SB435 800 1375 (The compiler generates run-time checks in safe code for the following constructs:) 1375 SB525 875 470 (dereferencing a null pointer) 470 SB525 925 158 (applying ) 158 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font683 930 25 (&) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font708 925 786 ( to an lvalue referencing an automatic variable) 786 SB525 977 783 (initializing a reference in an object created by ) 783 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1308 982 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1383 977 418 ( to an automatic variable) 418 SB525 1029 247 (explicit use of ) 247 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font772 1034 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font872 1029 1099 ( when it points to an automatic object, unless it is the operand of ) 1099 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1971 1034 25 (*) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font600 1081 46 (or ) 46 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font646 1086 50 (->) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font525 1133 933 (returning a dangling reference to an automatic variable) 933 SB525 1183 911 (exiting a value-returning function without an explicit ) 911 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1436 1188 150 (return) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1586 1183 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1643 1188 125 (throw) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1260 300 (If a check fails, a ) 300 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font675 1260 392 (checked run-time error) 392 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1067 1260 890 ( occurs and the program halts in an implementation-) 890 SB375 1310 262 (dependent way.) 262 SB435 1360 839 (Two restrictions are placed on the compiler itself:) 839 SB525 1435 1450 (The storage for a temporary object used in the initialization of a reference must not be) 1450 SB525 1485 846 (reused until the block defining the reference exits.) 846 SB525 1560 761 (Arrays of pointers must be initialized to null.) 761 SB375 1635 1609 (Code-generator safety imposes further restrictions on the compiler. But code-generator safety is) 1609 SB375 1685 1222 (required regardless of whether the safe subset is used or not \(see section ) 1222 SB1597 1685 42 (11) 42 SB1639 1685 25 (\).) 25 SB435 1735 403 (Three standard classes, ) 403 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font838 1740 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font963 1735 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font985 1740 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1185 1735 95 (, and ) 95 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1280 1740 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1480 1735 509 (, provide safe arrays with run-) 509 SB375 1787 708 (time subscript checks. The standard class ) 708 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1083 1792 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1183 1787 630 ( provides efficient immutable strings.) 630 SB435 1839 1527 (In what follows, each of the restrictions is specified more precisely and discussed in detail.) 1527 SB375 1889 1300 (Everywhere an operator is mentioned, we mean the built-in operator, not any) 1300 SB375 1939 1223 (overloadings\227there are no specific restrictions on overloaded operators.) 1223 SB435 1989 1039 (The following terms are used by the subset definition. A type ) 1039 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1474 1994 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1499 1989 50 ( is ) 50 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1549 1989 317 (pointer-containing) 317 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1866 1989 48 ( if:) 48 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2071 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 2066 293 ( is a pointer type;) 293 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2123 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 2118 987 ( is an array type whose element type is pointer-containing;) 987 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2175 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 2170 1374 ( is a class containing or inheriting a member whose type is pointer-containing; or) 1374 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2227 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 2222 815 ( is a union containing a pointer-containing type.) 815 SB375 2299 312 (The definitions of ) 312 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font687 2299 355 (reference-containing) 355 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1042 2299 84 ( and ) 84 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1126 2299 334 (function-containing) 334 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1460 2299 204 ( are similar.) 204 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2399 53 (7.2) 53 SB428 2399 244 (. Pragma safe) 244 SB%%BeginResource: font MSTT31c295/GreNewFont{10 dict dup 3 1 roll def dup begin 6 1 roll/FontType 3def/FontMatrix exch def/FontBBox exch def/FontInfo 2 dict def FontInfo/UnderlinePosition 3 -1 roll put FontInfo/UnderlineThickness 3 -1roll put/Encoding 256 array def 0 1 255{Encoding exch/.notdef put}for/CharProcs 256 dict def CharProcs/.notdef{}put/Metrics 256 dict defMetrics/.notdef 3 -1 roll put/BuildChar{/char exch def/fontdict exchdef/charname fontdict/Encoding get char get def fontdict/Metrics getcharname get aload pop setcachedevice fontdict begin Encoding charget CharProcs exch get end exec}def end definefont pop}def/AddChar{beginEncoding 3 1 roll put CharProcs 3 1 roll put Metrics 3 1 roll put end}def/MSTT31c295 [42.0 0 0 0 0 0] 47 -92 [-42.0 -42.0 42.0 42.0] [1 42 div 0 0 1 42 div 0 0] /MSTT31c295 GreNewFont%%EndResource32 0 0 42 42 0 0 1 37 /MSTT31c295 font%%BeginResource: font MSTT31c295/G6f [37.0 0.0 4.0 0.0 34.0 30.0]/G6f {    30 30 true [1 0 0 -1 -4.0 30.0] {<fffffffcfffffffcfffffffcfffffffcf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cfffffffcfffffffcfffffffcfffffffc>} imagemask   }  111 /G6f MSTT31c295 AddChar%%EndResourcegs 412 3231 0 0 CB375 2500 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2499 1438 (Programmers use pragmas to specify which code is written in the safe subset, and the) 1438 SB450 2549 1396 (compiler enforces the use of the safe subset in such code. Declarations, blocks, and) 1396 SB450 2599 1282 (parenthesized expressions can be specified safe or unsafe using the pragmas) 1282 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2672 300 (#pragma safe) 300 SB525 2717 350 (#pragma unsafe) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2789 1505 (The pragmas can occur syntactically anywhere a declaration can occur \(in a file, class, or) 1505 SB450 2839 957 (block\) or at the beginning of a parenthesized expression:) 957 SB1209 3069 42 (23) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font0 0 0 fC525 267 25 (\() 25 SB525 312 350 (#pragma unsafe) 350 SB525 357 100 (...\)) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 429 1560 (The scope of the pragma extends to the end of the file, class, block, or expression containing) 1560 SB450 479 485 (the pragma or until the next ) 485 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font935 484 100 (safe) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1035 479 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1092 484 150 (unsafe) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1242 479 742 ( pragma, whichever comes first. There is an) 742 SB450 531 143 (implicit ) 143 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font593 536 350 (#pragma unsafe) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font943 531 999 ( at the beginning of every file. The scope of a pragma in an) 999 SB450 583 908 (included header file ends at the end of the header file.) 908 SB510 633 583 (A name declared in the scope of a ) 583 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1093 638 100 (safe) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1193 633 739 ( pragma is marked safe; all other names are) 739 SB450 685 258 (marked unsafe.) 258 SB510 735 1473 (It is a compile-time error for declarations, statements, and expressions in the scope of a) 1473 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font450 790 100 (safe) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 785 1213 ( pragma to use unsafe names or constructs prohibited by the safe subset.) 1213 SB510 837 1515 (The declaration of a function may be declared safe, while its definition is declared unsafe.) 1515 SB450 887 1540 (In this case, the programmer is asserting that he believes the function cannot violate safety,) 1540 SB450 937 1501 (even though it may be implemented with unsafe constructs. It is a programmer bug if the) 1501 SB450 987 983 (function ever violates safety when called from safe scopes.) 983 SB375 1062 1627 (A programmer is assured that a storage bug couldn't be caused by safe files and blocks, since the) 1627 SB375 1112 1537 (execution of a safe block cannot cause GC-safety to be violated. If a name's declaration and) 1537 SB375 1162 1575 (definition are both declared safe, then any use of the name in safe scopes will not violate GC-) 1575 SB375 1212 108 (safety.) 108 SB435 1262 1018 (A class may declare both safe and unsafe member functions:) 1018 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1335 300 (#pragma safe) 300 SB525 1380 225 (class T {) 225 SB525 1425 325 (    void f\(\);) 325 SB525 1470 450 (    #pragma unsafe) 450 SB525 1515 400 (    void g\(\); }:) 400 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1587 1584 (This allows programmers to provide unsafe methods that aren't intended for general, safe use.) 1584 SB435 1637 1425 (As a rule, it is good to have as many safe interfaces as possible, even if some of their) 1425 SB375 1687 1623 (implementations are written in the unsafe language. An interface declared safe signals to clients) 1623 SB375 1737 1573 (that use of the interface shouldn't cause storage bugs. If the interface's implementation is also) 1573 SB375 1787 1603 (declared safe, then the compiler ensures that its use from safe scopes won't violate safety; but if) 1603 SB375 1837 1643 (the implementation is declared unsafe, then the programmer is merely asserting that its use won't) 1643 SB375 1887 1465 (violate safety, and it is a bug in the implementation if it does. If most of an interface or) 1465 SB375 1937 1204 (implementation is safe, it is best to declare the entire file as safe, using ) 1204 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1579 1942 350 (#pragma unsafe) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1929 1937 43 ( to) 43 SB375 1989 800 (identify the few unsafe declarations and blocks.) 800 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2089 53 (7.3) 53 SB428 2089 595 (. Enforcing what's already illegal) 595 SB%%BeginResource: font MSTT31c295/GreNewFont{10 dict dup 3 1 roll def dup begin 6 1 roll/FontType 3def/FontMatrix exch def/FontBBox exch def/FontInfo 2 dict def FontInfo/UnderlinePosition 3 -1 roll put FontInfo/UnderlineThickness 3 -1roll put/Encoding 256 array def 0 1 255{Encoding exch/.notdef put}for/CharProcs 256 dict def CharProcs/.notdef{}put/Metrics 256 dict defMetrics/.notdef 3 -1 roll put/BuildChar{/char exch def/fontdict exchdef/charname fontdict/Encoding get char get def fontdict/Metrics getcharname get aload pop setcachedevice fontdict begin Encoding charget CharProcs exch get end exec}def end definefont pop}def/AddChar{beginEncoding 3 1 roll put CharProcs 3 1 roll put Metrics 3 1 roll put end}def/MSTT31c295 [42.0 0 0 0 0 0] 47 -92 [-42.0 -42.0 42.0 42.0] [1 42 div 0 0 1 42 div 0 0] /MSTT31c295 GreNewFont%%EndResource32 0 0 42 42 0 0 1 37 /MSTT31c295 font%%BeginResource: font MSTT31c295/G6f [37.0 0.0 4.0 0.0 34.0 30.0]/G6f {    30 30 true [1 0 0 -1 -4.0 30.0] {<fffffffcfffffffcfffffffcfffffffcf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cfffffffcfffffffcfffffffcfffffffc>} imagemask   }  111 /G6f MSTT31c295 AddChar%%EndResourcegs 412 3231 0 0 CB375 2190 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2189 1302 (A run-time check ensures that dereferenced pointer expressions are non-null.) 1302 SB375 2264 1613 (Dereferencing a null pointer would violate the definition of safety. In most implementations, an) 1613 SB375 2314 1031 (unchecked dereference of null could result in garbage values.) 1031 SB435 2364 1523 (In many, if not most, implementations, run-time checks for null are almost free\227the first ) 1523 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1958 2364 21 (n) 21 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2414 1621 (bytes of an address space are unmapped, and attempts to reference them cause a virtual-memory) 1621 SB375 2464 1023 (exception. Only dereferences involving an offset larger than ) 1023 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1398 2464 21 (n) 21 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1419 2464 556 ( or an offset unknown at compile) 556 SB375 2514 712 (time require explicit checks. For example:) 712 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2590 425 (struct S {char a[) 425 SB32 0 0 42 42 0 0 0 36 /Courier-Oblique /font11 ANSIFont font950 2587 25 (n) 25 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font975 2590 275 (]; int i;};) 275 SB525 2635 275 (S* s = ...;) 275 SB525 2680 325 (int j = s->i;) 325 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2752 38 (If ) 38 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font413 2757 25 (s) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font438 2752 492 ( is null, then the dereference ) 492 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font930 2757 100 (s->i) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1030 2752 991 ( won't cause a virtual-memory exception, since the word at) 991 SB375 2804 137 (address ) 137 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font512 2804 21 (n) 21 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font533 2804 1326 ( isn't unmapped. The check requires a single instruction: before dereferencing ) 1326 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1859 2809 25 (s) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1884 2804 46 (, it) 46 SB375 2856 527 (loads the word at offset 0 from ) 527 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font902 2861 25 (s) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font927 2856 401 ( and discards the result.) 401 SB1209 3069 42 (24) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 1 37 /MSTT31c295 font0 0 0 fCgs 412 3231 0 0 CB375 270 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 269 1506 (A run-time check ensures that a function never returns a reference to one of its automatic) 1506 SB450 319 162 (variables.) 162 SB375 394 1568 (If a function returns a reference to one of its automatic variables, the reference will dangle as) 1568 SB375 444 1278 (soon as the function's stack frame is popped. References can be returned by ) 1278 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1653 449 150 (return) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1803 444 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1887 449 125 (throw) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 496 1582 (statements, either as the returned or thrown value, or as a member or element of such a value.) 1582 SB435 546 1509 (Checking returned references at run-time is cheap. On the MIPS R3000, for example, the) 1509 SB375 596 907 (following sequence checks that an address in register ) 907 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1282 601 50 ($r) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1332 596 682 ( doesn't point to the current stack frame:) 682 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 671 425 (subu  $t, $r, $sp) 425 SB525 716 575 (sltiu $t, $t, framesize) 575 SB525 761 450 (bne   $t, 0, error) 450 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 833 1525 (The check can be omitted wherever the compiler can determine statically that the returned) 1525 SB375 883 1569 (reference was or was not initialized to an lvalue of a local automatic variable. For example, a) 1569 SB375 933 1543 (reference-valued formal parameter or a pointer dereference couldn't possibly refer to a local) 1543 SB375 983 1629 (automatic variable \(in the safe subset\). In general, the only returned references needing run-time) 1629 SB375 1033 1574 (checks are those whose initialization is not statically apparent, that occurs after entry into the) 1574 SB375 1083 1595 (function, and that might refer to local variables; such references can occur only as the result of) 1595 SB375 1133 1356 (function calls with reference parameters or of catching exceptions. For example:) 1356 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1206 375 (int& f\(int& i\);) 375 SB525 1251 250 (int& g\(\) {) 250 SB525 1296 400 (    int i = ...;) 400 SB525 1341 425 (    return f\(i\);}) 425 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1413 671 (The initialization of the return value of ) 671 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1046 1418 100 (f\(i\)) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1146 1413 798 ( is not statically apparent, so the compiler must) 798 SB375 1465 509 (generate a run-time check for ) 509 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font884 1470 25 (g) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font909 1465 1088 ('s return. Note that references returned by inlined functions need) 1088 SB375 1517 1556 (not be checked \(assuming the storage for the function's automatic variables persists until the) 1556 SB375 1567 212 (callee exits\).) 212 SB435 1617 1567 (Most returned references can be statically analyzed by the compiler, and thus the overall cost) 1567 SB375 1667 769 (of the run-time check should be insignificant.) 769 SB%%BeginResource: font MSTT31c295/GreNewFont{10 dict dup 3 1 roll def dup begin 6 1 roll/FontType 3def/FontMatrix exch def/FontBBox exch def/FontInfo 2 dict def FontInfo/UnderlinePosition 3 -1 roll put FontInfo/UnderlineThickness 3 -1roll put/Encoding 256 array def 0 1 255{Encoding exch/.notdef put}for/CharProcs 256 dict def CharProcs/.notdef{}put/Metrics 256 dict defMetrics/.notdef 3 -1 roll put/BuildChar{/char exch def/fontdict exchdef/charname fontdict/Encoding get char get def fontdict/Metrics getcharname get aload pop setcachedevice fontdict begin Encoding charget CharProcs exch get end exec}def end definefont pop}def/AddChar{beginEncoding 3 1 roll put CharProcs 3 1 roll put Metrics 3 1 roll put end}def/MSTT31c295 [42.0 0 0 0 0 0] 47 -92 [-42.0 -42.0 42.0 42.0] [1 42 div 0 0 1 42 div 0 0] /MSTT31c295 GreNewFont%%EndResource32 0 0 42 42 0 0 1 37 /MSTT31c295 font%%BeginResource: font MSTT31c295/G6f [37.0 0.0 4.0 0.0 34.0 30.0]/G6f {    30 30 true [1 0 0 -1 -4.0 30.0] {<fffffffcfffffffcfffffffcfffffffcf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cfffffffcfffffffcfffffffcfffffffc>} imagemask   }  111 /G6f MSTT31c295 AddChar%%EndResourcegs 412 3231 0 0 CB375 1768 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1767 1447 (A run-time check at the end of a value-returning function ensures that it exits with an) 1447 SB450 1817 137 (explicit ) 137 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font587 1822 150 (return) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font737 1817 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font794 1822 125 (throw) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font919 1817 11 (.) 11 SB375 1894 1283 (It is illegal in C++ for a value-returning function to exit without an explicit ) 1283 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1658 1899 150 (return) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1808 1894 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1865 1899 125 (throw) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1990 1894 11 (,) 11 SB375 1946 1547 (but implementations are not required to check for that. In most implementations, a function) 1547 SB375 1996 457 (exiting without an explicit ) 457 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font832 2001 150 (return) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font982 1996 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1039 2001 125 (throw) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1164 1996 790 ( will return some undefined value to the caller,) 790 SB375 2048 1576 (typically whatever happens to be in the return-value register. A pointer-valued function could) 1576 SB375 2098 466 (thus return an illegal value.) 466 SB435 2148 1565 (The check is trivial to implement\227after the function's last statement, the compiler generates) 1565 SB375 2198 1648 (an unconditional error call. The check imposes no run-time penalty, and in most situations, dead-) 1648 SB375 2248 1572 (code removal will eliminate the check entirely. Good compilers should warn the programmer) 1572 SB375 2298 671 (about functions that may exit without a ) 671 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1046 2303 150 (return) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1196 2298 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1253 2303 125 (throw) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1378 2298 565 ( \(that is, those functions in which) 565 SB375 2350 887 (dead-code removal isn't able to eliminate the check\).) 887 SB32 0 0 42 42 0 0 1 37 /MSTT31c295 fontgs 412 3231 0 0 CB375 2451 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2450 949 ( All pointers must be explicitly initialized. In particular:) 949 SB510 2500 885 (All pointer-valued variables and pointers created by ) 885 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1395 2505 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1470 2500 503 ( must be explicitly initialized.) 503 SB510 2552 1452 (All pointer-valued non-static members of an object must be explicitly initialized by an) 1452 SB450 2602 1411 (aggregate list, a member initializer of a constructor, or a compiler-synthesized copy) 1411 SB450 2652 1429 (constructor. A constructor's member initializer for a pointer- or reference-containing) 1429 SB450 2702 439 (member must not refer to ) 439 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font889 2707 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font989 2702 977 ( or other members of its class or base classes. A compiler-) 977 SB450 2754 1401 (synthesized implicit default constructor does not explicitly initialize pointer-valued) 1401 SB450 2804 164 (members.) 164 SB510 2854 1217 (As a special case, arrays of pointers are automatically initialized to null.) 1217 SB1209 3069 42 (25) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 1636 (Pointers must be explicitly initialized to legal values, since C++ does not define the initial values) 1636 SB375 319 945 (of automatic variables or members of objects created by ) 945 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1320 324 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1395 319 604 (. C++ already requires references to) 604 SB375 371 231 (be initialized.) 231 SB435 421 1446 (In practice, requiring explicit initializers won't produce less efficient code, since good) 1446 SB375 471 1644 (compilers remove clearly useless assignments. But some programmers will grumble about having) 1644 SB375 521 1215 (to write a few extra characters in constructors and variable declarations.) 1215 SB435 571 1576 (The language would be more concise if implementations automatically initialized all pointers) 1576 SB375 621 1552 (to null, optimizing away any useless assignments. Unfortunately, many programmers would) 1552 SB375 671 1529 (object if this change were made to both the safe and the unsafe parts of the language, since) 1529 SB375 721 1586 (compilers can't always detect when an initializing assignment can be optimized away, and the) 1586 SB375 771 1645 (programmers would object to the \(very small\) inefficiency. But if pointers were initialized only in) 1645 SB375 821 1597 (the safe subset, code that worked in the safe subset might behave differently if copied to unsafe) 1597 SB375 871 322 (code. For example:) 322 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 944 200 (char *s;) 200 SB525 989 575 (if \(s == 0\) s1 else s2;) 575 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1061 250 (The statement ) 250 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font625 1066 50 (s1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font675 1061 746 ( would be executed in the safe subset, while ) 746 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1421 1066 50 (s1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1471 1061 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1528 1066 50 (s2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1578 1061 397 ( may be executed in the) 397 SB375 1113 1560 (unsafe language. While such behavior is consistent with the definition of C++, as a practical) 1560 SB375 1163 1633 (matter it seems unwise to create situations that allow safe code free of checked run-time errors to) 1633 SB375 1213 856 (behave differently when copied to an unsafe scope.) 856 SB435 1263 1492 (Unfortunately, C++ provides no general method for initializing arrays of pointers. Thus,) 1492 SB375 1313 1526 (arrays of pointers declared in the safe subset will be automatically initialized to null by the) 1526 SB375 1363 366 (compiler \(see section ) 366 SB741 1363 53 (7.7) 53 SB794 1363 25 (\).) 25 SB435 1413 567 (Some people have suggested that ) 567 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1002 1418 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1077 1413 920 ( should zero all objects, not just arrays of pointers. But) 920 SB375 1465 1647 (it's more efficient to require explicit initialization, since a class often needs to initialize a member) 1647 SB375 1515 995 (to a non-zero value. Zeroing every object could slow down ) 995 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1370 1520 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1445 1515 518 ( \(or garbage collection\) quite a) 518 SB375 1567 743 (bit. For example, a good implementation of ) 743 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1118 1572 150 (malloc) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1268 1567 12 (/) 12 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1280 1572 100 (free) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1380 1567 642 ( \(which doesn't zero objects\) may take) 642 SB375 1619 1462 (about 70 RISC instructions, while zeroing a 200-byte object could add at least 50 more) 1462 SB375 1669 209 (instructions.) 209 SB435 1719 355 (Given a pointer type ) 355 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font790 1724 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font815 1719 361 (, the standard syntax ) 361 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1176 1724 200 (new T\(e\)) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1376 1719 513 ( initializes the newly allocated) 513 SB375 1771 131 (pointer.) 131 SB435 1821 1506 (A constructor's member initializer for a pointer-containing member mustn't refer to other) 1506 SB375 1871 1379 (members of its class, because those members may not be initialized yet. Consider:) 1379 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1944 250 (struct T {) 250 SB525 1989 300 (    int* p1;) 300 SB525 2034 300 (    int* p2;) 300 SB525 2086 775 (    T\(\): p1\(p2\), p2\(p1\) {}; /* ) 775 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1300 2081 382 (error in the safe subset) 382 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1682 2086 75 ( */) 75 SB525 2131 150 (    };) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2203 225 (The member ) 225 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font600 2208 50 (p1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font650 2203 747 ( gets initialized to the uninitialized value of ) 747 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1397 2208 50 (p2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1447 2203 180 (, and then ) 180 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1627 2208 50 (p2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1677 2203 303 ( gets initialized to) 303 SB375 2255 363 (the still uninitialized ) 363 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font738 2260 50 (p1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font788 2255 1207 (. It isn't feasible for compilers to detect all such situations; for example:) 1207 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2330 250 (struct A {) 250 SB525 2375 825 (    virtual char* f\(\) {return 0;}) 825 SB525 2420 400 (    char* g\(\);};) 400 SB525 2510 675 (char* A::g\(\) {return f\(\);};) 675 SB525 2600 325 (struct B: A {) 325 SB525 2645 300 (    char* p;) 300 SB525 2690 825 (    virtual char* f\(\) {return p;}) 825 SB525 2735 500 (    B\(\): p\(g\(\)\) {}};) 500 SB375 2812 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font400 2807 418 ('s member initializer for ) 418 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font818 2812 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font843 2807 99 ( calls ) 99 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font942 2812 150 (A::g\(\)) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1092 2807 224 (, which calls ) 224 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1316 2812 75 (f\(\)) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1391 2807 333 (, which is bound to ) 333 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1724 2812 150 (B::f\(\)) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1874 2807 125 (, which) 125 SB375 2859 418 (returns the uninitialized ) 418 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font793 2864 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font818 2859 11 (.) 11 SB1209 3069 42 (26) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 633 (A member initializer mustn't refer to ) 633 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1068 274 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1168 269 847 (, since it could be passed to a function that returns) 847 SB375 321 425 (an uninitialized member.) 425 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 421 53 (7.4) 53 SB428 421 492 (. Restricting built-in arrays) 492 SB%%BeginResource: font MSTT31c295/GreNewFont{10 dict dup 3 1 roll def dup begin 6 1 roll/FontType 3def/FontMatrix exch def/FontBBox exch def/FontInfo 2 dict def FontInfo/UnderlinePosition 3 -1 roll put FontInfo/UnderlineThickness 3 -1roll put/Encoding 256 array def 0 1 255{Encoding exch/.notdef put}for/CharProcs 256 dict def CharProcs/.notdef{}put/Metrics 256 dict defMetrics/.notdef 3 -1 roll put/BuildChar{/char exch def/fontdict exchdef/charname fontdict/Encoding get char get def fontdict/Metrics getcharname get aload pop setcachedevice fontdict begin Encoding charget CharProcs exch get end exec}def end definefont pop}def/AddChar{beginEncoding 3 1 roll put CharProcs 3 1 roll put Metrics 3 1 roll put end}def/MSTT31c295 [42.0 0 0 0 0 0] 47 -92 [-42.0 -42.0 42.0 42.0] [1 42 div 0 0 1 42 div 0 0] /MSTT31c295 GreNewFont%%EndResource32 0 0 42 42 0 0 1 37 /MSTT31c295 font%%BeginResource: font MSTT31c295/G6f [37.0 0.0 4.0 0.0 34.0 30.0]/G6f {    30 30 true [1 0 0 -1 -4.0 30.0] {<fffffffcfffffffcfffffffcfffffffcf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cfffffffcfffffffcfffffffcfffffffc>} imagemask   }  111 /G6f MSTT31c295 AddChar%%EndResourcegs 412 3231 0 0 CB375 522 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 521 464 (Given a pointer expression ) 464 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font914 526 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font939 521 427 (, expressions of the form ) 427 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1366 526 125 (p + c) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1491 521 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1513 526 125 (p - c) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1638 521 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1660 526 75 (p++) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1735 521 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1757 526 75 (p--) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1832 521 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1854 526 75 (++p) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1929 521 84 (, and) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font450 578 75 (--p) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font525 573 265 ( are disallowed.) 265 SB375 650 788 (We know of no efficient way for ensuring that ) 788 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1163 655 125 (p + c) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1288 650 734 ( results in a legal pointer within the bounds) 734 SB375 702 1575 (of its referent array. Most schemes involve carrying some information along with the pointer,) 1575 SB375 752 1646 (doubling the natural size of the pointer and imposing a cost on every dereference [Steffen 92, Dix) 1646 SB375 802 67 (93].) 67 SB435 852 1452 (Safe arrays provide an adequately expressive replacement for pointer arithmetic. With) 1452 SB375 902 1645 (modern optimizing compilers, pointer arithmetic is no longer necessary to produce efficient code.) 1645 SB375 952 467 (As Stroustrup points out in ) 467 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font842 952 593 (The C++ Programming Language ) 593 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1435 952 569 ([Stroustrup 91, page 93], the only) 569 SB375 1002 1572 (remaining purpose for pointer arithmetic is syntactic conciseness\227programmers like writing) 1572 SB375 1052 1570 (tight little custom loops for scanning strings and copying arrays. But with the introduction of) 1570 SB375 1102 1575 (powerful string and array classes and the use of function inlining, programmers can get more) 1575 SB375 1152 1616 (conciseness \(and often more efficiency\) by using the searching and copying operations provided) 1616 SB375 1202 361 (by those abstractions.) 361 SB435 1252 945 (More than a few C++ enthusiasts will balk at giving up ) 945 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1380 1257 75 (p++) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1455 1252 523 (, but trading a small amount of) 523 SB375 1304 1591 (conciseness for safety is well worth it, at least to any programmer who has spent days tracking) 1591 SB375 1354 450 (down a single storage bug.) 450 SB32 0 0 42 42 0 0 1 37 /MSTT31c295 fontgs 412 3231 0 0 CB375 1455 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1454 413 (Expressions of the form ) 413 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font863 1459 100 (a[i]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font963 1454 265 ( are disallowed.) 265 SB375 1531 838 (Subscripting is equivalent to pointer arithmetic\227) 838 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1213 1536 100 (a[i]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1313 1531 336 ( means the same as ) 336 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1649 1536 200 (*\(a + i\)) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1849 1531 88 (. The) 88 SB375 1583 1053 (standard array classes provide safe array subscripting \(section ) 1053 SB1428 1583 53 (7.8) 53 SB1481 1583 25 (\).) 25 SB32 0 0 42 42 0 0 1 37 /MSTT31c295 fontgs 412 3231 0 0 CB375 1684 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1683 538 (An expression of type \223array of ) 538 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font988 1688 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1013 1683 44 (\224 \() 44 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1057 1688 75 (T[]) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1132 1683 11 ( ) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1143 1688 50 (or) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1193 1683 11 ( ) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1204 1688 100 (T[c]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1304 1683 497 (\) cannot be converted to type ) 497 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1801 1688 50 (T*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1851 1683 11 (.) 11 SB375 1760 1574 (Converting an automatic array to a pointer to its first element could create a dangling pointer) 1574 SB375 1810 944 (after the function defining the array exits. The operator ) 944 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1319 1815 25 (&) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1344 1810 663 ( can be used to take the address of non-) 663 SB375 1862 291 (automatic arrays.) 291 SB32 0 0 42 42 0 0 1 37 /MSTT31c295 fontgs 412 3231 0 0 CB375 1963 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1962 470 (A formal parameter of type ) 470 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font920 1967 75 (T[]) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font995 1962 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1017 1967 100 (T[c]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1117 1962 68 (, or ) 68 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1185 1967 150 (T\(&\)[]) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1335 1962 676 ( cannot be initialized with an argument,) 676 SB450 2014 1121 (unless the argument is a string literal. A formal parameter of type ) 1121 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1571 2019 175 (T\(&\)[c]) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1746 2014 119 ( can be) 119 SB450 2066 701 (initialized only with an argument of type ) 701 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1151 2071 100 (T[c]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1251 2066 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1308 2071 175 (T\(&\)[c]) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1483 2066 11 (.) 11 SB375 2143 1188 (In general, there is no safe use of a formal parameter of type \223array of ) 1188 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1563 2148 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1588 2143 415 (\224, since the length of the) 415 SB375 2195 1561 (actual argument isn't supplied and needn't match the size of the formal. An argument can be) 1561 SB375 2245 551 (passed safely to a formal of type ) 551 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font926 2250 175 (T\(&\)[c]) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1101 2245 875 ( \(a reference to an array with known size\), since the) 875 SB375 2297 1613 (language requires the argument to be an array of the same size. \(This contrasts with a formal of) 1613 SB375 2347 81 (type ) 81 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font456 2352 100 (T[c]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font556 2347 1050 (, which can be initialized with an array argument of any size.\)) 1050 SB435 2399 1155 (The one exception for string literals allows the standard string class ) 1155 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1590 2404 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1690 2399 288 ( to provide a safe) 288 SB375 2451 200 (constructor ) 200 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font575 2456 500 (Text\(const char s[]\)) 500 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1075 2451 518 ( that converts string literals to ) 518 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1593 2456 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1693 2451 328 (s. The constructor's) 328 SB375 2503 1628 (interface is safe, meaning its use by clients can't violate safety, but it must be implemented using) 1628 SB375 2553 1120 (unsafe language features \(the constructor uses the unsafe function ) 1120 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1495 2558 150 (strlen) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1645 2553 318 ( to find the string's) 318 SB375 2605 132 (length\).) 132 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2705 53 (7.5) 53 SB428 2705 762 (. Preventing fabrication of invalid pointers) 762 SB32 0 0 42 42 0 0 1 37 /MSTT31c295 fontgs 412 3231 0 0 CB375 2806 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2805 1484 (All casts to types containing pointers, references, or functions are disallowed, except for) 1484 SB450 2855 1004 (widening casts and checked narrowing casts. Given a class ) 1004 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1454 2860 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1479 2855 331 ( derived from class ) 331 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1810 2860 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1835 2855 156 (, a cast is) 156 SB450 2907 423 (widening if it casts from ) 423 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font873 2912 50 (B*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font923 2907 54 ( to ) 54 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font977 2912 50 (A*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1027 2907 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1049 2912 50 (B*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1099 2907 54 ( to ) 54 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1153 2912 50 (B*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1203 2907 68 (, or ) 68 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1271 2912 50 (B*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1321 2907 54 ( to ) 54 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1375 2912 125 (void*) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1500 2907 506 (; a cast is narrowing if it casts) 506 SB1209 3069 42 (27) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC450 269 92 (from ) 92 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font542 274 50 (A*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font592 269 54 ( to ) 54 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font646 274 50 (B*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font696 269 1322 (. As in general with C++, two types are considered the same here if they differ) 1322 SB450 321 339 (only in instances of ) 339 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font789 326 125 (const) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font914 321 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font936 326 200 (volatile) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1136 321 68 (, or ) 68 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1204 326 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1254 321 739 (. To be considered a widening or narrowing) 739 SB450 373 1264 (cast, the class types involved must be fully declared at the point of the cast.) 1264 SB375 448 1574 (We assume the ANSI C++ committee will soon adopt a proposal for checked narrowing casts) 1574 SB375 498 715 ([Stroustrup 92], which can't violate safety.) 715 SB435 548 1573 (Casts that fabricate pointers or references to non-existent objects must be disallowed. Casting) 1573 SB375 598 1568 (to a function type can create a function that does an implicit disallowed cast; for example, on) 1568 SB375 648 1423 (machines where pointers and integers have the same size, casting a function of type ) 1423 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1798 653 100 (void) 100 SB375 705 150 (\(int*\)) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font525 700 54 ( to ) 54 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font579 705 250 (void \(int\)) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font829 700 976 ( creates a function that implicitly casts its argument from ) 976 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1805 705 75 (int) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1880 700 43 ( to) 43 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 757 100 (int*) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font475 752 11 (.) 11 SB%%BeginResource: font MSTT31c295/GreNewFont{10 dict dup 3 1 roll def dup begin 6 1 roll/FontType 3def/FontMatrix exch def/FontBBox exch def/FontInfo 2 dict def FontInfo/UnderlinePosition 3 -1 roll put FontInfo/UnderlineThickness 3 -1roll put/Encoding 256 array def 0 1 255{Encoding exch/.notdef put}for/CharProcs 256 dict def CharProcs/.notdef{}put/Metrics 256 dict defMetrics/.notdef 3 -1 roll put/BuildChar{/char exch def/fontdict exchdef/charname fontdict/Encoding get char get def fontdict/Metrics getcharname get aload pop setcachedevice fontdict begin Encoding charget CharProcs exch get end exec}def end definefont pop}def/AddChar{beginEncoding 3 1 roll put CharProcs 3 1 roll put Metrics 3 1 roll put end}def/MSTT31c295 [42.0 0 0 0 0 0] 47 -92 [-42.0 -42.0 42.0 42.0] [1 42 div 0 0 1 42 div 0 0] /MSTT31c295 GreNewFont%%EndResource32 0 0 42 42 0 0 1 37 /MSTT31c295 font%%BeginResource: font MSTT31c295/G6f [37.0 0.0 4.0 0.0 34.0 30.0]/G6f {    30 30 true [1 0 0 -1 -4.0 30.0] {<fffffffcfffffffcfffffffcfffffffcf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cfffffffcfffffffcfffffffcfffffffc>} imagemask   }  111 /G6f MSTT31c295 AddChar%%EndResourcegs 412 3231 0 0 CB375 855 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 854 1510 (The declaration of union types containing pointers, references, or functions is disallowed.) 1510 SB375 929 1542 (C++ unions are untagged, leaving no efficient way for implementations to effectively check) 1542 SB375 979 1579 (which variant of a union variable is currently being used. Without run-time checking the type) 1579 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1034 425 (union {S s; T t;}) 425 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font800 1029 962 ( could be used to arbitrarily cast from a non-pointer type ) 962 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1762 1034 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1787 1029 204 ( to a pointer) 204 SB375 1081 81 (type ) 81 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font456 1086 25 (S) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font481 1081 460 (. As discussed in appendix ) 460 SB941 1081 27 (B) 27 SB968 1081 1047 (, it isn't feasible to have compilers add implicit tags to unions.) 1047 SB435 1133 1489 (Class derivation provides a better alternative to many uses of unions, without sacrificing) 1489 SB375 1183 1619 (either time or space efficiency. Untagged pointer-containing unions remain most useful for low-) 1619 SB375 1233 1617 (level systems code and applications that must deal with predefined structure formats; even here,) 1617 SB375 1283 1588 (the use of such unions can usually be hidden behind a safe interface \(whose implementation is) 1588 SB375 1333 730 (declared unsafe\) [Stroustrup 91, page 169].) 730 SB32 0 0 42 42 0 0 1 37 /MSTT31c295 fontgs 412 3231 0 0 CB375 1434 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1433 221 (Overloading ) 221 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font671 1438 300 (operator new) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font971 1433 923 (, either globally or for particular classes, is disallowed.) 923 SB375 1510 357 (When an overridden ) 357 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font732 1515 300 (operator new) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1032 1510 934 ( is invoked, the language does an implicit cast from the) 934 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1567 125 (void*) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font500 1562 250 ( return type of ) 250 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font750 1567 300 (operator new) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1050 1562 592 ( to the argument type of the call to ) 592 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1642 1567 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1717 1562 275 (. Nothing would) 275 SB375 1614 280 (prevent a buggy ) 280 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font655 1619 300 (operator new) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font955 1614 983 ( from implicitly casting the result from one pointer type to) 983 SB375 1666 1532 (another, violating safety. We know no practical method for ensuring the safety of that cast.) 1532 SB435 1716 629 (Safe code has no need for overriding ) 629 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1064 1721 300 (operator new) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1364 1716 651 (, since the safe subset must necessarily) 651 SB375 1768 1224 (use garbage collection to enforce safety. The language interface \(section ) 1224 SB1599 1768 53 (4.1) 53 SB1652 1768 178 (\) prevents ) 178 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1830 1773 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1880 1768 126 ( classes) 126 SB375 1820 425 (from overriding a class's ) 425 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font800 1825 300 (operator new) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1100 1820 11 (.) 11 SB32 0 0 42 42 0 0 1 37 /MSTT31c295 fontgs 412 3231 0 0 CB375 1923 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1922 560 (Functions declared with ellipsis \() 560 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1010 1927 150 (f\(...\)) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1160 1922 279 (\) are disallowed.) 279 SB375 1999 1650 (Functions with varying numbers of arguments are unsafe, since the function relies on the caller to) 1650 SB375 2049 1554 (follow whatever convention is established to signal the number of arguments; a buggy caller) 1554 SB375 2099 1644 (could cause unpredictable results in the function as it tried to access its arguments. And using the) 1644 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2154 150 (va_arg) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font525 2149 826 ( macro would, in general, require unsafe casting.) 826 SB435 2201 967 (The most common use of variadic functions is to call C's ) 967 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1402 2206 150 (printf) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1552 2201 346 ( and friends. But the) 346 SB375 2253 1609 (standard C++ stream library provides an adequately concise and efficient replacement. Further,) 1609 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2308 150 (printf) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font525 2303 1282 (-style formatting strings could be added easily to C++ streams; for example:) 1282 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2378 975 (cout\("i = %3d  x = %7.3f\\n"\) << i << x;) 975 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2450 1629 (Default arguments and function overloading subsume most other uses of variadic functions in C.) 1629 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2550 53 (7.6) 53 SB428 2550 816 (. Preventing dangling pointers and references) 816 SB32 0 0 42 42 0 0 1 37 /MSTT31c295 fontgs 412 3231 0 0 CB375 2651 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2650 228 (The operator ) 228 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font678 2655 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font828 2650 801 ( and explicit calls to destructors are disallowed.) 801 SB375 2727 192 (Obviously, ) 192 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font567 2732 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font717 2727 1307 ( can cause dangling pointers and references, and we know of no way to check) 1307 SB375 2779 1548 (for dangling pointers that doesn't involve increasing the size of pointers and checking every) 1548 SB375 2829 1115 (pointer dereference at run-time. In effect, garbage collection calls ) 1115 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1490 2834 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1640 2829 341 ( automatically when) 341 SB375 2881 551 (an object is no longer accessible.) 551 SB1209 3069 42 (28) 42 SBEJ RS%%PageTrailerSVDoc restore /SVDoc save defSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font435 269 1472 (Informally, destructors turn objects into \223raw memory\224. Accessing a destroyed object is) 1472 SB375 319 1583 (explicitly undefined by the language, and there is no way to ensure such accesses don't violate) 1583 SB375 369 990 (GC-safety without referring to particular implementations.) 990 SB%%BeginResource: font MSTT31c295/GreNewFont{10 dict dup 3 1 roll def dup begin 6 1 roll/FontType 3def/FontMatrix exch def/FontBBox exch def/FontInfo 2 dict def FontInfo/UnderlinePosition 3 -1 roll put FontInfo/UnderlineThickness 3 -1roll put/Encoding 256 array def 0 1 255{Encoding exch/.notdef put}for/CharProcs 256 dict def CharProcs/.notdef{}put/Metrics 256 dict defMetrics/.notdef 3 -1 roll put/BuildChar{/char exch def/fontdict exchdef/charname fontdict/Encoding get char get def fontdict/Metrics getcharname get aload pop setcachedevice fontdict begin Encoding charget CharProcs exch get end exec}def end definefont pop}def/AddChar{beginEncoding 3 1 roll put CharProcs 3 1 roll put Metrics 3 1 roll put end}def/MSTT31c295 [42.0 0 0 0 0 0] 47 -92 [-42.0 -42.0 42.0 42.0] [1 42 div 0 0 1 42 div 0 0] /MSTT31c295 GreNewFont%%EndResource32 0 0 42 42 0 0 1 37 /MSTT31c295 font%%BeginResource: font MSTT31c295/G6f [37.0 0.0 4.0 0.0 34.0 30.0]/G6f {    30 30 true [1 0 0 -1 -4.0 30.0] {<fffffffcfffffffcfffffffcfffffffcf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cfffffffcfffffffcfffffffcfffffffc>} imagemask   }  111 /G6f MSTT31c295 AddChar%%EndResourcegs 412 3231 0 0 CB375 470 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 469 957 (Static and run-time checks ensure that in the expression ) 957 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1407 474 50 (&e) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1457 469 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1479 474 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1504 469 376 ( is not the lvalue of an) 376 SB450 521 323 (automatic variable.) 323 SB375 596 1618 (Taking the address of an automatic variable would leave the resulting pointer dangling after the) 1618 SB375 646 411 (variable's function exits.) 411 SB435 696 963 (The compiler can detect statically most improper uses of ) 963 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1398 701 50 (&e) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1448 696 241 (. Specifically, ) 241 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1689 701 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1714 696 236 ( cannot be the) 236 SB375 748 569 (lvalue of an automatic variable if:) 569 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 828 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 823 1395 ( is a static variable, possibly followed by one or more applications of the operator \223) 1395 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1945 828 25 (.) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1970 823 31 (\224;) 31 SB600 875 35 (or) 35 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 930 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 925 934 ( is formed by one or more applications of the operators ) 934 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1484 930 25 (*) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1509 925 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1593 930 50 (->) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1643 925 58 (; or) 58 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 982 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 977 1293 ( is a reference initialized to an lvalue known not to be an automatic variable.) 1293 SB375 1054 1610 (The second rule follows from the invariant enforced by the safe subset: pointers never reference) 1610 SB375 1104 1108 (automatic variables. In all other cases, the compiler must assume ) 1108 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1483 1109 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1508 1104 381 ( could be an automatic) 381 SB375 1156 1086 (variable's lvalue and generate a run-time check. For example, if ) 1086 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1461 1161 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1486 1156 360 ( is a reference-valued) 360 SB375 1208 1338 (parameter or function-call result, it might well reference an automatic variable.) 1338 SB435 1258 1521 (Checking if a pointer addresses an automatic variable is equivalent to checking if it points) 1521 SB375 1308 1616 (into a thread stack, and that check is fairly cheap. In most Unix implementations, the stacks are) 1616 SB375 1358 1585 (allocated from a dedicated virtual-memory segment with statically known bounds. Testing the) 1585 SB375 1408 1562 (address against those bounds involves two comparisons, which would take four cycles on the) 1562 SB375 1458 441 (MIPS R3000 architecture.) 441 SB435 1508 1499 (Even in implementations where stacks are intermingled with the heaps, the check can be) 1499 SB375 1558 1579 (implemented cheaply. To support conservative scanning of the stacks and registers, collectors) 1579 SB375 1608 1603 (typically use a \223page table\224 of some sort that tracks which pages are allocated to the heap. This) 1603 SB375 1658 1628 (same table could also record which pages are allocated to stacks. The run-time check can extract) 1628 SB375 1708 1577 (the page index from the address and look it up in the table. This test would take about 7 to 10) 1577 SB375 1758 1557 (cycles on the MIPS architecture, depending on whether the operating system allows the data) 1557 SB375 1808 1272 (segment to be very sparse. \(Sparse data segments require a two-level table.\)) 1272 SB435 1858 974 (But note that in practice, the great majority of uses of the ) 974 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1409 1863 25 (&) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1434 1858 536 ( operator will not require a run-) 536 SB375 1910 1287 (time check, so the actual overhead of the run-time check will be quite small.) 1287 SB32 0 0 42 42 0 0 1 37 /MSTT31c295 fontgs 412 3231 0 0 CB375 2011 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2010 1301 (Static and run-time checks ensure that any references in an object created by ) 1301 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1751 2015 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1826 2010 128 ( are not) 128 SB450 2062 600 (initialized to an automatic variable.) 600 SB375 2137 1597 (Storing a reference to an automatic variable in a heap object would create a dangling reference) 1597 SB375 2187 1467 (after the variable's function exits. Using the same static and run-time checks as for the ) 1467 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1842 2192 25 (&) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2239 1554 (operator, the compiler must ensure the initializing expressions of all references in the newly) 1554 SB375 2289 1636 (created object don't refer to an automatic variable. In practice, heap objects containing references) 1636 SB375 2339 1510 (are not common, and of those, most are initialized with expressions that the compiler can) 1510 SB375 2389 1561 (statically determine are not automatic lvalues. Thus, the overhead of the checks will be quite) 1561 SB375 2439 103 (small.) 103 SB32 0 0 42 42 0 0 1 37 /MSTT31c295 fontgs 412 3231 0 0 CB375 2540 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2539 38 (If ) 38 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font488 2544 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font588 2539 725 ( is used explicitly and is not an operand of ) 725 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1313 2544 50 (->) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1363 2539 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1420 2544 25 (*) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1445 2539 565 (, a run-time check ensures it does) 565 SB450 2591 580 (not point at an automatic variable.) 580 SB375 2666 985 (When a member function of an automatic object is called, ) 985 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1360 2671 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1460 2666 543 ( gets bound to the address of the) 543 SB375 2718 506 (variable on the stack. Storing ) 506 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font881 2723 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font981 2718 957 ( in another variable, returning it, or passing it to another) 957 SB375 2770 1271 (function might then create a dangling pointer. The run-time check ensures ) 1271 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1646 2775 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1746 2770 245 ( cannot escape) 245 SB375 2822 596 (outside of its scope. Implicit use of ) 596 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font971 2827 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1071 2822 517 ( to access members and use of ) 517 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1588 2827 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1688 2822 300 ( as an operand of ) 300 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1988 2827 25 (*) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2874 46 (or ) 46 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font421 2879 50 (->) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font471 2874 830 ( are not restricted and require no run-time check.) 830 SB1209 3069 42 (29) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 313 (The restriction on ) 313 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font748 274 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font848 269 1148 ( will not significantly affect the expressiveness of C++. The referent) 1148 SB375 321 44 (of ) 44 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font419 326 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font519 321 656 ( can be passed efficiently to a function ) 656 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1175 326 25 (f) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1200 321 228 ( by reference:) 228 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 396 325 (void f\(T& t\);) 325 SB525 486 225 (class T {) 225 SB525 531 775 (    m\(\) {...f\(*this\)...}; ...};) 775 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 603 772 (Note that this use requires no run-time check.) 772 SB435 653 136 (Storing ) 136 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font571 658 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font671 653 1250 ( in a static or heap object is a useful technique for managing lists of active) 1250 SB375 705 1628 (objects, and the safe subset requires such objects to be allocated in the heap. Programmers might) 1628 SB375 755 1501 (object to this requirement, thinking that their particular objects might be more efficiently) 1501 SB375 805 1532 (allocated on the stack. But in practice, when a class maintains active lists of its objects, the) 1532 SB375 855 1632 (objects tend to be long-lived, and the performance penalty for allocating them in the heap is very) 1632 SB375 905 628 (small relative to total execution time.) 628 SB435 955 387 (The run-time check of ) 387 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font822 960 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font922 955 573 ( is the same as the check used for ) 573 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1495 960 25 (&) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1520 955 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1604 960 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1679 955 281 (. We can make a) 281 SB375 1007 825 (crude estimate of the overall cost of the check of ) 825 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1200 1012 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1300 1007 713 (. A good RISC calling sequence consumes) 713 SB375 1059 1616 (about 10% of total execution time, and on the MIPS, the average call takes about 8 instructions,) 1616 SB375 1109 760 (about twice the cost of the run-time check of ) 760 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1135 1114 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1235 1109 785 (. If 1/10 of all calls make explicit references to) 785 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1166 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font475 1161 1455 ( requiring checks, then the checks will increase total execution time by about 0.5%. In) 1455 SB375 1213 1533 (practice, far fewer than 1/10 of all function calls in an average program will make checked) 1533 SB375 1263 225 (references to ) 225 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font600 1268 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font700 1263 11 (.) 11 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1365 53 (7.7) 53 SB428 1365 405 (. Compiler restrictions) 405 SB%%BeginResource: font MSTT31c295/GreNewFont{10 dict dup 3 1 roll def dup begin 6 1 roll/FontType 3def/FontMatrix exch def/FontBBox exch def/FontInfo 2 dict def FontInfo/UnderlinePosition 3 -1 roll put FontInfo/UnderlineThickness 3 -1roll put/Encoding 256 array def 0 1 255{Encoding exch/.notdef put}for/CharProcs 256 dict def CharProcs/.notdef{}put/Metrics 256 dict defMetrics/.notdef 3 -1 roll put/BuildChar{/char exch def/fontdict exchdef/charname fontdict/Encoding get char get def fontdict/Metrics getcharname get aload pop setcachedevice fontdict begin Encoding charget CharProcs exch get end exec}def end definefont pop}def/AddChar{beginEncoding 3 1 roll put CharProcs 3 1 roll put Metrics 3 1 roll put end}def/MSTT31c295 [42.0 0 0 0 0 0] 47 -92 [-42.0 -42.0 42.0 42.0] [1 42 div 0 0 1 42 div 0 0] /MSTT31c295 GreNewFont%%EndResource32 0 0 42 42 0 0 1 37 /MSTT31c295 font%%BeginResource: font MSTT31c295/G6f [37.0 0.0 4.0 0.0 34.0 30.0]/G6f {    30 30 true [1 0 0 -1 -4.0 30.0] {<fffffffcfffffffcfffffffcfffffffcf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cf000003cfffffffcfffffffcfffffffcfffffffc>} imagemask   }  111 /G6f MSTT31c295 AddChar%%EndResourcegs 412 3231 0 0 CB375 1466 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1465 1516 (If a temporary object is created anywhere within the initializing expression of a reference,) 1516 SB450 1515 1494 (the temporary's storage must not be reused until the block containing the initialization is) 1494 SB450 1565 113 (exited.) 113 SB375 1640 1630 (This restriction on the compiler prevents dangling references to temporary objects. Consider this) 1630 SB375 1690 154 (example:) 154 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1763 475 (    struct T {...};) 475 SB525 1808 650 (    T& f\(T& t\) {return t;}) 650 SB525 1853 450 (    T& t = f\(T\(\)\);) 450 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1925 829 (A temporary object is created as the argument to ) 829 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1204 1930 25 (f) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1229 1925 781 (. If the compiler destroys the temporary before) 781 SB375 1977 492 (the block containing it exits, ) 492 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font867 1982 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font892 1977 661 ( would be left dangling. But as long as ) 661 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1553 1982 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1578 1977 418 ('s destructor is written in) 418 SB375 2029 1609 (the safe subset and the compiler doesn't reuse the temporary's storage until the block exits, then) 1609 SB375 2079 1351 (the temporary object will continue to contain valid pointers and it's use through ) 1351 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1726 2084 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1751 2079 269 ( couldn't violate) 269 SB375 2131 108 (safety.) 108 SB435 2181 1073 (This restriction may already be required by the C++ definition. ) 1073 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1508 2181 343 (The Annotated C++) 343 SB375 2231 312 (Reference Manual) 312 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font687 2231 1318 ( says only that \223If a reference is bound to a temporary, the temporary must not) 1318 SB375 2281 1593 (be destroyed until the reference is\224 \(12.2\). Do the authors intend this to apply to examples like) 1593 SB375 2331 1622 (that above, where the compiler doesn't know whether the result of an initializing function call is) 1622 SB375 2381 331 (a temporary or not?) 331 SB435 2431 1583 (The ANSI committee is trying to define exactly when temporaries should be destroyed, but no) 1583 SB375 2481 1638 (matter what they decide and no matter what the current interpretation of the reference manual is,) 1638 SB375 2531 1592 (this implementation restriction will be compatible and will ensure that GC-safety is preserved.) 1592 SB375 2581 1316 (It's trivial for compilers to implement\227at least some already behave this way.) 1316 SB32 0 0 42 42 0 0 1 37 /MSTT31c295 fontgs 412 3231 0 0 CB375 2682 37 (o) 37 SBgr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2681 761 (Arrays of pointers must be initialized to null.) 761 SB375 2756 1636 (C++ provides no general method to initialize arrays of pointers that can be easily enforced by the) 1636 SB375 2806 1586 (safe subset. Consider a class containing an array of pointers\227the lack of general array-valued) 1586 SB375 2856 1649 (expressions means that the array cannot be initialized by a constructor's member initializer. Since) 1649 SB375 2906 1618 (there is no easy way for the compiler to ensure that the programmer has initialized an array, the) 1618 SB1209 3069 42 (30) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 1573 (only alternative is to have the compiler generate code that initializes to null all pointer arrays) 1573 SB375 319 1629 (created in safe blocks. A pointer array contained within an automatic variable must be zeroed on) 1629 SB375 369 1457 (entry to the variable's block, and a pointer array contained within an object created by ) 1457 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1832 374 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1907 369 93 ( must) 93 SB375 421 221 (be zeroed by ) 221 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font596 426 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font671 421 1085 (. \(The language already ensures that static variables are zeroed.\)) 1085 SB435 473 1475 (Requiring compilers to initialize pointer arrays is allowed by the C++ definition, which) 1475 SB375 523 1046 (merely states that the initial values of variables are undefined.) 1046 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 623 53 (7.8) 53 SB428 623 227 (. Safe arrays) 227 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 698 1644 (Safe arrays are provided by three standard template classes defining arrays of fixed size, arrays of) 1644 SB375 748 1640 (varying size allocated in the heap, and sub-arrays of the first two kinds. The overloaded subscript) 1640 SB375 798 1620 (operator of these classes checks at run-time that its index is within bounds, signaling a run-time) 1620 SB375 848 1566 (error if not. The interface to these classes is declared safe, meaning any use by clients cannot) 1566 SB375 898 1464 (violate safety, but their implementations must use unsafe language features. Appendix ) 1464 SB1839 898 28 (C) 28 SB1867 898 154 ( provides) 154 SB375 948 892 (a completely specified interface and implementation.) 892 SB435 998 1555 (These classes are intended to provide a safe, efficient alternative to the basic functionality of) 1555 SB375 1048 1552 (built-in C++ arrays, not the full generality of higher-level array abstractions. They would be) 1552 SB375 1098 1594 (specified and included as part of the standard classes available with any implementation of the) 1594 SB375 1148 1629 (safe subset. Programmers wanting to build their own flavor of safe arrays can use these both as a) 1629 SB375 1198 504 (model and as building blocks.) 504 SB435 1248 63 (An ) 63 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font498 1253 275 (Array<T, n>) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font773 1248 244 ( is an array of ) 244 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1017 1253 25 (n) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1042 1248 296 ( elements of type ) 296 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1338 1253 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1363 1248 656 ( that behaves like a built-in C++ array.) 656 SB375 1300 222 (For example,) 222 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1373 425 (Array<int, 10> a;) 425 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1445 148 (declares ) 148 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font523 1450 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font548 1445 506 ( to be an array of 10 integers, ) 506 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1054 1450 100 (a[0]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1154 1445 155 ( through ) 155 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1309 1450 100 (a[9]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1409 1445 85 (. An ) 85 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1494 1450 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1619 1445 347 ( is represented using) 347 SB375 1497 466 (the built-in C++ array type:) 466 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1570 950 (template<class T, int n> class Array {) 950 SB525 1615 275 (    T a[n];) 275 SB525 1660 225 (    ...};) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1732 294 (A dynamic array ) 294 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font669 1737 275 (DynArray<T>) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font944 1732 967 ( is a pointer to a heap-allocated array of elements of type ) 967 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1911 1737 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1784 1025 (whose size is chosen when the array is created. For example,) 1025 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1857 525 (DynArray<int> d1, d2;) 525 SB525 1902 75 (...) 75 SB525 1947 600 (d1 = DynArray<int>\(100\);) 600 SB525 1992 600 (d2 = DynArray<int>\(200\);) 600 SB375 2069 50 (d1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font425 2064 584 ( refers to an array of 100 integers, ) 584 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1009 2069 100 (d[0]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1109 2064 155 ( through ) 155 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1264 2069 125 (d[99]) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1389 2064 63 (. A ) 63 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1452 2069 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1652 2064 320 ( is represented as a) 320 SB375 2116 671 (single pointer to a heap-allocated array:) 671 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2189 850 (template<class T> class DynArray {) 850 SB525 2234 225 (    T* a;) 225 SB525 2279 225 (    ...};) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2351 227 (The size of a ) 227 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font602 2356 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font802 2351 213 ( is stored by ) 213 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1015 2356 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1090 2351 258 ( with the array.) 258 SB435 2403 41 (A ) 41 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font476 2408 275 (SubArray<T>) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font751 2403 1024 ( acts as a reference to a sub-sequence of elements in another ) 1024 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1775 2408 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1900 2403 11 (,) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2460 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font575 2455 68 (, or ) 68 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font643 2460 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font843 2455 22 (. ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font865 2460 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1065 2455 460 (s are constructed using the ) 460 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1525 2460 75 (Sub) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1600 2455 356 ( methods of the three) 356 SB375 2507 406 (classes. For example, if ) 406 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font781 2512 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font806 2507 102 ( is an ) 102 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font908 2512 275 (Array<T, n>) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1183 2507 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1205 2512 275 (SubArray<T>) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1480 2507 68 (, or ) 68 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1548 2512 275 (DynArray<T>) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1823 2507 96 (, then) 96 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2582 900 (SubArray<T> s = a.Sub\(start, length\)) 900 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2654 177 (initializes ) 177 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font552 2659 25 (s) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font577 2654 506 ( to be a sub-array of elements ) 506 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1083 2659 200 (a[start]) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1283 2654 155 ( through ) 155 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1438 2659 525 (a[start + length - 1]) 525 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1963 2654 11 (.) 11 SB375 2706 281 (The elements of ) 281 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font656 2711 25 (s) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font681 2706 597 ( share storage with the elements of ) 597 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1278 2711 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1303 2706 149 (; that is, ) 149 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1452 2711 100 (s[i]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1552 2706 358 ( is the same lvalue as) 358 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2763 300 (a[start + i]) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font675 2758 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font435 2815 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font635 2810 1315 (s can be used to pass varying-sized arrays by reference. Consider this function) 1315 SB375 2862 200 (declaration:) 200 SB1209 3069 42 (31) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font0 0 0 fC525 267 600 (void F\(SubArray<int> s\);) 600 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 339 175 (Callers of ) 175 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font550 344 25 (F) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font575 339 216 ( can pass an ) 216 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font791 344 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font916 339 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font938 344 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1138 339 68 (, or ) 68 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1206 344 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1406 339 54 ( to ) 54 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1460 344 25 (F) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1485 339 462 (, and the formal parameter ) 462 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1947 344 25 (s) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 391 1530 (will reference the elements of the actual parameter. The run-time checking of these classes) 1530 SB375 441 197 (ensure that ) 197 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font572 446 25 (F) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font597 441 1008 ( cannot index non-existent elements of its actual parameter.) 1008 SB435 493 299 (For convenience, ) 299 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font734 498 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font859 493 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font943 498 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1143 493 506 ( define default conversions to ) 506 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1649 498 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1849 493 80 (. For) 80 SB375 545 268 (example, given ) 268 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font643 550 400 (Array<int, 10> a) 400 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1043 545 107 (, then ) 107 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1150 550 100 (F\(a\)) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1250 545 279 ( is equivalent to ) 279 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1529 550 350 (F\(a.Sub\(0, 9\)\)) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1879 545 11 (.) 11 SB435 597 41 (A ) 41 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font476 602 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font676 597 973 ( is represented as a reference to its elements and a length:) 973 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 672 700 (template<class T> SubArray {) 700 SB525 717 325 (    T \(&t\)[];) 325 SB525 762 375 (    int number;) 375 SB525 807 225 (    ...};) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 879 1113 (The array classes support several common operations on an array ) 1113 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1488 884 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1513 879 23 ( :) 23 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 961 100 (a[i]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font625 956 224 ( accesses the ) 224 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font849 961 25 (i) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font874 956 247 (-th element of ) 247 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1121 961 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1146 956 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1038 250 (a.Number\(\)) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font775 1033 593 ( returns the number of elements in ) 593 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1368 1038 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1393 1033 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1115 500 (a.Sub\(start, length\)) 500 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1025 1110 168 ( creates a ) 168 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1193 1115 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1393 1110 374 ( referencing elements ) 374 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1767 1115 200 (a[start]) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font525 1162 144 (through ) 144 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font669 1167 525 (a[start + length - 1]) 525 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1194 1162 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1244 225 (a.Copy\(s\)) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font750 1239 394 ( copies the elements of ) 394 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1144 1244 250 (SubArray s) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1394 1239 355 ( into the elements of ) 355 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1749 1244 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1774 1239 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1321 150 (a == s) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font675 1316 254 ( returns true if ) 254 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font929 1321 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font954 1316 147 ( and the ) 147 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1101 1321 250 (SubArray s) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1351 1316 653 ( refer to the same element lvalues, that) 653 SB525 1368 86 (is, if ) 86 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font611 1373 600 (a.Number\(\) == s.Number\(\)) 600 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1211 1368 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1295 1373 350 (&a[0] == &s[0]) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1645 1368 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1450 250 (a.Equal\(s\)) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font775 1445 254 ( returns true if ) 254 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1029 1450 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1054 1445 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1138 1450 250 (SubArray s) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1388 1445 560 ( are the same size and all of their) 560 SB525 1497 428 (elements are equal using ) 428 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font953 1502 200 (operator) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1153 1497 11 ( ) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1164 1502 75 (==.) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1574 1545 (The operations check their arguments at run-time, preventing out-of-bounds array accesses.) 1545 SB435 1624 77 (The ) 77 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font512 1629 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font637 1624 213 ( assignment ) 213 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font850 1629 175 (a1 = a2) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1025 1624 394 ( copies the elements of ) 394 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1419 1629 50 (a2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1469 1624 88 ( into ) 88 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1557 1629 50 (a1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1607 1624 22 (. ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1629 1629 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1829 1624 150 (s act like) 150 SB375 1676 268 (pointers, so the ) 268 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font643 1681 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font843 1676 213 ( assignment ) 213 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1056 1681 175 (d1 = d2) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1231 1676 129 ( makes ) 129 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1360 1681 50 (d1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1410 1676 543 ( reference the same elements as ) 543 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1953 1681 50 (d2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font2003 1676 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1733 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font575 1728 1446 (s act like references and thus can't be assigned. The elements of all three kinds can be) 1446 SB375 1780 388 (copied en masse using ) 388 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font763 1785 100 (Copy) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font863 1780 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font435 1837 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font560 1832 1087 (s can be nested to create multi-dimensional arrays. For example,) 1087 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1907 650 (Array<Array<int, 3>, 2> a;) 650 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1979 993 (declares a 2 x 3 array of integers, similar to the C++ array ) 993 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1368 1984 275 (int a[2][3]) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1643 1979 22 (. ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1665 1984 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1790 1979 135 (s can be) 135 SB375 2031 230 (nested inside ) 230 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font605 2036 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font805 2031 100 (s and ) 100 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font905 2036 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1105 2031 28 (s:) 28 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2106 750 (DynArray<Array<int, 3> > d\(5\);) 750 SB525 2151 1025 (SubArray<Array<int, 3> > s = d.Sub\(3, 2\);) 1025 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2223 264 (This initializes ) 264 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font639 2228 25 (d) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font664 2223 351 ( to a 5 x 3 array and ) 351 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1015 2228 25 (s) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1040 2223 601 ( to be a 2 x 3 sub-array referencing ) 601 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1641 2228 175 (d[3][0]) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1816 2223 44 ( ...) 44 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2280 175 (d[4][2]) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 2275 11 (.) 11 SB435 2327 1369 (The array classes provide no direct method for statically initializing an array, but) 1369 SB375 2377 439 (programmers can declare ) 439 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font814 2382 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1014 2377 620 (s of initialized C++ arrays using the ) 620 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1634 2382 75 (SUB) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1709 2377 128 ( macro:) 128 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2452 850 (static int a[] = {55, 66, 73, 99};) 850 SB525 2497 750 (SubArray<int> s = SUB\(int, a\);) 750 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2569 77 (The ) 77 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font452 2574 250 (SubArray s) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font702 2569 481 ( refers to all the elements of ) 481 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1183 2574 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1208 2569 99 (. The ) 99 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1307 2574 75 (SUB) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1382 2569 484 ( macro expands to a call of a) 484 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2626 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font575 2621 653 ( constructor and its use is always safe. ) 653 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1228 2626 100 (SUB2) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1328 2621 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1350 2626 100 (SUB3) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1450 2621 95 (, and ) 95 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1545 2626 100 (SUB4) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1645 2621 348 ( can be used for two,) 348 SB375 2673 595 (three, and four-dimensional arrays.) 595 SB435 2723 1504 (In general, these safe array classes provide fully functional replacements for built-in C++) 1504 SB375 2773 273 (arrays. Further, ) 273 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font648 2778 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font848 2773 351 (s combined with the ) 351 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1199 2778 100 (Copy) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1299 2773 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1383 2778 125 (Equal) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1508 2773 468 ( methods provide extremely) 468 SB375 2825 1506 (concise, efficient notations for copying and comparing arrays, mostly eliminating the one) 1506 SB1209 3069 42 (32) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 1515 (remaining reason some programmers think they \223need\224 pointer arithmetic. \(With modern) 1515 SB375 319 1261 (compilers, pointer arithmetic is irrelevant for producing good object code.\)) 1261 SB435 369 1047 (When these classes are used with a good compiler like DEC's ) 1047 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1482 369 57 (cxx) 57 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1539 369 348 (, the only significant) 348 SB375 419 1640 (overhead relative to built-in arrays comes from the index checks, which of course can be disabled) 1640 SB375 469 1601 (with a compile-time switch. The classes impose no overhead on modern optimizers, since their) 1601 SB375 519 1468 (overloaded operators expand inline to use the built-in operators. For example, given an) 1468 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 574 400 (Array<int, 10> a) 400 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font775 569 275 (, the expression ) 275 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1050 574 100 (a[i]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1150 569 584 ( is implemented by the expression ) 584 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1734 574 175 (aImp[i]) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1909 569 11 (,) 11 SB375 621 113 (where ) 113 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font488 626 100 (aImp) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font588 621 203 ( is declared ) 203 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font791 626 300 (int aImp[10]) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1091 621 11 (.) 11 SB435 673 1515 (Several people have suggested that these classes should inherit their specification from an) 1515 SB375 723 318 (abstract base class ) 318 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font693 728 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font818 723 1123 (. Unfortunately, that would require the use of virtual functions and) 1123 SB375 775 1634 (impose a word of overhead for every array. That word of overhead would be intolerable for many) 1634 SB375 825 1493 (uses of C++ built-in arrays, which these arrays are intended to replace in the safe subset.) 1493 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 925 53 (7.9) 53 SB428 925 286 (. Safe interfaces) 286 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1000 1649 (The safe subset won't be widely used until most class libraries have safe interfaces. Unfortunately,) 1649 SB375 1050 1563 (programmers will be reluctant to provide safe libraries until the safe subset is widely used. A) 1563 SB375 1100 1625 (combination of three strategies can help deal with this problem incrementally, without requiring) 1625 SB375 1150 377 (an edict from on high.) 377 SB435 1200 1454 (First, many common unsafe library functions are subsumed by the standard interfaces ) 1454 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1889 1205 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1252 73 (and ) 73 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font448 1257 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font548 1252 1445 (. Most applications using the safe subset will have little need to use old interfaces like) 1445 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1309 200 (string.h) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font575 1304 11 (.) 11 SB435 1356 1495 (Second, it's straightforward to provide safe veneers for most of the other standard library) 1495 SB375 1406 1125 (functions. The most common unsafe construct is a function with a ) 1125 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1500 1411 125 (char*) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1625 1406 393 ( argument representing) 393 SB375 1458 1367 (a string of unknown size; such arguments can be papered over in the veneer with) 1367 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1513 350 (SubArray<char>) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font725 1508 651 (. For example, here's a safe veneer for ) 651 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1376 1513 100 (read) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1476 1508 12 (:) 12 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1583 75 (int) 75 SB600 1583 350 ( safe_read\(int) 350 SB950 1583 150 ( file,) 150 SB1100 1583 375 ( SubArray<char>) 375 SB1475 1583 75 ( s\)) 75 SB1550 1583 50 ( {) 50 SB525 1628 25 ( ) 25 SB550 1628 25 ( ) 25 SB575 1628 25 ( ) 25 SB600 1628 175 ( return) 175 SB775 1628 275 ( read\(file,) 275 SB1050 1628 175 ( &s[0],) 175 SB1225 1628 350 ( s.Number\(\)\);}) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1700 1609 (In general, the veneers' interfaces will be safe while the implementations must be written in the) 1609 SB375 1750 1602 (unsafe language. Experience with Modula-2+ and Modula-3 shows that it's not hard to provide) 1602 SB375 1800 1338 (safe interfaces to the most common standard services [McJones 87, Nelson 91].) 1338 SB435 1850 1528 (Providing safe veneers for complicated interfaces like X or Microsoft Windows is a fair bit) 1528 SB375 1900 1592 (more work, but not at all unthinkable for one programmer to do in a few weeks. Many veneers) 1592 SB375 1950 1606 (already exist for those interfaces, for example to provide an object-oriented C++ interface or an) 1606 SB375 2000 239 (Ada interface.) 239 SB435 2050 1575 (Finally, well-written applications tend to isolate their use of low-level system libraries behind) 1575 SB375 2100 1623 (a small number of their own interfaces. For example, an application doing binary i/o often hides) 1623 SB375 2150 1511 (the calls to the low-level i/o services behind its own application-specific abstractions. The) 1511 SB375 2200 1636 (programmer can provide safe interfaces to these abstractions, encapsulating the low-level, unsafe) 1636 SB375 2250 1582 (code in one or two modules. If a module needs to call only one or two unsafe functions, rather) 1582 SB375 2300 1422 (than defining a whole new interface, the programmer can wrap just those calls with ) 1422 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1797 2305 175 (#pragma) 175 SB375 2357 150 (unsafe) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font525 2352 11 (.) 11 SB435 2404 1581 (Experience with Cedar, Modula-2+, and Modula-3 shows that this mixed approach is feasible) 1581 SB375 2454 1642 (and is not a major roadblock to using a safe language. But we don't want to minimize the amount) 1642 SB375 2504 1587 (of care and effort that will be needed to gradually build up a solid core of safe interfaces to the) 1587 SB375 2554 306 (standard libraries.) 306 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2654 74 (7.10) 74 SB449 2654 638 (. Signaling checked run-time errors) 638 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2729 1622 (By definition, a checked run-time error occurs because of a programming bug such as an out-of-) 1622 SB375 2779 1498 (bounds subscript. Precisely how the error is signaled is up to the implementation, but the) 1498 SB375 2829 1599 (program should normally halt immediately with enough information for a debugger to find out) 1599 SB1209 3069 42 (33) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 1537 (where the error occurred. Implementations might choose to print an error message and call) 1537 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 324 175 (abort\(\)) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 319 746 ( or, more likely, to raise a private exception.) 746 SB435 371 1496 (Programmers should not expect to catch such exceptions by name. Long experience with) 1496 SB375 421 1632 (languages such as Mesa and Modula-2+ shows that allowing programs to handle run-time errors) 1632 SB375 471 840 (in a programmatic way will often mask true bugs.) 840 SB435 521 440 (For example, suppose the ) 440 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font875 526 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1000 521 599 ( interface raised a public exception ) 599 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1599 526 350 (SubscriptError) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1949 521 59 ( for) 59 SB375 573 1589 (out-of-bound subscripts. A programmer might write a loop indexing through an array, using a) 1589 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 628 75 (try) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 623 1008 ( statement to terminate the loop when the index got too big:) 1008 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 698 125 (try {) 125 SB525 743 575 (    for \(i = 0;; i++\) {) 575 SB525 788 450 (        ...a[i]...) 450 SB525 833 300 (        f\(\);) 300 SB525 878 325 (        ...}}) 325 SB525 923 625 (catch \(SubscriptError\) {}) 625 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 995 802 (If some other statement in the loop body raised ) 802 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1177 1000 350 (SubscriptError) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1527 995 365 ( as the result of a true) 365 SB375 1047 788 (programming error \(for example, the function ) 788 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1163 1052 25 (f) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1188 1047 808 ( might be buggy\), the resulting exception would) 808 SB375 1099 286 (be caught by the ) 286 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font661 1104 125 (catch) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font786 1099 1230 (, the loop would terminate prematurely, and the program would continue) 1230 SB375 1151 1645 (execution with no indication that a bug had occurred. This defeats the purpose of the safe subset's) 1645 SB375 1201 902 (run-time checks: to detect bugs as soon as they occur.) 902 SB435 1251 1559 (Another complication arises if programs can catch exceptions raised as the result of checked) 1559 SB375 1301 1583 (run-time errors. For efficiency, programmers often want to turn off run-time checking in fully) 1583 SB375 1351 1608 (tested production code. The safe subset specifically allows checking to be disabled to encourage) 1608 SB375 1401 1645 (its use in the development of production programs. Letting programs catch run-time errors would) 1645 SB375 1451 1556 (open up additional avenues for complexity and mistakes, since the programmer mustn't ever) 1556 SB375 1501 1491 (disable run-time checks in any code that explicitly handles the resulting run-time errors.) 1491 SB435 1551 1507 (In situations like the example above, it is almost always clearer and more efficient for the) 1507 SB375 1601 1557 (programmer to use explicit tests instead of catching run-time errors. Using explicit tests, the) 1557 SB375 1651 1599 (programmer is free to disable all run-time checks in a correct program. But if a program relied) 1599 SB375 1701 1607 (on catching some of the run-time checks, it wouldn't be practical for the programmer to disable) 1607 SB375 1751 1546 (all but the few checks his program relies on. More likely, he would leave all checks in a file) 1546 SB375 1801 1339 (enabled, even though most of them would be unnecessary for correct execution.) 1339 SB435 1851 1524 (Programs may catch run-time errors in one special circumstance: to notify the user that an) 1524 SB375 1901 1523 (unexpected bug has occurred and to shut down as gracefully as possible. The top level of a) 1523 SB375 1951 425 (program might look like:) 425 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2024 125 (try {) 125 SB525 2076 100 (    ) 100 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font625 2071 444 (...main body of program...) 444 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1069 2076 25 (}) 25 SB525 2121 300 (catch\(...\) {) 300 SB525 2173 100 (    ) 100 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font625 2168 640 (...notify user of a bug and shutdown...) 640 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1265 2173 25 (}) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2245 1627 (Note that shutting down \223gracefully\224 is fraught with peril. By definition, a run-time error means) 1627 SB375 2295 1644 (that a bug has occurred and that the program has violated its invariants in an unexpected way. Its) 1644 SB375 2345 1644 (state could be arbitrarily corrupted, so the program shouldn't update any persistent objects or files) 1644 SB375 2395 225 (with its state.) 225 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2495 74 (7.11) 74 SB449 2495 485 (. Evaluating the safe subset) 485 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2570 1608 (Some critics have accused us of trying to ram Modula-3 \(or Ada, or Pascal\) down the throats of) 1608 SB375 2620 1634 (C++ programmers. On the contrary, our sole goal is to improve productivity by reducing the cost) 1634 SB375 2670 1530 (of storage bugs, not to impose our broader subjective views about programming languages.) 1530 SB375 2720 1601 (Researchers and practitioners might reasonably disagree whether the benefits of the safe subset) 1601 SB375 2770 1535 (are worth the costs, but surely this issue requires a dispassionate, detailed examination, not) 1535 SB375 2820 1218 (emotional cries of \223Fascist programming languages!\224 or \223This isn't C!\224.) 1218 SB1209 3069 42 (34) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 1540 (We've tried hard to minimize the restrictions of the safe subset. We don't know how to pare) 1540 SB375 319 1587 (down the list further without sacrificing GC-safety or imposing much larger run-time costs on) 1587 SB375 369 1639 (programs. We've resisted the temptation to add restrictions that might \223improve\224 the language in) 1639 SB375 419 486 (ways unrelated to GC-safety.) 486 SB435 469 1560 (The benefit of the safe subset is obvious: freedom from storage bugs. But there are two costs,) 1560 SB375 519 1262 (restrictions on the expressiveness of the language and the run-time checks.) 1262 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font375 594 277 (Expressiveness. ) 277 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font652 594 842 (There are four major restrictions on the language:) 842 SB435 644 1564 (First, the use of built-in arrays is restricted, but the safe array classes provide equally concise) 1564 SB375 694 455 (and efficient replacements.) 455 SB435 744 1480 (Second, unsafe casting and union types containing pointers, references, or functions are) 1480 SB375 794 1603 (prohibited. These constructs are useful mainly in low-level code dealing with hardware devices) 1603 SB375 844 1576 (and external data formats. Many uses of unions are better expressed with derived classes, and) 1576 SB375 894 868 (often the space savings of a union are insignificant.) 868 SB435 944 1590 (Third, functions taking a variable number of arguments are prohibited. The most common use) 1590 SB375 994 575 (of variadic functions is to call C's ) 575 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font950 999 150 (printf) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1100 994 838 ( and friends, and the standard C++ stream library) 838 SB375 1046 1519 (provides an adequately concise and efficient replacement. Default arguments and function) 1519 SB375 1096 1238 (overloading subsume most other common uses of variadic functions in C.) 1238 SB435 1146 1527 (Fourth, pointers to automatic variables are prohibited, as is storing references to automatic) 1527 SB375 1196 1595 (variables into heap objects. By far, the most common use of taking the address of an automatic) 1595 SB375 1246 1519 (variable is to pass an argument \223by reference\224 to a function. But reference parameters and) 1519 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1301 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font575 1296 1383 (s allow this to be done safely, and safe veneer interfaces provide access to existing) 1383 SB375 1348 364 (library functions like ) 364 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font739 1353 100 (read) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font839 1348 11 (.) 11 SB435 1400 1572 (Judging from this list, we believe that most programming styles can be readily adapted to use) 1572 SB375 1450 1584 (the safe subset with almost no effort and no sacrifice in performance. Further, based on over a) 1584 SB375 1500 1605 (decade of experience with languages such as Cedar, Ada, and Modula-2+, we believe that most) 1605 SB375 1550 1573 (parts of most applications can be written in the safe subset, with the small unsafe parts neatly) 1573 SB375 1600 605 (encapsulated behind safe interfaces.) 605 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font375 1675 301 (Run-time checks. ) 301 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font676 1675 1251 (The overhead of the run-time checking is not insignificant. In similar safe) 1251 SB375 1725 1615 (languages, the overhead can range from 1 to 15% for programs that don't use arrays heavily, up) 1615 SB375 1775 1634 (to as much as 100% for programs that do. \(Well-known compiler optimizations can dramatically) 1634 SB375 1825 1438 (reduce the overhead of array-subscript checks.\) But this overhead is much better than) 1438 SB375 1875 1606 (CenterLine's factor of 50 or Purify's factor of two to four, and unlike those tools, the safe subset) 1606 SB375 1925 530 (requires no additional memory.) 530 SB435 1975 1581 (The relatively low overhead of the checks allows them to be used throughout the development) 1581 SB375 2025 1576 (process, even in embedded or CPU-intensive applications where larger performance penalties) 1576 SB375 2075 1572 (aren't practical. The checks can be left enabled throughout testing and beta release, and some) 1572 SB375 2125 1589 (programmers may well choose to leave checks enabled in released programs where safety is of) 1589 SB375 2175 1460 (extreme importance. \(Many Ada programs are shipped with run-time checks enabled.\)) 1460 SB1209 3069 42 (35) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 25 (8) 25 SB400 319 656 (. Suitable collection algorithms) 656 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 920 (The language interface to garbage collection \(sections ) 920 SB1295 403 21 (4) 21 SB1316 403 84 ( and ) 84 SB1400 403 21 (5) 21 SB1421 403 561 (\) is compatible with all the major) 561 SB375 453 1617 (families of collection algorithms. But as a practical matter, some algorithms will be more suited) 1617 SB375 503 665 (for C++ garbage collection than others.) 665 SB435 553 1480 (Practical collection algorithms for C++ must satisfy traditional requirements of garbage) 1480 SB375 603 173 (collectors:) 173 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 678 159 (Latency: ) 159 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font684 678 1167 (interruptions of the program should be short, less than 0.1 second for) 1167 SB525 728 360 (interactive programs.) 360 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 803 196 (Efficiency: ) 196 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font721 803 1244 (the collector should be time- and space-efficient, competitive with current) 1244 SB525 853 337 (implementations of ) 337 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font862 858 150 (malloc) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1012 853 12 (/) 12 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1024 858 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1099 853 801 (, and should be able to handle very large heaps.) 801 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 930 245 (Concurrency: ) 245 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font770 930 1214 (the collector should support multi-threaded programs running on multi-) 1214 SB525 980 186 (processors.) 186 SB375 1055 1569 (By \223competitive\224, we mean only that programmers will find that they can achieve their goals) 1569 SB375 1105 1605 (more cheaply by using garbage collection. Even if collection were more expensive than explicit) 1605 SB375 1155 1555 (deallocation \(and recent measurements indicate it often isn't [Zorn 92]\), many programmers) 1555 SB375 1205 1174 (would gladly pay that cost to increase productivity and decrease bugs.) 1174 SB435 1255 1518 (Compared to previous collected languages like Lisp or Cedar, our design for C++ garbage) 1518 SB375 1305 985 (collection imposes some additional, tougher requirements:) 985 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 1380 305 (Interior pointers: ) 305 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font830 1380 1097 (pointers can address the interior of objects. Traditional collectors) 1097 SB525 1430 728 (support pointers only to the base of objects.) 728 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 1505 356 (Cross-heap pointers:) 356 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font881 1505 1133 ( non-collected objects can point at collected objects, and vice versa.) 1133 SB525 1555 1459 (Traditional collectors assume the language prohibits storing collected-heap pointers in) 1459 SB525 1605 392 (the non-collected heap.) 392 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 1680 649 (Unions containing collector pointers: ) 649 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1174 1680 850 (pointers to collected objects can be stored in union) 850 SB525 1730 1258 (members. Unlike previous collected languages, C++ doesn't tag its unions.) 1258 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 1805 486 (Multi-lingual compatibility: ) 486 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1011 1805 1005 (pointers to collected objects can be freely passed to libraries) 1005 SB525 1855 1367 (written in other languages, and those libraries' objects can point at collected C++) 1367 SB525 1905 126 (objects.) 126 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 1980 538 (Minimal changes to compilers: ) 538 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1063 1980 931 (the more special support needed from the compiler, the) 931 SB525 2030 1395 (less likely C++ garbage collection will be accepted and provided by vendors. Some) 1395 SB525 2080 1482 (algorithms, such as reference counting, require special language, compiler, or hardware) 1482 SB525 2130 1430 (support that wouldn't be practical in today's commercial multi-lingual environments.) 1430 SB375 2205 1616 (In the last several years, researchers have evolved a class of collection algorithms meeting these) 1616 SB375 2255 1624 (requirements. Boehm et al. have developed mark-and-sweep collectors [Boehm 91], and Bartlett) 1624 SB375 2305 1634 (et al. have developed copying collectors [Bartlett 89, Detlefs 90, Yip 91], and the performance of) 1634 SB375 2355 1595 (these collectors is good enough for many C++ applications [Yip 91, Zorn 92]. Both families of) 1595 SB375 2405 1094 (collectors use similar technology for satisfying our requirements.) 1094 SB435 2455 1457 (Low latency \(short interruptions\) is achieved using virtual-memory synchronization to) 1457 SB375 2505 1191 (implement generational and concurrent collection [Shaw 87, Ellis 88].) 1191 SB435 2555 1532 (Interior pointers are handled in the Boehm collectors by ensuring that all objects on a page) 1532 SB375 2605 1507 (have the same size and by using a table to map page numbers to object sizes. The Bartlett) 1507 SB375 2655 1225 (collectors use a bitmap per page indicating the starting offsets of objects.) 1225 SB435 2705 1442 (Cross-heap pointers from the non-collected heap to the collected heap can be handled) 1442 SB375 2755 1598 (efficiently with the same VM-synchronization techniques used for generational collection. The) 1598 SB375 2805 1589 (non-collected heap is considered part of the root-pointer set of a generational collection, along) 1589 SB375 2855 1607 (with global data and the old-space pages of the collected heap. At the start of each generational) 1607 SB375 2905 1594 (collection, all the pages in the root set are write-protected, and the subsequent write-protection) 1594 SB1209 3069 42 (36) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 1547 (faults caused by the program tell the collector which of those pages have been modified; the) 1547 SB375 319 1647 (collector needs to scan just those modified pages, not the entire root set. The cost of this approach) 1647 SB375 369 462 (for a non-collected heap of ) 462 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font837 369 28 (N) 28 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font865 369 505 ( bytes and a collected heap of ) 505 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1370 369 28 (C) 28 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1398 369 575 ( bytes is about no worse than for a) 575 SB375 419 412 (totally collected heap of ) 412 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font787 419 106 (N + C) 106 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font893 419 1074 ( bytes. This hasn't yet been implemented in either a Boehm or a) 1074 SB375 469 1418 (Bartlett collector, though it would be straightforward and take almost no extra code.) 1418 SB435 519 1583 (Most of today's major commercial platforms provide the basics for supporting virtual-memory) 1583 SB375 569 1557 (synchronization, including Windows, Windows NT, OS/2, Macintosh, the various flavors of) 1557 SB375 619 1558 (Unix, and almost all of the newer hardware for those systems. The collectors must be able to) 1558 SB375 669 1597 (protect and unprotect data pages, intercept the resulting page-protection faults, and resume the) 1597 SB375 719 1638 (program. The Boehm mark-and-sweep collectors only need write protection, whereas the Bartlett) 1638 SB375 769 1630 (copying collectors need both write and no-access protection. The actual facilities provided by the) 1630 SB375 819 1569 (various platforms may well be an imperfect match for the collectors' needs, and in particular,) 1569 SB375 869 1647 (they may not be very well tuned [Appel 91], but experience to date indicates they are adequate for) 1647 SB375 919 1596 (initial use by C++ collectors. Once paying customers start using C++ collectors, we can expect) 1596 SB375 969 1423 (operating-system vendors to pay more attention to the requisite underlying facilities.) 1423 SB435 1019 1457 (Multi-lingual compatibility and minimizing changes to C++ compilers dictate that the) 1457 SB375 1069 1623 (collector must be at least partially conservative. A totally conservative collector treats each word) 1623 SB375 1119 1649 (in a register, stack frame, or object as a possible pointer, whereas a totally precise collector knows) 1649 SB375 1169 1546 (exactly where each pointer is stored at all times. The Boehm mark-and-sweep collectors are) 1546 SB375 1219 1448 (totally conservative, while the Bartlett copying collectors scan the registers and stacks) 1448 SB375 1269 1497 (conservatively and the heap precisely. \(Copying collectors must scan the heap precisely.\)) 1497 SB435 1319 1495 (Conservative scanning requires no compiler support and very little run-time support; the) 1495 SB375 1369 1545 (collector just needs access to the stacks and registers. With conservative collectors, libraries) 1545 SB375 1419 1648 (written in C and other languages can allocate collected objects without requiring changes to those) 1648 SB375 1469 1617 (compilers. Because each word in the registers, stacks, and heaps is treated as a pointer even if it) 1617 SB375 1519 1594 (isn't, conservative scanning sometimes retains unused objects accidentally, increasing memory) 1594 SB375 1569 106 (usage.) 106 SB435 1619 1452 (Precise scanning requires a fair bit of compiler and run-time support \(but no language) 1452 SB375 1669 1645 (changes\). The compiler generates \223type maps\224 describing the locations of pointers within objects,) 1645 SB375 1719 73 (and ) 73 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font448 1724 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font523 1719 569 ( tags each object with a type map.) 569 SB435 1771 1555 (Most researchers believe precise scanning of the heap is more time- and space-efficient than) 1555 SB375 1821 1586 (conservative scanning, since it examines fewer words, does less work to identify true pointers,) 1586 SB375 1871 1575 (and doesn't accidentally retain unused objects. On the other hand, interpretation of type maps) 1575 SB375 1921 1616 (entails a fair bit of overhead. No one has yet published good comparisons of the two techniques.) 1616 SB375 1971 1577 (However, measurements of the Boehm collectors show that fully conservative scanning yields) 1577 SB375 2021 1595 (practical collectors [Boehm 91, Zorn 92]. Boehm has recently developed simple techniques for) 1595 SB375 2071 1541 (dramatically reducing accidental retention of objects by conservative scanning [Boehm 93].) 1541 SB435 2121 1451 (While it is technically possible to scan stacks and registers precisely, doing so without) 1451 SB375 2171 1597 (compromising code quality is complicated [Diwan 92], and it would be infeasible to modify all) 1597 SB375 2221 1646 (the other major language compilers as well as C++ compilers. The performance benefit of precise) 1646 SB375 2271 1649 (stack scanning is not large, since the average size of stacks is small and scanning them takes only) 1649 SB375 2321 666 (a small fraction of total collection time.) 666 SB435 2371 1460 (There's been quite a bit of positive experience with algorithms that scan the stacks and) 1460 SB375 2421 1590 (registers conservatively and scan the heap precisely [Rovner 85a, DeTreville 90b, Bartlett 89].) 1590 SB375 2471 1646 (However, those collectors didn't allow interior pointers; once interior pointers are allowed, there's) 1646 SB375 2521 1527 (a greater chance that a random word on the stack could be mistakenly interpreted as a true) 1527 SB375 2571 1550 (pointer and more unused storage retained. In practice, this doesn't appear to be a significant) 1550 SB375 2621 362 (problem [Boehm 93].) 362 SB435 2671 1453 (The best C++ collectors might scan the stacks conservatively and use both precise and) 1453 SB375 2721 1068 (conservative scanning of the heaps. Objects allocated by C++'s ) 1068 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1443 2726 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1518 2721 462 ( would be tagged with their) 462 SB375 2773 958 (type map and scanned precisely; objects allocated by C's ) 958 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1333 2778 150 (malloc) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1483 2773 402 ( would be untagged and) 402 SB375 2825 399 (scanned conservatively.) 399 SB1209 3069 42 (37) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 401 (As discussed in section ) 401 SB836 269 21 (9) 21 SB857 269 1146 (, the language interface explicitly allows unions to contain collected) 1146 SB375 319 1505 (pointers. This requires a collector without hardware support to scan pointer-valued union) 1505 SB375 369 1604 (members conservatively, even if the collector uses otherwise totally precise scanning. Handling) 1604 SB375 419 1624 (unions is straightforward for both conservative mark-and-sweep and mostly copying algorithms,) 1624 SB375 469 1545 (which already have the necessary mechanisms to handle ambiguous pointers in the root set.) 1545 SB435 519 1471 (Detlefs hypothesized that it isn't possible to scan unions conservatively in a concurrent,) 1471 SB375 569 1518 (mostly copying collector [Detlefs 90]. But we now believe that is wrong. A collector could) 1518 SB375 619 1634 (maintain the set of all objects having pointer-containing unions \(the set could be implemented as) 1634 SB375 669 1569 (a threaded list\). Before scanning the heap, the collector marks all objects that are referents of) 1569 SB375 719 1595 (those pointer-containing unions. If the collector later discovers that a marked object is actually) 1595 SB375 769 1490 (reachable from the root set, it promotes the object rather than copying it \(since it may be) 1490 SB375 819 1600 (referenced by an ambiguous pointer\). In a VM-synchronized collector, it's easy to do the initial) 1600 SB375 869 918 (marking from pointer-containing unions concurrently.) 918 SB1209 3069 42 (38) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 25 (9) 25 SB400 319 176 (. Unions) 176 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 1619 (C++ unions cause problems for garbage collection. Some algorithms simply can't handle unions) 1619 SB375 453 1650 (containing collected pointers, while those that can don't always perform well. We were faced with) 1650 SB375 503 1572 (a tough choice: If we prohibited unions containing collected pointers, we'd be adding another) 1572 SB375 553 1427 (restriction to the language and sacrificing some compatibility with existing code and) 1427 SB375 603 1650 (programming practice. But if we allowed such unions, we'd be imposing additional constraints on) 1650 SB375 653 835 (collector implementations and their performance.) 835 SB435 703 1540 (In the end, we decided in favor of fewer restrictions on the language. The definition of GC-) 1540 SB375 753 454 (safety presented in section ) 454 SB829 753 21 (6) 21 SB850 753 991 ( explicitly allows unions containing collected pointers. But) 991 SB375 803 1643 (programmers must be warned that such unions may cause particular collector implementations to) 1643 SB375 853 1616 (perform sub-optimally, and they should avoid such unions wherever possible. Obviously, telling) 1616 SB375 903 1613 (programmers that a feature is legal but should be avoided is not ideal. But the alternatives seem) 1613 SB375 953 109 (worse.) 109 SB435 1003 1542 (The root of the problem is that, unlike the variant records of Pascal or Modula, C++ unions) 1542 SB375 1053 1416 (are untagged, containing no indication of their current contents. Consider the union) 1416 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1126 650 (union {int i; char* p;} u;) 650 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1198 499 (A collector can't tell whether ) 499 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font874 1203 25 (u) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font899 1198 1086 ( contains an integer or a pointer, since on most implementations) 1086 SB375 1250 1225 (the representations of integers and pointers are indistinguishable. These ) 1225 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1600 1250 333 (ambiguous pointers) 333 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1300 1570 (cause two problems for collectors. First, conservative collectors simply assume that the union) 1570 SB375 1350 1599 (contains a pointer, whether it does or not, and retain the object that is apparently referenced by) 1599 SB375 1400 1630 (the ambiguous pointer value. This can cause excess unused storage to be accidentally retained; if) 1630 SB375 1450 1568 (pointer-containing unions are used extensively, the excess storage may be unacceptably large) 1568 SB375 1500 1577 ([Detlefs 90]. Second, pure copying collectors are in a bind: If the union contains a pointer, its) 1577 SB375 1550 1591 (referent must be moved and the pointer updated, but if it contains an integer, its value must be) 1591 SB375 1600 1531 (left unchanged. Without special hardware, untagged unions seem to preclude pure copying) 1531 SB375 1650 172 (collectors.) 172 SB435 1700 1460 (Some have suggested that compilers could add implicit tags to unions identifying their) 1460 SB375 1750 793 (current contents to the collector. But appendix ) 793 SB1168 1750 27 (B) 27 SB1195 1750 703 ( shows it isn't feasible to tag unions while) 703 SB375 1800 1534 (maintaining C++ semantics. Even if it were, the tagging would increase the size of unions,) 1534 SB375 1850 1587 (making their representation incompatible with data structures defined externally by hardware,) 1587 SB375 1900 1532 (file formats, and modules written in other languages like C. This would defeat our original) 1532 SB375 1950 1569 (purpose for allowing unions, maintaining compatibility with existing code and programming) 1569 SB375 2000 144 (practice.) 144 SB435 2050 1569 (Prohibiting unions containing collected pointers would sidestep the algorithmic issues, but at) 1569 SB375 2100 1508 (the cost of compatibility. For example, clients would be prohibited from passing collected) 1508 SB375 2150 1114 (pointers to an existing library that stored those pointers in unions.) 1114 SB435 2200 1577 (We finally decided that minimizing language restrictions and maximizing compatibility were) 1577 SB375 2250 1592 (most important, and that collector implementations must handle pointer-containing unions. In) 1592 SB375 2300 1583 (practice, this probably means that an otherwise precise collector must scan pointer-containing) 1583 SB375 2350 1501 (unions conservatively, as is done in Boehm's mark-and-sweep collectors [Boehm 91] and) 1501 SB375 2400 1607 (Bartlett's mostly copying collectors [Bartlett 89]. Note, however, that a collector with otherwise) 1607 SB375 2450 1566 (totally precise scanning will incur no performance penalty if the program avoids unions with) 1566 SB375 2500 1638 (ambiguous pointers; in particular, a mostly copying collector that scans the root set precisely will) 1638 SB375 2550 618 (behave like a pure copying collector.) 618 SB435 2600 1570 (Though the proposal requires collectors to work correctly with pointer-containing unions, we) 1570 SB375 2650 1507 (recognize that they may be much less efficient if there are many ambiguous pointers. The) 1507 SB375 2700 741 (language interface thus includes a standard ) 741 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1116 2705 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1291 2700 715 ( template class that provides programmers) 715 SB375 2752 666 (with the functionality of tagged unions:) 666 SB1209 3069 42 (39) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font0 0 0 fC525 267 1000 (template <class T1, class T2> Variant2 {) 1000 SB525 312 350 (      int tag;) 350 SB525 357 750 (      union {T1 t1; T2 t2;} u;) 750 SB525 409 225 (      // ) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font750 404 316 (public interface to ) 316 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1066 409 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1241 404 125 ( class...) 125 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 454 150 (     }) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 526 244 ( For example, ) 244 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font619 531 550 (Variant2<int, char*> v) 550 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1169 526 159 ( declares ) 159 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1328 531 25 (v) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1353 526 460 ( to be a tagged union of an ) 460 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1813 531 75 (int) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1888 526 103 ( and a) 103 SB375 578 183 (pointer. A ) 183 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font558 583 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font733 578 1266 ('s tag is automatically set when a value is assigned to it, and it is optionally) 1266 SB375 630 312 (checked when the ) 312 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font687 635 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font862 630 577 ('s value is accessed. See appendix ) 577 SB1439 630 26 (E) 26 SB1465 630 520 ( for the full interface. By using) 520 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 687 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 682 1413 (s wherever possible, programmers can avoid the collector inefficiencies of untagged) 1413 SB375 734 124 (unions.) 124 SB435 784 1400 (A compiler/collector implementation may be built with particular knowledge about) 1400 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 839 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 834 408 (s. When it encounters a ) 408 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font958 839 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1133 834 801 (, it can use the tag field to determine its current) 801 SB375 886 1320 (value and thus scan it precisely. Of course, conservative collectors can handle ) 1320 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1695 891 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1870 886 16 (s) 16 SB375 938 1566 (correctly without any extra implementation work, though they won't receive the performance) 1566 SB375 988 126 (benefit.) 126 SB435 1038 300 (Finally, note that ) 300 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font735 1043 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font910 1038 924 (s impose no further requirements for GC-safety. Since ) 924 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1834 1043 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font2009 1038 16 (s) 16 SB375 1090 1133 (are implemented with unions, the rules for unions apply equally to ) 1133 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1508 1095 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1683 1090 290 (s. In particular, a) 290 SB375 1142 1201 (GC-safe program must access only the currently assigned member of a ) 1201 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1576 1147 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1751 1142 11 (.) 11 SB1209 3069 42 (40) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 50 (10) 50 SB425 319 193 (. Interior) 193 SB32 0 0 58 58 0 0 0 54 /Times-Bold /font29 ANSIFont font618 311 15 ( ) 15 SB32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font633 319 174 (pointers) 174 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 1593 (Unlike most other languages with garbage collection, this proposal for C++ garbage collection) 1593 SB375 453 119 (allows ) 119 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font494 453 300 (interior pointers, ) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font794 453 1142 (pointers addressing the middle of objects. \(Taking the address of an) 1142 SB375 503 1065 (array element or an object's member yields an interior pointer.\)) 1065 SB435 553 1406 (Language designers typically assume that interior pointers make garbage collection) 1406 SB375 603 1553 (significantly more expensive. If interior pointers are allowed, a collector cannot assume that) 1553 SB375 653 1535 (every pointer addresses the base of an object, and it must map every pointer it follows to its) 1535 SB375 703 1617 (corresponding base. Since that mapping occurs in the collector's inner loops, it might cost a fair) 1617 SB375 753 1508 (bit extra. Also, allowing interior pointers can cause conservative collectors to retain more) 1508 SB375 803 132 (storage.) 132 SB435 853 1351 (Our initial design of the C++ safe subset prohibited interior pointers. Appendix ) 1351 SB1786 853 30 (A) 30 SB1816 853 149 ( presents) 149 SB375 903 1623 (the necessary changes to the safe subset and discusses the implications for implementations. But) 1623 SB375 953 1528 (we eventually decided that it would be better to allow interior pointers, for several reasons.) 1528 SB435 1003 1572 (First, to appeal to the largest number of programmers, we wanted to minimize restrictions on) 1572 SB375 1053 1629 (the language. Though practical systems programming languages like Cedar, Modula-3, and Ada) 1629 SB375 1103 1489 (prohibit or discourage interior pointers, we wanted to avoid antagonizing the many C++) 1489 SB375 1153 930 (programmers who would surely object to their absence.) 930 SB435 1203 1529 (Second, multiple inheritance creates problems not faced by other languages. Given a class ) 1529 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1964 1208 25 (C) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1255 354 (derived from classes ) 354 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font729 1260 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font754 1255 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font838 1260 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font863 1255 942 (, in current implementations widening \(\223up-casting\224\) a ) 942 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1805 1260 50 (C*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1855 1255 84 ( to a ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1939 1260 50 (B*) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1307 798 (can create an interior pointer to the storage for ) 798 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1173 1312 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1198 1307 186 ( inside the ) 186 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1384 1312 25 (C) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1409 1307 608 ( object. Thus prohibiting all interior) 608 SB375 1359 1531 (pointers would require radical changes to current implementations of multiple inheritance.) 1531 SB375 1409 177 (Appendix ) 177 SB552 1409 30 (A) 30 SB582 1409 1432 ( presents a run-time representation of objects that could efficiently handle the special) 1432 SB375 1459 1631 (case of interior pointers resulting from widening casts, but this scheme would require non-trivial) 1631 SB375 1509 1555 (changes to current implementations that we think would impede acceptance of C++ garbage) 1555 SB375 1559 175 (collection.) 175 SB435 1609 1505 (Third, two recently developed families of partially conservative collection algorithms can) 1505 SB375 1659 1619 (handle interior pointers fairly cheaply [Bartlett 89, Yip 91, Boehm 91, Zorn 92], and we believe) 1619 SB375 1709 1578 (that these algorithms best meet all the other practical requirements of C++ garbage collection) 1578 SB375 1759 206 (\(see section ) 206 SB581 1759 21 (8) 21 SB602 1759 1415 (\). We think that allowing general interior pointers will typically cost less than a few) 1415 SB375 1809 995 (percent extra in total program execution time. \(See below.\)) 995 SB375 1884 1590 (Samples's language proposal [Samples 92] would facilitate more efficient following of interior) 1590 SB375 1934 1620 (pointers by the collector. Implementations could wrap each collected object, member object, and) 1620 SB375 1984 297 (sub-object with a ) 297 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font672 1989 250 (gc wrapper) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font922 1984 1061 ( that would let the garbage collector quickly find the outermost) 1061 SB375 2036 786 (containing object in the heap. Most likely, the ) 786 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1161 2041 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1211 2036 691 ( wrapper would require no extra space in) 691 SB375 2088 1064 (objects with virtual functions if a scheme like that in appendix ) 1064 SB1439 2088 30 (A) 30 SB1469 2088 466 ( is used, but objects without) 466 SB375 2138 1617 (virtual functions would need an extra header word in their representation. The cost of following) 1617 SB375 2188 1631 (interior pointers is only reduced, not eliminated, because the proposal still allows the declaration) 1631 SB375 2238 44 (of ) 44 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font419 2243 200 (embedded) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font619 2238 1403 ( objects and pointers to such objects, with the intention that embedded objects don't) 1403 SB375 2290 90 (have ) 90 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font465 2295 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font515 2290 1398 ( wrappers; following an embedded pointer would entail the full cost of mapping an) 1398 SB375 2342 1232 (interior pointer to the corresponding object base. As discussed in section ) 1232 SB1607 2342 53 (3.5) 53 SB1660 2342 343 (, Samples's proposal) 343 SB375 2392 1041 (doesn't meet our criteria of minimal changes and coexistence.) 1041 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2492 74 (10.1) 74 SB449 2492 691 (. The run-time cost of interior pointers) 691 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2567 1627 (The Boehm and Bartlett family of collectors provide heap data structures that allow the collector) 1627 SB375 2617 1600 (to map interior pointers to base pointers. The Boehm collector carves the heap into pages, with) 1600 SB375 2667 1606 (all of the objects on a page being the same size \(\223big bag of pages\224\) and a page table giving the) 1606 SB375 2717 1597 (size of objects on each page. The Bartlett collectors keep a bit vector per page indexed by word) 1597 SB375 2767 1628 (offset, indicating the beginnings of objects on the page. In either scheme, mapping a pointer to a) 1628 SB375 2817 1649 (base pointer involves extracting a page index, indexing into the page table, then indexing another) 1649 SB375 2867 337 (table or a bit vector.) 337 SB1209 3069 42 (41) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 1412 (On the MIPS processor, this mapping takes about 15 instructions, compared to zero) 1412 SB375 319 1640 (instructions for a language like Modula-3 that prohibits interior pointers. Pointer following is the) 1640 SB375 369 1530 (most frequent operation of a collector, and it must pay this 15-instruction penalty for every) 1530 SB375 419 299 (pointer it follows.) 299 SB435 469 1506 (To get a feel for the magnitude of this penalty, we measured a commercial C++ debugger) 1506 SB375 519 1602 (modified to use version 2.3 of Boehm's collector. Running on a 40 MHz DECstation 5000/240,) 1602 SB375 569 1219 (we drove the debugger with a test script that executed its basic facilities:) 1219 SB525 644 803 (The script executed for 11 minutes, 20 seconds.) 803 SB525 694 620 (The heap grew to 7.08 million bytes.) 620 SB525 744 1398 (There were 22 collections of the entire heap, taking an average of 1.48 seconds per) 1398 SB600 794 175 (collection.) 175 SB525 844 1036 (The collector followed 2.68 million pointers to actual objects.) 1036 SB375 919 1530 (Assume that 10 of the 15 instructions per pointer followed are devoted to handling interior) 1530 SB375 969 390 (pointers \(see appendix ) 390 SB765 969 30 (A) 30 SB795 969 1064 (\), and pessimistically assume the processor executes 20 million) 1064 SB375 1019 1545 (instructions per second. Then only 0.2% of total execution time was spent handling interior) 1545 SB375 1069 1508 (pointers, which is about 0.061 seconds per collection or about 4% of the time spent in the) 1508 SB375 1119 156 (collector.) 156 SB435 1169 1568 (Based on this one experiment, we think interior pointers are quite affordable. At worst, if the) 1568 SB375 1219 1612 (typical application spent 5 times as much time handling interior pointers, it would still cost just) 1612 SB375 1269 460 (20% of total collector time.) 460 SB435 1319 1477 (However, even if we outlawed interior pointers in the language, it would still be hard to) 1477 SB375 1369 1597 (eliminate all of the interior-pointer overhead from the Boehm and Bartlett family of collectors.) 1597 SB375 1419 401 (As discussed in section ) 401 SB776 1419 21 (8) 21 SB797 1419 1139 (, most implementations in the next few years will probably scan the) 1139 SB375 1469 1552 (stacks and registers conservatively, and such scanning needs a way to determine whether an) 1552 SB375 1519 1521 (address points at a heap object. The heap structures needed for this determination are very) 1521 SB375 1569 1595 (similar to those needed for handling general interior pointers, and the heap allocator must still) 1595 SB375 1619 436 (maintain those structures.) 436 SB435 1669 1584 (Further, with mark-and-sweep collectors, it's generally more efficient to store object mark bits) 1584 SB375 1719 1646 (on the side to increase locality of reference and reduce dirtying of pages during the mark phase of) 1646 SB375 1769 1631 (collection, and it's required for concurrent VM-synchronized collectors. Storing mark bits on the) 1631 SB375 1819 1564 (side requires heap structures similar to those needed for interior pointers, and the instruction) 1564 SB375 1869 1566 (sequence for following a pointer is about the same regardless of whether interior pointers are) 1566 SB375 1919 1622 (allowed or not\227a page index must be extracted from the pointer and used to index a page table.) 1622 SB375 1969 1636 (For example, version 2.3 of Boehm's collector can be configured to disallow interior pointers, yet) 1636 SB375 2019 1134 (the sequence for following a pointer is only one instruction shorter.) 1134 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2119 74 (10.2) 74 SB449 2119 632 (. The space cost of interior pointers) 632 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2194 1617 (Interior pointers have no effect on the space efficiency of a totally precise collector, but they can) 1617 SB375 2244 1594 (cause conservative collectors to retain more storage. When interior pointers are allowed with a) 1594 SB375 2294 1620 (conservative collector, a word is considered to point at an object if it points anywhere within the) 1620 SB375 2344 1620 (object, not just at its first byte. This increases the probability that a random bit pattern in a word) 1620 SB375 2394 1647 (will be misinterpreted as a valid pointer, and thus more objects may be unnecessarily retained. To) 1647 SB375 2444 1593 (the extent that a collector uses precise scanning, fewer words will be misinterpreted as interior) 1593 SB375 2494 147 (pointers.) 147 SB435 2544 1567 (Fortunately, unnecessary retention isn't a serious problem with totally conservative collectors) 1567 SB375 2594 1524 (on newer architectures, especially with Boehm's techniques for improving space efficiency) 1524 SB375 2644 1550 ([Boehm 93]. The more limited experience reported for the Bartlett family of mostly copying) 1550 SB375 2694 1623 (collectors, which also allow interior pointers but scan the collected heap precisely, indicates that) 1623 SB375 2744 1539 (unnecessary retention is not a big problem with those collectors either [Detlefs 90, Yip 91].) 1539 SB1209 3069 42 (42) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 50 (11) 50 SB425 319 497 (. Code-generator safety) 497 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 1551 (Existing compilers may sometimes generate code incompatible with the correct operation of) 1551 SB375 453 1328 (garbage collectors. Given an expression dereferencing the last use of a pointer ) 1328 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1703 458 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1728 453 291 (, many compilers) 291 SB375 505 586 (may generate code that overwrites ) 586 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font961 510 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font986 505 982 ('s register with a temporary address that points outside the) 982 SB375 557 1633 (bounds of the referenced object. If a concurrent collection occurs at that point, the object may get) 1633 SB375 607 1163 (collected prematurely before the dereferencing expression completes.) 1163 SB435 657 1499 (A garbage collector determines which objects are no longer being used by tracing out the) 1499 SB375 707 1575 (graph of reachable objects, using the registers, stacks, and static data segments as roots of the) 1575 SB375 757 1595 (trace. Any object not traced is garbage and can be reused. The algorithms discussed in section ) 1595 SB1970 757 21 (8) 21 SB375 807 1644 (consider an address to point at an object if it points at the base of the object or anywhere inside it.) 1644 SB435 857 1540 (As long as the program thinks an object is live, the code generator should ensure there is at) 1540 SB375 907 1548 (least one reachable pointer pointing at it; otherwise the collector may collect it prematurely.) 1548 SB375 957 489 (Consider this code fragment:) 489 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1030 575 (char* a = new char[10];) 575 SB525 1075 475 (int i = 20, j = 19;) 475 SB525 1120 350 (...a[i - j]...) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1192 291 (If the expression ) 291 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font666 1197 200 (a[i - j]) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font866 1192 293 ( is the last use of ) 293 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1159 1197 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1184 1192 25 ( \() 25 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1209 1197 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1234 1192 698 ( is dead after the expression\), then a code) 698 SB375 1244 1152 (generator might decide to generate the following MIPS R3000 code:) 1152 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1317 1075 (    # a is in register $a, i in $i, j in $j) 1075 SB525 1362 825 (    # result will be placed in $r) 825 SB525 1407 375 (addu $a, $a, $i) 375 SB525 1452 275 (subu $a, $j) 275 SB525 1497 350 (lb   $r, 0\($a\)) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1569 583 (After the first instruction, register ) 583 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font958 1574 50 ($a) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1008 1569 167 ( points at ) 167 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1175 1574 150 (a + 20) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1325 1569 631 (, that is, beyond the end of the object ) 631 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1956 1574 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1981 1569 11 (.) 11 SB375 1621 1621 (If there is no other pointer addressing the object, and if a garbage collection occurs at this point,) 1621 SB375 1671 1580 (the object would get garbage collected prematurely. \(Concurrent garbage collectors can run at) 1580 SB375 1721 171 (any time.\)) 171 SB435 1771 1590 (Reduction of strength of loop induction variables can cause similar problems. For example, an) 1590 SB375 1821 835 (optimizing compiler might transform this source:) 835 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1894 575 (char* a = new char[10];) 575 SB525 1939 675 (for \(i = 10; i < 20; i++\) {) 675 SB525 1984 500 (    ...a[i - j]...};) 500 SB525 2036 100 (/* a) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font625 2031 213 ( is dead here) 213 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font838 2036 75 ( */) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2108 371 (into the equivalent of:) 371 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2181 575 (char* a = new char[10];) 575 SB525 2226 425 (char* p = a + 10;) 425 SB525 2271 475 (char* end = p + 20;) 475 SB525 2323 100 (/* a) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font625 2318 213 ( is dead here) 213 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font838 2323 75 ( */) 75 SB525 2368 550 (for \(; p < end; p++\) {) 550 SB525 2413 475 (    ...*\(p - j\)...}) 475 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2485 272 (Inside the loop, ) 272 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font647 2490 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font672 2485 669 ( always points past the end of the array ) 669 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1341 2490 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1366 2485 583 (. The code generator or the calling) 583 SB375 2537 740 (sequence may cause the register containing ) 740 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1115 2542 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1140 2537 820 ( to be reused, leaving no pointer that points at or) 820 SB375 2589 982 (into the object and allowing it to be collected prematurely.) 982 SB435 2639 1396 (This problem is not academic\227many commercial compilers perform these sorts of) 1396 SB375 2689 1580 (optimizations. Users of the current Boehm and Bartlett collectors are responsible for avoiding) 1580 SB375 2739 1590 (such situations themselves, and some conservative programmers disable optimization entirely.) 1590 SB375 2789 1298 (Though the problem appears to be rare in practice, it needs a robust solution.) 1298 SB1209 3069 42 (43) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font0 0 0 fC375 269 74 (11.1) 74 SB449 269 202 (. A solution) 202 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 344 1581 (In this section, we'll sketch a solution to code-generator safety that's appropriate for collectors) 1581 SB375 394 1571 (that scan the stacks and registers conservatively, interpreting each word as a possible interior) 1571 SB375 444 131 (pointer.) 131 SB435 494 66 (Let ) 66 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font501 499 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font526 494 792 ( be a pointer-valued source expression, and let ) 792 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1318 499 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1343 494 618 ( be a dereferencing expression of the) 618 SB375 546 92 (form ) 92 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font467 551 100 (p[i]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font567 546 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font589 551 50 (*p) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font639 546 68 (, or ) 68 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font707 551 100 (p->f) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font807 546 1039 (. The compiler must ensure that throughout the evaluation of ) 1039 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1846 551 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1871 546 109 (, some) 109 SB375 598 970 (reachable pointer \(possibly in a register\) points at or into ) 970 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1345 603 50 (*p) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1395 598 483 (. The compiler can meet this) 483 SB375 650 655 (constraint by extending the lifetime of ) 655 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1030 655 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1055 650 968 ('s value in the generated object code to include every load) 968 SB375 702 625 (and store to an address derived from ) 625 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1000 707 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1025 702 291 (. For example, if ) 291 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1316 707 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1341 702 631 ( is in a register, the compiler couldn't) 631 SB375 754 1025 (reuse that register until a load from an address derived from ) 1025 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1400 759 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1425 754 190 ( completes.) 190 SB435 806 1574 (Let's look at how a traditional compiler might implement this, assuming it generates code for) 1574 SB375 856 1266 (one function at a time and does no inter-procedural optimization. Define a ) 1266 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1641 856 210 (base pointer) 210 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1851 856 108 ( in the) 108 SB375 906 1605 (compiler's intermediate code to be a pointer-valued variable with no reaching definitions or the) 1605 SB375 956 901 (pointer-valued result of a function call or load, and a ) 901 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1276 956 260 (derived pointer) 260 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1536 956 454 ( to be any pointer resulting) 454 SB375 1006 1630 (from address arithmetic on a base pointer or another derived pointer. Intermediate address, load,) 1630 SB375 1056 1562 (and store operations can be annotated with the base pointers from which their arguments are) 1562 SB375 1106 1348 (derived. For example, consider this intermediate code for the source expression ) 1348 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1723 1111 200 (a[i - j]) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1923 1106 12 (:) 12 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1181 375 (t1 = a + i, {a}) 375 SB525 1226 400 (t2 = t1 - j, {a}) 400 SB525 1271 425 (x  = load t2, {a}) 425 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1343 424 (The address temporaries ) 424 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font799 1348 50 (t1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font849 1343 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font933 1348 50 (t2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font983 1343 799 ( and the load are derived from the base pointer ) 799 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1782 1348 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1807 1343 88 (. The) 88 SB375 1395 1479 (annotations must in general be sets, since a derived pointer may have multiple reaching) 1479 SB375 1445 192 (definitions:) 192 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1518 100 (if e) 100 SB525 1563 375 (    t1 = a, {a}) 375 SB525 1608 100 (else) 100 SB525 1653 375 (    t1 = b, {b}) 375 SB525 1698 475 (t2 = t1 + i, {a, b}) 475 SB525 1743 500 (x  = load t2, {a, b}) 500 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1815 296 (The definition of ) 296 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font671 1820 50 (t2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font721 1815 559 ( has two reaching definitions for ) 559 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1280 1820 50 (t1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1330 1815 405 (, so it is annotated with ) 405 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1735 1820 150 ({a, b}) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1885 1815 11 (.) 11 SB435 1867 1569 (The compiler's live-variable analysis can treat the annotated base pointers of loads and stores) 1569 SB375 1917 1617 (as uses of those pointers, effectively extending the live ranges of the base pointers to include the) 1617 SB375 1967 1634 (loads and stores. Once the loads and stores have been annotated with their bases, the annotations) 1634 SB375 2017 1618 (of address temporaries can be discarded, and the annotations of the loads and stores will remain) 1618 SB375 2067 1509 (valid even after traditional optimizations. The compiler must be careful to ensure that the) 1509 SB375 2117 1536 (extended live ranges of base pointers are observed by the later phases of register allocation,) 1536 SB375 2167 1027 (instruction selection, scheduling, and peephole optimization.) 1027 SB435 2217 1589 (Suppose the source program creates a derived pointer pointing outside of its referenced object:) 1589 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2290 575 (char* a = new char[10];) 575 SB525 2335 275 (a = a + 12;) 275 SB525 2380 75 (...) 75 SB525 2425 275 (c = a[-12];) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2497 1613 (The behavior of such programs is explicitly undefined under the ANSI C standard and the draft) 1613 SB375 2547 1610 (C++ standard, so the compiler is not obligated to maintain code-generator safety. It can assume) 1610 SB375 2597 1626 (that a pointer-valued source expression points at or into the object referenced by the expression's) 1626 SB375 2647 359 (original base pointer.) 359 SB435 2697 679 (Extending the lifetime of a base pointer ) 679 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1114 2702 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1139 2697 796 ( isn't required if all pointers derived from it are) 796 SB375 2749 415 (guaranteed to point into ) 415 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font790 2754 50 (*p) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font840 2749 412 (. Consider this example:) 412 SB1209 3069 42 (44) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font0 0 0 fC525 267 825 (struct S {int i; char a[10];} *s;) 825 SB525 312 325 (...s->a[i]...) 325 SB525 364 100 (/* s) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font625 359 213 ( is dead here) 213 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font838 364 75 ( */) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 436 960 (A valid \(but suboptimal\) code sequence for the R3000 is:) 960 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 516 550 (addiu $s, $s, 4    /* ) 550 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1075 511 282 (add the offset of ) 282 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1357 516 100 (a */) 100 SB525 568 550 (addu  $s, $s, $i   /* ) 550 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1075 563 182 (index into ) 182 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1257 568 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1282 563 97 ( with ) 97 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1379 568 100 (i */) 100 SB525 620 550 (lb    $r, 0\($s\)    /* ) 550 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1075 615 215 (load the byte) 215 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1290 620 75 ( */) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 692 474 (This sequence is safe, since ) 474 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font849 697 50 ($s) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font899 692 588 ( always points at or into the object ) 588 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1487 697 50 (*s) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1537 692 11 (.) 11 SB435 744 1541 (Extending the live ranges of base pointers has little impact on the quality of code generated) 1541 SB375 794 1024 (for modern RISC architectures. In the common cases, either ) 1024 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1399 799 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1424 794 438 ( is live at the end of all its) 438 SB375 846 1588 (dereferencing expressions, or else the temporary pointers created by the expressions point into) 1588 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 901 50 (*p) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font425 896 218 (. Only when ) 218 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font643 901 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font668 896 1227 ( is dead at the end of a dereferencing expression must the code generator) 1227 SB375 948 1131 (consider extending its live range. For a single expression based on ) 1131 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1506 953 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1531 948 280 (, this may cause ) 280 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1811 953 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1836 948 162 ('s register) 162 SB375 1000 1616 (to be retained for a few extra instructions, and only in rare situations would this cause a register) 1616 SB375 1050 490 (spill. For an optimized loop, ) 490 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font865 1055 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font890 1050 1129 ('s register could either be retained for the duration of the loop or, if) 1129 SB375 1102 1446 (there aren't enough registers, stored in a stack temporary at the beginning of the loop.) 1446 SB435 1152 1554 (Safety is easy to implement in a code generator written from scratch. We used this approach) 1554 SB375 1202 1642 (several years ago to add GC-safety to a better-than-pcc-quality Modula-2+ compiler implemented) 1642 SB375 1252 1534 (at SRC, and it took less than 50 lines of additional code. Obviously, retrofitting an existing) 1534 SB375 1302 1573 (optimizing compiler could be harder, though it should be only a small part of the total cost of) 1573 SB375 1352 883 (adding garbage collection to a C++ implementation.) 883 SB435 1402 1425 (Our approach to code-generator safety is based on that described by Boehm [92], but) 1425 SB375 1452 1534 (somewhat simpler. Their main concern was how to use C as an intermediate code for other) 1534 SB375 1502 1579 (compilers, so they worried about handling source not conforming to the ANSI standard. They) 1579 SB375 1552 1583 (also assumed that target garbage collectors might not handle interior pointers, requiring more) 1583 SB375 1602 837 (careful handling of base pointers by the compiler.) 837 SB435 1652 1550 (Diwan et al. describe an approach suitable for totally precise copying collectors [Diwan 92].) 1550 SB375 1702 1647 (Their scheme is considerably more complicated to implement in the presence of optimization, but) 1647 SB375 1752 1565 (it allows collectors to relocate any object. The approach described here, since it considers the) 1565 SB375 1802 1500 (stacks and registers to contain ambiguous roots, requires the use of partially conservative) 1500 SB375 1852 912 (collectors such as Bartlett's mostly copying algorithm.) 912 SB435 1902 1518 (Finally, researchers working on smart pointers have tried to provide code-generator safety) 1518 SB375 1952 1537 (purely at the source level without modifying the compiler [Detlefs 92]. In general, this isn't) 1537 SB375 2002 1544 (possible without increasing the natural size of pointers, relying on details about a particular) 1544 SB375 2052 1259 (implementation's compiler, or relying on the vaguely specified, inefficient ) 1259 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1634 2057 200 (volatile) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1834 2052 81 ( type) 81 SB375 2104 152 (attribute.) 152 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2204 74 (11.2) 74 SB449 2204 309 (. Unsafe libraries) 309 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2279 1564 (Our proposal for C++ garbage collection emphasizes coexistence with existing non-collected) 1564 SB375 2329 1592 (libraries written in C++ and other languages. In particular, we feel it's very important to allow) 1592 SB375 2379 781 (collected objects to be passed to such libraries.) 781 SB435 2429 1516 (Unfortunately, it is unlikely that all or even most such libraries will be compiled with safe) 1516 SB375 2479 1597 (code generators in the near future. A programmer who writes in the safe subset and uses a safe) 1597 SB375 2529 1643 (C++ compiler may still have problems if he must use a library compiled with an unsafe compiler.) 1643 SB435 2579 1453 (Luckily, experience with the Boehm collectors indicates that in practice, lack of safely) 1453 SB375 2629 1636 (compiled libraries may not be a serious problem. Objects being manipulated by a function almost) 1636 SB375 2679 1545 (always have a base pointer stored somewhere, either in the heap or in a caller of the current) 1545 SB375 2729 1621 (function. Further, since objects created and managed by the existing libraries will be in the non-) 1621 SB375 2779 1638 (collected heap, the only vulnerable collected objects are those created by clients and passed to the) 1638 SB375 2829 1336 (libraries as uninterpreted \223client data\224. Since the libraries view such objects as ) 1336 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1711 2834 125 (void*) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1836 2829 158 ( pointers,) 158 SB375 2881 1482 (they won't be dereferencing them, and unsafe addressing expressions won't be executed.) 1482 SB1209 3069 42 (45) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 1487 (Obviously, conservative programmers won't be completely satisfied with assurances that) 1487 SB375 319 1623 (problems will be \223rare\224. Ideally, we would give them 100% confidence. Until garbage collection) 1623 SB375 369 1595 (is accepted as an indispensable tool, however, many vendors will see little need to provide safe) 1595 SB375 419 1530 (compilers and safely compiled libraries, especially for languages other than C++. But even) 1530 SB375 469 1623 (without safely compiled libraries, we think garbage collection will greatly decrease the total cost) 1623 SB375 519 1597 (of storage bugs; we think most programmers would rather deal with extremely infrequent bugs) 1597 SB375 569 1628 (caused by unsafe libraries than with the very frequent storage bugs and design problems they see) 1628 SB375 619 560 (today without garbage collection.) 560 SB1209 3069 42 (46) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 50 (12) 50 SB425 319 370 (. Standardization) 370 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 1572 (Before C++ garbage collection can be widely used, there must be a standard that vendors and) 1572 SB375 453 1625 (programmers can rely on. Programmers want assurance they're not tied to a particular vendor or) 1625 SB375 503 1540 (platform, and vendors want assurance that programmers won't view garbage collection as a) 1540 SB375 553 1475 (vendor-specific language extension. Initially, the standard will most likely be a de facto) 1475 SB375 603 1600 (agreement among the few adventurous vendors who might risk providing garbage collection to) 1600 SB375 653 1569 (their users. But eventually, garbage collection will have to be included in the ANSI standard.) 1569 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 753 74 (12.1) 74 SB449 753 466 (. What should be included) 466 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 828 940 (The standard should include the following components:) 940 SB525 903 528 (the language interface \(section ) 528 SB1053 903 21 (4) 21 SB1074 903 26 (\);) 26 SB525 953 1157 (the specification of object clean-up, including the standard interface ) 1157 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1682 958 325 (WeakPointer.h) 325 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font600 1005 143 (\(section ) 143 SB743 1005 21 (5) 21 SB764 1005 250 ( and appendix ) 250 SB1014 1005 23 (F) 23 SB1037 1005 26 (\);) 26 SB525 1055 605 (the definition of GC-safety \(section ) 605 SB1130 1055 21 (6) 21 SB1151 1055 25 (\).) 25 SB375 1130 1629 (The safe subset is not required to use garbage collection, but for those programmers who want to) 1629 SB375 1180 1557 (use the safe subset, its definition should be standardized to allow portability. The safe-subset) 1557 SB375 1230 415 (standard should include:) 415 SB525 1305 679 (the definition of the safe subset \(section ) 679 SB1204 1305 21 (7) 21 SB1225 1305 26 (\);) 26 SB525 1355 393 (the standard interfaces ) 393 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font918 1360 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1043 1355 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1065 1360 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1165 1355 95 (, and ) 95 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1260 1360 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1435 1355 222 ( \(appendices ) 222 SB1657 1355 28 (C) 28 SB1685 1355 22 (, ) 22 SB1707 1355 30 (D) 30 SB1737 1355 95 (, and ) 95 SB1832 1355 26 (E) 26 SB1858 1355 25 (\).) 25 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1457 74 (12.2) 74 SB449 1457 470 (. What should be excluded) 470 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1532 1576 (As part of our system-level approach to adding collection to C++, we've discussed quite a few) 1576 SB375 1582 1632 (implementation issues. While implementation issues are important to consider when designing a) 1632 SB375 1632 1608 (programming language, the final language design should leave implementors as much freedom) 1608 SB375 1682 887 (as possible to best meet the needs of their customers.) 887 SB435 1732 1416 (The following implementation issues should be explicitly excluded from a standard:) 1416 SB525 1807 624 (requirements for specific algorithms;) 624 SB525 1857 1008 (how C++ garbage collection interacts with other languages;) 1008 SB525 1907 827 (performance specifications of garbage collection;) 827 SB525 1957 687 (how to implement code-generator safety.) 687 SB375 2032 1614 (The standard should not specify particular collector algorithms. No single algorithm is ideal for) 1614 SB375 2082 1588 (all programs, and we want to allow vendors and researchers as much flexibility as possible for) 1588 SB375 2132 1644 (designing new algorithms. The GC-safety rules let programmers write portable programs without) 1644 SB375 2182 807 (relying on particular collector implementations.) 807 SB435 2232 1453 (In general, a C++ language standard can't specify how C++ should interact with other) 1453 SB375 2282 1620 (languages, since it doesn't have control over those languages. Those languages weren't designed) 1620 SB375 2332 1572 (or implemented with collection in mind, so there is no way to ensure that implementations of) 1572 SB375 2382 1605 (those languages will be compatible with particular implementations of collection. Our proposal) 1605 SB375 2432 1620 (allows straightforward collector implementations that should be compatible with many common) 1620 SB375 2482 1643 (language implementations. But the degree of compatibility with other languages must necessarily) 1643 SB375 2532 1421 (depend on which collector algorithm has been chosen by the C++ vendor and on the) 1421 SB375 2582 1516 (implementations of the other languages. C++ vendors \(particularly those who also offer C) 1516 SB375 2632 1481 (compilers\) may choose to sacrifice some general compatibility in favor of more efficient) 1481 SB375 2682 368 (collection algorithms.) 368 SB435 2732 1587 ( Performance specifications of garbage collection \(that is, space and time usage\) should not be) 1587 SB375 2782 1588 (included in the standard, just as the current draft standard does not specify the performance of) 1588 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2837 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2832 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font534 2837 150 (delete) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font684 2832 1261 ( \(or any other part of the language, for that matter\). To date, no one knows) 1261 SB1209 3069 42 (47) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 1547 (how to write such a specification that is helpful to programmers, feasible to implement, and) 1547 SB375 319 1270 (flexible enough to allow different implementations of storage management.) 1270 SB435 369 1409 (Finally, as with all issues of compiler implementation, how code-generator safety is) 1409 SB375 419 888 (implemented should not be included in the standard.) 888 SB1209 3069 42 (48) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 50 (13) 50 SB425 319 819 (. Summary of implementation changes) 819 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 1610 (Here's a summary of the changes that must be made to current C++ implementations to support) 1610 SB375 453 228 (this proposal.) 228 SB435 503 547 (The language interface requires:) 547 SB525 578 238 (providing the ) 238 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font763 583 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font813 578 165 ( keyword,) 165 SB525 630 168 (changing ) 168 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font693 635 125 (new T) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font818 630 629 ( to call the collector's allocator when ) 629 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1447 635 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1472 630 80 ( is a ) 80 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1552 635 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1602 630 92 ( type,) 92 SB525 682 168 (changing ) 168 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font693 687 200 (delete e) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font893 682 447 ( to call the collector when ) 447 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1340 687 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1365 682 467 ( points at a collected object.) 467 SB375 759 416 (The safe subset requires:) 416 SB525 834 175 (providing ) 175 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font700 839 300 (#pragma safe) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1000 834 11 (,) 11 SB525 886 1242 (adding a \223safe\224 boolean attribute to names in the compiler's symbol table,) 1242 SB525 936 411 (10 compile-time checks,) 411 SB525 986 314 (6 run-time checks,) 314 SB525 1036 391 (2 compiler restrictions.) 391 SB375 1111 1604 (Both the language interface and the safe subset can be implemented as localized changes to the) 1604 SB375 1161 349 (compiler's front end.) 349 SB435 1211 1082 (The compiler must be changed to provide code-generator safety.) 1082 SB435 1261 1422 (The sources to the Boehm and Bartlett collectors are freely available for unrestricted) 1422 SB375 1311 275 (commercial use.) 275 SB1209 3069 42 (49) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 50 (14) 50 SB425 319 264 (. Conclusion) 264 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 1634 (For better or worse, use of C++ will surely increase over the next many years. Of all the different) 1634 SB375 453 1647 (ways studied by researchers for improving programmer productivity, adding garbage collection to) 1647 SB375 503 742 (C++ could give a big bang for a small buck.) 742 SB435 553 1589 (Researchers have been touting the virtues of garbage collection for three decades, and it's time) 1589 SB375 603 1612 (for us to put up or shut up. To that end, we've presented a two-part proposal. The first part adds) 1612 SB375 653 1539 (garbage collection to C++, and the second part defines an optional safe subset that enforces) 1539 SB375 703 1565 (correct, portable use of garbage collection and precludes storage bugs. Though both parts are) 1565 SB375 753 1629 (important, garbage collection by itself is so valuable that we think near-term efforts should focus) 1629 SB375 803 1620 (on it, rather than the safe subset. Once collection is accepted, it will be easy enough to provide a) 1620 SB375 853 559 (safe subset for those who want it.) 559 SB435 903 1516 (We've only started the long chicken-and-egg process of providing C++ programmers with) 1516 SB375 953 1610 (safe garbage collection. C and C++ programmers tend to be conservative, and experience based) 1610 SB375 1003 1555 (on other programming languages doesn't impress them. \(It took over a decade for static type) 1555 SB375 1053 1516 (safety to be accepted by C programmers.\) Most commercial programmers won't use a new) 1516 SB375 1103 1591 (language tool until it's widely available on several platforms, but most vendors are reluctant to) 1591 SB375 1153 1533 (offer new tools until there is a demonstrated demand for them and there is a corresponding) 1533 SB375 1203 1634 (standard. Standards committees are reluctant to standardize technology that isn't yet in wide use.) 1634 SB375 1253 383 (There is no free lunch.) 383 SB32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font375 1462 389 (Acknowledgments) 389 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1571 1256 (Al Dosser and Joel Bartlett helped us early on with the language interface.) 1256 SB375 1621 1618 (Kelvin Don Nilsen and Jerry Schwarz prodded us into thinking more carefully about GC-safety.) 1618 SB375 1671 968 (Hans Boehm was a patient sounding board for new ideas.) 968 SB375 1721 1016 (Thomas Breuel sharpened our arguments with lively debate.) 1016 SB375 1771 1022 (Dain Samples helped us understand his alternative proposal.) 1022 SB375 1821 1278 (Bjarne Stroustrup provided helpful feedback on the likely evolution of C++.) 1278 SB375 1871 573 (Cynthia Hibbard edited the paper.) 573 SB1209 3069 42 (50) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 230 (References) 230 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 183 ([Appel 91]) 183 SB645 403 513 (Andrew W. Appel and Kai Li.) 513 SB645 453 774 (Virtual memory primitives for user programs.) 774 SB645 503 47 (In ) 47 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font692 503 1295 (Fourth International Conference on Architectural Support for Programming) 1295 SB705 553 608 (Languages and Operating Systems, ) 608 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1313 553 95 (1991.) 95 SB375 628 208 ([Bartlett 89]) 208 SB645 628 260 (Joel F. Bartlett.) 260 SB645 678 1111 (Mostly-copying garbage collection picks up generations and C++.) 1111 SB645 728 1261 (Western Research Laboratory Technical Report TN-12, Digital Equipment) 1261 SB705 778 321 (Corporation, 1989.) 321 SB375 853 201 ([Boehm 91]) 201 SB645 853 810 (Hans-J. Boehm, Alan J. Demers, Scott Shenker.) 810 SB645 903 585 (Mostly parallel garbage collection.) 585 SB645 953 47 (In ) 47 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font692 953 1161 (Proceedings of the ACM SIGPLAN '91 Conference on Programming) 1161 SB705 1003 670 (Language Design and Implementation, ) 670 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1375 1003 95 (1991.) 95 SB375 1078 201 ([Boehm 92]) 201 SB645 1078 569 (Hans-J. Boehm and David Chase.) 569 SB645 1128 889 (A proposal for garbage-collector-safe C compilation.) 889 SB645 1178 26 (T) 26 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font671 1178 651 (he Journal of C Language Translation) 651 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1322 1178 531 ( 4\(2\):126-141, December 1992.) 531 SB375 1253 201 ([Boehm 93]) 201 SB645 1253 373 (Hans-Juergen Boehm.) 373 SB645 1303 836 (Space Efficient Conservative Garbage Collection.) 836 SB645 1353 226 (To appear in ) 226 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font871 1353 916 (Proceedings of the ACM SIGPLAN '93 Conference on) 916 SB705 1403 915 (Programming Language Design and Implementation, ) 915 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1620 1403 95 (1993.) 95 SB375 1478 271 ([CenterLine 92]) 271 SB645 1528 834 (CenterLine Software, Cambridge, Massachusetts.) 834 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font645 1578 785 (CodeCenter, The Programming Environment, ) 785 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1430 1578 95 (1992.) 95 SB375 1653 279 ([Codewright 93]) 279 SB645 1703 697 (Codewright's Toolworks, San Pedro, CA.) 697 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font645 1753 1045 (Alloc -GC: The garbage collecting replacement for malloc\(\), ) 1045 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1690 1753 95 (1993.) 95 SB375 1828 200 ([Detlefs 90]) 200 SB645 1828 290 (David L. Detlefs.) 290 SB645 1878 667 (Concurrent garbage collection for C++.) 667 SB645 1928 1296 (CMU-CS-90-119, School of Computer Science, Carnegie Mellon University,) 1296 SB705 1978 95 (1990.) 95 SB375 2053 200 ([Detlefs 92]) 200 SB645 2053 290 (David L. Detlefs.) 290 SB645 2103 963 (Garbage collection and run-time typing as a C++ library.) 963 SB645 2153 47 (In ) 47 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font692 2153 841 (Proceedings of the 1992 Usenix C++ Conference) 841 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1533 2153 117 (, 1992.) 117 SB375 2228 281 ([DeTreville 90a]) 281 SB645 2278 283 (John DeTreville.) 283 SB645 2328 653 (Heap usage in the Topaz environment.) 653 SB645 2378 1271 (Systems Research Center Report 63, Digital Equipment Corporation, 1990.) 1271 SB375 2453 282 ([DeTreville 90b]) 282 SB645 2503 283 (John DeTreville.) 283 SB645 2553 1053 (Experience with concurrent garbage collectors for Modula-2+.) 1053 SB645 2603 1271 (Systems Research Center Report 64, Digital Equipment Corporation, 1990.) 1271 SB375 2678 193 ([Diwan 92]) 193 SB645 2678 803 (Amer Diwan, Eliot Moss, and Richard Hudson.) 803 SB645 2728 1177 (Compiler support for garbage collection in a statically typed language) 1177 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1822 2728 11 (.) 11 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font645 2778 47 (In ) 47 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font692 2778 1161 (Proceedings of the ACM SIGPLAN '92 Conference on Programming) 1161 SB705 2828 648 (Language Design and Implementation) 648 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1353 2828 117 (, 1992.) 117 SB1209 3069 42 (51) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 144 ([Dix 93]) 144 SB645 269 533 (Trevor I. Dix and Tam T. Lien.) 533 SB645 319 900 (Safe-C for introductory undergraduate programming.) 900 SB645 369 226 (To appear in ) 226 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font871 369 864 (The 16th Australian Computer Science Conference) 864 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1735 369 117 (, 1993.) 117 SB375 444 216 ([Edelson 91]) 216 SB645 444 444 (D. R. Edelson and I. Pohl.) 444 SB645 494 914 (Smart pointers: They're smart but they're not pointers.) 914 SB645 544 47 (In ) 47 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font692 544 841 (Proceedings of the 1991 Usenix C++ Conference) 841 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1533 544 229 (, April, 1991.) 229 SB375 619 216 ([Edelson 92]) 216 SB645 619 319 (Daniel R. Edelson.) 319 SB645 669 722 (Precompiling C++ for Garbage Collection.) 722 SB645 719 625 (In Y. Bekkers and J. Choen, editors, ) 625 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1270 719 616 (Memory Management, International) 616 SB705 769 373 (Workshop IWMM 92. ) 373 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1078 769 393 (Springer-Verlag, 1992.) 393 SB375 844 159 ([Ellis 88]) 159 SB645 844 764 (John R. Ellis, Kai Li, and Andrew W. Appel.) 764 SB645 894 959 (Real-time concurrent collection on stock multiprocessors) 959 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1604 894 11 (.) 11 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font645 944 1271 (Systems Research Center Report 25, Digital Equipment Corporation, 1988.) 1271 SB375 1019 159 ([Ellis 91]) 159 SB645 1019 691 (Margaret A. Ellis and Bjarne Stroustrup.) 691 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font645 1069 677 (The Annotated C++ Reference Manual.) 677 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font645 1119 392 (Addison Wesley, 1990.) 392 SB375 1194 190 ([Ginter 91]) 190 SB645 1194 266 (Andrew Ginter.) 266 SB645 1244 1370 (Design alternatives for a cooperative garbage collector for the C++ programming) 1370 SB705 1294 164 (language.) 164 SB645 1344 1357 (Research Report No. 91/417/01, Department of Computer Science, University of) 1357 SB705 1394 269 (Calgaray, 1992.) 269 SB375 1469 182 ([Hayes 92]) 182 SB645 1469 218 (Barry Hayes.) 218 SB645 1519 637 (Finalization in the collector interface.) 637 SB645 1569 625 (In Y. Bekkers and J. Choen, editors, ) 625 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1270 1569 616 (Memory Management, International) 616 SB705 1619 373 (Workshop IWMM 92. ) 373 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1078 1619 393 (Springer-Verlag, 1992.) 393 SB375 1694 228 ([McJones 87]) 228 SB645 1694 640 (Paul R. McJones and Garret F. Swart.) 640 SB645 1744 1222 (Evolving the UNIX system interface to support multithreaded programs.) 1222 SB645 1794 1271 (Systems Research Center Report 21, Digital Equipment Corporation, 1987.) 1271 SB375 1869 158 ([Pure 92]) 158 SB645 1869 626 (Pure Software, Los Altos, California.) 626 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font645 1919 436 (Purify Version 1.1 Beta A) 436 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1081 1919 117 (, 1992.) 117 SB375 1994 199 ([Nelson 91]) 199 SB645 1994 344 (Greg Nelson, editor.) 344 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font645 2044 648 (Systems Programming with Modula-3.) 648 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font645 2094 338 (Prentice Hall, 1991.) 338 SB375 2169 203 ([Owicki 81]) 203 SB645 2169 245 (Susan Owicki.) 245 SB645 2219 769 (Making the world safe for garbage collection.) 769 SB645 2269 47 (In ) 47 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font692 2269 1280 (Eighth Annual ACM Symposium on Principles of Programming Languages,) 1280 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font705 2319 95 (1991.) 95 SB375 2394 222 ([Rovner 85a]) 222 SB645 2394 219 (Paul Rovner.) 219 SB645 2444 1308 (On adding garbage collection and runtime types to a strongly typed, statically) 1308 SB705 2494 514 (checked, concurrent language.) 514 SB645 2544 969 (Xerox Palo Alto Research Center report CSL-84-7, 1985.) 969 SB375 2619 223 ([Rovner 85b]) 223 SB645 2619 691 (Paul Rovner, Roy Levin, and John Wick.) 691 SB645 2669 1057 (On extending Modula-2 for building large, integrated systems.) 1057 SB645 2719 1250 (Systems Research Center Report 3, Digital Equipment Corporation, 1985.) 1250 SB1209 3069 42 (52) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC375 269 223 ([Samples 92]) 223 SB645 269 299 (A. Dain Samples.) 299 SB645 319 363 (GC-cooperative C++.) 363 SB645 369 625 (In Y. Bekkers and J. Choen, editors, ) 625 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1270 369 616 (Memory Management, International) 616 SB705 419 373 (Workshop IWMM 92. ) 373 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1078 419 393 (Springer-Verlag, 1992.) 393 SB375 494 174 ([Shaw 87]) 174 SB645 494 279 (Robert A. Shaw.) 279 SB645 544 1028 (Improving garbage collector performance in virtual memory.) 1028 SB645 594 1278 (Technical Report CSL-TR-87-323, Computer Systems Laboratory, Stanford) 1278 SB705 644 292 (University, 1987.) 292 SB375 719 200 ([Steffen 92]) 200 SB645 719 301 (Joseph L. Steffen.) 301 SB645 769 924 (Adding run-time checking to the Portable C Compiler.) 924 SB645 819 1082 (Software\227Practice and Experience 22\(4\):305-316, April 1992..) 1082 SB375 894 257 ([Stroustrup 91]) 257 SB645 894 310 (Bjarne Stroustrup.) 310 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font645 944 873 (The C++ Programming Language, Second Edition.) 873 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font645 994 1024 (Addison-Wesley, reprinted with corrections December 1991.) 1024 SB375 1069 257 ([Stroustrup 92]) 257 SB645 1069 652 (Bjarne Stroustrup and Dmitry Lenkov.) 652 SB645 1119 781 (Run-time type identification for C++ \(revised\)) 781 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1426 1119 11 (.) 11 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font645 1169 47 (In ) 47 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font692 1169 841 (Proceedings of the 1992 Usenix C++ Conference) 841 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1533 1169 117 (, 1992.) 117 SB375 1244 144 ([Yip 91]) 144 SB645 1244 212 (G. May Yip.) 212 SB645 1294 1327 (Incremental, generational, mostly-copying garbage collection in uncooperative) 1327 SB705 1344 241 (environments.) 241 SB645 1394 1210 (Western Research Laboratory Research Report 91/8, Digital Equipment) 1210 SB705 1444 321 (Corporation, 1991.) 321 SB375 1519 163 ([Zorn 92]) 163 SB645 1519 268 (Benjamin Zorn.) 268 SB645 1569 910 (The measured cost of conservative garbage collection.) 910 SB645 1619 1339 (Technical Report CU-CS-573-92, Department of Computer Science, University) 1339 SB705 1669 503 (of Colorado at Boulder, 1992.) 503 SB1209 3069 42 (53) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SMEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 884 (Appendix A: Restricting interior pointers) 884 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 1553 (Our proposal's language interface and safe subset allow programs to create arbitrary interior) 1553 SB375 453 1586 (pointers \(pointers into the middle of objects\). In early designs, we prohibited interior pointers,) 1586 SB375 503 1493 (believing that would significantly improve the performance of garbage collection. But as) 1493 SB375 553 344 (discussed in section ) 344 SB719 553 74 (10.1) 74 SB793 553 1083 (, we now believe the performance improvement to be negligible,) 1083 SB375 603 1447 (compared to the significant costs of outlawing interior pointers and changing existing) 1447 SB375 653 1247 (implementations to achieve the corresponding performance improvement.) 1247 SB435 703 1457 (This appendix presents our original design for prohibiting interior pointers and taking) 1457 SB375 753 488 (advantage of the prohibition.) 488 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 853 326 (A.1. Base pointers) 326 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 928 1064 (In a GC-safe program, all pointers to collected objects must be ) 1064 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1439 928 226 (base pointers) 226 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1665 928 306 (. A base pointer is) 306 SB375 978 212 (the result of ) 212 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font587 983 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font662 978 424 ( or a legal widening cast.) 424 SB435 1030 1470 (Unfortunately, this definition of base pointer can still result in pointers that address the) 1470 SB375 1080 594 (middle of objects. Consider a class ) 594 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font969 1085 25 (C) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font994 1080 239 ( derived from ) 239 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1233 1085 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1258 1080 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1342 1085 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1367 1080 12 (:) 12 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1155 350 (class A {...};) 350 SB525 1200 350 (class B {...};) 350 SB525 1245 500 (class C: A, B {...};) 500 SB525 1290 275 (C* c = ...;) 275 SB525 1335 350 (B* b = \(B*\) c;) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1407 182 (Assuming ) 182 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font557 1412 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font582 1407 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font604 1412 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font629 1407 95 (, and ) 95 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font724 1412 25 (C) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font749 1407 1243 ( have virtual functions, a typical implementation will lay out instances of ) 1243 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1992 1412 25 (C) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1459 180 (as follows:) 180 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font798 1548 131 (C's vptr) 131 SB798 1623 218 (A's members) 218 SB798 1701 216 (C's members) 216 SB798 1773 130 (B's vptr) 130 SB804 1851 215 (B's members) 215 SB0 lc0 lj0 0 0 pC6 1 SP463 374 778 1539 BSn1 lc1 ljgs 465 1 778 1614 CB778 1614 M 464 0 1 PPSngrgs 465 1 778 1689 CB778 1689 M 464 0 1 PPSngrgs 465 1 778 1764 CB778 1764 M 464 0 1 PPSngrgs 465 1 778 1839 CB778 1839 M 464 0 1 PPSngrgs 104 1 1262 1536 CB1262 1536 M 103 0 1 PPSngrgs 104 1 1262 1761 CB1262 1761 M 103 0 1 PPSngrgs 1 76 1313 1536 CB1313 1536 M 0 75 1 PPSngrgs 1 76 1313 1686 CB1313 1686 M 0 75 1 PPSngr32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1303 1620 21 (o) 21 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font585 1544 25 (c) 25 SBgs 130 1 624 1564 CB624 1564 M 129 0 1 PPSngrgs 54 26 709 1552 CB709 1552 M -53 13 53 12 2 PPSngr588 1769 25 (b) 25 SBgs 130 1 627 1789 CB627 1789 M 129 0 1 PPSngrgs 54 26 712 1777 CB712 1777 M -53 13 53 12 2 PPSngr32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1970 55 (\(A ) 55 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font430 1970 68 (vptr) 68 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font498 1970 885 ( is a pointer to a virtual-function table.\) The pointer ) 885 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1383 1975 25 (c) 23 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1406 1970 522 ( addresses the beginning of the) 522 SB375 2022 194 (object, and ) 194 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font569 2027 25 (b) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font594 2022 541 (, the result of the widening cast ) 541 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1135 2027 175 (\(B*\) c,) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1310 2022 270 ( points at offset ) 270 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1580 2022 21 (o) 21 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1601 2022 343 ( in the middle of the) 343 SB375 2074 110 (object.) 110 SB435 2124 1513 (In general, a base pointer addresses the base of an object or a sub-object of another object.) 1513 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2224 754 (A.2. A run-time representation for objects) 754 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2299 1641 (This definition of \223base pointer\224 could make it harder for the collector to follow pointers\227unlike) 1641 SB375 2349 1567 (traditional languages like Modula-3 and Lisp, a base pointer does not necessarily address the) 1567 SB375 2399 1604 (beginning of an object in the collected heap. But a simple implementation technique allows the) 1604 SB375 2449 1297 (collector to follow any base pointer efficiently. The compiler ensures that all ) 1297 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1672 2454 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1722 2449 189 ( classes are) 189 SB375 2501 1637 (represented with virtual-function-table pointers \(vptrs\), regardless of whether the classes actually) 1637 SB375 2551 379 (have virtual functions.) 379 SB435 2601 1547 (The compiler stores in each virtual-function table \(vtbl\) the offset from the beginning of the) 1547 SB375 2651 1000 (object to the slot containing the pointer to that table \(offset ) 1000 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1375 2651 21 (o) 21 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1396 2651 394 ( in the example above\).) 394 SB1209 3069 42 (55) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC795 283 131 (C's vptr) 131 SB795 358 218 (A's members) 218 SB795 433 227 ( C's members) 227 SB795 508 130 (B's vptr) 130 SB801 586 215 (B's members) 215 SB0 lc0 lj0 0 0 pC6 1 SP463 374 775 274 BSn1 lc1 ljgs 465 1 775 349 CB775 349 M 464 0 1 PPSngrgs 465 1 775 424 CB775 424 M 464 0 1 PPSngrgs 465 1 775 499 CB775 499 M 464 0 1 PPSngrgs 465 1 775 574 CB775 574 M 464 0 1 PPSngrgs 104 1 1259 271 CB1259 271 M 103 0 1 PPSngrgs 104 1 1259 496 CB1259 496 M 103 0 1 PPSngrgs 1 76 1310 271 CB1310 271 M 0 75 1 PPSngrgs 1 76 1310 421 CB1310 421 M 0 75 1 PPSngr32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1301 355 21 (o) 21 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font585 503 25 (p) 25 SBgs 130 1 624 524 CB624 524 M 129 0 1 PPSngrgs 54 26 709 512 CB709 512 M -53 13 53 12 2 PPSngrgs 284 1 1214 524 CB1214 524 M 283 0 1 PPSngrgs 54 26 1431 512 CB1431 512 M -53 13 53 12 2 PPSngr32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1517 508 21 (o) 21 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1517 583 373 (B's virtual functions...) 373 SB0 lc0 lj464 249 1497 499 BSn1 lc1 ljgs 466 1 1497 574 CB1497 574 M 465 0 1 PPSngr1497 436 126 (B's vtbl) 126 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 805 1610 (The collector is thus assured that, in a GC-safe program, every base pointer points to a vptr slot) 1610 SB375 855 622 (in some object. Given a base pointer ) 622 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font997 860 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1022 855 836 (, the collector finds the beginning of the object by) 836 SB375 907 1050 (extracting the offset from the vtbl and adding it to the pointer:) 1050 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 980 375 (p + **\(int**\) p) 375 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1052 1609 (On the MIPS processor, this takes 5 cycles, compared to the 15 cycles needed to handle general) 1609 SB375 1102 284 (interior pointers.) 284 SB435 1152 457 (A couple of details remain.) 457 SB435 1202 222 (First, a class ) 222 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font657 1207 25 (B) 23 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font680 1202 1319 ( may be a base class of many different classes, and the storage for its members) 1319 SB375 1254 1633 (may be placed at different offsets in those derived classes. So there needs to be a separate copy of) 1633 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1309 25 (B) 23 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font398 1304 1231 ('s virtual function table for each such derived class. \(For related reasons, ) 1231 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1629 1304 248 (The Annotated) 248 SB375 1356 323 (Reference Manual ) 323 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font698 1356 1112 (also suggests a different copy of the virtual function table for each) 1112 SB375 1406 664 (combination of base and derived class.\)) 664 SB435 1456 144 (Second, ) 144 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font579 1461 50 (gc) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font629 1456 1348 ( classes with no virtual functions and non-class types allocated in the heap must) 1348 SB375 1508 822 (have vptrs to empty vtbls containing the offset 0.) 822 SB435 1558 1537 (Third, we'd like the representation of ordinary structs \(classes with no base classes\) to have) 1537 SB375 1608 1631 (the same representation as C structs, which would allow such structs to be passed to C functions.) 1631 SB375 1658 1645 (Storing a vptr in the first word would ordinarily make the representation of a struct incompatible.) 1645 SB375 1708 1564 (But we can finesse that problem by changing the C++ implementation so that a pointer to an) 1564 SB375 1758 1617 (object points at the word immediately following the vptr. Thus, a C++ pointer to a struct will be) 1617 SB375 1808 609 (interpreted correctly by C functions.) 609 SB435 1858 1509 (Only the collected-heap instances of structs and non-class types need the dummy vptr. To) 1509 SB375 1908 1614 (maintain representational compatibility with C, instances that are static, automatic, members of) 1614 SB375 1958 1427 (other objects, or elements of arrays can't have a dummy vptr. Consider this example:) 1427 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2031 450 (gc struct S {...};) 450 SB525 2076 500 (struct T {S s; ...};) 500 SB525 2121 375 (typedef S A[c];) 375 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2193 861 (To maintain compatibility with C, the instances of ) 861 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1236 2198 25 (S) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1261 2193 358 ( that are members of ) 358 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1619 2198 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1644 2193 288 ( and elements of ) 288 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1932 2198 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2245 1636 (can't have vptrs. Because the safe-use rules for the collector \(enforced by the safe subset\) prohibit) 1636 SB375 2295 499 (pointers to those instances of ) 499 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font874 2300 25 (S) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font899 2295 1116 ( \(since they would be interior pointers\), the vptrs aren't needed for) 1116 SB375 2347 560 (correct operation of the collector.) 560 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2447 1044 (A.3. Extending the safe subset to prohibit interior pointers) 1044 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2522 1650 (The safe subset must be extended to prohibit creation of interior pointers. Three additional checks) 1650 SB375 2572 237 (would suffice:) 237 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 2647 529 (Use of the address-of operator ) 529 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1054 2652 25 (&) 25 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1079 2647 237 ( is prohibited.) 237 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1316 2647 205 ( Otherwise, ) 205 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1521 2652 25 (&) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1546 2647 402 ( applied to a member or) 402 SB525 2699 769 (array element would yield an interior pointer.) 769 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font525 2774 232 (The operator ) 232 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font757 2779 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font832 2774 888 ( applied to reference-containing types is disallowed.) 888 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1720 2774 224 ( Otherwise, a) 224 SB525 2826 1467 (reference in a heap object might address an object's member or an array element via an) 1467 SB525 2876 268 (interior pointer.) 268 SB1209 3069 42 (56) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font0 0 0 fC525 269 712 (A run-time check prohibits explicit use of ) 712 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1237 274 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1337 269 621 ( except when it is a base pointer to a) 621 SB525 321 514 (heap object or the operand of ) 514 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1039 326 25 (*) 25 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1064 321 48 ( or) 48 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1112 321 11 ( ) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1123 326 50 (->) 50 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1173 321 11 (.) 11 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1184 321 307 ( Otherwise, when ) 307 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1491 326 100 (this) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1591 321 299 ( gets bound to the) 299 SB525 373 1403 (address of a member object or an array element, it would be an interior pointer that) 1403 SB525 423 626 (could then be stored in a heap object.) 626 SB375 498 1547 (Since a base pointer can address a sub-object within a containing object, the run-time check) 1547 SB375 548 1620 (needs a quick way of determining whether an object offset corresponds to a valid offset of a sub-) 1620 SB375 598 1629 (object. The compiler can represent the set of valid offsets as a bit vector stored in the class's vtbl.) 1629 SB435 648 1554 (Using the same mechanism used for conservative scanning of the stacks, the run-time check) 1554 SB375 698 583 (first determines whether a pointer ) 583 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font958 703 25 (p) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font983 698 1039 ( references a heap object, and if it does, it finds the beginning) 1039 SB375 750 137 (address ) 137 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font512 755 25 (b) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font537 750 1021 ( of the object. The check then tests whether the bit for offset ) 1021 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1558 755 125 (p - b) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1683 750 318 ( is set in the vector) 318 SB375 802 1564 (of valid offsets stored in the object's vtbl. Using heap structures like those used in the Boehm) 1564 SB375 852 1195 (collector, the check would take about 18 cycles on the MIPS processor.) 1195 SB1209 3069 42 (57) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 1038 (Appendix B: Why tagged unions aren't practical) 1038 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 453 1617 (Unions containing collected pointers pose special problems for copying collectors. For example,) 1617 SB375 503 154 (consider:) 154 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 576 650 (union {int i; char* p;} u;) 650 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 648 644 (How does the collector know whether ) 644 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1019 653 25 (u) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1044 648 872 ( contains an integer or a pointer? A pointer must be) 872 SB375 700 1500 (relocated by the collector, and an integer must not. In other languages such as Cedar and) 1500 SB375 750 1582 (Modula-2+, variant records have tags indicating their current contents, but in traditional C++) 1582 SB375 800 657 (implementations, unions are untagged.) 657 SB435 850 1466 (Tagging unions in C++ isn't practical for two reasons: it can't be done efficiently while) 1466 SB375 900 1637 (conforming to C++ semantics, and it would sacrifice representational compatibility with external) 1637 SB375 950 257 (data structures.) 257 SB435 1000 1529 (Suppose that the compiler adds an implicit tag to each union and generates code to change) 1529 SB375 1050 1558 (the tag when a member is assigned. This works fine for simple assignments to members, but) 1558 SB375 1100 1609 (there doesn't seem to be any efficient method of updating the tag when a member is changed by) 1609 SB375 1150 1553 (assignment through an alias \(a pointer or reference to the member\). Consider this fragment,) 1553 SB375 1200 999 (which conforms to the ANSI C and ARM union semantics:) 999 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1323 650 (union U {int i; char* p;};) 650 SB525 1368 100 (U u;) 100 SB525 1413 350 (char** ptrToP;) 350 SB525 1510 600 (u.i = 0;            /* u) 600 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1125 1505 344 ( contains an integer ) 344 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1469 1510 100 (i */) 100 SB525 1562 575 (ptrToP = &u.p;      /* ) 575 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1100 1557 295 (create an alias to ) 295 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1395 1562 150 (u.p */) 150 SB525 1614 600 (... = u.i;          /* u) 600 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1125 1609 367 ( still contains integer ) 367 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1492 1614 100 (i */) 100 SB525 1666 575 (*ptrToP = ...;      /* ) 575 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1100 1661 117 (assign ) 117 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1217 1666 75 (u.p) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1292 1661 214 ( via the alias) 214 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1506 1666 75 ( */) 75 SB525 1718 600 (... = u.p;          /* u) 600 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1125 1713 376 ( now contains pointer ) 376 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1501 1718 100 (p */) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1840 333 (The union member ) 333 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font708 1845 75 (u.p) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font783 1840 801 ( gets changed via assignment through the alias ) 801 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1584 1845 175 (*ptrToP) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1759 1840 205 (. In general,) 205 SB375 1892 1576 (since almost any pointer could be an alias for a union member, there isn't any way a compiler) 1576 SB375 1942 886 (could generate efficient code to maintain union tags.) 886 SB435 1992 1551 (Even if tagging could be done efficiently, the tags would increase the size of unions. Unions) 1551 SB375 2042 1499 (are frequently used to access data defined by hardware devices, external file formats, and) 1499 SB375 2092 1631 (modules written in other languages \(especially C\), and increasing the size of unions would make) 1631 SB375 2142 924 (them incompatible with these external representations.) 924 SB1209 3069 42 (58) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 456 (Appendix C: Array.h) 456 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 779 (This appendix presents the standard interface ) 779 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1154 408 175 (Array.h) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1329 403 558 (, which provides safe arrays. The) 558 SB375 455 628 (interface has been tested with DEC's ) 628 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1003 455 57 (cxx) 57 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1060 455 171 ( compiler.) 171 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 543 161 (#ifndef) 161 SB600 543 207 (_Array_h_) 207 SB375 583 161 (#define) 161 SB600 583 207 (_Array_h_) 207 SB375 663 1633 (/**********************************************************************) 1633 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 755 214 (Safe Arrays) 214 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 830 1643 (The three template classes in this interface provide safe arrays, which replace built-in C++ arrays) 1643 SB375 880 700 (in the safe subset. The subscript operator ) 700 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1075 885 50 ([]) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1125 880 898 ( of these classes checks its index at run-time, causing) 898 SB375 932 784 (a checked run-time error if it is out-of-bounds.) 784 SB435 982 63 (An ) 63 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font498 987 425 (Array<type, size>) 425 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font923 982 244 ( is an array of ) 244 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1167 987 100 (size) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1267 982 215 ( elements of ) 215 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1482 987 100 (type) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1582 982 431 (; it behaves like a built-in) 431 SB375 1034 185 (C++ array.) 185 SB435 1084 41 (A ) 41 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font476 1089 350 (DynArray<type>) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font826 1084 1141 ( is a heap-allocated array whose size is chosen when it is created. A) 1141 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1141 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font575 1136 673 ( behaves like a pointer to its heap array.) 673 SB435 1188 41 (A ) 41 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font476 1193 350 (SubArray<type>) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font826 1188 1039 ( references a contiguous sub-sequence of elements in another ) 1039 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1865 1193 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1990 1188 11 (,) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1245 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font575 1240 68 (, or ) 68 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font643 1245 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font843 1240 63 (. A ) 63 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font906 1245 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1106 1240 913 ( shares elements with the other array and behaves like) 913 SB375 1292 605 (a reference combined with a length.) 605 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1392 359 (Common operations) 359 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1467 1319 (The three classes provide the following common set of operations on an array ) 1319 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1694 1472 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1719 1467 230 ( with element) 230 SB375 1519 81 (type ) 81 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font456 1524 25 (T) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font481 1519 12 (:) 12 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1594 250 (a.Number\(\)) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1641 593 (Returns the number of elements of ) 593 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1043 1646 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1068 1641 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1716 100 (a[i]) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1763 224 (Accesses the ) 224 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font674 1768 25 (i) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font699 1763 247 (-th element of ) 247 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font946 1768 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font971 1763 627 (, causing a checked run-time error if ) 627 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1598 1768 125 (i < 0) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1723 1763 46 ( or) 46 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font450 1820 375 (a.Number\(\) <= i) 375 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font825 1815 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1890 500 (a.Sub\(start, number\)) 500 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1937 172 (Returns a ) 172 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font622 1942 325 (SubArray<T> s) 325 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font947 1937 437 ( referencing the elements ) 437 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1384 1942 200 (a[start]) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1584 1937 155 ( through ) 155 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1739 1942 225 (a[start +) 225 SB450 1994 275 (number - 1]) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font725 1989 149 (; that is, ) 149 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font874 1994 500 (s.Number\(\) == number) 500 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1374 1989 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1458 1994 550 (&s[i] == &a[start + i]) 550 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font2008 1989 11 (,) 11 SB450 2041 59 (for ) 59 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font509 2046 375 (0 <= i < number) 375 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font884 2041 616 (. Causes a checked run-time error if ) 616 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1500 2046 225 (start < 0) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1725 2041 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1747 2046 250 (a.Number\(\)) 250 SB450 2098 400 (< start + number) 400 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font850 2093 68 (, or ) 68 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font918 2098 250 (number < 0) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1168 2093 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2168 300 (a.Sub\(start\)) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2215 59 (=> ) 59 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font509 2220 800 (a.Sub\(start, a.Number\(\) - start\)) 800 SB375 2290 175 (a.Sub\(\)) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2337 59 (=> ) 59 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font509 2342 500 (a.Sub\(0, a.Number\(\)\)) 500 SB375 2412 225 (a.Copy\(s\)) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2459 393 (Copies the elements of ) 393 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font843 2464 250 (SubArray s) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1093 2459 355 ( into the elements of ) 355 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1448 2464 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1473 2459 138 (; that is,) 138 SB450 2511 172 (assigning ) 172 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font622 2516 275 (a[i] = s[i]) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font897 2511 81 (, for ) 81 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font978 2516 475 (0 <= i < a.Number\(\)) 475 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1453 2511 117 (. It is a) 117 SB450 2563 435 (checked run-time error if ) 435 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font885 2568 600 (a.Number\(\) != s.Number\(\)) 600 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1485 2563 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2638 150 (a == s) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 2685 255 (Returns true if ) 255 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font705 2690 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font730 2685 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font814 2690 250 (SubArray s) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1064 2685 602 ( refer to the same elements; that is, ) 602 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1666 2690 325 (a.Number\(\) ==) 325 SB450 2742 250 (s.Number\(\)) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font700 2737 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font784 2742 350 (&a[i] == &b[i]) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1134 2737 81 (, for ) 81 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1215 2742 475 (0 <= i < a.Number\(\)) 475 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1690 2737 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2812 150 (a != s) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font435 2859 229 (equivalent to ) 229 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font664 2864 250 (! \(a == s\)) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 3069 42 (59) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font0 0 0 fC375 267 250 (a.Equal\(s\)) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 314 522 (Returns true if the elements of ) 522 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font972 319 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font997 314 486 ( are equal to the elements of ) 486 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1483 319 250 (SubArray s) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1733 314 149 (; that is, ) 149 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1882 319 50 (if) 50 SB450 371 600 (a.Number\(\) == s.Number\(\)) 600 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1050 366 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1134 371 300 (a[i] == s[i]) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1434 366 81 (, for ) 81 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1515 371 475 (0 <= i < a.Number\(\)) 475 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1990 366 11 (.) 11 SB375 443 722 (The classes provide implicit conversion of ) 722 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1097 448 150 (Arrays) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1247 443 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1331 448 225 (DynArrays) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1556 443 54 ( to ) 54 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1610 448 225 (SubArrays) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1835 443 83 (\227an) 83 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 500 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font500 495 57 ( or ) 57 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font557 500 250 (DynArray a) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font807 495 462 ( is converted by evaluating ) 462 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1269 500 175 (a.Sub\(\)) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1444 495 11 (.) 11 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 597 456 (Array-specific operations) 456 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 670 350 (Array<T, n>\(s\)) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 717 113 (Given ) 113 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font563 722 250 (SubArray s) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font813 717 313 (, constructs a new ) 313 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1126 722 175 (Array a) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1301 717 55 ( of ) 55 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1356 722 25 (n) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1381 717 616 ( elements and copies the elements of) 616 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font450 774 25 (s) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font475 769 88 ( into ) 88 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font563 774 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font588 769 125 (, using ) 125 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font713 774 225 (a.Copy\(s\)) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font938 769 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 844 175 (a1 = a2) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 891 572 (Copies the elements of a2 into a1.) 572 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 991 530 (DynArray-specific operations) 530 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1066 41 (A ) 41 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font416 1071 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font616 1066 1098 ( can be null, meaning it has no storage associated with it. A null ) 1098 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1714 1071 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1914 1066 104 ( is not) 104 SB375 1118 236 (the same as a ) 236 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font611 1123 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font811 1118 289 ( with 0 elements.) 289 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1193 350 (DynArray<T>\(\);) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1240 299 (Constructs a null ) 299 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font749 1245 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font949 1240 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1315 375 (DynArray<T>\(n\);) 375 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1362 323 (Creates a non-null ) 323 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font773 1367 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font973 1362 55 ( of ) 55 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1028 1367 25 (n) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1053 1362 171 ( elements.) 171 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1437 375 (DynArray<T>\(s\);) 375 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1484 113 (Given ) 113 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font563 1489 250 (SubArray s) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font813 1484 335 (, creates a non-null ) 335 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1148 1489 250 (DynArray d) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1398 1484 55 ( of ) 55 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1453 1489 250 (s.Number\(\)) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1703 1484 233 ( elements and) 233 SB450 1536 116 (copies ) 116 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font566 1541 25 (s) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font591 1536 88 ( into ) 88 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font679 1541 25 (d) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font704 1536 125 (, using ) 125 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font829 1541 225 (d.Copy\(s\)) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1054 1536 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1611 250 (d.IsNull\(\)) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font435 1658 255 (Returns true if ) 255 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font690 1663 25 (d) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font715 1658 128 ( is null.) 128 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1733 175 (d1 = d2) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1780 122 (Makes ) 122 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font572 1785 50 (d1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font622 1780 510 ( refer to the same elements as ) 510 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1132 1785 50 (d2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1182 1780 397 (. After the assignment, ) 397 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1579 1785 350 (d1.Number\(\) ==) 350 SB450 1837 775 (d2.Number\(\) && &d1[i] == &d2[i]) 775 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1225 1832 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1247 1837 500 (0 <= i < d2.Number\(\)) 500 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1747 1832 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1907 200 (d1 == d2) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 1954 255 (Returns true if ) 255 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font705 1959 50 (d1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font755 1954 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font839 1959 50 (d2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font889 1954 863 ( refer to the same elements or both are null; that is,) 863 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font450 2004 1550 (\(d1.IsNull\(\) && d2.IsNull\(\)\) || \(d1.Number\(\) == d2.Number\(\) &&) 1550 SB450 2056 375 (&d1[i]== &d2[i]) 375 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font825 2051 81 (, for ) 81 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font906 2056 525 (0 <= i < d1.Number\(\)\)) 525 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1431 2051 11 (.) 11 SB375 2128 839 (The following array operations invoked on a null ) 839 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1214 2133 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1414 2128 514 ( will cause a checked run-time) 514 SB375 2180 95 (error:) 95 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2260 150 (Number) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font675 2255 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font697 2260 50 ([]) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font747 2255 11 (,) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font758 2260 100 ( Sub) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font858 2255 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font880 2260 100 (Copy) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font980 2255 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1002 2260 125 (Equal) 125 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2357 524 (SubArray-specific operations) 524 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2432 41 (A ) 41 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font416 2437 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font616 2432 1389 ( is implemented as a reference so that it can refer to local arrays in the safe subset.) 1389 SB375 2484 107 (Thus, ) 107 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font482 2489 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font682 2484 1197 (s can't be assigned or stored in heap objects. The safe subset will detect) 1197 SB375 2536 161 (dangling ) 161 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font536 2541 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font736 2536 276 (s to local arrays.) 276 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2611 250 (SubArray\(\)) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font435 2658 167 (Creates a ) 167 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font602 2663 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font802 2658 261 ( of 0 elements \() 261 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1063 2663 375 (s.Number\(\) == 0) 375 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1438 2658 25 (\).) 25 SB375 2735 1515 (Initialized built-in arrays can be accessed in the safe subset only by using the special form) 1515 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2790 400 (SUB\(type, array\)) 400 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font775 2785 195 ( to create a ) 195 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font970 2790 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1170 2785 664 ( accessing the built-in array's elements:) 664 SB1209 3069 42 (60) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font0 0 0 fC525 267 775 (int a[] = {39, 45, 57, 63, 79};) 775 SB525 312 750 (SubArray<int> s = SUB\(int, a\);) 750 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 384 169 (The form ) 169 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font544 389 525 (SUB2\(type, array, d2\)) 525 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1069 384 168 ( creates a ) 168 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1237 389 650 (SubArray<Array<type, d2> >) 650 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1887 384 76 ( that) 76 SB375 436 1335 (accesses the elements of a two-dimensional array whose second dimension has ) 1335 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1710 441 50 (d2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1760 436 240 ( elements. For) 240 SB375 488 153 (example,) 153 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 561 1050 (int a[][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}};) 1050 SB525 606 1125 (SubArray<Array<int, 4> > s = SUB2\(int, a, 4\);) 1125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 678 157 (creates a ) 157 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font532 683 250 (SubArray s) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font782 678 494 ( that accesses the 2 x 4 array ) 494 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1276 683 25 (a) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1301 678 207 (. The forms ) 207 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1508 683 425 (SUB3\(type, array,) 425 SB375 735 175 (d2, d3\)) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font550 730 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font634 735 725 (SUB4\(type, array, d2, d3, d4\)) 725 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1359 730 464 ( operate on three- and four-) 464 SB375 782 332 (dimensional arrays.) 332 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 882 387 (Implementation notes) 387 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 957 1601 (These template classes are implemented without using class derivation or abstract base classes.) 1601 SB375 1007 1497 (The benefits of derivation would accrue only with the use of virtual functions, but virtual) 1497 SB375 1057 1365 (functions would add a word of overhead to every array. This is intolerable, since ) 1365 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1740 1062 125 (Array) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1865 1057 27 (s,) 27 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1114 200 (SubArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font575 1109 111 (s, and ) 111 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font686 1114 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font886 1109 994 (s are intended to be as efficient as built-in C++ arrays. The) 994 SB375 1161 1545 (approach used here, three separate classes and implicit conversions between them, is just as) 1545 SB375 1211 839 (expressive for the programmer but more efficient.) 839 SB435 1261 1521 (With a good compiler, the only overhead of using these classes instead of the built-in C++) 1521 SB375 1311 755 (equivalents comes from the run-time checks.) 755 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1411 339 (Run-time checking) 339 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1486 1525 (The run-time checks can be disabled at compile time by defining the preprocessor variable) 1525 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1541 250 (CHECKING=0) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font625 1536 1374 ( before including this file. Of course, disabling checking eliminates the guarantee) 1374 SB375 1588 1641 (of safety provided by the safe subset. In general, programmers should leave the checks enabled as) 1641 SB375 1638 1556 (late in the development process as possible, even perhaps in production code. With run-time) 1556 SB375 1688 1563 (checking, a buggy program halts as soon as safety is violated, before it can produce incorrect) 1563 SB375 1738 121 (results.) 121 SB435 1788 1452 (The exact mechanism of signaling run-time errors is not specified by this interface. In) 1452 SB375 1838 1624 (general, a run-time error \(such as an out-of-bounds index\) is a bug, and programs should not try) 1624 SB375 1888 366 (to handle such errors.) 366 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 1986 1633 (**********************************************************************/) 1633 SB375 2066 276 (#pragma safe) 276 SB375 2146 437 (#include <stdlib.h>) 437 SB375 2226 828 (template< class T > class SubArray {) 828 SB375 2266 161 (public:) 161 SB375 2306 391 (    int Number\(\);) 391 SB375 2346 644 (    T& operator []\( int i \);) 644 SB375 2386 1081 (    SubArray< T > Sub\( int start, int number \);) 1081 SB375 2426 805 (    SubArray< T > Sub\( int start \);) 805 SB375 2466 552 (    SubArray< T > Sub\(\);) 552 SB375 2506 713 (    void Copy\( SubArray< T > \);) 713 SB375 2546 851 (    int operator ==\( SubArray< T > \);) 851 SB375 2586 851 (    int operator !=\( SubArray< T > \);) 851 SB375 2626 713 (    int Equal\( SubArray< T > \);) 713 SB375 2706 322 (#pragma unsafe) 322 SB375 2746 759 (    SubArray\( T* t, int number \);) 759 SB525 2792 46 (/*) 46 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font571 2788 162 ( Creates a ) 162 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font733 2792 184 (SubArray) 184 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font917 2788 50 ( of ) 50 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font967 2792 138 (number) 138 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1105 2788 194 ( elements at ) 194 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1299 2792 23 (t) 23 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1322 2788 20 (, ) 20 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1342 2792 115 (t + 1) 115 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1457 2788 70 (, ..., ) 70 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1527 2792 322 (t + number - 1) 322 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1849 2788 20 (. ) 20 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1869 2792 46 (*/) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 3069 42 (61) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font0 0 0 fC375 273 230 (/* private) 230 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font605 269 1038 (: These members should be private, but C++ doesn't allow us to say ) 1038 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1643 273 276 (friend class) 276 SB375 319 299 (Array< T, n >) 299 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font674 315 112 ( for all ) 112 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font786 319 23 (n) 23 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font809 315 1006 (;. But they are declared unsafe and can't be accessed in safe code. ) 1006 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1815 319 46 (*/) 46 SB375 405 851 (    T \(&t\)[];                     /* ) 851 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1226 401 292 (The array elements) 292 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1518 405 69 ( */) 69 SB375 451 851 (    int number;                   /* ) 851 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1226 447 310 (Number of elements) 310 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1536 451 69 ( */) 69 SB375 497 851 (    T* First\(\);                   /* ) 851 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1226 493 449 (Returns first element of array) 449 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1675 497 69 ( */) 69 SB375 543 851 (    void Error\( const char [] \);  /* ) 851 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1226 539 364 (Signals a run-time error) 364 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1590 543 69 ( */) 69 SB375 583 138 (    };) 138 SB375 703 920 (template< class T, int n > class Array {) 920 SB375 743 161 (public:) 161 SB375 783 276 (    Array\(\);) 276 SB375 823 621 (    Array\( SubArray< T > \);) 621 SB375 863 391 (    int Number\(\);) 391 SB375 903 644 (    T& operator []\( int i \);) 644 SB375 943 1081 (    SubArray< T > Sub\( int start, int number \);) 1081 SB375 983 805 (    SubArray< T > Sub\( int start \);) 805 SB375 1023 552 (    SubArray< T > Sub\(\);) 552 SB375 1063 667 (    operator SubArray< T >\(\);) 667 SB375 1103 713 (    void Copy\( SubArray< T > \);) 713 SB375 1143 851 (    int operator ==\( SubArray< T > \);) 851 SB375 1183 851 (    int operator !=\( SubArray< T > \);) 851 SB375 1223 713 (    int Equal\( SubArray< T > \);) 713 SB375 1303 184 (private:) 184 SB450 1349 828 (    T  a[ n ];                   /* ) 828 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1278 1345 205 (The elements) 205 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1483 1349 69 ( */) 69 SB375 1395 828 (    T* First\(\);                  /* ) 828 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1203 1391 379 (Returns the first element) 379 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1582 1395 69 ( */) 69 SB375 1441 828 (    void Error\( const char [] \); /* ) 828 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1203 1437 497 (Signals a checked run-time error) 497 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1700 1441 69 ( */) 69 SB375 1481 138 (    };) 138 SB375 1601 828 (template< class T > class DynArray {) 828 SB375 1641 161 (public:) 161 SB375 1681 345 (    DynArray\(\);) 345 SB375 1721 621 (    DynArray\( int number \);) 621 SB375 1761 690 (    DynArray\( SubArray< T > \);) 690 SB375 1801 391 (    int IsNull\(\);) 391 SB375 1841 391 (    int Number\(\);) 391 SB375 1881 644 (    T& operator []\( int i \);) 644 SB375 1921 1081 (    SubArray< T > Sub\( int start, int number \);) 1081 SB375 1961 805 (    SubArray< T > Sub\( int start \);) 805 SB375 2001 552 (    SubArray< T > Sub\(\);) 552 SB375 2041 667 (    operator SubArray< T >\(\);) 667 SB375 2081 1058 (    DynArray< T > operator =\( DynArray< T > \);) 1058 SB375 2121 713 (    void Copy\( SubArray< T > \);) 713 SB375 2161 851 (    int operator ==\( DynArray< T > \);) 851 SB375 2201 851 (    int operator ==\( SubArray< T > \);) 851 SB375 2241 851 (    int operator !=\( DynArray< T > \);) 851 SB375 2281 851 (    int operator !=\( SubArray< T > \);) 851 SB375 2321 713 (    int Equal\( SubArray< T > \);) 713 SB375 2401 184 (private:) 184 SB375 2447 828 (    T* t;                        /* ) 828 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1203 2443 329 (First element of array) 329 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1532 2447 69 ( */) 69 SB375 2493 828 (    T* First\(\);                  /* ) 828 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1203 2489 379 (Returns the first element) 379 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1582 2493 69 ( */) 69 SB375 2539 828 (    void Error\( const char [] \); /* ) 828 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1203 2535 497 (Signals a checked run-time error) 497 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1700 2539 69 ( */) 69 SB375 2579 483 (    typedef gc T GCT;) 483 SB375 2619 138 (    };) 138 SB375 2699 1633 (/**********************************************************************) 1633 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2766 396 (Inline implementation) 396 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 2864 1633 (**********************************************************************/) 1633 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 3069 42 (62) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font0 0 0 fC375 267 322 (#pragma unsafe) 322 SB375 347 368 (#ifndef CHECKING) 368 SB375 387 414 (#define CHECKING 1) 414 SB375 427 138 (#endif) 138 SB375 507 1633 (/**********************************************************************) 1633 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 574 178 (SubArray) 178 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 662 1633 (**********************************************************************/) 1633 SB375 742 437 (template< class T >) 437 SB375 782 828 (inline int SubArray< T >::Number\(\) {) 828 SB375 822 460 (    return number; }) 460 SB375 902 437 (template< class T >) 437 SB375 942 1081 (inline T& SubArray< T >::operator []\( int i \) {) 1081 SB375 982 1380 (    if \(CHECKING && \(i < 0 || i >= Number\(\)\)\) Error\( "[]" \);) 1380 SB375 1022 460 (    return t[ i ]; }) 460 SB375 1102 437 (template< class T >) 437 SB375 1142 1518 (inline SubArray< T > SubArray< T >::Sub\( int start, int number \) {) 1518 SB375 1182 1403 (    if \(CHECKING && \(start < 0 || start + number > Number\(\)\)\)) 1403 SB375 1222 529 (        Error\( "Sub" \);) 529 SB375 1262 1242 (    return SubArray< T >\( First\(\) + start, number \); }) 1242 SB375 1342 437 (template< class T >) 437 SB375 1382 1242 (inline SubArray< T > SubArray< T >::Sub\( int start \) {) 1242 SB375 1422 1012 (    return Sub\( start, Number\(\) - start \); }) 1012 SB375 1502 437 (template< class T >) 437 SB375 1542 989 (inline SubArray< T > SubArray< T >::Sub\(\) {) 989 SB375 1582 736 (    return Sub\( 0, Number\(\) \); }) 736 SB375 1662 437 (template< class T >) 437 SB375 1702 1196 (inline void SubArray< T >::Copy\( SubArray< T > s \) {) 1196 SB375 1742 483 (    int n = Number\(\);) 483 SB375 1782 1219 (    if \(CHECKING && n != s.Number\(\)\) Error\( "Copy" \);) 1219 SB375 1822 506 (    T* to   = First\(\);) 506 SB375 1862 552 (    T* from = s.First\(\);) 552 SB375 1902 1150 (    for \(int i = 0; i < n; i++\) *to++ = *from++; }) 1150 SB375 1982 437 (template< class T >) 437 SB375 2022 1334 (inline int SubArray< T >::operator ==\( SubArray< T > s \) {) 1334 SB375 2062 1380 (    return Number\(\) == s.Number\(\) && First\(\) == s.First\(\); }) 1380 SB375 2142 437 (template< class T >) 437 SB375 2182 1334 (inline int SubArray< T >::operator !=\( SubArray< T > s \) {) 1334 SB375 2222 644 (    return ! \(*this == s\); }) 644 SB375 2302 437 (template< class T >) 437 SB375 2342 1196 (inline int SubArray< T >::Equal\( SubArray< T > s \) {) 1196 SB375 2382 483 (    int n = Number\(\);) 483 SB375 2422 782 (    if \(n != s.Number\(\)\) return 0;) 782 SB375 2462 506 (    T* to   = First\(\);) 506 SB375 2502 552 (    T* from = s.First\(\);) 552 SB375 2542 1449 (    for \(int i = 0; i < n; i++\) if \(*to++ != *from++\) return 0;) 1449 SB375 2582 345 (    return 1; }) 345 SB375 2662 437 (template< class T >) 437 SB375 2702 1127 (inline SubArray< T >::SubArray\( T* first, int n \)) 1127 SB375 2742 989 (    : t\( *\(T \(*\)[]\) first \), number\( n \) {}) 989 SB375 2822 437 (template< class T >) 437 SB375 2862 782 (inline T* SubArray< T >::First\(\) {) 782 SB375 2902 345 (    return t; }) 345 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 3069 42 (63) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font0 0 0 fC375 307 437 (template< class T >) 437 SB375 347 1173 (inline void SubArray< T >::Error\( const char [] \) {) 1173 SB375 387 322 (    abort\(\); }) 322 SB375 467 1633 (/**********************************************************************) 1633 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 534 110 (Array) 110 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 622 1633 (**********************************************************************/) 1633 SB375 702 598 (template< class T, int n >) 598 SB375 742 736 (inline Array< T, n >::Array\(\) {}) 736 SB375 822 598 (template< class T, int n >) 598 SB375 862 1104 (inline Array< T, n >::Array\( SubArray< T > s \) {) 1104 SB375 902 368 (    Copy\( s \); }) 368 SB375 982 598 (template< class T, int n >) 598 SB375 1022 828 (inline int Array< T, n >::Number\(\) {) 828 SB375 1062 345 (    return n; }) 345 SB375 1142 598 (template< class T, int n >) 598 SB375 1182 1081 (inline T& Array< T, n >::operator []\( int i \) {) 1081 SB375 1222 1380 (    if \(CHECKING && \(i < 0 || i >= Number\(\)\)\) Error\( "[]" \);) 1380 SB375 1262 460 (    return a[ i ]; }) 460 SB375 1342 598 (template< class T, int n >) 598 SB375 1382 1518 (inline SubArray< T > Array< T, n >::Sub\( int start, int number \) {) 1518 SB375 1422 1403 (    if \(CHECKING && \(start < 0 || start + number > Number\(\)\)\)) 1403 SB375 1462 529 (        Error\( "Sub" \);) 529 SB375 1502 1242 (    return SubArray< T >\( First\(\) + start, number \); }) 1242 SB375 1582 598 (template< class T, int n >) 598 SB375 1622 1242 (inline SubArray< T > Array< T, n >::Sub\( int start \) {) 1242 SB375 1662 1012 (    return Sub\( start, Number\(\) - start \); }) 1012 SB375 1742 598 (template< class T, int n >) 598 SB375 1782 989 (inline SubArray< T > Array< T, n >::Sub\(\) {) 989 SB375 1822 736 (    return Sub\( 0, Number\(\) \); }) 736 SB375 1902 598 (template< class T, int n >) 598 SB375 1942 1104 (inline Array< T, n >::operator SubArray< T >\(\) {) 1104 SB375 1982 437 (    return Sub\(\); }) 437 SB375 2062 598 (template< class T, int n >) 598 SB375 2102 1081 (inline Array< T, n >::Copy\( SubArray< T > s \) {) 1081 SB375 2142 483 (    int n = Number\(\);) 483 SB375 2182 1219 (    if \(CHECKING && n != s.Number\(\)\) Error\( "Copy" \);) 1219 SB375 2222 506 (    T* to   = First\(\);) 506 SB375 2262 552 (    T* from = s.First\(\);) 552 SB375 2302 1150 (    for \(int i = 0; i < n; i++\) *to++ = *from++; }) 1150 SB375 2382 598 (template< class T, int n >) 598 SB375 2422 1334 (inline int Array< T, n >::operator ==\( SubArray< T > s \) {) 1334 SB375 2462 1380 (    return Number\(\) == s.Number\(\) && First\(\) == s.First\(\); }) 1380 SB375 2542 598 (template< class T, int n >) 598 SB375 2582 1334 (inline int Array< T, n >::operator !=\( SubArray< T > s \) {) 1334 SB375 2622 644 (    return ! \(*this == s\); }) 644 SB375 2702 598 (template< class T, int n >) 598 SB375 2742 1196 (inline int Array< T, n >::Equal\( SubArray< T > s \) {) 1196 SB375 2782 483 (    int n = Number\(\);) 483 SB375 2822 782 (    if \(n != s.Number\(\)\) return 0;) 782 SB375 2862 506 (    T* to   = First\(\);) 506 SB375 2902 552 (    T* from = s.First\(\);) 552 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 3069 42 (64) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font0 0 0 fC375 267 1449 (    for \(int i = 0; i < n; i++\) if \(*to++ != *from++\) return 0;) 1449 SB375 307 345 (    return 1; }) 345 SB375 387 598 (template< class T, int n >) 598 SB375 427 782 (inline T* Array< T, n >::First\(\) {) 782 SB375 467 345 (    return a; }) 345 SB375 547 598 (template< class T, int n >) 598 SB375 587 1150 (inline void Array< T,n >::Error\( const char [] \) {) 1150 SB375 627 322 (    abort\(\); }) 322 SB375 747 1633 (/**********************************************************************) 1633 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 814 184 (DynArray) 184 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 902 1633 (**********************************************************************/) 1633 SB375 982 437 (template< class T >) 437 SB375 1022 736 (inline DynArray< T >::DynArray\(\)) 736 SB375 1062 414 (    : t\( NULL \) {}) 414 SB375 1142 299 (#ifdef NEWNEW) 299 SB375 1182 437 (template< class T >) 437 SB375 1222 1012 (inline DynArray< T >::DynArray\( int number \)) 1012 SB375 1262 713 (    : t\( new GCT[ number ] \) {}) 713 SB375 1302 115 (#else) 115 SB375 1342 437 (template< class T >) 437 SB375 1382 1058 (inline DynArray< T >::DynArray\( int number \) {) 1058 SB375 1422 1242 (    int bytes  = sizeof\( int \) + sizeof\( T \) * number;) 1242 SB375 1462 1012 (    int* block = \(int*\) \(new char[ bytes ]\);) 1012 SB375 1502 552 (    *block     = number;) 552 SB375 1542 828 (    t          = \(T*\) \(block + 1\); }) 828 SB375 1588 253 (        /* ) 253 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font628 1584 872 (This hack implementation doesn't run the constructor for ) 872 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1500 1588 92 (T */) 92 SB375 1628 138 (#endif) 138 SB375 1708 437 (template< class T >) 437 SB375 1748 1173 (inline DynArray< T >::DynArray\( SubArray< T > s \) {) 1173 SB375 1788 782 (    DynArray< T > d\( s.Number\(\) \);) 782 SB375 1828 276 (    t = d.t;) 276 SB375 1868 368 (    Copy\( s \); }) 368 SB375 1948 437 (template< class T >) 437 SB375 1988 828 (inline int DynArray< T >::Number\(\) {) 828 SB375 2028 667 (    return *\(\(\(int*\) t\) - 1\);) 667 SB375 2074 253 (        /* ) 253 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font628 2070 484 (...where new stores the size for ) 484 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1112 2074 46 (gc) 46 SB32 0 0 38 38 0 0 0 34 /Times-Roman /font32 ANSIFont font1158 2070 112 ( arrays.) 112 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1270 2074 69 ( */) 69 SB375 2114 115 (    }) 115 SB375 2194 437 (template< class T >) 437 SB375 2234 1081 (inline T& DynArray< T >::operator []\( int i \) {) 1081 SB375 2274 1380 (    if \(CHECKING && \(i < 0 || i >= Number\(\)\)\) Error\( "[]" \);) 1380 SB375 2314 460 (    return t[ i ]; }) 460 SB375 2394 437 (template< class T >) 437 SB375 2434 1518 (inline SubArray< T > DynArray< T >::Sub\( int start, int number \) {) 1518 SB375 2474 1403 (    if \(CHECKING && \(start < 0 || start + number > Number\(\)\)\)) 1403 SB375 2514 529 (        Error\( "Sub" \);) 529 SB375 2554 1242 (    return SubArray< T >\( First\(\) + start, number \); }) 1242 SB375 2634 437 (template< class T >) 437 SB375 2674 1242 (inline SubArray< T > DynArray< T >::Sub\( int start \) {) 1242 SB375 2714 1012 (    return Sub\( start, Number\(\) - start \); }) 1012 SB375 2794 437 (template< class T >) 437 SB375 2834 989 (inline SubArray< T > DynArray< T >::Sub\(\) {) 989 SB375 2874 736 (    return Sub\( 0, Number\(\) \); }) 736 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 3069 42 (65) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font0 0 0 fC375 267 437 (template< class T >) 437 SB375 307 1104 (inline DynArray< T >::operator SubArray< T >\(\) {) 1104 SB375 347 437 (    return Sub\(\); }) 437 SB375 427 437 (template< class T >) 437 SB375 467 1541 (inline DynArray< T > DynArray< T >::operator =\( DynArray< T > d \) {) 1541 SB375 507 276 (    t = d.t;) 276 SB375 547 345 (    return d; }) 345 SB375 627 437 (template< class T >) 437 SB375 667 1196 (inline void DynArray< T >::Copy\( SubArray< T > s \) {) 1196 SB375 707 483 (    int n = Number\(\);) 483 SB375 747 1219 (    if \(CHECKING && n != s.Number\(\)\) Error\( "Copy" \);) 1219 SB375 787 506 (    T* to   = First\(\);) 506 SB375 827 552 (    T* from = s.First\(\);) 552 SB375 867 1150 (    for \(int i = 0; i < n; i++\) *to++ = *from++; }) 1150 SB375 947 437 (template< class T >) 437 SB375 987 1334 (inline int DynArray< T >::operator ==\( DynArray< T > d \) {) 1334 SB375 1027 506 (    return t == d.t; }) 506 SB375 1107 437 (template< class T >) 437 SB375 1147 1334 (inline int DynArray< T >::operator ==\( SubArray< T > s \) {) 1334 SB375 1187 1380 (    return Number\(\) == s.Number\(\) && First\(\) == s.First\(\); }) 1380 SB375 1267 437 (template< class T >) 437 SB375 1307 1334 (inline int DynArray< T >::operator !=\( DynArray< T > d \) {) 1334 SB375 1347 644 (    return ! \(*this == d\); }) 644 SB375 1427 437 (template< class T >) 437 SB375 1467 1334 (inline int DynArray< T >::operator !=\( SubArray< T > s \) {) 1334 SB375 1507 644 (    return ! \(*this == s\); }) 644 SB375 1587 437 (template< class T >) 437 SB375 1627 1196 (inline int DynArray< T >::Equal\( SubArray< T > s \) {) 1196 SB375 1667 483 (    int n = Number\(\);) 483 SB375 1707 782 (    if \(n != s.Number\(\)\) return 0;) 782 SB375 1747 506 (    T* to   = First\(\);) 506 SB375 1787 552 (    T* from = s.First\(\);) 552 SB375 1827 1449 (    for \(int i = 0; i < n; i++\) if \(*to++ != *from++\) return 0;) 1449 SB375 1867 345 (    return 1; }) 345 SB375 1947 437 (template< class T >) 437 SB375 1987 782 (inline T* DynArray< T >::First\(\) {) 782 SB375 2027 345 (    return t; }) 345 SB375 2107 437 (template< class T >) 437 SB375 2147 1173 (inline void DynArray< T >::Error\( const char [] \) {) 1173 SB375 2187 322 (    abort\(\); }) 322 SB375 2267 1633 (/**********************************************************************) 1633 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2334 222 (SUB macros) 222 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 2422 1633 (**********************************************************************/) 1633 SB375 2502 805 (/* #define UNSAFE #pragma unsafe */) 805 SB375 2582 644 (#define SUB\( type, array \) \\) 644 SB375 2622 920 (    __SubArray< type, 1, 1, 1 >::New1\( \\) 920 SB375 2662 1426 (        array, \(int\)\(sizeof\( array \) / sizeof\( array[ 0 ] \)\) \)) 1426 SB375 2742 805 (#define SUB2\( type, array, dim2 \) \\) 805 SB375 2782 989 (    __SubArray< type, dim2, 1, 1 >::New2\( \\) 989 SB375 2822 1426 (        array, \(int\)\(sizeof\( array \) / sizeof\( array[ 0 ] \)\) \)) 1426 SB375 2902 943 (#define SUB3\( type, array, dim2, dim3 \) \\) 943 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 3069 42 (66) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font0 0 0 fC375 267 1058 (    __SubArray< type, dim2, dim3, 1 >::New3\( \\) 1058 SB375 307 1426 (        array, \(int\)\(sizeof\( array \) / sizeof\( array[ 0 ] \)\) \)) 1426 SB375 387 1081 (#define SUB4\( type, array, dim2, dim3, dim4 \) \\) 1081 SB375 427 1127 (    __SubArray< type, dim2, dim3, dim4 >::New4\( \\) 1127 SB375 467 1426 (        array, \(int\)\(sizeof\( array \) / sizeof\( array[ 0 ] \)\) \)) 1426 SB375 547 989 (template< class T, int d2, int d3, int d4 >) 989 SB375 587 575 (class __SubArray {public:) 575 SB375 627 1150 (    static SubArray< T > New1\( T \(&a\)[], int n \) {) 1150 SB375 667 920 (        return SubArray< T >\( a, n \); };) 920 SB375 747 690 (    typedef Array< T, d2 > A2;) 690 SB375 787 1265 (    static SubArray< A2 > New2\( T \(&a\)[][d2], int n \) {) 1265 SB375 827 1081 (        return SubArray< A2 >\( \(A2*\) a, n \); };) 1081 SB375 907 989 (    typedef Array< Array< T, d3 >, d2 > A3;) 989 SB375 947 1357 (    static SubArray< A3 > New3\( T \(&a\)[][d2][d3], int n \) {) 1357 SB375 987 1081 (        return SubArray< A3 >\( \(A3*\) a, n \); };) 1081 SB375 1067 1288 (    typedef Array< Array< Array< T, d4 >, d3 >, d2 > A4;) 1288 SB375 1107 1449 (    static SubArray< A4 > New4\( T \(&a\)[][d2][d3][d4], int n \) {) 1449 SB375 1147 1081 (        return SubArray< A4 >\( \(A4*\) a, n \); };) 1081 SB375 1187 138 (    };) 138 SB375 1267 506 (#endif /* _Array_h_ */) 506 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 3069 42 (67) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 424 (Appendix D: Text.h) 424 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 779 (This appendix presents the standard interface ) 779 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1154 408 150 (Text.h) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1304 403 492 (, which provides safe strings.) 492 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 503 368 (#ifndef _Text_h_) 368 SB375 543 368 (#define _Text_h_) 368 SB375 623 1633 (/**********************************************************************) 1633 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 715 319 (Text and SubText) 319 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 790 41 (A ) 41 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font416 795 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font516 790 819 ( is a heap-allocated varying-length string, and a ) 819 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1335 795 175 (SubText) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1510 790 388 ( is a sub-sequence of a ) 388 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1898 795 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1998 790 11 (.) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 847 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font475 842 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font559 847 175 (SubText) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font734 842 864 ( are intended as safe replacements for most uses of ) 864 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1598 847 125 (char*) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1723 842 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1807 847 200 (string.h) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font2007 842 11 (.) 11 SB435 894 41 (A ) 41 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font476 899 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font576 894 80 ( is a ) 80 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font656 899 350 (DynArray<char>) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1006 894 385 ( and inherits all of the ) 385 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1391 899 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1591 894 216 ( methods. A ) 216 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1807 899 175 (SubText) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1982 894 39 ( is) 39 SB375 946 301 (another name for ) 301 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font676 951 350 (SubArray<char>) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1026 946 11 (.) 11 SB435 998 858 (Many common operations can be performed using ) 858 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1293 1003 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1493 998 397 ( methods. For example,) 397 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1055 250 (t.Number\(\)) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font625 1050 334 ( gives the length of ) 334 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font959 1055 150 (Text t) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1109 1050 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1131 1055 75 (t[i) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1206 1050 11 ( ) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1217 1055 25 (]) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1242 1050 224 ( accesses the ) 224 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1466 1055 25 (i) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1491 1050 270 (-th character of ) 270 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1761 1055 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1786 1050 84 (, and) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1107 275 (t.Equal\(t2\)) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font650 1102 182 ( compares ) 182 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font832 1107 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font857 1102 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font941 1107 50 (t2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font991 1102 11 (.) 11 SB435 1154 921 (The string-specific operations defined here operate on ) 921 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1356 1159 200 (SubTexts) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1556 1154 22 (. ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1578 1159 200 (DynArray) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1778 1154 184 ( provides a) 184 SB375 1206 413 (default conversion from ) 413 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font788 1211 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font888 1206 54 ( to ) 54 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font942 1211 175 (SubText) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1117 1206 11 (.) 11 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 1306 1633 (**********************************************************************/) 1633 SB375 1346 276 (#pragma safe) 276 SB375 1426 759 (typedef SubArray< char > SubText;) 759 SB375 1506 851 (class Text: public DynArray< char > {) 851 SB375 1546 161 (public:) 161 SB375 1626 506 (Text\( const char* s \);) 506 SB495 1676 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 1668 263 ( Returns a new ) 263 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font804 1673 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font904 1668 274 ( that's a copy of ) 274 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1178 1673 25 (s) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1203 1668 226 (, with length ) 226 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1429 1673 225 (strlen\(s\)) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1654 1668 22 (. ) 22 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1676 1676 46 (*/) 46 SB375 1758 483 (Text\( const char c \);) 483 SB495 1808 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 1800 263 ( Returns a new ) 263 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font804 1805 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font904 1800 396 ( of length 1 containing ) 396 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1300 1805 25 (c) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1325 1800 22 (. ) 22 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1347 1808 46 (*/) 46 SB375 1890 414 (Text\( SubText s \);) 414 SB495 1940 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 1932 263 ( Returns a new ) 263 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font804 1937 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font904 1932 274 ( that's a copy of ) 274 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1178 1937 25 (s) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1203 1932 22 (. ) 22 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1225 1940 46 (*/) 46 SB375 2022 1127 (friend Text operator +\( SubText s1, SubText s2 \);) 1127 SB495 2072 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 2064 263 ( Returns a new ) 263 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font804 2069 100 (Text) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font904 2064 554 ( containing the concatenation of ) 554 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1458 2069 50 (s1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1508 2064 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1592 2069 50 (s2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1642 2064 22 (. ) 22 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1664 2072 46 (*/) 46 SB375 2154 1081 (friend int EqualCase\( SubText s1, SubText s2 \);) 1081 SB495 2204 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 2196 266 ( Returns true if ) 266 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font807 2201 50 (s1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font857 2196 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font941 2201 50 (s2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font991 2196 946 ( contain the same sequence of characters, ignoring case.) 946 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1937 2204 69 ( */) 69 SB375 2286 1495 (friend int Compare\( SubText s1, SubText s2, int ignoreCase = 0 \);) 1495 SB495 2336 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 2328 718 ( Returns -1, 0, or 1 depending on whether ) 718 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1259 2333 50 (s1) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1309 2328 670 ( is lexicographically less than, equal, or) 670 SB495 2380 215 (greater than ) 215 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font710 2385 50 (s2) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font760 2380 60 (. If ) 60 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font820 2385 250 (ignoreCase) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1070 2380 609 (, case is ignored in the comparison. ) 609 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1679 2388 46 (*/) 46 SB375 2510 1334 (friend int Find\( SubText s1, char c, int ignoreCase = 0 \);) 1334 SB375 2550 1426 (friend int Find\( SubText s1, SubText s2, int ignoreCase = 0 \);) 1426 SB375 2590 1449 (friend int FindRight\( SubText s1, char c, int ignoreCase = 0 \);) 1449 SB375 2630 1541 (friend int FindRight\( SubText s1, SubText s2, int ignoreCase = 0 \);) 1541 SB495 2680 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 2672 1245 ( Returns the index of the leftmost \(rightmost\) occurrence of the character ) 1245 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1786 2677 25 (c) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1811 2672 46 ( or) 46 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font495 2729 250 (SubText s2) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font745 2724 119 ( in the ) 119 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font864 2729 250 (SubText s1) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1114 2724 522 (. Returns -1 if the character or ) 522 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1636 2729 175 (SubText) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1811 2724 104 ( is not) 104 SB495 2776 157 (found. If ) 157 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font652 2781 250 (ignoreCase) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font902 2776 521 (, case is ignored in the search. ) 521 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1423 2784 46 (*/) 46 SB375 2826 46 (};) 46 SB375 2866 483 (#endif /* _Text_h_ */) 483 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 3069 42 (68) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 491 (Appendix E: Variant.h) 491 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 779 (This appendix presents the standard interface ) 779 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1154 408 225 (Variant.h) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1379 403 537 (, which provides tagged unions.) 537 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 503 414 (#ifndef _Variant_h) 414 SB375 543 414 (#define _Variant_h) 414 SB375 623 1633 (/**********************************************************************) 1633 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 715 140 (Variant) 140 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 830 41 (A ) 41 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font416 835 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font591 830 1320 ( is a union combined with a tag, indicating which member the union currently) 1320 SB375 882 1639 (contains. An attempt to access the incorrect member will \(optionally\) result in a checked runtime) 1639 SB375 932 1609 (error. When using garbage collection, variants should be used in preference to unions wherever) 1609 SB375 982 254 (possible, since ) 254 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font629 987 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font804 982 901 (s avoid the collection inefficiencies caused by unions.) 901 SB435 1034 454 (The template class Variant) 454 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font889 1034 21 (n) 21 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font910 1034 530 ( creates a variant that can hold ) 530 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1440 1034 21 (n) 21 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1461 1034 496 ( different types. For example,) 496 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1107 625 (Variant2< int, char* > v;) 625 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1179 148 (declares ) 148 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font523 1184 25 (v) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font548 1179 597 ( to be a variant that can contain an ) 597 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1145 1184 75 (int) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1220 1179 87 ( or a ) 87 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1307 1184 125 (char*) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1432 1179 99 (. The ) 99 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1531 1184 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1706 1179 219 ('s current tag) 219 SB375 1231 346 (value is accessed by:) 346 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1304 175 (v.Tag\(\)) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1376 346 (The tag values for a ) 346 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font721 1381 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font896 1376 21 (n) 21 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font917 1376 284 ( range from 0 to ) 284 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1201 1376 21 (n) 21 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1222 1376 415 (-1, corresponding to the ) 415 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1637 1376 21 (n) 21 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1658 1376 205 ( types in the) 205 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 1433 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font550 1428 21 (n) 21 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font571 1428 11 (.) 11 SB435 1480 387 (Assigning a value to a ) 387 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font822 1485 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font997 1480 438 ( automatically sets its tag:) 438 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1562 600 (v = 4;        // v.Tag\(\)) 600 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1125 1557 211 ( now equals ) 211 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1336 1562 25 (0) 25 SB525 1614 600 (v = "Hello";  // v.Tag\(\)) 600 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1125 1609 211 ( now equals ) 211 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1336 1614 25 (1) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1686 384 (The current value of a ) 384 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font759 1691 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font934 1686 801 ( can be accessed using explicit type conversion:) 801 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1761 225 (\(char*\) v) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1833 14 (\() 14 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font389 1838 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font564 1833 1369 (s will also be implicitly converted whenever there's an unambiguous conversion.\)) 1369 SB375 1885 413 (Attempting to convert a ) 413 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font788 1890 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font963 1885 972 ( to a type other than that of the current value results in an) 972 SB375 1937 562 (\(optional\) checked runtime error.) 562 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font435 1992 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font610 1987 1269 (s are standard classes that are handled specially by some compiler/collector) 1269 SB375 2039 1613 (implementations to avoid the collector inefficiencies associated with untagged unions. During a) 1613 SB375 2089 584 (collection, these collectors use the ) 584 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font959 2094 200 (Variant') 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1159 2089 835 (s tag to determine the current type of its contents.) 835 SB435 2141 197 (Note: Only ) 197 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font632 2146 200 (Variant2) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font832 2141 492 ( is presented here. The other ) 492 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1324 2146 175 (Variant) 175 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1499 2141 21 (n) 21 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1520 2141 354 ( are almost identical.) 354 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 2231 1633 (**********************************************************************/) 1633 SB375 2311 483 (#include "iostream.h") 483 SB375 2351 437 (#include "stdlib.h") 437 SB375 2431 1081 (template< class T0, class T1 > class Variant2 {) 1081 SB375 2471 161 (public:) 161 SB375 2511 322 (    int Tag\(\);) 322 SB525 2561 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font571 2553 216 ( Returns the ) 216 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font787 2561 161 (Variant) 161 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font948 2553 241 ('s current tag, ) 241 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1189 2561 23 (0) 23 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1212 2553 277 ( if it's holding a ) 277 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1489 2561 46 (T0) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1535 2553 22 (, ) 22 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1557 2561 23 (1) 23 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1580 2553 77 ( if a ) 77 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1657 2561 46 (T1) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1703 2553 22 (. ) 22 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1725 2561 46 (*/) 46 SB375 2641 621 (    void SetTag\( int tag \);) 621 SB525 2691 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font571 2683 154 ( Sets the ) 154 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font725 2691 161 (Variant) 161 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font886 2683 273 ('s current tag to ) 273 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1159 2691 69 (tag) 69 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1228 2683 601 (, raising a checked runtime error if ) 601 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1829 2691 161 (tag < 0) 161 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font525 2733 46 (or ) 46 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font571 2741 161 (tag > 1) 161 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font732 2733 770 (. After the tag is changed, the contents of the ) 770 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1502 2741 161 (Variant) 161 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1663 2733 264 ( are undefined. ) 264 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1927 2741 46 (*/) 46 SB375 2821 345 (    Variant2\(\);) 345 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font525 2863 11 ( ) 11 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font536 2871 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font582 2863 232 ( Constructs a ) 232 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font814 2871 161 (Variant) 161 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font975 2863 574 ( with undefined tag and contents. ) 574 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1549 2871 46 (*/) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 3069 42 (69) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font0 0 0 fC375 267 667 (    Variant2\( const T0& t0 \);) 667 SB375 307 667 (    Variant2\( const T1& t1 \);) 667 SB525 357 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font571 349 232 ( Constructs a ) 232 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font803 357 161 (Variant) 161 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font964 349 133 ( from a ) 133 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1097 357 46 (T0) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1143 349 57 ( or ) 57 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1200 357 46 (T1) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1246 349 315 (, setting the tag to ) 315 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1561 357 23 (0) 23 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1584 349 57 ( or ) 57 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1641 357 23 (1) 23 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1664 349 272 ( as appropriate. ) 272 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1936 357 46 (*/) 46 SB375 437 437 (    operator T0&\(\);) 437 SB375 477 437 (    operator T1&\(\);) 437 SB525 527 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font571 519 52 ( A ) 52 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font623 527 161 (Variant) 161 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font784 519 378 ( can be converted to a ) 378 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1162 527 46 (T0) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1208 519 87 ( or a ) 87 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1295 527 46 (T1) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1341 519 638 (. Attempting to convert a variant to a ) 638 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1979 527 46 (T0) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font525 569 153 (when its ) 153 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font678 577 184 (tag != 0) 184 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font862 569 767 ( raises a checked runtime error \(similarly for ) 767 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1629 577 46 (T1) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1675 569 69 (\). */) 69 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 657 1518 (    Variant2< T0, T1 >& operator =\( const Variant2< T0, T1 >& v \);) 1518 SB525 707 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font571 699 155 ( Assigns ) 155 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font726 707 23 (v) 23 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font749 699 54 ( to ) 54 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font803 707 115 (*this) 115 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font918 699 11 ( ) 11 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font929 707 46 (*/) 46 SB375 787 1173 (    Variant2< T0, T1 >& operator =\( const T0& t0 \);) 1173 SB375 827 1173 (    Variant2< T0, T1 >& operator =\( const T1& t1 \);) 1173 SB525 877 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font571 869 185 ( Assigns a ) 185 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font756 877 46 (t0) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font802 869 57 ( or ) 57 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font859 877 46 (t1) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font905 869 54 ( to ) 54 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font959 877 115 (*this) 115 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1074 869 506 (, setting its tag appropriately. ) 506 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1580 877 46 (*/) 46 SB375 957 184 (private:) 184 SB375 997 276 (    int tag;) 276 SB375 1037 667 (    union {T0 t0; T1 t1; } u;) 667 SB375 1077 966 (    void Error\( const char message[] \); };) 966 SB375 1197 1633 (/**********************************************************************) 1633 SB375 1277 483 (Inline implementation) 483 SB375 1357 1633 (**********************************************************************/) 1633 SB375 1437 368 (#ifndef CHECKING) 368 SB375 1477 414 (#define CHECKING 1) 414 SB375 1517 138 (#endif) 138 SB375 1597 690 (template< class T0, class T1 >) 690 SB375 1637 874 (inline int Variant2< T0, T1 >::Tag\(\) {) 874 SB375 1677 391 (    return tag; }) 391 SB375 1757 690 (template< class T0, class T1 >) 690 SB375 1797 1173 (inline void Variant2< T0, T1 >::SetTag\( int tag \) {) 1173 SB375 1837 943 (    if \(CHECKING && \(tag < 0 || tag > 1\)\)) 943 SB375 1877 920 (        Error\( "Invalid Variant2 tag" \);) 920 SB375 1917 506 (    this->tag = tag; }) 506 SB375 1997 690 (template< class T0, class T1 >) 690 SB375 2037 1150 (inline Variant2< T0, T1 >::Variant2\(\): tag\( 0 \) {}) 1150 SB375 2117 690 (template< class T0, class T1 >) 690 SB375 2157 1449 (inline Variant2< T0, T1 >::Variant2\( const T0& t0 \): tag\( 0 \) {) 1449 SB450 2197 253 (u.t0 = t0;}) 253 SB375 2277 690 (template< class T0, class T1 >) 690 SB375 2317 1449 (inline Variant2< T0, T1 >::Variant2\( const T1& t1 \): tag\( 1 \) {) 1449 SB375 2357 345 (    u.t1 = t1;}) 345 SB375 2437 690 (template< class T0, class T1 >) 690 SB375 2477 989 (inline Variant2< T0, T1 >::operator T0&\(\) {) 989 SB375 2517 1610 (        if \(CHECKING && tag != 0\) Error\( "Variant2 has invalid tag" \);) 1610 SB375 2557 506 (        return u.t0; }) 506 SB375 2637 690 (template< class T0, class T1 >) 690 SB375 2677 989 (inline Variant2< T0, T1 >::operator T1&\(\) {) 989 SB375 2717 1610 (        if \(CHECKING && tag != 1\) Error\( "Variant2 has invalid tag" \);) 1610 SB375 2757 506 (        return u.t1; }) 506 SB375 2837 690 (template< class T0, class T1 >) 690 SB375 2877 575 (inline Variant2< T0, T1>&) 575 SB375 2917 1449 (Variant2< T0, T1 >::operator =\( const Variant2< T0, T1 >& v \) {) 1449 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 3069 42 (70) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font0 0 0 fC375 267 368 (    tag = v.tag;) 368 SB375 307 276 (    u = v.u;) 276 SB375 347 437 (    return *this; }) 437 SB375 427 690 (template< class T0, class T1 >) 690 SB375 467 575 (inline Variant2< T0, T1>&) 575 SB375 507 1104 (Variant2< T0, T1 >::operator =\( const T0& t0 \) {) 1104 SB375 547 276 (    tag = 0;) 276 SB375 587 460 (    this->u.t0 = t0;) 460 SB375 627 437 (    return *this; }) 437 SB375 707 690 (template< class T0, class T1 >) 690 SB375 747 598 (inline Variant2< T0, T1 >&) 598 SB375 787 1104 (Variant2< T0, T1 >::operator =\( const T1& t1 \) {) 1104 SB375 827 276 (    tag = 1;) 276 SB375 867 460 (    this->u.t1 = t1;) 460 SB375 907 437 (    return *this; }) 437 SB375 987 690 (template< class T0, class T1 >) 690 SB375 1027 1449 (inline void Variant2< T0, T1 >::Error\( const char message[] \) {) 1449 SB375 1067 644 (    cerr << message << "\\n";) 644 SB375 1107 322 (    abort\(\); }) 322 SB375 1187 529 (#endif /* _Variant_h */) 529 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 3069 42 (71) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 50 50 0 0 0 46 /Times-Bold /font29 ANSIFont font0 0 0 fC375 319 603 (Appendix F: WeakPointer.h) 603 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 403 779 (This appendix presents the standard interface ) 779 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1154 408 325 (WeakPointer.h) 325 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1479 403 524 (, which provides weak pointers) 524 SB375 455 339 (and object clean-up.) 339 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 553 161 (#ifndef) 161 SB600 553 345 (_WeakPointer_h_) 345 SB375 593 161 (#define) 161 SB600 593 345 (_WeakPointer_h_) 345 SB375 673 1633 (/**********************************************************************) 1633 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 780 485 (WeakPointer and CleanUp) 485 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 868 1633 (**********************************************************************/) 1633 SB375 948 276 (#pragma safe) 276 SB375 1028 1633 (/**********************************************************************) 1633 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1120 238 (WeakPointer) 238 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1195 41 (A ) 41 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font416 1195 218 (weak pointer) 218 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font634 1195 1349 ( is a pointer to a heap-allocated object that doesn't prevent the object from being) 1349 SB375 1245 1602 (garbage collected. Weak pointers can be used to track which objects haven't yet been reclaimed) 1602 SB375 1295 269 (by the collector.) 269 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 1383 1633 (**********************************************************************/) 1633 SB375 1503 897 (template< class T > class WeakPointer {) 897 SB375 1543 161 (public:) 161 SB375 1623 552 (WeakPointer\( T* t = 0 \);) 552 SB495 1673 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 1665 520 ( Constructs a weak pointer for ) 520 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1061 1670 50 (*t) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1111 1665 866 (, reactivating it if it was previously deactivated \(see) 866 SB495 1717 135 (below\). ) 135 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font630 1722 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font655 1717 489 ( may be null. It is an error if ) 489 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1144 1722 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1169 1717 279 ( is non-null and ) 279 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1448 1722 50 (*t) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1498 1717 426 ( is not a collected object. ) 426 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1924 1725 46 (*/) 46 SB375 1807 299 (T* Pointer\(\);) 299 SB495 1857 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 1849 11 ( ) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font552 1854 300 (wp.Pointer\(\)) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font852 1849 685 ( returns the original pointer from which ) 685 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1537 1854 50 (wp) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1587 1849 403 ( was constructed or null) 403 SB495 1901 36 (if ) 36 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font531 1906 50 (wp) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font581 1901 1396 ( has been deactivated. The collector deactivates a weak pointer when it detects that) 1396 SB495 1953 1530 (the referenced object is unreachable by normal pointers. \(Reachability and deactivation are) 1530 SB495 2003 260 (defined below.\)) 260 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font755 2011 69 ( */) 69 SB375 2091 805 (int operator==\( WeakPointer< T > \);) 805 SB495 2141 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 2133 124 ( Given ) 124 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font665 2138 125 (T* t1) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font790 2133 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font874 2138 125 (T* t2) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font999 2133 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1021 2138 200 (t1 == t2) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1221 2133 240 ( if and only if ) 240 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1461 2138 525 (WeakPointer<T>\(t1\) ==) 525 SB495 2190 450 (WeakPointer<T>\(t2\)) 450 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font945 2185 22 (. ) 22 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font967 2193 46 (*/) 46 SB375 2275 253 (int Hash\(\);) 253 SB495 2325 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 2317 1461 ( Returns a hash code suitable for use by multiplicative- and division-based hash tables.) 1461 SB495 2367 38 (If ) 38 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font533 2372 250 (wp1 == wp2) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font783 2367 107 (, then ) 107 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font890 2372 600 (wp1.Hash\(\) == wp2.Hash\(\)) 600 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1490 2367 11 (.) 11 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1501 2375 69 ( */) 69 SB375 2417 46 (};) 46 SB375 2497 1633 (/**********************************************************************) 1633 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2589 158 (CleanUp) 158 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2664 1592 (A garbage-collected object can have an associated clean-up function that will be invoked some) 1592 SB375 2714 1494 (time after the collector discovers the object is unreachable via normal pointers. Clean-up) 1494 SB375 2764 1569 (functions can be used to release resources such as open-file handles or window handles when) 1569 SB375 2814 1639 (their containing objects become unreachable. The initial clean-up function of a collected object is) 1639 SB375 2864 230 (its destructor.) 230 SB1209 3069 42 (72) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 1528 (There is no guarantee that the collector will detect every unreachable object \(though it will) 1528 SB375 319 1414 (find almost all of them\). Clients should not rely on clean-up to cause some action to) 1414 SB375 369 1151 (occur\227clean-up is only a mechanism for improving resource usage.) 1151 SB435 419 1573 (Every object with a clean-up function also has a clean-up queue. When the collector finds the) 1573 SB375 469 1548 (object is unreachable, it enqueues it on its queue. The clean-up function is applied when the) 1548 SB375 519 1565 (object is removed from the queue. By default, objects are enqueued on the garbage collector's) 1565 SB375 569 1521 (queue, and the collector removes all objects from its queue after each collection. If a client) 1521 SB375 619 1539 (supplies another queue for objects, it is his responsibility to remove objects \(and cause their) 1539 SB375 669 810 (functions to be called\) by polling it periodically.) 810 SB435 719 1578 (Clean-up queues allow clean-up functions accessing global data to synchronize with the main) 1578 SB375 769 1636 (program. Garbage collection can occur at any time, and clean-ups invoked by the collector might) 1636 SB375 819 1575 (access data in an inconsistent state. A client can control this by defining an explicit queue for) 1575 SB375 869 598 (objects and polling it at safe points.) 598 SB435 919 1038 (The following definitions are used by the specification below:) 1038 SB525 994 274 (Given a pointer ) 274 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font799 999 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font824 994 428 ( to a collected object, the ) 428 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font1252 994 192 (base object) 192 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1444 994 11 ( ) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1455 999 125 (BO\(t\)) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1580 994 406 ( is the value returned by) 406 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1051 75 (new) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font600 1046 1034 ( when it created the object. \(Because of multiple inheritance, ) 1034 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1634 1051 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1659 1046 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1743 1051 125 (BO\(t\)) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1868 1046 147 ( may not) 147 SB525 1098 360 (be the same address.\)) 360 SB525 1173 270 (A weak pointer ) 270 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font795 1178 50 (wp) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font845 1173 355 ( references an object ) 355 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1200 1178 50 (*t) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1250 1173 47 ( if ) 47 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1297 1178 625 (BO\(wp.Pointer\(\)\) == BO\(t\)) 625 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1922 1173 11 (.) 11 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 1263 1633 (**********************************************************************/) 1633 SB375 1343 1081 (template< class T, class Data > class CleanUp {) 1081 SB375 1383 161 (public:) 161 SB375 1463 1426 (static void Set\( T* t, void c\( Data* d, T* t \), Data* d = 0 \);) 1426 SB495 1513 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 1505 615 ( Sets the clean-up function of object ) 615 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1156 1510 125 (BO\(t\)) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1281 1505 103 ( to be ) 103 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1384 1510 150 (<c, d>) 150 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1534 1505 436 (, replacing any previously) 436 SB495 1557 502 (defined clean-up function for ) 502 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font997 1562 125 (BO\(t\)) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1122 1557 23 (; ) 23 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1145 1562 25 (c) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1170 1557 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1254 1562 25 (d) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1279 1557 283 ( can be null, but ) 283 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1562 1562 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1587 1557 434 ( cannot. Sets the clean-up) 434 SB495 1609 169 (queue for ) 169 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font664 1614 125 (BO\(t\)) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font789 1609 579 ( to be the collector's queue. When ) 579 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1368 1614 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1393 1609 615 ( is removed from its clean-up queue,) 615 SB495 1661 644 (its clean-up will be applied by calling ) 644 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1139 1666 175 (c\(d, t\)) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1314 1661 280 (. It is an error if ) 280 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1594 1666 50 (*t) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1644 1661 294 ( is not a collected) 294 SB495 1713 121 (object. ) 121 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font616 1721 46 (*/) 46 SB375 1801 575 (static void Call\( T* t \);) 575 SB495 1851 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 1843 600 ( Sets the new clean-up function for ) 600 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1141 1848 125 (BO\(t\)) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1266 1843 694 ( to be null and, if the old one is non-null,) 694 SB495 1895 479 (calls it immediately, even if ) 479 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font974 1900 125 (BO\(t\)) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1099 1895 308 ( is still reachable. ) 308 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1407 1903 46 (*/) 46 SB375 1985 460 (class Queue {public:) 460 SB375 2025 276 (    Queue\(\);) 276 SB525 2075 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font571 2067 433 ( Constructs a new queue. ) 433 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1004 2075 46 (*/) 46 SB375 2155 483 (    void Set\( T* t \);) 483 SB525 2205 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font571 2197 11 ( ) 11 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font582 2202 200 (q.Set\(t\)) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font782 2197 457 ( sets the clean-up queue of ) 457 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1239 2202 125 (BO\(t\)) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1364 2197 103 ( to be ) 103 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1467 2202 25 (q) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1492 2197 22 (. ) 22 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1514 2205 46 (*/) 46 SB375 2287 345 (    int Call\(\);) 345 SB525 2337 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font571 2329 49 ( If ) 49 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font620 2334 25 (q) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font645 2329 253 ( is non-empty, ) 253 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font898 2334 200 (q.Call\(\)) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1098 2329 771 ( removes the first object and calls its clean-up) 771 SB525 2381 427 (function; does nothing if ) 427 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font952 2386 25 (q) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font977 2381 1030 ( is empty. Returns true if there are more objects in the queue.) 1030 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font525 2431 46 (*/) 46 SB375 2471 138 (    };) 138 SB375 2511 46 (};) 46 SB375 2591 1633 (/**********************************************************************) 1633 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 2683 480 (Reachability and Clean-up) 480 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2758 212 (An object is ) 212 SB32 0 0 42 42 0 0 0 38 /Times-Italic /font31 ANSIFont font587 2758 169 (reachable) 169 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font756 2758 1242 ( if it can be reached via a path of normal pointers starting at the registers,) 1242 SB375 2808 764 (stacks, global variables, or some other object ) 764 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1139 2813 25 (O) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1164 2808 729 ( with a non-null clean-up function \(even if ) 729 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1893 2813 25 (O) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1918 2808 104 ( is not) 104 SB375 2860 186 (reachable\).) 186 SB1209 3069 42 (73) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font0 0 0 fC435 269 885 ( This definition of reachability ensures that if object ) 885 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1320 274 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1345 269 430 ( is accessible from object ) 430 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1775 274 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1800 269 152 ( \(and not) 152 SB375 321 386 (vice versa\) and if both ) 386 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font761 326 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font786 321 84 ( and ) 84 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font870 326 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font895 321 520 ( have clean-up functions, then ) 520 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1415 326 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1440 321 557 ( will always be cleaned up before) 557 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 378 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font400 373 1603 (. Note that as long as two objects reference each other directly or indirectly via normal pointers) 1603 SB375 425 1604 (and both have non-null clean-up functions, then the objects will be reachable and they won't be) 1604 SB375 475 160 (collected.) 160 SB435 525 1526 (When the collector finds an unreachable object with a null clean-up function, it atomically) 1526 SB375 575 1431 (deactivates all weak pointers referencing the object and recycles its storage. If object ) 1431 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1806 580 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1831 575 39 ( is) 39 SB375 627 380 (accessible from object ) 380 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font755 632 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font780 627 522 ( via a path of normal pointers, ) 522 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1302 632 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1327 627 670 ( will be discovered unreachable no later) 670 SB375 679 86 (than ) 86 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font461 684 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font486 679 397 (, and a weak pointer to ) 397 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font883 684 25 (A) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font908 679 865 ( will be deactivated no later than a weak pointer to ) 865 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1773 684 25 (B) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1798 679 11 (.) 11 SB435 731 1445 (When the collector finds an unreachable object with a non-null clean-up function, the) 1445 SB375 781 1585 (collector atomically deactivates all weak pointers referencing the object, redefines its clean-up) 1585 SB375 831 1574 (function to be null, and enqueues it on its clean-up queue. The object then becomes reachable) 1574 SB375 881 1226 (again and remains reachable at least until its clean-up function executes.) 1226 SB435 931 1570 (The clean-up function is assured that its argument is the only accessible pointer to the object.) 1570 SB375 981 1645 (Nothing prevents the function from redefining the object's clean-up function or making the object) 1645 SB375 1031 1236 (reachable again \(for example, by storing the pointer in a global variable\).) 1236 SB435 1081 1510 (If the clean-up function does not make its object reachable again and does not redefine its) 1510 SB375 1131 1629 (clean-up function, then the object will be collected by a subsequent collection \(because the object) 1629 SB375 1181 1609 (remains unreachable and now has a null clean-up function\). If the clean-up function does make) 1609 SB375 1231 161 (its object ) 161 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font536 1236 50 (*t) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font586 1231 696 ( reachable again, any subsequent calls to ) 696 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1282 1236 425 (WeakPointer<T>\(t\)) 425 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1707 1231 313 ( will reactivate the) 313 SB375 1283 1394 (original weak pointer and return it. Further, if a clean-up function is redefined for ) 1394 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1769 1288 25 (t) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1794 1283 207 (, then it will) 207 SB375 1335 1217 (be invoked on the object the next time the collector finds it unreachable.) 1217 SB435 1385 1551 (Note that a destructor for a collected object cannot safely redefine a clean-up function for its) 1551 SB375 1435 1611 (object, since after the destructor executes, the object has been destroyed into \223raw memory\224. \(In) 1611 SB375 1485 1027 (most implementations, destroying an object mutates its vtbl.\)) 1027 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 1585 470 (An implementation sketch) 470 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1660 1486 (Here's a sketch of an implementation suitable for incremental and concurrent collectors:) 1486 SB435 1710 645 (The collector maintains a single table ) 645 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1080 1715 75 (wps) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1155 1710 812 (, representing both weak pointers and registered) 812 SB375 1762 720 (clean-up functions, for all instances of the ) 720 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1095 1767 175 (CleanUp) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1270 1762 260 ( template class:) 260 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1837 350 (struct Entry {) 350 SB525 1882 675 (    void*           object;) 675 SB525 1927 750 (    int             timeStamp;) 750 SB525 1972 700 (    CleanUpFunction cleanUp;) 700 SB525 2017 625 (    void*           data;) 625 SB525 2062 550 (    CleanUpQueue    q;) 550 SB525 2107 700 (    int             next; };) 700 SB525 2152 300 (Entry wps[];) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2224 778 (A weak pointer is represented as two integers:) 778 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2297 925 (template<class T> class WeakPointer {) 925 SB525 2349 100 (    ) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font625 2344 33 (...) 33 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2392 675 (    int index, timeStamp;};) 675 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2464 174 (The entry ) 174 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font549 2469 425 (e = wps[wp.index]) 425 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font974 2464 405 ( describes weak pointer ) 405 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1379 2469 50 (wp) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1429 2464 23 (: ) 23 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1452 2469 50 (wp) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1502 2464 321 ( is activated only if) 321 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2521 650 (wp.timeStamp = e.timeStamp) 650 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1025 2516 931 ( \(otherwise, the entry has been reused for another weak) 931 SB375 2568 204 (pointer and ) 204 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font579 2573 50 (wp) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font629 2568 276 ( is deactivated\). ) 276 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font905 2573 200 (e.object) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1105 2568 299 ( is the referent of ) 299 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1404 2573 50 (wp) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1454 2568 409 (. The implementation of) 409 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2625 300 (wp.Pointer\(\)) 300 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font675 2620 186 ( looks like:) 186 SB1209 3069 42 (74) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font0 0 0 fC525 267 1050 (template<class T> WeakPointer::Pointer\(\) {) 1050 SB525 312 1150 (    if \(timeStamp == wpTable[index].timeStamp\)) 1150 SB525 357 1050 (        return \(T*\) wpTable[index].object;) 1050 SB525 402 200 (    else) 200 SB525 447 450 (        return 0;}) 450 SB375 524 675 (CleanUp<T, D>::Set\(t, c, d\)) 675 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1050 519 614 ( implicitly creates a weak pointer to ) 614 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1664 524 125 (BO\(t\)) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1789 519 197 ( and sets its) 197 SB375 571 121 (entry's ) 121 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font496 576 175 (cleanUp) 175 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font671 571 22 (, ) 22 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font693 576 100 (data) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font793 571 95 (, and ) 95 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font888 576 25 (q) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font913 571 11 (.) 11 SB435 623 354 (There is at most one ) 354 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font789 628 350 (WeakPointer<T>) 350 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1139 623 458 ( referencing a given object ) 458 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1597 628 100 (T* t) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1697 623 277 (, but many weak) 277 SB375 675 1412 (pointers of different types may address different sub-objects of the same base object ) 1412 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1787 680 100 (BO\(t) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1887 675 90 (\). All) 90 SB375 727 187 (the entries ) 187 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font562 732 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font587 727 56 ( in ) 56 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font643 732 75 (wps) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font718 727 568 ( referring to the same base object ) 568 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1286 732 50 (bo) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1336 727 25 ( \() 25 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1361 732 450 (BO\(e.object\) == bo) 450 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1811 727 77 (\) are) 77 SB375 779 377 (chained through their ) 377 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font752 784 100 (next) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font852 779 1086 ( field. There will be at most one entry in a chain with a non-null) 1086 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 836 225 (e.cleanUp) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font600 831 739 (, and if it there is one, it will be at the head.) 739 SB435 883 223 (A hash table ) 223 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font658 888 225 (boToIndex) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font883 883 1128 ( maps a base-object address to the index of the head of the chain of) 1128 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 940 75 (wps) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font450 935 605 ( entries for that base-object address:) 605 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 1010 800 (    Table<void*, int> boToIndex;) 800 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1082 307 (Unused entries in ) 307 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font682 1087 75 (wps) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font757 1082 451 ( are chained through their ) 451 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1208 1087 100 (next) 100 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1308 1082 114 ( fields.) 114 SB435 1134 293 (For a base object ) 293 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font728 1139 50 (bo) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font778 1134 1122 ( with a null clean-up, the collector deactivates its weak pointers by) 1122 SB375 1186 147 (deleting ) 147 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font522 1191 50 (bo) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font572 1186 103 ( from ) 103 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font675 1191 225 (boToIndex) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font900 1186 352 ( and, for every entry ) 352 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1252 1191 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1277 1186 56 ( in ) 56 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1333 1191 50 (bo) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1383 1186 35 ('s ) 35 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1418 1191 75 (wps) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1493 1186 250 ( chain, setting ) 250 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1743 1191 200 (e.object) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1943 1186 43 ( to) 43 SB375 1238 278 (null and adding ) 278 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font653 1243 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font678 1238 527 ( to the list of unused entries. If ) 527 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1205 1243 50 (bo) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1255 1238 640 ( has a non-null clean-up, the collector) 640 SB375 1290 666 (deactivates its weak pointers by setting ) 666 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1041 1295 650 (e.timeStamp = -e.timeStamp) 650 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1691 1290 268 ( for every entry ) 268 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1959 1295 25 (e) 25 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 1342 45 (in ) 45 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font420 1347 50 (bo) 50 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font470 1342 1482 ('s chain, . The weak pointers may be later reactivated, so the entries can't be deleted yet.) 1482 SB375 1459 1554 (Here's an outline of how a mark-and-sweep collector identifies objects needing clean-up and) 1554 SB375 1509 1351 (deactivates weak pointers. Similar methods can be used with copying collectors:) 1351 SB375 1584 1615 (1. The collector performs the normal mark phase of its collection, marking all objects reachable) 1615 SB375 1634 429 (from the roots. The table ) 429 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font804 1639 75 (wps) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font879 1634 395 ( is not treated as a root.) 395 SB375 1711 992 (2. At the end of normal marking, the collector passes over ) 992 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1367 1716 75 (wps) 75 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1442 1711 540 (, recursively marking all objects) 540 SB375 1763 1615 (that are reachable from an object with a non-null clean-up. An object with a clean-up is marked) 1615 SB375 1813 1595 (only if it is reachable from some other object with a clean-up. \(This marking requires a careful) 1595 SB375 1863 1632 (linear-time implementation to meet the specification of \223reachability\224 given above. In particular,) 1632 SB375 1913 751 (extra mark bits per object appear necessary.\)) 751 SB375 1988 739 (3. For each chain of entries referenced by a ) 739 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1114 1993 275 (<bo, index>) 275 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1389 1988 134 ( pair in ) 134 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1523 1993 225 (boToIndex) 225 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1748 1988 214 (, if the chain) 214 SB375 2040 1643 (references an unmarked object with a null clean-up, the collector deactivates the weak pointers in) 1643 SB375 2090 1555 (the chain. If the chain references an unmarked object with a non-null clean-up, the collector) 1555 SB375 2140 1566 (deactivates the weak pointers, marks the object, sets its clean-up to be null, and enqueues the) 1566 SB375 2190 480 (object on its clean-up queue.) 480 SB375 2265 1617 (4. After collection finishes, the collector removes all entries from the default clean-up queue via) 1617 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font375 2320 400 (while \(q.Call\(\)\)) 400 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font775 2315 11 (.) 11 SB375 2467 891 (The compiler generates a clean-up function for each ) 891 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1266 2472 250 (gc class T) 250 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1516 2467 333 ( that has an explicit) 333 SB375 2519 1030 (destructor or that has a base class with an explicit destructor:) 1030 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font525 2592 300 (class T ...{) 300 SB525 2637 1200 (    static void __CleanUp\(void* data, void* t\) {) 1200 SB525 2682 650 (        \(\(T*\) t\)->~T\(\);}};) 650 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 2754 311 (For an expression ) 311 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font686 2759 125 (new T) 125 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font811 2754 1206 (, the compiler generates a call to register the clean-up function with the) 1206 SB375 2806 759 (newly created base object. For an expression ) 759 SB32 0 0 42 42 0 0 0 33 /Courier /font0 ANSIFont font1134 2811 200 (new T[e]) 200 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1334 2806 590 (, the compiler generates a clean-up) 590 SB375 2858 1106 (function that invokes the destructors of each element of the array.) 1106 SB1209 3069 42 (75) 42 SBEJ RS%%PageTrailerSS0 0 25 11 798 1100 300 SM32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font0 0 0 fC375 267 1633 (**********************************************************************/) 1633 SB375 387 345 (#ifdef _IGNORE_) 345 SB375 427 1633 (/**********************************************************************) 1633 SB32 0 0 42 42 0 0 0 39 /Times-Bold /font29 ANSIFont font375 519 282 (The C interface) 282 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font375 594 1607 (This version has the same semantics as the C++ version, except that it cannot use templates for) 1607 SB375 644 1380 (safe typechecking. The C++ version probably is implemented using this interface.) 1380 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font375 732 1633 (**********************************************************************/) 1633 SB375 812 1173 (typedef struct {int index, timeStamp;} WeakPointer;) 1173 SB495 862 46 (/*) 46 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font541 854 771 ( The struct fields are private to WeakPointer. ) 771 SB32 0 0 38 38 0 0 0 30 /Courier /font0 ANSIFont font1312 862 46 (*/) 46 SB375 942 897 (WeakPointer WeakPointer_New\( void* t \);) 897 SB375 982 1012 (void* WeakPointer_Pointer\( WeakPointer wp \);) 1012 SB375 1062 1219 (typedef void CleanUp_Function\( void* data, void* t \);) 1219 SB375 1102 1518 (void CleanUp_Set\( void* t, CleanUp_Function cleanUp, void* data \);) 1518 SB375 1142 667 (void CleanUp_Call\( void* t \);) 667 SB375 1222 644 (typedef void* CleanUp_Queue;) 644 SB375 1262 782 (CleanUp_Queue CleanUp_Queue_New\(\);) 782 SB375 1302 1173 (void CleanUp_Queue_Set\( CleanUp_Queue q, void* t \);) 1173 SB375 1342 989 (void CleanUp_Queue_Call\( CleanUp_Queue q \);) 989 SB375 1422 483 (#endif /* _IGNORE_ */) 483 SB375 1502 644 (#endif /* _WeakPointer_h_ */) 644 SB32 0 0 42 42 0 0 0 38 /Times-Roman /font32 ANSIFont font1209 3069 42 (76) 42 SBEJ RS%%PageTrailer%%TrailerSVDoc restoreend% TrueType font name key:%    MSTT310000 = %    MSTT310000 = %    MSTT310000 = %    MSTT310000 = %    MSTT310000 = %    MSTT310000 = %    MSTT310000 = %    MSTT310000 = %    MSTT310000 = %    MSTT310000 = %    MSTT310000 = %    MSTT310000 = %    MSTT31c22f = 0907DTimes New RomanF0000002a000001900000%    MSTT31c23c = 0907DTimes New RomanF00000032000002bc0000%    MSTT31c249 = 0907DTimes New RomanF0000002a000002bc0000%    MSTT31c256 = 0907DTimes New RomanF0000003a000002bc0000%    MSTT31c263 = 0907DTimes New RomanF00000032000001900000%    MSTT31c270 = 0907DTimes New RomanF0000002a000001900001%    MSTT31c27d = 0907DCourier NewF0000002a000001900000%    MSTT31c289 = 0907DCourier NewF0000002a000002bc0000%    MSTT31c295 = 0907DWingdingsF0000002a000001900000%    MSTT31c2a1 = 0907DCourier NewF0000002a000001900001%    MSTT31c2ad = 0907DTimes New RomanF00000016000001900000%    MSTT31c2ba = 0907DCourier NewF00000026000001900000%    MSTT31c2c6 = 0907DTimes New RomanF00000026000001900000%%DocumentSuppliedResources: procset Win35Dict 3 1%%+ font MSTT31c295%%DocumentNeededResources: font Courier%%+ font Courier-Bold%%+ font Courier-Oblique%%+ font Symbol%%+ font Times-Bold%%+ font Times-Italic%%+ font Times-Roman%%EOF