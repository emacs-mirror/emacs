%!
%%BoundingBox: (atend)
%%Pages: (atend)
%%DocumentFonts: (atend)
%%EndComments
%
% FrameMaker PostScript Prolog 3.0, for use with FrameMaker 3.0
% Copyright (c) 1986,87,89,90,91 by Frame Technology Corporation.
% All rights reserved.
%
% Known Problems:
%	Due to bugs in Transcript, the 'PS-Adobe-' is omitted from line 1
/FMversion (3.0) def 
% Set up Color vs. Black-and-White
	/FMPrintInColor systemdict /colorimage known
		systemdict /currentcolortransfer known or def
% Uncomment this line to force b&w on color printer
%   /FMPrintInColor false def
/FrameDict 195 dict def 
systemdict /errordict known not {/errordict 10 dict def
		errordict /rangecheck {stop} put} if
% The readline in 23.0 doesn't recognize cr's as nl's on AppleTalk
FrameDict /tmprangecheck errordict /rangecheck get put 
errordict /rangecheck {FrameDict /bug true put} put 
FrameDict /bug false put 
mark 
% Some PS machines read past the CR, so keep the following 3 lines together!
currentfile 5 string readline
00
0000000000
cleartomark 
errordict /rangecheck FrameDict /tmprangecheck get put 
FrameDict /bug get { 
	/readline {
		/gstring exch def
		/gfile exch def
		/gindex 0 def
		{
			gfile read pop 
			dup 10 eq {exit} if 
			dup 13 eq {exit} if 
			gstring exch gindex exch put 
			/gindex gindex 1 add def 
		} loop
		pop 
		gstring 0 gindex getinterval true 
		} def
	} if
/FMVERSION {
	FMversion ne {
		/Times-Roman findfont 18 scalefont setfont
		100 100 moveto
		(FrameMaker version does not match postscript_prolog!)
		dup =
		show showpage
		} if
	} def 
/FMLOCAL {
	FrameDict begin
	0 def 
	end 
	} def 
	/gstring FMLOCAL
	/gfile FMLOCAL
	/gindex FMLOCAL
	/orgxfer FMLOCAL
	/orgproc FMLOCAL
	/organgle FMLOCAL
	/orgfreq FMLOCAL
	/yscale FMLOCAL
	/xscale FMLOCAL
	/manualfeed FMLOCAL
	/paperheight FMLOCAL
	/paperwidth FMLOCAL
/FMDOCUMENT { 
	array /FMfonts exch def 
	/#copies exch def
	FrameDict begin
	0 ne dup {setmanualfeed} if
	/manualfeed exch def
	/paperheight exch def
	/paperwidth exch def
	/yscale exch def
	/xscale exch def
	currenttransfer cvlit /orgxfer exch def
	currentscreen cvlit /orgproc exch def
	/organgle exch def /orgfreq exch def
	setpapername 
	manualfeed {true} {papersize} ifelse 
	{manualpapersize} {false} ifelse 
	{desperatepapersize} if
	end 
	} def 
	/pagesave FMLOCAL
	/orgmatrix FMLOCAL
	/landscape FMLOCAL
/FMBEGINPAGE { 
	FrameDict begin 
	/pagesave save def
	3.86 setmiterlimit
	/landscape exch 0 ne def
	landscape { 
		90 rotate 0 exch neg translate pop 
		}
		{pop pop}
		ifelse
	xscale yscale scale
	/orgmatrix matrix def
	gsave 
	} def 
/FMENDPAGE {
	grestore 
	pagesave restore
	end 
	showpage
	} def 
/FMFONTDEFINE { 
	FrameDict begin
	findfont 
	ReEncode 
	1 index exch 
	definefont 
	FMfonts 3 1 roll 
	put
	end 
	} def 
/FMFILLS {
	FrameDict begin
	array /fillvals exch def
	end 
	} def 
/FMFILL {
	FrameDict begin
	 fillvals 3 1 roll put
	end 
	} def 
/FMNORMALIZEGRAPHICS { 
	newpath
	0.0 0.0 moveto
	1 setlinewidth
	0 setlinecap
	0 0 0 sethsbcolor
	0 setgray 
	} bind def
	/fx FMLOCAL
	/fy FMLOCAL
	/fh FMLOCAL
	/fw FMLOCAL
	/llx FMLOCAL
	/lly FMLOCAL
	/urx FMLOCAL
	/ury FMLOCAL
/FMBEGINEPSF { 
	end 
	/FMEPSF save def 
	/showpage {} def 
	FMNORMALIZEGRAPHICS 
	[/fy /fx /fh /fw /ury /urx /lly /llx] {exch def} forall 
	fx fy translate 
	rotate
	fw urx llx sub div fh ury lly sub div scale 
	llx neg lly neg translate 
	} bind def
/FMENDEPSF {
	FMEPSF restore
	FrameDict begin 
	} bind def
FrameDict begin 
/setmanualfeed {
%%BeginFeature *ManualFeed True
	 statusdict /manualfeed true put
%%EndFeature
	} def
/max {2 copy lt {exch} if pop} bind def
/min {2 copy gt {exch} if pop} bind def
/inch {72 mul} def
/pagedimen { 
	paperheight sub abs 16 lt exch 
	paperwidth sub abs 16 lt and
	{/papername exch def} {pop} ifelse
	} def
	/papersizedict FMLOCAL
/setpapername { 
	/papersizedict 14 dict def 
	papersizedict begin
	/papername /unknown def 
		/Letter 8.5 inch 11.0 inch pagedimen
		/LetterSmall 7.68 inch 10.16 inch pagedimen
		/Tabloid 11.0 inch 17.0 inch pagedimen
		/Ledger 17.0 inch 11.0 inch pagedimen
		/Legal 8.5 inch 14.0 inch pagedimen
		/Statement 5.5 inch 8.5 inch pagedimen
		/Executive 7.5 inch 10.0 inch pagedimen
		/A3 11.69 inch 16.5 inch pagedimen
		/A4 8.26 inch 11.69 inch pagedimen
		/A4Small 7.47 inch 10.85 inch pagedimen
		/B4 10.125 inch 14.33 inch pagedimen
		/B5 7.16 inch 10.125 inch pagedimen
	end
	} def
/papersize {
	papersizedict begin
		/Letter {lettertray letter} def
		/LetterSmall {lettertray lettersmall} def
		/Tabloid {11x17tray 11x17} def
		/Ledger {ledgertray ledger} def
		/Legal {legaltray legal} def
		/Statement {statementtray statement} def
		/Executive {executivetray executive} def
		/A3 {a3tray a3} def
		/A4 {a4tray a4} def
		/A4Small {a4tray a4small} def
		/B4 {b4tray b4} def
		/B5 {b5tray b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	/FMdicttop countdictstack 1 add def 
	statusdict begin stopped end 
	countdictstack -1 FMdicttop {pop end} for 
	} def
/manualpapersize {
	papersizedict begin
		/Letter {letter} def
		/LetterSmall {lettersmall} def
		/Tabloid {11x17} def
		/Ledger {ledger} def
		/Legal {legal} def
		/Statement {statement} def
		/Executive {executive} def
		/A3 {a3} def
		/A4 {a4} def
		/A4Small {a4small} def
		/B4 {b4} def
		/B5 {b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	stopped 
	} def
/desperatepapersize {
	statusdict /setpageparams known
		{
		paperwidth paperheight 0 1 
		statusdict begin
		{setpageparams} stopped pop 
		end
		} if
	} def
/savematrix {
	orgmatrix currentmatrix pop
	} bind def
/restorematrix {
	orgmatrix setmatrix
	} bind def
/dmatrix matrix def
/dpi    72 0 dmatrix defaultmatrix dtransform
    dup mul exch   dup mul add   sqrt def
/freq dpi 18.75 div 8 div round dup 0 eq {pop 1} if 8 mul dpi exch div def
/sangle 1 0 dmatrix defaultmatrix dtransform exch atan def
/DiacriticEncoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
/numbersign /dollar /percent /ampersand /quotesingle /parenleft
/parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K
/L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash
/bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h
/i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar
/braceright /asciitilde /.notdef /Adieresis /Aring /Ccedilla /Eacute
/Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis
/atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis
/iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve
/ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex
/udieresis /dagger /.notdef /cent /sterling /section /bullet
/paragraph /germandbls /registered /copyright /trademark /acute
/dieresis /.notdef /AE /Oslash /.notdef /.notdef /.notdef /.notdef
/yen /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown
/exclamdown /logicalnot /.notdef /florin /.notdef /.notdef
/guillemotleft /guillemotright /ellipsis /.notdef /Agrave /Atilde
/Otilde /OE /oe /endash /emdash /quotedblleft /quotedblright
/quoteleft /quoteright /.notdef /.notdef /ydieresis /Ydieresis
/fraction /currency /guilsinglleft /guilsinglright /fi /fl /daggerdbl
/periodcentered /quotesinglbase /quotedblbase /perthousand
/Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave /Iacute
/Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex /.notdef /Ograve
/Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde /macron
/breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
] def
/ReEncode { 
	dup 
	length 
	dict begin 
	{
	1 index /FID ne 
		{def} 
		{pop pop} ifelse 
	} forall 
	0 eq {/Encoding DiacriticEncoding def} if 
	currentdict 
	end 
	} bind def
/graymode true def
	/bwidth FMLOCAL
	/bpside FMLOCAL
	/bstring FMLOCAL
	/onbits FMLOCAL
	/offbits FMLOCAL
	/xindex FMLOCAL
	/yindex FMLOCAL
	/x FMLOCAL
	/y FMLOCAL
/setpattern {
	 /bwidth  exch def
	 /bpside  exch def
	 /bstring exch def
	 /onbits 0 def  /offbits 0 def
	 freq sangle landscape {90 add} if 
		{/y exch def
		 /x exch def
		 /xindex x 1 add 2 div bpside mul cvi def
		 /yindex y 1 add 2 div bpside mul cvi def
		 bstring yindex bwidth mul xindex 8 idiv add get
		 1 7 xindex 8 mod sub bitshift and 0 ne
		 {/onbits  onbits  1 add def 1}
		 {/offbits offbits 1 add def 0}
		 ifelse
		}
		setscreen
	 {} settransfer
	 offbits offbits onbits add div FMsetgray
	/graymode false def
	} bind def
/grayness {
	FMsetgray
	graymode not {
		/graymode true def
		orgxfer cvx settransfer
		orgfreq organgle orgproc cvx setscreen
		} if
	} bind def
	/HUE FMLOCAL
	/SAT FMLOCAL
	/BRIGHT FMLOCAL
	/Colors FMLOCAL
FMPrintInColor 
	
	{
	/HUE 0 def
	/SAT 0 def
	/BRIGHT 0 def
	% array of arrays Hue and Sat values for the separations [HUE BRIGHT]
	/Colors   
	[[0    0  ]    % black
	 [0    0  ]    % white
	 [0.00 1.0]    % red
	 [0.37 1.0]    % green
	 [0.60 1.0]    % blue
	 [0.50 1.0]    % cyan
	 [0.83 1.0]    % magenta
	 [0.16 1.0]    % comment / yellow
	 ] def
      
	/BEGINBITMAPCOLOR { 
		BITMAPCOLOR} def
	/BEGINBITMAPCOLORc { 
		BITMAPCOLORc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUECOLOR } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUECOLORc } def
	/K { 
		Colors exch get dup
		0 get /HUE exch store 
		1 get /BRIGHT exch store
		  HUE 0 eq BRIGHT 0 eq and
			{1.0 SAT sub setgray}
			{HUE SAT BRIGHT sethsbcolor} 
		  ifelse
		} def
	/FMsetgray { 
		/SAT exch 1.0 exch sub store 
		  HUE 0 eq BRIGHT 0 eq and
			{1.0 SAT sub setgray}
			{HUE SAT BRIGHT sethsbcolor} 
		  ifelse
		} bind def
	}
	
	{
	/BEGINBITMAPCOLOR { 
		BITMAPGRAY} def
	/BEGINBITMAPCOLORc { 
		BITMAPGRAYc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUEGRAY } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUEGRAYc } def
	/FMsetgray {setgray} bind def
	/K { 
		pop
		} def
	}
ifelse
/normalize {
	transform round exch round exch itransform
	} bind def
/dnormalize {
	dtransform round exch round exch idtransform
	} bind def
/lnormalize { 
	0 dtransform exch cvi 2 idiv 2 mul 1 add exch idtransform pop
	} bind def
/H { 
	lnormalize setlinewidth
	} bind def
/Z {
	setlinecap
	} bind def
	/fillvals FMLOCAL
/X { 
	fillvals exch get
	dup type /stringtype eq
	{8 1 setpattern} 
	{grayness}
	ifelse
	} bind def
/V { 
	gsave eofill grestore
	} bind def
/N { 
	stroke
	} bind def
/M {newpath moveto} bind def
/E {lineto} bind def
/D {curveto} bind def
/O {closepath} bind def
	/n FMLOCAL
/L { 
 	/n exch def
	newpath
	normalize
	moveto 
	2 1 n {pop normalize lineto} for
	} bind def
/Y { 
	L 
	closepath
	} bind def
	/x1 FMLOCAL
	/x2 FMLOCAL
	/y1 FMLOCAL
	/y2 FMLOCAL
	/rad FMLOCAL
/R { 
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	x1 y1
	x2 y1
	x2 y2
	x1 y2
	4 Y 
	} bind def
/RR { 
	/rad exch def
	normalize
	/y2 exch def
	/x2 exch def
	normalize
	/y1 exch def
	/x1 exch def
	newpath
	x1 y1 rad add moveto
	x1 y2 x2 y2 rad arcto
	x2 y2 x2 y1 rad arcto
	x2 y1 x1 y1 rad arcto
	x1 y1 x1 y2 rad arcto
	closepath
	16 {pop} repeat
	} bind def
/C { 
	grestore
	gsave
	R 
	clip
	} bind def
	/FMpointsize FMLOCAL
/F { 
	FMfonts exch get
	FMpointsize scalefont
	setfont
	} bind def
/Q { 
	/FMpointsize exch def
	F 
	} bind def
/T { 
	moveto show
	} bind def
/RF { 
	rotate
	0 ne {-1 1 scale} if
	} bind def
/TF { 
	gsave
	moveto 
	RF
	show
	grestore
	} bind def
/P { 
	moveto
	0 32 3 2 roll widthshow
	} bind def
/PF { 
	gsave
	moveto 
	RF
	0 32 3 2 roll widthshow
	grestore
	} bind def
/S { 
	moveto
	0 exch ashow
	} bind def
/SF { 
	gsave
	moveto
	RF
	0 exch ashow
	grestore
	} bind def
/B { 
	moveto
	0 32 4 2 roll 0 exch awidthshow
	} bind def
/BF { 
	gsave
	moveto
	RF
	0 32 4 2 roll 0 exch awidthshow
	grestore
	} bind def
/G { 
	gsave
	newpath
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath fill
	grestore
	} bind def
/A { 
	gsave
	savematrix
	newpath
	2 index 2 div add exch 3 index 2 div sub exch 
	normalize 2 index 2 div sub exch 3 index 2 div add exch 
	translate 
	scale 
	0.0 0.0 1.0 5 3 roll arc 
	restorematrix
	stroke
	grestore
	} bind def
	/x FMLOCAL
	/y FMLOCAL
	/w FMLOCAL
	/h FMLOCAL
	/xx FMLOCAL
	/yy FMLOCAL
	/ww FMLOCAL
	/hh FMLOCAL
	/FMsaveobject FMLOCAL
	/FMoptop FMLOCAL
	/FMdicttop FMLOCAL
/BEGINPRINTCODE { 
	/FMdicttop countdictstack 1 add def 
	/FMoptop count 4 sub def 
	/FMsaveobject save def
	userdict begin 
	/showpage {} def 
	FMNORMALIZEGRAPHICS 
	3 index neg 3 index neg translate
	} bind def
/ENDPRINTCODE {
	count -1 FMoptop {pop pop} for 
	countdictstack -1 FMdicttop {pop end} for 
	FMsaveobject restore 
	} bind def
/gn { 
	0 
	{	46 mul 
		cf read pop 
		32 sub 
		dup 46 lt {exit} if 
		46 sub add 
		} loop
	add 
	} bind def
	/str FMLOCAL
/cfs { 
	/str sl string def 
	0 1 sl 1 sub {str exch val put} for 
	str def 
	} bind def
/ic [ 
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0
	{0 hx} {1 hx} {2 hx} {3 hx} {4 hx} {5 hx} {6 hx} {7 hx} {8 hx} {9 hx}
	{10 hx} {11 hx} {12 hx} {13 hx} {14 hx} {15 hx} {16 hx} {17 hx} {18 hx}
	{19 hx} {gn hx} {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}
	{13} {14} {15} {16} {17} {18} {19} {gn} {0 wh} {1 wh} {2 wh} {3 wh}
	{4 wh} {5 wh} {6 wh} {7 wh} {8 wh} {9 wh} {10 wh} {11 wh} {12 wh}
	{13 wh} {14 wh} {gn wh} {0 bl} {1 bl} {2 bl} {3 bl} {4 bl} {5 bl} {6 bl}
	{7 bl} {8 bl} {9 bl} {10 bl} {11 bl} {12 bl} {13 bl} {14 bl} {gn bl}
	{0 fl} {1 fl} {2 fl} {3 fl} {4 fl} {5 fl} {6 fl} {7 fl} {8 fl} {9 fl}
	{10 fl} {11 fl} {12 fl} {13 fl} {14 fl} {gn fl}
	] def
	/sl FMLOCAL
	/val FMLOCAL
	/ws FMLOCAL
	/im FMLOCAL
	/bs FMLOCAL
	/cs FMLOCAL
	/len FMLOCAL
	/pos FMLOCAL
/ms { 
	/sl exch def 
	/val 255 def 
	/ws cfs 
	/im cfs 
	/val 0 def 
	/bs cfs 
	/cs cfs 
	} bind def
400 ms 
/ip { 
	is 
	0 
	cf cs readline pop 
	{	ic exch get exec 
		add 
		} forall 
	pop 
	
	} bind def
/wh { 
	/len exch def 
	/pos exch def 
	ws 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/bl { 
	/len exch def 
	/pos exch def 
	bs 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/s1 1 string def
/fl { 
	/len exch def 
	/pos exch def 
	/val cf s1 readhexstring pop 0 get def
	pos 1 pos len add 1 sub {im exch val put} for
	pos len 
	} bind def
/hx { 
	3 copy getinterval 
	cf exch readhexstring pop pop 
	} bind def
	/h FMLOCAL
	/w FMLOCAL
	/d FMLOCAL
	/lb FMLOCAL
	/bitmapsave FMLOCAL
	/is FMLOCAL
	/cf FMLOCAL
/wbytes { 
	dup 
	8 eq {pop} {1 eq {7 add 8 idiv} {3 add 4 idiv} ifelse} ifelse
	} bind def
/BEGINBITMAPBWc { 
	1 {} COMMONBITMAPc
	} bind def
/BEGINBITMAPGRAYc { 
	8 {} COMMONBITMAPc
	} bind def
/BEGINBITMAP2BITc { 
	2 {} COMMONBITMAPc
	} bind def
/COMMONBITMAPc { 
	/r exch def
	/d exch def
	gsave
	translate rotate scale /h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	r                    
	/is im 0 lb getinterval def 
	ws 0 lb getinterval is copy pop 
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{ip} image 
	bitmapsave restore 
	grestore
	} bind def
/BEGINBITMAPBW { 
	1 {} COMMONBITMAP
	} bind def
/BEGINBITMAPGRAY { 
	8 {} COMMONBITMAP
	} bind def
/BEGINBITMAP2BIT { 
	2 {} COMMONBITMAP
	} bind def
/COMMONBITMAP { 
	/r exch def
	/d exch def
	gsave
	translate rotate scale /h exch def /w exch def
	/bitmapsave save def 
	r                    
	/is w d wbytes string def
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{cf is readhexstring pop} image
	bitmapsave restore 
	grestore
	} bind def
	/proc1 FMLOCAL
	/proc2 FMLOCAL
	/newproc FMLOCAL
/Fmcc {
    /proc2 exch cvlit def
    /proc1 exch cvlit def
    /newproc proc1 length proc2 length add array def
    newproc 0 proc1 putinterval
    newproc proc1 length proc2 putinterval
    newproc cvx
} bind def
/ngrayt 256 array def
/nredt 256 array def
/nbluet 256 array def
/ngreent 256 array def
	/gryt FMLOCAL
	/blut FMLOCAL
	/grnt FMLOCAL
	/redt FMLOCAL
	/indx FMLOCAL
	/cynu FMLOCAL
	/magu FMLOCAL
	/yelu FMLOCAL
	/k FMLOCAL
	/u FMLOCAL
/colorsetup {
	currentcolortransfer
	/gryt exch def
	/blut exch def
	/grnt exch def
	/redt exch def
	0 1 255 {
		/indx exch def
		/cynu 1 red indx get 255 div sub def
		/magu 1 green indx get 255 div sub def
		/yelu 1 blue indx get 255 div sub def
		/k cynu magu min yelu min def
		/u k currentundercolorremoval exec def
		nredt indx 1 0 cynu u sub max sub redt exec put
		ngreent indx 1 0 magu u sub max sub grnt exec put
		nbluet indx 1 0 yelu u sub max sub blut exec put
		ngrayt indx 1 k currentblackgeneration exec sub gryt exec put
	} for
	{255 mul cvi nredt exch get}
	{255 mul cvi ngreent exch get}
	{255 mul cvi nbluet exch get}
	{255 mul cvi ngrayt exch get}
	setcolortransfer
	{pop 0} setundercolorremoval
	{} setblackgeneration
	} bind def
	/tran FMLOCAL
/fakecolorsetup {
	/tran 256 string def
	0 1 255 {/indx exch def 
		tran indx
		red indx get 77 mul
		green indx get 151 mul
		blue indx get 28 mul
		add add 256 idiv put} for
	currenttransfer
	{255 mul cvi tran exch get 255.0 div}
	exch Fmcc settransfer
} bind def
/BITMAPCOLOR { 
	/d 8 def
	gsave
	translate rotate scale /h exch def /w exch def
	/bitmapsave save def 
	colorsetup
	/is w d wbytes string def
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{cf is readhexstring pop} {is} {is} true 3 colorimage 
	bitmapsave restore 
	grestore
	} bind def
/BITMAPCOLORc { 
	/d 8 def
	gsave
	translate rotate scale /h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	colorsetup
	/is im 0 lb getinterval def 
	ws 0 lb getinterval is copy pop 
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{ip} {is} {is} true 3 colorimage
	bitmapsave restore 
	grestore
	} bind def
/BITMAPTRUECOLORc { 
        gsave
        translate rotate scale /h exch def /w exch def
        /bitmapsave save def 
        
        /is w string def
        
        ws 0 w getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {ip} {gip} {bip} true 3 colorimage
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUECOLOR { 
        gsave
        translate rotate scale /h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop } 
        { cf gis readhexstring pop } 
        { cf bis readhexstring pop } 
        true 3 colorimage 
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUEGRAYc { 
        gsave
        translate rotate scale /h exch def /w exch def
        /bitmapsave save def 
        
        /is w string def
        
        ws 0 w getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {ip gip bip w gray} image
        bitmapsave restore 
        grestore
        } bind def
/ww FMLOCAL
/r FMLOCAL
/g FMLOCAL
/b FMLOCAL
/i FMLOCAL
/gray { 
        /ww exch def
        /b exch def
        /g exch def
        /r exch def
        0 1 ww 1 sub { /i exch def r i get .299 mul g i get .587 mul
			b i get .114 mul add add r i 3 -1 roll floor cvi put } for
        r
        } bind def
/BITMAPTRUEGRAY { 
        gsave
        translate rotate scale /h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop 
          cf gis readhexstring pop 
          cf bis readhexstring pop w gray}  image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPGRAY { 
	8 {fakecolorsetup} COMMONBITMAP
	} bind def
/BITMAPGRAYc { 
	8 {fakecolorsetup} COMMONBITMAPc
	} bind def
/ENDBITMAP {
	} bind def
end 
	/ALDsave FMLOCAL
	/ALDmatrix matrix def ALDmatrix currentmatrix pop
/StartALD {
	/ALDsave save def
	 savematrix
	 ALDmatrix setmatrix
	} bind def
/InALD {
	 restorematrix
	} bind def
/DoneALD {
	 ALDsave restore
	} bind def
%%EndProlog
%%BeginSetup
(3.0) FMVERSION
1 1 612 792 0 1 11 FMDOCUMENT
0 0 /Times-Roman FMFONTDEFINE
1 0 /Times-Bold FMFONTDEFINE
2 0 /Times-Italic FMFONTDEFINE
3 0 /Courier FMFONTDEFINE
32 FMFILLS
0 0 FMFILL
1 .1 FMFILL
2 .3 FMFILL
3 .5 FMFILL
4 .7 FMFILL
5 .9 FMFILL
6 .97 FMFILL
7 1 FMFILL
8 <0f1e3c78f0e1c387> FMFILL
9 <0f87c3e1f0783c1e> FMFILL
10 <cccccccccccccccc> FMFILL
11 <ffff0000ffff0000> FMFILL
12 <8142241818244281> FMFILL
13 <03060c183060c081> FMFILL
14 <8040201008040201> FMFILL
16 1 FMFILL
17 .9 FMFILL
18 .7 FMFILL
19 .5 FMFILL
20 .3 FMFILL
21 .1 FMFILL
22 0.03 FMFILL
23 0 FMFILL
24 <f0e1c3870f1e3c78> FMFILL
25 <f0783c1e0f87c3e1> FMFILL
26 <3333333333333333> FMFILL
27 <0000ffff0000ffff> FMFILL
28 <7ebddbe7e7dbbd7e> FMFILL
29 <fcf9f3e7cf9f3f7e> FMFILL
30 <7fbfdfeff7fbfdfe> FMFILL
%%EndSetup
%%Page: "1" 1
%%BeginPaperSize: Letter
%%EndPaperSize
612 792 0 FMBEGINPAGE
72 745.99 540 756 R
7 X
0 K
V
72 32.69 540 42.7 R
V
0 10 Q
0 X
(1) 303.5 36.03 T
72 72 540 720 R
7 X
V
1 24 Q
0 X
(A Fast W) 109.37 704 T
(rite Barrier for Generational) 206.2 704 T
(Garbage Collectors) 206.41 674 T
0 12 Q
(Urs H\232lzle) 279.85 634 T
(Computer Systems Laboratory) 232.38 619 T
(Stanford University) 258.53 604 T
(urs@cs.stanford.edu) 256.85 589 T
1 14 Q
(Intr) 72 558.67 T
(oduction) 95.84 558.67 T
0 12 Q
4.25 (Generational garbage collectors need to keep track of references from older to younger) 72 538 P
0.12 (generations so that younger generations can be garbage-collected without inspecting every object) 72 523 P
-0.05 (in the older generation\050s\051 [LH83], [Ung86]. The set of locations potentially containing pointers to) 72 508 P
0.02 (newer objects is often called the) 72 493 P
2 F
0.02 (r) 229.31 493 P
0.02 (emember) 233.54 493 P
0.02 (ed set) 277.05 493 P
0 F
0.02 ([Ung86]. At every store, the system must ensure) 307.71 493 P
0.63 (that the updated location is added to the remembered set if the store creates a reference from an) 72 478 P
(older to a newer object. This mechanism is usually referred to as a) 72 463 T
2 F
(write barrier) 393.09 463 T
0 F
( or) 455.39 463 T
2 F
(stor) 471.38 463 T
(e check) 489.6 463 T
0 F
(.) 525.22 463 T
0.7 (For some stores, the compiler can know statically that no store check is necessary) 72 442 P
0.7 (, for example,) 471.99 442 P
-0.17 (when storing an integer \050assuming that integers are implemented as immediates rather than as real) 72 427 P
0.8 (heap-allocated objects\051. However) 72 412 P
0.8 (, in the general case, a store check must be executed for every) 233.98 412 P
1.6 (store operation. Since stores are fairly frequent in non-functional languages, an ef) 72 397 P
1.6 (\336cient write) 480.77 397 P
0.64 (barrier implementation is essential. The write barrier implementation described here reduces the) 72 382 P
(write barrier overhead in the mutator to only two extra instructions per checked store.) 72 367 T
1 14 Q
(Card Marking) 72 336.67 T
0 12 Q
-0.24 (Our new write barrier implementation is based on W) 72 316 P
-0.24 (ilson\325) 322.74 316 P
-0.24 (s card marking scheme [W) 349.4 316 P
-0.24 (il89].) 476.51 316 P
0 10 Q
-0.2 (\240) 502.17 320.8 P
0 12 Q
-0.24 ( In this) 507.16 316 P
-0.02 (scheme, the heap is divided into) 72 301 P
2 F
-0.02 (car) 228.78 301 P
-0.02 (ds) 244.32 301 P
0 F
-0.02 ( of size 2) 254.99 301 P
0 10 Q
-0.02 (k) 298.56 305.8 P
0 12 Q
-0.02 (words \050typically) 306.04 301 P
-0.02 (, k = 5..7\051, and every card has an) 383.52 301 P
1.08 (associated bit in a separate bit vector) 72 286 P
1.08 (. A store check simply marks the bit corresponding to the) 254.36 286 P
3.15 (location being updated. At garbage collection time, the collector scans the bit vector and,) 72 271 P
(whenever it \336nds a marked bit, examines all pointers in the corresponding card in the heap.) 72 256 T
0.95 (Unfortunately) 72 235 P
0.95 (, card marking as just described can be fairly slow) 138.5 235 P
0.95 (. Since the bit must be inserted) 386.73 235 P
1.44 (into the bit vector) 72 220 P
1.44 (, the corresponding word has to be read from memory) 160.79 220 P
1.44 (, updated, and written) 431.42 220 P
2.33 (back. In addition, bit manipulations usually require several instructions on RISC processors.) 72 205 P
2.53 (Chambers and Ungar improved on W) 72 190 P
2.53 (ilson\325) 264.37 190 P
2.53 (s scheme by using bytes instead of bits to mark) 291.03 190 P
0.88 (cards) 72 175 P
0.88 ([Cha92]. That is, every card in the heap has one byte associated with it; a card is marked) 100.3 175 P
0.74 (simply by storing a special value \050e.g., zero\051 into the corresponding byte. Although this scheme) 72 160 P
0.15 (uses eight times more memory) 72 145 P
0.15 (, the space overhead is usually still small; for example, with a card) 219.07 145 P
(size of 32 words = 128 bytes, the space for the byte map is less than 1% of the heap size.) 72 130 T
72 84 540 98.98 C
72 84 540 98.98 R
7 X
0 K
V
81 89.98 225 89.98 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 8 Q
0 X
0 K
(\240) 72 81.33 T
0 10 Q
(Similar but less efficient schemes have been proposed by Sobalvarro [Sob88] and Shaw [Sha88].) 78 77.33 T
72 738 540 747 R
7 X
V
0 X
(Presented at the OOPSLA\32593 Garbage Collection Workshop, Washington, D.C., October 1993.) 115.02 740.33 T
FMENDPAGE
%%EndPage: "1" 2
%%Page: "2" 2
612 792 0 FMBEGINPAGE
72 745.99 540 756 R
7 X
0 K
V
72 32.69 540 42.7 R
V
0 10 Q
0 X
(2) 303.5 36.03 T
72 72 540 720 R
7 X
V
0 12 Q
0 X
1.84 (The big advantage of the byte marking scheme is its speed. In the) 72 712 P
0 11 Q
1.68 (S) 413 712 P
0 10 Q
1.53 (ELF) 419.11 712 P
0 12 Q
1.84 ( system described in) 436.88 712 P
([Cha92], a store check requires just 3 SP) 72 697 T
(ARC instructions in addition to the actual store:) 266.09 697 T
3 F
(st) 108 676 T
([%obj + offset], %ptr) 136.78 676 T
0 10 Q
(store ptr into object\325) 358.99 676 T
(s \336eld) 439.78 676 T
3 12 Q
(add %obj, offset, %temp) 108 644 T
0 10 Q
(calculate address of updated word) 358.99 644 T
3 12 Q
(sll %temp, k, %temp) 108 628 T
0 10 Q
(divide by card size 2) 358.99 628 T
0 8 Q
(k) 441.71 632 T
0 10 Q
( \050shift left\051) 445.7 628 T
3 12 Q
(st) 108 612 T
(%g0, [%byte_map + %temp]) 136.78 612 T
0 10 Q
(clear byte in byte map) 358.99 612 T
0 12 Q
-0.27 (This code sequence assumes that the register byte_map holds the adjusted base address of the byte) 72 590 P
2.09 (map, i.e. byte_map_start_address - \050\336rst_heap_word / 2) 72 575 P
0 10 Q
1.74 (k) 352.01 579.8 P
0 12 Q
2.09 (\051, thus avoiding an extra subtraction) 357.01 575 P
(when computing the index of the byte to be cleared.) 72 560 T
1 14 Q
(A T) 72 529.67 T
(wo-Instruction W) 93.9 529.67 T
(rite Barrier) 199.75 529.67 T
0 12 Q
-0.07 (Our new write barrier improves on standard card marking by relaxing the invariant maintained by) 72 509 P
(the card marking scheme. The invariant maintained by standard card marking is) 72 494 T
(bit or byte) 108 473 T
2 F
( i) 157.3 473 T
0 F
( is marked <--> card) 163.64 473 T
2 F
(i) 264.75 473 T
0 F
( may contain a pointer from old to new) 268.09 473 T
(Our scheme\325) 72 451 T
(s relaxed invariant is) 132.95 451 T
(bit or byte) 108 430 T
2 F
( i) 157.3 430 T
0 F
( is marked <--> cards) 163.64 430 T
2 F
(i..i+l) 269.42 430 T
0 F
(may contain a pointer from old to new) 299.51 430 T
0.44 (where) 72 408 P
2 F
0.44 (l) 104.74 408 P
0 F
0.44 ( is a small constant \0501 in our current implementation\051. Essentially) 108.08 408 P
0.44 (,) 425.2 408 P
2 F
0.44 (l) 431.64 408 P
0 F
0.44 ( gives the store check) 434.98 408 P
0.02 (some) 72 393 P
2 F
0.02 (leeway) 100.33 393 P
0 F
0.02 ( in choosing which byte to mark\321the marked byte may be up to) 133.64 393 P
2 F
0.02 (l) 446 393 P
0 F
0.02 ( bytes away \050in the) 449.33 393 P
1.48 (direction of lower addresses\051 from the \322correct\323 byte. The relaxed invariant allows us to omit) 72 378 P
0.43 (computing the exact address of the updated word: as long as the of) 72 363 P
0.43 (fset of the updated word \050i.e.,) 396.65 363 P
3.31 (its distance from the beginning of the object\051 is less than) 72 348 P
2 F
3.31 (l * 2) 382.52 348 P
2 10 Q
2.76 (k) 410.46 352.8 P
0 12 Q
3.31 (, we can mark the byte) 414.89 348 P
1.87 (corresponding to the object\325) 72 333 P
1.87 (s address rather than the byte corresponding to the updated \336eld.) 211.85 333 P
(Thus, the common-case store check is only two instructions:) 72 318 T
3 F
(st) 108 297 T
([%obj + offset], %ptr) 136.78 297 T
0 10 Q
(store ptr into object\325) 358.99 297 T
(s \336eld) 439.78 297 T
3 12 Q
(sll %obj, k, %temp) 108 265 T
0 10 Q
(calculate \322approximate\323 byte index) 358.99 265 T
3 12 Q
(st) 108 249 T
(%g0, [%byte_map + %temp]) 136.78 249 T
0 10 Q
(clear byte in byte map) 358.99 249 T
0 12 Q
0.98 (Usually) 72 227 P
0.98 (, a leeway of one \050) 108.53 227 P
2 F
0.98 (l = 1) 201.99 227 P
0 F
0.98 (\051 is suf) 227.36 227 P
0.98 (\336cient to cover virtually all stores \050except for stores into) 261.74 227 P
-0.16 (array elements\051. For example, the card size is 128 bytes in the) 72 212 P
0 11 Q
-0.15 (S) 369.83 212 P
0 10 Q
-0.14 (ELF) 375.94 212 P
0 12 Q
-0.16 ( system and thus all stores into) 393.71 212 P
(any of the \336rst 30 \336elds of objects can use the fast code sequence.) 72 197 T
0 10 Q
(\240) 387.76 201.8 T
0 12 Q
1.87 (If the system can determine object boundaries, the maximum leeway restriction can be lifted) 72 176 P
(entirely: in this case, the relaxed variant can be stated as) 72 161 T
(bit or byte) 108 140 T
2 F
( i) 157.3 140 T
0 F
( is marked <-->) 163.64 140 T
-0.01 (card) 242 140 P
2 F
-0.01 (i) 265.63 140 P
0 F
-0.01 ( or the last object starting in card) 268.96 140 P
2 F
-0.01 (i) 429.45 140 P
0 F
-0.01 ( may contain a pointer) 432.78 140 P
(from old to new) 242 124 T
72 84 540 98.98 C
72 84 540 98.98 R
7 X
0 K
V
81 89.98 225 89.98 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 8 Q
0 X
0 K
(\240) 72 81.33 T
0 10 Q
(The first 2 fields of every object are used by the system, so the first user-defined field has an offset of 8 bytes.) 78 77.33 T
FMENDPAGE
%%EndPage: "2" 3
%%Page: "3" 3
612 792 0 FMBEGINPAGE
72 745.99 540 756 R
7 X
0 K
V
72 32.69 540 42.7 R
V
0 10 Q
0 X
(3) 303.5 36.03 T
72 72 540 720 R
7 X
V
0 12 Q
0 X
0.26 (When scanning a card, the garbage collector simply needs to make sure that the last object in the) 72 712 P
-0.09 (card is scanned completely even if only part of it belongs to the card. In other words, the collector) 72 697 P
1.24 (continues scanning beyond the last word of the card until encountering the next object header) 72 682 P
1.24 (.) 537 682 P
2.36 (However) 72 667 P
2.36 (, with very lar) 115.48 667 P
2.36 (ge objects, this scheme could result in high scanning costs since the) 189.61 667 P
0.17 (amount of scanning is no longer bounded by a \336xed maximum leeway but only by the size of the) 72 652 P
0.85 (last object. Fortunately) 72 637 P
0.85 (, this problem can be mitigated by marking the exact card for stores into) 183.19 637 P
2.32 (arrays; then, if the last object starting in a card is an array) 72 622 P
2.32 (, the collector need not continue) 374.51 622 P
(scanning into the next card\050s\051.) 72 607 T
1 14 Q
(Performance evaluation) 72 576.67 T
0 12 Q
0.57 (W) 72 556 P
0.57 (e have implemented the new card marking scheme with a leeway of 1 in the) 82.36 556 P
0 11 Q
0.52 (S) 458.34 556 P
0 10 Q
0.48 (ELF) 464.45 556 P
0 12 Q
0.57 ( system and) 482.22 556 P
(have measured its performance for the) 72 541 T
0 11 Q
(S) 259.17 541 T
0 10 Q
(ELF) 265.28 541 T
0 12 Q
( programs brie\337y described in T) 283.05 541 T
(able) 436.43 541 T
(1.) 459.41 541 T
0.5 (All programs were run on a lightly loaded SP) 72 342 P
0.5 (ARCstation-2. The time consumed by store checks) 292.8 342 P
-0.09 (was determined by running the programs under an instruction-level simulator modelling the exact) 72 327 P
0.85 (hardware behavior of the workstation, including its caching behavior) 72 312 P
0.85 (. The scavenging overhead) 408.89 312 P
3.54 (was measured by running the programs 100 times with a version of the virtual machine) 72 297 P
(instrumented with gprof. Figure) 72 282 T
(1 and T) 228.24 282 T
(able) 264.04 282 T
(2 show the results.) 287.02 282 T
0 10 Q
(Benchmark) 122.96 504.33 T
(Size) 196.4 510.33 T
(\050lines\051) 192.23 498.33 T
(Description) 341.68 504.33 T
(DeltaBlue) 116 476.33 T
(544) 207.01 476.33 T
(two-way constraint solver) 234 476.33 T
(Parser) 116 456.33 T
(522) 207.01 456.33 T
(parser for a version of) 234 456.33 T
0 11 Q
(S) 324.75 456.33 T
0 10 Q
(ELF) 330.86 456.33 T
(PrimMaker) 116 436.33 T
(1097) 202.01 436.33 T
(program generating \322glue\323 stubs for external) 234 436.33 T
0 11 Q
(S) 415.52 436.33 T
0 10 Q
(ELF) 421.63 436.33 T
( primitives) 439.4 436.33 T
(Richards) 116 416.33 T
(413) 207.01 416.33 T
(simple operating system simulator) 234 416.33 T
(Cecil) 116 396.33 T
(10,600) 194.51 396.33 T
(interpreter for the Cecil language) 234 396.33 T
1 12 Q
(T) 227.54 369 T
(able 1: Benchmark pr) 234.43 369 T
(ograms) 346.49 369 T
0 10 Q
(Benchmark) 108.96 233.33 T
(execution) 171.07 239.33 T
(time \050ms\051) 171.21 227.33 T
-0.09 (number of) 227.82 239.33 P
(scavenges) 228.24 227.33 T
(store) 296.79 251.33 T
(checks) 292.9 239.33 T
(card) 355.9 251.33 T
(scanning) 346.73 239.33 T
(total) 413.61 251.33 T
(scavenging) 400.02 239.33 T
(total) 471.61 251.33 T
(overhead) 462.18 239.33 T
(\050as percentage of total execution time\051) 316.76 215.33 T
(DeltaBlue) 108.5 193.33 T
(355) 198.51 193.33 T
(12) 261.51 193.33 T
(4.4%) 308.68 193.33 T
(0.86%) 361.68 193.33 T
(5.5%) 424.68 193.33 T
(9.9%) 482.68 193.33 T
(Parser) 108.5 173.33 T
(204) 198.51 173.33 T
(5) 266.5 173.33 T
(0.4%) 308.68 173.33 T
(0.58%) 361.68 173.33 T
(5.0%) 424.68 173.33 T
(5.4%) 482.68 173.33 T
(PrimMaker) 108.5 153.33 T
(448) 198.51 153.33 T
(12) 261.51 153.33 T
(1.0%) 308.68 153.33 T
(0.42%) 361.68 153.33 T
(9.4%) 424.68 153.33 T
(10.4%) 477.68 153.33 T
(Richards) 108.5 133.33 T
(860) 198.51 133.33 T
(0) 266.5 133.33 T
(7.8%) 308.68 133.33 T
(0.00%) 361.68 133.33 T
(0.0%) 424.68 133.33 T
(7.8%) 482.68 133.33 T
(Cecil) 108.5 113.33 T
(2,228) 191.01 113.33 T
(44) 261.51 113.33 T
(0.5%) 308.68 113.33 T
(0.65%) 361.68 113.33 T
(9.7%) 424.68 113.33 T
(10.2%) 477.68 113.33 T
1 12 Q
(T) 229.76 86 T
(able 2: Scavenging overhead) 236.65 86 T
110 524.95 110 389.05 2 L
V
0.1 H
0 Z
N
182 525.05 182 388.95 2 L
V
N
228 525.05 228 388.95 2 L
V
N
502 524.95 502 389.05 2 L
V
N
109.95 525 502.05 525 2 L
V
N
110.05 490.05 227.95 490.05 2 L
V
N
110.05 487.95 227.95 487.95 2 L
V
N
228.05 489 502.05 489 2 L
V
N
109.95 469 502.05 469 2 L
V
N
109.95 449 502.05 449 2 L
V
N
109.95 429 502.05 429 2 L
V
N
109.95 409 502.05 409 2 L
V
N
109.95 389 502.05 389 2 L
V
N
102.5 265.95 102.5 106.05 2 L
V
N
161.5 266.05 161.5 105.95 2 L
V
N
219.5 266.05 219.5 105.95 2 L
V
N
277.5 266.05 277.5 105.95 2 L
V
N
335.5 266.05 335.5 229.95 2 L
V
N
335.5 204.9 335.5 105.95 2 L
V
N
393.5 266.05 393.5 229.95 2 L
V
N
393.5 204.9 393.5 105.95 2 L
V
N
451.5 266.05 451.5 229.95 2 L
V
N
451.5 204.9 451.5 105.95 2 L
V
N
509.5 265.95 509.5 106.05 2 L
V
N
102.45 266 509.55 266 2 L
V
N
277.45 230 509.55 230 2 L
V
N
102.55 207.05 509.45 207.05 2 L
V
N
102.55 204.95 509.45 204.95 2 L
V
N
102.45 186 509.55 186 2 L
V
N
102.45 166 509.55 166 2 L
V
N
102.45 146 509.55 146 2 L
V
N
102.45 126 509.55 126 2 L
V
N
102.45 106 509.55 106 2 L
V
N
FMENDPAGE
%%EndPage: "3" 4
%%Page: "4" 4
612 792 0 FMBEGINPAGE
72 745.99 540 756 R
7 X
0 K
V
72 32.69 540 42.7 R
V
0 10 Q
0 X
(4) 303.5 36.03 T
72 72 540 720 R
7 X
V
0 12 Q
0 X
0.49 (The system we measured optimizes store checks in two ways. First, no store check is performed) 72 469 P
3.11 (for initializing stores \050i.e., by the _Clone primitive\051, unless the new object is allocated in) 72 454 P
0.7 (OldSpace \050which happens extremely rarely) 72 439 P
0.7 (, if no space is available anywhere else\051. Second, the) 281.2 439 P
0.03 (compiler omits store checks if the stored value is known to be an integer or \337oat, or if it is known) 72 424 P
(to be an \322old\323 object.) 72 409 T
0 10 Q
(\240) 174.26 413.8 T
0 12 Q
0.2 (All of the programs show scavenging overheads of between \336ve and ten percent of total runtime,) 72 388 P
0.13 (and store check overheads between roughly 0.5% and 8% \050which agrees well with measurements) 72 373 P
0.51 (of Lisp programs taken by Zorn) 72 358 P
0.51 ([Zor90]\051. Even with the fast store check code, the card marking) 230.45 358 P
1.78 (overhead signi\336cantly exceeds the card scanning time for three of the benchmarks \050Richards,) 72 343 P
0.59 (DeltaBlue, and PrimMaker\051. For the other two benchmarks, the card marking and card scanning) 72 328 P
1.61 (overheads are about equal.) 72 313 P
0 10 Q
1.35 (\340) 204.73 317.8 P
0 12 Q
1.61 ( For the programs we measured, card marking consumed between) 209.73 313 P
(40% and 100% of the total write barrier cost.) 72 298 T
1 14 Q
(Discussion) 72 267.67 T
0 12 Q
1.99 (Our numbers dif) 72 247 P
1.99 (fer somewhat from those obtained in Chambers\325 study of garbage collection) 155.04 247 P
1.57 (overhead in the) 72 232 P
0 11 Q
1.43 (S) 153.64 232 P
0 10 Q
1.3 (ELF) 159.74 232 P
0 12 Q
1.57 ( system) 177.51 232 P
1.57 ([Cha91]. Generally) 222.96 232 P
1.57 (, Chambers\325 measurements of store checking) 316.34 232 P
-0.03 (overhead showed even higher overheads than our study) 72 217 P
-0.03 (, ranging from 3% to 24% for a similar set) 337.11 217 P
2.4 (of programs. However) 72 202 P
2.4 (, these measurements cannot be directly compared to ours for several) 184.57 202 P
1.45 (reasons. First, too many factors are dif) 72 187 P
1.45 (ferent: hardware, compiler) 265.02 187 P
1.45 (, store-check-implementation,) 394.99 187 P
1.37 (and the) 72 172 P
0 11 Q
1.25 (S) 112.71 172 P
0 10 Q
1.14 (ELF) 118.82 172 P
0 12 Q
1.37 ( programs all have changed. Second, Chambers estimated store-checking time by) 136.59 172 P
2.57 (running two versions of the system, one completely without store checks and one with the) 72 157 P
2.15 (standard store checking code, with an \322eden\323 space lar) 72 142 P
2.15 (ge enough to prevent any scavenging) 351.07 142 P
72 120 540 134.98 C
72 120 540 134.98 R
7 X
0 K
V
81 125.98 225 125.98 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 8 Q
0 X
0 K
0.54 (\240) 72 117.33 P
0 10 Q
0.67 (Old object never become new again, so if the constant being stored is old, the compiler can safely omit the store) 78.54 113.33 P
(check.) 72 101.33 T
0 8 Q
0.88 (\340) 72 93.33 P
0 10 Q
1.1 (The above numbers overestimate the card scanning overhead somewhat since the scanning code is written in C) 78.88 89.33 P
(rather than in assembler where it could exploit doubleword load instructions.) 72 77.33 T
72 72 540 720 C
87.52 477 524.48 720 C
0 23 421 448 627 425 206 93.52 508 FMBEGINEPSF
%%BeginDocument: /export/home/urs/papers/oopsla93-gc/scavenge-overhead.eps
%!PS-Adobe-2.0 EPSF-1.2
%%Creator: DeltaGraph 2.0
%%Title: scavenge-overhead
%%Creation Date: 7/12/93 8:10 PM 
%%BoundingBox: 23 421 448 627
%%DocumentProcSets: DeltaGraph 2.0
%%DocumentSuppliedProcSets: DeltaGraph 2.0
%%DocumentProcessColors: Cyan Magenta Yellow Black
%%DocumentFonts: DeltaSymbol
%%+Times-Roman
%%EndComments
%%BeginProcSet: DeltaGraphPro
/DeltaGraphPro 150 dict def DeltaGraphPro begin
/currentpacking where{pop true setpacking}if
/Version 1.0 def
/Revision 5 def
/bdef{bind def}bind def
/ldef{load def}bdef
/xdef{exch def}bdef
/setcmykcolor where dup not {
/setcmykcolor {1 sub 4 1 roll 3 {3 index add neg dup 0 lt
{pop 0}if 3 1 roll}repeat setrgbcolor pop }def
}if {pop} if
/FillGray 0 def
/FillCyan 0 def
/FillMagenta 0 def
/FillYellow 0 def
/FillBlack 1 def
/FillMac 8 string def
/UseMacFill false def
/StrokeGray 0 def
/StrokeCyan 1 def
/StrokeMagenta 1 def
/StrokeYellow 1 def
/StrokeBlack 1 def
/StrokeMac 8 string def
/UseMacStroke false def
/cmyk{/FillBlack xdef /FillYellow xdef/FillMagenta xdef/FillCyan xdef}bdef
/CMYK{/StrokeBlack xdef /StrokeYellow xdef/StrokeMagenta xdef/StrokeCyan xdef}bdef
/apat 8 string def/mat matrix def
1 0 mat defaultmatrix dtransform exch atan/patang xdef
/sscrn{currentscreen/proc xdef/ang xdef/freq xdef}bdef
/rscrn{freq ang/proc load setscreen}bdef
/macpat{apat copy pop 9.375 patang{1 add 4 mul cvi apat exch get exch 1 add 4 mul cvi 7 sub bitshift 1 and}setscreen setgray}bdef
/d/setdash ldef
/g{false/UseMacFill xdef/FillGray xdef}bdef
/mg{true/UseMacFill xdef FillMac copy pop/FillGray xdef}bdef
/G{false/UseMacStroke xdef/StrokeGray xdef}bdef
/MG{true/UseMacStroke xdef StrokeMac copy pop/StrokeGray xdef}bdef
/_i currentflat def
/i{dup 0 eq{pop _i}if setflat}bdef
/j/setlinejoin ldef
/J/setlinecap ldef
/M/setmiterlimit ldef
/w/setlinewidth ldef
/_R{.25 sub round .25 add}bdef
/_r{transform _R exch _R exch itransform}bdef
/m{_r moveto}bdef
/L{_r lineto}bdef
/c{_r curveto}bdef
/_gf{1.0 FillGray sub mul}bdef
/_gs{1.0 StrokeGray sub mul}bdef
/sf{UseMacFill{FillCyan FillMagenta FillYellow FillBlack setcmykcolor sscrn FillGray FillMac macpat
}{FillGray setgray FillCyan _gf FillMagenta _gf FillYellow _gf FillBlack _gf setcmykcolor}ifelse}bdef
/ss{UseMacStroke{StrokeCyan StrokeMagenta StrokeYellow StrokeBlack setcmykcolor sscrn StrokeGray StrokeMac macpat
}{StrokeGray setgray StrokeCyan _gs StrokeMagenta _gs StrokeYellow _gs StrokeBlack _gs setcmykcolor}ifelse}bdef
/F{sf eofill UseMacFill{rscrn}if}bdef
/f{closepath F}bdef
/S{ss stroke UseMacStroke{rscrn}if}bdef
/s{closepath S}bdef
/B{gsave F grestore S}bdef
/b{closepath B}bdef
/N/newpath ldef
/n/N ldef
/sh{currentpoint 3 -1 roll show 3 -1 roll add moveto}bdef
/NewCodes 256 array def
/NUL/SOH/STX/ETX/EOT/ENQ/ACK/BEL/BS/HT/LF/VT/FF/CR/SO/SI
/DLE/DC1/DC2/DC3/DC4/NAK/SYN/ETB/CAN/EM/SUB/ESC/FS/GS/RS/US
NewCodes 0 32 getinterval astore pop
NewCodes 32/Times-Roman findfont/Encoding get
32 96 getinterval putinterval NewCodes dup 39/quotesingle put 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registeCyan/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/blank/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcenteCyan/quotesinglbase/quotedblbase/perthousand/Acircumflex/Ecircumflex/Aacute
/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave/Oacute/Ocircumflex
/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
NewCodes 128 128 getinterval astore pop
/cd{dup maxlength dict/NF xdef{1 index/FID ne{NF 3 1 roll put}{pop pop}ifelse}forall NF}bdef
/rc{dup cvn/NewName xdef (|______) anchorsearch{pop findfont cd dup/Encoding NewCodes put NewName exch definefont}if pop}bdef
/rfnt{dup FontDirectory exch known{pop}{rc}ifelse}bdef
/sfnt{findfont exch scalefont setfont}bdef
/mfnt{findfont exch makefont setfont}bdef
/oshow{/str2 xdef .1 w 0 1 str2 length 1 sub{str2 exch 1 getinterval false charpath currentpoint stroke m}for}bdef
/ktx {newpath /$1 xdef /$2 xdef /$3 xdef /$4 xdef
$3 $2 moveto $4 show
$1 0 gt { $1 2 div w 0 $1 rmoveto $3 $2 $1 add lineto stroke } if }bdef
/tx{newpath /$1 xdef /$2 xdef /$3 xdef /$4 xdef
dup /$5 xdef
0 1 $4 length 1 sub{$4 exch 1 getinterval exch $2 moveto $3} for
$1 0 gt { $1 2 div w 0 $1 rmoveto $5 $2 $1 add lineto stroke } if}bdef
/showsym {moveto
gsave
/ch xdef
currentpoint initmatrix translate 0 0 moveto
currentfont /FontName get /Courier eq
ch exch charpath flattenpath pathbbox
/ury xdef /urx xdef /lly xdef /llx xdef
urx llx sub -2 div llx sub 
ury lly sub -2 div lly sub
grestore
rmoveto ch show} def
/ps2mac{1 -1 scale
neg 0 exch translate} bdef
/mac2ps{0 exch translate
1 -1 scale} bdef
/xpat{gsave
setcmykcolor eofill 
grestore
gsave
FillCyan FillMagenta FillYellow FillBlack setcmykcolor 
eoclip
/thepat xdef
/right xdef/bottom xdef/left xdef/top xdef
/sizev xdef /sizeh xdef
/shrink exch 72 div def
/howmanywide left right sub abs cvi sizeh idiv 1 add shrink mul 1 add cvi def
/howmanydown bottom top sub abs cvi sizev idiv 1 add shrink mul 1 add cvi def
left top translate
sizeh shrink div sizev shrink div scale
howmanydown {gsave
howmanywide {sizeh sizev true [sizeh 0 0 sizev 0 0] {thepat} imagemask
1 0 translate} repeat
grestore
0 1 translate} repeat
grestore} bdef
/drawrect{/$r xdef
/$b xdef
/$l xdef
/$t xdef
$l $t m $r $t L $r $b L $l $b L closepath} bdef
/drawdiamond{/$r xdef
/$b xdef
/$l xdef
/$t xdef
$l $r add 2 div $t m
$l $t $b add 2 div L
$l $r add 2 div $b L
$r $t $b add 2 div L closepath} bdef
/ellipse{newpath/savematrix matrix currentmatrix def
translate scale 0 0 1 5 -2 roll arc savematrix setmatrix}bdef
/drawcircle{/$r xdef
/$b xdef
/$l xdef
/$t xdef
0 360 $r $l sub 2 div $t $b sub 2 div $r $l add 2 div $b $t add 2 div ellipse} bdef
/dofill{gsave 1 setlinewidth eoclip
/$drawit xdef
/$steps xdef
/$cv xdef /$ch xdef
/$r xdef /$b xdef /$l xdef /$t xdef
/$tstep $t $cv sub $steps div def
/$bstep $b $cv sub $steps div def
/$lstep $l $ch sub $steps div def
/$rstep $r $ch sub $steps div def
dup /$black xdef exch sub $steps div /$blackStep xdef
dup /$yellow xdef exch sub $steps div /$yellowStep xdef
dup /$magenta xdef exch sub $steps div /$magentaStep xdef
dup /$cyan xdef exch sub $steps div /$cyanStep xdef
newpath
0 1 $steps{pop
$cyan $magenta $yellow $black setcmykcolor
$t $l $b $r $drawit eofill
/$t $t $tstep sub def /$l $l $lstep sub def /$b $b $bstep sub def /$r $r $rstep sub def
/$cyan $cyan $cyanStep sub def
/$magenta $magenta $magentaStep sub def
/$yellow $yellow $yellowStep sub def
/$black $black $blackStep sub def} for
grestore} bdef
/dolfill {gsave 1 setlinewidth eoclip
1 sub /$steps xdef
/$r xdef /$b xdef /$l xdef /$t xdef
/$type xdef
1 eq /$isdouble xdef
dup /$black xdef exch sub $steps div /$blackStep xdef
dup /$yellow xdef exch sub $steps div /$yellowStep xdef
dup /$magenta xdef exch sub $steps div /$magentaStep xdef
dup /$cyan xdef exch sub $steps div /$cyanStep xdef
$type 1 eq{/$fromx $l def /$fromy $t def /$tox $r def /$toy $t def
/$stepx 0 def /$stepy $t $b sub $steps div $isdouble { 2 div } if def
$stepx abs $stepy abs gt { $stepx } { $stepy } ifelse abs setlinewidth} if
$type 2 eq{/$fromx $l def /$fromy $t def /$tox $l def /$toy $b def
/$stepx $r $l sub $steps div $isdouble { 2 div } if def /$stepy 0 def
$stepx abs $stepy abs gt { $stepx } { $stepy } ifelse abs setlinewidth} if
$type 3 eq{/$fromx $l $r $l sub 2 div sub def
/$fromy $t $b add 2 div def
/$tox $r $l add 2 div def
/$toy $t $t $b sub 2 div add def
/$stepx $r $l sub $steps div $isdouble { 2 div } if def
/$stepy $t $b sub $steps div $isdouble { 2 div } if def
$stepx abs $stepy abs gt { $stepx } { $stepy } ifelse abs 2 mul setlinewidth} if
$type 4 eq{/$fromx $r $r $l sub 2 div add def
/$fromy $t $b add 2 div def
/$tox $r $l add 2 div def
/$toy $t $t $b sub 2 div add def
/$stepx $r $l sub $steps div neg $isdouble { 2 div } if def
/$stepy $t $b sub $steps div $isdouble { 2 div } if def
$stepx abs $stepy abs gt { $stepx } { $stepy } ifelse abs 2 mul setlinewidth} if
newpath
0 1 $steps{pop
$cyan $magenta $yellow $black setcmykcolor
$fromx $fromy moveto $tox $toy lineto stroke
/$fromx $fromx $stepx add def
/$fromy $fromy $stepy sub def
/$tox $tox $stepx add def
/$toy $toy $stepy sub def
/$cyan $cyan $cyanStep sub def
/$magenta $magenta $magentaStep sub def
/$yellow $yellow $yellowStep sub def
/$black $black $blackStep sub def} for
$isdouble{/$cyanStep $cyanStep neg def
/$magentaStep $magentaStep neg def
/$yellowStep $yellowStep neg def
/$blackStep $blackStep neg def
0 1 $steps 1 sub{pop
/$cyan $cyan $cyanStep sub def
/$magenta $magenta $magentaStep sub def
/$yellow $yellow $yellowStep sub def
/$black $black $blackStep sub def
$cyan $magenta $yellow $black setcmykcolor
$fromx $fromy moveto $tox $toy lineto stroke
/$fromx $fromx $stepx add def
/$fromy $fromy $stepy sub def
/$tox $tox $stepx add def
/$toy $toy $stepy sub def} for} if
grestore} bdef
/myarc {90 exch sub exch 90 exch sub arc} bdef
/arcfill {gsave 1 setlinewidth eoclip
exch dup /$startangle xdef
sub exch dup /$steps xdef
div /$stepsize xdef
/$hight xdef
/$width xdef
/$y xdef
/$x xdef
/$steps $steps 1 sub def
dup /$black xdef exch sub $steps div /$blackStep xdef
dup /$yellow xdef exch sub $steps div /$yellowStep xdef
dup /$magenta xdef exch sub $steps div /$magentaStep xdef
dup /$cyan xdef exch sub $steps div /$cyanStep xdef
$x $y translate
$hight $width gt
{ /$rad $width def 1 $hight $width div scale }
{ /$rad $hight def $width $hight div 1 scale }
ifelse
1 -1 scale
newpath
0 1 $steps{pop
$cyan $magenta $yellow $black setcmykcolor
0 0 moveto
0 0 $rad $startangle dup $stepsize add dup /$startangle xdef myarc
closepath eofill
/$cyan $cyan $cyanStep sub def
/$magenta $magenta $magentaStep sub def
/$yellow $yellow $yellowStep sub def
/$black $black $blackStep sub def} for
grestore} bdef
/currentpacking where{pop false setpacking}if
end
%%EndProcSet
%%BeginSetup
DeltaGraphPro begin 2 setmiterlimit n
1 -1 scale 0 -728 translate
%%EndSetup
% Chart
% Rect
0.078 w
1 g
0 0 0 0 cmyk
0 0 0 1 CMYK
67.168 107.094 m
323.559 107.094 L
323.559 290.559 L
67.168 290.559 L
67.168 107.094 L
f
% Poly line
0.5 w
0 0 0 1 CMYK
67.168 290.559 m
323.559 290.559 L
N
67.168 259.98 m
323.559 259.98 L
N
67.168 229.402 m
323.559 229.402 L
N
67.168 198.824 m
323.559 198.824 L
N
67.168 168.246 m
323.559 168.246 L
N
67.168 137.668 m
323.559 137.668 L
N
67.168 107.094 m
323.559 107.094 L
N
% Poly line
0.5 w
0 0 0 1 CMYK
67.168 290.559 m
67.168 107.094 L
N
118.445 290.559 m
118.445 107.094 L
N
169.723 290.559 m
169.723 107.094 L
N
221 290.559 m
221 107.094 L
N
272.277 290.559 m
272.277 107.094 L
N
323.559 290.559 m
323.559 107.094 L
N
% Poly line
0.25 w
0 G
0 0 0 1 CMYK
64.168 290.559 m
67.168 290.559 L
S
64.168 275.27 m
67.168 275.27 L
S
64.168 259.98 m
67.168 259.98 L
S
64.168 244.691 m
67.168 244.691 L
S
64.168 229.402 m
67.168 229.402 L
S
64.168 214.113 m
67.168 214.113 L
S
64.168 198.824 m
67.168 198.824 L
S
64.168 183.535 m
67.168 183.535 L
S
64.168 168.246 m
67.168 168.246 L
S
64.168 152.957 m
67.168 152.957 L
S
64.168 137.668 m
67.168 137.668 L
S
64.168 122.379 m
67.168 122.379 L
S
64.168 107.094 m
67.168 107.094 L
S
% Poly line
0.5 w
0 G
0 0 0 1 CMYK
61.168 290.559 m
67.168 290.559 L
S
61.168 259.98 m
67.168 259.98 L
S
61.168 229.402 m
67.168 229.402 L
S
61.168 198.824 m
67.168 198.824 L
S
61.168 168.246 m
67.168 168.246 L
S
61.168 137.668 m
67.168 137.668 L
S
61.168 107.094 m
67.168 107.094 L
S
% Poly line
0.5 w
0 G
0 0 0 1 CMYK
67.168 290.559 m
67.168 290.559 L
S
118.445 290.559 m
118.445 290.559 L
S
169.723 290.559 m
169.723 290.559 L
S
221 290.559 m
221 290.559 L
S
272.277 290.559 m
272.277 290.559 L
S
323.559 290.559 m
323.559 290.559 L
S
% Rect
1 w
0 G
0 g
0 0 0 1 cmyk
0 0 0 1 CMYK
79.984 223.285 m
105.625 223.285 L
105.625 290.559 L
79.984 290.559 L
79.984 223.285 L
b
% Rect
1 w
0 G
0.75 g
0 0 0 0 cmyk
0 0 0 1 CMYK
79.984 210.137 m
105.625 210.137 L
105.625 223.285 L
79.984 223.285 L
79.984 210.137 L
b
% Rect
1 w
0 G
0.25 g
0 0 0 0.3 cmyk
0 0 0 1 CMYK
79.984 139.199 m
105.625 139.199 L
105.625 210.137 L
79.984 210.137 L
79.984 139.199 L
b
% Rect
1 w
0 G
0 g
0 0 0 1 cmyk
0 0 0 1 CMYK
131.266 284.441 m
156.902 284.441 L
156.902 290.559 L
131.266 290.559 L
131.266 284.441 L
b
% Rect
1 w
0 G
0.75 g
0 0 0 0 cmyk
0 0 0 1 CMYK
131.266 275.574 m
156.902 275.574 L
156.902 284.441 L
131.266 284.441 L
131.266 275.574 L
b
% Rect
1 w
0 G
0.25 g
0 0 0 0.3 cmyk
0 0 0 1 CMYK
131.266 207.996 m
156.902 207.996 L
156.902 275.574 L
131.266 275.574 L
131.266 207.996 L
b
% Rect
1 w
0 G
0 g
0 0 0 1 cmyk
0 0 0 1 CMYK
182.543 275.27 m
208.18 275.27 L
208.18 290.559 L
182.543 290.559 L
182.543 275.27 L
b
% Rect
1 w
0 G
0.75 g
0 0 0 0 cmyk
0 0 0 1 CMYK
182.543 268.848 m
208.18 268.848 L
208.18 275.27 L
182.543 275.27 L
182.543 268.848 L
b
% Rect
1 w
0 G
0.25 g
0 0 0 0.3 cmyk
0 0 0 1 CMYK
182.543 131.246 m
208.18 131.246 L
208.18 268.848 L
182.543 268.848 L
182.543 131.246 L
b
% Rect
1 w
0 G
0 g
0 0 0 1 cmyk
0 0 0 1 CMYK
233.82 171.305 m
259.461 171.305 L
259.461 290.559 L
233.82 290.559 L
233.82 171.305 L
b
% Rect
1 w
0 G
0.75 g
0 0 0 0 cmyk
0 0 0 1 CMYK
233.82 171.305 m
259.461 171.305 L
259.461 171.305 L
233.82 171.305 L
233.82 171.305 L
b
% Rect
1 w
0 G
0.25 g
0 0 0 0.3 cmyk
0 0 0 1 CMYK
233.82 171.305 m
259.461 171.305 L
259.461 171.305 L
233.82 171.305 L
233.82 171.305 L
b
% Rect
1 w
0 G
0 g
0 0 0 1 cmyk
0 0 0 1 CMYK
285.098 282.914 m
310.738 282.914 L
310.738 290.559 L
285.098 290.559 L
285.098 282.914 L
b
% Rect
1 w
0 G
0.75 g
0 0 0 0 cmyk
0 0 0 1 CMYK
285.098 272.973 m
310.738 272.973 L
310.738 282.914 L
285.098 282.914 L
285.098 272.973 L
b
% Rect
1 w
0 G
0.25 g
0 0 0 0.3 cmyk
0 0 0 1 CMYK
285.098 134.457 m
310.738 134.457 L
310.738 272.973 L
285.098 272.973 L
285.098 134.457 L
b
% Line
0 G
1 w
0 0 0 1 CMYK
67.168 290.559 m
67.168 107.094 L
S
% Line
0 G
1 w
0 0 0 1 CMYK
67.168 290.559 m
323.559 290.559 L
S
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 69.305 295.559 ] concat
0.176 9  m (DeltaBlue) show
grestore
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 130.082 295.559 ] concat
0.012 9  m (Parser) show
grestore
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 168.863 295.559 ] concat
0.176 9  m (PrimMaker) show
grestore
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 226.141 295.559 ] concat
0.176 9  m (Richards) show
grestore
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 285.918 295.559 ] concat
0.336 9  m (Cecil) show
grestore
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 43.168 284.559 ] concat
0.004 9  m (0%) show
grestore
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 43.168 253.98 ] concat
0.004 9  m (2%) show
grestore
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 43.168 223.402 ] concat
0.004 9  m (4%) show
grestore
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 43.168 192.824 ] concat
0.004 9  m (6%) show
grestore
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 43.168 162.246 ] concat
0.004 9  m (8%) show
grestore
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 37.168 131.668 ] concat
0.004 9  m (10%) show
grestore
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 37.168 101.094 ] concat
0.004 9  m (12%) show
grestore
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[0 -1 1 0 23.168 259.824 ] concat
0.355 9  m (% of total execution time) show
grestore
% Rect
1 w
0 G
1 g
0 0 0 0 cmyk
0 0 0 1 CMYK
341.559 138 m
447.559 138 L
447.559 258 L
341.559 258 L
341.559 138 L
b
% Rect
1 w
0 G
0 g
0 0 0 1 cmyk
0 0 0 1 CMYK
351.559 148 m
363.559 148 L
363.559 160 L
351.559 160 L
351.559 148 L
b
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 373.559 148 ] concat
0 9  m (store check) show
grestore
% Rect
1 w
0 G
0.75 g
0 0 0 0 cmyk
0 0 0 1 CMYK
351.559 186 m
363.559 186 L
363.559 198 L
351.559 198 L
351.559 186 L
b
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 373.559 180 ] concat
0 9  m (card) show
0 21  m (scanning) show
grestore
% Rect
1 w
0 G
0.25 g
0 0 0 0.3 cmyk
0 0 0 1 CMYK
351.559 230 m
363.559 230 L
363.559 242 L
351.559 242 L
351.559 230 L
b
0 0 0 1 setcmykcolor
(|______Times-Roman) rfnt [12 0 0 -12 0 0] /|______Times-Roman mfnt
gsave
[1 0 0 1 373.559 224 ] concat
0 9  m (other) show
0 21  m (scavenging) show
grestore
%%Trailer
end

%%EndDocument
FMENDEPSF
200.02 480 444.02 498 R
7 X
0 K
V
1 12 Q
0 X
(Figur) 202.52 490 T
(e) 230.96 490 T
(1. Distribution of Scavenging Overhead) 239.28 490 T
72 72 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "4" 5
%%Page: "5" 5
612 792 0 FMBEGINPAGE
72 745.99 540 756 R
7 X
0 K
V
72 32.69 540 42.7 R
V
0 10 Q
0 X
(5) 303.5 36.03 T
72 72 540 720 R
7 X
V
0 12 Q
0 X
0.41 (during execution of the benchmark. Thus, his measurements may well be less accurate than ours) 72 712 P
(since they could be af) 72 697 T
(fected by caching ef) 176.37 697 T
(fects unrelated to the actual store checking overhead.) 273.06 697 T
0 10 Q
(\240) 527.51 701.8 T
0 12 Q
2.76 (The only write barrier with comparably low mutator overhead that we are aware of is the) 72 676 P
0.3 (sequential store buf) 72 661 P
0.3 (fer \050SSB\051 described by Hosking et al.) 166.31 661 P
0.3 ([Hos92]. The SSB records all locations) 350.64 661 P
1.33 (being stored into; like our scheme, an SSB store barrier takes two instructions \050a store and an) 72 646 P
1.1 (add\051. At scavenge time, the SSB is scanned and the locations referenced by the pointers in the) 72 631 P
2.33 (buf) 72 616 P
2.33 (fer are examined. Although the actual SSB write barrier is just as fast as our scheme, a) 87.77 616 P
2.65 (signi\336cant drawback of the SSB scheme is that the processing ef) 72 601 P
2.65 (fort at scavenging time is) 408.13 601 P
0.51 (proportional to the number of stores performed between scavenges, rather than to the size of the) 72 586 P
0.43 (used part of oldspace \050as for card marking\051. In non-functional languages like) 72 571 P
0 11 Q
0.39 (S) 447.85 571 P
0 10 Q
0.36 (ELF) 453.96 571 P
0 12 Q
0.43 (, stores can be) 470.77 571 P
0.29 (quite frequent, and thus the store buf) 72 556 P
0.29 (fer can gr) 249.73 556 P
0.29 (ow very lar) 296.26 556 P
0.29 (ge. T) 351.24 556 P
0.29 (able) 375.33 556 P
0.29 (3 shows the number of stores) 398.31 556 P
0.93 (requiring a check for each program, and an estimate of the overhead of a SSB implementation.) 72 329 P
2.97 (The column labelled \322ideal SSB overhead\323 shows the estimated overhead of an ideal \050but) 72 314 P
1.7 (somewhat unrealistic\051 SSB implementation consuming a combined overhead \050store check and) 72 299 P
3.14 (buf) 72 284 P
3.14 (fer scanning\051 of 21 cycles per store.) 87.77 284 P
0 10 Q
2.62 (\340) 278.16 288.8 P
0 12 Q
3.14 ( The \322realistic SSB overhead\323 column assumes a) 283.15 284 P
0.05 (combined overhead of 30 cycles per store which still requires careful assembly programming and) 72 269 P
0.24 (very low cache miss ratios; it is intended to represent a very good practical SSB implementation.) 72 254 P
1.13 (Nevertheless, the estimated \322realistic SSB\323 overhead is between 1.5 and almost 4 times higher) 72 239 P
0.75 (than the card marking overhead for all of our benchmarks, and even the \322ideal\323 SSB would not) 72 224 P
1.76 (beat card marking for any of our benchmarks. It appears that stores are too frequent in) 72 209 P
0 11 Q
1.61 (S) 516.12 209 P
0 10 Q
1.47 (ELF) 522.23 209 P
0 12 Q
(programs for the Sequential Store Buf) 72 194 T
(fer to be competitive.) 254.66 194 T
72 144 540 158.98 C
72 144 540 158.98 R
7 X
0 K
V
81 149.98 225 149.98 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 8 Q
0 X
0 K
-0.18 (\240) 72 141.33 P
0 10 Q
-0.22 (Machines with direct-mapped caches such as the Sun workstations used in both studies can exhibit pronounced vari-) 77.82 137.33 P
0.04 (ations in cache effectiveness. It is our experience that the execution time of programs can vary by up to 10 or 15 per-) 72 125.33 P
(cent depending on the exact positioning of code or data on such machines.) 72 113.33 T
0 8 Q
0.63 (\340) 72 105.33 P
0 10 Q
0.79 (9 cycles for the store check \0501 cycle add, 3 cycle store, 5 cycles uncached write overhead\051 and 12 cycles for the) 78.62 101.33 P
-0.19 (scanning \0502 loads at 2 cycles each, 2 cycles for a compare-and-branch, and 6 cycles cache overhead for the load of the) 72 89.33 P
(pointer from the SSB\051.) 72 77.33 T
(Benchmark) 130.13 507.33 T
(number of) 196.73 519.33 T
(checked) 201.04 507.33 T
(stores) 205.75 495.33 T
(\322ideal\323) 264.26 525.33 T
(SSB) 269.52 513.33 T
(overhead) 260.09 501.33 T
(\050estimated\051) 255.93 489.33 T
(\322realistic\323) 319.73 525.33 T
(SSB) 331.1 513.33 T
(overhead) 321.67 501.33 T
(\050estimated\051) 317.5 489.33 T
(card) 392.85 525.33 T
(marking) 384.79 513.33 T
(\050check +) 384.06 501.33 T
(scanning\051) 382.02 489.33 T
(ratio of) 447.88 525.33 T
(\322realistic\323) 442.2 513.33 T
(to card) 448.72 501.33 T
(marking) 445.8 489.33 T
(DeltaBlue) 125.17 467.33 T
(73,782) 206.97 467.33 T
(12.1) 265.51 467.33 T
(1%) 282.64 467.33 T
(17.30%) 326.8 467.33 T
(5.26%) 393.06 467.33 T
(3.29) 454.94 467.33 T
(Parser) 125.17 447.33 T
(3,810) 211.97 447.33 T
(1.04%) 270.14 447.33 T
(1.48%) 331.8 447.33 T
(0.98%) 393.06 447.33 T
(1.51) 454.94 447.33 T
(PrimMaker) 125.17 427.33 T
(22,021) 206.97 427.33 T
(2.88%) 270.14 427.33 T
(4.1) 332.17 427.33 T
(1%) 344.29 427.33 T
(1.42%) 393.06 427.33 T
(2.90) 454.94 427.33 T
(Richards) 125.17 407.33 T
(320,480) 201.98 407.33 T
(21.21%) 265.14 407.33 T
(30.30%) 326.8 407.33 T
(7.80%) 393.06 407.33 T
(3.88) 454.94 407.33 T
(Cecil) 125.17 387.33 T
(57,231) 206.97 387.33 T
(1.50%) 270.14 387.33 T
(2.15%) 331.8 387.33 T
(1.15%) 393.06 387.33 T
(1.87) 454.94 387.33 T
1 12 Q
(T) 162.91 360 T
(able 3: Estimated Overhead of Sequential Stor) 169.81 360 T
(e Buffer) 407.46 360 T
119.17 539.95 119.17 380.05 2 L
V
0.1 H
0 Z
N
187.17 540.05 187.17 379.95 2 L
V
N
247.66 540.05 247.66 379.95 2 L
V
N
309.16 540.05 309.16 379.95 2 L
V
N
370.82 540.05 370.82 379.95 2 L
V
N
432.08 540.05 432.08 379.95 2 L
V
N
492.83 539.95 492.83 380.05 2 L
V
N
119.12 540 492.88 540 2 L
V
N
119.22 481.05 492.78 481.05 2 L
V
N
119.22 478.95 492.78 478.95 2 L
V
N
119.12 460 492.88 460 2 L
V
N
119.12 440 492.88 440 2 L
V
N
119.12 420 492.88 420 2 L
V
N
119.12 400 492.88 400 2 L
V
N
119.12 380 492.88 380 2 L
V
N
FMENDPAGE
%%EndPage: "5" 6
%%Page: "6" 6
612 792 0 FMBEGINPAGE
72 745.99 540 756 R
7 X
0 K
V
72 32.69 540 42.7 R
V
0 10 Q
0 X
(6) 303.5 36.03 T
72 72 540 720 R
7 X
V
1 14 Q
0 X
(Conclusions) 72 710.67 T
0 12 Q
2.82 (W) 72 690 P
2.82 (e propose a new variant of card marking that reduces the marking overhead to just two) 82.36 690 P
1.3 (instructions per store. Even with the two-instruction card marking code, the marking overhead) 72 675 P
0.02 (consumes a signi\336cant fraction of the total cost of maintaining the write barrier) 72 660 P
0.02 (. For the programs) 451.33 660 P
-0.06 (we measured, marking consumed between 40% and 100% of the total write barrier cost \050the other) 72 645 P
-0.23 (part being the time for scanning the cards at scavenge time\051. For two of the programs, the marking) 72 630 P
(overhead even accounted for more than 40% of the total garbage collection overhead.) 72 615 T
0.5 (Given that the marking cost represents roughly half of the total write barrier cost, it appears that) 72 594 P
3.93 (write barrier implementations with a signi\336cantly higher mutator overhead than the two-) 72 579 P
-0.11 (instruction sequence presented here will not be competitive in terms of the total write barrier cost.) 72 564 P
0.27 (The Sequential Store Buf) 72 549 P
0.27 (fer\321as far as we know) 194.19 549 P
0.27 (, the only other write barrier scheme with a two-) 305.73 549 P
3.19 (instruction overhead\321is likely to be signi\336cantly slower than card marking \050based on the) 72 534 P
0.96 (estimates shown in T) 72 519 P
0.96 (able) 175.65 519 P
0.96 (3\051 because its scavenging overhead is too high. Thus, a card-marking) 198.63 519 P
-0.02 (scheme such as the one described here appears to be an excellent choice for maintaining the write) 72 504 P
(barrier in ef) 72 489 T
(\336cient garbage-collected systems.) 128.39 489 T
1 14 Q
(Acknowledgments) 72 458.67 T
0 12 Q
1.6 (I would like to thank Bob Cmelik for) 72 438 P
2 F
1.6 (shade) 266.04 438 P
0 F
1.6 (, the tracing tool used for the measurements, and) 294.02 438 P
1.27 (Gordon Irlam for the) 72 423 P
2 F
1.27 (spa) 180.34 423 P
0 F
1.27 ( SP) 197 423 P
1.27 (ARC simulator) 213.5 423 P
1.27 (. I would also like to think Benjamin Zorn and the) 287.08 423 P
(members of the S) 72 408 T
0 11 Q
(ELF) 156.28 408 T
0 12 Q
( group for their comments on an inital version of this paper) 175.81 408 T
(.) 458.63 408 T
1 14 Q
(Refer) 72 377.67 T
(ences) 105.15 377.67 T
0 11 Q
([Cha91]) 72 358.67 T
0.88 (Craig Chambers. \322Cost of garbage collection in the Self system.\323 OOPSLA'91 GC Work-) 135 358.67 P
(shop, October 1991.) 135 345.67 T
([Cha92]) 72 331.67 T
1.06 (Craig Chambers. \322The Design and Implementation of the SELF Compiler, an Optimizing) 135 331.67 P
0.89 (Compiler for Object-Oriented Programming Languages.\323 Ph.D. Thesis, Computer Science) 135 318.67 P
(Department, Stanford University, 1992.) 135 305.67 T
([Hos92]) 72 291.67 T
-0.3 (Antony Hosking, J. Eliot B. Moss, and Darko Stefanovic. \322A comparative performance eval-) 135 291.67 P
(uation of write barrier implementations.\323 In) 135 278.67 T
2 F
(OOPSLA'92 Proceedings) 329.97 278.67 T
0 F
(, pp. 92-109,) 441.87 278.67 T
([LH83]) 72 264.67 T
0.21 (Henry Lieberman and Carl Hewitt. \322A Real-Time Garbage Collector Based on the Lifetime) 135 264.67 P
(of Objects.\323 Communications of the ACM 26 \0506\051: 419-429.) 135 251.67 T
([Sha88]) 72 237.67 T
1.17 (Robert A. Shaw. \322Empirical Analysis of a LISP System.\323 Stanford University, Computer) 135 237.67 P
(Systems Laboratory, Technical Report CSL-TR-88-351, 1988.) 135 224.67 T
([Sob88]) 72 210.67 T
1.87 (Patrick G. Sobalvarro. \322A lifetime-based collector for LISP systems on general-purpose) 135 210.67 P
(computers.\323 B.S. Thesis, MIT EECS Dept., Cambridge Ma, 1988.) 135 197.67 T
([Ung86]) 72 183.67 T
1.2 (David Ungar,) 135 183.67 P
2 F
1.2 (The Design and Evaluation of a High Performance Smalltalk System.) 199.95 183.67 P
0 F
1.2 ( MIT) 515.91 183.67 P
(Press, Cambridge, MA, 1986.) 135 170.67 T
([Wil89]) 72 156.67 T
0.26 (Paul R Wilson and Thomas G Moher. \322A card-marking scheme for controlling intergenera-) 135 156.67 P
1.51 (tional references in generation-based GC on stock hardware.\323 SIGPLAN Notices 24 \0505\051,) 135 143.67 P
(pp.) 135 130.67 T
(87-92.) 151.48 130.67 T
([Zor90]) 72 116.67 T
0.69 (Benjamin Zorn. \322Barrier Methods for Garbage Collection.\323 Technical Report CU-CS-494-) 135 116.67 P
(90, University of Colorado at Boulder, November 1990.) 135 103.67 T
FMENDPAGE
%%EndPage: "6" 7
%%Trailer
%%BoundingBox: 0 0 612 792
%%Pages: 6 1
%%DocumentFonts: Times-Roman
%%+ Times-Bold
%%+ Times-Italic
%%+ Courier
