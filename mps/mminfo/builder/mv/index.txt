                   MICROSOFT VISUAL C++ 2.0 AND ABOVE
                               builder.mv
                             draft builder
                           richard 1995-08-10

Pre-processor symbol: MPS_BUILD_MV


.what: We're kind of vague about which version of the C compiler we mean:

Microsoft Visual C++ 2.0 (for C only, not C++)

Microsoft Visual C++ 4.2 also works (this is the version we use for C++ work)

Microsoft Visual C++ 5.x also works (this is the version we use for most C 
work)

Microsoft MASM 6.11
MASM 6.11d (a patch release) also works (and the patch is recommended by 
Microsoft)

.what.masm: Here is the patch to get from MASM 6.11 to MASM 6.11d:.  It's a 
self extracting archive.  When you extracted everything, I think you'll need to 
run patch.exe.  I downloaded this from some microsoft site or other.


MASM is slightly unusual for harlequin, it's not standard issue for 
developers.  There are two ways to get it:
1) Buy it (via a Purchase Request / Systems and the usual channels).
2) It is included (bin/win98/ml.exe) as part of Microsoft's Windows 98 DDK, 
available for download from the web:
<URL: http://www.microsoft.com/hwdev/ddk/install98ddk.htm?>

The version of ml.exe provided with the Windows 98 DDK is identical to the 
version provided in MASM 6.11 when patched to 6.11d.  drj checked using comp on 
my machine aaron on 1998-12-09 (drj) that this was the case.

As far as I can tell the license allows up to 10 installations of the software 
per download.

I you install any of the software from the Windows 98 DDK using these 
attachments then please change the installed count and add a record of where it 
is installed.

This software has been installed 1 time(s):
on aaron by drj

If you want to get ml.exe from the Windows 98 DDK you've got three options: 1) 
download the Windows 98 DDK from the microsoft wesbite and install it yourself, 
you'll need "set-up files" (98setup.exe) and "build environment" (98bldenv.exe) 
at a minimum.  2) Install the DDK build environment using these downloaded 
copies.  3) Copy the extracted ml.exe.

If you go for case 2 or 3 please update the installation info above in order to 
comply with the license.





FLAGS

.flags: Various.

.flags.crt: The flags we use to control code generation and linking info for 
linking against the C Runtime (CRT) are documented in 
design.windows.compiler(0))


Runtime library

.status: This section discusses the compiler options which affect the choice of 
C runtime library.

.sources: Section headed "/MD, /ML, /MT, /LD (Use Run-Time Library)" from the 
VC++ documentation. (URL mk:@ivt:vccore/F19/D1E/S4D030.HTM)

.lib-flags: The compiler options affect 3 flags, _MT, _DLL and _DEBUG.  These 
in turn
determine whether the C library is thread-safe, in a separate DLL, and supports
debugging.  The relevant options are as follows:-

 option  _MT _DLL _DEBUG  C library
 ------  --- ---- ------  ---------
 /MD  yes yes no  MSVCRT.LIB
 /MDd  yes yes yes  MSVCRTD.LIB
 /MT  yes no no  LIBCMT.LIB
 /MTd  yes no yes  LIBCMTD.LIB
 /ML  no no no  LIBC.LIB
 /MLd  no no yes  LIBCD.LIB

.effect.link: The options are intended to be used in conjunction with 
particular linking options for the C runtime library, as given by the last 
column in the table above. 

.usage.mps: MPS source code avoids any dependency upon C library 
functionality.  However, the code generated by the VC++ compiler introduces 
implicit dependencies when certain language constructs are used (e.g. for SEH, 
or casting between ints & floats).  Since MPS is normally provided as a 
library, the mapping to the library cannot be ensured at release time.  There 
may be problems if an attempt is made to link an MPS library with an 
inappropriate C library, depending on whether the inappropriate C library 
implements the implicit dependencies any differently from expected C library.  
The safe option is to always link with the correct C library - and the 
Microsoft documentation doesn't strictly permit any other combination.  But 
other combinations should be reliable too - and the following discussion shows 
which.

.flag._MT: The effect of _MT is that code to access errno and a few other 
global locations is compiled specially to use a function call instead.  This 
shouldn't make any difference to MPS, since the implicit dependencies won't be 
accessing errno or the other locations.

.flag._DLL: The effect of _DLL is that the compiler will generate code to 
access functions and variables from the C library via indirections in the DLL 
import table).  Code compiled without _DLL may call C library functions whether 
or not the C library is in a separate DLL. OTOH, it may not be possible to link 
a non-DLL C library with code compiled with _DLL (there would be a link-time 
error).  The _DLL flag must be set correctly for variable accesses to work (and 
this won't be checked at link time).  However, MPS has no implicit dependencies 
on variables in the C library.

.flag._DEBUG: The effect of _DEBUG is that in appropriate circumstances the 
compiler generates additional calls to the C library for checking and debugging 
purposes, and also uses special debugging versions of C library functions.  
This is not necessary for program correctness, but it may aid debugging.  It's 
possible to link code compiled without _DEBUG with a debug version of the C 
library with impunity.  However, this won't be true the other way around if the 
compiler did, indeed, generate an additional call (leading to a link-time 
error). 

.implication.ml-and-mt: The /ML and /MT options should each generate code which 
is compatible with all versions of the C library (assuming the only 
dependencies are the implicit ones).  These options are "universal donors" -- 
but they may lead to slight inefficiencies when used with DLL versions of the C 
library.

.implication.md: The /MD option generates code which probably won't statically 
link against a C library (leading to a link-time error).  It should be possibly 
to link against either MSVCRT.LIB or MSVCRTD.LIB.

.implication.mdd: The /MDd option generates code which probably won't 
statically link against a C library, or against a non-debugging library 
(leading to a link-time error).  It's only known to be safe to link this 
against MSVCRTD.LIB.  Currently, there don't appear to be any problems linking 
MPS code compiled in this way against MSVCRT.LIB.

.mps.options: The MPS build system for the VC++ compiler currently [99-03-19] 
uses the following compiler options:  .mps.options.sw: For ScriptWorks-related 
targets (mmsw.lib & epvmss.exe), MPS is compiled with option /MD for white hot 
variety builds, and /MDd for all other varieties.  These are expected to be 
used with MSVCRT.LIB and MSVCRTD.LIB respectively, as used by ScriptWorks 
release and debug builds respectively.  .mps.options.default: For all other 
targets, regardless of variety, MPS is compiled with option /ML.


VERSIONS

Hints for finding out what version of the C compiler and so on you have.

.version.vc.v4point2: drj has Visual C++ 4.2 on his machine (Aaron).  typing 
"cl" gives the following output:

H:\u\drj\prj\mm\src>cl
Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 10.20.6166 for 80x86
Copyright (C) Microsoft Corp 1984-1996. All rights reserved.

usage: cl [ option... ] filename... [ -link linkoption... ]

.version.vc.v2point0: drj also has Visual C++ 2.0 on Aaron.  This gives the 
following output:

H:\u\drj\prj\mm\src>cl
Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 9.00 for 80x86
Copyright (C) Microsoft Corp 1984-1994. All rights reserved.

usage: cl [ option... ] filename... [ -link linkoption... ]

.version.masm.v6point11d: drj has MASM 6.11d on his machine (Aaron).  typing 
"ml" gives the following output:

H:\u\drj\prj\mm\src>ml
Microsoft (R) Macro Assembler Version 6.11d
Copyright (C) Microsoft Corp 1981-1995.  All rights reserved.

usage: ML [ options ] filelist [ /link linkoptions]
Run "ML /help" or "ML /?" for more info




ATTACHMENTS:

   "Ml611d.exe"
   "98setup.exe"
   "98bldenv.exe"
   "Ml.exe"


