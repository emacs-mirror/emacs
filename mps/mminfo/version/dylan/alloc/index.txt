                   DYLAN "ALLOCATOR" PRODUCT VERSION
                          version.dylan.alloc
                             incomplete doc
                           richard 1995-08-11

Purpose?
Date released?
Release to whom?
Checkpoint identifier?
Manifest?
Versions of files?
Branches?

Checkpoint MMprod_dw_alloc_0 in compound MMprod_dw (and not elsewhere).


REQUIREMENT SATISFACTION

req.dylan.fun.soft.manage.object.alloc
req.dylan.fun.soft.manage.static.alloc
req.dylan.fun.soft.env.c
req.dylan.fun.soft.env.component.gc
req.dylan.fun.soft.env.component.trap
req.dylan.fun.soft.env.arch.i386
req.dylan.fun.soft.env.os.win32
req.dylan.fun.support.use
req.dylan.fun.support.debugging
req.dylan.fun.support.available


RELEASE NOTES

               DYLANWORKS MEMORY MANAGER RELEASE NOTES


                          Release: $Revision: 1.1 $
                           Status: $State: Exp $
                         Modified: $Date: 1994/11/24 13:40:19 $
                  Confidentiality: company confidential
                        Reference: MMprod_dw_doc!readme.txt


0. INTRODUCTION

These are the release notes for the DylanWorks Memory Manager.  This
document describes differences between the supplied memory manager and
the documentation, extensions to the memory manager, and other
information you really ought to know before you start using it.


1. ERRATA

There are currently no known discrepancies between the documentation
and the memory manager.


2. ADDITIONAL INFORMATION

There is currently no information to add to that in the documentation.


3. OTHER STUFF YOU REALLY OUGHT TO KNOW

There is plenty that you really ought to know.

---
$Id: readme.txt,v 1.1 1994/11/24 13:40:19 richard Exp $

                                -*-

                     DYLANWORKS MEMORY MANAGER API


                          Release: $Revision: 1.1 $
                           Status: $State: Exp $
                         Modified: $Date: 1994/11/24 12:26:29 $
                  Confidentiality: company confidential
                        Reference: MMprod_dw_doc!dwapi.txt


** Please read the release notes accompanying the product in the file
   readme.txt.  This may contain important corrections to this
   documentation, and possibly useful extra information to enhance
   your programming pleasure.


CONTENTS

0.      Introduction
1.      General concepts
2.      Manifest
3.      Interface details
3.0       Style
3.1       General -- mm.h
3.2       Arena -- mmarena.h
3.2.1       MMArenaInit
3.2.2       MMArenaFinish
3.3       Pools -- mmpool.h
3.3.1       MMPoolCreate and MMPoolCreateV
3.3.2       MMPoolDestroy
3.4       Generic allocation -- mmalloc.h
3.4.1       MMAlloc
3.4.2       MMFree
3.5       Error codes -- mmerror.h
3.5.1       MMErrorName
3.5.2       MMErrorDesc


0. INTRODUCTION

This document describes the interface to the DylanWorks Memory Manager
product of the Memory Management Project.


1. GENERAL CONCEPTS

Memory is managed within an `arena' which represents resources being
managed.  An arena can be thought of as an address space within which
memory is manipulated.  An arena is represented by an object of type
MMArena.  Each arena is managed completely separately, and no
communication takes place between arenas.

Some operating systems do not support the creation of more than one
arena.  Refer to the operating system specific documentation for
details [dwnt].

Memory within the arena is divided into `pools', represented by
objects of type MMPool.  Each pool is controlled by a memory
management policy defined by its memory pool 'class'.  (Each pool is
an instance of a pool class.)  Pool classes are represented by objects
of type MMPoolClass.

A client program communicates with memory pools via a `generic
function interface'.  A generic function is defined for each
operations which is supported by all memory pool classes.  This has
the advantage that particular calls to the memory manager need not
know which pool class they are using, and therefore classes may be
readily substituted for one another in order to improve particular
attributes such as speed, space, intrusiveness, auditing, etc.

The behaviour of a pool class in response to generic function calls is
defined by that class.  A pool class may also supplement the
functionality available via the generic generic function interface
with class-specific functions.  These are made available on a
class-by-class basis.  Refer to the documentation for the pool class
for details.


2. MANIFEST

The DylanWorks Memory Manager consists of the following parts:

  readme.txt    release notes -- READ THEM
  dwapi.txt     API documentation
  dwnt.txt      Windows NT specific documentation
  dwpca.txt     allocate-only pool class documentation
  dwpcmfs.txt   manual-fixed-small pool class documentation
  dwpcmv.txt    manual-variable pool class documentation
  mmdw.lib      statically linked library for release
  mmdw.dll      dynamically linked library for release
  mmdwg.lib     statically linked library for debugging
  mmdwg.dll     dynamically linked library dor debugging
  mm.h          general interface
  mmarena.h     arena interface
  mmarenos.h    OS specific parameter definition
  mmerror.h     error code definitions and utility interface
  mmpool.h      memory pool interface
  mmalloc.h     generic allocation interface
  mmpca.h       allocate-only memory pool class interface
  mmpcmfs.h     manual-fixed-small memory pool class interface
  mmpcmv.h      manual-variable memory pool class interface

The mmdwg.lib and mmdwg.dll libraries contain code which checks the
validity of all arguments passed through the API, and also performs
internal consistency checks to test for memory corruption or bugs.  If
a check fails, the library writes a message to the standard error
stream and aborts the program by calling the ANSI C library function
`abort'*2.

Notes
 *2. We need to expose the interface which allows the client to
     register an alternative assertion failure handler.
     richard 1994-11-24


3. INTERFACE DETAILS


3.0 STYLE

The interface to the memory manager follows conventions which allow it
to perform validity checks on arguments and results, and also help to
avoid problems of lost error codes and other slip-ups.  The interface
follows some of the suggestions made in [Mag93].

Functions which could legitimately fail at run-time always return an
error code of type MMError (defined in mmerror.h).  Results are
returned via result-arguments which are passed by reference.  The
results are written only if the operation succeeds.  Functions which
may not fail and have a single result return that result.  Functions
which may not fail and have no result are declared to return `void'.

Most objects defined by the interface have an opaque type.  This is
achieved by declaring them as pointers to an incomplete type [ANSI90,
6.1.2.5], which ensures that no client program can dereference access
the object without causing a static type error.  Client programs
should not attempt to examine or modify the contents of these objects.


3.1 GENERAL -- mm.h

mm.h defines the general interface to the memory manager.  This is the
header that most client sources will need to include.  In fact, it is
a convenience header which includes mmerror.h, mmarena.h, mmroot.h,
mmpool.h, and mmalloc.h.  It does _not_ include headers which define
pool classes.  Including mm.h but not any mmpc*.h in client source
will ensure that the code only uses the generic function interface,
and can therefore be passed different memory pools to change its
behaviour without modification.


3.2 ARENA -- mmarena.h

mmarena.h defines the MMArena type and the protocol for initialization
and finalization of arena objects.  Two functions are defined:
MMArenaInit and MMArenaFinish.


3.2.1 MMArenaInit

  extern MMError MMArenaInit(MMArena *arenaReturn,
                             char *buffer,
                             const struct MMArenaParamStruct *params);

MMArenaInit initializes an arena, reserving resources from the
operating system for later management by memory pools.  It takes three
arguments:

- arenaReturn is a pointer to an object of type MMArena which is
  updated with the resulting arena object if the function succeeds.

- buffer is a pointer to an array of characters of size
  MMArenaBUFFER_SIZE for internal use by the arena.  The array must
  exist for as long as the arena is in use (until a call to
  MMArenaFinish) and may not be updated by the client program.

- params is a pointer to a structure which contains operating system
  specific parameters which control arena creation.  See operating
  system specific documentation for details [dwnt].  The structure
  need not be retained after MMArenaInit returns.

The result of MMArenaInit is an error codes of type MMError, defined
in mmerror.h.

Example

  #include <stdio.h>
  #include <stdlib.h>
  #include "mm.h"

  int main(void)
  {
    MMArena arena;
    char mmbuffer[MMArenaBUFFER_SIZE];
    MMError e;

    e = MMArenaInit(&arena, mmbuffer, &MMArenaParamDefault);
    if(e != MMSUCCESS) {
      fprintf(stderr, "Unable to create arena: %s\n", MMErrorName(e));
      exit(EXIT_FAILURE);
    }

    /* Insert program containing MM calls in terms of arena. */

    MMArenaFinish(arena);

    return EXIT_SUCCESS;
  }

Discussion

The arena uses the buffer to store vital control information about the
arena.  It does not use memory in the arena itself to store this
information to minimize the possibility that arena corruption will
cause an undetectable error.


3.2.2 MMArenaFinish

  extern void MMArenaFinish(MMArena arena);

MMArenaFinish finalizes an arena, returning all resources allocated to
it to the operating system.  After an arena object as been passed to
MMArenaFinish it is illegal to pass it to any other memory manager
function again unless it is re-initialized by MMArenaInit.  Any memory
pools or other objects created within the arena are also destroyed and
become invalid.  The buffer passed to MMArenaInit may be deleted or
re-used once the arena is finalized.


3.3 POOLS -- mmpool.h


3.3.1 MMPoolCreate and MMPoolCreateV

  extern MMError MMPoolCreate(MMPool *poolReturn,
                              MMPoolClass class,
                              MMArena arena, ...);

  extern MMError MMPoolCreateV(MMPool *poolReturn,
                               MMPoolClass class,
                               MMArena arena, va_list arg);

MMPoolCreate and MMPoolCreateV create and initialize a new memory pool
object.

MMPoolCreateV is equivalent to MMPoolCreate except that the variable
argument list is replaced by a va_list object which shall have been
initialized using va_start.  PoolCreateV does not call va_end.  This
relationship is similar to that between fprintf and vfprintf [ANSI90,
7.9.6].

Both functions take three generic arguments:

- poolReturn is a pointer to an object of type MMPool which is updated
  with the resulting pool object if the function succeeds.

- class is an object of type MMPoolClass indicating the memory pool
  class to be used to manage the pool.

- arena is an arena object indicating the arena from which memory will
  be managed by the class.

The number and type of further arguments to the function are defined
by the particular pool class.  Refer to the pool class documentation
for details.

The result of MMPoolCreate is an error code of type MMError, defined
in mmerror.h.

Example

  MMPool pool;
  MMError e;

  e = MMPoolCreate(&pool, MMPoolClassMFS, arena,
                   (size_t)1000, (size_t)100);
  if(e != MMSUCCESS) {
    fprintf(stderr, "Unable to create pool: %s\n", MMErrorName(e));
    exit(EXIT_FAILURE);
  }


3.3.2 MMPoolDestroy

  extern void MMPoolDestroy(MMPool pool);

MMPoolDestroy finalizes and deallocates a memory pool object,
returning resources allocated to it to the arena in which it was
created.  After a pool object has been passed to MMPoolDestroy it is
illegal to pass it to any other memory manager function again.  Any
objects or memory allocated from the pool also become invalid.


3.4 GENERIC ALLOCATION -- mmalloc.h


3.4.1 MMAlloc

  extern MMError MMAlloc(void **pReturn, MMPool pool, size_t size);

MMAlloc allocates an object from a memory pool.  The exact meaning of
this operation is defined by the management policy, and therefore by
the pool class.  The function takes three parameters:

- pReturn is a pointer to a generic pointer which is updated with a
  pointer to the allocated object if the function succeeds.

- pool is a memory pool object indicating the pool from which to
  allocate, and therefore, indirectly, the management policy to
  allocate under.

- size is the size of the object to allocate, in bytes.

The result of MMAlloc is an error code of type MMError, defined in
mmerror.h.

Example

  struct spong *p;

  for(;;) {
    MMError e = MMAlloc((void **)&p, pool, sizeof(struct spong));
    if(e == MMSUCESS) break;
    low_memory_recovery();
  }


3.4.2 MMFree

  extern void MMFree(MMPool pool, void *old, size_t size);

MMFree deallocates an object, returning the memory resource associated
with it to the memory pool.  After an object has been passed to MMFree
it is illegal to pass it to any memory manager function again,
including MMFree, or to reference or update the memory that contained it.

The function takes three parameters:

- pool is the memory pool from which the object was allocated.  It
  must match the parameter passed to MMAlloc.  It indirectly specifies
  the management policy to apply to the object.

- old is the generic pointer to the object that was returned by
  MMAlloc.  Some pool classes may relax this restriction, in which
  case the exact meaning of this pointer is determined by the class.
  Refer to the pool class documentation for details.

- size is the size of the object in bytes, and must match the
  parameter massed to MMAlloc.  This restriction may be relaxed by the
  pool class.  Refer to the pool class documentation for details.

Example

  struct spong *foo;
  MMError e;

  e = MMAlloc((void **)&foo, pool, sizeof(struct spong));
  if(e == MMSUCCESS) {
    manipulate(foo);
    MMFree(foo, pool, sizeof(struct spong));
  }


3.5 ERROR CODES -- mmerror.h

Functions which might legitimately fail return an error code of type
MMError.  There are only a limited number of reasons and a function
might fail.  mmerror.h defines the error codes, and functions for
providing more information about errors.

The MMError type is not guaranteed to be any particular type, and the
error code expressions might be macros which expand to non-trivial
expressions.  Objects of type MMError may be compared for equality
with the error codes defined below.

MMSUCCESS indicate that an operation succeeded.  The expression
(MMSUCCESS==0) is true, and therefore error codes may be used directly
in conditional expressions.

MMFAILURE indicates that an operation failed, but not why.  It is
returned when the memory manager cannot determine why an operation
failed.

MMRESOURCE indicates that an operation failed because it was unable to
obtain resources necessary for its completion.  It does not indicate
which resources caused the problem.

MMRESMEM indicates that an operation failed because it was unable to
obtain memory resources.

MMLIMIT indicates that an operation failed because some limitation was
reached.  This could be an internal limitation (e.g. an internal table
is full) or a limitation imposed by previous parameters specified by
the client.

MMUNIMPLEMENTED indicates that an operation failed because some part
of it is unimplemented.  Clients should never see this error.

MMIO indicates that an operation either completely or partially failed
because a system I/O operation failed.


3.5.2 MMErrorName

  extern const char *MMErrorName(MMError error);

MMErrorName returns a pointer to a character string which is the name
of the error code.  For example, MMErrorName(MMRESMEM) returns a
pointer to the string "MMRESMEM".  The string may not be updated by
the client, and may be overwritten by future calls to MMErrorName.


3.5.3 MMErrorDesc

  extern const char *MMErrorDesc(MMError error);

MMErrorDesc returns a pointer to a character string which is a verbose
description of the error code, with as much detail as possible.  The
string may not be updated by the client, and may be overwritten by
future calls to MMErrorDesc.*3

Notes
 *3. The language used in the string ought to depend on the current
     locale.  richard 1994-11-24


A. REFERENCES

dwnt    The DylanWorks Memory Manager API for Windows NT
        Harlequin Group
        DylanWorks Memory Manager Documentation

dwpca   The Allocate-Only Pool Class
        Harlequin Group
        DylanWorks Memory Manager Documentation

dwpcmfs The Manual-Fixed-Small Pool Class
        Harlequin Group
        DylanWorks Memory Manager Documentation

dwpcmv  The Manual-Variable Pool Class
        Harlequin Group
        DylanWorks Memory Manager Documentation

Gilb88  Principles of Software Engineering Management
        Tom Gilb
        Addison-Wesley, 1988

Mag93   Writing Solid Code
        Stephen A. Maguire
        Microsoft Press, 1993

ANSI90  American National Standard for Programming Languages -- C
        ANSI/ISO 9899-1990

---
$Id: dwapi.txt,v 1.1 1994/11/24 12:26:29 richard Exp $


                                -*-


             DYLANWORKS MEMORY MANAGER API FOR WINDOWS NT


                          Release: $Revision: 1.1 $
                           Status: $State: Exp $
                         Modified: $Date: 1994/11/24 12:26:36 $
                  Confidentiality: company confidential
                        Reference: MMprod_dw_doc!dwnt.txt


** Please read the release notes accompanying the product in the file
   readme.txt.  This may contain important corrections to this
   documentation, and possibly useful extra information to enhance
   your programming pleasure.


0. INTRODUCTION

This document describes the Windows NT specific parts of the
DylanWorks Memory Manager API.  It supplements the document [dwapi]
which describes the general API.


1. MEMORY MANAGEMENT UNDER WINDOWS NT

The Memory Manager supports the creation of multiple arenas under
Windows NT [dwapi, 1].


2. ARENA PARAMETERS -- mmarenos.h

There are no NT-specific client-defined parameters for arena creation.
MMArenaInit should be passed a pointer to the default parameter
structure, MMArenaParamDefault.

Example

  #include <stdio.h>
  #include <stdlib.h>
  #include "mm.h"

  int main(void)
  {
    MMArena arena;
    char mmbuffer[MMArenaBUFFER_SIZE];
    MMError e;

    e = MMArenaInit(&arena, mmbuffer, &MMArenaParamDefault);
    if(e != MMSUCCESS) {
      fprintf(stderr, "Unable to create arena: %s\n", MMErrorName(e));
      exit(EXIT_FAILURE);
    }

    /* Insert program containing MM calls in terms of arena. */

    MMArenaFinish(arena);

    return EXIT_SUCCESS;
  }


A. REFERENCES

dwapi   The DylanWorks Memory Manager API
        Harlequin Group
        DylanWorks Memory Manager Documentation

Gilb88  Principles of Software Engineering Management
        Tom Gilb
        Addison-Wesley, 1988

Mag93   Writing Solid Code
        Stephen A. Maguire
        Microsoft Press, 1993

ANSI90  American National Standard for Programming Languages -- C
        ANSI/ISO 9899-1990

---
$Id: dwnt.txt,v 1.1 1994/11/24 12:26:36 richard Exp $


                                -*-


                      DYLANWORKS MEMORY MANAGER
                       ALLOCATE-ONLY POOL CLASS


                          Release: $Revision: 1.1 $
                           Status: $State: Exp $
                         Modified: $Date: 1994/11/24 12:26:44 $
                  Confidentiality: company confidential
                        Reference: MMprod_dw_doc!dwpca.txt


** Please read the release notes accompanying the product in the file
   readme.txt.  This may contain important corrections to this
   documentation, and possibly useful extra information to enhance
   your programming pleasure.


0. INTRODUCTION

This document describes the allocate-only memory pool class supplied
with the DylanWorks Memory Manager.  It suppliments the document
[dwapi] which describes the general API.


1. POLICY

The allocate-only pool class implements a very simple memory
management policy.  Raw memory can be allocated from the pool by call
to the generic function MMAlloc.  Calls to MMFree are ignored.

The allocate-only policy efficiently supports an allocation pattern
where a large number of allocations take place followed by a single
operation to free all the memory allocated.  In particular the
implementation of MMAlloc is very efficient compared to more complex
policies.


2. INTERFACE DETAILS

The interface to the allocate-only pool is defined in mmpca.h.

The pool class object representing the allocate-only pool class is
MMPoolClassA.


2.1 MMPoolCreate

In addition to the generic parameters, MMPoolCreate takes one
additional parameter.

  extern MMError MMPoolCreate(MMPool *poolReturn,
                              MMPoolClass class,
                              MMArena arena,
                              size_t extendBy);

extendBy controls the granularity of memory added to the pool, and
must be positive.  A large extendBy makes allocation faster, but has
high memory resource overheads.  A small extendBy is efficient on
memory resources, but will slow down allocation.  Allocation requests
with sizes larger than extendBy will always be considerably less
efficient.


2.2 MMAlloc

MMAlloc on an allocate-only pool returns a pointer to a raw memory
block.  The memory contents are not guaranteed to be initialized to
any particular value.


2.3 MMFree

Calls to MMFree have no effect.  However, the parameters must still
match those passed to MMAlloc, and the memory manager may check them
for validity.


A. REFERENCES

dwapi   The DylanWorks Memory Manager API
        Harlequin Group
        DylanWorks Memory Manager Documentation

dwnt    The DylanWorks Memory Manager API for Windows NT
        Harlequin Group
        DylanWorks Memory Manager Documentation

Gilb88  Principles of Software Engineering Management
        Tom Gilb
        Addison-Wesley, 1988

Mag93   Writing Solid Code
        Stephen A. Maguire
        Microsoft Press, 1993

ANSI90  American National Standard for Programming Languages -- C
        ANSI/ISO 9899-1990

---
$Id: dwpca.txt,v 1.1 1994/11/24 12:26:44 richard Exp $


                                -*-


                      DYLANWORKS MEMORY MANAGER
                    MANUAL-FIXED-SMALL POOL CLASS


                          Release: $Revision: 1.2 $
                           Status: $State: Exp $
                         Modified: $Date: 1994/11/24 12:42:22 $
                  Confidentiality: company confidential
                        Reference: MMprod_dw_doc!dwpcmfs.txt


** Please read the release notes accompanying the product in the file
   readme.txt.  This may contain important corrections to this
   documentation, and possibly useful extra information to enhance
   your programming pleasure.


0. INTRODUCTION

This document describes the manual-fixed-small memory pool class
supplied with the DylanWorks Memory Manager.  It suppliments the
document [dwapi] which describes the general API.


1. POLICY

The manual-fixed-small pool class implements an efficient policy for
managing sets of objects which have the same size and whose size is
not more than 64 bytes.  Raw memory blocks are allocated by call to
the generic function MMAlloc and released by call to MMFree.

The class stores control structures in the memory it manages, rather
than to one side.  It therefore achieves good VM locality for small
objects, but has both high memory and locality overheads for large
objects.  It should not be used unless you are packing a reasonable
number of objects on to a page, or have only a few pages worth of
objects in total.


2. INTERFACE DETAILS

The interface to the manual-fixed-small pool is defined in mmpcmfs.h.

The pool class object representing the manual-fixed-small pool class
is MMPoolClassMFS.


2.1 MMPoolCreate

In addition to the generic parameters, MMPoolCreate takes two
additional parameters.

  extern MMError MMPoolCreate(MMPool *poolReturn,
                              MMPoolClass class,
                              MMArena arena,
                              size_t extendBy,
                              size_t unitSize);

extendBy is the default number of bytes reserved by the pool at a
time.  A large size will make allocation cheaper but have a higher
resource overhead.  A typical value might be 65536.

unitSize is the size in bytes of the objects you with to allocate.  It
must be larger than the minimum unit size returned by
MMPoolMFSGetInfo, and not larger than extendBy.


2.2 MMAlloc

MMAlloc on a manual-fixed-small pool returns a pointer to a raw memory
block of at least the requested size.  The size parameter must match
the unitSize passed to MMPoolCreate exactly.  The memory contents are
not guaranteed to be intialized to any particular value.  [dwapi,
3.4.1]


2.3 MMFree

MMFree must be passed parameters which match those passed to MMAlloc.
[dwapi, 3.4.2]


2.4 MMPoolMFSGetInfo

** This function is not available.  The minimum unit size which can
** be passed to MMPoolCreate may be assumed to be 16 bytes for the
** time being.

** This documentation is incomplete.


A. REFERENCES

dwapi   The DylanWorks Memory Manager API
        Harlequin Group
        DylanWorks Memory Manager Documentation

dwnt    The DylanWorks Memory Manager API for Windows NT
        Harlequin Group
        DylanWorks Memory Manager Documentation

Gilb88  Principles of Software Engineering Management
        Tom Gilb
        Addison-Wesley, 1988

Mag93   Writing Solid Code
        Stephen A. Maguire
        Microsoft Press, 1993

ANSI90  American National Standard for Programming Languages -- C
        ANSI/ISO 9899-1990

---
$Id: dwpcmfs.txt,v 1.2 1994/11/24 12:42:22 richard Exp $


                                -*-



                      DYLANWORKS MEMORY MANAGER
                      MANUAL-VARIABLE POOL CLASS


                          Release: $Revision: 1.2 $
                           Status: $State: Exp $
                         Modified: $Date: 1994/11/24 12:38:25 $
                  Confidentiality: company confidential
                        Reference: MMprod_dw_doc!dwpcmv.txt


** Please read the release notes accompanying the product in the file
   readme.txt.  This may contain important corrections to this
   documentation, and possibly useful extra information to enhance
   your programming pleasure.


0. INTRODUCTION

This document describes the manual-variable memory pool class supplied
with the DylanWorks Memory Manager.  It suppliments the document
[dwapi] which describes the general API.


1. POLICY

The manual-variable pool class implements a general-purpose policy for
managing objects of any size.  Raw memory blocks are allocated by call
to MMAlloc and released by call to MMFree.

The class provides management for any size of object, and any
combination of sizes.  It will attempt to adapt to the conditions
under which it is used.  This generality has a cost, and the
manual-variable class will usually be less efficient than a special
purpose class which is parameterized with a client's specific
requirements.

The manual-variable pool accepts several parameters which help it to
choose the correct behaviour initially.  If you have several different
patterns of use which suggest different parameters, use several
different pools of this class.


2. INTERFACE DETAILS

The interface to the manual-variable pool is defined in mmpcmv.h.

The pool class object representing the manual-variable pool class is
MMPoolClassMV.


2.1 MMPoolCreate

The manual-variable class adds three arguments to MMPoolCreate.

  extern MMError MMPoolCreate(MMPool *poolReturn,
                              MMPoolClass class,
                              MMArena arena,
                              size_t extendBy,
                              size_t avgSize,
                              size_t maxSize);

extendBy is the default number of bytes reserved by the pool at a
time.  A large size will make allocation cheaper but have a higher
resource overhead.  A typical value might be 65536.

avgSize is an estimate of the average size of an allocation, and is
used to choose the size of internal tables.  An accurate estimate will
improve the efficiency of the pool.  A low estimate will make the pool
less space efficient.  A high estimate will make the pool less time
efficient.  A typical value might be 32.  avgSize must not be less
than extendBy.

maxSize is an estimate of the maximum total size that the pool will
reach.  Setting this parameter does not actually constrain the pool,
but an accurate estimate will improve the efficiency of the pool.
maxSize must not be less than extendBy.


2.2 MMAlloc

MMAlloc on a manual-variable pool returns a pointer to a raw memory
block of at least the requested size.  The memory contents are not
guaranteed to be initialized to any particular value.  [dwapi, 3.4.1]


2.3 MMFree

MMFree must be passed parameters which match those passed to MMAlloc.
[dwapi, 3.4.2]



A. REFERENCES

dwapi   The DylanWorks Memory Manager API
        Harlequin Group
        DylanWorks Memory Manager Documentation

dwnt    The DylanWorks Memory Manager API for Windows NT
        Harlequin Group
        DylanWorks Memory Manager Documentation

Gilb88  Principles of Software Engineering Management
        Tom Gilb
        Addison-Wesley, 1988

Mag93   Writing Solid Code
        Stephen A. Maguire
        Microsoft Press, 1993

ANSI90  American National Standard for Programming Languages -- C
        ANSI/ISO 9899-1990

---
$Id: dwpcmv.txt,v 1.2 1994/11/24 12:38:25 richard Exp $

