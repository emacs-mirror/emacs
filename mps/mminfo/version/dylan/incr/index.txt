                  DYLAN "INCREMENTAL" PRODUCT VERSION
                           version.dylan.incr
                             incomplete doc
                           richard 1995-08-22

Date: Fri, 7 Jul 1995 16:51:31 +0100
To: mm
From: richard (Richard Brooksby)
Subject: More planning -- an incremental version

INCREMENTAL VERSION

Description

This release is the first step to solving the most important requirements
of DylanWorks: acceptable pause times.  Incremental garbage collection is
necessary to amortise the cost of collection across continuing mutator
activity.  The release will _not_ meet the time _overhead_ requirements
(REQ.DYLAN.ATTR.TIME.OVERHEAD) since the underlying garbage collector
algorithm will still be very simple.

Justification

Incrementality is the only way we can ever meet the critical pause time
requirements (REQ.DYLAN.ATTR.TIME.PAUSE).  The problem must be dealt with
soonest to reduce the risk.  Late failure on these requirements would be
disasterous for the project and serious for DylanWorks delivery.  There are
too many unknowns in this area to delay resolution.

Many of the other solution ideas solve problems of overall performance of
the collector.  These address the requirement of time overhead, which is
less critical that that of pause times, although the former contributes to
the latter.

Implementing incrementality before these other ideas also means that we get
to incrementalize a relatively simple collector, and worry about the
interactions with performance-improving schemes later.  Moreover, we won't
run the risk of needing to modify the code which implements these new
schemes in order to make it "incremental" -- we will understand what needs
to be done when we design the for the first time.

Tasks

1       Incrementality
1.1     Investigate detailed requirements on the incremental scheme
1.2     Detailed design of the incremental scheme (use ML)
1.3     Work out in detail the interface with:
         - pool class implementations (see task 5.1),
         - barriers (see task 2.2),
         - the general MM interface.
1.4     Implement the incremental scheme and a non-incremental driver
1.5     Test the incremental scheme using a simple pool and the load/store
        interface.

2       Barriers
2.1     Investigate detailed requirements on barriers
2.2     Work out in detail the interface with the incremental scheme and
        the AMC pool (see task 1.3).
2.3     Implement barriers
2.4     Develop a test for barriers using the load/store interface and a
        simple pool.

3       Load/store interface
3.1     Investigate detailed requirements on the general MM interface
3.2     Detailed design of the general MM interface
3.3     Implement the load/store methods in the interface, and whatever
        other changes arise from the detailed design
3.4     Develop a test for the load/store interface

4       Fault handling
4.1     Investigate detailed requirements on fault handling
4.2     Research how requirements might be met under Win32 with a concrete
        example
4.3     Detailed design of fault handling, including interface to load/store
        interface (see task 3).
4.4     Implement fault handling under Win32
4.5     Develop a test for fault handling

5       Incremental AMC pool class
5.1     Work out detail of interface with incremental scheme (see task 1.3).
5.2     Detailed design of AMC pool class for incrementality and better use of
        allocation buffers.  (ML model?)
5.3     Change implementation of AMC pool class to match new design
5.4     Update and run test for AMC pool class

