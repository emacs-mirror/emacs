           CREATE PLAN FOR DEVELOPMENT OF INCREMENTAL RELEASE
                          obj.plan-dylan-incr
                         obsolete complete obj
                           richard 1995-08-22

Responsible: richard
Due: 25/08/95
Products: proc.plan;obj.*
Sources: obj.dylan.incr
Procedures: proc.plan


1. Create a more detailed description and justification of the incremental 
release.  Which requirements is it supposed to satisfy, for example?
2. Break down objectives required to contribute to release.
3. Estimate work contributing to each objective.
4. Schedule objectives, juiciest first.
5. Refine early objectives in more detail.
6. Negotiate objectives with team.

[Is this a general procedure for planning?]


REPORT:

obj.dylan.incr.design-outline:   Create design document ouline and placeholders

Produce an outline of the design documentation we should have created earlier 
to support the current implementation.  The outline should cover all areas of 
the project which require design documentation, and include the tags for the 
proposed design documents.  The areas for documentation should also be 
prioritized against the current development plan, so that documentation is 
produced to support the next phase of development.  The result will be a set of 
empty (or outline) documents in a hierarchy tagged by "design.*".

obj.dylan.incr.interface:

Design a schema for interfaces to memory managers, including generic prototypes 
for allocation, freeing, etc.  Use this schema to redesign both the external 
interface of the memory manager, and as input to the arena manager redesign.

Our interface to the outside world (SpaceInit, PoolAllocP, etc.) isn't very
well designed (or even defined).  I've had some ideas about "generic
allocation interfaces" which try to give an interface to a wider range of
services from a pool: protection, useful mappings, etc.  We ought to put
much more thought into the interface, and we can't afford to wait much
longer because more of our interface will be exposed to DylanWorks soon,
and will be much less easy to change.

obj.dylan.incr.arena:

Redesign the arena manager interface using the scheme for interfaces to memory 
managers.  The interface must include support for the barrier mechanism 
(address maps to chain of handlers?).  Design an implementation which will 
support the new AMC pool design, which will use more and smaller segments, and 
also require barriers on those segments.  The implementation should obtain 
protection services from the virtual mapping module for the system (vm*.c), if 
present.  The virtual mapping module interface will also require design.

Hardware barriers will require support from the Arena Manager, which
provides our OS abstractions.  The arena interface must be extended to
include "protection" in the abstract, for both the hard and soft barriers.

I would also like to move the arena interface towards a "generic allocation
interface" (idea.interface.alloc) which is similar to the general MM
interface (see below) in the hope that one day we can actually make them
the same, and provide arena-like services to our clients, as well as to
ourselves.

  requirements
    from
      AMC pool
      barrier
      fault handling
    to
      virtual mapping
  solution ideas
    shadow page-table
  generalized interface
  data structures
  implementation

obj.dylan.incr.poolamc:

Redesign the AMC pool implementation to support gray sets, incrementality, 
barriers, buffered allocation, and thread safety.

The current AMC pool is clunky and difficult to adapt to incremental
collection (or even something as simple as allocation buffers).  I have a
design which will significantly simplify it, which providing allocation
buffers and a gray set implementation.  Initial sketches are in
design.mps.poolamc.


obj.dylan.incr.scheduler:

The scheduler is a part of the MPM which takes a specified amount of CPU
time and spends it in order to advance the collection processes in the
system.

Initially, we can measure "CPU time" in terms of "words scanned" or
"objects fixed up".  This may turn out to be an accurate enough measurement
to meet our requirements, but if not we may want to instrument code in more
detail (idea.instrument) or use features of the hardware (cycle clocks) in
order to make better scheduling decisions.

The scheduler should be quite simple at first.  We can start by scheduling
a single collection process, and move on to multiple collections later.  On
a multiprocessor or multithreaded machine there are opportunities for more
sophisticated scheduling.  For example, we might be able to schedule a
single collection's scanning work on two processors at once.

A process object contains the current state of a collection, and is
analogous to a process in a kernel (idea.collect).  Our collectors will be
state machines, so the design of their state is quite important.  Most of
the time, the collection will "contain" the gray set, but sometimes it
might contain the state of other stages such as reclaim, forwarding, or
whatever.

  data structures
    process table
    collection object
      gray set
      stages of collection
        flip
        trace
          scan part of gray set
          copy object incrementally
        reclaim
      barrier handling
  measurement of time
    words scanned/copied
    instrumentation of collector with measure
  decision making
    cost/benefit analysis
    real-time scheduling
    ensuring termination
  read paper.henrick94 again

obj.dylan.incr.grayset:

Gray sets must be implemented by pools on the objects they manage, and also by 
roots.  Design the gray set interface to be used by the collection process as 
the tracer state.  Solution suggestion: use a collection ID and index that into 
data stored adjacent to the objects in the pool.

If we limit the number of concurrent collections, then becomes quite easy
to store the gray set for a collection adjacent to the objects to be
scanned.  Every aggregation of objects that needs to be scanned must
implement a "gray set" abstraction, and a fixed number of sets.  For
example, a pool implemented as a linear block of memory with allocation only
could implement a gray set as a pointer to the next object to be scanned.
The properties of the set matter a lot: operations going on inside the pool
must preserve the grayness of objects so that collections see all the
things they need to.  A small number of objects could go from black to
gray, but not vice versa.  The properties must be clearly defined in the
design.  Initial sketches are in design.dylan.incr.mpm.incremental.

  requirements
  interface
  invariants: black->grey

obj.dylan.incr.barrier:   Create design of software barrier mechanism

The software barrier mechanism takes a soft load/store request and schedules 
whatever work is necessary to lift the barrier condition on the page accessed.  
This requires a mapping from the address to the code which will remove the 
barrier.  Suggestion: the arena page table contains masks with one bit per 
process in the process table.  The load/store request checks the appropriate 
mask and calls the fault handler of the processes which have bits set.  These 
handlers must lift the barrier before returning.

Loads and stores to memory that we manage can be considered as operations
through the MM interface.  In fact, ww can make these operations explicit,
by adding "Load" and "Store" to our interface explicitly.  This gives us a
good place to implement and test incremental collection with barriers
independently of the OS or hardware fault mechanism.  The barrier
mechanism, and its interaction with scheduling, collections, etc. can be
implemented behind this interface.

  requirements
    from
      scheduler
      AMC pool
      fault handling
    to
      fault handling
  load/store interface
  look up in arena page table
  dispatch via chain in page table

obj.dylan.incr.fault:     Create design of hardware fault handling

Each platform will have its own special mechanism for fault handling.  The 
strategy for dealing with this is to "convert" the hardware fault into a soft 
load/store request which will trigger the software barrier mechanism.  This 
reduces the dependency on the the details of the hardware.  The interaction 
between the two needs to be worked out in detail: when is hardware protection 
lifted, for example?  Signal-based platforms will be able to invoke the 
software barrier from the bottom.  Win32 SEH will need to come in from the top 
somehow.

Implementing the hardware barrier is just a matter of converting hardware
loads and stores to protected memory into calls to the software barrier
mechanism.  With the right abstractions this can be independent of the rest
of the MM machinery.  For Win32 we already have a mechanism which uses
Structured Exception Handling, but this is not very satisfactory and we
should investigate alternatives.  We should also be able to construct
barriers on our Unix platforms without much difficulty.

  conversion to software
  implementations
    Win32
      SEH-based
      signal-based?
      other hack?
    Unix

obj.dylan.incr.ranks:    Create design for reference ranking interface

Reference ranking (idea.ranks) defines special behaviour of different "rank" of 
pointer.  In particular, it can include weakness and finalization.  The client 
programmer must have an interface to these different varieties of pointer, and 
Dylan requires weakness and finalization in particular.  We must investigate 
our speculative requirements for this area, and Dylan's particular 
requirements, then design an interface to this stuff.  At the very least, we 
should have a specialized interface to weakness and finalization in order to 
meet the Dylan requirements.

Dylan will require weakness and finalization "soon", though initially an
interface without an implementation would suffice.  We must design and
implement our interface, perhaps generalizing it to include other pointer
"ranks" (idea.ranks).  We must also produce a detailed design for how the
final implementation will work, though we may postpone implementation until
a later release.

obj.buildsys:        Create build system design

Both drj and dsm have mentioned that they spend too long mucking around
with HOPE compounds, changing directories, and editing makefiles for
different target platforms.  This has a lot to do with the way I set up the
build system and divided the sources into "products".  Originally, I
expected us to store a lot more information under HOPE, but now this looks
less likely, and we're probably only going to keep the sources in it.  This
means we can reform and simplify the structure of the sources to make them
easier to handle.  I should produce a design document for the build system
and analyse the requirements a bit more carefully.  The build system will
also need to support various tests.

obj.testssys:        Create test system design

We have ad-hoc tests at the moment.  We need a framework which supports
acceptance tests (against requirements) and regression tests, and we should
construct some tests to go in it, too.

obj.proc.develop:           Document the development process

I'm developing a development process model in order that we can all work
more effectively and get the information we need.  The InfoSys is evolving
to support that process, and will continue to do so, especially in this
phase of development.  I will be placing more emphasis on design
documentation, and linking together implementation, design, requirements,
etc.  I'm also going to tinker with the review process.  The aim is to
support development, so if something's not appropriate, speak up!  The
InfoSys _is_ a bureaucracy, but it's supposed to be one which we all work
on to make sure it does the right thing.  (Have a look at
book.gilb93.policy.cqi.)


BACKGROUND WORK

There are quite a few minor issues around: inconsistencies in the code,
untidy stuff, obsolete conventions, etc.  I'm going to plan time to fix
these up as well as concentrating on vital development, as I believe that
we are only laying traps for ourselves if we don't sort them out.

  Deal with issues
  Implementation procedure
  Source analysis and recommendations
  Review procedure
  Purify evaluation




