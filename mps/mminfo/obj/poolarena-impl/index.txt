                REIMPLEMENT THE ARENA AND MAKE IT A POOL
                           obj.poolarena-impl
                         obsolete finished obj
                           richard 1995-09-12

Responsible: drj
Due: 16/10/95
Products: impl.h.arena;impl.c.arena
Sources: design.mps.arena
Procedures: proc.universal


A new arena manager is needed to support the incremental AMC pool 
implementation.  Implement the design documented in pool.mps.arena, and make 
the new arena a pool, with extended interface.

Here is my hack at an interface:

/*  ==== TEMPORARY ARENA POOL ====
 *
 *  $HopeName$
 */

#ifndef poolaren_h
#define poolaren_h


#include "std.h"
#include "lib.h"
#include "pool.h"
#include "space.h"
#include "refsig.h"
#include <stddef.h>


extern PoolClass PoolClassArena(void);

typedef struct ArenaStruct *Arena;

extern Error ArenaCreate(Arena *arenaReturn, Space space);
extern void ArenaDestroy(Arena arena);
extern Error ArenaInit(Arena arena, Space space);
extern void ArenaFinish(Arena arena);
extern Bool ArenaIsValid(Arena arena, ValidationType validParam);
extern Error ArenaDescribe(Arena arena, LibStream stream);
extern Pool (ArenaPool)(Arena arena);


/*  == Preferenced Allocation ==
 *
 *  ArenaAllocHere is like AllocP, except that the arena places the
 *  allocated block such that its reference signature (returned by
 *  ArenaBlockRefSig) is a subset of a particular signature.
 *  [What are the failure conditions and codes?]
 *
 *  ArenaRefSig returns the reference signature that would be obtained
 *  by accumulating all the addresses in a block into the empty refsig.
 */
 
extern Error ArenaAllocHere(Addr *baseReturn, Arena arena, Addr size,
                            RefSig refsig);
extern RefSig ArenaBlockRefSig(Arena arena, Addr base);


/*  == Address Translation ==
 *
 *  ArenaBlockOfAddr finds the base address of the arena block from any
 *  address within it.  If there exists a block in the arena which contains
 *  the address, it returns TRUE and sets *baseReturn to the base address
 *  of the block.  Otherwise it returns FALSE and does not update
 *  *baseReturn.
 */

extern Bool   ArenaBlockOfAddr(Arena arena, Addr *baseReturn, Addr addr);


/*  == Granularity ==
 *
 *  The granularity is the alignment of both the base address and
 *  size of blocks allocated from the arena.
 *  
 *  [Consider adding these to generic interface.]
 */

extern Addr ArenaGrainSize(Arena arena);
extern unsigned ArenaGrainShift(Arena arena);


/*  == Association ==
 *
 *  The arena can associate N pointers with each allocated block.
 *
 *  ArenaKeys returns N, the number of pointers which can be associated
 *  with each block.  The pointers are numbered 0 to N-1.
 *
 *  ArenaPut associates a pointer with a block, labelled by a key.
 *  ArenaGet retrieves the pointer labelled by a key which was previously
 *  associated with a block, or NULL if no pointer was previously Put.
 */

extern int ArenaKeys(Arena arena);
extern void ArenaPut(Arena arena, Addr base, int key, void *p);
extern void *ArenaGet(Arena arena, Addr base, int key);


/*  == Software Barrier ==
 *
 *  The arena defines N different "types" of access.  (These might
 *  be interpreted by the client as 0=read, 1=write, etc.)  For each
 *  type of access it can store M barrier flags for every block.
 *  (These flags might correspond with processes.)
 *
 *  ArenaAccessTypes returns the N, the number of different types of
 *  access provided by the arena.  These are numbered 0 to N-1.
 *
 *  ArenaAccessFlags returns M, the number of barrier flags provided
 *  for each block.  These are numbered 0 to M-1.
 *
 *  ArenaAccess calls handlers for an access type if the block is
 *  barred (i.e. has any barrier flags set) for that access type.
 *  During the calls to the handlers the block is not barred, and it
 *  is illegal to call ArenaAccess on it (e.g. the mutator accesing a
 *  block while it is being scanned.)
 *
 *  ArenaBar sets a barrier flag for a block for an access type.
 *  ArenaUnbar clears a barrier flag.
 *
 *  ArenaHandle installs a handler function for an access type.  It
 *  returns the previous handler function, or NULL if the access type
 *  was not handled.  Installing a NULL handle ignores accesses for that
 *  type.
 */

typedef void (*ArenaHandler)(Arena arena, int access, int flagIdx, Addr addr);

extern int ArenaAccessTypes(Arena arena);
extern int ArenaAccessFlags(Arena arena);
extern void ArenaAccess(Arena arena, int access, Addr addr);
extern void ArenaBar(Arena arena, int access, Addr base, int flagIdx);
extern void ArenaUnbar(Arena arena, int access, Addr base, int flagIdx);
extern ArenaHandler ArenaHandle(Arena arena, int access, int flagIdx,
                                ArenaHandler handler);

#endif /* poolaren_h */


