                         EVALUATE PURE PRODUCTS
                            obj.rival-purify
                          obsolete started obj
                             drj 1995-10-30

Responsible: drj
Due: 10/11/95
Products: .report
Procedures: proc.universal


Falls into two categories:
Evaluation of rival products (Purify)
Evaluation of tools (PureCoverage, PureLink, PureTestExpert, PureDDTS, Quantify)

Evalute Purify as a rival.
Evaluate PureCoverage as a tool.



REPORT:

Schedule:

Purify rival evaluation:
Peruse manual 1 day
Install evaluation copy of Purify .5 day
Use Purify .5 day
write report 1 day
I imagine most of the critical analysis can be carried out by reading the 
manual alone.  I am intending out the analysis by bearing in mind the questions 
below:



How to evaluate a rival product.

What is the intended market for the product?
What does it do?
What technology does it use to do this?
What is the user interface?
What is the impact on the customers' existing practises?
How complete is it?
What doesn't it do in the same area?
What about it can be improved upon?


How to evaluate a tool.

What is the intended market?
What does it do?
What do I want?
What is the interface?
How will I have to change my practises?
What is the support like?
How much training will I need?
What will the benefit be?
How long will it take me before I start to acrue the benefit?


Purify.
Can it detect when I reference B array from A array pointer?
Can it cope with obscure behaviour of BSD free (wrt realloc)?
Limitations:  You cannot purify a quantified program; you cannot quantify a 
purified program
Can it purify servers?
detect out of bounds with automatic extent variables.
read from a calloc'ed area without initing it.
work with other obscure BSD allocators (memalign, valloc, realloc)
Purify _can_ work with PureCoverage.
No red bounds on static arrays
on stack, red bounds between frames only
has cute 3 letter names for errors.  FUM, ABW, UMR, etc.
assert_is_{readable|writable}.  I like this.
free-queue-length and assorted parms are adjustable.
has a "pool" API which allows custom MMs to associate a word with a given 
malloc'ed block, and to map over all blocks with a given association.  Have to 
think about how we could use this.
see page 161 re SBR SBW
can it cope with various obscure things happening during atexit functions? (try 
on_exit in SunOS)
does it work with alloca?
can it detect _unreachable_ things as well as _unreferenced_ things?
try it with rc, or kawk.


!995-11-09 Purify
James had installed purify yesterday.  Started the "hello world" example.  
Seems to work.  
Can't invoke the editor from the Purify Viewer (xterm pops up and immediately 
vanishes).
Tracked this down to my EDITOR environment variable being set to /usr/bin/ed.
finished hello world
purify produces intermediate object files that are world writable.  Why?
Read/Write errors are reported as soon as they are detected.  Leaks are 
detected at program exit or by a call to (mumble).
drj1: can't detect when accessing B array from A pointer (surprise, surprise).
drj2: gives a FUM when reallocing a freed block (not in the spirit of the man 
page).
drj3: can't detect ABW if automatic arrays.  See page 36.
drj4: can read from calloc'ed block without provoking errors.
drj5: gives a PAR error if realloc's first parm is 0 (but notes that this works 
in an ANSI implementation).
      works with memalign and valloc.
drj6: doesn't do leak detection until after on_exit functions have been called 
(this is correct).
      correctly detects memory leaked during an on_exit function.
drj7: couldn't get alloca to work.
drj8: correctly detects unreachable blocks, even when they have references.

After Purify was installed I quickly went through the "Purifying Hello World" 
example in the User Manual.Purify is dead easy to use.  Just stick purify in 
front of your linker line.  It detects all common misuses of standard malloc 
and free.  It handles calls to valloc and memalign (on SunOS) as well.  It 
whinges if you try to use realloc as an allocator (first arg NULL).

It is quite easy to suppress messages, but the granularity of suppression is 
not quite as good as I would like.  I would like to be able to suppress 
messages generated from a particular call location.  Currently only the 
function call chain can be used (ie, you can't specify line-number information).

Who should use it?

The intended market for Purify is (I guess) application developers.  It seems 
that is supposed to be used during the latter stages of development, when you 
have a product that stands a fair chance of running with no "obvious" bugs.  It 
is intended to discover memory usage errors; these include scribbling of the 
end of arrays, leaking allocated memory, attempting to free memory not 
allocated (freeing twice).

What is it like to use?

It is trivial to use, just put the word "purify" before your linker command, 
running the resultant program then invokes a purify "listener".  All the errors 
that purify detects are logged in the listener.  Each type of error has a cute 
3 letter code (FUM for Freeing Unallocated Memory, FMW for Free Memory Write, 
etc).  It works by tagging the heap with 2 extra bits (an allocated bit and an 
initialised bit), allocated heap blocks have "safety zones" around them, freed 
heap blocks are kept on a reserve list in order to detect memory references to 
them.  It finds all types of errors that you could reasonably expect to find 
using this method.  Stack frames have "safety zones" around them, but objects 
in the frame do not (which means it can only detect references of the end of a 
stack allocated array if they go beyond the stack frame as well).
My experience.  The listener (or viewer as they call it) runs like a dog, but 
then I'm not surprised as all serious X applications seem to.  The trivial test 
programs I ran through came up with no susprises, only minor annoyances 
(realloc(0,1) gives a PAR message, which is a warning, and it does note that 
this is valid under strict ANSI).  I tried purifiying two real programs:  rc - 
a shell - running its supplied test suite, and awk running a date format 
conversion script of my own devising on a small (10 line) file.  The results 
are slightly hard to interpret, mostly because I wasn't intimately familiar 
with the code.  There were memory leaks reported (not very large ones); I 
suspect that they were in fact pseudo-leaks.  To expand, purify is fascist and 
regards memory as leaked if it is not reachable upon exit.  If the only 
pointers to memory are automatic variables in main, and main returns (the 
variables going out of scope), then purify will report the memory as leaked 
even though you are just about to exit (usually).  It is possible to get round 
this by modifying the program to call "purify_new_leaks" just before returning 
from main.

Hacky internals

SPARC details.  Purify uses the global registers, some of which are designated 
in the Architecture Manual as "reserved for the application".  As far as I can 
tell, they simply rely on the C compiler not using these global registers.  All 
stores and loads are translated so that they indirect through a single global 
register (%g3 as it happens).  Another global register points to a jump table 
(for the type of operation) and the tag table.  A few other registers are used 
for miscellaneous (unknown) purposes.

Can we use it?

Hard.  Purify intercepts calls to malloc.  There are ways of using purify if 
you have a custom allocator, but they all boil down to modifying the custom 
allocator so that it calls malloc.  This is fine if your custom allocator acts 
essentially like malloc, but we do tricks with zones which would not be 
possible if we had to call malloc.

Conclusion

Pure have done a very complete job with Purify.  It's a tool that helps you 
debug your programs memory errors without changing your source code, it can 
therefore be deployed with existing software.  Pretty much the only serious 
thing it lacks is telling you _when_ memory was leaked, though you can get some 
idea by (as they suggest) stepping the program in a debugger and calling 
purify_new_leaks frequently.  I can think of a few ways of telling when memory 
was leaked (making write operations more expensive) and I don't see why they 
can't, so I wouldn't be surprised if a future version had an option to do 
this.  I don't believe there is much scope for improvement in this niche.  
There is, as Tucker points out in his earlier analysis 
(rival.purify.analysis.1), scope for different products.  There is little to be 
gained by deployment purify within the MM group.


