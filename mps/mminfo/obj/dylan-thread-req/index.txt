                INITIAL INVESTIGATION INTO THREAD SAFETY
                          obj.dylan-thread-req
                         obsolete finished obj
                           richard 1995-08-29

Responsible: dsm
Due: 30/08/95
Products: .report
Procedures: proc.universal


I need help with obj.dylan-thread-req.

There are two parts to this:
  1. what needs to be done in the MPS
  2. what we need to do in the Dylan glue

Take a look around the sources and work out which areas are vulnerable and what 
we might be able to do in the short term to make the system "thread safe".  
It's worth talking to Tony to find out what they need, in fact -- what does 
"thread safe" mean to them?  Is my idea of locking the "Space" and then 
incrementally pushing the locks deeper valid?  What steps might we actually 
take to do this?

How might we go about locating thread state?  Tony has offerred to declare 
thread state to us in the past.  Ask him what they're prepared to do (negotiate 
the level of the Dylan glue interface).  Who is responsible for actually 
finding the thread state?  What do we need to do to scan it?

Suggested approach: sketch data structures and examine the entry points.

We'll go through your notes together and produce an analysis.


REPORT:

SUMMARY

Now

In order to support thread safety now we need to:
.build.env: Use thread safe libraries.
.mpm.suspend: Implement suspension and resumption of mutator.
.std.lock: Implement locking in std.
.dw.scan-stacks: Add os specific scan stack code to dw.
.dw.init: Add explicit MMinit() call to dw.
.dw.register: Incorporate thread registration
.dw.lock: Add locks around calls to MPS.

I do not how to be sure that this is all we need to do, apart from testing it 
and seeing whether it works.
I have not thought much about testing.  But it is going to be tricky to do it 
well.

Future

- We need to worry a bit more about exceptions.
- There are ways of improving performance if lock contention is the problem.
- Performance should be acceptable once buffers are in place.


DETAILS (well some)

Thread Safe Environment

All our calls to the outside world must be to thread safe interfaces.  In 
particular we must use thread safe versions of libraries.  Calls will be in the 
context of running thread, which will be whatever thread calls us.

Suspending the Mutator

We have to worry about concurrent mutator activity.  Problems arise when we 
wish to move the mutator's objects around i.e. when we are collecting.  For 
now, we can avoid this problem by suspending all (non-current) threads before a 
collection.

Locking

We can maintain consistent state by locking the appropriate data structures.

In the short term, we can make our interface thread safe by locking each 
interface when it is called and unlocking on return.  A safe conservative 
strategy is to use a one global lock for every interface.

This locking works because it serialises the calls to the mps.  So as long as 
the sequence of calls in the different threads turn into a legal sequence of 
calls we are  Initially we do not need to make the mps thread-safe, the dw 
layer will contain all the junk to make sure it uses the mps in a legal way.

So all we need to check what restrictions there are on orders of calls into our 
interface.

all ok :
reservehandler 
allocmisc
allochandler
freemisc
extern unsigned MMCollectCount(void);

Problem with Reserve/Commit:
Reserve needs to be called before Commit
These calls cannot be interleaved. At the moment Reserve is just a wrapper for 
the old allocate, which stores stuff in global data for Commit to have a look 
at.  Until buffers are in place we will need to ensure threads can allocate 
concurrently without negotiation.

solution:
Lock on reserve; unlock on commit
works as long as no deadlock
No deadlock if no interaction with another thread between Reserve and Commit
Tony says: only thing done between Reserve and Commit is copying of Dylan 
data.  No thread sych.  No external calls.


Scanning Stacks

With threads there are more roots:
Per thread we have
- Thread Local Storage -- cannot actually get hold of this from a different 
thread.  We must not have roots here in TLS.
  tony says: this is ok.  (solaris impl. uses one pointer in TLS, this is copy 
of something (pointer to static) on heap.)
- stack limit
- stack base -- on thread registration
- registers
these roots have to be created and destroyed dynamically.
Tony says: No roots other than stack per thread.  No registers contain roots on 
_calls_ to MM.

Dynamically Reading Stack Limits and registers
win32:
We can use GetThreadContext() but we must have
- a handle for each thread with THREAD_GET_CONTEXT access
The CONTEXT is a architecture specific structure that seems to
contain the sp and registers that will presumably need scanning.
Tony says: be careful about pushing registers onto stack.  What if interrupt 
occurs?

Implementation of Suspending threads
Win32:
- We need thread handle with THREAD_SUSPEND_RESUME access
- Call SuspendThread(), ResumeThread() to suspend and resume.  Be careful not 
to suspend yourself.

This could be provided by per space Suspend and Resume methods that can be set 
by the mutator.  This would involve updating the mpm to include:
SpaceSetSuspend(space, suspendfunction, resumefunction)
SpaceGetSuspend(suspendfunctionReturn, resumefunctionReturn, space)
SpaceSuspend(space)
SpaceResume(space)

Thread Creation and Deletion

To support suspension of threads and scanning of thread stacks we need to:

On creation
- need to declare roots (keep hold of arguments)
- declare stack base
- provide way of reading limit
- (in future) set up exception handler
Tony says: Will register thread with us explicitly.

On legal deletion
- need to destroy roots
Tony says: Will deregister thread.  No roots other than stack to destroy.

On accidental death
- may be holding lock
  does this automatically die?  It's bad either way.
- roots not destroyed
- reading stack limit will fail
Tony says: We can assume this won't happen.  At least initially.


Implementation of Locks

Presumably we _could_ implement this ourselves.  The implementation is going to 
be either OS dependent or ARCH dependent.
Win32 provides:
- Mutexes which do more than we need, they can work between processes and are 
probably quite heavyweight
- Semaphores like mutexes, but they're semaphores
- Critical sections -- I no longer think these are monitors.
  This is, I assume, the most lightweight mechanism provided.  The interface 
allows us to allocate multiple critical sections.  A thread cannot enter a 
critical section while a different thread is inside it.  A possible 
disadvantage is that a thread cannot choose to do something else while blocked, 
unlike with mutexes and semaphores.  This does not seem to be too serious a 
disadvantage.

This should be added to std.

ptw:
> If the substrate does not provide it, we should implement our own
> spin-locks that only branch out to O/S thread blocking on failure to
> acquire.  If we really believe we are on an MP system, the spin lock
> should spin more than once.  (Balance average lock hold time against
> thread reschedule time.)

Problem with initialisation?

We would need to allocate a critical section before we use it.  We could have a 
global CS that we allocate on intialisation?
At the moment we have
Bool ready = FALSE;   and call init() if !ready.
This potentially causes problems if a second thread calls the mm before the 
first call to it completed.

solution:
Disallow calling the MM interface from a separate thread before the one call 
(which causes init) is completed
)-: This is not very clean.
)-: We have to be careful of the exact wording.  e.g. MMCollectCount() does not 
cause an init.
(-: It doesn't involve messing around with the code.

solution (recommended):
Introduce an init call
(-: There are probably other things that will need initialising anyway (e.g. 
exception handler?)
(-: We can get rid of all the nasty "if(!ready)" code.
)-: Hassle and inconvenience.
)-: The dw layer has deliberately avoided this so far (why?)

solution:
Use init call to DLL
$=)-: Vomit

Exceptions

We will need to worry about exceptions when we implement fault handling

- does sp change during stack unwind?  (could get scan stack wrong if during an 
exception before a continue.)
ptw says this is a red herring
- on thread creation need to install exception handler before the new thread 
reads some possibly protected memory
- any other problems?


IMPROVEMENTS

Reducing Cost of Locking
- time spent doing locking and unlocking
- cost of contention

I feel that this cost will not become critical for some time if ever.

Acquiring and releasing locks is fairly cheap and only happens when the MPS is 
called.  The MPS is mostly called to allocate memory and is (and will be) 
rarely called for other stuff such as creating/deleting spaces and pools etc.  
The cost of locks on allocation of memory
is reduced by buffering (idea.buffers).  When we implement buffers, the locks 
on Reserve and Commit should be removed, and replaced by a lock around the 
allocation of the buffer.
 
As long as all non-allocate calls are quick (well within required pause time), 
contention caused by locking them is unlikely to be a problem.  Otherwise 
contention is caused when two or more threads try to allocate from the same 
space at the same time.  With buffers this only happens on buffer allocation 
which should be rarer.  Allocating is quick minimising contention, unless, of 
course we do some scanning.  As long as this involves suspending all threads 
contention during scanning is irrelevent.

Contention would become an issue if there are so many threads that time spent 
in these "quick" calls becomes a large portion of the total time.  To deal with 
this we could:
- avoid using locks at all. Particularly in bits that need to be quick or take 
a long time.
  Buffers don't need locks.  (Maybe think of this as allocating a buffer 
object, reserve and commit perform mutations on it.) This may be harder to do 
on our internal structures
- lock in stages.

Locking in stages

This is essentially the idea of pushing locks deeper.  This does not reduce the 
amount of locking, but increases it.  However, each lock is held for a shorter 
amount of time and be on more local data structures.
For example, given any structure that has a lock, and substructures that are 
accessed separately we can add a lock to each.  For example
we could have a separate lock on each pool:
    :
  LockClaim(space->lock);
    pool=SomePoolOfSpace(space);
    MessWithPool(pool);
  LockRelease(space->lock);
    :
could become
    :
  LockClaim(space->lock); 
    pool=SomePoolOfSpace(space); 
  LockClaim(pool->lock);
  LockRelease(space->lock);  /* Having released the space lock
                              * we must not claim it again before
                              * releasing the pool lock */
    MessWithPool(pool);
  LockRelease(pool->lock);
    :
rule.c.impl.symmetry helps us ensure that creation and deletion happen 
consistently

PoolDestroy(Pool pool){
  Space space = pool->space->lock;
  LockClaim(space->lock);  
  /* always lock from top down.  This gives us partial order on 
   * locks to avoiding deadlock */
  PoolFinish(pool);
  /* This involves finishing the pool lock. The client must have
     stopped using the pool before calling this function */
  Free(pool);
  LockRelease(space->lock);
}

Having thought about this more, I now think that most locking needed can be 
achieved by having locks on the the DequeStruct.  Most Create/Init and 
Destroy/Finish methods will merely need to lock the Deque.




Testing

How are we going to test this stuff?

design?
impl?
release?





