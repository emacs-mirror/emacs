                    IRC #MM ON 1997-01-14 WEDNESDAY
                           irc.mm.1998-01-14
                               draft doc
                           gavinm 1998-01-15

.logbot.00-07-06: PART

.logbot.00-07-09: JOIN

.logbot.00-07-09.1: This channel is logged to irc.mm.1998-01-14

.logbot.00-07-09.2: ANN JILLIAN'S HAIR makes LONI ANDERSON'S HAIR look like

.logbot.00-07-09.3:  RICARDO MONTALBAN'S HAIR!

.drj.11-59-26: JOIN

.logbot.11-59-26: This channel is logged to irc.mm.1998-01-14

.logbot.11-59-26.1: Should I do my BOBBIE VINTON medley?

.ptw.12-40-01: JOIN

.logbot.12-40-01: This channel is logged to irc.mm.1998-01-14

.logbot.12-40-01.1: Catsup and Mustard all over the place!  It's the Human 
Hamburger!

.drj.12-40-14: hello

.ptw.12-40-22: helo

.gavinm.12-40-25: Hello.

.ptw.12-40-33: Just checking to see that I can see the whiteboard

.gavinm.12-40-37: CAn you seem me?

.drj.12-41-12: got a url of rlook@me gavinm?

.drj.12-41-18: s/of r/for /

.ptw.12-41-23: I can see it

.ptw.12-41-29: Guess it fills the whole screen

.gavinm.12-41-30: www.netopia.com

.gavinm.12-41-47: Hang on.  I need to reboot Ibid.

.ptw.12-42-15: Hm.  Guess I need another monitor so I can see the w/b and IRC 
at the same time

.gavinm.12-42-38: You can see the proposed desk arrangement in the new room.

.drj.12-42-44: use Victoria to convert IRC to spoken word

.gavinm.12-43-04: I want to be Fred!

.gavinm.12-44-04: Isn't your screen larger than mine.

.gavinm.12-44-15: I though everyone had a larger screen than me.

.ptw.12-44-29: Not my home screen

.ptw.12-44-33: Victoria?

.gavinm.12-44-45: A MAc voice.

.drj.12-45-51: yeah, a mac voice.

.ptw.12-46-01: Hm.  speech is dimmed out, maybe I don't have it installed

.gavinm.12-46-44:  Is that any better?

.ptw.12-47-00: My laptop can only do 1024x768

.gavinm.12-47-18: I've reduced my screen size.

.ptw.12-48-56: Well, I think you can leave you screen big and I'll just flip 
back and forth.

.ptw.12-50-22: Hm, I could steal Neil's machine this morning -- she has 2 19" 
monitors

.ptw.12-52-45: ACTION going away to turn on speech and see how bad it really 
is

.drj.12-55-27: ACTION experiments by scrolling one of gavin's windows

.gavinm.12-56-07: PTW, I'll just chuck you off to test a PC.

.ptw.13-02-13: JOIN

.logbot.13-02-13: This channel is logged to irc.mm.1998-01-14

.logbot.13-02-13.1: A shapely CATHOLIC SCHOOLGIRL is FIDGETING inside my 
costume..

.ptw.13-07-34: JOIN

.logbot.13-07-34: This channel is logged to irc.mm.1998-01-14

.logbot.13-07-34.1: Hmmm..  a CRIPPLED ACCOUNTANT with a FALAFEL sandwich is HIT

.logbot.13-07-34.2:  by a TROLLEY-CAR..

.ptw.13-08-25: Okay, somebody say something

.ptw.13-09-00: Hm.  This doesn't seem to work

.ptw.13-09-41: JOIN

.logbot.13-09-41: This channel is logged to irc.mm.1998-01-14

.logbot.13-09-41.1: On SECOND thought, maybe I'll heat up some BAKED BEANS and

.logbot.13-09-41.2:  watch REGIS PHILBIN..  It's GREAT to be ALIVE!!

.ptw.13-12-12: JOIN

.logbot.13-12-12: This channel is logged to irc.mm.1998-01-14

.logbot.13-12-12.1: Today, THREE WINOS from DETROIT sold me a framed photo of

.logbot.13-12-12.2:  TAB HUNTER before his MAKEOVER!

.gavinm.13-12-31: HEllo.

.ptw.13-12-54: Hi, ok speech is on, pretty wierd

.drj.13-13-26: is it more weird than wierd?

.ptw.13-13-37: yes

.drj.13-13-53: Really I was wondering how the speech thing coped with typos

.ptw.13-14-11: neighbor, weigh, nieghbor, wiegh

.ptw.13-14-32: I guess you have to send me type-ohs, it does not speak what I 
say

.drj.13-15-01: neighbor, weigh, nieghbor, wiegh

.drj.13-15-10: view, friends, veiw, freinds

.drj.13-15-16: seize, sieze

.ptw.13-15-34: What would be really cool is if I could assign different voices 
to different people...

.drj.13-15-38: .oO( bubbles )

.drj.13-16-06: on my client, the utterances are prefixed by the nickname in 
angle brackets.

.ptw.13-16-25: So, it pronouces the misspellings pretty accurately.  .oO is 
pronouced "woo"

.ptw.13-16-48: On mine, there are no angles.  It keeps saying "d-r-j ..."

.drj.13-17-10: ah.  it didn't reduce me to drudj

.ptw.13-17-23: ACTION snickers

.gavinm.13-22-19: PTW, Pekka doesn't want to install Look@Me today, so it looks 
like we won't be making use of the Ibid.

.ptw.13-22-37: whatever

.drj.13-40-01: ACTION discovers a bug in the MM

.drj.13-40-14: in the currently shipping (to dylan) MM.  ouch

.ptw.13-57-14: JOIN

.logbot.13-57-14: This channel is logged to irc.mm.1998-01-14

.logbot.13-57-14.1: Zippy's brain cells are straining to bridge synapses...

.ptw.13-59-02: JOIN

.logbot.13-59-02: This channel is logged to irc.mm.1998-01-14

.logbot.13-59-02.1: Th' MIND is the Pizza Palace of th' SOUL

.ptw.14-02-47: 2Eww gross< colored 6text

.ptw.14-04-44: what does this do?

.ptw.14-05-53: JOIN

.logbot.14-05-53: This channel is logged to irc.mm.1998-01-14

.logbot.14-05-53.1: HELLO, everybody, I'm a HUMAN!!

.gavinm.14-07-28: I see outline C's.

.ptw.14-07-48: Outline C's?

.gavinm.14-07-49:  C 2Eww gross C< colored C 6text

.ptw.14-08-15: Ah, probably some control code that your client does not 
interpret

.ptw.14-08-58: Speech is pretty cool, just too bad I couldn't give each of you 
a different voice.

.pekka.14-13-55: JOIN

.logbot.14-13-55: This channel is logged to irc.mm.1998-01-14

.logbot.14-13-55.1: FOOLED you!  Absorb EGO SHATTERING impulse rays, polyester 
poltroon!!

.pekka.14-14-07: hello

.pekka.14-16-16: Bad news: SW QA found that one of their job is asserting in 
poolepdl.c; it didn't last week, so it might have broken in pilchard

.pekka.14-16-45: Looks like the epdl free-list is corrupted

.pekka.14-17-18: Tucker: can you help with this?

.ptw.14-43-50: JOIN

.logbot.14-43-50: This channel is logged to irc.mm.1998-01-14

.logbot.14-43-50.1: I demand IMPUNITY!

.ptw.14-44-15: Hm, this new ircle just crashed on me

.gavinm.14-44-22: Hello Tucker.  Did you catch Pekka

.gavinm.14-44-25: 's question?

.ptw.14-44-33: No, I did not

.ptw.14-45-25: Would you care to repeat it?

.gavinm.14-45-40: <Pekka> Bad news: SW QA found that one of their job is 
asserting in poolepdl.c; it didn't last week, so it might have broken in 
pilchard

.gavinm.14-45-40.1:  <Pekka> Looks like the epdl free-list is corrupted

.gavinm.14-45-40.2:  <Pekka> Tucker: can you help with this?

.ptw.14-46-16: In what way can I help?

.pekka.14-48-05: I was asking you that.

.pekka.14-48-18: You're the epdl expert...

.ptw.14-48-51: I am, am I?

.pekka.14-50-37: But can you do SW build?

.ptw.14-50-52: I have never done one

.pekka.14-50-59: AFAIK, there are not tests for epdl, right?

.ptw.14-51-14: None that I know of

.ptw.14-51-41: To my knowledge it has always been debugged used EP tests

.pekka.14-52-41: I thought all SW tests were basically (collection of) PS jobs 
-- the one that found this was.

.pekka.14-53-47: I'm doing a SW build now, so I suppose I need to see if I can 
repeat the problem.

.ptw.14-54-04: Right, AFAIK in the past they have either grovelled over the 
running test with the debugger or turned on more sanity checking

.ptw.14-54-22: And the bugs have, in the past, usually been EP lying to MM

.ptw.14-55-12: I see that the ASSERT is being raised in EPDLAddToFreeList

.pekka.14-56-31: It might still be SW's fault, but the freelist had addresses 
and sizes that weren't multiples of 8 -- I guess they should be.

.ptw.14-57-06: I'm looking at the code now...

.ptw.14-58-50: I don'

.ptw.14-59-21: I don't see anwhere that we AVER freed objects to be x8 in size

.drj.14-59-58: can we get overlapping free blocks if they specify a size that 
is too large when they free an object?

.pekka.15-00-06: Ouch.  The requirements say we allocate 8-byte aligned.

.drj.15-00-10: ACTION says slightly randomly

.ptw.15-00-51: Yes, the code rounds the size up to the next alignment

.pekka.15-02-02: At allocation, but not at free?

.tony.15-02-12: JOIN

.logbot.15-02-12: This channel is logged to irc.mm.1998-01-14

.logbot.15-02-12.1: Either CONFESS now or we go to ``PEOPLE'S COURT''!!

.ptw.15-02-19: No, it is aligned at free too

.tony.15-02-29: $who*

.ptw.15-02-37: Thus drj's suggestion is entirely plausible

.ptw.15-03-35: The assertion that fired is saying the block you are trying to 
free overlaps the next one

.gavinm.15-03-41: TOPIC: Design Discussion: Rainy Day Fund

.gavinm.15-04-02: Thanks for your last mail, Tony.  That makes things clearer.

.ptw.15-05-04: ACTION runs for loo and coffee before he is stuck in irc

.tony.15-06-30: You're welcome, Gavin. Hey - this is a historical moment. My 
first message.

.gavinm.15-07-36: I understand why you need to be able to allocate in handling 
out-of-memory,

.gavinm.15-08-02: and why you need to do so under thread-specific guarantees.

.ptw.15-08-18: ACTION is back

.ptw.15-08-27: may we have 5 minutes to read Tony's mail?

.gavinm.15-08-38: That's probably a good idea.

.gavinm.15-08-50: Can I get anyone a coffee?

.drj.15-08-56: I'm madly trying to cram all 25 emails

.tony.15-09-32: I had hoped to propose a pseudo API before the meeting, too.

.tony.15-09-41: Unfortunately, I ran out of time.

.tony.15-10-06: I can propose something if anyone wishes.

.ptw.15-10-20: Victoria pronounces API as "a pee"

.drj.15-10-26: may as well I think

.tony.15-11-29: There are 4 functions, I think:-

.gavinm.15-11-38: On you go, Tony.

.tony.15-11-59:   request_fund_be_this_size(no_of_buffers, fund_per_buffer)

.ptw.15-12-08: ACTION wonders if his watch is fast

.tony.15-12-17:   permit_allocation_buffer_to_use_fund()

.gavinm.15-12-21: 15:12 by NTP.

.tony.15-13-10:   see_how_many_buffers_may_be_funded()

.ptw.15-13-26: JOIN

.logbot.15-13-26: This channel is logged to irc.mm.1998-01-14

.logbot.15-13-26.1: How do you explain Wayne Newton's POWER over millions?

.logbot.15-13-26.2:  It's th' MOUSTACHE...  Have you ever noticed th' way it 
radiates

.logbot.15-13-26.3:  SINCERITY, HONESTY & WARMTH?  It's a MOUSTACHE you want to 
take

.logbot.15-13-26.4:  HOME and introduce to NANCY SINATRA!

.tony.15-13-38:   block_until_n_buffers_are_funded()

.gavinm.15-13-45: Is that: permit_allocation_buffer_to_use_fund(ap) ?

.tony.15-13-58: Yes. Sorry.

.drj.15-14-10: I guess the arguments were deliberately left unspecified so that 
the details could be filled in later

.tony.15-14-20:   Similarly it's block_until...(n)

.ptw.15-14-26: Sorry, the 5 minutes we had to read went by awfully fast

.drj.15-14-35: what do see_how_many...() and block_until...() do?

.tony.15-14-42: My fault. I jumped the gun.

.gavinm.15-14-46: Does Tony owe the swearbox 50p?

.tony.15-14-54: ???

.ptw.15-15-02: Then my "30-day trial" expired and I was disconnected

.ptw.15-15-16: Could you summarize the API please?

.ptw.15-15-40: ACTION wonders if having an API is a bit premature

.drj.15-16-22: ACTION trys the /me feature

.pekka.15-16-36: It seems that the major disagreement about the API is whether 
it needs to support multi-threading in some way.

.tony.15-16-52: NB: I agree it's premature. I wanted to present a straw man

.pekka.15-16-57: I'm happy that Tucker's argument in his recent mail shows that 
it need not.

.gavinm.15-17-01: I understand the set_size and permit_allocation, but I'm not 
so sure about the blocking.

.ptw.15-17-07: And buffers are our way of supporting multi-threading

.pekka.15-17-14: Yes.

.ptw.15-17-32: I think thread synchronization must be handled by the client

.tony.15-17-37: The blocking may not be necessary. Drop that bit if it worries 
you.

.drj.15-17-47: the blocking waits until the rainy-day-fund grows sufficiently 
large again, gavinm

.pekka.15-17-48: And the ap and the count

.ptw.15-17-57: Could my simple API work if it were on a per-buffer basis?

.gavinm.15-18-01: I think that allowing a specific buffer to use a nugget of 
RDF is a good clean way to support multi-threading.

.pekka.15-18-25: Agreed, but do we need that.

.pekka.15-18-29: ?

.gavinm.15-18-35: DRJ, I got that, but I'm concerned about the implications.

.drj.15-18-46: oh I see.  yes.  tricky isn't it.

.tony.15-18-53: I think there is a need for a per-buffer (or at least 
per-thread) permission

.gavinm.15-19-01: That's where the idea of changing the reserve size falls down.

.drj.15-19-05: ACTION prepares to switch to X

.ptw.15-19-22: you've lost me

.drj11.15-20-05: JOIN

.logbot.15-20-05: This channel is logged to irc.mm.1998-01-14

.logbot.15-20-05.1: The FALAFEL SANDWICH lands on my HEAD and I become a 
VEGETARIAN...

.gavinm.15-20-37: It seems ot me that we want to be able to breach the reserve 
advisedly, without having to lock out other threads.

.pekka.15-20-55: Why

.drj.15-21-14: so that other threads don't run away with all the spare memory?

.gavinm.15-21-18: Tony, were you suggesting the out-of-memory handler would 
block on a full RDF before restarting the allocation?

.ptw.15-21-30: Can't that be done by setting the reserve on buffers

.gavinm.15-21-41: Well, requiring that other threads be locked out is generally 
bad.

.gavinm.15-21-53: In particular it could dead-lock us.

.tony.15-22-07: Gavin - the intention was that a restart wouldn't be allowed 
unless there was some guarantee that another OOM error couldn't fail 
out-of-language

.pekka.15-22-11: Well, that's the client's problem

.ptw.15-22-16: Suppose the client could set a reserve on a per-buffer basis

.drj.15-22-34: if there was only one buffer I think it would okay to just give 
some memory to that buffer and let the thread get on with it.  however each 
thread has several buffers (one per pool at least in particular) and may need 
to balance memory usage between the bu

.tony.15-22-45: Pekka - I agree that deadlock is the client's problem. That's 
precisely why MM shouldn't provoke it.

.pekka.15-22-46: I.e., if the client rwites locking code then they'd better 
know what they're doing.

.drj.15-22-55: pekka, what is the client's problem?  oh deadlocking.

.pekka.15-23-12: yes

.ptw.15-23-30: Tony's proposed API specifies a reserve * # of buffers

.ptw.15-23-45: Are you suggesting that one buffer could get more than it's 
share?

.drj.15-24-08: pekka, I don't understanding how you're proposing to prevent 
%random_other thread from consuming the RDF...

.tony.15-24-18: Tucker - no, each buffer would only be expected to grab one 
chunk

.pekka.15-24-22: Read Tucker's maiol.

.gavinm.15-24-25: Tony, does your proposal require any less memory than would 
be required to reserve some amount per buffer?

.pekka.15-24-38: More

.drj.15-24-42: ptw, I was suggesting that it might not be good enough (in 
particuolar it might be too profligate) to allocate the memory to the buffers 
in one shot

.ptw.15-25-05: but that's what the straw API does

.tony.15-25-25: Gavin, I'm not sure I understand. Does it require it be USED or 
RESERVED

.ptw.15-25-37: My idea is that you can add a reserve to a buffer at any time

.drj.15-26-00: ACTION should read ptw's mail

.ptw.15-26-02: That will guarantee you can do that much consing from that 
buffer, when you need it

.tony.15-26-31: Tucker - do you think it's important to do so ahead of time?

.ptw.15-26-35: The system could have a per-thread reserved buffer for signalling

.gavinm.15-26-42: Tony, I was comparing your idea of reserving nBuffers * 
nPages pages in a central RDF, against Tucker's idea of reserving nPages on 
particular buffers.

.ptw.15-27-13: A sophisticated user could create a reserve buffer for running 
his handler in, or the system could provide it for him

.pekka.15-27-20: Memory is not the only resource that might be needed by 
arbitrary user code: therefore threads must synchronise their low-memory 
actions, anyway.

.gavinm.15-27-27: It is absolutely necessary for the out-of-memeory handler to 
use more than one buffer?

.ptw.15-27-34: No

.tony.15-27-40: Gavin, I see. 'd be happy for the user to limit the RDF to the 
number of threads he would consider to be "active" simultaneously.

.pekka.15-27-41: Yes

.ptw.15-27-44: (to gavin)

.drj.15-27-53: gavinm, in general yes, in particular perhaps not

.ptw.15-27-59: ?

.pekka.15-28-05: Buffers are not a Dylan-level feature, the user cannot choose 
how many they use.

.tony.15-28-21: Gavin, the handler may need to allocate in several pools (e.g. 
LO + AMC)

.drj.15-28-26: well, in general the client might be allocating an object that 
is required to be in some pool, hence requires to use a buffer from that pool

.ptw.15-28-34: But the system could have 1/thread that is sets to be the user's 
buffer for the duration of the handler

.drj.15-28-40: a headerless pair pool for example

.tony.15-28-49: Pekka, I was expecting the Dylan runtime to hide the details 
about buffers from the Dylan programmer's API

.ptw.15-29-05: drj - touché

.pekka.15-29-23: Tony, so was I

.drj.15-29-36: so you need a "shadow reserve buffer" for every ordinary buffer 
that you had.  I think.

.tony.15-29-57: David, yes that was the mdel I had in mind

.gavinm.15-30-01: Could the corresponding buffers in different threads share 
the same segments/pages?

.ptw.15-30-01: Or, a reserve on every ordinary buffer that you release during 
handling

.tony.15-30-52: Gavin, yes in principle - provided that each thread is 
permitted it's full reserve

.ptw.15-31-03: Huh?

.drj.15-31-08: gavinm, only with extra hair

.ptw.15-31-16: Is that the miracle of the loaves and fishes?

.drj.15-31-36: gavinm, might be simpler to have one set of reserve buffers 
which all threads use during lowmem handling.  and make them interlock

.tony.15-31-54: ptw, no miracle if the reserve is less than a page. A 
miraculous haircut might be needed, though.

.drj.15-31-59: but I'm not sure we can arrange the interlocking

.gavinm.15-32-03: The buffers could fill only the reserved amount in a 
low-memory context.

.ptw.15-32-03: who are "them" that interlock

.drj.15-32-35: ptw, I was briefly speculating that we might be able to somehow 
force buffers to be automagically interlocking without changing the client 
code, but I dojn't think we can.

.ptw.15-32-58: Nor do I

.ptw.15-33-10: Consider tony's run-away conser

.drj.15-33-14: is there any difference between allocating the reserve to each 
buffer "at the beginning" and allocating the reserve to buffers on demand as 
they each need it?

.ptw.15-33-20: How do you know which thread is the runaway

.ptw.15-33-30: How do you stop the right thread

.tony.15-33-38: ptw, the runaway conser can only happen BEFORE the thread has 
detected the low memory

.ptw.15-34-05: But what if the runaway handles low-mem by releasing all reserve?

.pekka.15-34-17: And after that, it must synchronize with the other threads, 
anyway.

.tony.15-34-21: ptw, you can't know the right thread - it will have to decide 
that in the handler

.ptw.15-34-21: Or has no low-mem handler?

.ptw.15-34-33: "it"?

.tony.15-34-39: ptw, the handler has bounded allocation limits

.ptw.15-35-02: I'm seriously confused

.tony.15-35-12: ptw, "it" refers to the thread

.ptw.15-35-35: Does each thread get its own handler

.tony.15-35-39: ptw, I said something about this in my mail

.tony.15-35-59: ptwm yes - handlers are dynamically bound

.gavinm.15-36-05: My idea was that, on failed allocation, a thread could 
temporarily authorise all its buffers to use the RDF.  These buffers would Trip 
every time, however,

.gavinm.15-36-17: enabling the RDF to be shared between threads at finer 
granularity.

.ptw.15-36-43: does each thread have its own low-mem handler, or is there a 
global strategy?

.drj.15-36-51: gavinm, yes.  you only save the cost of rounding up to pages 
though.

.pekka.15-36-55: Not in AMC: it eats up the whole segment when the buffer 
detaches.

.tony.15-37-01: Gavin, I was thinking that authorization would only be needed 
when the existing buffer was full

.gavinm.15-37-23: Tony, yes.  Existing buffers wouldn't Trip until they had to.

.ptw.15-37-42: Do we really need the generality of each thread having a 
different low-memory policy?

.gavinm.15-37-43: Pekka, true.

.drj.15-37-52: pekka, yes, atm.  hence the extra hair I said was necessary

.ptw.15-38-08: Could we not worry about 1/2 pages for now?

.tony.15-38-12: ptw, we need to support the Dylan handler binding mechanism

.gavinm.15-38-18: DRJ, I didn't realise that that was the hair you meant.

.drj.15-38-24: pekka, gavinm, besides may well be able to have some mechanism 
to do that in the buffer code.  ptw, concur

.ptw.15-38-59: Do we agree that low-memory is a bit different that divide-by-0?

.pekka.15-39-05: yes

.ptw.15-39-10: That it is a system-wide condition?

.tony.15-39-14: ptw, I see no need to worry about sub-pages. But as Pekka said, 
the client doesn't want to think in pages

.gavinm.15-39-23: Ok.  Would a reserve on/for every buffer in every thread be 
enough to _guarantee_ non-deadlocking low-memory handling?

.pekka.15-39-31: no

.pekka.15-39-48: Since memory is not the only resource

.gavinm.15-40-06: Tony?

.tony.15-40-14: Gavin, no. It's important that each thread should DETECT low 
memory before using he fund

.gavinm.15-40-57: Tony, yes.   Given a reserve and detection, can we 
_guarantee_ in-language handling?

.ptw.15-40-58: Is it unreasonable for the Dylan run-time to interlock it's 
threads so that only one can enter a low-memory handler at a time?

.tony.15-41-16: ptw etc: yes, low memory is system wide. But we need to use the 
Dylan handler mechanism

.pekka.15-42-02: ptw: I expect it must, or the client's handlers must.

.tony.15-42-06: ptw: it may be unreasonable for the runtime to interlock, 
because the runtime won't know the potential deadlock problems

.ptw.15-42-06: Is it unreasonable for Dylan to interlock it's threads so that 
only one can enter the low-memory handler at a time

.pekka.15-42-20: tony: agreed

.ptw.15-42-54: Is it unreasonable to advise clients that they must interlock 
their lwo-memory handlers?

.tony.15-42-59: The handler may very well decide to interlock threads, though

.gavinm.15-43-04: Are we all agreed that any such mechanism could not 
theoretically guarantee the desired in-language behaviour?

.pekka.15-43-14: What?

.tony.15-43-18: ptw, that advice sounds reasonable

.ptw.15-43-34: Is there any reason a client would need to _not_ interlock on 
low-memory handling?

.tony.15-43-41: gavin, which mechanism?

.pekka.15-43-53: If they know they have only one thread active?

.tony.15-44-15: ptw, the client may not need to interlock. That's not quite 
what you asked, though

.ptw.15-44-23: Can the client know they only have one thread active?  Are there 
not invisible rt threasd?

.gavinm.15-44-40: Pekka, I'm trying to establish a consensus on whether a 
mechanism that supports reserved that threads can knowingly breach, could ever 
_guarantee_ that out-of-memory handling can always be done in-language.

.ptw.15-44-47: When could the client not need to interlock?

.tony.15-45-08: ptw, the dylan implementation includes no invisible threads. 
Who knows what the user will consider to be invisible in a multi-programmer 
app, though

.pekka.15-45-14: Gavin: I still don't understand

.ptw.15-45-18: GavinM, not if the user is allowed to write an arbitrary 
handler.  QED

.ptw.15-45-55: There are no threads in DUIM?

.gavinm.15-46-19: Pekka, you said "No.  Since memory is not the only 
resource".  I wanted to get general agreement.

.tony.15-46-41: ptw, each DUIM window has a thread, I think. Is that in the 
runtime or no?  Hence my comment on multi-programmer apps.

.ptw.15-47-13: In general, I expect there will be libraries that will create 
threads that the programmer cannot possibly know about.

.gavinm.15-47-25: ... before drawing a conclusion.

.tony.15-47-29: ptw, yes, very probably

.ptw.15-48-08: Thus it seems to me the programmer cannot _know_ if he needs to 
synchronize or not

.tony.15-49-00: ptw, I don't see why that should necessarily follow. I can 
provide counter-examples, for instance

.pekka.15-49-12: Gavin: you generalized that a bit too far.

.ptw.15-49-13: I'm not convinced that writing lwo-memoory actions as signal 
handlers is the right approach

.drj.15-49-35: ptw, tony, it would seem to be bad practise to write low-memory 
handlers that needed to explicitly interlock with anything in order to access a 
resource

.tony.15-49-39: ptw,  would you care to make an alternative proposal?

.gavinm.15-50-24: It seems to me that there are various reasons why no RDF 
mechanism can provide an absolute guarantee.

.tony.15-50-31: drj, are you saying they should never lock, then?

.pekka.15-50-53: drj: but as Tony pointed out only the client program knows how 
to get more memory; if the client program has many threads, how could you avoid 
interlocking?

.ptw.15-51-08: That low-memory handling be run in a single distinguished 
thread, that modules can add low-memory recovery actions to a list that is 
processed by the l-m thread

.drj.15-51-12: tony, I don't think so.  They may want to clear a cache and the 
cache's implementation may lock, but that sort of thing seems fine.

.tony.15-51-41: pekka, a client thread may know it can release memory by 
freeing something it is controlling or aborting

.drj.15-51-46: pekka, because the resources you can release may not require 
interlocking.

.tony.15-52-21: drj, A thread may wish to put up a dialog box to ask the user 
what to do. It would be a pain for every thread to do that.

.pekka.15-52-25: yes

.drj.15-53-11: tony, that's true.  though in that case the thread that failed 
to acquire the lock presumably wouldn't be interested in popping up the 
dialogue box anyway

.pekka.15-53-33: So sometimes you must interlock, and sometimes you can get by 
without.

.tony.15-53-46: drj, hopefully by the time it gets the lock the problem will be 
solved so it won't have to

.ptw.15-53-56: We're thinking about too simple a lock

.tony.15-54-59: all: I'm not sure where we're heading. There's plenty of 
anecdotal support that we have to leave this to the client, isn't there?

.ptw.15-55-12: How does the per-thread mechanism deal with A runs out of memory 
and wants low mem handling, but B has the only useful handler, all the memory, 
and never tries to cons?

.ptw.15-55-31: How can A ask B to give up some memory?

.pekka.15-55-35: That's a bug in the program.

.pekka.15-55-59: tony: agreed

.ptw.15-56-00: A and B are separately loadable modules,  B keeps caches that it 
knows it can flush

.gavinm.15-56-06: But Dylan doesn't explicitly expose consing to the user.

.ptw.15-56-19: B is an OODB lib, e.g.,

.ptw.15-56-46: ACTION wonders if he is typing in white ink

.tony.15-56-50: ptw: are you assuming that modules and threads are necessarily 
tied together?

.pekka.15-56-55: ptw: I see, that's an argument for registering low-memory 
handler at a central point.

.drj.15-57-18: ptw _is_ typing in white ink.  on a black background!

.ptw.15-57-25: no

.ptw.15-57-28: I'm assuming that Dylan encourages component software

.ptw.15-57-36: And that you seldom know the inner workings of the components 
you use

.tony.15-57-44: pekka: FYI, the Dylan handler mechanism DOES support central 
handlers - it's just that they may be dynamically overridden

.drj.15-57-49: or perhaps signalling the low-memory condition in alls threads 
simultaneously.  as ptw pointed out, it is a global problem.

.ptw.15-58-17: ACTION is glad that DRJ can see his typing

.pekka.15-58-42: Tony: I know that, I meant "handler" in the abstract sense.

.gavinm.15-58-57: Tucker's point is a good one.  We've been overlooking the 
idea of a hog that doesn't allocate.

.tony.15-59-23: drj: there's a problem with signalling too asynchronously to 
Dylan. If we limit it to allocation requests then that might be a reasonable 
approach.

.pekka.15-59-24: ptw: OK, so these components need some protocol for 
cooperating in the event of low memory

.ptw.15-59-30: GavinM, yes, but the hog may have a low-mem action

.tony.15-59-36: drj: perhaps that what you had in mind?

.ptw.16-00-11: Like, they might register low-mem actions on a global list

.drj.16-00-25: tony, well we mentioned yesterday the possibility that one 
buffer running out of memory could arrange that all the other buffers would see 
the condition on their next allocation

.ptw.16-01-07: drj, which misses the hog that is done allocating but has a 
low-mem action

.tony.16-01-23: drj, we did discuss that - and it might be workable. But it's 
more heavyweight/fascist

.gavinm.16-01-48: Tony, Does the Dylan definition suggest that out-of-memory 
execptions are only thrown on allocation?

.ptw.16-01-59: I now _really_ think that handling low-mem in a signal handler 
is the wrong thing.

.drj.16-02-06: ptw, yes, I see that it does.  It's not clear to me that Dylan 
has _any_ way of coping with that

.ptw.16-02-34: Dylan (the language) assumes infinite memory

.tony.16-02-44: ptw, so you know the "wrong" thing. What's the "right" thing?

.drj.16-03-10: gavinm, I doubt it, but the the problem is that arbitrary 
asynchronous actions on a thread are impossible.  The thread may be in the 
middle of some MM action (and have a lock) for an example of a bad situation to 
be caught in.

.ptw.16-03-10: As a practicality we need to provide an implementation way of 
dealing with less than infinite.

.tony.16-03-32: ptw: I disagree. Dylan the language permits exceptional 
behaviour.

.ptw.16-03-49: tony:  A central place where modules can register low-memory 
actions

.gavinm.16-04-09: Tony, does it define out-of-memory exceptions?

.tony.16-04-38: gavin: no - Dylan defines virtually no exceptions. Not even 
divide by 0

.ptw.16-04-44: a way to run those actions when low-memory occurs

.drj.16-04-49: we still seem to be discussing client issues.

.tony.16-05-04: drj: my thoughts exactly.

.ptw.16-05-12: low-memory is never signalled

.drj.16-05-16: which is quite interesting, but it ain't reaching anywhere wrt 
MM interfaces and support

.ptw.16-05-32: if the actions all run and recover nothing, then out-of-memory 
is signalled

.gavinm.16-05-37: Getting back to the idea of a RDF ...

.tony.16-05-59: ptw: how is the low-memory cleanup code invoked in your model?

.ptw.16-06-14: haven't designed that yet

.gavinm.16-06-27: If we fail an allocation, the the client can do arbitrary 
things in arbitrary threads to recover memory before attempting a restart.

.ptw.16-06-32: possibly they are forms that all run in a thread that locks out 
all others

.ptw.16-06-48: if so, there are obviously restrictions on what the forms can do

.pekka.16-06-55: Gavin: but as you pointed out earlier we can't give any 
guarantees.

.gavinm.16-07-19: Pekka, we didn't reach a consensus on that.

.ptw.16-07-30: I think that's simplest, letting forms run in the thread that 
created them is more complex (implementation) perhaps easier (programmer)

.tony.16-07-38: ptw: that seems more restrictive than the handler model. How do 
you permit the pig-thread to cleanup?

.ptw.16-07-42: implementation == runtime

.drj.16-08-21: getting back to MM support...

.tony.16-08-32: ptw: would you agree that we need a RDF even with your model?

.drj.16-08-36: I think the minimum that the MM needs to supply is:

.ptw.16-08-42: pig-thread registers a low-mem action, perhaps "cache := 
make(<cache>);"

.drj.16-08-48: min1 - a way to specify the size of a reserve fund

.tony.16-09-11: ptw: what if that action involves changes to the dynamic 
environment of that thread?

.drj.16-09-15: min2 - a way to notify the client when there is no more memory 
(or perhaps very little memory) left apart from the reserve fund

.ptw.16-09-15: low-mem thread runs all actions, then GC, then checks to see if 
more memory exists, if so, returns to regularly scheduled program

.drj.16-09-29: min3 - a way for the client to allocate from the reserve fund

.drj.16-09-42: min4 - a way to expediently restore the reserve fund

.ptw.16-09-46: I think my model requires simpler rdf

.gavinm.16-10-03: DRJ, min2 is triggerred by an allocation (attempt).

.pekka.16-10-33: And I think the more complicated rdfs can't make any better 
guarantees

.drj.16-10-42: gavinm, yes.  but posting a message has also been suggested 
(poo-pooed because it ain't timely enough, or perhaps on the wrong thread)

.ptw.16-10-49: dyamic changes require eval-in-environment

.pekka.16-10-56: drj: Agreed, and min4 could be automatic

.tony.16-11-02: drj: How about min5 - a way to introspect the current fund size

.drj.16-11-25: min3 seems to be either: explicitly with each request (or 
buffered), or implicitly when min2 has been done

.tony.16-11-33: ptw: that's easy for you to say. You don't have to implement it

.ptw.16-11-58: min0 - a way to set the reserve with SUCCESS/FAIL

.drj.16-12-02: tony, min5, yes perhaps.  though I think it's getting 
non-minimal then.  I see why you want it though

.ptw.16-12-09: that satisfies all the others

.drj.16-12-24: pekka, min4 certainly could be automatic.  and I would encourage 
it to be.

.drj.16-12-53: ptw, is your min0 just min1 with the possibility of failure?  
(in which case I concur)

.ptw.16-13-05: drj, yes

.gavinm.16-13-39: I think we're all happy with the idea of min1 -- min4.

.drj.16-13-43: obviously we couldn't guarantee being able to set the reserve to 
some value... 

.ptw.16-13-46: and the client worries about everything else

.drj.16-13-52: gavinm, good.  I think so too.

.pekka.16-14-06: ptw: agreed

.tony.16-14-10: drj: I think there needs to be some minimal guarantee for 
multi-threaded behaviour

.ptw.16-14-22: right, the idea is min4 is done by trying to raise and looking 
for success

.gavinm.16-14-28: min5 worries me a little.

.ptw.16-14-31: min3 by lowering

.drj.16-14-34: the only issues with the minimal model seem to be, how to signal 
min2? and how min3 works

.pekka.16-14-45: tony: Didn't we dismiss that already.

.ptw.16-15-05: min5 the client infers by a) knowing his last setting and b) not 
getting another warning

.tony.16-15-28: pekka, if so I didn't spot it. Perhaps you saw a suggestion for 
a particular guarantee?

.pekka.16-15-43: I don't think any can be given.

.ptw.16-15-47: The multi-threaded behaviour is the client's responsibility!

.gavinm.16-16-02: PTW, I don't think we can do min4/min3 by raising/lowering 
the RDF level, because it doesn't give the client the power to permit a 
particular allocation.

.drj.16-16-14: I don't think we do need a guarantee anyway.  Dylan already does 
lots of differnt things when a thread is created and we don't make much 
guarantee about any of them (creating an AP for example).

.ptw.16-16-28: Yes it does. The client can interlock other threads to guarantee 
only one is allocating

.tony.16-16-36: ptw: but we've already seen examples where the other client 
thread won't even see that it HAS a problem

.ptw.16-16-49: ?

.pekka.16-17-01: Busy-waiting forever on an allocation is in-language behaviour 
(even if not particularly desirable).

.gavinm.16-17-09: PTW, I don't think we should require client interlocking when 
we can easily avoid it.

.ptw.16-17-13: Which is why the low-mem actions must be a central resource

.drj.16-17-19: ptw, I don't see the client can interlock the other threads 
actually.  unless there is a lock on all allocations.

.pekka.16-17-25: Gavin: no , we can;t in general

.ptw.16-17-32: I don't think we should be doing interlocking for the client 
when we can avoid it

.tony.16-17-40: ptw: how do you lock other threads out whicle runing the 
low-mem actions?

.gavinm.16-17-48: Pekka, can't require it or can't avoid it?

.pekka.16-17-49: ptw: agreed

.pekka.16-18-00: Gavin: Can't avoid.

.ptw.16-18-18: you lock the other threads by when they get a warning they try 
to grab a global low-mem lock and stop allocating

.tony.16-18-43: ptw: fine. Then there has to be a guarantee that they'll get a 
warning

.drj.16-19-02: and you have to arrange that only the thread with the lomem lock 
can allocate from the reserve fund?

.ptw.16-19-10: But none of this has to be seen at the language level

.drj.16-19-14: (which implies a particular scheme to min2)

.tony.16-19-32: ptw: I though we were discussing MM interface requirements??????

.pekka.16-19-36: drj: that's up to the client.

.ptw.16-19-44: that's the idea, the low-mem lock says I got the allocation key, 
if I lower the low-mem setting, I can allocate

.drj.16-19-48: damn, I meant min3 not min2

.gavinm.16-19-57: PTW, so what happens if the first low-mem handler is 
ineffective?

.ptw.16-20-17: tony:nguage leve == Dylan , not MM interface

.drj.16-20-37: pekka, what is up to client?

.ptw.16-20-38: gavinm: there is only _one_ low-mem handler, it runs all low-mem 
actions

.pekka.16-21-07: drj: The client decides what threads will allocate, and which 
ones wait for the others.

.tony.16-21-13: ptw: there are problems with this one handler mechanism. 
Especially the possibility of deadlock.

.gavinm.16-21-40: It seems to me that making min3 give per-buffer permission 
gives the client maximum flexibility of implementation.

.ptw.16-21-44: The beauty of the MM not interlocking is that you can design 
some other mechanism

.gavinm.16-21-50: After that, it's the client's problem.

.drj.16-21-56: pekka, I'm either confused or don't see how the client can 
arrange that.

.ptw.16-22-02: I propose the 1-handler strategy, feel free to explore others

.pekka.16-22-08: Gavin: unnecessary and too complex

.tony.16-22-22: ptw: we'd need a more general discussion with the Dylan group 
to get agreement on the 1-handler strategy

.pekka.16-22-30: drj: they write the handlers.

.ptw.16-22-34: Do we allow one thread to interrupt another?

.drj.16-22-40: pekka, I don't see how it is unnecessary (the per-buffer 
permission)

.drj.16-22-54: pekka, how do we prevent ordinary allocations breaking into the 
reserve?

.tony.16-23-02: gavinm: I still favour the per-buffer permission FWIW

.ptw.16-23-22: If a thread in low-mem cannot force another thread to run its 
handler, I don't see how to have multi-threaded handlers

.pekka.16-23-30: drj: we take Tony's suggestion that all thread will get the 
low-memory warning (at next BufferFill).

.drj.16-23-39: pekka, right.  okay

.ptw.16-23-46: Which is why I propose 1 handler.  I didn't think we allowed 
cross-thread signals

.gavinm.16-23-57: per-buffer permission doesn't perform interlocking within the 
MM _as_such_, it merely gives the client control .

.ptw.16-24-03: Please don't forget the hog that is not allocating!

.drj.16-24-09: pekka, then I think that works.  But I too prefer the per buffer 
permission.

.gavinm.16-24-17: It's true that a globally aware client could simulate the 
same behaviour.

.drj.16-24-27: I think it's more elegant and admits more client flexibility

.tony.16-24-31: ptw: the hog-not-allocating problem should be left for the 
client

.pekka.16-24-38: But why go to the trouble of implementing that when the client 
can do it (better)

.gavinm.16-24-42: I don't think that requiring global awareness in the client 
meets the need.

.pekka.16-24-57: Nothing else does.

.ptw.16-25-31: I propose to leave everything to the client but my 1 
reserve-setting API

.pekka.16-25-44: We went through this already: sometimes the threads have to 
interlock: ptw's central registry and one handler is a particularly severe form 
of interlocking

.ptw.16-25-50: I don't think it needs to be per-buffer, that can be left to the 
client too

.pekka.16-26-11: ptw: agreed, with Tony's guaranteed low-momery warning

.ptw.16-26-37: yes, there needs to be a low-mem return code on allocate

.ptw.16-26-55: (and also a no-mem return code)

.gavinm.16-27-06: ACTION notices yet another geographical division of opinion.


.pekka.16-27-36: Although the choice between ptw one-function API and drj's 
four is a matter of taste/

.ptw.16-27-45: ACTION thinks the pool hall may be talking behind our IRC's

.gavinm.16-28-02: If we provide per-buffer permission, then the client can 
provide one-thread handling, and arbitrary interlocking.

.drj.16-28-15: pool-hall isn't doing much talking for once

.ptw.16-28-25: It can do the same without being per-buffer

.pekka.16-28-29: ACTION thinks the Pool Hall has a touch of NIH attitude

.gavinm.16-28-41: If we provide a globally lowering reserve then a client 
thread cannot do its local best to free up memory.

.ptw.16-29-01: ACTION is amused by Pekka's suggestion

.ptw.16-29-15: why not, gavin?

.pekka.16-29-23: Gavin: and sometimes it would need to interlock, anyway, for 
some other resource.

.drj.16-29-45: since, min2--min3 can all be done with no function calls, ptw's 
1 fn interface is an implementation of min

.gavinm.16-29-54: Pekka, agreed, but it's still bad form to require client 
interlocking.

.ptw.16-30-44: Clients always have to interlock on globally shared resources

.pekka.16-30-48: Gavin: and it's bad to write it in MM if the client could do 
it.  We need to weigh theses two principles.

.gavinm.16-30-54: PTW, because lowering the reserve has global effect, and 
cannot be guaranteed to enable local activity.

.ptw.16-31-14: Memory is a global resource

.ptw.16-31-22: The client must interlock on it

.pekka.16-31-25: Gavin: it can with Tony's guaranteed notification to other 
threads

.gavinm.16-31-25: ACTION wonders if we should all change location halfway 
through such meetings.

.drj.16-31-34: pekka, I don't understand where gavin has required that the MM 
provide some sort of interlocking.

.ptw.16-31-40: Buffers are simply caches, filled under interlock

.ptw.16-32-13: If we provide the buffer-prefill op (proposed elsewhere) the 
client can grab the global reserve lock, lower the reserve, prefill, release 
the lock

.gavinm.16-32-14: Pekka, what was Tony's guaranteed notification?

.pekka.16-32-22: Drj: not interlocking, but additional mechanism for allocting 
reserves to buffers (remember we're talking about an arbitrary number of 
buffers here)

.ptw.16-32-57: notification == allocate returns a low-mem error before it 
returns no-mem

.pekka.16-33-01: Gavin: At next BufferFill, they will get the low-memory 
warning too (even if the reserve has been lowered).

.gavinm.16-33-01: PTW, true.  If the Dylan run-time imposes a global reserve 
lock on all allocation.

.ptw.16-33-40: No, the global reserve lock only has to be used to parcel out 
reserve without interference from other threads

.ptw.16-33-50: Normal allocation does not need the reserve lock

.gavinm.16-34-01: Pekka, even if the first thread has released skads of memory?

.pekka.16-34-05: You're talking past each other

.ptw.16-34-05: You only grab the lock if allocate returns low-mem

.drj.16-34-19: gavinm, ptw is right, remember that lomem signals the condition 
on all buffers.

.gavinm.16-34-39: Now I'm confused.

.pekka.16-34-56: Gavin: I suppose we can optimize that case

.ptw.16-35-04: At 90 minutes I think it is time for someone to go write a 
summary

.drj.16-35-09: pekka, so we either have a way for the client to specify that a 
buffer use the reserve, or we signal low memory on all buffers when we it occurs

.pekka.16-35-13: Or several summaries

.gavinm.16-35-22: I don't think we're sure what any of us are talking about any 
more.

.ptw.16-35-22: Sure

.drj.16-35-31: pekka, a priori neither of these seem more or less complex than 
the other

.ptw.16-35-37: I think each of us is sure of what he is talking about

.ptw.16-35-52: Noone is sure what the others are

.ptw.16-36-06: Tony appears to have been stunned into silence

.pekka.16-36-17: I think the guranteed warning actaully requires one more i/f 
function to keep track of whether we're already handling ot not (whether we 
have released some reserve or not).

.gavinm.16-36-18: I think we should close soon, but we need an action that will 
bring us to agreement.

.tony.16-36-25: Forgive me. I'm just a new boy

.pekka.16-36-30: But we'll see how ptw writes it up...

.gavinm.16-36-48: PTW, do you want to write up something?

.ptw.16-36-52: Hey, Pekka, that is pretty sneaky

.drj.16-37-02: pekka, I'm not sure it does require MM to keep track.  though I 
haven't thought about it.

.pekka.16-37-13: ACTION feels satisfied at being sneaky

.ptw.16-37-17: I am happy to write up what _I_ think is the answer

.drj.16-37-23: I'll write something up.  I have made some notes in my note book

.gavinm.16-37-23: How about PTW and Pekka write up their proposal, and I refine 
my original RFC?

.drj.16-37-38: (about what I think the proposed alternatives are, using my 
min1--4 framework)

.ptw.16-37-39: Sure

.pekka.16-37-47: drj: good

.gavinm.16-37-51: OK.  RFC-war tomorrow, then.

.ptw.16-38-03: "RFC-war"?

.gavinm.16-38-04: Any other remarks?

.tony.16-38-16: It was an education

.gavinm.16-38-27: PTW, if everyone writes up an RFC, then we can fire them at 
each other.

.pekka.16-38-28: I almost gave up on this discussion, but in the end we got 
somewhere, even if it's just preparation for the next round of design.

.drj.16-38-34: we didn't discuss SW requirements at all.

.ptw.16-38-40: REM This program is a simple program to calculate the 

.gavinm.16-38-43: RJ, true.

.gavinm.16-38-55: We still haven't got the hang of design discussions.

.drj.16-39-00: and it got bogged down in client-side issues

.gavinm.16-39-04: Ok.  Enough already.

.ptw.16-39-07: REM sqaw of the hippopotamus from the sum of the sqaw

.ptw.16-39-10: REM of the two hides

.ptw.16-39-28: REM For information on the allgorithm used see

.gavinm.16-39-32:  /topic General MM Wibblings

.pekka.16-39-38: Ah yes, SW has a reserve hack already.  I just note that some 
proposals would work equally well for SW.  Client arena is not a problem; lack 
of ap's might be.

.gavinm.16-39-41: TOPIC: General MM Wibblings

.gavinm.16-39-56: Thanks for your time everyone.

.pekka.16-40-00: ACTION wibbles

.drj.16-40-15: SW has it easy I think because they don't use threads

.ptw.16-40-16: ACTION wobbles, back to the coffee pot

.ptw.16-40-35: Er, what about the multi-CPU SW?

.drj.16-40-43: in particular after having released the reserve they can easily 
guarantee that no other thread allocates from it

.drj.16-40-55: ptw, SW only has one interpreter thread (ever) and only that 
allocates

.ptw.16-41-19: ACTION breathes a sigh of relief

.drj.16-41-23: ptw, other threads in the RIP render into bands of the page 
buffer

.drj.16-41-30: (and do no allocation)

.pekka.16-41-58: ACTION thinks that was a good way to spend the wait for the 
SW build

.ptw.16-43-23: Oh, Pekka, re: SW, isn't there some SW fence-posting that can 
check they are not returning wrong-sized blocks to us?

.ptw.16-43-43: ACTION really goes to get coffee now

.pekka.17-05-01: Yes, there's a fencepost thing, but the checking is written so 
that it always checks all objects.  This makes it unimaginably slow.

.pekka.17-05-24: I'll take a look at that if I can't see anything in the 
debugger.


