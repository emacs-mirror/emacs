                       #MM ON 1997-08-18 TUESDAY
                           irc.mm.1998-08-18
                               draft doc
                          richardk 1998-08-19

TOPICS

.topics: A very rough list:
  mps interface version naming;
    version declaration, vs. compatibility inference;
    CFM (MacOS code fragment manager, hazy recollections);
    (/etc/passwd)
    branching versions (a.o.t. linear total ordering);
    evolution of compatibility;
    dynamic OLE-like compatibility checking;
    global versioning vs. version sub-components;
  (golf courses)
  


TRANSCRIPT

.logbot.00-09-32: PART

.logbot.00-09-35: JOIN

.logbot.00-09-35.1: This channel is logged to irc.mm.1998-08-18 [in 
trillian:/u/ldisk/richardk/irc-logs]

.logbot.00-09-35.2: HAIR TONICS, please!!

.topic.00-09-35: TOPIC: MM

.drj.09-55-17: "2.1.2.3"

.drj.09-55-27: (4, 2, 1, 2, 3)

.drj.09-55-38: {2, 1, 2, 3}

.drj.10-02-27: #define MM_VERSION 2, 1, 2, 3

.drj.10-02-42: #define MM_VERSION_COMPONENTS 4

.drj.10-03-13: int ver[] = { MM_VERSION };

.drj.10-04-00: AVER(sizeof ver / sizeof ver[0] == MM_VERSION_COMPONENTS);

.drj.10-05-20: void printver(int n, ...);

.drj.10-05-34: printver(MM_VERSION_COMPONENTS, MM_VERSION);

.drj.10-08-15: /* but this gets the _interface_ version, not the binary library 
version */

.richardk.10-16-16: 
................................................................................
...........................................................................0

.richardk.10-16-30: ACTION stops leaning on his keyboard.

.rit.13-32-01: JOIN

.logbot.13-32-01: This channel is logged to irc.mm.1998-08-18 [in 
trillian:/u/ldisk/richardk/irc-logs]

.logbot.13-32-01.1: Did I say I was a sardine?  Or a bus???

.drj.13-41-05: hello rit

.drj.13-41-25: I just realised that some of the version requirements can be 
very easily met.

.drj.13-41-45: (see change.epcore.anchovy.160021: There is no way to tell which 
version and release of the MM one is using. and

.drj.13-41-59: request.epcore.160021 for example).

.richardk.13-42-20: I think versions should be colours.  Just have a red 
integer for epcore, a blue one for dylan.  Skaboing.

.drj.13-42-41: red 5 standing by

.rit.13-45-42: Hello.

.rit.13-48-14: drj: yes, I think that's true. The most important thing is 
simply to have something that encodes the version that you can get at / look at.

.rit.13-48-28: Things like checking for compatibility are additional bonuses.

.richardk.13-49-14: For inference about compatibility, we might want to solve 
the two-way problem.  Apple's CodeFragmentManager has a simple neat trick for 
this, that probably works well.

.richardk.13-49-33: I agree with rit that compatibility-inference is a bonus.

.richardk.13-50-07: Sorry!

.drj.13-50-52: how does CodeFragmentManager do it>

.drj.13-50-56: s/>/?

.richardk.13-51-38: [Meta-sorry: a lot of guff appeared on my screen, my Sorry 
was cos I thought I'd accidentally sent it onto the channel]

.richardk.13-52-01: CFM: basic idea is a monotonically increasing version 
number with time.

.drj.13-52-21: okay...

.richardk.13-52-46: When a client and service 'meet', if the versions aren't 
the same the the _newer_ (ie. with higher version number) makes the decision 
about compatibility.

.richardk.13-53-33: This is simple: each piece declares its version, and the 
oldest other-half it is compatible with.

.richardk.13-54-03: (Hmm, I think that was it)

.drj.13-54-19: er, what if the pre image of the compatibility function is not 
connected?

.drj.13-54-29: s/pre /pre-

.richardk.13-54-33: So when you add a new entry to the History of the 
Interface, it goes like this:

.richardk.13-55-46: new interface version 7, the library supports clients back 
to version 4, and clients with this interface will run with libraries back to 
version 6.

.drj.13-57-13: okay.  So how does it cope with me branching my product and 
producing two children which each have separate new functionality?

.drj.13-57-25: So I take V4 and produce V4a and V4b

.richardk.13-57-29: Hmm, I think I need to do a worked example mroe carefully.  
I think I told Richard Brooksby about the CFM scheme.

.drj.13-57-44: V4 clients can use either V4a or V4b...

.drj.13-58-10: but clients of either V4a or V4b may not be able to use V4b and 
V4a respectively.

.richardk.13-58-29: I don't expect it would solve that branching problem.

.drj.13-58-33: [the obvious answer is, it doesn't, so don't do that]

.drj.13-59-11: So I'm kind of worried that a version compatibility interface 
constrains what product configuration and change we can do.

.richardk.13-59-35: I think that is a concern, yup.

.lth.13-59-51: Well, if the versions form a tree, maybe the version 
compatibility information should also be tree-structured.

.drj.14-00-14: Yes, that was what was behind some of the more complex ideas in 
my recent mail, lth.

.lth.14-00-24: Which I've yet to read (oops)

.drj.14-00-28: 3.1.4.1 and all that.

.drj.14-00-56: I came up with with several humourous ways to encode paths along 
trees in C

.richardk.14-01-24: I hope varargs was humourous.  (But I'm always prepared to 
be wrong).

.drj.14-01-29: er, no.

.richardk.14-01-44: But it's horrible!

.drj.14-01-50: I know!

.drj.14-01-54: :)

.richardk.14-05-16: The CFm ploy only addresses binary compat.

.richardk.14-05-21: m/M

.rit.14-05-34: Yes. Finding out about interface versions is pretty important 
too.

.richardk.14-06-26: I meant binary a.o.t. source; but rit is quite right, that 
CFM doesn't make it easy to look at these versions really.

.richardk.14-07-08: ACTION tries setting the topic to Recording Version

.richardk.14-07-15: TOPIC: Recording

.drj.14-07-20: TOPIC: Recording Version

.drj.14-07-24: ACTION beams

.richardk.14-07-28: TOPIC: "Recording

.drj.14-07-33: TOPIC: Recording Version

.lth.14-10-13: ACTION observes that if V4a and V4b are independently produced, 
neither can contain information about whether it's compatible with the other; 
i.e., if they are compatible, one of them must have that info, and then a 
tree-like CFM ploy should work.

.richardk.14-10-54: praps the compat inference info should be quite separate 
from any instance of either client or service.

.richardk.14-11-12: maintenance nightmare :-)

.lth.14-11-16: Yes.

.richardk.14-12-42: Nonetheless, it might be nice to correct errors in the 
inference info, without touching binary.  CFM lets you do this: the inference 
info is in the cfrg resource in the resource fork.

.lth.14-12-47: And assuming that there is a temporal ordering on all 
components, the latest component can always have the info.  Which I guess is 
what CFM relies on (there's a total temporal order).

.drj.14-12-59: yes

.lth.14-13-03: RichardK, ah.

.richardk.14-13-06: total temp order] yes, as I understand it.

.drj.14-13-12: how about:

.richardk.14-13-25: resource fork in client and in service: best of both worlds?

.drj.14-13-35: 
http://www.harlequin.com/mm/reference/products/mps/versions/compatible?v2.1.2/v2
.2.1

.richardk.14-13-55: ACTION can't help smiling.

.lth.14-14-09: Are we relying on the MPS only running on systems connected to 
the 'net? :-)

.richardk.14-14-22: Umm, and how does my TCP stack boot it's copy of MPS?

.richardk.14-14-33: Aaaaaaaaaghh.  it's/its

.drj.14-14-48: well, how else are we going to lift copies of /etc/passwd (see 
also request.product.160063)

.richardk.14-14-52: Still, it's a concept.

.lth.14-19-37: *Why* does the MPS mmap /etc/passwd on some platforms?

.drj.14-21-46: er, umm, it seemed like an amusing idea at the time.  Ahem.

.drj.14-21-53: it can to richard (brooksby) in a dream.

.drj.14-21-59: s/can/came/

.drj.14-22-41: we need a readable plain (ie local disk or NFS) file guaranteed 
to be available on all installations.

.richardk.14-22-55: Quick, drj, come up with a plausible reason too.  Otherwise 
the secret will be out.

.richardk.14-23-01: Good one!

.richardk.14-23-17:  /msg

.drj.14-23-24: /dev/zero won't do because it has different swap behaviour when 
you mmap it, etc, etc.

.richardk.14-23-24: :-)

.lth.14-23-27: What's wrong with mktemp()'ing a file?

.drj.14-23-39: oh yeah, and like that's guaranteed to work.

.drj.14-23-47: er, I mean.  That might not work all the time.

.lth.14-24-05: Methinks that if you can't create a temp file, your Un*x system 
is about to die anyway, no?

.drj.14-24-09: like when I have a diskless workstation booted with a remote 
read-only root.

.drj.14-24-12: no

.lth.14-24-15: Ah.

.lth.14-24-18: I see.

.drj.14-24-24: might be just an X server for example.

.drj.14-24-27: I dunno

.lth.14-24-41: The X server is a good point.

.lth.14-24-56: (I think?)

.drj.14-25-06: though for all I only, plenty of unix X server require temporary 
files anyway

.richardk.14-25-29: ("only" ?)

.drj.14-25-40: s/only/know

.drj.14-25-44: bizarre

.lth.14-25-54: On the other hand, if you're running on an X server, does your 
"OS" have mmap??

.lth.14-26-34: ACTION thinks the divine inspiration explanation is more 
plausible.

.tony.14-26-51: JOIN

.logbot.14-26-51: This channel is logged to irc.mm.1998-08-18 [in 
trillian:/u/ldisk/richardk/irc-logs]

.logbot.14-26-51.1: Are you selling NYLON OIL WELLS??  If so, we can use TWO 
DOZEN!!

.drj.14-26-55: well, it's quite common to turn old Sun3s (and Sun4s these days 
I guess) into X server.  They run unix, but only really have enough support for 
the X server process.

.drj.14-26-58: helly tony.

.tony.14-27-04: Hi. 

.richardk.14-27-17: hello tono, quipped richard.

.tony.14-27-31: What's occuring, then?

.drj.14-27-43: ACTION doesn't understand rk's quip

.richardk.14-27-47: It's a common misspelling of "occurring".

.richardk.14-27-54: ACTION is well out of order.

.lth.14-28-02: ACTION is being inquisitive about /etc/passwd mapping in the 
mps.

.richardk.14-28-06: Topic = Recording Version.

.drj.14-28-12: we were talking about complexity of version interfaces

.richardk.14-28-25: quip]  DRJ, you said "helly tony".

.drj.14-28-38: oh yes

.drj.14-28-47: you were conserving 'o' and 'y'

.richardk.14-28-53: Oh Yes.

.richardk.14-29-16: ACTION meant to say "yh oes"

.tony.14-29-27: Anything new about version interfaces?

.drj.14-29-36: erm, it's all too complicated.

.drj.14-29-49: we just need a string like:

.richardk.14-30-42: New]  we achieved separation of two issues: version 
declaration (simpler) and automatic version-coompatibility inference (could be 
hard)

.drj.14-30-56: "Variety Hot, Product Dylan, 1998-08-18, W3I3MV, $HopeName: 
MMsrc!version.c(trunk.356)"

.drj.14-31-37: describing the version of the interface compiled against and 
having the client and the MPS discuss compatibility is much more complicated.

.tony.14-32-39: Doesn't describing the version of the interface compiled 
against also count as version declaration?

.drj.14-33-25: er, could be.  What's version declaration?

.tony.14-33-56: RichardK's term.

.tony.14-34-13: Biut I meant that it could be something like this:

.tony.14-34-41: "Product Dylan, 1998-08-18, W3I3MV, $HopeName: 
MMsrc!mps.h(trunk.356)"

.drj.14-36-03: it's trickier

.drj.14-36-36: 'cause the string literal is compiled into the binary by the 
compiler (in what I would consider the "easy" case), it never appears in the 
sourfce.

.drj.14-36-54: for stamping the interface version we need to change the source 
of the header

.drj.14-37-43: by actually editing it.  Which I think is unavoidable.

.tony.14-38-19: Can't we rely on HOPE?

.drj.14-38-37: that can get us $HopeName$ and possible a couple of other things.

.drj.14-38-45: not variety or product or platform.

.drj.14-39-06: we could have the build system automatically construct the 
header file for every compile

.drj.14-39-10: but I would resists.

.tony.14-39-18: OK - but variety isn't exposed via interface files, is it?

.drj.14-39-22: s/s\./.

.tony.14-39-42: And product can usually be derived from release branch name

.drj.14-40-02: er, you mean we don't need to discuss variety when talking about 
interface versions?  true.

.tony.14-40-18: That's what I meant

.rit.14-40-19: Perhaps you can define some cunning macros, then "#include 
.version" to compute a magic string which will change when any source file does.

.drj.14-40-37: cunning

.rit.14-40-41: I can't believe I just suggested that.

.drj.14-40-47: but impossible.

.drj.14-40-52: unless I misunderstand

.drj.14-41-49: C twists your mind rit.  Before yesterday I can't believe I 
would've proposed using varargs as a representation for a walk on an edge 
labelled graph.

.rit.14-42-57: why impossible? (I don't know the full story about C macros)

.drj.14-43-12: what if you add a new source file?

.tony.14-43-43: Um - are we still talking about interfaces?

.drj.14-43-59: compiling each source file would have to have some sort of 
permanent effect other than producing an object file.

.drj.14-44-05: I dojn't think rit is.

.drj.14-44-28: for identifying the interface to humans, I think you're right 
tony, we can just $HopeName$ is a string

.rit.14-44-41: No, sorry. I was off on a tangent.

.drj.14-44-46: and makes sure that mps.h has at least one change (possibly 
trivial) per release.

.drj.14-45-12: but identifying the interface is more useful to programs than to 
humans (according to rit I believe).

.tony.14-45-15: I don't see the need for a change per release. Doesn't the act 
of branching cover that?

.drj.14-45-55: patch releases on branches would need to force a change in mps.h 
otherwise they'd hav the same branch and minor version number.

.rit.14-45-59: Not for patch releases.

.tony.14-46-28: OK - I can see the need for an edit for patch releases. That 
could be a procedure that must be followed.

.drj.14-46-40: yes.

.richardk.14-46-57: ACTION likes the simplicity of the version of mps.h being 
the version of the MPS itnerface.

.rit.14-47-11: It'd be nice if there was some kind of order on the interface 
version.

.rit.14-47-25: Alphabetical order of names of birds isn't something I'd like to 
rely on for that.

.tony.14-47-36: Nice for humans or programs, rit?

.drj.14-47-40: there is.  it's jsut hard to access programmatically.  hence all 
my silly suggestions.

.rit.14-48-47: I'm thinking mainly of the MMQA tests. I'd like it if each test 
could know what versions of the mps interface it could work with.

.rit.14-49-00: Also the test libraries would like to make some small 
adjustments depending on the interface.

.tony.14-49-06: I wonder if the OLE mechanism might be ideally suited to this?

.drj.14-49-34: I know nothing about OLE.

.tony.14-50-00: I'm not an expert, but I  can give a quick paragraph on the 
important bit

.drj.14-50-06: how does it work?  is it cross platform?  would we be just 
borrowing the idea or actually using somebody elses code

.drj.14-50-09: ok

.tony.14-50-28: I'm thinking that we could borrow the idea, not any code.

.rit.14-51-01: To do what I'd like to with the MMQA tests, I'd like an 
interface version that I can get at in the C preprocessor (ideally including 
some kind of order comparison), or get at by, say, having a program that looked 
at mps.h and extracted the version info.

.tony.14-51-05: The idea is that "components" (in our case MPS releases) export 
named/numbered "interfaces"

.tony.14-51-37: Clients can ask a component what interfaces they support.

.tony.14-52-34: If a component doesn't support the latest interface, then the 
client can decide to use an older interface (via a different name/number) if it 
can remember how to do so.

.rit.14-53-11: #ifdef MPS_INTERFACE_FINALISATION // #

.rit.14-53-24: oops. THat was a line I was in the middle of editing. Anyway, 
you get the idea.

.tony.14-53-28: rit: is it definitely a requirement that this can be resolved 
at preprocessor time?

.drj.14-53-34: is there a linear ordering of interfaces in the OLE scheme?

.tony.14-54-12: drj: no, I don't think so. But a convention could be used to 
give the illusion of one.

.lth.14-54-18: rit, tony: it'd be possible to have a small program that queries 
the MPS and produces an include file with the proper preprocessor symbols for 
the QA suite.

.rit.14-54-33: tony: Yes, because some versions will include symbols not 
defined in earlier versions. If I try to use these symbols, I'll get 
compilation errors.

.drj.14-54-49: so without domain specific knowledge the client just has to 
iterate through all versions of the interface that it knows about asking about 
each one it turn.

.rit.14-55-27: lth: Yes, that's a nice idea.

.tony.14-55-33: I don't see why the interfaces names could be implemented as 
#defined - so they could just be tested with #ifdef

.tony.14-55-47: s/defined/define

.drj.14-56-10: example tony?

.drj.14-56-41: oh you just mean #define MPS_RES_COMMIT_LIMIT 6 rather than enum 
{MPS_RES_COMMIT_LIMIT = 6}

.rit.14-56-51: #ifdef MPS_INTERFACE_FINALISATION .... #if 
MPS_INTERFACE_VERSION_FINALIZATION > 4 ... #else .... #endif ... #else ... 
#endif

.tony.14-56-58: For example, consider consecutive releases of MPS changing the 
way we represent RANK:

.tony.14-57-23: We iterate through the following versions:

.tony.14-57-35: version A: Ranks are integers

.tony.14-57-56: version B: Ranks are accessed via macros. Integers are still 
supported but deprecated

.tony.14-58-18: version C: Ranks are accessed via macros. Integers not 
supported.

.tony.14-58-52: Versions A and B would both support the interface MPS_RANK_ENUM

.tony.14-59-13: Version B and C would both support the interfave MPS_RANK_MACRO

.tony.14-59-34: Of course, this depends on choosing suitable granularities for 
interfaces.

.tony.15-00-06: If it hadn't occured to us that we might change the rank 
interface, then we might not have added an explicit name for it

.drj.15-00-26: more amusingly, if _all_ your public symbols are macros 
(possibly in some boring way, e.g. #define mps_alloc _mps_alloc) then you can 
trivially feature test for anything.

.rit.15-00-47: .. except for what the symbols _mean_.

.drj.15-00-52: er, yes.

.rit.15-00-57: .. or how many parameters they take.

.drj.15-01-01: well, if we change the meaning you're stuffed.

.tony.15-01-08: But there is always the fallback of naming an interface for MPS 
as a whole - e.g. MPS_version2.1

.rit.15-01-20: Well I'm going to be stuffed then, because you _do_ change the 
meaning of symbols every now and then.

.drj.15-01-32: I know, and I wish we wouldn't.

.tony.15-01-43: rit: that's when you drop support for old interface names

.tony.15-02-18: assuming you adopt separate interface names, that is

.rit.15-03-05: Ok, but what if you make a new version of the SPONG pool class 
which supports finalization (it didn't previously). I think this is an 
interface change, because the allowed protocol of mps calls has changed.

.rit.15-03-19: But no symbols have changed at all.

.tony.15-03-45: If it's really an interface change, then you drop support for 
the old interface and add a new one

.rit.15-04-57: Yes, that makes sense. In this case you'd have to change the 
name of the pool.

.tony.15-05-06: I don't see why?

.rit.15-05-38: Oh. What were the old and new interface you mentioned?

.drj.15-05-42: rit, in tony's scheme the client would've done a version 
negotiation step and found that it wasn't compatible.  persumably.

.tony.15-06-16: drj: exactly. The old version supported spong.1; the new 
version just supports spong.2

.rit.15-06-46: Ah sorry. I wasn't arguing against tony's scheme, which I would 
support. I was arguing against the view that simply #defining macros for all 
mps functions would be sufficient, as drj suggested. Or as I thought he 
suggested.

.drj.15-07-05: ah.  yes, you're right.

.drj.15-07-18: I did suggest that in a moment of glibness.

.rit.15-11-03: I like tony's approach. If there are multiple numbered versions 
of an interface, I would like to be able to get at the numbers easily, though: 
why not have each interface name #defined to a value which told you the version 
of that interface?

.rit.15-11-16: s/value/integer/

.drj.15-11-47: er yes.

.tony.15-11-57: Because that wouldn't make it clear whether you did/didn't 
support old versions

.drj.15-12-05: and would there be a linear order rit?

.drj.15-12-46: tony, I thought rit was suggesting that, as well as the OLE 
style negotiation.

.tony.15-13-08: Oh, sorry. Looks like I misunderstood.

.tony.15-13-31: In that case, how do they fit together?

.rit.15-13-35: er, yes and that's what I was thinking, yes.

.richardk.15-13-49: tony, is OLE negotiation dynamic?

.drj.15-14-05: well presumably the client, having got hold of the interface 
numbers, could use domain specific knowledge to make its own inferences.

.rit.15-14-09: You could use sequential numbering for cases where the 
functionality of the interface was all related, and where you always had 
compatibility in one direction.

.tony.15-14-23: richardk: yes. It's a runtime introspection.

.rit.15-14-23: In other cases, you'd use a new named interface.

.richardk.15-14-59: With the MPS, do we have a requirement for supporting 
several ages of interface?

.tony.15-15-07: rit: I'm not sure how you could know ahead of time whether an 
interface will always have compatibility in one direction.

.rit.15-15-20: So, e.g. you'd use a sequentially numbered interface for when 
you add a new possible result code (mps_res_t) (assuming you never remove 
them). You'd use named interfaced for ranks, as you suggested.

.richardk.15-15-31: (Even if not, a mechanism that can represent it might be 
the right solution)

.rit.15-16-00: Er, you don't have to know in advance. If you find suddenly that 
you can no longer have such compatibility, you just have to choose a new 
interface name.

.tony.15-16-11: richardk: We can up with some requirements for always 
supporting the previous version

.tony.15-17-09: rit: What does the increased number tell you, though? That you 
have made an extension to the interface?

.rit.15-17-36: Yes, exactly. If your program can run with version N, it can run 
with any version greater than N.

.tony.15-17-42: richardk: s/can/came

.drj.15-18-03: so that you can perform (some) computations about compatibility 
in the C preP.

.tony.15-18-33: I don't see why you need to use a linear ordering for that. Why 
isn't the existance of the interface name enough?

.tony.15-19-30: I guess I'm saying that the linear ordering is isomorphic to (a 
subset of) what you can do with names alone. So why have 2 schemes?

.drj.15-20-24: it's potentially more compact and simpler to manage.

.drj.15-20-52: so that every time I extend an interface (add more result codes 
say) I dojn't have to define another interface name.

.rit.15-21-16: Because it's easier to check N > 5 than test for existence of 
several interfaces.

.drj.15-21-21: er, in other words, a position binary number representation is 
better than von neumann set theoretic number representation.  I think.

.tony.15-21-37: drj: Hmm. But you do have to remember which version number 
introduced which new feature

.drj.15-21-41: s/position/&al/

.rit.15-21-44: And easier to work out what interfaces your program relies on if 
there aren't so many of them.

.tony.15-22-01: rit: I don't see that. For each N > 5 test you would test 
exactly one name

.rit.15-22-26: tony: Surely you weren't proposing the interface names would be 
self documenting? 8-)

.tony.15-22-33: No

.rit.15-22-39: (I take your point that they're more memorable than numbers.)

.tony.15-23-29: My point is not just about mnemnonics. I'm disputing that you 
can forget anthing about the numbers less than N and hence gain a 
simplification.

.rit.15-23-33: tony: Ah, but to know that only one name test is required, you 
have to know a fact about the ordering of interface names. The numerical 
approach makes this fact apparent.

.tony.15-23-58: rit: yes. As I say the 2 are isomorphic.

.tony.15-24-24: Is it a benefit that this is apparant?

.rit.15-24-49: Also, not so many #defines would be needed in mps.h

.tony.15-25-23: Yes - I think that was drj's point. But I claim you'll still 
need at least as much documentation.

.drj.15-25-41: yes, I think you need as much doc'.

.rit.15-25-58: Yes, it's a benefit 'cos I might have two programs that used 
different interface versions, and I'd want to be able to see by looking how the 
interfaces were related.

.tony.15-26-53: Would interfaces names spong.1 and spong.2 have that benefit as 
far as you are concerned?

.rit.15-27-04: Yes, that would be fine.

.drj.15-27-19: well, then we're done.

.tony.15-27-39: That was fun

.rit.15-28-05: Yes. Quick, implement it before we think of more requirements.

.richardk.15-28-15: IS it better to have one global version, or separately 
version various parts of the whole MPS interface.

.richardk.15-28-22: ./?

.tony.15-28-34: Both, I would have thought.

.richardk.15-28-42: ACTION hopes drj hasn't already implemented it :-)

.drj.15-28-46: the separate versions of various parts solves the branching 
problem.

.richardk.15-29-04: What is the branching prob this solves?

.drj.15-29-22: because the interface names simply form a set and compatibility 
is defined by the subset relation

.richardk.15-29-30: I think it is hard to maintain one global version 
accurately, let alone a load of versions for several parets.

.richardk.15-29-35: parets/parts

.drj.15-30-08: er, the one I mentioned earlier.  I have a product A and I 
extend it in two separate and different ways to produce A_b and A_c

.drj.15-30-23: so all three have interface.A

.rit.15-30-32: To allow for future expansion, make the interface-versioning 
system a named interface.

.drj.15-30-38: but only one has interface.B and only one has interface.B

.richardk.15-30-52: rit: ... in CORBA IDL

.drj.15-30-56: s/B/A/  ; / damn!

.drj.15-31-14: rats rats

.rit.15-31-22: s/B/C/ ?

.tony.15-31-26: yes

.drj.15-31-32: I meant s/B/G/;s/B/C/;s/G/B/

.drj.15-31-55: bleedin' line editors.

.richardk.15-31-56: Just say it again.  Go on.  Go wild with that keyboard :-)

.drj.15-32-22: ACTION thinks wouldn't it be amusing to simply edit the 
scrollback and have it change on everyone's screen.

.tony.15-32-50: sounds like revisionism

.lth.15-32-54: _and_ in the log?

.drj.15-33-07: ah well, the log would record the edits as well

.richardk.15-33-11: and edit the subsequent discussion.

.richardk.15-33-18: pop

.richardk.15-34-05: Hmm, so startiung from the simplest interface versioning 
scheme: identifier for each version, and you either support it or you don't 
with no inference,...

.drj.15-34-09: so MPS_INTERFACE_VERSION would be our first named interface?

.richardk.15-34-48: ... we have branched the versioning scheme with two 
suggestions: b) numerical inference and c) set-like inference given versions of 
the sub-components.

.drj.15-35-07: but observed that sets can used to implement numbers.

.drj.15-35-26: (and with equal power for what we want to do)

.richardk.15-35-27: Have we decided that these two can be combined, or that 
they are incomaptible?

.tony.15-36-22: I don't think there's any problem combining them, except that 
it means we start using 2 techniques when one would work

.tony.15-37-31: Note that there's a danger with making assumptions about linear 
ordering anyway.

.tony.15-38-03: All it needs is for parallel extensions in branches (as drj 
suggested) to extend the same interface, and you have lost

.richardk.15-38-13: I'm uneasy about versioning the parts.  How does the 
partitioning itself evolve? ...

.drj.15-38-28: ad hoc

.richardk.15-38-36: ... presum you could start with a gloabl version, then 
later retract it and provide part_a.1 and part_b.1

.tony.15-39-43: I suggest that we always have a global version, but that we 
additionally add in small interfaces for bits that are known to change often, 
or when things do change

.richardk.15-40-09: I think I'm brainstormed out on this.  (I may have been for 
a while, and just not realised :-)

.rit.15-41-18: That sounds sensible. I think you might very soon want a 
distinction between DYLAN and EPCORE products, and an interface for each 
shipped pool class.

.tony.15-41-55: Agreed. That should probably be introduced up-front

.richardk.15-42-04: ACTION realises/concedes that would be hellish with a 
single global interface version!

.drj.15-42-21: odd the dylan, even for EP

.drj.15-42-27: pool classes gets increasing primes

.tony.15-42-50: Is there a smiley coming?

.richardk.15-42-55: Why?

.drj.15-42-59: er, :)

.richardk.15-43-29: There are a lot of integers in 4billion; why only use the 
first infinitesimal few? :-)

.tony.15-43-59: Who said we must stick with integers?

.richardk.15-44-25: Yay!  Transcendental version numbers!  Complex!  
Hyper-dimensional!

.drj.15-44-32: Hmm.  C9X gives us complex numbers...

.tony.15-44-47: One up on Dylan, then.

.drj.15-45-10: er, apparently.  but then, it is an evolving language.

.drj.15-48-52: TOPIC: mm 

.ptw.15-51-38: JOIN

.logbot.15-51-38: This channel is logged to irc.mm.1998-08-18 [in 
trillian:/u/ldisk/richardk/irc-logs]

.logbot.15-51-38.1: I feel like I'm in a Toilet Bowl with a thumbtack in my 
forehead!!

.drj.15-51-45: hello ptw

.drj.15-52-07: I hope you don't want a discussion of versions, versioning, 
version inspection and negotiation, etc etc.

.ptw.15-52-19: My thoughts on your version are in the email

.drj.15-52-26: ah

.drj.15-52-44: (though looking through today's log might be instructive)

.ptw.15-52-50: I guess the IRC discussion already happened.

.ptw.15-53-18: Hm.  How can I see today's log?  Tomorrow in Notes?

.rit.15-53-43: We can run some software to play back the IRC log, and give ptw 
the illusion of being in a live discussion!

.rit.15-53-51: Not a very convincing illusion, I admit.

.drj.15-54-23: trillian:/u/ldisk/richardk/irc-logs

.drj.15-54-54: I keep pestering gavinm about there being no automatic way for 
the logs to get into notes.

.tony.15-55-36: Hi, Tucker

.drj.15-55-57: have you been on holiday recently ptw?  I've not been keeping 
track.

.lth.15-56-29: ACTION goes to lunch.

.ptw.16-16-28: I did not go on my 2 day vacation last week because Neil's work 
overflowed.

.drj.16-16-40: bad luck...

.ptw.16-16-50: I am on vacation this week from Thursday, until the next

.drj.16-16-56: aha.  Where are you going?

.ptw.16-17-12: The usual:  visit in-laws in Williamsburg

.ptw.16-17-24: Contrary to all in-law jokes, it is a really nice time.

.drj.16-17-40: where is williamsburg>

.ptw.16-17-56: They live in Kingsmill, which has 72-hole golf course.

.drj.16-18-07: big golf/

.ptw.16-18-22: (In Virginia -- 15 hours by car :-( )

.drj.16-18-36: there was an article in the guardian at the weekend about how 
golf was rapidly becoming one of the biggest land change reasons

.ptw.16-18-45: Within 15 minutes is Bush Gardens, Water Country, etc.  for kids.

.drj.16-19-03: sounds good.

.drj.16-19-16: so how's your golf coming along?

.ptw.16-19-20: Yes.  Here in the States it seems to be the compromise that 
developers and environmentalists keep reaching.

.ptw.16-19-41: Plymouth has 5 courses, with 4 more being built.

.drj.16-19-50: apparently some company owned by Jack Niklaus has some very 
sharp practices

.ptw.16-19-57: I expect it will be real cheap to play golf in a few years

.drj.16-20-11: e.g. buying a ring of land around a proposed golf development 
site

.drj.16-20-27: then making it difficult for the people living in the middle to 
get in or out...

.ptw.16-20-49: Mm.  Sounds typical of any big developer.

.ptw.16-21-43: The property next to me (3k acres) was bought and the developer 
threatened to use existing zoning to build 2500 new homes if the town did not 
give him concessions to build commercial stuff.

.ptw.16-21-55: Luckily, he ran out of money.

.ptw.16-22-15: Now a new developer is in, who will build 700 "luxury

.ptw.16-22-26: homes" with 4 golf courses...

.drj.16-22-40: are they allowed to build that densely in the states?

.drj.16-22-58: I have to say >4acres per dwelling on average seems enormous to 
me.

.ptw.16-27-15: Most towns have a "default" zoning that is a combination of 
acreage (in Plymouth 1.5 acres) and "frontage", that is linear feet along an 
existing way.

.drj.16-27-32: aha

.ptw.16-27-55: But if a developer is willing to create new roads, they can 
create frontage and only the acreage resetriction applies.

.ptw.16-28-05: Which is what the first developer threatened.

.ptw.16-28-27: New roads have to be approved by the town, luckily.

.drj.16-32-48: home time for me.  bye!


