                         WIN32 FAULT BENCHMARK
                              os.nt.fault
                               draft doc
                             dsm 1995-08-04

/* bench.c */
/* Benchmark of Win32 fault handling */
/*                              
  Purpose
    FUNCTION Test functionality of fault operations on Win32 platforms
    MEASURE  Provide estimates of protection handling overhead

  # means not implemented

    FUNCTION
     #correct - verify test results
      protect
       #read only
        no access
        all access
      except
        read
       #write
      lock - locking between threads
    MEASURE
      total
      fault
      lock
      suspend } measured together
      resume  }
      alloc  } measured together
      free   }

  General strategy
    There is a general test parameterised by a set of options.
    The options are set before the is test is run.  By running
    the test with different sets of options and comparing the 
    timings we can estimate the cost of various operations, and
    combinations of operations.  This is hopefully gives more
    realistic results than timing a single function call many 
    times. We may otherwise get optimistic results due to caching.

  To do/Issues
    Windows95:  I have had problems with this program crashing in
      an irreproducable way on Windows95, but this only _seems_ to
      occur after managing to get MVC++ 2.0 into a confused state by
      building while a previous version the program running.
    verify: functionality not checked very well
    fixsuspend: Check thread has died properly when suspending??
                Should threads declare their demise?? doubt it
    stress: cause system to be stressed
    cover: make sure all paths are covered
      (in particular check thread locking issues)
    pause: The average pause time is estimated from total overhead
      the distribution of pause times is not measured
    stats: Add more things to stats struct.
      This is where we can accumulate pause time distributions etc.
      We could record
        time
        nfaults?
        nrfault?
        nconflicts?
    Tstats: we probably need per thread stats structure to 
      gather info without conflict problems

  Assumptions
    bit32:  assume 32-bit sizeof(int)=4 etc
*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <assert.h>

#include <signal.h>

#define MAX_THREADS 10

#define pd(x) printf(#x"=%d\n",(x))
#define pu(x) printf(#x"=%u\n",(x))
#define pp(x) printf(#x"=%p\n",(x))
#define px(x) printf(#x"=0x%x\n",(x))

typedef struct StateStruct *State;
typedef struct ThreadStruct *Thread;
typedef struct OptionsStruct *Options;
typedef struct StatsStruct *Stats;

typedef DWORD Time;


typedef struct ThreadStruct {
  HANDLE h;
  DWORD starttime;
  State s;
} ThreadStruct;

typedef struct StateStruct {
  DWORD addr;
  DWORD len;
  DWORD pagesize;
  DWORD starttime;
  CRITICAL_SECTION lock;
  Options opt;
  ThreadStruct t[MAX_THREADS];
} StateStruct;

typedef struct OptionsStruct {
  unsigned nthreads;
  unsigned npages;
  int incremental; /* If 0 pages unprotected and fixup done before 
                      execution and no faults will happen during run. */
  int locking;     /* critical section locking */
  int dofixup;     /* 0 => no fixup */
  int protect;     /* use protection */
  int suspendtwice;/* suspend and resume threads an extra time */
  int print;       /* print info.  Don't use with multiple threads. */
} OptionsStruct;

typedef struct StatsStruct {
  Time totaltime;
} StatsStruct;

DWORD pagesize(){ SYSTEM_INFO si; GetSystemInfo(&si); 
  return si.dwPageSize; }

void suspend_threads(Thread t)
{
  unsigned i;
  HANDLE h;
  State s=t->s;
  Options opt=s->opt;

  for(i=0;i<MAX_THREADS;i++)
  {
    h=s->t[i].h;
    if(h!=NULL && h!=t->h)
      if(SuspendThread(h)==0xffffffff){
        if(opt->print)printf("Couldn't suspend thread %d :",t-s->t);
        assert(GetLastError()==ERROR_INVALID_HANDLE); /*!! fixsuspend*/
        /* assume thread has died */
        s->t[i].h=(HANDLE)NULL;
      }
  }
}

void resume_threads(Thread t)
{
  unsigned i;
  HANDLE h;

  for(i=0;i<MAX_THREADS;i++)
  {
    h=t->s->t[i].h;
    if(h!=NULL && h!=t->h )
      if(ResumeThread(h)==0xffffffff)
        assert(0); /*!!*/
  }
}

int setprotect(DWORD addr, DWORD len, DWORD access)
{
  DWORD oldaccess;
  if(!VirtualProtect((LPVOID)addr,len,access,&oldaccess))
    assert(0); /* !! */
  return oldaccess==PAGE_NOACCESS; /* page was protected */
}

/* Using PAGE_NO_ACCESS and PAGE_EXECUTE_READWRITE 
   use guard pages?? */
int   protect(DWORD addr, DWORD len){ 
  return setprotect(addr, len, PAGE_NOACCESS); }
int unprotect(DWORD addr, DWORD len){ 
  return setprotect(addr, len, PAGE_EXECUTE_READWRITE); }

void fixup(State s, DWORD from, DWORD to)
{
  DWORD *i;

  if(!s->opt->dofixup) return;

  for(i=(DWORD *)from;i<(DWORD *)to;i++)
    *i=(DWORD)(i-s->addr);
}

int fault(Thread t, int iswrite, DWORD address)
{
  DWORD base,len,limit;
  State s=t->s;
  Options opt=s->opt;
  int tn=t-s->t;

  if(opt->print){
    printf("thread %d:",tn);
    printf(iswrite?"write":"read ");
    printf(":%x ",address);
  }

  if(address < t->s->addr || address >= s->addr+s->len)
    return 0;

  base=address&-(int)s->pagesize;
  if(base<s->addr) base=s->addr;

  len=s->pagesize;
  limit=base+len;
  if(limit>=s->addr+s->len) limit=s->addr+s->len;


  if(opt->protect && !unprotect(base, len))
  {
    if(opt->print)printf("already unprotected\n",address);
    return 1;
  }

  fixup(s, base, limit);

  if(opt->print)printf("\n");
  return 1;
}

 
LONG WINAPI filterfun(Thread t, LPEXCEPTION_POINTERS info)
{
  LPEXCEPTION_RECORD er;
  DWORD iswrite;
  DWORD address;
  State s=t->s;
  Options opt=s->opt;

  er=info->ExceptionRecord;
  if(er->ExceptionCode!=EXCEPTION_ACCESS_VIOLATION
    || er->ExceptionFlags==1) /* non continuable exception */
    return EXCEPTION_CONTINUE_SEARCH;

  /* er->ExceptionRecord is pointer to next exception in chain 
     hopefully we do not have nested faults */
  /* er-ExceptionAddress is where exception occurred */

  assert(er->NumberParameters>=2);

  iswrite=er->ExceptionInformation[0]; /* 0 read; 1 write */
  assert(iswrite==0||iswrite==1);
  address=er->ExceptionInformation[1];

  {
    LONG action=EXCEPTION_CONTINUE_SEARCH;

    if(opt->locking)EnterCriticalSection(&s->lock);
    suspend_threads(t);
    
    if(opt->suspendtwice){
      resume_threads(t); 
      suspend_threads(t);
    }

    if(fault(t,(int)iswrite,address))
      action=EXCEPTION_CONTINUE_EXECUTION;  

    resume_threads(t); 
    if(opt->locking)LeaveCriticalSection(&s->lock);
    return action;
  }
}



DWORD WINAPI Thread0(LPDWORD par){
  Thread t=(Thread)par;
  State s=t->s;
  int tn=t-t->s->t;
  int step=tn*2+1; /* lenPOT */
  int print=s->opt->print;

  __try  
  {   
    {
      unsigned i,sum;
      DWORD *m=(DWORD *)s->addr;
      DWORD l=s->len/4;
      DWORD ti,to,t0;
      int k;
      for(k=0;k<2;k++)
      {
        sum=0;i=0;to=t0=s->starttime;
/*
  lenPOT: len needs to be Power Of Two to ensure step coprime
          with len so loop goes over all values
*/
        do{
          sum+=m[i];
          i+=step;
          i%=s->len/4; /* bit32; lenPOT */ 
          ti=GetCurrentTime();
          if(print)if(ti-to>10)printf("[%d]",ti-to);
          to=ti;
          /*        {int j;for(j=0;j<1000;j++);}  */
        } while(i);
        if(print){ t0=GetCurrentTime()-t0; pd(t0); }
        if(print)pu(sum);
      }
    }

    return 0;
  }
  __except(filterfun(t,GetExceptionInformation()))
  { assert(0); }
}
       
void create_thread(Thread t){
  HANDLE h;
  DWORD threadid;

  h=CreateThread(NULL,0,Thread0,t,CREATE_SUSPENDED,&threadid);
  t->h=h;
  t->starttime=GetCurrentTime();
  ResumeThread(h); /*!!*/
}

/* (opt->nthreads>1 && !opt->locking) => won't get right result */
/* (opt->nthreads>1 && opt->print) => no lock on printing - dodgy */
void test(Stats stats/*??*/, Options opt)
{
  StateStruct state;
  State s;
  unsigned nthreads;
  DWORD t0=GetCurrentTime();
  HANDLE h[MAX_THREADS];

  assert(opt->protect || !opt->incremental);
  assert(opt->nthreads<MAX_THREADS);

  s=&state;

  s->opt=opt;
  nthreads=opt->nthreads;

  s->pagesize=pagesize();
  s->len=s->pagesize*opt->npages;
  s->starttime=GetCurrentTime();

  {
    LPVOID p;

    p=VirtualAlloc(NULL, s->len, MEM_COMMIT, PAGE_READWRITE);
    if(p==NULL) 
      assert(0);  /*!!*/

    s->addr=(DWORD)p;
  }

  InitializeCriticalSection(&s->lock);

  {
    unsigned i;
    for(i=0;i<MAX_THREADS;i++)
    {
      s->t[i].h=(HANDLE)NULL;
      s->t[i].s=s;
    }
  }

  if(opt->protect)protect(s->addr,s->len);

  if(!opt->incremental){
    if(opt->protect)unprotect(s->addr,s->len);
    fixup(s,s->addr,s->addr+s->len);
  }

  {
    unsigned i;
    for(i=0;i<nthreads;i++)
    {
      create_thread(&s->t[i]);
      h[i]=s->t[i].h;
    }
  }
  WaitForMultipleObjectsEx(opt->nthreads,h,TRUE,INFINITE,TRUE/*??*/);

  if(!VirtualFree((LPVOID)s->addr, 0, MEM_RELEASE))
  {
    px(GetLastError());
    assert(0);/*!!*/
  }
  stats->totaltime=GetCurrentTime()-t0;
}

int main(void)
{
  OptionsStruct optst;
  Options opt=&optst;
  StatsStruct statsst;
  Stats stats=&statsst;
  DWORD t[10];
  unsigned i;

  for(i=0;i<3;i++){
    opt->nthreads=1<<i;
    opt->npages=0x100; /* lenPOT */
    opt->incremental=1;
    opt->locking=1;
    opt->dofixup=1;
    opt->protect=1;
    opt->suspendtwice=0;
    opt->print=0;

    test(stats, opt); /* Practice run */

    test(stats, opt); t[0]=stats->totaltime;

    opt->suspendtwice=1;
    test(stats, opt); t[3]=stats->totaltime;
    opt->suspendtwice=0;

    if(opt->nthreads<2){
      opt->locking=0;
      test(stats, opt); t[1]=stats->totaltime;
    }
    opt->protect=0; opt->incremental=0;
    test(stats, opt); t[2]=stats->totaltime;
    printf("\nNumber of threads = %u, pages = %u \n",
      opt->nthreads, opt->npages);
    printf("  Total time = %u ms\n",t[0]);
    printf("  Total time fault per page = %.4f ms\n",
      (double)(int)(t[0]-t[2])/opt->npages);
    if(opt->nthreads<2)
      printf("    time locking per page = %.4f ms\n",
        (double)(int)(t[0]-t[1])/opt->npages);
    if(opt->nthreads>1)
      printf("    time suspend/resuming threads per page = %.4f ms\n",
        (double)(int)(t[3]-t[0])/opt->npages);
  }

  {
    DWORD len;
    DWORD *p;
    unsigned i,n=10000;

    len=opt->npages*pagesize();
    t[0]=GetCurrentTime();
    for(i=0;i<n;i++){
      p=VirtualAlloc(NULL, len, MEM_COMMIT, PAGE_READWRITE);
      assert(p);/*!!*/
      assert(VirtualFree(p, 0, MEM_RELEASE));/*!!*/
    }
    t[0]=GetCurrentTime()-t[0];
    printf("\nVirtualAlloc/Free cost per pair of calls = %.4f ms\n",
      (double)(int)t[0]/n);
  }
  printf("\nEnd of Test\n");
  Sleep(INFINITE);
  return 0;
}


