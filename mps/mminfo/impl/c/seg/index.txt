                                SEGMENTS
                               impl.c.seg
                               draft doc
                           gavinm 1997-08-28

     1 /* impl.c.seg: SEGMENTS
     2  *
     3  * $HopeName: MMsrc!seg.c(trunk.6) $
     4  * Copyright (C) 1997 The Harlequin Group Limited.  All rights reserved.
     5  *
     6  * .design: The design for this module is design.mps.seg.
     7  *
     8  * TRANSGRESSIONS
     9  *
    10  * .check.shield: The "pm", "sm", and "depth" fields are not checked by
    11  * SegCheck, because I haven't spent time working out the invariants.
    12  * We should certainly work them out, by studying impl.c.shield, and
    13  * assert things about shielding, protection, shield cache consistency,
    14  * etc. richard 1997-04-03
    15  */
    16 
    17 #include "mpm.h"
    18 
    19 SRCID(seg, "$HopeName: MMsrc!seg.c(trunk.6) $");
    20 
    21 
    22 /* SegCheck -- check the integrity of a segment */
    23 
    24 Bool SegCheck(Seg seg)
    25 {
    26   CHECKU(Pool, seg->_pool);
    27   CHECKL(TraceSetCheck(seg->_white));
    28   CHECKL(TraceSetCheck(seg->_grey));
    29 
    30   if(seg->_buffer != NULL) {
    31     CHECKU(Buffer, seg->_buffer);
    32     /* design.mps.seg.field.buffer.owner */
    33     CHECKL(BufferPool(seg->_buffer) == seg->_pool);
    34   }
    35 
    36   CHECKL(RingCheck(&seg->_poolRing));
    37 
    38   /* The segment must belong to some pool, so it should be on a */
    39   /* pool's segment ring.  (Actually, this isn't true just after */
    40   /* the segment is initialized.) */
    41   /*  CHECKL(RingNext(&seg->_poolRing) != &seg->_poolRing); */
    42 
    43   /* The segment should be on a grey ring if and only if it is grey. */
    44   CHECKL(RingCheck(&seg->_greyRing));
    45   CHECKL((seg->_grey == TraceSetEMPTY) ==
    46          RingIsSingle(&seg->_greyRing));
    47 
    48   CHECKL(RankSetCheck(seg->_rankSet));
    49   if(seg->_rankSet == RankSetEMPTY) {
    50     /* design.mps.seg.field.rankSet.empty: If there are no refs */
    51     /* in the segment then it cannot contain black or grey refs. */
    52     CHECKL(seg->_grey == TraceSetEMPTY);
    53     CHECKL(seg->_summary == RefSetEMPTY);
    54     CHECKL(seg->_sm == AccessSetEMPTY);
    55     CHECKL(seg->_pm == AccessSetEMPTY);
    56   } else {
    57     /* design.mps.seg.field.rankSet.single: The Tracer only permits */
    58     /* one rank per segment [ref?] so this field is either empty or a */
    59     /* singleton. */
    60     CHECKL(RankSetIsSingle(seg->_rankSet));
    61     /* Can't check barrier invariants because SegCheck is called */
    62     /* when raising or lowering the barrier. */
    63     /* .check.wb: If summary isn't universal then it must be */
    64     /* write shielded. */
    65     /* CHECKL(seg->_summary == RefSetUNIV || (seg->_sm & AccessWRITE)); 
*/
    66     /* @@@@ What can be checked about the read barrier? */
    67   }
    68 
    69   /* "pm", "sm", and "depth" not checked.  See .check.shield. */
    70 
    71   CHECKL(BoolCheck(seg->_single));
    72 
    73   return TRUE;
    74 }
    75 
    76 
    77 /* SegInit -- initialize the generic part of a segment */
    78 
    79 void SegInit(Seg seg, Pool pool)
    80 {
    81   AVER(seg != NULL);
    82   AVERT(Pool, pool);
    83 
    84   seg->_pool = pool;
    85   seg->_p = NULL;
    86   seg->_rankSet = RankSetEMPTY;
    87   seg->_white = TraceSetEMPTY;
    88   seg->_grey = TraceSetEMPTY;
    89   seg->_summary = RefSetEMPTY;
    90   seg->_buffer = NULL;
    91   RingInit(&seg->_poolRing);
    92   RingInit(&seg->_greyRing);
    93   seg->_pm = AccessSetEMPTY;
    94   seg->_sm = AccessSetEMPTY;
    95   seg->_depth = 0;
    96   seg->_single = FALSE;
    97 
    98   AVERT(Seg, seg);
    99 
   100   RingAppend(&pool->segRing, SegPoolRing(seg));
   101 }
   102 
   103 
   104 /* SegFinish -- finish the generic part of a segment */
   105 
   106 void SegFinish(Seg seg)
   107 {
   108   AVERT(Seg, seg);
   109 
   110   /* Check that the segment is not exposed, or in the shield */
   111   /* cache (see impl.c.shield.def.depth). */
   112   AVER(seg->_depth == 0);
   113   
   114   /* Don't leave a dangling buffer allocating into hyperspace. */
   115   AVER(seg->_buffer == NULL);
   116 
   117   /* See impl.c.shield.shield.flush */
   118   ShieldFlush(PoolArena(seg->_pool));
   119 
   120   RingRemove(SegPoolRing(seg));
   121 
   122   /* Detach the segment from the grey list if it is grey.  It is OK */
   123   /* to delete a grey segment provided the objects in it have been */
   124   /* proven to be unreachable by another trace. */
   125   if(seg->_grey != TraceSetEMPTY)
   126     RingRemove(&seg->_greyRing);
   127 
   128   RingFinish(&seg->_poolRing);
   129   RingFinish(&seg->_greyRing);
   130 }
   131 
   132 
   133 /* SegSetSummary -- change the summary on a segment
   134  *
   135  * In fact, we only need to raise the write barrier if the
   136  * segment contains references, and its summary is strictly smaller 
   137  * than the summary of the unprotectable data (i.e. the mutator).
   138  * We don't maintain such a summary, assuming that the mutator can 
   139  * access all references, so its summary is RefSetUNIV.
   140  */
   141 
   142 void SegSetSummary(Seg seg, RefSet summary)
   143 {
   144   RefSet oldSummary;
   145   Arena arena;
   146 
   147   AVERT(Seg, seg);
   148 
   149   arena = PoolArena(seg->_pool);
   150   oldSummary = seg->_summary;
   151   seg->_summary = summary;
   152 
   153   AVER(seg->_rankSet != RankSetEMPTY);
   154 
   155   /* Note: !RefSetSuper is a test for a strict subset */
   156   if(!RefSetSuper(summary, RefSetUNIV)) {
   157     if(RefSetSuper(oldSummary, RefSetUNIV))
   158       ShieldRaise(arena, seg, AccessWRITE);
   159   } else {
   160     if(!RefSetSuper(oldSummary, RefSetUNIV))
   161       ShieldLower(arena, seg, AccessWRITE);
   162   }
   163 }
   164 
   165 
   166 /* SegSetGrey -- change the greyness of a segment
   167  *
   168  * Sets the segment greyness to the trace set ts and adjusts
   169  * the shielding on the segment appropriately.
   170  */
   171 
   172 void SegSetGrey(Seg seg, TraceSet grey)
   173 {
   174   Arena arena;
   175   TraceSet oldGrey, flippedTraces;
   176   Rank rank;
   177   
   178   AVERT(Seg, seg);
   179   AVER(TraceSetCheck(grey));
   180   AVER(seg->_rankSet != RankSetEMPTY);
   181 
   182   arena = PoolArena(seg->_pool);
   183   oldGrey = seg->_grey;
   184   seg->_grey = grey;
   185 
   186   /* If the segment is now grey and wasn't before, add it to the */
   187   /* appropriate grey list so that TraceFindGrey can locate it */
   188   /* quickly later.  If it is no longer grey and was before, */
   189   /* remove it from the list. */
   190   if(oldGrey == TraceSetEMPTY) {
   191     if(grey != TraceSetEMPTY) {
   192       AVER(RankSetIsSingle(seg->_rankSet));
   193       for(rank = 0; rank < RankMAX; ++rank)
   194  if(RankSetIsMember(seg->_rankSet, rank)) {
   195    RingInsert(ArenaGreyRing(arena, rank), &seg->_greyRing);
   196    break;
   197  }
   198       AVER(rank != RankMAX); /* there should've been a match */
   199     }
   200   } else {
   201     if(grey == TraceSetEMPTY)
   202       RingRemove(&seg->_greyRing);
   203   }
   204 
   205   /* The read barrier is raised when the segment is grey for */
   206   /* some _flipped_ trace, i.e. is grey for a trace for which */
   207   /* the mutator is black. */
   208   flippedTraces = arena->flippedTraces;
   209   if(TraceSetInter(oldGrey, flippedTraces) == TraceSetEMPTY) {
   210     if(TraceSetInter(grey, flippedTraces) != TraceSetEMPTY)
   211       ShieldRaise(arena, seg, AccessREAD);
   212   } else {
   213     if(TraceSetInter(grey, flippedTraces) == TraceSetEMPTY)
   214       ShieldLower(arena, seg, AccessREAD);
   215   }
   216 
   217   EVENT_PPU(SegSetGrey, arena, seg, grey);
   218 }
   219 
   220 
   221 /* SegSetRankSet -- set the rank set of a segment
   222  *
   223  * If the rank set is made non-empty then the segment's summary is
   224  * now a subset of the mutator's (which is assumed to be RefSetUNIV)
   225  * so the write barrier must be imposed on the segment.  If the
   226  * rank set is made empty then there are no longer any references
   227  * on the segment so the barrier is removed.
   228  *
   229  * The caller must set the summary to empty before setting the rank
   230  * set to empty.  The caller must set the rank set to non-empty before
   231  * setting the summary to non-empty.
   232  */
   233 
   234 void SegSetRankSet(Seg seg, RankSet rankSet)
   235 {
   236   RankSet oldRankSet;
   237   Arena arena;
   238 
   239   AVERT(Seg, seg);
   240   AVER(RankSetCheck(rankSet));
   241   AVER(rankSet == RankSetEMPTY || RankSetIsSingle(rankSet));
   242 
   243   arena = PoolArena(seg->_pool);
   244   oldRankSet = seg->_rankSet;
   245   seg->_rankSet = rankSet;
   246 
   247   if(oldRankSet == RankSetEMPTY) {
   248     if(rankSet != RankSetEMPTY) {
   249       AVER(seg->_summary == RefSetEMPTY);
   250       ShieldRaise(arena, seg, AccessWRITE);
   251     }
   252   } else {
   253     if(rankSet == RankSetEMPTY) {
   254       AVER(seg->_summary == RefSetEMPTY);
   255       ShieldLower(arena, seg, AccessWRITE);
   256     }
   257   }
   258 }

