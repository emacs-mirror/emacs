                          GENERAL MPM SUPPORT
                               impl.c.mpm
                             accepted impl
                           gavinm 1996-09-11

     1 /* impl.c.mpm: GENERAL MPM SUPPORT
     2  *
     3  * $HopeName: MMsrc!mpm.c(trunk.5) $
     4  * Copyright (C) 1996 Harlequin Group, all rights reserved.
     5  *
     6  * .readership: MM developers.
     7  *
     8  * .purpose: Miscellaneous support for the implementation of the MPM
     9  * and pool classes.
    10  */
    11 
    12 #include "mpm.h"
    13 
    14 SRCID(mpm, "$HopeName: MMsrc!mpm.c(trunk.5) $");
    15 
    16 
    17 /* MPMCheck -- test MPM assumptions */
    18 
    19 Bool MPMCheck(void)
    20 {
    21   CHECKL(sizeof(char) == 1);
    22   CHECKL(sizeof(Word) * CHAR_BIT == WORD_WIDTH);
    23   CHECKL(1uL << WORD_SHIFT == WORD_WIDTH);
    24   CHECKL(AlignCheck(ARCH_ALIGN));
    25   /* impl.c.mpm.check.ti: Check that trace ids will fit in the */
    26   /* TraceId type. */
    27   CHECKL(TRACE_MAX <= TraceIdNONE);
    28   CHECKL(TRACE_MAX <= UINT_MAX);
    29   /* impl.c.mpm.check.ts: Check that there are enough bits in */
    30   /* a TraceSet to store all possible trace ids. */
    31   CHECKL(sizeof(TraceSet) * CHAR_BIT >= TRACE_MAX);
    32 
    33   CHECKL((SizeAlignUp(0, 2048) == 0));
    34   CHECKL(!SizeIsAligned(64, (unsigned) -1));
    35   CHECKL(SizeIsAligned(0, 32));
    36   CHECKL((SizeAlignUp(1024, 16) == 1024));
    37   /* .prime: 31051 is prime */
    38   CHECKL(SizeIsAligned(SizeAlignUp(31051, 256), 256));
    39   CHECKL(SizeIsAligned(SizeAlignUp(31051, 512), 512));
    40   CHECKL(!SizeIsAligned(31051, 1024));
    41   CHECKL(!SizeIsP2(0));
    42   CHECKL(SizeIsP2(128));
    43   CHECKL(SizeLog2(1L) == 0);
    44   CHECKL(SizeLog2(256L) == 8);
    45   CHECKL(SizeLog2(65536L) == 16);
    46   CHECKL(SizeLog2(131072L) == 17);
    47 
    48   return TRUE;  
    49 }
    50 
    51 
    52 /* AlignCheck -- check that an alignment is valid */
    53 
    54 Bool AlignCheck(Align align)
    55 {
    56   CHECKL(align > 0 && (align & (align - 1)) == 0);
    57   return TRUE;
    58 }
    59 
    60 
    61 /* WordIsAligned -- test whether a word is aligned */
    62 
    63 Bool (WordIsAligned)(Word word, Align align)
    64 {
    65   return (word & (align - 1)) == 0;
    66 }
    67 
    68 
    69 /* WordAlignUp -- round up a word to the nearest aligned value */
    70 
    71 Word (WordAlignUp)(Word word, Align align)
    72 {
    73   AVER(AlignCheck(align));
    74   return (word + align - 1) & ~(align - 1);
    75 }
    76 
    77 
    78 /* SizeIsP2 -- test whether a size is a power of two */
    79 
    80 Bool SizeIsP2(Size size)
    81 {
    82   return size > 0 && (size & (size - 1)) == 0;
    83 }
    84 
    85 
    86 /* Logarithms */
    87 
    88 Shift SizeFloorLog2(Size size)
    89 {
    90   Shift l = 0;
    91 
    92   while(size > 1) {
    93     ++l;
    94     size >>= 1;
    95   }
    96 
    97   return l;
    98 }
    99 
   100 Shift SizeLog2(Size size)
   101 {
   102   AVER(SizeIsP2(size));
   103 
   104   return SizeFloorLog2(size);
   105 }
   106 
   107 
   108 /* AddrAdd -- add a size to an address */
   109 
   110 Addr (AddrAdd)(Addr addr, Size size)
   111 {
   112   Addr next = (Addr)((Word)addr + size);
   113   AVER(next >= addr);   /* overflow check */
   114   return next;
   115 }
   116 
   117 
   118 /* AddrSub -- subtract a size from an address */
   119 
   120 Addr (AddrSub)(Addr addr, Size size)
   121 {
   122   Addr next = (Addr)((Word)addr - size);
   123   AVER(next <= addr);   /* overflow check */
   124   return next;
   125 }
   126 
   127 
   128 /* AddrOffset -- calculate the offset between two addresses */
   129 
   130 Size (AddrOffset)(Addr base, Addr limit)
   131 {
   132   AVER(base <= limit);
   133   return (Size)((Word)limit - (Word)base);
   134 }
   135 
   136 
   137 /* WriteWord -- output a textual representation of a word to a stream */
   138  
   139 static Res WriteWord(mps_lib_FILE *stream, Word w, unsigned base, 
unsigned width)
   140 {
   141   static const char digit[16] = "0123456789ABCDEF";
   142   char buf[MPS_WORD_WIDTH + 1]; /* enough for binary, plus one for 
terminator */
   143   unsigned i;
   144   int r;
   145 
   146   AVER(stream != NULL);
   147   AVER(2 <= base && base <= 16);
   148   AVER(width <= MPS_WORD_WIDTH);
   149   
   150   /* Add digits to the buffer starting at the right-hand end, so that */
   151   /* the buffer forms a string representing the number.  A do...while */
   152   /* loop is used to ensure that at least one digit (zero) is written */
   153   /* when the number is zero. */
   154   i = MPS_WORD_WIDTH;
   155   buf[i] = '\0';
   156   do {
   157     --i;
   158     buf[i] = digit[w % base];
   159     w /= base;
   160   } while(w > 0);
   161 
   162   /* If the number is not as wide as the requested field, pad out the */
   163   /* buffer with zeros. */
   164   while(i > MPS_WORD_WIDTH - width) {
   165     --i;
   166     buf[i] = digit[0];
   167   }
   168 
   169   r = mps_lib_fputs(&buf[i], stream);
   170   if(r == mps_lib_EOF)
   171     return ResIO;
   172 
   173   return ResOK;
   174 }
   175 
   176 
   177 /* WriteF -- write formatted output
   178  *
   179  * .writef.p: There is an assumption that void * fits in Word in
   180  * the case of $P.
   181  *
   182  * .writef.div: Although MPS_WORD_WIDTH/4 appears three times, there
   183  * are effectively three separate decisions to format at this width.
   184  */
   185 
   186 Res WriteF(mps_lib_FILE *stream, ...)
   187 {
   188   const char *format;
   189   int r;
   190   Res res;
   191   va_list args;
   192 
   193   AVER(stream != NULL);
   194   
   195   va_start(args, stream);
   196   
   197   for(;;) {
   198     format = va_arg(args, const char *);
   199     if(format == NULL)
   200       break;
   201 
   202     while(*format != '\0') {
   203       if(*format != '$') {
   204         r = mps_lib_fputc(*format, stream);
   205         if(r == mps_lib_EOF)
   206           return ResIO;
   207       } else {
   208         ++format;
   209         AVER(*format != '\0');
   210 
   211         switch(*format) {
   212           case 'A': {   /* address */
   213             Addr addr = va_arg(args, Addr);
   214             res = WriteWord(stream, (Word)addr, 0x10, MPS_WORD_WIDTH / 
4);
   215             if(res != ResOK) return res;
   216           } break;
   217 
   218           case 'P': {   /* pointer, see .writef.p */
   219             void *p = va_arg(args, void *);
   220             res = WriteWord(stream, (Word)p, 0x10, MPS_WORD_WIDTH / 4);
   221             if(res != ResOK) return res;
   222           } break;
   223 
   224           case 'S': {   /* string */
   225             char *s = va_arg(args, char *);
   226             r = mps_lib_fputs(s, stream);
   227             if(r == mps_lib_EOF)
   228               return ResIO;
   229           } break;
   230         
   231           case 'C': {   /* character */
   232             char c = va_arg(args, int);
   233             r = mps_lib_fputc(c, stream);
   234             if(r == mps_lib_EOF)
   235               return ResIO;
   236           } break;
   237         
   238           case 'W': {   /* word */
   239             Word w = va_arg(args, Word);
   240             res = WriteWord(stream, w, 0x10, MPS_WORD_WIDTH / 4);
   241             if(res != ResOK) return res;
   242           } break;
   243 
   244           case 'U': {   /* decimal */
   245             unsigned long u = va_arg(args, unsigned long);
   246             res = WriteWord(stream, (Word)u, 10, 0);
   247             if(res != ResOK) return res;
   248           } break;
   249 
   250           case 'B': {   /* binary */
   251             unsigned long u = va_arg(args, unsigned long);
   252             res = WriteWord(stream, (Word)u, 2, MPS_WORD_WIDTH);
   253             if(res != ResOK) return res;
   254           } break;
   255         
   256           case '$': {   /* dollar char */
   257             r = mps_lib_fputc('$', stream);
   258             if(r == mps_lib_EOF)
   259               return ResIO;
   260           } break;
   261 
   262           default:
   263           NOTREACHED;
   264         }
   265       }
   266 
   267       ++format;
   268     }
   269   }
   270   
   271   va_end(args);
   272   
   273   return ResOK;
   274 }

