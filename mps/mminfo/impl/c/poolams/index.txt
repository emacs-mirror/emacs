                   AUTOMATIC MARK & SWEEP POOL CLASS
                             impl.c.poolams
                               draft doc
                           gavinm 1997-08-18

     1 /* impl.c.poolams: AUTOMATIC MARK & SWEEP POOL CLASS
     2  *
     3  * $HopeName: MMsrc!poolams.c(trunk.2) $
     4  * Copyright (C) 1997 The Harlequin Group Limited.  All rights reserved.
     5  * 
     6  * NOTES
     7  * 
     8  * .readership: any MPS developer.
     9  * 
    10  * .scope: Implementation of a basic mark/sweep pool.
    11  *
    12  * .purpose: A canonical mark/sweep pool to be used as the basis for
    13  * other mark/sweep pools and for understanding the issues involved in
    14  * doing mark/sweep collection in the MPS framework.
    15  * 
    16  * .design: See design.mps.poolams.
    17  */
    18 
    19 #include "mpm.h"
    20 #include "mpscams.h"
    21 
    22 SRCID(poolams, "$HopeName: MMsrc!poolams.c(trunk.2) $");
    23 
    24 /* These two BT utility functions should be in the BT module.
    25  * See design.mps.poolams.bt.utilities */
    26 
    27 static void AMSBTCopyInvRange(BT fromBT, BT toBT, Index base, Index 
limit)
    28 {
    29   Index i = base;
    30   while(i < limit) {
    31     if (BTGet(fromBT, i))
    32       BTRes(toBT,i);
    33     else
    34       BTSet(toBT,i);
    35     ++ i;
    36   }
    37 }
    38 
    39 static Bool AMSBTRangesSame(BT BTx, BT BTy, Index base, Index limit)
    40 {
    41   Index i = base;
    42   while(i < limit) {
    43     if (BTGet(BTx, i) != BTGet(BTy, i))
    44       return FALSE;
    45     ++ i;
    46   }
    47   return TRUE;
    48 }
    49 
    50 #define AMSSig          ((Sig)0x519A3599) /* SIGnature AMS */
    51 
    52 typedef struct AMSStruct *AMS;
    53 typedef struct AMSStruct {
    54   PoolStruct poolStruct;        /* generic pool structure */
    55   Format format;                /* format of objects in this pool */
    56   Shift grainShift;             /* log2 of grain size */
    57   ActionStruct actionStruct;    /* action of collecting this pool */
    58   Size size;                    /* total segment size of the pool */
    59   Size lastReclaimed;           /* total size of the pool after last 
reclaim */
    60   Sig sig;
    61 } AMSStruct;
    62 
    63 
    64 #define AMSGroupSig     ((Sig)0x519A359B) /* SIGnature AMS GrouP */
    65 
    66 typedef struct AMSGroupStruct *AMSGroup;
    67 typedef struct AMSGroupStruct {
    68   Sig sig;
    69   Seg seg;                      /* segment of group's memory */
    70   AMS ams;                      /* owning ams */
    71   Count grains;                 /* number of grains in this group */
    72   BT allocTable;                /* set if grain is allocated */
    73 
    74   /* design.mps.poolams.one-condemn */
    75   Bool marked;                  /* has been marked since last scan */
    76   BT markTable;                 /* set if grain marked */
    77   BT scanTable;                 /* set if grain scanned */
    78 } AMSGroupStruct;
    79 
    80 /* prototype the check function here; definition is at the end of the
    81  * file, after the declaration of the pool class structure. */
    82 
    83 static Bool AMSCheck(AMS ams);
    84 
    85 /* macros to get between child and parent structures */
    86 
    87 #define PoolPoolAMS(pool) PARENT(AMSStruct, poolStruct, pool)
    88 #define AMSPool(ams)      (&(ams)->poolStruct)
    89 
    90 #define ActionAMS(action) PARENT(AMSStruct, actionStruct, action)
    91 #define AMSAction(ams)    (&(ams)->actionStruct)
    92 
    93 /* macros for abstracting index/address computations */
    94 
    95 /* design.mps.poolams.addr-index.slow */
    96 
    97 #define AMSGroupSpace(group)      PoolSpace(AMSPool((group)->ams))
    98 
    99 #define AMSGrains(ams,size)       ((size) >> (ams)->grainShift)
   100 
   101 #define AMSGroupBase(group)       SegBase(AMSGroupSpace(group), 
(group)->seg)
   102 
   103 #define AMSGroupLimit(group)      SegLimit(AMSGroupSpace(group), 
(group)->seg)
   104 
   105 #define AMSGroupShift(group)      ((group)->ams->grainShift)
   106 
   107 #define AMSGroupOffset(group, addr) AddrOffset(AMSGroupBase(group), addr)
   108 
   109 #define AMSGroupAddr(group, offset) AddrAdd(AMSGroupBase(group), offset)
   110 
   111 #define AMSAddrIndex(group,addr) ((Index)(AMSGroupOffset(group,addr) \
   112                                           >> AMSGroupShift(group)))
   113 
   114 #define AMSIndexAddr(group,index) AMSGroupAddr(group,                \
   115                                                (index) << 
AMSGroupShift(group))
   116 
   117 #define AMSSegGroup(seg) ((AMSGroup)SegP(seg))
   118 
   119 
   120 static Bool AMSGroupCheck(AMSGroup group)
   121 {
   122   CHECKS(AMSGroup, group);
   123   CHECKL(SegCheck(group->seg));
   124   CHECKU(AMS, group->ams);
   125 
   126   /* do the grains check both ways, to avoid rounding and overflow 
errors */
   127   CHECKL(group->grains ==
   128          (SegSize(PoolSpace(AMSPool(group->ams)), group->seg) >>
   129           group->ams->grainShift));
   130   CHECKL((group->grains << group->ams->grainShift) ==
   131          SegSize(PoolSpace(AMSPool(group->ams)), group->seg));
   132   
   133   if (SegWhite(group->seg) != TraceSetEMPTY) {
   134     CHECKL(TraceSetSingle(SegWhite(group->seg)));
   135   }
   136 
   137   CHECKL(BoolCheck(group->marked));
   138   /* design.mps.poolams.bt-check */
   139   CHECKL(group->allocTable != NULL);
   140   CHECKL(group->markTable != NULL);
   141   CHECKL(group->scanTable != NULL);
   142   return TRUE;
   143 }
   144 
   145 /* the different valid colours of grains. See 
design.mps.poolams.invariant. */
   146 
   147 enum {
   148   AMS_WHITE,
   149   AMS_GREY,
   150   AMS_BLACK,
   151   AMS_FREE,
   152   AMS_ILLEGAL
   153 };
   154 
   155 /* find the colour of a grain. See design.mps.poolams.colour.slow */
   156 
   157 static int AMSGrainColour(AMSGroup group, Index index)
   158 {
   159   Bool mark, scan, alloc;
   160 
   161   AVERT(AMSGroup, group);
   162   AVER(index < group->grains);
   163 
   164   mark = BTGet(group->markTable, index);
   165   scan = BTGet(group->scanTable, index);
   166   alloc = BTGet(group->allocTable, index);
   167   
   168   if (mark) {     /* mark */
   169     if (scan) {   /* mark, scan */
   170       if (alloc)
   171         return AMS_BLACK;       /*  mark,  scan,  alloc: black */
   172       else
   173         return AMS_ILLEGAL;
   174     } else {      /* mark, !scan */
   175       if (alloc)
   176         return AMS_GREY;        /*  mark, !scan,  alloc: grey */
   177       else
   178         return AMS_ILLEGAL;
   179     } 
   180   } else {        /* !mark */
   181     if (scan) {   /* !mark, scan */
   182       if (alloc)
   183         return AMS_ILLEGAL;
   184       else
   185         return AMS_FREE;        /* !mark,  scan, !alloc: free */
   186     } else {      /* !mark, !scan */
   187       if (alloc)
   188         return AMS_WHITE;       /*  mark, !scan,  alloc: white */
   189       else
   190         return AMS_ILLEGAL;
   191     }
   192   }
   193 }
   194 
   195 /* AMSBTCreate -- allocate a BT from the control pool */
   196 
   197 static Res AMSBTCreate(BT *btReturn, Space space, Count length)
   198 {
   199   Res res;
   200   BT bt;
   201   void *p;
   202 
   203   AVER(btReturn != NULL);
   204   AVERT(Space, space);
   205   AVER(length > 0);
   206 
   207   res = SpaceAlloc(&p, space, BTSize(length));
   208   if(res != ResOK)
   209     return res;
   210   bt = (BT)p;
   211 
   212   BTResRange(bt, 0, length);
   213 
   214   *btReturn = bt;
   215   return ResOK;
   216 }
   217 
   218 /* AMSBTDestroy -- free a BT to the control pool */
   219 
   220 static void AMSBTDestroy(BT bt, Space space, Count length)
   221 {
   222   AVER(bt != NULL);
   223   AVERT(Space, space);
   224   AVER(length > 0);
   225   
   226   SpaceFree(space, (Addr)bt, BTSize(length));
   227 }
   228 
   229 static Res AMSGroupCreate(AMSGroup *groupReturn, Pool pool, Size size,
   230                           RankSet rankSet)
   231 {
   232   AMSGroup group;               /* the group */
   233   AMS ams;
   234   Res res;
   235   Space space;
   236   Seg seg;
   237   void *p;
   238   
   239   AVER(groupReturn != NULL);
   240   AVERT(Pool, pool);
   241   AVER(RankSetCheck(rankSet));
   242   AVER(size > 0);
   243 
   244   ams = PoolPoolAMS(pool);
   245   AVERT(AMS,ams);
   246   
   247   space = PoolSpace(pool);
   248   
   249   size = SizeAlignUp(size, ArenaAlign(space));
   250   if (size == 0)
   251     return ResMEMORY;
   252   
   253   res = SpaceAlloc(&p, space, (Size)sizeof(AMSGroupStruct));
   254   if (res != ResOK)
   255     goto failGroup;
   256   group = (AMSGroup)p;
   257 
   258   res = PoolSegAlloc(&seg, SegPrefDefault(), pool, size);
   259   if (res != ResOK)
   260     goto failSeg;
   261   
   262   group->seg = seg;
   263   SegSetP(seg, (void*)group);
   264   SegSetRankSet(seg, rankSet);
   265   if (rankSet != RankSetEMPTY)
   266     SegSetSummary(seg, RefSetUNIV);
   267 
   268   group->grains = size >> ams->grainShift;
   269   group->marked = FALSE; /* design.mps.poolams.marked.unused */
   270 
   271   res = AMSBTCreate(&group->allocTable, space, group->grains);
   272   if (res != ResOK)
   273     goto failAlloc;
   274 
   275   res = AMSBTCreate(&group->markTable, space, group->grains);
   276   if (res != ResOK)
   277     goto failMark;
   278 
   279   res = AMSBTCreate(&group->scanTable, space, group->grains);
   280   if (res != ResOK)
   281     goto failScan;
   282   
   283   /* design.mps.poolams.invariant.create */
   284   BTSetRange(group->scanTable, 0, group->grains);
   285 
   286   group->ams = ams;
   287   group->sig = AMSGroupSig;
   288   AVERT(AMSGroup, group);
   289   ams->size += size;
   290 
   291   *groupReturn = group;
   292   return ResOK;
   293   
   294 failScan:
   295   AMSBTDestroy(group->markTable, space, group->grains);
   296 failMark:
   297   AMSBTDestroy(group->allocTable, space, group->grains);
   298 failAlloc:
   299   PoolSegFree(pool, seg);
   300 failSeg:
   301   SpaceFree(space, (Addr)group, (Size)sizeof(AMSGroupStruct));
   302 failGroup:
   303   return res;
   304 }
   305 
   306 static void AMSGroupDestroy(AMSGroup group)
   307 {
   308   AMS ams;
   309   Space space;
   310 
   311   AVERT(AMSGroup, group);
   312   ams = group->ams;
   313   AVERT(AMS, ams);
   314   space = PoolSpace(AMSPool(ams));
   315   AVERT(Space, space);
   316 
   317   AVER(ams->size >= SegSize(space, group->seg));
   318 
   319   ams->size -= SegSize(space, group->seg);
   320   ams->lastReclaimed = ams->size;
   321 
   322   group->sig = SigInvalid;
   323 
   324   AMSBTDestroy(group->allocTable, space, group->grains);
   325   AMSBTDestroy(group->markTable, space, group->grains);
   326   AMSBTDestroy(group->scanTable, space, group->grains);
   327   PoolSegFree(AMSPool(ams), group->seg);
   328   SpaceFree(space, (Addr)group, (Size)sizeof(AMSGroupStruct));
   329 }  
   330   
   331 static Res AMSInit(Pool pool, va_list arg)
   332 {
   333   AMS ams;
   334 
   335   AVERT(Pool, pool);
   336 
   337   ams = PoolPoolAMS(pool);
   338 
   339   ams->format = va_arg(arg, Format);
   340   AVERT(Format, ams->format);
   341   pool->alignment = ams->format->alignment;
   342   ams->grainShift = SizeLog2(pool->alignment);
   343 
   344   ActionInit(AMSAction(ams), pool);
   345 
   346   ams->size = 0;
   347   ams->lastReclaimed = 0;
   348 
   349   ams->sig = AMSSig;
   350   AVERT(AMS, ams);
   351 
   352   return ResOK;
   353 }
   354 
   355 static void AMSFinish(Pool pool)
   356 {
   357   AMS ams;
   358   Ring ring, node;
   359 
   360   AVERT(Pool, pool);
   361   ams = PoolPoolAMS(pool);
   362   AVERT(AMS, ams);
   363 
   364   ring = PoolSegRing(pool);
   365   node = RingNext(ring);
   366   while(node != ring) {
   367     Ring next = RingNext(node);
   368     Seg seg = SegOfPoolRing(node);
   369     AMSGroup group = (AMSGroup)SegP(seg);
   370 
   371     AMSGroupDestroy(group);
   372 
   373     node = next;
   374   }
   375 
   376   ActionFinish(AMSAction(ams));
   377   /* can't invalidate the AMS until we've destroyed all the groups */
   378   ams->sig = SigInvalid;
   379 }
   380 
   381 /* attempts to allocate an object of at least the given size in the
   382  * given group. If successful, returns the base and limit grain
   383  * indices of the allocated object.  */
   384 
   385 static Bool AMSGroupAlloc(Index *baseReturn, Index *limitReturn,
   386                           AMSGroup group, Size size)
   387 {
   388   AMS ams;
   389   Size grains;
   390   Bool b;
   391   Index base, limit;
   392 
   393   AVER(baseReturn != NULL);
   394   AVER(limitReturn != NULL);
   395   AVERT(AMSGroup, group);
   396 
   397   ams = group->ams;
   398   AVERT(AMS, ams);
   399 
   400   AVER(size > 0);
   401   AVER(SizeIsAligned(size, AMSPool(ams)->alignment));
   402 
   403   grains = AMSGrains(ams, size);
   404   AVER(grains >= 1);
   405   if (grains > group->grains)
   406     return FALSE;
   407 
   408   b = BTFindLongResRange(&base, &limit, group->allocTable,
   409                          0, group->grains, grains);
   410   if (!b)
   411     return FALSE;
   412 
   413   /* design.mps.poolams.invariant.free */
   414   AVER(BTIsResRange(group->markTable, base, limit));
   415   AVER(BTIsSetRange(group->scanTable, base, limit));
   416   AVER(BTIsResRange(group->allocTable, base, limit));
   417 
   418   /* design.mps.poolams.invariant.black */
   419   BTSetRange(group->allocTable, base, limit);
   420   BTSetRange(group->markTable, base, limit);
   421 
   422   *baseReturn = base;
   423   *limitReturn = limit;
   424   return TRUE;
   425 }
   426 
   427 
   428 static Res AMSBufferFill(Seg *segReturn,
   429                          Addr *baseReturn, Addr *limitReturn,
   430                          Pool pool, Buffer buffer, Size size)
   431 {
   432   Res res;
   433   AMS ams;
   434   AMSGroup group;
   435   Ring node, ring;
   436   Index base, limit;
   437   Bool b;
   438 
   439   AVER(segReturn != NULL);
   440   AVER(baseReturn != NULL);
   441   AVER(limitReturn != NULL);
   442   AVERT(Buffer, buffer);
   443   AVER(size > 0);
   444 
   445   AVERT(Pool, pool);
   446   ams = PoolPoolAMS(pool);
   447   AVERT(AMS, ams);
   448 
   449   size = SizeAlignUp(size, PoolAlignment(pool));
   450   if (size == 0) { /* overflow */
   451     return ResMEMORY;
   452   }
   453 
   454   /* design.mps.poolams.fill.slow */
   455   ring = PoolSegRing(pool);
   456   RING_FOR(node, ring) {
   457     Seg seg = SegOfPoolRing(node);
   458     if (SegBuffer(seg) == NULL) {
   459       group = AMSSegGroup(seg);
   460       AVERT(AMSGroup, group);
   461       b = AMSGroupAlloc(&base, &limit, group, size);
   462       if (b)
   463         goto found;
   464     }
   465   }
   466   
   467   res = AMSGroupCreate(&group, pool, size, BufferRankSet(buffer));
   468   if (res != ResOK)
   469     return res;
   470   b = AMSGroupAlloc(&base, &limit, group, size);
   471   AVER(b);
   472   
   473 found:
   474   *segReturn = group->seg;
   475   *baseReturn = AMSIndexAddr(group, base);
   476   *limitReturn = AMSIndexAddr(group, limit);
   477   return ResOK;
   478 }
   479 
   480 static void AMSBufferEmpty(Pool pool, Buffer buffer)
   481 {
   482   AMS ams;
   483   Addr init, limit;
   484   Index initIndex, limitIndex;
   485   Seg seg;
   486   AMSGroup group;
   487 
   488   AVERT(Pool, pool);
   489   ams = PoolPoolAMS(pool);
   490   AVERT(AMS, ams);
   491   AVERT(Buffer,buffer);
   492   AVER(!BufferIsReset(buffer));
   493   AVER(BufferIsReady(buffer));
   494   
   495   seg = BufferSeg(buffer);
   496   group = AMSSegGroup(seg);
   497   AVERT(AMSGroup, group);
   498   AVER(group->seg == seg);
   499   
   500   init = BufferGetInit(buffer);
   501   limit = BufferLimit(buffer);
   502 
   503   AVER(AddrIsAligned(init, PoolAlignment(pool)));
   504   AVER(AddrIsAligned(limit, PoolAlignment(pool)));
   505 
   506   if (init == limit)
   507     return;
   508 
   509   initIndex = AMSAddrIndex(group, init);
   510   limitIndex = AMSAddrIndex(group, limit);
   511 
   512   /* design.mps.poolams.invariant.black, 
design.mps.poolams.invariant.fill */
   513   AVER(BTIsSetRange(group->markTable, initIndex, limitIndex));
   514   AVER(BTIsSetRange(group->scanTable, initIndex, limitIndex));
   515   AVER(BTIsSetRange(group->allocTable, initIndex, limitIndex));
   516 
   517   /* design.mps.poolams.invariant.free, 
design.mps.poolams.invariant.empty */
   518   BTResRange(group->markTable, initIndex, limitIndex);
   519   BTResRange(group->allocTable, initIndex, limitIndex);
   520 }
   521 
   522 static void AMSRangeCondemn(AMSGroup group, Index base, Index limit)
   523 {
   524   if (base != limit) {
   525     AVER(base < limit);
   526     AVER(limit <= group->grains);
   527     
   528     /* either black or free, see design.mps.poolams.invariant */
   529     AVER(BTIsSetRange(group->scanTable, base, limit));
   530     AVER(AMSBTRangesSame(group->allocTable, group->markTable, base, 
limit));
   531     
   532     /* black -> white, free -> free, see design.mps.poolams.invariant */
   533     BTResRange(group->markTable, base, limit);
   534     AMSBTCopyInvRange(group->allocTable, group->scanTable, base, limit);
   535   }
   536 }
   537 
   538 static Res AMSCondemn(Pool pool, Trace trace, Seg seg, Action action)
   539 {
   540   AMS ams;
   541   AMSGroup group;
   542   Buffer buffer;
   543 
   544   AVERT(Pool, pool);
   545   ams = PoolPoolAMS(pool);
   546   AVERT(AMS, ams);
   547 
   548   AVERT(Trace, trace);
   549   AVER(SegCheck(seg));
   550   AVERT(Action, action);
   551   AVER(ams == ActionAMS(action));
   552 
   553   group = AMSSegGroup(seg);
   554   AVERT(AMSGroup, group);
   555   AVER(group->seg == seg);
   556   AVER(group->ams == ams);
   557 
   558   buffer = SegBuffer(seg);
   559   if (buffer != NULL) { /* design.mps.poolams.condemn.buffer */
   560     Index scanLimitIndex, limitIndex;
   561     scanLimitIndex = AMSAddrIndex(group, BufferScanLimit(buffer));
   562     limitIndex = AMSAddrIndex(group, BufferLimit(buffer));
   563     
   564     AMSRangeCondemn(group, 0, scanLimitIndex);
   565     AMSRangeCondemn(group, limitIndex, group->grains);
   566   } else { /* condemn whole seg */
   567     AMSRangeCondemn(group, 0, group->grains);
   568   }
   569 
   570   group->marked = FALSE; /* design.mps.poolams.marked.condemn */
   571   SegSetWhite(seg, TraceSetAdd(SegWhite(seg), trace->ti));
   572 
   573   return ResOK;
   574 }
   575 
   576 static Res AMSScanGroupOnce(ScanState ss, AMS ams, AMSGroup group,
   577                             Seg seg, Space space, Bool scanAllObjects)
   578 {
   579   Res res;
   580   Format format;
   581   Align alignment;
   582   Addr p;
   583   Addr limit;
   584 
   585   limit = SegLimit(space, seg);
   586   format = ams->format;
   587   alignment = AMSPool(ams)->alignment;
   588 
   589   p = SegBase(space, seg);
   590   while (p < limit) {
   591     Addr next;
   592     Buffer buffer = SegBuffer(seg);
   593 
   594     AVER(AddrIsAligned(p, alignment));
   595     
   596     if (buffer != NULL &&
   597         p == BufferScanLimit(buffer) &&
   598         p != BufferLimit(buffer)) { /* design.mps.poolams.scan.buffer */
   599       p = BufferLimit(buffer); 
   600     } else { /* not in the buffer */
   601 
   602       Index i = AMSAddrIndex(group,p);
   603       int colour = AMSGrainColour(group, i);
   604       AVER(colour != AMS_ILLEGAL);
   605       if (colour == AMS_FREE) { /* no object here */
   606         next = AddrAdd(p, alignment);
   607       } else { /* there is an object here */
   608         next = (*format->skip)(p);
   609         if (scanAllObjects || (colour == AMS_GREY)) {
   610           next = (*format->skip)(p);
   611           res = (*format->scan)(ss, p, next);
   612           if (res != ResOK) {
   613             return res;
   614           }
   615           BTSet(group->scanTable, i);
   616         }
   617       }
   618       p = next;
   619     }
   620   }
   621   AVER(p == limit);
   622   return ResOK;
   623 }
   624 
   625 static Res AMSScan(ScanState ss, Pool pool, Seg seg)
   626 {
   627   Res res;
   628   AMS ams;
   629   Space space;
   630   AMSGroup group;
   631   Bool scanOnce;
   632   Bool scanAllObjects;
   633 
   634   AVERT(ScanState, ss);
   635   AVER(ss->summary == RefSetEMPTY); /* to make afterSummary correct */
   636   AVER(ss->fixed == RefSetEMPTY);   /* to make afterSummary correct */
   637   
   638   AVERT(Pool, pool);
   639   ams = PoolPoolAMS(pool);
   640   AVERT(AMS, ams);
   641   space = PoolSpace(pool);
   642 
   643   AVER(SegCheck(seg));
   644   group = AMSSegGroup(seg);
   645   AVERT(AMSGroup, group);
   646 
   647   /* design.mps.poolams.scan.all */
   648   scanAllObjects = (TraceSetDiff(ss->traces, SegWhite(seg)) != 
TraceSetEMPTY);
   649   /* design.mps.poolams.scan.once */
   650   scanOnce = (TraceSetInter(ss->traces, SegWhite(seg)) == TraceSetEMPTY);
   651 
   652   AVER(!scanOnce || scanAllObjects); /* scanOnce implies scanAllObjects 
*/
   653   
   654   if (scanOnce) {
   655 
   656     Bool wasMarked = group->marked; /* for checking */
   657     group->marked = FALSE;          /* for checking */
   658     res = AMSScanGroupOnce(ss, ams, group, seg, space, scanAllObjects);
   659     AVER(!group->marked);
   660     group->marked = wasMarked;      /* restore marked flag */
   661     if (res != ResOK)
   662       return res;
   663 
   664   } else {
   665 
   666     AVER(group->marked);
   667     do { /* design.mps.poolams.marked.scan */
   668       group->marked = FALSE; 
   669       res = AMSScanGroupOnce(ss, ams, group, seg, space, scanAllObjects);
   670       if (res != ResOK) {
   671         group->marked = TRUE; /* design.mps.poolams.marked.scan.fail */
   672         return res;
   673       }
   674     } while(group->marked);
   675 
   676   }
   677 
   678   AVER(RefSetSub(ss->summary, SegSummary(seg)));
   679 
   680   if (!scanAllObjects) { /* design.mps.poolams.summary */
   681     /* design.mps.poolams.summary.scan.part.summary */
   682     ss->summary = RefSetUnion(ss->summary, SegSummary(seg));
   683     /* design.mps.poolams.summary.scan.part.fixed */
   684     ss->fixed = RefSetUnion(ss->fixed, RefSetInter(SegSummary(seg),
   685                                                    ss->white));
   686   }
   687 
   688   return ResOK;
   689 }
   690 
   691 static Res AMSFix(Pool pool, ScanState ss, Seg seg, Ref *refIO)
   692 {
   693   AMS ams;
   694   AMSGroup group;
   695   Space space;
   696   Index i;
   697   Ref ref;
   698   int colour;
   699 
   700   AVERT(Pool, pool);
   701   ams = PoolPoolAMS(pool);
   702   AVERT(AMS, ams);
   703 
   704   AVERT(ScanState, ss);
   705   AVER(refIO != NULL);
   706 
   707   AVER(SegCheck(seg));
   708   group = AMSSegGroup(seg);
   709   AVERT(AMSGroup, group);
   710   
   711   space = PoolSpace(pool);
   712 
   713   ref = *refIO;
   714   i = AMSAddrIndex(group, ref);
   715   colour = AMSGrainColour(group, i);
   716   AVER(colour != AMS_ILLEGAL);
   717   
   718   ss->wasMarked = TRUE;
   719 
   720   switch (ss->rank) {
   721   case RankAMBIG:
   722     /* not a real pointer if not aligned or not allocated */
   723     if(!AddrIsAligned((Addr)ref, pool->alignment) ||
   724        (colour == AMS_FREE)) {
   725       return ResOK;
   726     }
   727     /* falls through */
   728   case RankEXACT:
   729   case RankFINAL:
   730   case RankWEAK:
   731     AVER(AddrIsAligned((Addr)ref, pool->alignment));
   732     AVER(colour != AMS_FREE);
   733     if(colour == AMS_WHITE) {
   734       ss->wasMarked = FALSE;
   735       if(ss->rank == RankWEAK) { /* then splat the reference */
   736         *refIO = (Ref)0;
   737       } else {
   738         BTSet(group->markTable, i); /* turn this object grey */
   739 
   740         /* design.mps.poolams.fix.to-black */
   741         if (RefSetInter(SegSummary(seg), ss->white) != RefSetEMPTY) {
   742           TraceSegGreyen(space, seg, ss->traces); /* turn this segment 
grey */
   743           group->marked = TRUE; /* design.mps.poolams.marked.fix */
   744         } else {
   745           BTSet(group->scanTable, i); /* turn this object black */
   746         }
   747       }
   748     }
   749     break;
   750   default:
   751     NOTREACHED;
   752   }
   753 
   754   return ResOK;
   755 }
   756 
   757 static void AMSReclaim(Pool pool, Trace trace, Seg seg)
   758 {
   759   AMS ams;
   760   AMSGroup group;
   761   Space space;
   762   Format format;
   763   Addr p;
   764   Addr limit;
   765   Buffer buffer;
   766   Bool anySurvivors;
   767 
   768   AVERT(Pool, pool);
   769   ams = PoolPoolAMS(pool);
   770   AVERT(AMS, ams);
   771 
   772   group = AMSSegGroup(seg);
   773 
   774   AVER(group->marked == FALSE); /* design.mps.poolams.marked.reclaim */
   775   
   776   space = PoolSpace(pool);
   777   limit = SegLimit(space, seg);
   778   format = ams->format;
   779   buffer = SegBuffer(seg);
   780   p = SegBase(space, seg);
   781   anySurvivors = FALSE;
   782 
   783   while (p < limit) {
   784     Addr next;
   785     AVER(AddrIsAligned(p, pool->alignment));
   786     
   787     if (buffer != NULL &&
   788         p == BufferScanLimit(buffer) &&
   789         p != BufferLimit(buffer)) { /* design.mps.poolams.reclaim.buffer 
*/
   790       p = BufferLimit(buffer); 
   791     } else { /* not in the buffer */
   792 
   793       Index i = AMSAddrIndex(group, p);
   794       int colour = AMSGrainColour(group, i);
   795       AVER(colour != AMS_ILLEGAL);
   796       AVER(colour != AMS_GREY); /* no grey objects now */
   797       if (colour == AMS_FREE) { /* no object here */
   798         next = AddrAdd(p, pool->alignment);
   799       } else { /* there is an object here */
   800         next = (*format->skip)(p);
   801         if (colour == AMS_WHITE) { /* then we can free it */
   802           Index j = AMSAddrIndex(group, next);
   803           /* design.mps.poolams.invariant.free */
   804           BTResRange(group->markTable, i, j);
   805           BTSetRange(group->scanTable, i, j);
   806           BTResRange(group->allocTable, i, j);
   807         } else {
   808           anySurvivors = TRUE;
   809         }
   810       }
   811       p = next;
   812     }
   813   }
   814   AVER(p == limit);
   815   
   816   if ((buffer == NULL) && !anySurvivors) {
   817     AMSGroupDestroy(group);
   818   } else {
   819     SegSetWhite(seg, TraceSetDel(SegWhite(seg), trace->ti));
   820   }
   821 }
   822 
   823 /* design.mps.poolams.benefit.guess */
   824 static double AMSBenefit(Pool pool, Action action)
   825 {
   826   AMS ams;
   827 
   828   AVERT(Pool, pool);
   829   ams = PoolPoolAMS(pool);
   830   AVERT(AMS, ams);
   831 
   832   AVERT(Action, action);
   833   AVER(ams == ActionAMS(action));
   834 
   835   /* design.mps.poolams.benefit.repeat */
   836   if ((ams->size > 1024*1024) &&
   837       (ams->size > ams->lastReclaimed + ams->lastReclaimed))
   838     return 1.0;
   839   else
   840     return 0.0;
   841 }
   842 
   843 static Res AMSSegDescribe(AMS ams, Seg seg, mps_lib_FILE *stream)
   844 {
   845   Res res;
   846   AMSGroup group;
   847   Buffer buffer;
   848   Index i;
   849 
   850   AVERT(AMS, ams);
   851   AVER(SegCheck(seg));
   852   group = AMSSegGroup(seg);
   853   AVERT(AMSGroup, group);
   854   AVER(group->ams == ams);
   855 
   856   buffer = SegBuffer(seg);
   857 
   858   if (buffer != NULL) {
   859     AVERT(Buffer, buffer);
   860     AVER(BufferSeg(buffer) == seg);
   861   }
   862 
   863   res = WriteF(stream,
   864                "AMS Group $P {\n", (WriteFP)group,
   865                "  seg $P [$A-$A]\n",
   866                (WriteFP)seg, AMSGroupBase(group), AMSGroupLimit(group),
   867                "  AMS $P\n", (WriteFP)ams,
   868                "  grains $W\n", (WriteFW)group->grains,
   869                "  tables: alloc $P, mark $P, scan $P\n",
   870                  (WriteFP)group->allocTable,
   871                  (WriteFP)group->markTable,
   872                  (WriteFP)group->scanTable,
   873                "  map: ",
   874                NULL);
   875                
   876   for (i=0 ; i < group->grains; ++ i) {
   877     char c = 0;
   878     if (buffer != NULL) {
   879       Index baseIndex, limitIndex, scanLimitIndex, initIndex, allocIndex;
   880 
   881       baseIndex = AMSAddrIndex(group, BufferBase(buffer));
   882       limitIndex = AMSAddrIndex(group, BufferLimit(buffer));
   883       scanLimitIndex = AMSAddrIndex(group, BufferScanLimit(buffer));
   884       initIndex = AMSAddrIndex(group, BufferGetInit(buffer));
   885       allocIndex = AMSAddrIndex(group, BufferAlloc(buffer));
   886 
   887       if (i == limitIndex)
   888         c = ']';
   889       else if (i == baseIndex)
   890         c = '[';
   891       else if (i == scanLimitIndex)
   892         c = '<';
   893       else if (i == initIndex)
   894         c = '|';
   895       else if (i == allocIndex)
   896         c = '>';
   897 
   898       if (c != 0) {
   899         res = WriteF(stream, "$C", c, NULL);
   900         if (res != ResOK)
   901           return res;
   902       }
   903     }
   904 
   905     switch(AMSGrainColour(group, i)) {
   906     case AMS_FREE:
   907       c = '.';
   908       break;
   909     case AMS_WHITE:
   910       c = '-';
   911       break;
   912     case AMS_GREY:
   913       c = '+';
   914       break;
   915     case AMS_BLACK:
   916       c = '*';
   917       break;
   918     case AMS_ILLEGAL: /* maybe we've broken an invariant from the 
debugger */
   919       c = '!';
   920       break;
   921     default:
   922       NOTREACHED;
   923     }
   924     res = WriteF(stream, "$C", c, NULL);
   925     if (res != ResOK)
   926       return res;
   927     if (i % 64 == 63) {
   928       res = WriteF(stream, "\n       ", NULL);
   929       if (res != ResOK)
   930         return res;
   931     }
   932   }
   933 
   934   res = WriteF(stream, "\n} AMS Group $P\n", (WriteFP)group);
   935   return res;
   936 }
   937 
   938 static Res AMSDescribe(Pool pool, mps_lib_FILE *stream)
   939 {
   940   AMS ams;
   941   Ring node;
   942   Res res;
   943 
   944   AVERT(Pool, pool);
   945   ams = PoolPoolAMS(pool);
   946   AVERT(AMS, ams);
   947 
   948   res = WriteF(stream,
   949                "AMS $P {\n", (WriteFP)ams,
   950                "  pool $P ($U)\n",
   951                (WriteFP)pool, (WriteFU)pool->serial,
   952                "  size $W, lastReclaimed $W\n",
   953                (WriteFW)ams->size, (WriteFW)ams->lastReclaimed,
   954                "  format $P ($U)\n",
   955                (WriteFP)ams->format, (WriteFU)ams->format->serial,
   956                "  grain shift $U\n", (WriteFU)ams->grainShift,
   957                NULL);
   958   if (res != ResOK)
   959     return res;
   960 
   961   res = WriteF(stream,
   962                "  segments [* = black, + = grey, - = white, . = free,\n"
   963                "            ! = bad, [.<.|.>.] = buffer b, sl, i, a, 
l]:\n",
   964                NULL);
   965   if (res != ResOK)
   966     return res;
   967 
   968   
   969   RING_FOR(node, PoolSegRing(pool)) {
   970     Seg seg = SegOfPoolRing(node);
   971     AMSSegDescribe(ams, seg, stream);
   972   }
   973 
   974   res = WriteF(stream, "} AMS $P\n",(WriteFP)ams, NULL);
   975   if (res != ResOK)
   976     return res;
   977 
   978   return ResOK;
   979 }
   980 
   981 /* PoolClassAMSStruct -- the class descriptor */
   982 
   983 static PoolClassStruct PoolClassAMSStruct = {
   984   PoolClassSig,
   985   "AMS",                        /* name */
   986   sizeof(AMSStruct),            /* size */
   987   offsetof(AMSStruct, poolStruct),      /* offset */
   988   AttrFMT | AttrSCAN | AttrBUF | AttrBUF_RESERVE | AttrGC | AttrINCR_RB,
   989   AMSInit,                      /* init */
   990   AMSFinish,                    /* finish */
   991   PoolNoAlloc,                   /* design.mps.poolams.no-alloc */
   992   PoolNoFree,                    /* design.mps.poolams.no-free */
   993   PoolTrivBufferInit,           /* design.mps.poolams.triv-buffer-init */
   994   AMSBufferFill,                /* bufferFill */
   995   AMSBufferEmpty,               /* bufferEmpty */
   996   PoolTrivBufferFinish,         /* design.mps.poolams.triv-buffer-finish 
*/
   997   PoolTrivTraceBegin,           /* design.mps.poolams.triv-trace-begin */
   998   AMSCondemn,                   /* condemn */
   999   PoolTrivGrey,                 /* design.mps.poolams.triv-grey */
  1000   AMSScan,                      /* scan */
  1001   AMSFix,                       /* fix */
  1002   AMSReclaim,                   /* reclaim */
  1003   PoolTrivTraceEnd,             /* design.mps.poolams.triv-trace-end */
  1004   AMSBenefit,                   /* benefit */
  1005   AMSDescribe,                  /* describe */
  1006   PoolClassSig                  /* impl.h.mpm.class.end-sig */
  1007 };
  1008 
  1009 static Bool AMSCheck(AMS ams)
  1010 {
  1011   CHECKS(AMS, ams);
  1012   CHECKD(Pool, AMSPool(ams));
  1013   CHECKL(AMSPool(ams)->class == &PoolClassAMSStruct);
  1014   CHECKD(Format, ams->format);
  1015   CHECKL((1 << ams->grainShift) == AMSPool(ams)->alignment);
  1016   CHECKD(Action, AMSAction(ams));
  1017   CHECKL(ams->lastReclaimed <= ams->size);
  1018 
  1019   return TRUE;
  1020 }
  1021 
  1022 /* mps_class_ams -- return the pool class descriptor to the client */
  1023 
  1024 mps_class_t mps_class_ams(void)
  1025 {
  1026   return (mps_class_t)&PoolClassAMSStruct;
  1027 }
  1028 

