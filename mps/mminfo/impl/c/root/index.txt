                          ROOT IMPLEMENTATION
                              impl.c.root
                             accepted impl
                           gavinm 1996-09-11

     1 /*  impl.c.root
     2  *
     3  *                   ROOT IMPLEMENTATION
     4  *
     5  *  $HopeName: MMsrc!root.c(trunk.15) $
     6  *
     7  *  Copyright (C) 1995 Harlequin Group, all rights reserved
     8  *
     9  *  This is the implementation of roots.
    10  */
    11 
    12 #include "mpm.h"
    13 
    14 SRCID(root, "$HopeName: MMsrc!root.c(trunk.15) $");
    15 
    16 Bool RootCheck(Root root)
    17 {
    18   CHECKS(Root, root);
    19   CHECKU(Space, root->space);
    20   CHECKL(root->serial < root->space->rootSerial);
    21   CHECKL(RingCheck(&root->spaceRing));
    22   CHECKL(RankCheck(root->rank));
    23   switch(root->var)
    24   {
    25     case RootTABLE:
    26     CHECKL(root->the.table.base != 0);
    27     CHECKL(root->the.table.base < root->the.table.limit);
    28     break;
    29 
    30     case RootFUN:
    31     CHECKL(root->the.fun.scan != NULL);
    32     break;
    33 
    34     case RootREG:
    35     CHECKL(root->the.reg.scan != NULL);
    36     CHECKD(Thread, root->the.reg.thread);
    37     break;
    38 
    39     case RootFMT:
    40     CHECKL(root->the.fmt.scan != NULL);
    41     CHECKL(root->the.fmt.base != 0);
    42     CHECKL(root->the.fmt.base < root->the.fmt.limit);
    43     break;
    44 
    45     default:
    46     NOTREACHED;
    47   }
    48   return TRUE;
    49 }
    50 
    51 static Res create(Root *rootReturn, Space space,
    52                   Rank rank, RootVar type,
    53                   union RootUnion theUnion)
    54 {
    55   Root root;
    56   Res res;
    57 
    58   AVER(rootReturn != NULL);
    59   AVERT(Space, space);
    60   AVERT(Rank, rank);
    61 
    62   res = SpaceAlloc((Addr *)&root, space, sizeof(RootStruct));
    63   if(res != ResOK)
    64     return res;
    65 
    66   root->space = space;
    67   root->rank = rank;
    68   root->var = type;
    69   root->the  = theUnion;
    70   root->grey = TraceSetEMPTY;
    71 
    72   RingInit(&root->spaceRing);
    73 
    74   root->sig = RootSig;
    75   root->serial = space->rootSerial;
    76   ++space->rootSerial;
    77 
    78   AVERT(Root, root);
    79 
    80   RingAppend(SpaceRootRing(space), &root->spaceRing);
    81 
    82   *rootReturn = root;
    83   return ResOK;
    84 }
    85 
    86 Res RootCreateTable(Root *rootReturn, Space space,
    87                       Rank rank, Addr *base, Addr *limit)
    88 {
    89   union RootUnion theUnion;
    90 
    91   AVER(base != 0);
    92   AVER(base < limit);
    93 
    94   theUnion.table.base = base;
    95   theUnion.table.limit = limit;
    96 
    97   return create(rootReturn, space, rank, RootTABLE, theUnion);
    98 }
    99 
   100 Res RootCreateReg(Root *rootReturn, Space space,
   101                     Rank rank, Thread thread,
   102                     RootScanRegMethod scan, void *p)
   103 {
   104   union RootUnion theUnion;
   105 
   106   AVER(scan != NULL);
   107   AVERT(Thread, thread);
   108 
   109   theUnion.reg.scan = scan;
   110   theUnion.reg.thread = thread;
   111   theUnion.reg.p = p;
   112 
   113   return create(rootReturn, space, rank, RootREG, theUnion);
   114 }
   115 
   116 Res RootCreateFmt(Root *rootReturn, Space space,
   117                   Rank rank, FormatScanMethod scan,
   118                   Addr base, Addr limit)
   119 {
   120   union RootUnion theUnion;
   121 
   122   AVER(scan != NULL);
   123   AVER(base != 0);
   124   AVER(base < limit);
   125 
   126   theUnion.fmt.scan = scan;
   127   theUnion.fmt.base = base;
   128   theUnion.fmt.limit = limit;
   129 
   130   return create(rootReturn, space, rank, RootFMT, theUnion);
   131 }
   132 
   133 Res RootCreate(Root *rootReturn, Space space,
   134                  Rank rank,
   135                  RootScanMethod scan,
   136                  void *p, size_t s)
   137 {
   138   union RootUnion theUnion;
   139 
   140   AVER(scan != NULL);
   141 
   142   theUnion.fun.scan = scan;
   143   theUnion.fun.p = p;
   144   theUnion.fun.s = s;
   145 
   146   return create(rootReturn, space, rank, RootFUN, theUnion);
   147 }
   148 
   149 void RootDestroy(Root root)
   150 {
   151   Space space;
   152 
   153   AVERT(Root, root);
   154 
   155   space = RootSpace(root);
   156 
   157   AVERT(Space, space);
   158 
   159   RingRemove(&root->spaceRing);
   160   RingFinish(&root->spaceRing);
   161 
   162   root->sig = SigInvalid;
   163 
   164   SpaceFree(space, (Addr)root, sizeof(RootStruct));
   165 }
   166 
   167 Rank RootRank(Root root)
   168 {
   169   AVERT(Root, root);
   170   return root->rank;
   171 }
   172 
   173 void RootGrey(Root root, Space space, TraceId ti)
   174 {
   175   AVERT(Root, root);
   176   root->grey = TraceSetAdd(root->grey, ti);
   177 }
   178 
   179 Res RootScan(ScanState ss, Root root)
   180 {
   181   Res res;
   182 
   183   AVERT(Root, root);
   184   AVERT(ScanState, ss);
   185   AVER(root->rank == ss->rank);
   186 
   187   if(!TraceSetIsMember(root->grey, ss->traceId))
   188     return ResOK;
   189 
   190   switch(root->var) {
   191     case RootTABLE:
   192     TraceScanArea(ss,
   193       (Addr *)root->the.table.base,
   194       (Addr *)root->the.table.limit);
   195     break;
   196 
   197     case RootFUN:
   198     res = (*root->the.fun.scan)(ss, root->the.fun.p, root->the.fun.s);
   199     if(res != ResOK)
   200       return res;
   201     break;
   202 
   203     case RootREG:
   204     res = (*root->the.reg.scan)(ss, root->the.reg.thread,
   205                               root->the.reg.p);
   206     if(res != ResOK)
   207       return res;
   208     break;
   209 
   210     case RootFMT:
   211     res = (*root->the.fmt.scan)(ss, root->the.fmt.base,
   212                               root->the.fmt.limit);
   213     if(res != ResOK)
   214       return res;
   215     break;
   216 
   217     default:
   218     NOTREACHED;
   219   }
   220 
   221   root->grey = TraceSetDelete(root->grey, ss->traceId);
   222 
   223   return ResOK;
   224 }
   225 
   226 /* Must be thread-safe.  See impl.c.mpsi.thread-safety. */
   227 Space RootSpace(Root root)
   228 {
   229   return root->space;
   230 }
   231 
   232 Res RootDescribe(Root root, mps_lib_FILE *stream)
   233 {
   234   Res res;
   235 
   236   AVERT(Root, root);
   237   AVER(stream != NULL);
   238 
   239   res = WriteF(stream,
   240                "Root $P ($U) {\n", (void *)root, (unsigned 
long)root->serial,
   241                "  space $P ($U)\n", (void *)root->space, (unsigned 
long)root->space->serial,
   242                "  rank $U\n", (unsigned long)root->rank,
   243                "  grey $B\n", (unsigned long)root->grey,
   244                NULL);
   245   if(res != ResOK) return res;
   246 
   247   switch(root->var)
   248   {
   249     case RootTABLE:
   250     res = WriteF(stream,
   251                  "  table base $P limit $P\n",
   252                  (void *)root->the.table.base,
   253                  (void *)root->the.table.limit,
   254                  NULL);
   255     if(res != ResOK) return res;
   256     break;
   257 
   258     case RootFUN:
   259     res = WriteF(stream,
   260                  "  scan function $P\n", (void *)root->the.fun.scan,
   261                  "  environment p $P s $W\n",
   262                  root->the.fun.p, (Word)root->the.fun.s,
   263                  NULL);
   264     if(res != ResOK) return res;
   265     break;
   266 
   267     default:
   268     NOTREACHED;
   269   }
   270 
   271   res = WriteF(stream,
   272                "} Root $P ($U)\n", (void*)root, (unsigned 
long)root->serial,
   273                NULL);
   274   if(res != ResOK) return res;
   275 
   276   return ResOK;
   277 }

