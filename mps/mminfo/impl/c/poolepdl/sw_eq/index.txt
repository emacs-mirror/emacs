                ELECTRONIC PUBLISHING DISPLAY LIST POOL
                         impl.c.poolepdl.sw_eq
                               draft doc
                           gavinm 1997-03-12

     1 /* impl.c.poolepdl: ELECTRONIC PUBLISHING DISPLAY LIST POOL
     2  * 
     3  * Copyright (C) 1997 Harlequin Group Limited, all rights reserved
     4  * $HopeName: MMsrc!poolepdl.c(MMdevel_sw_eq.2) $
     5  *
     6  * .purpose: This is a pool class for EPcore display lists. See
     7  * req.epcore.fun.dl.*. It is implemented in response to
     8  * request.epcore.170193, which arose because the existing PoolMV had
     9  * bad fragmentation behaviour when used for display lists.
    10  * 
    11  * .status: This is an interim solution; long-term solutions might
    12  * include refining PoolMV to have less fragmentation.
    13  * 
    14  * .readership: MM developers
    15  * 
    16  * .design: design.mps.poolepdl
    17  * 
    18  * .req: requirements are inherited from req.epcore, especially
    19  * req.epcore.attr.footprint.
    20  * 
    21  * .req.frag: Have less fragmentation than PoolMV, in the presence of
    22  * shrinking objects. See also request.epcore.170193).
    23  * 
    24  * .depend: We depend on SegNext working in address order. See
    25  * design.mps.poolepdl.
    26  */
    27 
    28 #include "mpm.h"
    29 #include "poolepdl.h"
    30 #include "mpscepdl.h"
    31 
    32 SRCID(poolepdl, "$HopeName: MMsrc!poolepdl.c(MMdevel_sw_eq.2) $");
    33 
    34 /* EPDLBlockStruct -- block structure
    35  *
    36  * The pool maintains a descriptor structure for each contiguous free
    37  * block of memory it manages. The descriptor is on a simple
    38  * linked-list of such descriptors (the free list), which is in
    39  * ascending order of address. See design.mps.poolepdl
    40  */
    41 
    42 typedef struct EPDLBlockStruct *EPDLBlock;
    43 typedef struct EPDLBlockStruct {
    44   EPDLBlock next;
    45   Addr base, limit;
    46   Size size;
    47 } EPDLBlockStruct;
    48 
    49 
    50 /* EPDLStruct -- EPDL (EP Display List) pool outer structure
    51  *
    52  * .EPDL: See design.mps.poolepdl
    53  *
    54  * The signature is placed at the end, see
    55  * design.mps.pool.outer-structure.sig
    56  */
    57 
    58 #define EPDLSig           ((Sig)0x519EBd11)
    59 
    60 typedef struct EPDLStruct *EPDL;
    61 typedef struct EPDLStruct {     /* EPDL pool outer structure */
    62   PoolStruct poolStruct;        /* generic structure */
    63   Pool blockPool;               /* for managing block descriptors */
    64   SegPref segPref;              /* the preferences for segments */
    65   Size extendBy;                /* segment size to extend pool by */
    66   Size avgSize;                 /* client estimate of allocation size */
    67   Size total;                   /* total bytes in pool */
    68   Size free;                    /* total free bytes in pool */
    69   Size lost;                    /* total lost bytes in pool */
    70   Size length;                  /* length of free list */
    71   EPDLBlock freeList;           /* head of free list */
    72   Sig sig;                      /* design.mps.sig */
    73 } EPDLStruct;
    74 
    75 #define PoolPoolEPDL(pool)   PARENT(EPDLStruct, poolStruct, pool)
    76 #define EPDLPool(EPDL)       (&((EPDL)->poolStruct))
    77 
    78 static Bool EPDLCheck(EPDL EPDL);
    79 
    80 /* EPDLBlockCheck -- check the consistency of a block structure */
    81 
    82 static Bool EPDLBlockCheck(EPDLBlock block)
    83 {
    84   AVER(block != NULL);
    85   AVER(block->size > 0);
    86   AVER(block->limit == AddrAdd(block->base, block->size));
    87   /* There are other possible checks, e.g. checking that the block is in 
a
    88    * block pool, but they are all hard. */
    89   return TRUE;
    90 }
    91 
    92 /* EPDLNewBlock(&b,epdl,base,limit,size) makes b a new free block
    93  * (with contents base, limit, size) and increments epdl->length. If
    94  * the block allocation fails, it adds size to epdl->lost. */
    95 
    96 static Res EPDLNewBlock(EPDLBlock *pReturn, EPDL EPDL,
    97                         Addr base, Addr limit, Size size)
    98 {
    99   Res res;
   100   Addr new;
   101   EPDLBlock block;
   102 
   103   AVERT(EPDL, EPDL);
   104   AVER(AddrAdd(base, size) == limit);
   105 
   106   res = PoolAlloc(&new, EPDL->blockPool, sizeof(EPDLBlockStruct));
   107   if (res != ResOK) {
   108     EPDL->lost += size;
   109     return res;
   110   }
   111 
   112   ++ EPDL->length;
   113   block = (EPDLBlock)new;
   114   block->base = base;
   115   block->limit = limit;
   116   block->size = size;
   117  
   118   AVERT(EPDLBlock, block);
   119 
   120   *pReturn = block;
   121   return ResOK;
   122 }
   123 
   124 /* EPDLRemoveAreaFromFreeList(epdl,block,base,limit) removes the area
   125  * [base, limit) from block, which must be on the free list for epdl.
   126  * 
   127  * It's called when one or more segments in the block have been returned
   128  * to the arena; the free list must be fixed up so that the memory in
   129  * those segments will not then be allocated (i.e. no longer appears
   130  * to belong to this pool).
   131  */
   132 
   133 static void EPDLRemoveAreaFromFreeList(EPDL EPDL, EPDLBlock block, Addr 
base,
   134                                       Addr limit)
   135 {
   136   Size size;
   137   EPDLBlock *blockPtr;
   138 
   139   AVERT(EPDL, EPDL);
   140   AVERT(EPDLBlock, block);
   141   AVER(limit > base);
   142   AVER(base >= block->base);
   143   AVER(limit <= block->limit);
   144 
   145   size = AddrOffset(base, limit);
   146   EPDL->free -= size;
   147   EPDL->total -= size;
   148 
   149   /* find the pointer to this block, in case we have to remove or split 
it */
   150   blockPtr = &EPDL->freeList;
   151   while(*blockPtr != block)
   152     blockPtr = &((*blockPtr)->next);
   153 
   154   if (base == block->base) {
   155     if (limit == block->limit) { /* remove whole block */
   156       *blockPtr = block->next;
   157       PoolFree(EPDL->blockPool, (Addr)block, sizeof(EPDLBlockStruct));
   158       -- EPDL->length;
   159     } else { /* truncate head of block */
   160       block->base = limit;
   161       block->size = AddrOffset(limit, block->limit);
   162     }
   163   } else {
   164     if (limit != block->limit) { /* split the block */
   165       EPDLBlock new;
   166       Res res = EPDLNewBlock(&new, EPDL, limit, block->limit,
   167                              AddrOffset(limit, block->limit));
   168       if (res == ResOK) {
   169         new->next = block->next;
   170         block->next = new;
   171       }
   172     }
   173     /* truncate tail of block */
   174     block->limit = base;
   175     block->size = AddrOffset(block->base, base);
   176   }
   177 }
   178 
   179 /* EPDLBlockFreeSegs(epdl, block) frees any segments which lie wholly
   180  * within the block, and corrects the block accordingly (by calling
   181  * EPDLRemoveAreaFromFreeList()). When freeing an object, this
   182  * function is applied to the resulting block. The purpose is to
   183  * return unused segments to the arena. */
   184 
   185 static void EPDLBlockFreeSegs(EPDL EPDL, EPDLBlock block)
   186 {
   187   Seg seg;
   188   Space space;
   189   Bool b;
   190   Pool pool;
   191   Addr segLimit, freeBase, freeLimit;
   192 
   193   AVERT(EPDL, EPDL);
   194   AVERT(EPDLBlock, block);
   195 
   196   pool = EPDLPool(EPDL);
   197   space = PoolSpace(pool);
   198   b = SegOfAddr(&seg, space, block->base);
   199   AVER(b);
   200 
   201   segLimit = SegLimit(space, seg);
   202   if (segLimit > block->limit) /* then there are no segs to free */
   203     return;
   204 
   205   freeBase = SegBase(space, seg);
   206   if (freeBase < block->base) { /* then we can't free this first seg */
   207     if (segLimit == block->limit) /* no segs to free */
   208       return;
   209     seg = SegNext(space, seg); /* move on to the next seg */
   210     segLimit = SegLimit(space, seg);
   211     freeBase = SegBase(space, seg);
   212   }
   213 
   214   AVER(seg->pool == pool);
   215 
   216   if (block->limit >= segLimit) { /* then we have some segs to free */
   217     while(block->limit > segLimit) { /* free a seg and move on */
   218       Seg segNext = SegNext(space, seg);
   219       AVER(segNext->pool == pool);
   220       PoolSegFree(pool, seg);
   221       freeLimit = segLimit;
   222       seg = segNext;
   223       segLimit = SegLimit(space, seg);
   224     }
   225     if (block->limit == segLimit) { /* then free the last seg */
   226       PoolSegFree(pool, seg);
   227       freeLimit = segLimit;
   228     }
   229     
   230     EPDLRemoveAreaFromFreeList(EPDL, block, freeBase, freeLimit);
   231   }
   232 }
   233 
   234 /* EPDLAddToFreeList(&p,epdl,base,limit) adds the memory [base, limit)
   235  * to epdl's free list, and returns in p a pointer to the block of
   236  * which this memory now forms a part. It can fail if it is unable to
   237  * allocate a new block descriptor. This is done when freeing an
   238  * object or when adding a new segment to the pool. */
   239 
   240 static Res EPDLAddToFreeList(EPDLBlock *pReturn, EPDL EPDL,
   241                              Addr base, Addr limit)
   242 {
   243   Res res;
   244   EPDLBlock prev, next, block;
   245   Size size;
   246 
   247   AVERT(EPDL, EPDL);
   248   AVER(base <= limit);
   249   AVER(pReturn != NULL);
   250 
   251   size = AddrOffset(base, limit);
   252 
   253   next = EPDL->freeList;
   254   
   255   if ((next != NULL) && (next->limit <= base)) {
   256     /* this is not the first block */
   257     do { /* find blocks immediately before and after */
   258       prev = next;
   259       next = prev->next;
   260     } while((next != NULL) && (next->limit <= base));
   261     
   262     AVER(base >= prev->limit);
   263     
   264     if ((next != NULL) && (limit == next->base)) { /* merge with next */
   265       next->base = base;
   266       next->size += size;
   267       block = next;
   268       if (next->base == prev->limit) {
   269         prev->limit = next->limit;
   270         prev->size += next->size;
   271         block = prev;
   272         PoolFree(EPDL->blockPool, (Addr)next, sizeof(EPDLBlockStruct));
   273         -- EPDL->length;
   274       }
   275     } else if (base == prev->limit) { /* merge with previous */
   276       prev->size += size;
   277       prev->limit = limit;
   278       block = prev;
   279     } else { /* no merges; independent block */
   280       res = EPDLNewBlock(&block, EPDL, base, limit, size);
   281       if (res != ResOK)
   282         return res;
   283       block->next = next;
   284       prev->next = block;
   285     }
   286   } else { /* this comes before the first free block */
   287     if (next && (limit == next->base)) {
   288       next->base = base;
   289       next->size += size;
   290       block = next;
   291     } else { /* no merge; independent block at head of list */
   292       res = EPDLNewBlock(&block, EPDL, base, limit, size);
   293       if (res != ResOK)
   294         return res;
   295       EPDL->freeList = block;
   296       block->next = next;
   297     }
   298   }
   299   EPDL->free += size;
   300   *pReturn = block;
   301   return ResOK;
   302 }
   303 
   304 /* EPDLAddSeg(epdl, size) gets a new segment from the arena, large
   305  * enough for an object of size 'size', and adds it to the pool by
   306  * calling EPDLAddToFreeList(). */
   307 
   308 static Res EPDLAddSeg(EPDL EPDL, Size size)
   309 {
   310   Pool pool;
   311   Space space;
   312   Size segSize;
   313   Seg seg;
   314   Res res;
   315   EPDLBlock block;
   316   Align align;
   317 
   318   AVERT(EPDL, EPDL);
   319   AVER(size > 0);
   320 
   321   pool = EPDLPool(EPDL);
   322   space = PoolSpace(pool);
   323   align = ArenaAlign(space);
   324 
   325   AVER(SizeIsAligned(size, pool->alignment));
   326 
   327   if(size <= EPDL->extendBy)
   328     segSize = EPDL->extendBy;
   329   else
   330     segSize = size;
   331 
   332   segSize = SizeAlignUp(segSize, align);
   333 
   334   res = PoolSegAlloc(&seg, EPDL->segPref, pool, segSize);
   335   if(res != ResOK) { /* try again for a seg just large enough for object 
*/
   336     segSize = SizeAlignUp(size, align);
   337     res = PoolSegAlloc(&seg, EPDL->segPref, pool, segSize);
   338     if (res != ResOK)
   339       return res;
   340   }
   341   EPDL->total += segSize;
   342 
   343   seg->p = (void*)0;
   344 
   345   res = EPDLAddToFreeList(&block,
   346                           EPDL, SegBase(space, seg), 
SegLimit(space,seg));
   347   /* discard block */
   348   return res;
   349 }
   350 
   351 /*  == Allocate ==  */
   352 
   353 static Res EPDLAlloc(Addr *pReturn, Pool pool, Size size)
   354 {
   355   Res res;
   356   EPDL EPDL;
   357   Addr new;
   358   EPDLBlock block;
   359   EPDLBlock *blockPtr;
   360 
   361   AVERT(Pool, pool);
   362   EPDL = PoolPoolEPDL(pool);
   363   AVERT(EPDL, EPDL);
   364 
   365   AVER(pReturn != NULL);
   366   AVER(size > 0);
   367 
   368   size = SizeAlignUp(size, pool->alignment);
   369 
   370   do {
   371     if(size <= EPDL->free) {
   372       block = EPDL->freeList;
   373       blockPtr = &EPDL->freeList;
   374       while(block) { /* look for a fit */
   375         if (size <= block->size) { /* fit */
   376           new = block->base;
   377           block->base = AddrAdd(block->base, size);
   378           block->size -= size;
   379           if (block->size == 0) { /* perfect fit; remove the block */
   380             *blockPtr = block->next;
   381             PoolFree(EPDL->blockPool, (Addr)block,
   382                      sizeof(EPDLBlockStruct));
   383             -- EPDL->length;
   384           }
   385           AVER(AddrIsAligned(new, pool->alignment));
   386           *pReturn = new;
   387           EPDL->free -= size;
   388           return ResOK;
   389         } else {
   390           blockPtr = &block->next;
   391           block = block->next;
   392         }
   393       }
   394     }
   395     /* no fit found; make a new segment and try again */
   396     res = EPDLAddSeg(EPDL, size);
   397   } while (res == ResOK);
   398   return res;
   399 }
   400 
   401 /* == Freeing == */
   402 
   403 static void EPDLFree(Pool pool, Addr old, Size size)
   404 {
   405   Addr base, limit;
   406   EPDL EPDL;
   407   EPDLBlock block;
   408   Res res;
   409 
   410   AVERT(Pool, pool);
   411   EPDL = PoolPoolEPDL(pool);
   412   AVERT(EPDL, EPDL);
   413 
   414   AVER(old != (Addr)0);
   415   AVER(size > 0);
   416 
   417   size = SizeAlignUp(size, pool->alignment);
   418   base = old;
   419   limit = AddrAdd(base, size);
   420 
   421   res = EPDLAddToFreeList(&block, EPDL, base, limit);
   422   if (res != ResOK)
   423     return;
   424   EPDLBlockFreeSegs(EPDL, block); /* free segments eagerly */
   425 }
   426 
   427 /* == Initialize == */
   428 
   429 static Res EPDLInit(Pool pool, va_list arg)
   430 {
   431   Size extendBy, avgSize, blockExtendBy;
   432   EPDL EPDL;
   433   Space space;
   434   Res res;
   435   void *p;
   436 
   437   extendBy = va_arg(arg, Size);
   438   avgSize = va_arg(arg, Size);
   439 
   440   AVER(extendBy > 0);
   441   AVER(avgSize > 0);
   442   AVER(avgSize <= extendBy);
   443 
   444   EPDL = PoolPoolEPDL(pool);
   445   space = PoolSpace(pool);
   446 
   447   EPDL->extendBy = extendBy;
   448   EPDL->avgSize = avgSize;
   449 
   450   blockExtendBy = sizeof(EPDLBlockStruct) * (extendBy/avgSize)/2;
   451 
   452   res = PoolCreate(&EPDL->blockPool, 
   453                  PoolClassMFS(), space,
   454                  blockExtendBy, sizeof(EPDLBlockStruct));
   455   if(res != ResOK)
   456     return res;
   457 
   458   /* EPDL pools are always in low memory */
   459   res = SpaceAlloc(&p, space, sizeof(SegPrefStruct));
   460   if (res != ResOK) {
   461     PoolDestroy(EPDL->blockPool);
   462     return res;
   463   }
   464   
   465   EPDL->segPref = (SegPref)p;
   466   *EPDL->segPref = *SegPrefDefault();   /* copy in the default 
preference */
   467   SegPrefExpress(EPDL->segPref, SegPrefLow, NULL);
   468 
   469   EPDL->total = 0;
   470   EPDL->free = 0;
   471   EPDL->lost = 0;
   472   EPDL->length = 0;
   473   EPDL->freeList = NULL;
   474 
   475   EPDL->sig = EPDLSig;
   476 
   477   AVERT(EPDL, EPDL);
   478 
   479   return ResOK;
   480 }
   481 
   482 static void EPDLFinish(Pool pool)
   483 {
   484   EPDL EPDL;
   485   Space space;
   486   Seg seg;
   487 
   488   AVERT(Pool, pool);
   489   EPDL = PoolPoolEPDL(pool);
   490   AVERT(EPDL, EPDL);
   491 
   492   space = PoolSpace(pool);
   493 
   494   seg = SegFirst(space);
   495   while(seg != NULL) {
   496     if (seg->pool == pool)
   497       PoolSegFree(pool, seg);
   498     seg = SegNext(space, seg);
   499   }
   500 
   501   SpaceFree(space, (void*)EPDL->segPref, sizeof(SegPrefStruct));
   502   PoolDestroy(EPDL->blockPool);
   503 
   504   EPDL->sig = SigInvalid;
   505 }
   506 
   507 static Res EPDLDescribe(Pool pool, mps_lib_FILE *stream)
   508 {
   509   Res res;
   510   EPDL EPDL;
   511 
   512   AVERT(Pool, pool);
   513   EPDL = PoolPoolEPDL(pool);
   514   AVERT(EPDL, EPDL);
   515 
   516   AVER(stream != NULL);
   517 
   518   res = WriteF(stream,
   519                "  blockPool $P ($U)\n",
   520                (WriteFP)EPDL->blockPool, 
(WriteFU)EPDL->blockPool->serial,
   521                "  extendBy  $W\n",  (WriteFW)EPDL->extendBy,
   522                "  avgSize   $W\n",  (WriteFW)EPDL->avgSize,
   523                "  total     $U\n",  (WriteFU)EPDL->total,
   524                "  free      $U\n",  (WriteFU)EPDL->free,
   525                "  lost      $U\n",  (WriteFU)EPDL->lost,
   526                "  length    $U\n",  (WriteFU)EPDL->length,
   527                NULL);
   528   return res;               
   529 }
   530 
   531 
   532 static PoolClassStruct PoolClassEPDLStruct = {
   533   PoolClassSig,
   534   "EPDL",                                 /* name */
   535   sizeof(EPDLStruct),                     /* size */
   536   offsetof(EPDLStruct, poolStruct),       /* offset */
   537   AttrALLOC | AttrFREE,                   /* attr */
   538   EPDLInit,                               /* init */
   539   EPDLFinish,                             /* finish */
   540   EPDLAlloc,                              /* alloc */
   541   EPDLFree,                               /* free */
   542   PoolNoBufferInit,                       /* bufferInit */
   543   PoolNoBufferFinish,                     /* bufferFinish */
   544   PoolNoBufferFill,                       /* bufferFill */
   545   PoolNoBufferTrip,                       /* bufferTrip */
   546   PoolNoBufferExpose,                     /* bufferExpose */
   547   PoolNoBufferCover,                      /* bufferCover */
   548   PoolNoCondemn,                          /* condemn */
   549   PoolNoGrey,                             /* mark */
   550   PoolNoScan,                             /* scan */
   551   PoolNoFix,                              /* fix */
   552   PoolNoReclaim,                          /* relcaim */
   553   PoolNoAccess,                           /* access */
   554   EPDLDescribe,                           /* describe */
   555   PoolClassSig                            /* impl.h.mpmst.class.end-sig 
*/
   556 };
   557 
   558 PoolClass PoolClassEPDL(void)
   559 {
   560   return &PoolClassEPDLStruct;
   561 }
   562 
   563 
   564 /* MPS Interface Extensions. These should really call SpaceEnter and
   565    SpaceLeave, but see design.mps.poolepdl.issue.space-enter. */
   566 
   567 mps_class_t mps_class_epdl(void)
   568 {
   569   return (mps_class_t)(PoolClassEPDL());
   570 }
   571 
   572 /* Free bytes */
   573 
   574 size_t mps_epdl_free_size(mps_pool_t mps_pool)
   575 {
   576   Pool pool;
   577   EPDL EPDL;
   578 
   579   pool = (Pool)mps_pool;
   580 
   581   AVERT(Pool, pool);
   582   EPDL = PoolPoolEPDL(pool);
   583   AVERT(EPDL, EPDL);
   584   
   585   return (size_t)EPDL->free;
   586 }
   587 
   588 /* Total owned bytes */
   589 
   590 size_t mps_epdl_size(mps_pool_t mps_pool)
   591 {
   592   Pool pool;
   593   EPDL EPDL;
   594 
   595   pool = (Pool)mps_pool;
   596 
   597   AVERT(Pool, pool);
   598   EPDL = PoolPoolEPDL(pool);
   599   AVERT(EPDL, EPDL);
   600 
   601   return (size_t)EPDL->total;
   602 } 
   603 
   604 /* EPDLCheck -- check the consistency of an EPDL structure */
   605 
   606 static Bool EPDLCheck(EPDL EPDL)
   607 {
   608   CHECKS(EPDL, EPDL);
   609   CHECKD(Pool, &EPDL->poolStruct);
   610   CHECKL(EPDL->poolStruct.class == &PoolClassEPDLStruct);
   611   CHECKD(Pool, EPDL->blockPool);
   612   CHECKD(SegPref, EPDL->segPref);
   613   CHECKL(EPDL->extendBy > 0);
   614   CHECKL(EPDL->avgSize > 0);
   615   CHECKL(EPDL->avgSize <= EPDL->extendBy);
   616   CHECKL(EPDL->total >= EPDL->free + EPDL->lost);
   617   CHECKL(SizeIsAligned(EPDL->free, EPDLPool(EPDL)->alignment)); 
   618   CHECKL(SizeIsAligned(EPDL->lost, EPDLPool(EPDL)->alignment));
   619   CHECKL(SizeIsAligned(EPDL->total, ArenaAlign(EPDLPool(EPDL)->space)));
   620   /* free list is empty if and only if it has zero length */
   621   CHECKL((EPDL->length == 0) == (EPDL->freeList == NULL));
   622   /* free list is empty if and only if there is no free space */
   623   CHECKL((EPDL->length == 0) == (EPDL->free == 0));
   624   /* everything on the free list is at least 'alignment' in size */
   625   CHECKL(EPDL->length * EPDLPool(EPDL)->alignment <= EPDL->free);
   626   /* check the first thing on the free list */
   627   CHECKL(EPDL->freeList == NULL || EPDLBlockCheck(EPDL->freeList));
   628   return TRUE;
   629 }

