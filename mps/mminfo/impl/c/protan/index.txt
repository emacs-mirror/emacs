                         ANSI MEMORY PROTECTION
                             impl.c.protan
                               draft impl
                           gavinm 1996-09-24

     1 /* impl.c.protan: ANSI MEMORY PROTECTION
     2  *
     3  * $HopeName: MMsrc!protan.c(trunk.3) $
     4  * Copyright (C) 1996,1997 Harlequin Group, all rights reserved.
     5  *
     6  * READERSHIP
     7  *
     8  * .readership: Any MPS developer
     9  *
    10  * DESIGN
    11  *
    12  * design.mps.protan
    13  *
    14  */
    15 
    16 #include "mpm.h"
    17 
    18 SRCID(protan, "$HopeName: MMsrc!protan.c(trunk.3) $");
    19 
    20 void ProtSetup(void)
    21 {
    22   NOOP;
    23 }
    24 
    25 void ProtSet(Addr base, Addr limit, AccessSet pm)
    26 {
    27   AVER(base < limit);
    28   /* .improve.protset.check: There is nor AccessSetCheck, so we */
    29   /* don't check it. */
    30   UNUSED(pm);
    31   NOOP;
    32 }
    33 
    34 /* design.mps.protan.fun.sync */
    35 void ProtSync(Space space)
    36 {
    37   Bool synced;
    38 
    39   AVERT(Space, space);
    40 
    41   do {
    42     Seg seg;
    43 
    44     synced = TRUE;
    45     seg = SegFirst(space);
    46     while(seg != NULL) {
    47       if(seg->pm != AccessSetEMPTY) {   /* 
design.mps.protan.fun.sync.seg */
    48         ShieldEnter(space);
    49         PoolAccess(seg->pool, seg, seg->pm);
    50         ShieldLeave(space);
    51         synced = FALSE;
    52       }
    53       seg = SegNext(space, seg);
    54     }
    55   } while(!synced);
    56 }
    57 
    58 void ProtTramp(void **rReturn,
    59                 void *(*f)(void *, size_t),
    60                 void *p, size_t s)
    61 {
    62   AVER(rReturn != NULL);
    63   AVER(FUNCHECK(f));
    64   /* Can't check p and s as they are interpreted by the client */
    65 
    66   *(rReturn) = (*(f))(p, s);
    67 }

