                      ALLOCATION BUFFER INTERFACE
                             impl.h.buffer
                               draft impl
                           richard 1995-10-09

/*  impl.h.buffer
 *
 *                     ALLOCATION BUFFER INTERFACE
 *
 *  $HopeName: MMsrc/!buffer.h(trunk.1)$
 *
 *  Copyright (C) 1995 Harlequin Group, all rights reserved
 *
 *  This is the interface to allocation buffers.
 *
 *  An allocation buffer is an interface to a pool which provides
 *  very fast allocation, and defers the need for synchronization in
 *  a multi-threaded environment.
 *
 *  Pools which contain formatted objects must be synchronized so
 *  that the pool can know when an object is valid.  Allocation from
 *  such pools is done in two stages: reserve and commit.  The client
 *  first reserves memory, then initializes it, then commits.
 *  Committing the memory declares that it contains a valid formatted
 *  object.  Under certain conditions, some pools may cause the
 *  commit operation to fail.  (See the documentation for the pool.)
 *  Failure to commit indicates that the whole allocation failed and
 *  must be restarted.  When a pool with commit failure, the
 *  allocation sequence could look something like this:
 *
 *  do {
 *    e = BufferReserve(&p, buffer, size);
 *    if(e != ErrSUCCESS) return e; // allocation fails, reason e
 *    initialize(p);          // p now points at valid object
 *  } while(!BufferCommit(buffer, p, size));
 *
 *  Pools which do not contain formatted objects can use a one-step
 *  allocation as usual.  Effectively any random rubbish counts as a
 *  "valid object" to such pools.
 *
 *  An allocation buffer is an area of memory which is pre-allocated
 *  from a pool, plus a buffer descriptor, which contains, inter
 *  alia, four pointers: base, init, alloc, and limit.  Base points
 *  to the base address of the area, limit to the last address plus
 *  one.  Init points to the first uninitialized address in the
 *  buffer, and alloc points to the first unallocated address.
 *
 *   L . - - - - - .
 *     |           |
 *     |   junk    |
 *     |           |       the "busy" state, after Reserve
 *   A |-----------|
 *     |  uninit   |
 *   I |-----------|
 *     |   init    |
 *     |           |
 *   B `-----------'
 *
 *   L . - - - - - .
 *     |           |
 *     |   junk    |
 *     |           |       the "ready" state, after Commit
 * A=I |-----------|
 *     |           |
 *     |           |
 *     |   init    |
 *     |           |
 *   B `-----------'
 * 
 *  Access to these pointers is restricted in order to allow
 *  synchronization between the pool and the client.  The client may
 *  only write to init and alloc, but in a restricted and atomic way
 *  detailed below.  The pool may read the contents of the buffer
 *  descriptor at _any_ time.  During calls to the fill and trip
 *  methods, the pool may update any or all of the fields
 *  in the buffer descriptor.  The pool may update the limit at _any_
 *  time.
 *
 *  Only one thread may use a buffer at once, unless the client
 *  places a mutual exclusion around the buffer access in the usual
 *  way.  In such cases it is usually better to create one buffer for
 *  each thread.
 *
 *  Here are pseudo-code descriptions of the reserve and commit
 *  operations.  These may be implemented in-line by the client.
 *  Note that the client is responsible for ensuring that the size
 *  (and therefore the alloc and init pointers) are aligned according
 *  to the buffer's alignment.
 *
 *  Reserve(buf, size)    ; size must be aligned to pool
 *    if buf->limit - buf->alloc >= size then
 *      buf->alloc +=size   ; must be atomic update
 *      p = buf->init
 *    else
 *      e = (*buf->fill)(&p, buf, size)  ; buf contents may change
 *
 *  Commit(buf, p, size)
 *    buf->init = buf->alloc   ; must be atomic update
 *    if buf->limit == 0 then
 *      b = (*buf->trip)(buf, p, size)  ; buf contents may change
 */

#ifndef buffer_h
#define buffer_h

typedef struct BufferStruct *Buffer;

#include "std.h"
#include "pool.h"
#include "lib.h"


typedef Error (*BufferFill)(Addr *pReturn, Buffer buffer, Addr size);
typedef Bool (*BufferTrip)(Buffer buffer, Addr p, Addr size);


typedef struct BufferStruct
{
#ifdef DEBUG_SIGN
  Sig sig;
#endif

  Addr base;  /* base address of allocation buffer */
  Addr limit;  /* limit of allocation buffer */
  Addr alloc;  /* limit of allocated area */
  Addr init;  /* limit of initialized area */

  Addr alignment; /* allocation alignment */

  DequeNodeStruct poolDeque; /* buffers are attached to pools */

  BufferFill fill; /* call when buffer can't accommodate request */
  BufferTrip trip; /* call when pool set limit to zero */
  void *p; int i; /* closure variables */
} BufferStruct;


/*  == Create Buffer Descriptor ==
 *
 *  BufferCreate requests an allocation buffer from a pool.  Iff successful,
 *  *bufferReturn is updated with a pointer to the buffer descriptor, and
 *  ErrSUCCESS is returned.
 */

extern Error BufferCreate(Buffer *bufferReturn, Pool pool);


/*  == Destroy Buffer Descriptor ==
 *
 *  Destroy frees a buffer descriptor.  The buffer must be in the "ready" state,
 *  i.e. not between a Reserve and Commit.  Allocation in the area of memory to
 *  which the descriptor refers must cease after Destroy is called.
 */

extern void BufferDestroy(Buffer buffer);

extern Bool BufferIsValid(Buffer buffer, ValidationType validParam);
extern Error BufferDescribe(Buffer buffer, LibStream stream);


/*  == Reserve Memory from Buffer ==
 *
 *  This is a provided version of the reserve procedure described above.
 *
 *  Attempt to reserve size bytes from an allocation buffer.  The size must be
 *  aligned according to the buffer alignment modulus.  Iff successful,
 *  ErrSUCCESS is returned and *pReturn updated with a pointer to the reserved
 *  memory.  Otherwise *pReturn it not touched.  The reserved memory is not
 *  guaranteed to have any particular contents.  The memory must be initialized
 *  with a valid object (according to the pool to which the buffer belongs) and
 *  then passed to the Commit method (see below).
 *
 *  Reserve may not be applied twice to a buffer without a commit in-between.
 *  In other words, Reserve/Commit pairs do not nest.
 */

extern Error BufferReserve(Addr *pReturn, Buffer buffer, Addr size);


/*  == Commit Memory previously Reserved ==
 *
 *  Commit notifies the pool that memory which has been previously reserved
 *  (see above) has been initialized with a valid object (according to the pool
 *  to which the buffer belongs).  The pointer p must be the same as that
 *  returned by Reserve, and the size must match the size passed to Reserve.
 *
 *  Commit may not be applied twice to a buffer without a reserve in-between.
 *  In other words, objects must be reserved, initialized, then committed only
 *  once.
 *
 *  Commit returns TRUE iff successful.  If commit fails and returns FALSE,
 *  the client may try to allocate again by going back to the reserve stage,
 *  and may not use the memory at p again for any purpose.
 *  Some classes of pool may cause commit to fail under rare circumstances.
 */

extern Bool BufferCommit(Buffer buffer, Addr p, Addr size);



/*  == Initialize/Finish a Buffer Descriptor ==
 *
 *  Init is used by pool classes to initialize a buffer descriptor
 *  before it is passed to the client.  The descriptor is initialized with
 *  the fill and trip methods, and is attached to the pool buffer
 *  deque.  The base, init, alloc, and limit fields are set to zero, so that
 *  the fill method will get called the first time a reserve operation
 *  is attempted.
 */

extern void BufferInit(Buffer buffer, Pool pool,
                       BufferFill fill, BufferTrip trip);
extern void BufferFinish(Buffer buffer);


/*  == Set/Reset a Buffer ==
 *
 *  Set sets the buffer base, init, alloc, and limit fields so that the
 *  buffer is ready to start allocating in area of memory.  The alloc
 *  field is a copy of the init field.
 *
 *  Reset sets the buffer base, init, alloc, and limit fields to zero, so
 *  that the next reserve request will call the fill method.
 *
 *  BufferIsReset returns TRUE iff the buffer is in the reset state, i.e.
 *  with base, init, alloc, and limit set to zero.
 */

extern void BufferSet(Buffer buffer, Addr base, Addr init, Addr limit);
extern void BufferReset(Buffer buffer);
extern Bool BufferIsReset(Buffer buffer);


/*  == Buffer Information ==
 *
 *  BufferPoolDeque is a convenience function for accessing the deque node
 *  which attaches a buffer descriptor to a pool.
 *
 *  BufferPool returns the pool to which a buffer is attached.
 *
 *  BufferIsReady returns TRUE iff the buffer is not between a reserve and
 *  commit.  The result is only reliable if the client is not currently
 *  using the buffer, since it may update the alloc and init pointers
 *  asynchronously.
 */

extern DequeNode BufferPoolDeque(Buffer buffer);
extern Pool BufferPool(Buffer buffer);
extern Bool BufferIsReady(Buffer buffer);


#endif /* buffer_h */

