                        VIRTUAL MEMORY INTERFACE
                               impl.h.vm
                               draft impl
                           richard 1995-09-12

/*  impl.h.vm  draft impl
 *
 *                      VIRTUAL MEMORY INTERFACE
 *
 *  $HopeName: MMsrc/!vm.h(trunk.2)$
 *
 *  This is a system-independent interface to virtual memory mapping.
 *
 *  Memory mapping is the operation of manipulating virtual memory
 *  so as to map address ranges onto storage.  Not all systems
 *  provide this ability.  This is a common interface for those
 *  that do.  It provides facilities for reserving ranges of address
 *  space, then mapping subranges onto storage.
 */

#ifndef vm_h
#define vm_h

#include "std.h"


/*  == VM Type ==
 *
 *  The VM type is a handle on a contiguous range of address space.
 */

typedef struct VMStruct *VM;


/*  == VM Granularity ==
 *
 *  VMGrain returns a positive power of two which is the size and alignment
 *  of the address range units which may be mapped or unmapped.
 */

extern Addr VMGrain(void);


/*  == Reserve Address Space ==
 *
 *  VMCreate reserves address space, and creates a VM object used to manage
 *  that space.  The size parameter must be aligned to VMGrain.
 *  On success, *vmReturn is updated to point to the structure
 *  and ErrSUCCESS is returned, otherwise *vmReturn is not touched.
 *
 *  VMDestroy unmaps any memory in the address space and unreserves the
 *  space.  It also destroys the VM object.
 */

extern Error VMCreate(VM *vmReturn, Addr size);
extern void VMDestroy(VM vm);
extern Bool VMIsValid(VM vm, ValidationType validParam);
 

/*  == VM Parameters ==
 *
 *  VMBase returns the base address of the address space managed by
 *  a VM object.  VMLimit returns the limit address (last address plus one).
 *  Both these address will be aligned to the VM granularity (see VMGrain).
 */

extern Addr VMBase(VM vm);
extern Addr VMLimit(VM vm);


/*  == Map and Unmap Memory ==
 *
 *  Map attempts to populate the addresses [base,limit) with store, initially
 *  set to zero.  Base and limit must be aligned to the grain size, with
 *  base < limit.
 *
 *  Unmap removes any mappings that exist in the range [base, limit),
 *  which must be aligned to the grain size with base < limit.
 */

extern Error VMMap(VM vm, Addr base, Addr limit);
extern void VMUnmap(VM vm, Addr base, Addr limit);


#endif /* vm_h */

