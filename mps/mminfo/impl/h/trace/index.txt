                        GENERIC TRACE INTERFACE
                              impl.h.trace
                               draft impl
                             drj 1995-10-26

     1 /*  impl.h.trace
     2  *
     3  *                  GENERIC TRACER INTERFACE
     4  *
     5  *  $HopeName$
     6  *
     7  *  Copyright (C) 1995 Harlequin Group, all rights reserved
     8  */
     9 
    10 #ifndef trace_h
    11 #define trace_h
    12 
    13 typedef struct TraceStruct *Trace;
    14 typedef size_t TraceId;
    15 typedef struct TraceSetStruct *TraceSet;
    16 
    17 #include "std.h"
    18 #include "lib.h"
    19 #include "mpmconf.h"
    20 #include "pool.h"
    21 #include "root.h"
    22 #include "ref.h"
    23 #include "refsig.h"
    24 #include "tracest.h"
    25 
    26 
    27 /*  == Trace Id ==
    28  *
    29  *  A TraceId is an unsigned integer in the range 0 to TRACE_MAX - 1.
    30  *  The space may only contain one trace with each TraceId at any
    31  *  time, so the TraceId uniquely identifies the trace while it
    32  *  exists.
    33  *
    34  *  Each scannable object must record its scanning state for each
    35  *  possible TraceId.
    36  */
    37 
    38 extern Bool TraceIdIsValid(TraceId id, ValidationType validParam);
    39 
    40 
    41 /*  == Trace Set ==
    42  *
    43  *  A TraceSet is an exact set of TraceIds.  These are the obvious
    44  *  set operations.
    45  */
    46 
    47 extern Error TraceSetInit(TraceSet set);
    48 extern void TraceSetFinish(TraceSet set);
    49 extern Bool TraceSetIsValid(TraceSet set, ValidationType validParam);
    50 extern void TraceSetAdd(TraceSet set, TraceId id);
    51 extern void TraceSetDelete(TraceSet set, TraceId id);
    52 extern Bool TraceSetIsMember(TraceSet set, TraceId id);
    53 
    54 
    55 /*  == Trace Creation ==
    56  *
    57  *  TraceCreate allocates and initializes a new Trace object belonging
    58  *  to a space, with an empty condemned set.  The Trace will have a
    59  *  different TraceId from any other trace which currently exists in
    60  *  the space.
    61  *
    62  *  Iff successful, TraceCreate updates *traceReturn to the new
    63  *  Trace object and returns ErrSUCCESS.  Otherwise *traceReturn is not
    64  *  updated.  In particular, TraceCreate returns ErrLIMIT if there are
    65  *  no available TraceIds in the space.
    66  *
    67  *  TraceDestroy finishes and deallocates a Trace object.  The Trace
    68  *  must have been completed (i.e. all gray sets must be empty).
    69  *
    70  *  TraceInit and TraceFinish initialize and finish a pre-allocated
    71  *  Trace structure, but otherwise behave the same way as TraceCreate
    72  *  and TraceDestroy.
    73  *
    74  *  TraceTraceId returns the TraceId of a Trace object.
    75  */
    76 
    77 extern Error TraceCreate(Trace *traceReturn, Space space);
    78 extern void TraceDestroy(Trace trace);
    79 extern Error TraceInit(Trace trace, Space space);
    80 extern void TraceFinish(Trace trace);
    81 extern Bool TraceIsValid(Trace trace, ValidationType validParam);
    82 extern Error TraceDescribe(Trace trace, LibStream stream);
    83 
    84 extern TraceId TraceTraceId(Trace trace);
    85 
    86 
    87 /*  == Condemned, Marked, and Scanned Sets ==
    88  *
    89  *  A Trace object defines several sets of objects:
    90  *
    91  *    condemned: the condemned set is the set of objects which the
    92  *      collection is trying to kill.  An object in the condemned
    93  *      set which is marked is alive, i.e. condemned and not marked
    94  *      implies that th object is "white".
    95  *
    96  *    marked: the marked set is the set of objects which are known
    97  *      or proved to be alive and must be scanned in order to determine
    98  *      the liveness of the objects in the condemned set.
    99  *
   100  *    scanned: the scanned set is the set of objects in the marked
   101  *      set which have been scanned.  Marked and not scanned implies
   102  *      an object is "gray".  Marked and scanned implies an object is
   103  *      "black".
   104  *
   105  *  Tracing consists of locating an object in the marked set which has
   106  *  not been scanned, and scanning it.  This may introduce new objects
   107  *  into the marked set.  Tracing terminates when the scanned set equals
   108  *  the marked set.  In fact, there is a marked and a scanned set for
   109  *  each reference rank.  An object which is marked but not scanned in
   110  *  rank N must be scanned for rank N references.
   111  *
   112  *  TraceCondemn sets the condemned set for a Trace object.  This is
   113  *  defined by a reference signature which includes all references to
   114  *  the condemned set.
   115  *
   116  *  TraceMark increments the marked set sized count, indicating that
   117  *  there is more scanning to be done.  TraceScan increments the scanned
   118  *  set count, indicating that scanning has been done.  See also 
PoolMark()
   119  *  and RootMark().
   120  *
   121  *  TraceRun scans unscanned marked objects until the scanned and marked
   122  *  sets are equal.
   123  */
   124 
   125 extern void TraceCondemn(Trace trace, RefSig refsig);
   126 extern void TraceMark(Trace trace, RefRank rank, Addr count);
   127 extern void TraceScan(Trace trace, RefRank rank, Addr count);
   128 
   129 extern Error TraceRun(Trace trace);
   130 
   131 
   132 /*  == Generic Fix Method ==
   133  *
   134  *  **** Needs explanation
   135  */
   136 
   137 extern Error TraceFix(Trace trace, RefRank rank, Ref *refIO);
   138 
   139 
   140 #endif /* trace_h */

