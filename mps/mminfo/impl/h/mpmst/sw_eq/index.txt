                  MEMORY POOL MANAGER DATA STRUCTURES
                           impl.h.mpmst.sw_eq
                             incomplete doc
                           gavinm 1996-12-04

     1 /* impl.h.mpmst: MEMORY POOL MANAGER DATA STRUCTURES
     2  *
     3  * $HopeName: MMsrc!mpmst.h(MMdevel_sw_eq.2) $
     4  * Copyright (C) 1996 Harlequin Group, all rights reserved.
     5  *
     6  * .readership: MM developers.
     7  *
     8  * .design: This header file crosses module boundaries.  The relevant 
design
     9  * a module's structures should be found in that module's design 
document.
    10  *
    11  * .requirements: There are none [maybe being easy to experiment is a
    12  * requirement].
    13  *
    14  * .rationale: Almost all MPM data structures are defined in this
    15  * header, or in headers selected from here.  Most structures have
    16  * already been declared as incomplete types in impl.h.mpmtypes.  This
    17  * organization means that there is an easily browsable view of the
    18  * data structures, and that it is easy to experiment.
    19  *
    20  * Most of the structures are the underlying aggregate types for an
    21  * abstract data type.  See
    22  * guide.impl.c.naming.type.adt-aggregate.relate.
    23  *
    24  * .rationale.sig: Object signatures (PoolSig, etc.) are defined
    25  * here, along with the structures, so that any code which can see
    26  * a structure can also check its signature before using any of its
    27  * fields.  See design.mps.sig.test.uniq to check that signatures are
    28  * unique.
    29  *
    30  * TRANSGRESSIONS
    31  *
    32  * .fildes.name: the VMStruct used by impl.c.vmso and impl.c.vmsu has
    33  * two fields whose names violate our naming conventions.  They are
    34  * called none_fd and zero_fd to emphasize the fact that they are file
    35  * descriptors and this fact is not reflected in their type.
    36  */
    37 
    38 #ifndef mpmst_h
    39 #define mpmst_h
    40 
    41 #include "mpmtypes.h"
    42 
    43 #if defined(MPS_OS_W3)
    44 /* windows.h included for CRITICAL_SECTION only, see .lock.win32 */
    45 #include <windows.h>            
    46 #endif /* MPS_OS_w3 */
    47 
    48 
    49 /* RingStruct -- double-ended queue structure
    50  *
    51  * .ring: The ring structure is used as a field in other structures
    52  * in order to link them together into "rings".  See impl.c.ring.
    53  */
    54 
    55 typedef struct RingStruct {     /* double-ended queue structure */
    56   Ring next, prev;              /* links to next and prev element */
    57 } RingStruct;
    58 
    59 
    60 /* PoolClassStruct -- pool class structure
    61  *
    62  * See design.mps.pool.
    63  *
    64  * .class: The pool class structure is defined by each pool class
    65  * implementation in order to provide an interface between the MPM
    66  * and the class (see design.mps.class-interface) via generic
    67  * functions (see impl.c.pool).  A class XXX defines a function
    68  * PoolClassXXX() returning a PoolClass pointing to a PoolClassStruct
    69  * of methods which implement the memory management policy.
    70  *
    71  * .class.end-sig: The class structure has another copy of the
    72  * signature at the end.  This causes the compiler to complain
    73  * if the class structure is extended without modifying static
    74  * initializers.
    75  */
    76 
    77 #define PoolClassSig    ((Sig)0x519C1A55)
    78 
    79 typedef struct PoolClassStruct {
    80   Sig sig;                      /* design.mps.sig */
    81   const char *name;             /* class name string */
    82   size_t size;                  /* size of outer structure */
    83   size_t offset;                /* offset of generic struct in outer 
struct */
    84   Attr attr;                    /* attributes */
    85   PoolInitMethod init;          /* initialize the pool descriptor */
    86   PoolFinishMethod finish;      /* finish the pool descriptor */
    87   PoolAllocMethod alloc;        /* allocate memory from pool */
    88   PoolFreeMethod free;          /* free memory to pool */
    89   PoolBufferInitMethod bufferInit;      /* additional buffer init */
    90   PoolBufferFinishMethod bufferFinish;  /* additional buffer finish */
    91   PoolBufferFillMethod bufferFill;      /* out-of-line reserve */
    92   PoolBufferTripMethod bufferTrip;      /* out-of-line commit */
    93   PoolBufferExposeMethod bufferExpose;  /* remove protection */
    94   PoolBufferCoverMethod bufferCover;    /* reinstate protection */
    95   PoolCondemnMethod condemn;    /* condemn (some or all) objects */
    96   PoolGreyMethod grey;          /* grey uncondemned objects */
    97   PoolScanMethod scan;          /* find references during tracing */
    98   PoolFixMethod fix;            /* referent reachable during tracing */
    99   PoolReclaimMethod reclaim;    /* reclaim dead objects after tracing */
   100   PoolAccessMethod access;      /* handle an access to shielded memory */
   101   PoolDescribeMethod describe;  /* describe the contents of the pool */
   102   Sig endSig;                   /* .class.end-sig */
   103 } PoolClassStruct;
   104 
   105 
   106 /* PoolStruct -- generic structure
   107  *
   108  * .pool: A generic structure is created when a pool is created
   109  * and holds the generic part of the pool's state.  Each pool class
   110  * defines a "subclass" of the pool structure (the "outer structure")
   111  * which contains PoolStruct as a a field.  The outer structure holds
   112  * the class-specific part of the pool's state.  See impl.c.pool,
   113  * design.mps.pool.
   114  */
   115 
   116 #define PoolSig         ((Sig)0x519B0011)
   117 
   118 typedef struct PoolStruct {     /* generic structure */
   119   Sig sig;                      /* design.mps.sig */
   120   Serial serial;                /* from space->poolSerial */
   121   PoolClass class;              /* pool class structure */
   122   Space space;                  /* owning space */
   123   RingStruct spaceRing;         /* link in list of pools in space */
   124   RingStruct bufferRing;        /* allocation buffers are attached to 
pool */
   125   Serial bufferSerial;          /* serial of next buffer */
   126   Align alignment;              /* alignment for units */
   127 } PoolStruct;
   128 
   129 
   130 /* MFSStruct -- MFS (Manual Fixed Small) pool outer structure
   131  *
   132  * .mfs: See impl.c.poolmfs, design.mps.poolmfs.
   133  *
   134  * The MFS outer structure is declared here because it is in-lined
   135  * in the control pool structure which is in-lined in the space.  
Normally,
   136  * pool outer structures are declared with the pools.
   137  *
   138  * The signature is placed at the end, see
   139  * design.mps.pool.outer-structure.sig
   140  */
   141 
   142 #define MFSSig          ((Sig)0x5193F5B1)
   143 
   144 typedef struct MFSStruct {      /* MFS outer structure */
   145   PoolStruct poolStruct;        /* generic structure */
   146   Size unroundedUnitSize;       /* the unit size requested */
   147   Size extendBy;                /* segment size rounded using unitSize */
   148   Size unitSize;                /* rounded for management purposes */
   149   Word unitsPerSeg;             /* number of units per segment */
   150   struct MFSHeaderStruct *freeList; /* head of the free list */
   151   Seg segList;                  /* the first segment */
   152   Sig sig;                      /* design.mps.sig */
   153 } MFSStruct;
   154 
   155 
   156 /* MVStruct -- MV (Manual Variable) pool outer structure
   157  *
   158  * .mv: See impl.c.poolmv, design.mps.poolmv.
   159  *
   160  * The MV pool outer structure is declared here because it is the
   161  * control pool structure which is in-lined in the space.  Normally,
   162  * pool outer structures are declared with the pools.
   163  *
   164  * The signature is placed at the end, see
   165  * design.mps.pool.outer-structure.sig
   166  */
   167 
   168 #define MVSig           ((Sig)0x519E3FEE)
   169 
   170 typedef struct MVStruct {       /* MV pool outer structure */
   171   PoolStruct poolStruct;        /* generic structure */
   172   MFSStruct blockPoolStruct;    /* for managing block descriptors */
   173   MFSStruct spanPoolStruct;     /* for managing span descriptors */
   174   Size extendBy;                /* segment size to extend pool by */
   175   Size avgSize;                 /* client estimate of allocation size */
   176   Size maxSize;                 /* client estimate of maximum size */
   177   Size space;                   /* total free space in pool */
   178   Size lost;                    /* design.mps.poolmv.lost */
   179   RingStruct spans;             /* span chain */
   180   Sig sig;                      /* design.mps.sig */
   181 } MVStruct;
   182 
   183 
   184 /* VMStruct -- virtual memory structure
   185  *
   186  * .vm: The VM structure is used when the MPM is configured to use a
   187  * virtual-memory based arena (impl.c.arenavm) which uses memory mapping
   188  * (impl.h.mpm.vm).  It holds the state information necessary to provide
   189  * that mapping, and as such, is specific to the implementation of that
   190  * vm (which is usually specific to an operating system).
   191  */
   192 
   193 #define VMSig           ((Sig)0x519FEE33)
   194 
   195 #ifdef TARGET_VM_RM
   196 
   197 typedef struct VMStruct {       /* Real Memory fake VM; impl.c.vmrm */
   198   Sig sig;                      /* design.mps.sig */
   199   Align align;                  /* made-up alignment */
   200   Addr base, limit;             /* boundaries of reserved space */
   201   Size reserved;                /* total reserved address space */
   202   Size mapped;                  /* total mapped memory */
   203 } VMStruct;
   204 
   205 #elif defined(MPS_OS_W3)
   206 
   207 typedef struct VMStruct {       /* Win32 VM structure; impl.c.vmnt */
   208   Sig sig;                      /* design.mps.sig */
   209   Align align;                  /* page size */
   210   Addr base, limit;             /* boundaries of reserved space */
   211   Size reserved;                /* total reserved address space */
   212   Size mapped;                  /* total mapped memory */
   213 } VMStruct;
   214 
   215 #elif defined(MPS_OS_O1) || defined(MPS_OS_S7) || defined(MPS_OS_IR)
   216 
   217 /* These platforms use vman, since no platform specific VM */
   218 
   219 /* ANSI fake VM structure, see impl.c.vman, design.mps.vman */
   220 typedef struct VMStruct {
   221   Sig sig;                      /* design.mps.sig */
   222   Addr base, limit;             /* boundaries of malloc'd memory */
   223   void *block;                  /* pointer to malloc'd block, for free() 
*/
   224   Size reserved;                /* total reserved address space */
   225   Size mapped;                  /* total mapped memory */
   226 } VMStruct;
   227 
   228 #elif defined(MPS_OS_SU) || defined(MPS_OS_SO)
   229 
   230 /* SunOS 4 & Solaris 2 use the same VM struct (only the prototypes of
   231  * mmap and so on are different) */
   232 
   233 /* SunOS 4 & Solaris 2 VM structure; impl.c.vmsu, impl.c.vmso */
   234 /* The names of zero_fd and none_fd are transgressions, see .fildes.name 
*/
   235 typedef struct VMStruct {
   236   Sig sig;                      /* design.mps.sig */
   237   int zero_fd;                  /* fildes for mmap, see impl.c.vms{o,u} 
*/
   238   int none_fd;                  /* fildes for mmap, see impl.c.vms{o,u} 
*/
   239   Align align;                  /* page size */
   240   Addr base, limit;             /* boundaries of reserved space */
   241   Size reserved;                /* total reserved address space */
   242   Size mapped;                  /* total mapped memory */
   243 } VMStruct;
   244 
   245 #else
   246 #error "No definition of VMStruct for this OS."
   247 #endif
   248 
   249 
   250 /* SegStruct -- segment structure
   251  *
   252  * .seg: Segments are the basic units of memory allocation from
   253  * the arena, and also the units of scanning, shielding, and colour
   254  * for the MPM (pool classes may subdivide segments and be able to
   255  * maintain colour on a finer grain (down to the object level for 
example)).
   256  *
   257  * .seg.pm: The pm field is used by both the shield (impl.c.shield)
   258  * and the ANSI fake protection (impl.c.protan).
   259  *
   260  * .seg.pool: This field must be first.  See
   261  * design.mps.seg.assume.pointer-conversion for why.
   262  */
   263 
   264 typedef struct SegStruct {      /* segment structure */
   265   Pool pool;                    /* MUST BE FIRST, see .seg.pool */
   266   Bool single;                  /* single page segment */
   267   Rank rank;                    /* rank of all references in this seg */
   268   AccessSet pm, sm;             /* protection and shield modes */
   269   Size depth;                   /* see impl.c.shield.def.depth */
   270   void *p;                      /* pointer for use of owning pool */
   271   TraceId condemned;            /* seg condemned? for which trace? */
   272 } SegStruct;
   273 
   274 
   275 /* ArenaStruct -- arena structure
   276  *
   277  * .def: The arena structure is in-lined in the space structure
   278  * (impl.h.mpmst.space).
   279  */
   280 
   281 #define ArenaSig        ((Sig)0x519A7E9A)
   282 
   283 #ifdef TARGET_ARENA_ANSI
   284 
   285 /* This is the arena structure used by the ANSI-based  */
   286 /* arena implementation, impl.c.arenaan. */
   287 
   288 typedef struct ArenaStruct {    /* ANSI arena structure */
   289   Sig sig;                      /* design.mps.sig */
   290   RingStruct blockRing;         /* list of blocks in arena */
   291   Size committed;               /* total committed (alloced by pools) 
memory */
   292 } ArenaStruct;
   293 
   294 #else
   295 #ifdef TARGET_ARENA_CLIENT
   296 
   297 typedef struct ArenaStruct { /* arena structure */
   298   Sig sig;   /* impl.h.misc.sig */
   299   RingStruct chunkRing;  /* all the chunks */
   300   Serial chunkSerial;  /* next chunk number */
   301   Shift pageShift;  /* log2(pageSize), for shifts */
   302   Size pageSize;  /* size of block managed by PageStruct */
   303 } ArenaStruct;
   304 
   305 #else  /* neither TARGET_ARENA_ANSI nor TARGET_ARENA_CLIENT */
   306 
   307 /* This is the arena structure used by the virtual memory based */
   308 /* arena implementation, impl.c.arenavm. */
   309 
   310 /* Types used in ArenaStruct, but otherwise defined in impl.c.arenavm. */
   311 typedef struct PageStruct *Page;/* page type */
   312 typedef Word *BT;               /* bool table type */
   313 
   314 typedef struct ArenaStruct {    /* VM arena structure */
   315   Sig sig;                      /* design.mps.sig */
   316   VMStruct vmStruct;            /* virtual memory structure */
   317   Addr base;                    /* base address of arena area */
   318   Addr limit;                   /* limit address of arena area */
   319   Size pageSize;                /* size of block managed by PageStruct */
   320   Shift pageShift;              /* log2 of page size, for shifts */
   321   Index pages;                  /* number of pages in table */
   322   Page pageTable;               /* the page table */
   323   BT freeTable;                 /* page free table */
   324   Size tablesSize;              /* size of area occupied by tables */
   325   Index tablePages;             /* number of pages occupied by tables */
   326 } ArenaStruct;
   327 
   328 #endif /* TARGET_ARENA_ANSI */
   329 
   330 
   331 /* APStruct -- allocation point structure
   332  *
   333  * AP are part of the design of buffers see design.mps.buffer.
   334  *
   335  * The allocation point is exported to the client code so that it can
   336  * do in-line buffered allocation.
   337  *
   338  * .ap: This structure must match impl.h.mps.ap.
   339  * See also impl.c.mpsi.check.ap.
   340  */
   341 
   342 typedef struct APStruct {
   343   Addr init;                    /* limit of initialized area */
   344   Addr alloc;                   /* limit of allocated area */
   345   Addr limit;                   /* limit of allocation buffer */
   346 } APStruct;
   347 
   348 
   349 /* BufferStruct -- allocation buffer structure
   350  *
   351  * See impl.c.buffer, design.mps.buffer.
   352  *
   353  * The buffer contains an AP which may be exported to the client.
   354  */
   355 
   356 #define BufferSig       ((Sig)0x519B0FFA)
   357 
   358 typedef struct BufferStruct {
   359   Sig sig;                      /* design.mps.sig */
   360   Serial serial;                /* from pool->bufferSerial */
   361   Space space;                  /* owning space */
   362   Pool pool;                    /* owning pool */
   363   Seg seg;                      /* segment being buffered */
   364   Rank rank;                    /* rank of references being created */
   365   Addr base;                    /* base address of allocation buffer */
   366   APStruct apStruct;            /* the allocation point */
   367   Align alignment;              /* allocation alignment */
   368   Bool exposed;                 /* is buffer memory exposed? */
   369   RingStruct poolRing;          /* buffers are attached to pools */
   370   AccessSet shieldMode;         /* shielding for allocated memory */
   371   TraceSet grey;                /* colour for allocated memory */
   372   void *p;
   373   int i;                        /* (p and i) closure variables (for 
pool) */
   374 } BufferStruct;
   375 
   376 
   377 /* FormatStruct -- object format structure
   378  *
   379  * See design.mps.format-interface, impl.c.format.
   380  *
   381  * .single: The only format actually implemented is variant "A" described
   382  * by the MPS Interface (impl.c.mpsi, impl.h.mps).  In future, when
   383  * more variants are added, the FormatStruct will have to be adapted in
   384  * some way to cope.
   385  */
   386 
   387 #define FormatSig       ((Sig)0x519F43A2)
   388 
   389 typedef struct FormatStruct {
   390   Sig sig;                      /* design.mps.sig */
   391   Serial serial;                /* from space->formatSerial */
   392   Space space;                  /* owning space */
   393   RingStruct spaceRing;         /* formats are attached to the space */
   394   Align alignment;              /* alignment of formatted objects */
   395   FormatScanMethod scan;
   396   FormatSkipMethod skip;
   397   FormatMoveMethod move;
   398   FormatIsMovedMethod isMoved;
   399   FormatCopyMethod copy;
   400   FormatPadMethod pad;
   401 } FormatStruct;
   402 
   403 
   404 /* LDStruct -- location dependency structure
   405  *
   406  * See design.mps.ld, and impl.c.ld.
   407  *
   408  * A version of this structure is exported to the client.
   409  * .ld.struct: This must be kept in sync with impl.h.mps.ld.
   410  * See also impl.c.mpsi.check.ld.
   411  */
   412 
   413 typedef struct LDStruct {
   414   Epoch epoch;          /* epoch when ld was last reset / init'ed */
   415   RefSet rs;            /* RefSet of Add'ed references */
   416 } LDStruct;
   417 
   418 
   419 /* LockStruct and ThreadStruct -- locking and thread structures
   420  *
   421  * See design.mps.lock, design.mps.thread-manager.
   422  *
   423  * There are no standard interfaces to locks and threads, typically
   424  * the implementations of these modules (and hence the structures used
   425  * by them) will depend on an OS interface.
   426  */
   427 
   428 #define LockSig         ((Sig)0x519110CC)
   429 #define ThreadSig       ((Sig)0x51924EAD)
   430 
   431 #if defined(MPS_OS_W3)
   432 
   433 /* .lock.win32: Win32 lock structure; uses CRITICAL_SECTION */
   434 typedef struct LockStruct {
   435   Sig sig;                      /* design.mps.sig */
   436   unsigned long claims;         /* # claims held by the owning thread */
   437   CRITICAL_SECTION cs;          /* Win32's recursive lock thing */
   438 } LockStruct;
   439 
   440 typedef struct ThreadStruct {   /* Win32 thread structure */
   441   Sig sig;                      /* design.mps.sig */
   442   Serial serial;                /* from space->threadSerial */
   443   Space space;                  /* owning space */
   444   RingStruct spaceRing;         /* threads attached to space */
   445   HANDLE handle;                /* Handle of thread, see
   446                                  * impl.c.thnti3.thread.handle */
   447   DWORD id;                     /* Thread id of thread */
   448 } ThreadStruct;
   449 
   450 #elif defined(MPS_OS_SU) || defined(MPS_OS_O1) || \
   451  defined(MPS_OS_S7) || defined(MPS_OS_IR) || defined(MPS_OS_SO)
   452 
   453 /* All these platforms use the trivial ANSI locks, since nothing better 
*/
   454 
   455 typedef struct LockStruct {     /* ANSI fake lock structure */
   456   Sig sig;                      /* design.mps.sig */
   457   unsigned long claims;         /* # claims held by owner */
   458 } LockStruct;
   459 
   460 typedef struct ThreadStruct {   /* ANSI fake thread structure */
   461   Sig sig;                      /* design.mps.sig */
   462   Serial serial;                /* from space->threadSerial */
   463   Space space;                  /* owning space */
   464   RingStruct spaceRing;         /* attaches to space */
   465 } ThreadStruct;
   466 
   467 #else
   468 #error "No definition of LockStruct or ThreadStruct for this OS."
   469 #endif
   470 
   471 
   472 /* RootStruct -- tracing root structure
   473  *
   474  * See impl.c.root.
   475  *
   476  * Synchronize with impl.c.root.
   477  */
   478 
   479 #define RootSig         ((Sig)0x51940022)
   480 
   481 typedef struct RootStruct {
   482   Sig sig;                      /* design.mps.sig */
   483   Serial serial;                /* from space->rootSerial */
   484   Space space;                  /* owning space */
   485   RingStruct spaceRing;         /* attachment to space */
   486   Rank rank;                    /* rank of references in this root */
   487   TraceSet grey;                /* marked but not scanned for per trace 
*/
   488   RootVar var;                  /* union discriminator */
   489   union RootUnion {
   490     struct {
   491       RootScanMethod scan;      /* the function which does the scanning 
*/
   492       void *p;                  /* environment for scan */
   493       size_t s;                 /* environment for scan */
   494     } fun;
   495     struct {
   496       Addr *base;               /* beginning of table */
   497       Addr *limit;              /* one off end of table */
   498     } table;
   499     struct {
   500       RootScanRegMethod scan;   /* function for scanning registers */
   501       Thread thread;            /* passed to scan */
   502       void *p;                  /* passed to scan */
   503       size_t s;                 /* passed to scan */
   504     } reg;
   505     struct {
   506       FormatScanMethod scan;    /* format-like scanner */
   507       Addr base, limit;         /* passed to scan */
   508     } fmt;
   509   } the;
   510 } RootStruct;
   511 
   512 
   513 /* ScanState and TraceStruct
   514  *
   515  * .ss: See impl.c.trace.
   516  *
   517  * .ss: The first four fields of the trace structure must match the
   518  * external scan state structure (mps_ss_s) thus:
   519  *   ss->fix            mps_ss->fix
   520  *   ss->zoneShift      mps_ss->w0
   521  *   ss->condemned      mps_ss->w1
   522  *   ss->summary        mps_ss->w2
   523  * See impl.h.mps.ss and impl.c.mpsi.check.ss.  This is why the
   524  * Sig field is in the middle of this structure.
   525  *
   526  * .ss.zone: The zoneShift field is therefore declared as Word
   527  * rather than Shift.
   528  *
   529  * The weakSplat field forms part of the design for weakness.
   530  * See design.mps.weakness.
   531  */
   532 
   533 #define ScanStateSig    ((Sig)0x5195CA95)
   534 
   535 typedef struct ScanStateStruct {
   536   Res (*fix)(ScanState, Addr *);/* fix function */
   537   Word zoneShift;               /* copy of space->zoneShift.  See 
.ss.zone */
   538   RefSet condemned;             /* condemned set, for inline fix test */
   539   RefSet summary;               /* accumulated summary of scanned 
references */
   540   Sig sig;                      /* design.mps.sig */
   541   Space space;                  /* owning space */
   542   TraceId traceId;              /* trace ID of scan */
   543   Rank rank;                    /* reference rank of scanning */
   544   Addr weakSplat;               /* value of weak refs to unforwarded 
objects */
   545 } ScanStateStruct;
   546 
   547 typedef struct TraceStruct {
   548   RefSet condemned;             /* summary of comdemnded set */
   549 } TraceStruct;
   550 
   551 
   552 /* SpaceStruct -- the space structure
   553  *
   554  * See impl.c.space.
   555  *
   556  * .space: The space structure is the top-level state of the
   557  * MPS, and as such contains a lot of fields which are considered
   558  * "global".  These fields belong to different modules.  The module
   559  * which owns each group of fields is commented.
   560  */
   561 
   562 #define SpaceSig        ((Sig)0x5195BACE)
   563 
   564 typedef struct SpaceStruct {
   565   /* space fields (impl.c.space) */
   566   Sig sig;                      /* design.mps.sig */
   567   Serial serial;                /* from static spaceSerial */
   568   RingStruct globalRing;        /* node in global ring of spaces */
   569   Bool poolReady;               /* has control pool been initialized? */
   570   MVStruct controlPoolStruct;   /* pool for miscellaneous items */
   571   LockStruct lockStruct;        /* space's lock */
   572   Size pollThreshold;           /* see impl.c.mpsi.poll and SpacePoll */
   573   Bool insidePoll;              /* prevent recursive polling, see 
SpacePoll */
   574 
   575   /* arena fields (impl.c.arena*) */
   576   ArenaStruct arenaStruct;      /* the arena */
   577   Shift zoneShift;              /* see also impl.c.ref */
   578 
   579   /* pool fields (impl.c.pool) */
   580   RingStruct poolRing;          /* ring of pools in space */
   581   Serial poolSerial;            /* serial of next created pool */
   582 
   583   /* root fields (impl.c.root) */
   584   RingStruct rootRing;          /* ring of roots attached to space */
   585   Serial rootSerial;            /* serial of next root */
   586 
   587   /* format fields (impl.c.format) */
   588   RingStruct formatRing;        /* ring of formats attached to space */
   589   Serial formatSerial;          /* serial of next format */
   590 
   591   /* thread fields (impl.c.thread) */
   592   RingStruct threadRing;        /* ring of attached threads */
   593   Serial threadSerial;          /* serial of next thread */
   594   
   595   /* shield fields (impl.c.shield) */
   596   Bool insideShield;             /* TRUE if and only if inside shield */
   597   Seg shCache[SHIELD_CACHE_SIZE];/* Cache of unsynced segs */
   598   Size shCacheI;                 /* index into cache */
   599   Size shDepth;                  /* sum of depths of all segs */
   600   Bool suspended;                /* TRUE if and only if mutator 
suspended */
   601 
   602   /* trace fields (impl.c.trace) */
   603   TraceSet busyTraces;          /* set of running traces */
   604   TraceStruct trace[TRACE_MAX]; /* trace structures.  See
   605                                    design.mps.trace.intance.limit */
   606 
   607   /* location dependency fields (impl.c.ld) */
   608   Epoch epoch;                  /* current epoch */
   609   RefSet prehistory;            /* all-time history of movements */
   610   RefSet history[SPACE_LD_LENGTH]; /* history of object movements */
   611 } SpaceStruct;
   612 
   613 
   614 #endif /* mpmst_h */
   615 

