          TRIP REPORT -- OOPSLA '97 MEMORY MANAGEMENT WORKSHOP
                    report.trip.oopsla97.mm-workshop
                               draft doc
                       P T Withington 1997-10-20

On 4 October 1997, Richard Brooksby and I attended an all-day Memory Management 
workshop in conjunction with OOPSLA '97 (full conference report in a separate 
message). There were about 35 people present, mostly from academia, although 
Oracle, Sun, Great Circle, and Harlequin attended from industry, and INRIA and 
"Real World Computing Partnership" from quasi-governmental agencies.  The 
highlight of the workshop, for me, was Ageson and Detlefs' talk on an exact 
collector for Java and Spertus' talk on Great Circle and the fact that Geodesic 
have hired a guy whose thesis is on GC for CORBA.  The papers given are 
available at <http://www.dcs.gla.ac.uk/~huw/oopsla97/gc/papers.html> should 
eventually also be available at <ftp://ftp.cs.utexas.edu/pub/garbage/gc97/>.  I 
have some of them in electronic form if you want copies.

Below are the papers that were presented at the workshop with a summary of my 
notes.  Feel free to ask me for more detail.

1. A Framework for Storage Management Evaluation in Persistent Object Systems
Thorna Humphries, Alexander Wolf, Benjamin Zorn
University of Colorado

As with many of Zorn's efforts, this involved creating execution traces, in 
this case of database benchmarks and then running those traces against 
different simulators to evaluate performance.

2. Bytecode Instrumentation as an Aid in Understanding the Behaviour of Java 
Persistent Stores
Han Bok Lee, Benjamin G. Zorn
University of Colorado

Basically ATOM for the Java VM.  Inserts byte-codes into existing program to 
create execution traces.  Done at byte-code level for portability, although a 
custom VM would be more efficient.  

Ole Ageson wanted to know how they stayed in the type system and didn't violate 
security.  As with any debugging system, all bets are off.

3. A Smalltalk Memory Profiler and its Performance Enhancement
Jingyu Sun, Edward F. Gehringer
North Carolina State University

Another trace generator, this one concerned with allocation.  Several graphical 
views:  allocator (function) vs. allocatee (object), method call graph colored 
by allocation rate.  Big problem: too much data!  Solution, only emit trace 
"within" methods of selected classes.

Implementation kept portable by using Smalltalk meta level rather than 
modifying VM because VM is proprietary.

4. OSCAR: A GC Testbed
Jonathan Moore, Mike Hicks, Scott Nettles
University of Pennsylvania

Snapshots the state of a heap in a common format against which different 
collector algorithms can be benchmarked.  Actually seemed to be studying 
implementations more than algorithms.

Ole Ageson remarked that they used the results to greatly speed up their Java 
GC copy loop.  Mike Spertus wanted to know if the heap representation muddled 
results.  Nettles asked the group to suggest things to study/measure.

A discussion followed on how to tune tunable GC's.  The conclusion was that 
there were many parameters but noone had any way to tell how to set them.  Urs 
H\0x9Alzle observed that none of the papers instrumented _real_ systems.  Ole 
observed that Sun wanted to add hooks to their VM to permit this.

5. Concurrent Collection for the Java Development Kit
Alex Garthwaite, Scott Nettles
University of Pennsylvania

The current Java GC is a stop-the-world GC.  The GC thread tries to GC during 
idle, but backs out if interrupted.  This is an allocate-driven collector with 
idle time used to stay ahead.  It uses mark and free bits in object headers and 
rotates bit patterns to avoid resetting.  Allocates white with atomic scan at 
end.  Uses a write barrier.  Problems with native code.  Sweeping done lazily 
at allocate time (but to rotate the mark/free bits, must complete the sweep).  
Compaction happens in a separate thread.

I asked if doing all this work at allocate time was the right thing as it would 
seem to slow the mutator.  The answer was that allocation was already so bad it 
didn't make any difference.

6. The Memory Manager for the Aurora Java Virtual Machine
Peter Benson
Oracle Corporation

Peter is implementing the memory manager for a JVM that will run on Oracle 
servers, allowing you to have stored (Java) procedures in your database.  The 
main challenge is fitting in the server runtime which has some very bizarre 
memory allocation restrictions.  All object formats are described in a 
metalanguage (Scheme) which emits C code for object access with appropriate 
barriers.

7. Finding References in Java Stacks
Ole Agesen, David Detlefs
Sun Microsystems

Sun (East) is implementing an exact GC for their Java VM.  One problem is how 
to scan the stack.  Since Java has "full sized" unboxed values, tagging is 
difficult, but due to some clever (lucky?) restrictions in what is allowed in 
Java byte codes it is fairly easy to figure out the type of any stack slot from 
the current PC.  There is one exception for finally clauses which was hard to 
work around, but perhaps that exception shouldn't have been there.

I asked why they didn't get their hardware designers to give them some tag 
bits.  Ed Gehringer tried to say that failed long ago, but Ole said that the 
hardware group often discussed such things.  [There may be hope!]

8. Reachability-based Orthogonal Persistencefor C, C++ and other intransigents
Anthony Hosking, Aria Novianto
Purdue University

Persistent store as the oldest generation of a generational collector.  
"Orthogonal" meaning you don't have to use special types or allocation to get a 
persistent object.  The problem:  ambiguous references -- when a persistent 
object references a nailed page they promote the whole page to the persistent 
store.  [I can't make sense of this now -- guess we have to wait for the paper.]

Paul Wilson suggested they look at his Portable Runtime Type Description, as 
Richard has already mentioned, to do a more exact collection.

9. Experiences in Commercialising Boehm's Collector
Michael Spertus
Geodesic Systems

Great Circle is Boehm's collector +15 man-years of "commercialization".  They 
sell into the C/C++ large end user market and are licensing to Java OEMs.  It 
is offered free for non-commercial research.  Their pitch is "We will fix the 
leaks  in the code that you don't have control over (we _know_ you don't have 
any leaks in your own code)".

In their experience allocation overhead is 5-10x collection overhead.  They 
have a "pooling" allocator that manages separate pools of common object sizes 
to reduce fragmentation and speed allocation.  They have really worked on 
efficiency [as an aside, he wondered when comparisons are done, are you 
comparing algorithm or implementation].  False positives from conservative 
collection were much worse than they expected.  Scheduling collections is still 
an open research question for them.

Originally they tried to use a precise treadmill algorithm, but it was a dog.  
Currently they use a conservative mark and sweep.  Simple, boring, but 
effective.  They believe they approach all the theoretical advantages of a 
copying collector without the storage overhead or read barrier overhead.  They 
support precise collection [which I take to mean they support an interface for 
you to tell how to scan your objects].

They don't try to sell their product as a garbage collector -- that is too 
radical for most of their customers.  They get their foot in the door selling 
it as a debugger:  it eliminates bugs, and it can report leaks, fragmentation, 
non-constant in time data structures [not sure what that last means].  GC 
covers the errors your coverage tests can't (i.e., you can leave it on in the 
shipping product).  All diagnostic output is HTML.

10. A Proposal for a Standard Memory Management Interface
Richard Brooksby, P. Tucker Withington and others
Harlequin

Can't tell if this was a yawn.  I zipped through the presentation to give time 
for discussion, which was really our goal.  We got some discussion which 
indicated people didn't understand what we were proposing at first.  There was 
a lot of interest in the idea of "cohorts", once understood.  Sun also appeared 
interested, as they want to make their GC interface a pluggable interface.  Of 
course we played coy and said we couldn't disclose how ours worked.

Peter Dickman suggested that discussion of the idea be carried on in email.

11. Cyclic Distributed Garbage Collection without
Global Synchronization in CORBA 
Gustavo Rodriguez-Rivera, Vince Russo
Purdue University

Uses generational hypothesis (picks young, not locally-referenced objects to 
collect), backtracing (local gc creates "reference list" at edge of nodes), 
read barrier (RPC uses "event counts"to note white references escaping local 
node).  He has proposed this to OMG.

Richard Jones wanted to know if he was familiar with Maheshwari & Liskov's 
work.  He was not [neither was I, but 
<ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-574.ps.gz> looks 
extremely interesting].

Gustavo now works for Geodesic (although it is not clear he has finished his 
thesis).  One might infer that Geodesic has an interest in CORBA GC.  He spent 
a lot of time "glad-handing" everyone in the workshop; presumably to impress 
his new boss.

12. PerDiS PPF Case Study: Fitting a Distributed Garbage Collection Algorithm 
to a Persistent Distributed Store Architecture
Xavier Blondel, Paulo Ferreira, Marc Shapiro
INRIA

Garbage is considered a stable property because mutator always works on a copy 
of the persistent object.  The persistent object can be reclaimed even if it is 
transiently in use.  If a persistent reference is created, the transient object 
will be made persistent again.  [Sounds like replicating GC to me.]

13. Gleaner-7: A Hybrid Distributed GC Algorithm
Munenori Maeda, Yutaka Ishikawa
Real World Computing Partnership

Yet another mutation of this algorithm developed at the MITI funded research 
lab for massively parallel computation.  It uses distributed reference counting 
and a global mark-sweep to collect cycles.  I think they must have something 
interesting here -- they've been working on it since 1992, but I didn't get it 
in the short presentation.

14. A Detection Algorithm for Distributed Cycles of Garbage
Fabrice Le Fessant, Ian Piumarta, Marc Shapiro
INRIA

Ian Piumarta and Fabrice Le Fessant each presented aspects of their algorithm 
for collecting distributed cycles.  I have to admit, I did not follow the 
presentation.

Peter Dickman commented to the group in general that he felt the algorithm they 
were using was sound, but extremely difficult to understand, let alone convey 
in 15 minutes.  I have the paper and plan to have a go at it, on Peter's 
recommendation.

15. Predictable Automatic Memory Management for Embedded Systems
Roger Henriksson
Lund University

A copying GC for hard real time!  Doesn't start a GC when a high-priority 
process is ready.  GC is interruptible by high-priority processes.  There is an 
emergency cons area only available to high-priority processes.  Uses Brooks 
technique (forwarding pointer in object header that is always chased -- 
essentially an ob-table that is distributed across the objects); effectively a 
1-instruction read barrier.  Evacuation on stores (~ 12 instruction overhead).

Richard and I agreed that we should consider if/how such a scheme could fit in 
our framework.

16. Eliminating Fragmentation without Moving Things
Michael Spertus
Geodesic

Great Circle splits allocations into small, medium and large.  Small objects 
are always allocated in single-page "arrays" of like-sized objects.  Medium 
objects in n-page arrays (i.e., sizeof(medium)%n == 0).  Large objects are any 
object greater than 1 page -- allocated individually.  Since everything is 
page-based, compaction can be done by re-mapping, but in practice just 
aggressively unmapping free pages seems to suffice.

Richard observed that he really had just moved the scale of fragmentation up.  
Mike replied that it is swap-space that is scarce, not address space.  I 
wondered about the detrimental effects on the underlying O/S's VM of all this 
mapping and unmapping.  They have not experienced a problem.

17. The Memory Fragmentation Problem: Solved?
Mark Johnstone, Paul Wilson
University of Texas at Austin

Mark Johnstone has been working on studying allocation algorithms to see how 
best to solve fragmentation.  He has tried to measure policy by factoring out 
implementation cost (i.e., implement several policies using a uniform 
implementation and data set).

Interestingly, he believes fragmentation is not really a problem, that there 
are lots of policies that work just fine.  He defines that fragmentation is 
only a problem when you have a hole that you _never_ reuse (over the life of 
the program).  He showed some traces to illustrate that most holes get reused.

Mike Spertus observed that fragmentation is a problem with very long running 
programs.  Richard described the SW problem, which always created unusable 
holes (was pathological).  The answer to both was that the programmer must 
understand the underlying policy [did he mean you have to program around the 
policy? -- I'm not convinced fragmentation is solved on this evidence].  

---

There were a number of "work in progress" announcements.

Richard described the LFCS result.

Richard Jones asked if anyone would buy a second edition of his book.  The 
publisher would like to revise it to mention Java on the front cover.

Tony Printezis is working on a persistent Java store and has invented "regimes" 
which parallel our cohorts.

Paul Wilson is working on compressed VM

---

There was discussion of IWMM '98.  All generally liked the idea of being in 
Cambridge.  The details were not settled.  Richard will have to push on Paul 
Wilson (program chair) to set the details if we are to have a call in time for 
a late September meeting.

