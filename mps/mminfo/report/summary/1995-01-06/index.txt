             MEMORY MANAGEMENT PROJECT SUMMARY, 1995-01-06
                       report.summary.1995-01-06
                             incomplete doc
                           richard 1995-01-06

                      MEMORY MANAGEMENT PROJECT
                                REPORT
                              1995-01-06


INTRODUCTION

This document is a report on the current status and future directions
of the Memory Management Project at the end of December 1994, just
after the release of the first deliverable to the DylanWorks Project.

The report covers the following areas:

 - a summary of the project progress and current position
 - review of the project definition
 - assessment of planning techniques
 - assessment of engineering techniques
 - a vision the the product range
 - approximate costing of the project and implications for the products
 - possible routes to market
 - future directions for development
 - outline plan and schedule.


SUMMARY OF PROGRESS

The project began in March 1994 when Richard Brooksby and Tucker
Withington met at 1CC for a brainstorming session.  By the end of a
one-week meeting we had investigated markets for memory management,
and produced descriptions of a range of products we could produce to
fill them.

A period followed during which we struggled to define the project more
formally in order to get clear directions and measurements of success.
This resulted in the project definition described in later (see REVIEW
OF DEFINITION).  The definition focussed attention on those products
and parts which were particularly of relevance to Dylan.

In May and June we discussed and documented designs, and wrote a
prototype which was `complete' by mid July.  A meeting at 1CC
followed, where we analysed the prototype and discussed in more detail
the collector technology for DylanWorks.  After that meeting the
prototype was more or less discarded and the code rebuilt to form the
basis of the DylanWorks Memory Manager product.

During September, intense discussion of the critical parts of the
garbage collector broke out between the Memory Management and Dylan
teams.  A huge amount of progress was made, and a complete design for
the collector, and a programming interface to Dylan, emerged.  Coding
began in earnest, with David Jones joining the project on 10th
October.

The design was reviewed by the team in mid October at a meeting at the
Hall.  During that meeting the implementation was broken into five
delivery stages (see PLANNING TECHNIQUES), and later Richard produced
a detailed plan of execution for the first two deliveries.  David and
Richard followed the plan closely, employing as many techniques as
possible to maintain a very high standard of code quality.  (During
this period Tucker was mainly occupied with writing for the Dylan
book.)  After a week of stress and coverage testing the first
deliverable was handed to the Dylan Project on the first of December.

We are now conducting a brief review of the project, writing this
report, and making detailed plans for the next stages of development.
Next week, Richard will work with Tony Mann to integrate the
deliverable into DylanWorks.  We await their feedback with interest.


REVIEW OF PROJECT DEFINITION

A period of discussion on the objectives and direction of the project
took place in April and May 1994 (see SUMMARY OF PROGRESS).  This
resulted in the project being defined with the following objectives:

 - To produce memory management components for the Dylan Project
   which will not compromise the image of Dylan in the eyes of the
   wider community, and will therefore contribute to the successful
   launch of Dylan.

 - To raise revenue by making products.

 - To broaden and improve the image of Harlequin.

 - To reduce duplicated effort and increase quality of memory
   management solutions throughout Harlequin.

The first objective requires that we produce memory management support
for DylanWorks which satisfies certain attributes:

 - solidly engineered so as not to cause defects in DylanWorks applications
 - performs well so as not to impact in the performance of applications
 - puts the programmer in control of memory management.

(I have omitted various attributes to do with deadlines, costs, effort, etc.)

We proposed, inter alia, the following approaches to satisfying these
attributes:

 - Adopt an evolutionary approach to production, developing
   component seperately in manageable stages and building scheduled
   products out of those components.  Avoid `big bang' release
   strategy.

 - Mitigate the impact of automatic management by providing
   selectable memory management strategies, including selectable
   garbage collectors.  This has an additional advantage that the
   developer makes the choices and suffers the consequences, and so has
   fewer grounds for blaming particular strategies or GC in general for
   performance failings.

One could regard our entire design as a `solution' and include it
under the project definition as such.  It is more useful to consider
the important points of the design and engineering as separate
solutions:

 - Incremental garbage collection, to reduce the visible impact of
   collection on applications.

 - Measurement and measureable techniques wherever possible, to gain
   enough knowledge about the system to make the incremental strategy
   effective.

Memory manager bugs are hard to track down and cause long delays in
production.  They also cause defects in end-user applications which
are next to impossible for the programmer to analyze and fix up.  It
is therefore essential to the objective that we produce very high
quality code.  To this end:

 - Adopt `solid coding' practices to improve the quality of code.
 - Hold regular inspections of code (code review).
 - Simplicity first, optimization later.

We have adopted the notion of `appropriateness' as a guiding
principle.  Complexity only where appropriate.


ASSESSMENT OF PLANNING

** richard should write something here.
** Basically I want to say that simple GANTT-chart type 
   planning has been successful so far and we have been able to deliver
   quality stuff on time.


ASSESSMENT OF ENGINEERING TECHNIQUES

** DRJ is writing something for this.
** There is a document describing our techniques and the advantages.  We
   could insert it here as a section.


A VISION OF THE PRODUCTS

Key attributes of the products:

 - high quality and reliability
 - good performance
 - good design
 - inspiring confidence
 - providing control

The product is a small kernel plus component memory management
libraries which can be composed for a particular application.  The
system is `open' in that it has plenty of well-documented parameters which
the developer can use to tune performance.

Each component also has an instrumented version, which produces output
which can be fed to analysis tools.  The tools assist debugging, and
also provide enough information to tune the performance of the system.
This information can be used `live' to provide information about the system
as it runs, and control its behaviour.

Graphics can provide a very natural and efficient way of presenting information
about memory management.  Graphical tools will therefore feature strongly,
incidentally giving us market appeal.  



APPROXIMATE COSTING

A quick back-of-envelope calculation gives an estimate of resource
consumption by the project of 150000 pounds per year.  If it takes us
18 months to get a unit product to market then to balance the books we
need to sell:

  4500 units @   50 pounds each
  2250 units @  100 pounds each
   450 units @  500 pounds each
   225 units @ 1000 pounds each

At high volume we have to factor in the cost of support.

Option 1 -- high volume drop-in

 - shrink-wrapped memory management library
 - drop-in replacement for Windows memory manager
 - performance benefits, maybe some simple measurement tools
 - minimal or limited support
 - 50-100 pounds per unit

Option 2 -- basic memory management toolkit

 - could bundle with DylanWorks
 - Memory Pool Manager core system 
 - some measurement tools
 - some manual memory pools with performance benefits
 - some memory pools with auditing and debugging facilities
 - go for the same corporate application developer market as DylanWorks
 - technical support
 - 100 to 500 pounds per unit

  (MicroQuill's SmartHeap sells for about 300 pounds.)

Option 3 -- advanced memory management and debugging tools

 - Memory Pool Manager core system
 - full measurement, data gathering, and analysis tools
 - debugging analysis and visualization tools
 - suite of standard memory pools including automatic (gc) managers
 - bespoke memory pools by contract
 - special needs consultancy
 - 500 to 1000 pounds per unit depending on tool range, plus consultancy

With these options come increasing impact on the schedule for
integration with DylanWorks.  We could produce option 1 with only small
impact, the others would need a more detailed study.  I don't think we
can feasibly produce the fully-featured system described under option 3
and a quality DylanWorks collector.


POSSIBLE ROUTES TO MARKET

The progress of the Memory Management Project depends mainly on the
DylanProject for at least nine months and probably a year.  Our main
target `market' is simply as an component in the DylanWorks environemnt
and run-time system.  However, there are possibilities for independent
and semi-independent products along the way.

The Dylan Project may adopt a strategy of releasing a version of the
DylanWorks compiler free or at a nominal cost, to generate interest in
the corporate C and C++ market.  A `Harlequin Memory Manager' product
could be bundled with DylanWorks as a separate product as well as
being part of the DylanWorks system.  That way it will get on to the
disks of the developers we are trying to target.  Dylan and Memory
Management have a great deal of overlap in terms of marketplace, so
even if a developer rejects Dylan, he might find a Memory Manager
useful.

Similarly, we could release the core of the Memory Manager (the MPM)
as a free component, and bundle a couple of basic management policy
modules (memory pools) as tasters.  If we provide some limited but
whizzy graphical feedback and measurement tools we might well get
orders for the more sophisticated policies.

Taking this further, there might be an advantage in publishing the
interface between the MPM and the memory pools in an attempt to make
an open standard.  We would supply memory pools, debugging and
measurement tools, and programmers could develop their own management
policies.


FUTURE DIRECTIONS FOR DEVELOPMENT

At present our resources are dedicated to producing a memory manager for
DylanWorks.  This section assumes that this will continue.

We have constructed and delivered a basic memory management framework and
simple allocator, and this has been successfully integrated into the
DylanWorks run-time system.

We have also developed a draft specification for a Dylan API to memory
managers in general.  This will become a discussion document for the
Dylan consortium and may be accepted as a standard.  If it does, we
will gain a lead, since it fits out memory manager nicely.

The next stage is to develop a minimal garbage collector.  DylanWorks will
be adapted to produce objects in a traceable format, and a collecting
memory management policy will be written.  This policy must perform tracing
of the Dylan state.  For this target we emphasize correctness rather than
efficiency.

With good cooperation for the Dylan compiler we expect to deliver this target
in March 1995.

After that we move on to develop an efficient collector by applying well
known performance enhancements.  The first will be generational collection.
This will require effort on measurement feedback so that the generational
algorithm is correctly tuned.  This stage also introduces methods which use
hardware protection mechanisms under Windows, something which will no doubt
need work.

July?

We must eliminate intrusive performances from DylanWorks-generated applications
and DylanWorks itself to be taken seriously.  The next stage of development
builds on the generation algorithm to spread it across timeslices so that it
becomes incremental.  This stage introduces more harware protection techinques,
and will no doubt be a pain to debug.

October?

The final stage is to add all functionality required by DylanWorks, such as


AN OUTLINE PLAN AND SCHEDULE

---
$Id$

