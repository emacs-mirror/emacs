                           INVENTORY OF IDEAS
                             overview.ideas
                               draft doc
                           richard 1996-05-30

INTRODUCTION


Scope and Purpose

.scope: This document lists major ideas associated with the Memory Management 
Project.

.purpose: The purpose of this document is to establish Harlequin's claims to 
some of these items as "trade secrets" and to provide Harlequin staff with 
information about what is and is not secret.


Document History

.hist.1: 1996-05-30: First draft created by Richard Brooksby from notes 
originally made for a technical overview document.

.hist.2: 1996-07-09: Declassified ML modeling, added a status for Zones, and 
added tags.

.hist.3: Recorded decisions made by Quartet 1999-06-01.  pekka 1999-06-03


INVENTORY


Abstract Collection Process

.acp: The MPS design includes an abstract collection process which subsumes 
many major garbage collection techniques.  The implementation of this process 
allows the integration of many different types of garbage collection strategies 
in a single framework.  The model is simple and efficient.  The ability to 
integrate collectors contributes significantly to the flexibility of the 
system.  The reduction in code duplication contributes to the reliability and 
integrity.

.acp.xref: Described in idea.collect.

.acp.status: partially implemented, existence secret, technique secret.


Adaptive Cost/Benefit Analysis

.adapt: The MPS is designed to make memory management decisions based on 
"adaptive cost/benefit analysis" rather than hard-wired strategy.  This 
technique allows the client to specify the operational parameters 
(requirements) dynamically, and the MPS will take decisions to meet them, 
adapting to the changing circumstances.  This technique contributes the 
flexibility and adaptability of the system.

.adapt.xref: [I have no idea what this refers to.  pekka 1999-06-03]

.adapt.status: partially implemented, existence secret, technique secret.


Allocation Points

.ap: The MPS interface provides "allocation points" which allow the client 
application to allocate in-line at high speed (around 10 instructions) without 
significantly compromising the flexibility of the memory management policy.  
Allocation points contribute to flexibility by providing a high-performance 
allocation option.

.ap.xref: Described in idea.buffers.

.ap.status: implemented, existence secret (revealed by the MPS i/f), 
implementation secret (mostly revealed by the MPS i/f).


Appropriate Techniques

.appro: The MPS is designed and implemented in a simple and straightforward 
manner, except where sophistication is needed to meet client requirements.  
Abstraction is applied where appropriate, and ignored where necessary.  
Optimization is done only where it is needed.  System dependency (assembly 
language or OS dependency) is allowed, but controlled.  The principle of 
appropriate techniques contributes to adaptability by making the system easy to 
manage and change.  It contributes to reliability and integrity by keeping the 
system simple except where it needs to be subtle.  It also contributes to 
flexibility in that we are able to introduce dependent but high-performance 
techniques when the need arises.

.appro.xref: This is so general, it's hard to point to any specific documents 
describing it.

.appro.status: implemented, not secret.


Arena

.arena: The MPS uses an abstraction of base memory called the "arena" to 
provide basic memory blocks which are then managed by the individual policies.  
This contributes to adaptability by limiting the system dependencies and 
simplifying the implementation of memory management policies.

.arena.xref: Described in idea.arena [not really, pekka 1999-06-03].

.arena.status: implemented, existence obvious, implementation secret.


Component Architecture

.component: The MPS is designed as a software component.  It is designed to fit 
in to a system where other such components may be operating.  It does not 
assume control over the address space, threads, the CPU, or the environment in 
general.  It is designed to be small, to fit in embedded systems.  It makes 
conservative use of the features of its implementation languages, and of the 
operating environment.  It avoids unjustifiable clever tricks.  An important 
test of this is that the system can run when there is another copy of itself in 
the application, or another foreign memory manager.  This approach contributes 
to the flexibility of the system by allowing it to be deployed in many 
environments.  It also contributes to the reliability and integrity by 
restricting the complexity and dependencies.

.component.xref: Described in idea.component.

.component.status: implemented, existence not secret, implementation secret.


Concurrent Collections

.concurrent: The MPS design provides the ability to operate several garbage 
collectors on the same heap concurrently, i.e., there may be several passes 
over the heap in progress at any one time.  The implementation does not 
compromise the efficiency of any single collection.  This contributes to the 
flexibility of the system, in that it can cope with situations where separate 
areas of memory need to be dealt with independently, or where long- and 
short-term passes over the heap are required simultaneously.  This is a major 
advance over the current state of the art.

.concurrent.xref: Described in idea.concurr.

.concurrent.status: partially implemented, existence secret, implementation 
secret.


Conservative Style

.conserv: The MPS development is done in "conservative style", meaning that 
simple, safe, and tested techniques that meet requirements are used in the 
design and implementation.  Note that this does not imply a lack of innovation 
or adaptability, since these are both required, but it means that we opt for 
the safe path when there is no reason to do otherwise.  An example of this 
principle is that we code in a "conservative subset" of the C language.  The 
principle contributes to portability, reliability, and flexibility.

.conserv.xref: This is so general, it's hard to point to any specific documents 
describing it.

.conserv.status: implemented, not secret.


Event Logging

.event: The MPS uses internal event logging and recording to provide both 
measurement feedback and a record of events in case of failure.  This 
contributes to flexibility by providing measurement, and to reliability by 
providing improved debugging ability.

.event.xref: @@@@.

.event.status: implemented, existence secret (revealed by the MPS i/f), 
implementation secret.


Evolutionary Delivery

.evol: The MPS is development is managed using the principle of "evolutionary 
delivery", which emphasizes requirement-oriented development, and determination 
of client requirements by early delivery and feedback.  This approach 
significantly reduces the risk of failure by ensuring that actual (as opposed 
to initially stated) client requirements are determined and met, and clients 
have access to early working solutions.

.evol.xref: Described in book.gilb88.

.evol.status: partially implemented, public.


Generalized Generations

.gen: Some garbage collectors developed by the Memory Management team use 
"generalized generational collection", a method which generalizes and subsumes 
several other garbage collection strategies, and adaptively chooses the best 
according to the client application's characteristics.  This technique 
contributes to the flexibility and adaptability of the system.

.gen.xref: Described in idea.gens.

.gen.status: prototyped, existence secret, implementation secret.


Incremental Processes

.incr: The MPS implements background management processing, such as incremental 
garbage collection, as a set of state machines whose timing is carefully 
controlled in order to meet the client's timing requirements.  This technique 
contributes to the flexibility and adaptability of the system.

.incr.xref: Described in idea.incremental [not really, pekka 1999-06-03].

.incr.status: partially implemented, existence obvious, implementation secret.


Inspection

.inspect: A formal document and code review technique called "Inspection" is 
applied to the development of the MPS.  Inspection is the single best 
contribution to the integrity and reliability of the design and implementation.

.inspect.xref: Described in book.gilb93.

.inspect.status: partially implemented, public.


Location Dependency

.locdep: A client application should avoid relying on the actual locations of 
objects in memory if it is to allow the memory manager the freedom to manage 
memory efficiently.  In cases where the client must depend on location, the MPS 
provides a "location dependency" mechanism which retains important freedom for 
the memory manager while giving the client application an efficient method of 
updating its dependency.  This mechanism contributes to the flexibility of the 
system.

.locdep.xref: Described in idea.location [not really, pekka 1999-06-03].

.locdep.status: implemented, existence required, implementation secret.


Model of Use

.model: The MPS Model of Use includes a mechanism by which the client's 
requirements are determined by a "measurement feedback loop" consisting of the 
MPS, associated tools, the client programmer, and the client application.  This 
model is designed to extract the clients requirements whether he knows them 
explicitly or not.  This mechanism is a significant contribution to the 
flexibility of the system, and to its overall quality, since it increases the 
probability that the system will meet the clients requirements.

.model.xref: @@@@.

.model.status: designed, existence secret, implementation secret.


Modelling

.modelling: The MPS is designed using a method of "modeling" in other 
languages, particularly ML.  The modeling method allows the development and 
maintenance of design ideas in a pure form, so that the implementation can be 
less abstract without sacrificing design ideals or maintainability.  This 
method contributes to integrity and reliability.

.modelling.lfcs: Note: Modeling is developed in collaboration with the LFCS 
(see goal.lfcs).

.modelling.xref: @@@@.

.modelling.status: prototyped, existence public, method not secret.


Multigraphs

.mg: The MPS uses "multigraphs", a generalization of the object graphs 
conventionally used to manage memory based on the state of the application 
program.  Multigraphs provide new ways of understanding application state and 
efficient methods for garbage collection.  Multigraphs contribute to 
flexibility and adaptability.  [This is an overblown description of a simple 
idea not really used in the MPS.  pekka 1999-06-08]

.mg.xref: Described in idea.levels [not really, pekka 1999-06-08].

.mg.status: not implemented, existence secret, implementation secret.


Multiple Co-operating Management Policies

.multi: The MPS allows several different memory management policies to co-exist 
and co-operate, especially in the process of garbage collection.  Several 
different types of garbage collector can work together on a pass over the 
application's data.  The protocols used to achieve this are highly efficient 
and do not compromise the efficiency of a single policy working alone.  Objects 
may also be migrated between policies if the MPS determines that this would 
better meet requirements.  This design contributes to flexibility by providing 
the ability to combine policies to form new composite policies.  It also 
contributes to adaptability by simplifying the implementation and integration 
of new policies.  This is a major advance over the current state of the art.

.multi.xref: Described in design.mps.collection.

.multi.status: implemented, existence public, implementation secret (partly 
revealed by the MPS i/f).


Object Formats

.format: The MPS provides "object formats" in order to abstract away from the 
client application's particular object layout.  In some cases, the format 
further divides into "object format" and "container format", providing greater 
flexibility.  This approach means that memory management policies do not need 
to depend on the particulars of an application's objects, but can nonetheless 
manage them efficiently.

.format.xref: No design exists, user documentation in protocol.mps.format.

.format.status: implemented, existence public, implementation secret  (revealed 
by the MPS i/f).


Pools and Pool Classes

.pools: The MPS is based on a system of "memory pools" and "memory pool 
classes" which implement memory management policies.  Memory pools improve 
locality, allow multiple instantiations of policies, co-operate to give 
composite policies, and provide a uniform interface to memory management which 
greatly improves flexibility by making it easy to modify and experiment with 
policy choices in the client application.

.pools.xref: Described in idea.pools [not really, pekka 1999-06-08].

.pools.status: implemented, existence public, implementation secret.


Ranks and Conservative Garbage Collection

.ranks: The MPS includes the concept of "reference rank" allowing it to cope 
naturally with ambiguous references when needed.  It is therefore suitable for 
deployment in systems where there is only partial knowledge about the 
connectivity of the application's objects.  (An example of this is conservative 
garbage collection.)  This contributes to the flexibility of the system in that 
it allows it to be used in circumstances where full knowledge is impossible or 
costly to obtain.  For example, the MPS can be retro-fitted on to an 
application that was not designed to support it, and provide a useful degree of 
automatic management.  [This description is misleading: ranks are neither 
necessary nor sufficient to support ambiguity; and we use this word now to 
describe other features as well (see idea.ranks).  pekka 1999-06-08]

.ranks.xref: Described in idea.ranks.

.ranks.status: partially implemented, existence secret (revealed by the MPS 
i/f), implementation secret (partly revealed by the MPS i/f).


Reference Sets

.refset: The MPS uses the concept of "reference sets" which provide efficient 
conservative approximations to sets of references, and thereby to sets of 
objects.  Several implementations of reference sets are used for different 
purposes in the system.  Reference sets provide a great number of efficiency 
improvements, thereby increasing the flexibility of the system.  [Zones 
(.zones) are essential to all the real uses of refsets.  pekka 1999-06-08]

.refset.xref: Described in idea.remember.

.refset.status: implemented, existence secret, implementation secret (partly 
revealed by the MPS i/f).


Reference Partitions

.refpart: The MPS design includes an important generalization of "tri-color 
marking" called "reference partition" which allows multiple concurrent 
collections as well as important deductions which help to reduce the CPU 
overhead of garbage collection.  Reference partitions thereby contribute to 
flexibility and adaptability.  [Actually, this idea proved fruitless, and is in 
fact somewhat mistaken.  pekka 1999-06-03]

.refpart.xref: Described in design.mps.tracer(0).

.refpart.status: not implemented, existence secret, implementation secret.


Scanning State Machine

.scanner: The MPS design includes the concept of a "scanning state machine" 
which can provide very efficient scanning of suitably formatted client 
application objects.  This contributes to flexibility.

.scanner.xref: idea.statescan.

.scanner.status: designed, existence secret.


Shield

.shield: The MPS uses an abstraction called the "shield" to virtualize and 
manage memory protection, allowing the MPS to function as a layer between the 
client program and the operating system supplied memory.  This technique 
contributes to adaptability by simplifying the protection mechanisms.

.shield.xref: Described in idea.shield.

.shield.status: implemented, existence secret, implementation secret.


Simplicity

.simple:
  "Everything should be as simple as possible, and no simpler."
                                                — Albert Einstein.

Wherever possible, the MPS design generalizes and simplifies existing 
techniques in order to achieve more.  This contributes to reliability and 
integrity by avoiding the production of unnecessary new subsystems (which would 
introduce new problems).  It contributes to flexibility by adding functionality.

.simple.xref: This is so general, it's hard to point to any specific documents 
describing it.

.simple.status: implemented, not secret.


Strategy and Tactics

.strategy: The MPS design separates decision making into "strategy" and 
"tactics".  Strategy uses adaptive cost/benefit analysis (.adapt) to decide on 
long-term measures and is applied across pools.  Tactics are implemented by the 
memory management policies to determine short term measures.  This separation 
allows policies to vary in their sophistication and therefore contributes to 
the adaptability of the system.

.strategy.xref: [I have no idea what this refers to.  pekka 1999-06-03]

.strategy.status: partially implemented, existence secret, implementation 
secret.


Two-Phase Allocation

.two-phase: The MPS provides a "two-phase allocation interface" which allows 
highly efficient communication of the status of a newly allocated object 
between the client application and the memory management policy, usually 
without any function call overhead.  This method is provided via allocation 
points (.ap).  Two-phase allocation contributes to adaptability, since it 
allows the implementation of policies which require more or less communication 
with the application without modifying the interface.  It also contributes to 
flexibility because it is efficient.

.two-phase.xref: Described in idea.buffers and design.mps.alloc-cache.

.two-phase.status: implemented, existence secret (revealed by the MPS i/f), 
implementation secret (revealed by the MPS i/f).


Zones

.zones: The MPS design includes a technique of zones which allows certain 
properties of an object to be determined extremely quickly given a reference to 
that objects.  This is a very important performance optimization for garbage 
collection, where a large number of objects must be scanned for references to 
other objects with particular properties.  Zones contribute to flexibility, by 
provide the performance needed to meet tight time overhead requirements.  
[Refsets (.refsets) are involved in all the real uses of zones.  pekka 
1999-06-08]

.zones.xref: Described in idea.zones.

.zones.status: implemented, existence secret, implementation secret (partly 
revealed by the MPS i/f).

