               HARLEQUIN MEMORY POOL SYSTEM MODEL OF USE
                           overview.mps.usage
                             incomplete doc
                           richard 1996-04-09

INTRODUCTION

Scope

.scope: This document outlines how the Harlequin Memory Pool System (MPS) is 
intended to be used.  The "Model of Use" has guided the design of the MPS and 
associated tools.  The document doesn't go into detail (it's not a user manual) 
or describe specific bits of design.

Purpose

.purp.back: To provide background information to assist in understanding the 
design of the MPS.

.purp.justify: To justify basic assumptions and decisions made in the design.

.purp.concept: To provide basic concepts which should permeate the software, 
documentation, and support in order to make the product uniform and consistent.


POOL CLASSES

The model and design are based the important principle that there is no single 
solution to all memory management problems.  There are several classes of 
memory manager, each with many variations, and each has distinct properties 
which make it suitable for meeting its own set of requirements.  So, rather 
than implement a single memory manager, the MPS is a generic framework for 
memory management policies which can coexist.  The user is supplied with the 
Memory Pool Manager (MPM) plus a set of Memory Pool Classes and selects the 
appropriate combination of classes and parameters for his application (see 
figure 1).


Figure 1. Memory Pool System architecture


USER LEVELS

Each client will be operating in different circumstances with different 
requirements.  Perhaps the most important tradeoff to consider is the amount of 
effort that can be invested in tuning memory management against the benefits 
gained.

Memory management policies, even when simple, can interact with the client 
program in subtle ways which drastically affect performance.  The user must 
have a very good understanding of this interaction in order to get the best 
performance out of the application.  On the other hand, there are a number of 
very simple things that a user can do to improve performance, and it's fairly 
easy to improve on system-supplied memory managers.

The following levels of use have been defined to cater to the varying 
effort/benefit requirements of users:

  1. trivial - install it and forget it,
  2. basic - use appropriate pool classes,
  3. intermediate - use measurement to influence choices,
  4. advanced - understand interactions to optimize program.

As with most things, the law of diminishing returns applies.  The amount of 
time and effort required to make "advanced" use of the MPS may not be 
worthwhile.  It is therefore important to cater to users at all levels and in 
all places, from installation notes to user documentation, library interfaces 
to memory pool classes, and also this the Model of Use!


FEEDBACK

The MPS is designed to be able to meet a wide range of requirements.  With this 
flexibility comes the problem of specifying those requirements in such a way as 
the system can attempt to meet them.  To some extent, the MPS is designed to do 
just that, and the MPS Interface is designed in terms of user requirements, 
with pools providing specific behaviour.  This is intended to be enough to 
satisfy trivial and basic use.  However, the system has very limited knowledge 
and we can't expect it to be able to adapt to all situations automatically.

The user's requirements must somehow be extracted and encoded in the system if 
they are to be met.  The MPS Interface forces the client to specify some, but 
to extract a full set we must invite the user (who is possibly not conscious of 
all the requirements himself) into a feedback loop (see figure 2).


Figure 2. Measurement and user feedback

The user needs to understand the interaction between his program and the memory 
manager at intermediate or advanced levels of use.  This understanding will 
enable him to modify his program's use of the MPS to meet his requirements.  
Products for intermediate and advanced users must therefore supply analysis 
tools which allow the user to make observations about the interaction.

