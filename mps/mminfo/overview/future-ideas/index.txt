                      IDEAS FOR FUTURE MPS DESIGN
                         overview.future-ideas
                             incomplete doc
                           gavinm 1997-12-12

INTRODUCTION

.intro: This is a list of functionality that we have mentioned in the past and 
have designed or discussed to some extent, but not actually implemented, or 
only implemented in some experimental fashion.

.source: This list originally came from a brainstorm in the Pool Hall on 
1997-11-19 (see mail.drj.1997-11-19.16-21).  An earlier vesion of this document 
was once called "design.mps.future".

.purpose: The intention of this document is that these ideas should be:
  - Categorized;
  - Prioritized;
  - Expanded on;
  - Referred to.


IDEAS

.trace.multiple: multiple simultaneous traces

.gen.strategy: better generational strategy

.seg.condemn: better condemning of buffered segments. [most (all?) pool classes 
now only condemn the portion of the buffer from init to limit though there are 
bugs in this area.  drj 1998-10-30 surely I mean "from base to init"?  drj 
1998-11-24]

.format.debug: debug methods in the object format (e.g. "trashed reference 
discovered by GC", and "reference not yet initialised" from 
mail.ptw.1997-05-12.12-46), and "is this a likely object", "scan backwards for 
object header".

.scan: scan optimisations
  .scan.partition: partition objects of different types into different pools
  .scan.pair: reorganise / duplicate code in scanner so as to capitalise on the 
observation that all dylan objects are pairs / vectors / the same.
  .scan.special: more specialised pool classes (probably not necesary with 
specialised formats).
  .scan.once: Don't "overscan" so much.  When a partially full segment is 
scanned the amount scanned is not remembered, the segment may become grey again 
(by allocation) and rescanned; the previously scanned stuff will be scanned 
again.  See mail.drj.1998-01-26.11-40 and others in thread.

.fix.three: Reorganize the fix protocol so that MPS_FIX1 can be applied to 
non-references (ie _before_ the dylan tag test because it is believed to be 
fast / more discriminatory).  Proposals include splitting mps_fix into 3 
parts.  See mail.pekka.1998-02-04.16-48.

.fix.unrank: Reorganize the fix protocol so that the pool specific fix methods 
don't have to switch on rank for every reference.  This probably involves 
something like selecting a rank specific fix function before starting a piece 
of scanning.  See mail.gavinm.1998-04-14.13-58 and the ensuing huge mail 
discussion (Subject "Tony's Resolve/Preserve proposal").

.ref.ambig: better handling of ambiguous references (partly implemented in that 
AMC uses a nail board; only the objects with ambiguous references to their base 
address are preserved).

.blacklisting: Blacklisting and dynamic blacklisting.  Some zones and address 
may be very common when scanning ambigous references.  Sometimes we will be 
able to prove that they are not genuine references.  We should avoid those 
zones and adresses for allocating GCed objects (because the bogus ambiguous 
references will slow us down and may cause over conservatism by retaining 
garbage).  E.G. perform a collection when no objects have been allocated (but 
the roots have been declared) any ambigous references found cannot refer to 
managed objects so they must be bogus references and the areas they refer to 
can be blacklisted.

.stack.exact: Scan the stack more exactly. Perhaps only scan the top frame 
ambiguously, which avoids the need to synchronize each thread at "gc-safe 
points". See mail.andys.1999-01-22.11-20(0), mail.andys.1999-02-16.13-58(0), 
mail.andys.1999-04-19.09-21(0) and following extensive discussion on those mail 
threads.

.counters: counters (survived, copied, scanned, fixed, etc) (partly 
implemented, partly usable from a debugger, less partly usable from telemetry)

.cache.snapout: "snapout" cache, for avoiding calls to PoolFix in out-of-line 
calls to fix.  In fact could cache nailings as well as snapouts. If we adopt 
the Resolve/Preserve proposal (see .fix.unrank) then the cache should be be a 
preserve cache.

.cache.greylist: greylist cache, ie, instead of incurring a two word penalty 
for every segment (so that all grey segments can be kept on a list), have some 
sort of cache that is filled by scanning the segment table.  As pekka observed 
(where?) pools like AMC would want to add entire segments into the cache at 
once, mark and sweep pools would add single objects at a time.

.nursery.move: Move the nursery to a different zone for each collection (cycle 
through a set of zones).  This means that objects in higher generations which 
reference nailed objects in the previous but no objects in the new nursery will 
not get scanned (by the usual refset summary arithmetic).  The experimental 
work on this is described in mail.richard.1997-10-30.12-21.

.page: page-level:
  .page.read-write: read- and write- barriers
  .page.remembered: remembered sets
  .page.scan: scanning
  .page.large: copying of large objects (richard's copying objects by "sucking" 
idea)

.write-barrier: write-barrier collector.

.interior-pointer: interior pointers, that is, pools and formats which 
understand them.

.pool.conservative: conservative pool (probably write-barrier if incremental).

.low: low memory messages / call backs.  and low-utility and long-pauses  [the 
reservoir, see design.mps.reservoir, mps_reserve_with_reservoir_permit, and so 
on, provide some degree of low memory handling.  drj 1998-10-30]

.footprint-control: memory footprint controls, that is, stay under this amount 
of memory.

.awareness: awareness of current memory usage, space overhead, time usage and 
overhead, etc (so they can affect current strategy).  Very crudely implemented 
in vmw3.c (VMSetCollectionStrategy).

.root.prot: root protection (implemented once, but abandoned) [Now implemented 
in the trunk. - Pekka 1997-12-15]  Write protection for remembered summaries of 
roots is implemented.  Read barriers for incremental scanning of roots is not 
yet implemented.  This probably involves a unified shield for segments and 
roots (and other protectable objects?).

.arena.flex: flexible arena, that is not grabbing 1Gb of address space on 
boot-up, being able to manage more discontiguous chunks of memory.  [VMArena 
Chunks, see design.mps.arena.coop-vm(0), helps here though there are still some 
concerns.  drj 1998-10-30]

.seg.pref: preferenced segment allocation, the interface between the arena and 
the pools by which pools indicate "where" (usually what zone) they want 
segments needs to be cleaned up and improved.

.large: handle large objects better, i.e., probably without copying them a lot 
and without them causing large pauses.

.zombie: A mechanism to make mps_pool_destroy safe in the presence of GC.  Also 
explicit object freeing and finalization with explicit freeing.  This may 
involve a "zombie pool" to manage address space but not committed RAM.  See 
mail.dsm.1996-02-14.18-18.

.debug.aids: Features to help customers debug problems, especially manual MM 
problems.  See mail.richard.1997-10-21.14-02.  For debug aids in fwmem (EP-Gui 
-derived HQNframework), see also mail.richardk.1998-03-27.16-08 and 
mail.richardk.1998-04-01.13-51.  Also, design.mps.object-debug.

.free.multi: Multiple free interface, such as "deallocation points" in 
mail.ptw.1997-12-05.19-07.

.locks.client: Use a client provided locking interface.  Dylan have a locking 
substrate that is superior to Win32 CRITICAL_SECTIONs.

.map.crossing: Add a crossing map.  Essentially this maps from any old address 
to an address suitable for using as the start address for scanning (a poor 
implementation would return the base address of the containing segment).  This 
is needed to avoid lots of skipping when we have larger segments and page-level 
scanning.

.barrier.software: Software barriers.

.refset.time-stamp: The write-barrier in combination with timestamps can help 
prevent us scan pages needlessly.  Pages which haven't been updated can't 
possibly refer to pages created since the update.  See 
mail.drj.1997-05-06.11-13 and mail.ptw.1998-10-29.21-23 (A).

.train: A collector using the train algorithm.  See 
mail.tony.1998-12-11.14-26(0)

.buckets: Don't always promote, keep multiple buckets per generation.

.page.recent: Try to scan recently touched pages first: those with no 
write-barrier, tight integration with Linux pager or a Mach pager.

.doc.tools: Tools to support extraction of documentation from structured 
comments.  This may help us to locate gory detailed design both near the code 
and in a more structured document.  See mail.ptw.1997-12-05.12-28.

.idle.gc: Perform GC in idle-time. See mail.pekka.1998-08-26.11-51(0) and 
following discussion.

.save-image: Provide support for save-image for Lisp. See idea.save-image(0).

.persist: Provide support for persistence (particularly for Dylan) using 
.save-image and also using ranks as a mechanism for determining a sub-graph. 
See idea.persistence(0).

.real-time.gc: Support garbage collection in "real time". We had somem 
preparatory meetings about this, but didn't get too far. See 
meeting.real-time.1999-05-13(0) and meeting.real-time.1999-05-20(0).



