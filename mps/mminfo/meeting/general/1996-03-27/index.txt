      NOTES FROM THE GENERAL PROJECT MEETING, 1996-03-27 TO 04-03
                       meeting.general.1996-03-27
                             incomplete doc
                           richard 1996-04-15

Agenda for ptw
- Decide finalization design and interface.
- Meet Clive Harris to discuss possible products.
- Rôles for the year.
- Design briefings.
- Discuss Dylan object representation requirements (with Kim?)
- Controls / measurements
- There should be some way of detecting object format versions (i.e.
structure marking).  We could do that this time around.

Tony
- Need to resolve legality of exact references outside the space.

EP detailed plan
2. Evaluation (up to May 15th)
- Fixed arena
 - VM arena + hack EP VM based on ANSI VM
- MV pool (for TR and DL membanks)
- Size-related stuff
 - low-memory callback
  - low-utility callback?
 - size accounting
- Debugging
 - fenceposting
 - tagging?
 - mapping?
3. Equivalent (up to July 1st)
 - At this stage we suspect space/frag. problems rather than speed
problems, so these will be studied.
 - Proper real-memory arena (maybe with extensions).
  - placement of segments
 - Measure DL usage and design DL pool class.
 - PostScript® VM pools with save/restore?
4. Final
 - PostScript® garbage collection.

Admin Rôles
- Bug/Issue Tracking
- Documentation
- Minutes
- Process development
- Process administration
- Procedure documentation
- Web page development
- Database design, development, and administration

Product Definition
- What is going to be in the product
 - Memory Manager
 - Tools
  - Which tools?
  - What do they do?
  - What do they look like?
  - How are they supposed to be used?
  - How are they implemented?
   - Measurement protocol.
  - Prototypes of tools.
 - "Model of use" description
  - Feedback loop
  - Levels of use
   - These should have names which encourage hackers to invest time in
them.  ("Rookie … Elite").
 - Outline user manual
 - Brochure
 - Business plan
 - Support plan
 - Development plan

Tasks
 April
  - Brainstorm ideas
  - Requirements analysis
  - Lists of things
   - pools
   - tools
   - documents
 May
  - Drafting product definition
 June
  - Circulate through management, feedback, improve
 July
  - Defintion approved (with luck)


Object format policy

An important purpose of the format is to isolate development.  Don't forget
that we can redesign and specialize the format once Dylan settles down.  A
specialized format can be much more efficient.  Also, we can release
collectors which are specialized on a particular format version.  So, don't
forget that it may not be entirely critical what exactly we decide right
now for the container format.  It is designed to allow flexibility at small
effort.


Kim's issues remaining (Tuesday)
- Stetchy vectors
 - Are stretchy vectors needed at rep. level?
 - Do we scan beyond fill pointer?
 - Do we clobber beyond the fill pointer?
 - Clarify current implementation status.
 - Specify time limit.
- Multiple variable parts
 - Propose using "stretchy vector" rep. (rename it?)
- Negative offset slots
 - We have a design.
 - Need to raise costs of implementation.
 - Need a final word on the requirements.
- Additional slots in wrappers
 - Too many penalties:
  - Most wrappers don't need to be registered currently.
  - Registered wrappers are more expensive than ordinary objects.
 - Doesn't outweigh double indirection cost unless it's pretty frequent.
 - Can these slots be as constant as classes?
 - Larger wrappers mean poorer scanning locality, however.
- Parameterizing the code
 - While we're maintaining the code we will be glad to resond to requests
for changes (tagging,etc.) and will do whatever is necessary to allow
maintenance if and when it is handed over.
 - What changes will be required and when.
- Finalization
 - Apple's scheme is dead hard with our general framework.
 - The GC is _not_ better equiped to find cycles than the mutator.
 - The random-order scheme and/or notified weakness is easy.
 - Need to negotiate what is really required.

Marketing

Dylan
Basic platform in Win95 on August 15th.
Beta Jan 97
Production July 97.

- Competetive analysis
- Functional description
- Profile of customer(s)
- "Model of use" description
- Cross-platform.
- Strategy for tools
  - Delphi?
  - Dylan won't be ready.
- Java/Sun deal.
- Clive available within three weeks.

Design Summaries
 Functional
 - Strategy
 - Scheduling
 - Weakness
 - Finalization
 - Wrapper pool
 - Preferenced allocation
 - Generations
 - Remembered sets
 - Metering
 - Large objects
 - Debugger liaison
 - Error recovery
 Attribute
 - Pauses / latency
 - Total CPU
 - Memory overhead
  - Static
  - Dynamic
 - Control

Fix (roughly)

new = status(ref, &base, &limit);
if(new)
  *ref = new;
else {
  size = offset(base, limit);
  do {
    new = reserve(buf, size);
    memcpy(new, base, size);
    buf->grey |= old->grey | ss->traces;
  } while(!commit(buf, size));
  fwd(base, limit, ref, new);
}

 - Container Format Diagram 
 - Layered Deliverable Structure 

 - Measurements 

Measurements


Distribution of pauses.  This is of dubious usefulness to the end user.

Mark/Space ratio with granularity T.  This is an interesting plot because it 
shows how much the mutator can expect to progress within a certain time 
interval.  It also expresses the overhead of memory management within any 
particular amount of time.



Mark/Space ration over the lifetime of the program.

The data needed to support these measurements:
  1. Entry/exit times.  Sub-entry/exit with reasons.

Allow the user to set the closure of a utility function from the tools by 
defining acceptable levels, etc.

Need to support several levels of use.  (c.f. HyperCard user levels)
1. Plug in and forget it.
2. Look at behaviour in terms of client requirements.
3. Adjust utility function in terms of client requirements.
4. Investigate reasons for current performance. (inc. deslugging)
5. Adjust client code.

It is critical to make the causal link between the behaviour of the memory 
manager and the structure and usage of the client code.  This is our unique 
angle.

We must think about what the client is doing with the interface that could 
cause the behaviour.  Is it a big root, inappropriate choice of pools, etc?  
This information must be fed back as directly as possible.  It might be 
possible to derive a lot of possibilities by examining the interface case by 
case.

The user manual can support the levels of use directly in chapters.  Chapter 1 
is "Installation", chapter 2 is examining behaviour, etc.

It would be good to provide the user with interactive feedback on the 
consequences of his decisions.  This would require knowledge of the 
characteristics of each pool (on line) and some predictive ability.

The client interface could be like a laboratory for experimenting the memory 
management strategies and parameters.

We must also think about the relationship between _our_ client and _his_ 
client.  If his client rings up with a slug he can get a trace downloaded, 
analyse it, and provide a solution.

Differentiate the tweaking of "parameters" and of the mutator structure.

Extensions to format:
1. Equivalence class of object.
2. What to display and in what format.
3. Ability to examine corrupted heap (robust format).
4. Release versions of the format should be defensive.

Again, the relationship between our client and his client is important.  Can we 
provide support for debugging his code when he ships it?  What reports get sent 
back?

 - Negative Slot Diagram 
 - Segment Structure Diagram 


ATTACHMENTS
   "Segment Structure Diagram"
   "Negative Slot Diagram"
   "Measurements"
   "Layered Deliverable Structure"
   "Container Format Diagram"

