               NOTES FROM MM GENERAL MEETING, 1997-02-05
                       meeting.general.1997-02-05
                             incomplete doc
                           richard 1997-02-05

INTRODUCTION

.intro: Richard Brooksby <richard>, Nick Barnes <nickb>, and David Jones <drj> 
met to discuss various issues arising from Nick's work on MM/EPCore.


AGENDA

1. Using the MLWorks strategy in the MPS.
2. Configuration of the MPS.
3. Merging MM/EPCore work into the trunk.
4. Nick's description of the "generational hypothesis".


ACTIONS

Create a request to implement configuration changes.


USING THE MLWORKS STRATEGY IN THE MPS

Gen params:
  size (bytes) -- current volume of data
  original size (bytes) -- total data originally allocated
  mean time of birth (alloc bytes)
  size of entry list
  size of statics

Actions on each generation:
  promote
  merge
  collect in place
  nothing

Costs:
  scanning other * scan weight
  scanning to-space * scan weight
  copying to-space * copy weight
  transient space overhead * transient space weight

Benefits
  space recycled * recycle weight

Scan and copy weights come from measurements.  Others are guessed.


CONFIGURATION

(Discussion caused by problems with protection module under ScriptWorks.)

Build is parameterized by: platform, variety, product (new) and module list.

Parameters are currently in mpmconf.h
Variety is in target.h
Modules aren't controlled (except arena)
These things should be done in one place.

Rules:
1. #ifdef isn't allowed in .c files (in functions, etc.)
2. Module selection #ifdefs may vary the concrete interface but not the 
abstract one.  The usage of the module remains the same.  e.g.

  #ifdef PROTECTION
  void ProtSync(Space space);
  /* more decls. */
  #else /* PROTECTION not */
  #define ProtSync(space) NOOP
  /* more decls. */
  #endif /* PROTECTION */

or

  #if defined(PROT_FOO)
  typedef struct ProtStruct {
    int foo;
  } ProtStruct;
  #define ProtSpong(prot)  X((prot)->foo)
  #elif defined(PROT_BAR)
  typedef struct ProtStruct {
    float bar;
  } ProtStruct;
  #define ProtSpong(prot)  Y((prot)->bar)
  #endif

but never

  #if defined(PROT_FOO)
  void ProtSpong(Foo foo, Bar bar);
  #else
  int ProtSpong(Bar bar, Foo foo);
  #endif


MERGING MM/EPCORE BRANCH INTO THE TRUNK

Changes (to the MPS):
  1. client arena "arenacl"
  2. preferenced segment allocation
  3. preferenced pool creation

PoolMV has changed most to use preferencing and place segments high or low.  
This is a preference on the entire pool, and that influences placement of all 
segments in that pool.

Nick's list of changes:

> Here's our notes of the changes on MMdevel_sw_eq:
> 
>   SegAlloc, PoolSegAlloc changed to accept a SegPref: amc.c, arenavm.c
>   
>   PoolInit takes a PoolPref, and consequence changes to pools: amc.c
>   
>   Argument order change in mps_pool_create, PoolCreate, PoolCreateV, &c: 
amcss.c
>   
>   Arena interface grows with ArenaExtend, ArenaRetract, SegPrefCheck,
>    SegPrefDefault, SegPrefExpress: arenavm.c
>   
>   
>   New: arenacl.c
>   
>   Removed junk: mpmconf.h
>   
>   New PoolPrefStruct, SegPrefStruct, ArenaStruct: mpmst.h
>   
>   New pointer and kind types and kind constants: mpmtypes.h
>   
>   New abstract pool_pref_t type, new integral type kind constants, new 
mps_space functions, pool pref functions: mps.h
>   
>   Removed: mpsvmrm.h
>   
>   New consistency checks and interface functions: mpsi.c
>   
>   ** mps_pool_pref_create: Error path is ugly
>   ** mps_pool_pref_express: Needs SpaceEnter and SpaceLeave
>   
>   Pool pref functions: pool.c
>   
>   poolmv.c
>   
>   ** near and far pools specified by the preferences have to be MV pools
>   
>   ** our existing pools can't make use of adjacency of segments: some
>      sort of SegMerge operation would reduce fragmentation here.
>   
>   pool pref stuff is new.
>   
>   PoolSegAlloc retried with smaller segment size if it fails
>   
>   vmrm: got rid of mpsvmrm.h and functions it declared

All present agreed that the "preference" mechanism is ugly and unwieldy.  
Richard suggested an alternative based on "keyword" arguments implemented using 
C varargs.  [Other people have thought of this before, I might add.  richard]

For example:

  foo(bar, baz, KEY_END);  /* empty arg list */
  foo(bar, baz, KEY_SPONG, spong_arg, KEY_WIBBLE, KEY_END);
    /* note that keys can have different numbers of arguments */
  format("Hello: %d", baz, KEY_SPONG, spong_arg, KEY_END, number);
    /* ordinary varargs come after KEY_END */

The KEY macro expands to a constant with various fields:

  .--------------------------------.
  |ver|flags|len|     unique       |
  `--------------------------------'

where

  ver is a version code, indicating the format of the key constant, for
      binary compatibility

  flags is various flags, including a flag indicating whether the keyword
      can be ignored if not understood (for upward compatibility)

  len is the number of args that follow, which must all be one word each

  unique is a unique bit pattern identifying the key

e.g.

  #define KEY_FOOD  ((Key)0xCE12F00D)

where

  CE   is the version
  1    is a flag indicating that food is ignorable
  2    is the number of arguments
  F00D is the unique

An unresolved question is whether keys would be global (reusable, like symbols) 
or specific to each function.  These options need to be weighed up.

The intention is to use this kind of interface both internally and externally, 
by the way.

The ignorable flag means that if the key isn't recognized then return it can be 
ignored.  (Otherwise return ResUNIMPL.)  For example, if a future client 
version passes a key which is supposed to force alignment then the 
implementation must say "sorry, I don't know what you mean" rather than just 
ignore the keyword as if it were a mere preference.

Some keywords express preferences, and can safely be ignored in any case, 
although that might affect performance.  This is where keywords subsume 
preferences.  These keywords would have the ignorable flag set.

The same unique would not be reused with different flags or numbers of 
arguments.

This design should be developed further and discussed before we consider 
changing anything.  However, this does indicate that it's not a good idea for 
Nick to merge his changes yet.

Here's Richard's quick hack at a keyword argument parser template:

Res Foo(int foo, int bar, ...)
{
  va_list args;
  Bool eat = FALSE;
  Pointer eat_p;
  Size eat_s;

  va_start(args, bar);

  for(;;) {
    Key key = va_arg(args, Key);

    if(key == KEY_END)
      break;

    switch(key) {

      case KEY_EAT: {
        AVER(KeyArgs(KEY_EAT) == 2);
        eat = TRUE;
        eat_p = va_arg(args, Pointer);
        eat_s = va_arg(args, Size);
      } break;

      /* etc. */

      default: {
        Size i;
        if(KeyVer(key) != MY_KEY_VERSION)
          return ResUNIMPL;
        /* could act on older versions */
        if(!KeyIsOpt(key))
          return ResUNIMPL;
        for(i = 0; i < KeyArgs(key); ++i)
          (void)va_arg(args, Word);
      } break;
    }
  }

  /* deal with any extra varargs */

  va_end(args);

  /* actually get on with the function */

  return ResOK;
}


GENERATIONAL HYPOTHESIS

Not done.  Keyword argument discussion was too interesting.

