                    MINI-PRODUCT DISCUSSION MEETING
                       meeting.general.1997-10-06
                               draft doc
                           richard 1997-10-15

INTRODUCTION

.intro: Richard Brooksby and Tucker Withington met to discuss the scope of the 
"mini-product".


GOALS

.goal.background: The idea is to take advantage of the opportunity to put a 
CD-ROM in the back cover of the MM Book (see project.book).  Chris Cox (PMM) 
would like to establish Harlequin MM in the market and put Geodesic Systems 
(makers of Great Circle) at a disadvantage.

We propose the following goals:

  .goal.enhance: Enhance the value of the MM Book.

  .goal.attract: Attract bespoke/contract MM business to Harlequin.

  .goal.increase: Increase sales of the full MM Product, when available.


NOTES

.outline: Richard and Tucker went through the examples in Tucker's book outline 
[reference?] in order to work out what software might be good to support the 
book (.goal.enhance).


Copying and Sharing

.problem: Many of Tucker's examples concern copying and sharing of data 
structures.  Many C++ programmers put object within other objects and do 
shallow copies (effectively keeping reference counts at one) when they could 
usefully share structure.  The problem is that sharing complicates the liveness 
and makes it difficult to free objects correctly.  Of course this problem goes 
away with a garbage collector.

.struct: Note that this is a structural change in the program, and not 
something that is fixed automatically by a drop-in GC like Great Circle.  There 
will still be a lot of duplicated objects in the code, even though they might 
be objects-within-objects, leading to a larger heap size than necessary.

.assignment: The default assignment operator in C++ will do a member-by-member 
assignment.  (The compiler might optimise this to a memcpy.)

.style: Once people are convinced that GC is good they can change their 
programming style to eliminate "intentional leaks".  To do this we need to 
encourage sharing.  If there are lots of objects which are equal (but not ID) 
then they are potentially sharable.  Could that be detected automatically?

.hash: An O(n log n) algorithm: 1. Pass over the heap doing an equal-hash on 
each object, and storing a map from ID to equal-hash (which is used in the 
recursive equal-hash).  2. Invert the map to find the IDs of objects with the 
same equal-hash.  3. Check those objects to see if they are actually equal.

.pop: Also, could do population survey of heap.  Find the frequent classes.  
Find calls to the constructor of that in the heap.  Then winnow out the deletes 
that are no longer necessary.

.log: Use event logging to do garbology: study the objects that are reclaimed 
-- their classes, and similarity -- to work out if it is possible to share.  If 
source locations of garbage objects are known then it would be possible to 
pinpoint places in source code which is creating it all.

.libs: How much allocation is being done by Windows class libraries etc.?  Is 
there anything that can be done about it?  If not, perhaps we should give some 
tools to help cope with that.


Cost of Allocation

.cost: One of Tucker's other main examples concerns the cost of allocation, and 
finding implicit allocation.  The example is a kind of strength reduction -- 
reducing consing in tight loops.

.growth: One way to find this might be to look at first derivitive of 
allocation rate at each location to find where leaks are coming from.  This 
could be especially useful if "steady state" is declared by the programmer.


Amortizing Cost

.amort: This involves reducing high peaks in the allocation rate, e.g. at start 
up, by spreading the cost of allocation and heap management.  Again, the 
differential might help (see .growth).


Uncollected Garbage

.uncol: This is the problem of objects which aren't used by the program but are 
still connected to the graph and so can't be recycled.

.trace: Could identify unused but connected stuff using tracer (see 
mail.richard.1997-08-14.12-14), then apply garbology tools to this "potential 
garbage".


Foreign Interface

.foreign: Tucker has a section for issues to do with foreign interfaces, but 
it's not fleshed out yet so we can't tell what tools might help.


Finalization

.final: We should supply a finalization interface if we want to demonstrate 
finalization.  To show it working we might need to be able to query 
finalization queue.


Modularity

.mod: To show the advantages of GC in modularity, just show how something like 
an immutable map is challenging to create abstractly without GC.  Show also how 
difficult it is to cope with data-dependent liveness.  No special tools would 
be necessary, unless it was to show the memory leaking.


SUGGESTED FORM

.form: The mini-product would consist of:

  - a fully conservative incremental GC for C and C++ with simple and limited 
interface;

  - tools to support the examples in the book.


LICENSING

.licensing: The software would be free for non-commercial use or for 
evaluation.  For commercial use the user would need to either purchase a 
commercial license, negotiate with Harlequin for custom work, or buy the full 
product.


WORK TO DO

.work: Perhaps two main pieces of work need to be done:

  .work.gc: make an MPS-based GC suitable for use with C/C++ but limited in 
some way,

  .work.tools: develop garbology tools based on the MPS.

.work.platforms: Should we limit the platforms, to make it easier?

To make the MPS-based GC we need:

  .work.gc.cons: fully conservative mark/sweep pool, like Boehm;

  .work.gc.roots: conservative root-finding code;

  .work.gc.interface: interface layer.  (May not need to bother with edge 
cases, provided we explain.)

.act.valuation: To meet the first goal, Tucker needs to decide what is of value 
to the book.  Need to look through the list of examples and see what needs to 
be written to support them.

.idea.boehm: Maybe we should put the Boehm GC on the CD-ROM.

