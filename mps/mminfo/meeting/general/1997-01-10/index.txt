              NOTES FROM THE MM DESIGN MEETING, 1997-01-10
                       meeting.general.1997-01-10
                             incomplete doc
                           richard 1997-01-21

INTRODUCTION

.intro: Richard Brooksby <richard> and Tucker Withington <ptw> met to elaborate 
the design of the memory management tool in order to estimate the effort 
required for implementation.  The meeting lasted approximately three days: 
1997-01-10, 13, and 14.


ESTIMATES

.est.week: All estimates are in weeks.  .est.prog: All estimates assume a 
competent programmer with no other commitments.  .est.dev: All estimates assume 
development in C++ on Windows using Microsoft development tools and libraries.  
.est.port: Porting effort is not included.  .est.prod: Estimates are purely for 
R&D and do not include "productization" overheads such as HCI involvement, QA, 
documentation, manufacturing, etc.

.phase.hack: Initial Hack

  Read data file                                    1
  Display something simple                          1
                                                  ---
                                                    2
.phase.bare: Bare Necessities

  Simple log manipulation                           1
  Simplest three queries and plots                 13
  Zoom tool                                         1
  Simple user interface                             4
  Required extra annotations in the MPS             1
  Filters                                           4
                                                  ---
                                                   24
.phase.product: Product

  Inspection of plot features (event lister)        4
  Handling large datasets / database substrate      4
  Client annotation                                 2
  Three more queries and plots                      6
  Improved user interface                          12
                                                  ---
                                                   28
.phase.future: Future

  Configurable plots                             8-12
  Snazzy user interface                            12
  Connections (live plots)                         10
  Remote control of MPS                             6


DETAILS


Handling the Log

.fig.log-index:

 - Log Indexing Diagram 

The prototype tool reads the entire log into an internal database.  This will 
be infeasible if the log is hundreds of megabytes long, containing millions of 
events.  A possible solution is to emit the log in chunks of fixed size, so 
that it contains frames, each with a header, and can be accessed at random.  
The tool can build up an index of the log mapping times to file positions, as 
shown in .fig.log-index.  Each frame will have a header with a time-stamp and 
other summary info.

The granularity of the index can be varied according to the level of access 
required.  It could be built up lazily when the user zooms in on areas of the 
data.  A multi-level index could be used.

Queries on the log should use a uniform interface.  The interace suggested is 
based on the abstract "reduce" operation:

  reduce function accumulator zoom start end log -> results

where function takes an accumulator value and an event and returns a new 
accumulator.

Reduce applies the function to events in the log between the start and end 
times, accumulating a result.  The results are emitted in a vector of length 
(end - start) / zoom, i.e.

  #[(t0, r0), (t1, r1), ...]

where t0 is the actual time of the first result, and r1 is the value of the 
accumulator at that point.

The reduce layer could cache results and base future results on cached 
results.  One obvious optimization is to avoid rescanning the log when the plot 
scrolls forward or backward in time by a small amount.

Reduce would have to return some sort of indefinite stream-like object in order 
to cope with a live connection to the producer of the log.

---

UI tools
http://www.quinn-curtis.com/~quinn/
http://www.zinc.com/

---

TOOL ANALYSIS
richard, ptw; 1997-01-10

Goal: Estimated effort required to produce various product quality tools.
Stages: analysis/design, implementation, QC, beta testing

Problems with prototype
  - not native look&feel  ->  native UI based on accepted tools
  - scale of data: prototype cope with 10K events (why?), 10M events
  - more tools: zoom, inspect
  - more plots: store composite plots, make own
  - more queries: based on new event types such as by type, etc.
  - connections: network, shared memory, file-based
  - filtering events, data reduction, control of MM
  - client annotation (requires dev. in the MPS interface)
    - naming MM objects
    - creator/backtrace
    - type from debug info
    - naming allocations

Imagine starting implementation from scratch in C++ or Dylan.  (For internal 
use we should continue to play with the prototype.)

Hack something up
  - read data file at all
  - one simple plot

Essentials -- external prototype
  - parse and deal with data file, including interface to large data set 
handling
  - approximately three most useful queries and plots (not configurable)
  - zoom
  - filters: by type etc. (using model)
  - basic naming of MM objects
  - simple UI
  - more event types emitted from MM, better log file handling, etc.

Next level
  - actually handle large data sets
  - inspection of plot features
  - client annotations
  - next three most useful plots (still not configurable)

Next, maybe?  Or choose between:
  - configurable plots
  - connection types
  - control of MM
  - snazzy UI

More ideas:
  - event lister with filters, e.g. events relevant to _this_ object.

ATTACHMENT
   "Log Indexing Diagram"

