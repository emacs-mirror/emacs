NOTES FROM PROJECT OVERVIEW PRESENTATION BY RICHARD BROOKSBY, 1995-10-03
                       meeting.general.1995-10-03
                               draft doc
                             rom 1995-10-09

INTRODUCTION

.intro: Richard Brooksby presented an overview of the Memory Management Project 
at Longstanton House on 3 October 1995.  This document consists of notes from 
the presentation.

ATTENDEES

The audience for the presentation included the following:
- Members of the Memory Management Project (David Jones, David Moore, P. Tucker 
Withington)
- Members of the Dylan group (Andy Sizer, Tony Mann, Keith Playford, Paul 
Haahr, Nosa Omorogbe, Scott McKay, Jonathan Bachrach, Peter Benson)
- Members of the EP group (Paul Butcher, Andrew Innes, Andy Cave)
- Bob Mathews

Some members of the Dylan and EP groups did not attend the entire meeting.

GOALS

Richard began by summarizing goals for the project as a whole and for the Dylan 
and EP clients.

Project Goals 

.goal.general.revenue: Make products for sale by Harlequin.
.goal.general.internal: Provide solutions for other groups within Harlequin.
.goal.general.central: Reduce duplicated effort within Harlequin.
.goal.general.quality: Improve the quality of solutions within Harlequin.
.goal.general.image: Broaden and improve the image of Harlequin.

Goals for the MM Dylan Client 

.goal.dylan.provide: Provide MM client for Dylan.
.goal.dylan.compete: Promote Dylan in the marketplace.
.goal.dylan.improve: Improve the system.

Goals for the MM EP Client 

.goal.epcore.protect: Protect ScriptWorks from future failure due to the 
increasing reliance of PostScript jobs on garbage collection.  GC is a 
requirement of PS level 2.
.goal.epcore.downsize: Enable "moving EP market down".  Reduce size of machine 
needed to run ScriptWorks.  (Yoryos mentioned print-servers, embedded 
controllers.)
.goal.epcore.compete: Remove the risk of bad publicity due to lack of GC.
.goal.epcore.maintain: Reduce the mainentance burden on EP.
.goal.epcore.perform: Increase the performance of ScriptWorks.
.goal.epcore.relate: Improve relationship and promote communication between SP 
and EP.
.goal.epcore.improve: Improve the general MM system for other clients.

PRIORITIES

Richard next reviewed priorities for the EP and Dylan clients and for external 
products.  The priorities for EP and Dylan have emerged from meetings between 
MM project members and members of the EP and Dylan groups.

Priorities for the MM EP Client 

The following priorities have been approved by Yoryos Yeracaris:

.prio.epcore.1: Reliability.
.prio.epcore.2: Equal performance to existing system.
.prio.epcore.3: Garbage collection of PostScript VM.
.prio.epcore.4: Debugging assistance.
.prio.epcore.5: Performance enhancement.
.prio.epcore.6: Downsizing of ScriptWorks.

Priorities for the MM Dylan Client 

The following priorities have been approved by Andy Sizer:

.prio.dylan.1: Reliability.
.prio.dylan.2a: Acceptable performance.
.prio.dylan.2b: Adaptability to new requirements.

Priorities for External Products

Richard noted that the project plans to  MM project has no product marketing 
manager.  The following requirements are speculative and should be considered 
unordered.

.prio.product.1: Performance.
.prio.product.2: Adaptability.
.prio.product.3: Flexibility.
.prio.product.4: Reliability.

SOLUTIONS

Pool system
A system open to observation and debugging
Component framework
Freestanding implementation making conservative use of the C language
Evolutionary development
Process for quality, including information system
Appropriate optimization
Simplicity

ARCHITECTURE

Pool System




         Pool Classes

         malloc/free
             -------------- first fit
            |
client --------- | ---------  MPM ----------- GC
   |         |
      interface          -------------- debugging
         alloc
          free

Discussion of Pool System

Pool classes represent policies for managing memory.
The Memory Pool Manager (MPM) manages pool classes.

Q.  Can the system accommodate multiple address spaces?
A.  It could.

Q.  (Paul Butcher)  Can you have a mixture of pool classes managing a given 
space?
A.  Yes.

Q.  What if you have a pointer from a malloc/free pool to a GC pool, as when 
using an FFI?
A.  Such GC objects are treated as roots (see later GC discussion).

Observing and Debugging

 -------->
library --------> comms. ------ debug ------- visualization
 -------->    |
    |      ----------- analysis
    |         |
    ------------- developer -------------------

Pools, Arena, Space


Space --       Arena Pool Class     Arena Address Space
   |   |      |        -----------  ------------------- -
   |   |      |       |   | ---> |    | |  |
   |   |      --->   |     Pool | | |    | |  |
   |   |        |   -------- | ---- |    | |  |
   |   |        |   |       | | ---- |    | |  |
   |   |        |   |       | |  | | ---------  | |  |
   |   |        |   -------- |     ------ | --> |   Segment | | |  |
   |   |         -----------     | | | ---------  | |  |
   |   |   alloc/free      | | |    | |  |
   |   |          | | |    | |  |
   |   |         -----------     | | |    | |  |
   |   |        |     Pool |    | | |    | |  |
   |    -------> |    -------- |    | | |    | |  |
   | alloc/free  |   |        |- |-- | | ---------  | |  |
   |        |   |        |- |-------- | --> |   Segment | | |  |
   |        |    -------- | | | ---------  | |  |
   |        |     Class info | | |    | |  |
   |         ----------- | |    | |  |
   |      | |    | |  |
   |         ----------- | |    | |  |
   |        |     Pool | | |    | |  |
     -------->  |    -------- | | | ---------  | |  |
  alloc/free  |   |        |- |-------- | --> |   Segment | | |  |
         |   |        | | | | ---------  | |  |
         |    -------- |<--- | --- | ----------------- | ----|  |
         |     Class info | | |    | |  |
          ----------- ---> |    | |  |
       ------------------- -

Discussion of Pools, Arena, Space

An area is a range of contiguous addresses in memory.

The arena area is a range of addresses reserved and used by the memory 
management system.  The addresses are usually, but not necessarily, contiguous.

Pools are implementations of policies (pool classes) for managing memory.  A 
pool provides interfaces for:
 Allocating (alloc) and freeing (free) memory in the areas of memory it manages
 Obtaining information
 Controlling behaviour

A block is an area that  is managed by a pool.  Allocation returns a block.

A segment is a block in the arena.   Each segment has a minimum size of one 
page.

The arena itself is a pool.  It provides an alloc/free interface for segments.  
Other pools provide alloc/free for space within segments.  A pool can manage 
more than one segment, but a segment can be managed by only one pool.

The arena is partitioned into zones, one for each bit in the natural word size 
of the machine.  If the machine has 32-bit words, the arena has 32 zones.

Each arena address encodes the zone number in the middle of the address:

 ------------------------------------------
 |    |  |  |     |
 ------------------------------------------
  prefix   zone   suffix

A reference signature is a conservative approximation to a set of memory 
references.  A reference set is the concrete representation of a reference 
signature.  A reference set is implemented as a bit mask in which each bit 
represents a zone.  If the set includes a reference to a particular zone, the 
bit in the reference set that represents that zone is on; if a set includes no 
references to a particular zone, the bit that represents that zone is off.

A table provides a mapping from arena addresses to pools.

GC Tracing

Goal of tracing: to identify objects that are not garbage.

Dijkstra's colour model: each object is one of three colours:
 White: object is not known not to be garbage
 Gray: object is a candidate for scanning
 Black: object has been scanned (and is not garbage)

Procedure for tracing:
 (1) Colour roots gray.

 (2) while (there are gray objects)
  scan a gray object

  scan: Look for pointers in an object and fix them.
   Turn the object black.

  fix: If object is white, colour it gray.
   If object is gray or black, do not change colour.

 (3) When no more gray objects exist:
  Black objects are not garbage.
  White objects are garbage.

 Note: There are never pointers from black to white objects.

Incremental GC

Problem for incremental GC: how to maintain the invariant that there are no 
pointers from black to white objects.  If this invariant is violated, some 
white objects may erroneously be declared garbage (because black objects are 
not scanned again).

There are two primary methods of maintaining this invariant, one using a read 
barrier and the other a write barrier.  These are fully described in Wilson's 
survey.

Read barrier method:
 The mutator can see black objects and pointers to gray objects but cannot see 
white objects.
 Gray objects are read protected.  If the mutator tries to read a gray object, 
that object is scanned, and it is turned black.  The GC essentially scampers 
ahead of the mutator, which can never reach a white object.
 New objects must be allocated black or gray.
 The collector can move gray objects as part of the graying process.
 The read barrier typically protects a page.  When a fault occurs on that page, 
the entire page is scanned.

Write barrier method:
 Black objects are write protected.  When the mutator tries to write into a 
black object, either:
  (a) Colour the black object gray.
  (b) Ensure that the value written is gray.
 New objects can be allocated white.

Dylan's incremental GC will use the read barrier method, but with a few changes 
it could use the write barrier method.

Partial GC

It is possible to designate a set of objects to be collected.  This is called 
the condemned set.

The purpose of designating a condemned set is strategic.  We choose such a set 
in the hope of reclaiming as many dead objects as possible.  The goal is to 
maximize the benefit of the GC.

One method for collecting the condemned set is to colour all objects gray 
except those in the condemned set and then scan all gray objects to find 
pointers into the condemned set.

Scanning all gray objects can consume a great deal of time.  Reference 
signatures and reference sets can be used in very fast tests to reduce the 
scanning time.

For objects in the arena, one can tell from an address which zone an object is 
in.  If an entire zone is condemned, the address of an object can be used in a 
fast test to determine whether the object is in that zone.  This test can be 
used to avoid scanning all gray objects.

Specifically, there are two uses here for reference signatures and reference 
sets:

(1) Approximate the condemned set:
 Construct a reference signature for the condemned set.
 Check a reference to find out whether its zone is in the condemned set; if so, 
conduct a more accurate test.

(2) Construct a remembered set:
 Construct a reference signature for an object's contents.
 When scanning the object, first conduct a fast test to determine whether that 
reference signature intersects the condemned set; if so, "really" scan the 
object.

Equivalence-class induced multigraph

Object references form a graph.  It is possible to think of a partial graph of 
references as a block and to construct equivalent graphs of references among 
these blocks.  For instance, a page or a zone could be a block.  These graphs 
might form either partial or total orderings.

Example of use: each page might have a reference signature that represents 
pointers from objects on that page.

Example of use: if an object overlaps two pages but it can be proved that there 
are no live references to the part of the object that is on one of the pages, 
it might be possible to reclaim that part of the object in the course of 
reclaiming that page.

Generic GC

GC capabilities:
 (1) GC across pools with different GCs.
 (2) Multiple simultaneous collections.
 This could allow low-priority, large collections while high-priority, small 
collections recycle most memory.

General Scanning Mechanism

Each root, pool, and object has a conceptual scan method that knows how to find 
references to objects.

The scan method takes an object and a fix function.  It applies the fix 
function to the object's references.

 scan(object, fix)
  fix(p1)
  fix(p2)
  ...

 fix(p)
  if (isOld(p))
   (p -> fix)(p)

The fix function can go through the arena's table to find the pool that looks 
after p.  It gets the appropriate fix function from the pool.

The fix function depends on the kind of GC used.  A mark and sweep GC might set 
a bit; another GC might copy and forward the reference.

Collections

A collection is a temporal instantiation of a collector.

(1) Flip
 Decide what to condemn.
 Condemn.
 Colour roots of collection gray.

(2) Trace
 Scan.
 Fix.

(3) Reclaim

Dylan GC

Dylan uses an automatic mostly copying (AMC) GC.


 Group         Group Memory = Segment
   -------------  ---> -----------------------
   |   |  | |     |
   | limit   ---  | --------  |     |
   | init   ---  | ------------ | --> ----- -- -- |
   | segment -- | --------  | | | | / | | / | |
   |   |   | | | | | / | | / | |
   | s1   --- | -------- | --- | --> | --- | | / | |X | |
   |   |   | | | | | / | |X | |
   |   |   | | | --- | | / | |X | |
   |   |   | | | | | / | |X | |
   | s0   --- | -------- | --- | --> | --- | |X | |X | |
   |   |   | | | | |X | |X | |
   |   |   | | | --- | |X | |X | |
   |   |   | | | | |X | |X | |
   -------------  ---> -----------------------
         Col. Col.
           0   1


Cheney algorithm for copying:
 Until (the scanner reaches the end of new space)
  Copy an object to be scanned to new space;
  Scan that object;
  Move pointed-to objects to new space.

Strategy

Generational collection

   -------- |
   |  | |     -----
   |    Gen 2 | |     | |
   -------- | -----------------------------
  ^  |
  |  |       /|
   -------- |   ----- / |
   |  | |     --- | |   |
   |    Gen 1 | |     | | |   |
   -------- | -----------------------------
  ^  |
     |  |          /|         /|
   -------- |         / |        / |
   |  | |        / |       / |
   |    Gen 0   | |       / |      / |
   -------- | -----------------------------
      Time -->


Generation 0 fills and is collected to generation 1; that is collected to 
generation 2; etc.

Generalized generations

Can distinguish classes of objects
 Example: If pairs are assumed shorter-lived than strings, pairs can be 
collected more frequently than strings.
 Assume that pairs die in 2 seconds, on average.  A possible strategy is to 
stripe areas by allocation time and condemn 2 seconds after allocation.

Ranks: Ambiguity, Finalization, and Weakness

References can be partitioned into ranks, which determine the order of scanning.

Rank 0: ambiguous references

Ambiguous references are not known definitely to be pointers; they may be 
floating-point numbers or some other type of object.

The ambiguous fix method colours gray the objects in the condemned set that are 
pointed to by ambiguous references.

Rank 1: exact references

Rank 2: finalized references

A finalized reference keeps the object pointed to alive.
If the object pointed to is in old space, a message is sent to the mutator.

Rank 3: weak references

A weak reference does not keep the object pointed to alive.

Multiple Simultaneous Collections

These can work as long as no collection turns another collection's gray objects 
to black.

Buffers

     Buffer      Buffer Memory
   ------   -------> ------------------- L
   |       |   |  |    |
   |  L   -- | ----------   | junk   |
   |       |     |    |
   |  A   -- | ------------------> |------------------ | A
   |       |     | being initialized |
   |  I    -- | ------------------> |------------------ | I
   |       |     | initialized  |
   ------     -------------------

Three-stage procedure for allocation:

(1) Reserve
 if (A + size) > L then Fill(buffer)
 A += size

(2) Init

(3) Commit
 I = A

If a GC collection starts in the middle of a cycle, the mutator cannot see the 
part of memory between I and A.  The commit then has to fail.  When a 
collection starts, the collector sets L to 0.  Then, we add a test to the 
commit function:

Commit
 if (L = 0) then { Trip(buffer); fail }
 I = A

The object must then  be reinitialized.  Entire procedure is as follows:

do {
 Reserve
 Init
} while (! Commit)

Notes on Richard's Earlier Talk:

Richard provided the following notes for an earlier version of this talk, which 
he gave several months before at Barrington Hall.  Most of the earlier topics 
were at least mentioned in the Longstanton talk, but not in the same order:

Goals
  General: revenue, internal, central, quality, image
  Dylan: provide, promote, improve.
  EP: protect, downsize, compete (pub), maintain, perform, relate (EP/SP), 
improve.

Requirements
  Dylan: reliability, performance, adaptability.
  EP: reliability, performance equality, GC, debugging, performance 
enhancement, downsizing.
  External: performance, adaptability, flexibility, reliability.
    No PMM.  Speculative.

Key solutions
  pool system
  observable system
  component framework
  freestanding conservative C
  evolutionary development
  process for quality: information system
  appropriate optimization
  simplicity

Architecture
  client/MPS
  MPM/STD/pool classes

- general architecture (client, MPM, pools, OS, tools)
- the arena, segments, zones, and reference signatures
- the equivalence-class induced multigraph
- abstract procedure for collection, and colour
- the tracer (scan and fix generic function model)
- roots and scanners
- reference flavours (ambiguous, exact, final, weak)
- internal scheduler, plans, and tasks
- incremental interactions between collections
- barriers
- remembered sets to optimise scanning
- strategy, tactics, knob twiddling, probability nets
- internal doc


ATTACHMENT
   "POOLSYS.CWK"

