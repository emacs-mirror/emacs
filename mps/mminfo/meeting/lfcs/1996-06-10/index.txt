                 NOTES FROM MM/LFCS MEETING, 1996-06-10
                        meeting.lfcs.1996-06-10
                               draft doc
                           richard 1996-06-11

To: pbj@dcs.ed.ac.uk, rb@dcs.ed.ac.uk, richard
Subject: meeting on 10/6/96
Date: Tue, 11 Jun 1996 15:57:46 +0100
From: Healfdene Goguen <hhg@dcs.ed.ac.uk>
Status:   

Richard and I met yesterday for the whole day.  Here's a condensed
electronic transcript of what we wrote down.  I'll provide a more
interpretive rendition later on, and my notes can also be copied.

The goals of the meeting were for me to understand in more detail the
Harlequin implementation, and to develop a framework so that Paul and
I would have something concrete to work on over the next few weeks.

The main items on the agenda were:
        * General discussion
        * Discuss their algorithm for the MPM
        * Look at Paul's MPM code

****************************************************************
General Discussion

Here's an overview of the things discussed:
        1. Changes in staff at Harlequin
        2. Particular collection algorithms
        3. ML
        4. Change in policy for secrecy
        5. Accuracy of the color abstraction
        6. Planning
        7. Connection between ML code and C code

1.  Richard said that David Moore (I think, or is it Jones?) is
leaving next week, but that someone is replacing him.  There will also
be someone coming in to work on documentation and quality of the MM
project.  I asked whether this person might end up writing some ML to
help document their code, and Richard said this was possible.

2.  Richard discouraged considering particular collection algorithms,
such as a copy collector, which would be in a pool.  We may want
to bring this up at a later meeting, but he seems less concerned
with correctness of particular collection algorithms and more
concerned with their performance.  On the other hand, he did
think that showing the correctness of the co-ordination of
several collectors via the MPM was interesting.

3.  We discussed the problem with structures in ML.  Richard said
that ML has two significant advantages for them:
        * They already know it.
        * Political advantage of it having been developed in
                the company.
I suggested that we discuss that at the next meeting, since it
wasn't central to our current discussion.

4.  Harlequin apparently has a new solicitor, who suggested that
having everything as a secret may be a bad policy.  Richard said
that they are working on documenting more precisely what is and
is not secret in their project.

5.  Paul had found a discrepancy in the short C collectors
we had written, where the actual implementation did not
exactly respect the color abstraction.  I produced something
which I thought was what he had found, although I was not
certain, and Richard said that this code (which I had written)
was not as they would have implemented it.  I will check with
Paul what the exact problem was.

More broadly, I think this has been a concern of Paul's, that
the color abstraction may not capture particular algorithms
exactly.  I mentioned this to Richard, and he sounded interested
but was not sure that this was the case.  There is room for
more discussion between Paul and Richard there.

6.  Planning.  We agreed that we should work towards something
more concrete for the moment.  Richard said that he is mainly
interested in numeric properties, but that he also wants to know that:
        * pools co-operate correctly (safely)
        * multiple traces work
        * greyness-preserving on forward
He said that showing these properties probably relied on the safety
property.  He was less concerned about completeness.

7.  I suggested that we should be thinking informally about
the connection between ML and C code, and about the overall
argument which we are using to justify increased confidence in
software via indirect means.

****************************************************************
Their algorithm for the MPM

The sections here are
        I. Partitions
        II. Read and Write traces
        III. Description of pools, trace, strategy
        IV. Tracing algorithm

I.  Partitions

Richard discussed their new idea of partitions, which I'll try to
describe.  Perhaps Richard can comment on what I've written.  The idea
is that when we think of the code Richard had discussed for
approximations for sements, they were partitioning the graph of
segments into white, grey and black.  They want to generalize this
partitioning with respect to any property P, where
        * white(P) means the segment has property P,
        * grey(P)  means that the segment may have a pointer to a
                        segment which has property P, and
        * black(P) is the absence of white(P) or grey(P).
A partition is a *reference partition* if it doesn't have a
pointer from black to white.

So, for example, we could have partitioning with respect to the
property that a segment is storing pairs: white segments wrt this
partition contain, grey segments have pointers to segments with pairs,
and black segments don't point to white segments.
[For the particular property of pairs, you could imagine eliminating
the problem statically by type-checking.]

In fact the way they represent it is as two bits for each
partition, one representing white and the other grey.  So there
are actually four colors, since an object can be both grey and white.

The advantage of their approach is that they can use the partitions to
make approximations of the work they need to do, which since they're
working at the higher level of segments can save a great deal of time.
They use the partitions in their tracing in the MPM algorithm, and
they only deal at the level of segments there, leaving objects to the
individual pools.

As far as I understand, this is not exactly a generalization of
tri-color marking, but instead a convenient way of thinking about the
segments.  Perhaps it also filters down to usual collection
algorithms.  But it seems to me that the meaning of white in a
tri-color marking algorithm doesn't quite correspond to having a
particular property: what you're looking for is objects that are white
at the end of collection, which means that they're unconnected,
but during the collection white means that it hasn't been considered
yet.

I'm not sure that this is exactly how it is implemented at the moment,
but Richard said that it is definitely how they intend to proceed.
As far as I understand, an earlier version worked very abstractly
using only color, but they now intend to incorporate the idea of
segments quite solidly into the implementation.

II.  Read and write traces

They have a new generalization of gc in terms of read and write
barriers.  Apparently, the main difference between read and write
barriers is the color of the roots.  At the beginning, the roots
are grey and you can implement a write barrier, where you can
collect ambiguous references.  Once you reach a particular
criterion (which Richard didn't mention), you can do a flip,
which means that the roots become black.  You now do collection
with a read barrier, where you can copy objects to make them grey.

Hence, a usual write barrier collector only does the first half
of this stage, and a read barrier does a flip immediately and
then the second half.

I'm sure I can give a better description of this if I think about
it more, but I'd like to send the message off now... in any case,
the tracing algorithm for the read or write barrier is essentially
the same, the difference is that you have a different protection
scheme to preserve the invariant.

III. Description of pools, trace, strategy

Pools.  Pool determines the management policy
        placement in memory
        format
        sets of objects
        how it is 'fixed' [copy, mark] and 'scanned'

Trace.  Manages the process of tracing the graph (global)
        state of partition
        faults
        chooses what to do next (grey thing to scan)
        progress/planning

Strategy.  long-term planning
        decides what to condemn.

To describe a general tracing algorithm, we need an interface with the
pools.  Here is a first try at a signature for pools, although the
operations for condemning and greying are unclear.  It's a la Richard,
meaning that it passes the store functionally to make it explicit
what's used.

create:         space * pool_class -> space * pool
        make state for pool
destroy:        space * pool -> space
        end use of pool
allocate:       space * pool * size -> space * pool * loc
        new loc for object
free:           space * pool * loc * size -> space * pool
        end use of loc
scan:           space * memory * pool * loc -> space * memory * pool * loc
        Get refs in object, fix them
fix:            space * memory * pool * loc -> space * memory * pool * loc
        Side-effects of making object grey from white (for example, copy)
load:           space * loc * memory ( * pool?) -> space * memory * item
        intercept access to object (read)
store:          space * loc * memory * item ( * pool?) -> space * memory
        intercept access to object (write)
reclaim:        space * pool -> space * pool
        destroy white objects

IV.  Tracing algorithm

Here, I'm just going to copy what he wrote...

Parameters:  space, memory, condemned set of objects, (deadline)
We can assume that the condemned sets don't overlap.

1.  Create Trace
        Create a partition wrt a new property T (for trace)
        Assign T to objects in condemned set [condemned are "white(T)"]
        T is not a reference partition yet (no grey)
        Deduce black and grey from properties of condemned set
                [in order to reduce size of grey set]
                [e.g. union of all condemned properties]
        Write protect black(T)
                [This step doesn't need to be modeled at the first try]

2.  W-Trace (W is for "Write")
        Find a grey(T) object
        scan object to make black(T) [scan using owning pool]
          [map generic fix (object's references)]
            [generic_fix calls pool's fix for the owner of an object
                if referent is white(T) then make grey(T)
                in doing so, must preserve greyness for other properties]
        make object black(T)    [and protect?]

3.  Flip
        scan roots      [scan using root scanner, roots are global]
                [roots are not a pool, though could be thought of as such]
          map generic_fix (root's refs)
                etc.
        make roots black
        start using read barrier

4.  R-Trace [R is for "Read"]
        just like W-trace, but maintaining invariant using read barrier

5.  Reclaim
        map free white(T)

The mutator is not active during a step (during scan, e.g.),
except for in loops in steps 2 and 4.  Rod's idea of scanning
the white objects in the main trace would be handled here by
reducing the size of objects; Richard intends that this be
an atomic action.

****************************************************************
Paul's Algorithm for the MPM

We looked at this fairly quickly after the longer discussion of
their implementation of the MPM, since at this point I was more
familiar with their ideas.

Richard said that the idea of dispatching wrt segments was accurate.
However, one misunderstanding reflected in Paul's code is that objects
can indeed change segments, and even pools.  The MPM itself doesn't
know anything about the objects, but it may "see" that an object has
moved because a different segment suddenly changes color.

The other obvious difference with what Richard is doing is that
Richard is using partitions.

****************************************************************

I hope to write down a merging of what Richard wrote together with
what Paul wrote some time soon, talk about the results of the meeting
with Paul, and have a further meeting with Richard before the end
of the week, probably on Thursday evening.

Please tell me of any questions or comments on what I've sent.

Cheers,
Healf

