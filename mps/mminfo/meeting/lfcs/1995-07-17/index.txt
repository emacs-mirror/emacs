              SUMMARY OF FIFTH MM/LFCS MEETING, 1995-07-17
                        meeting.lfcs.1995-07-17
                               draft doc
                           richard 1995-07-31

INTRODUCTION

David Jones, David Moore, and Richard Brooksby met with Rod Burstall and
John Longley in order to develop our mutual memory management model.


AGENDA

1. John's goals for his last month of the collaboration
2. Explaining the Harlequin ML GC model
3. Glenn Bruns' GC specified in CCS
4. Explaining the Edinburgh ML GC model
5. Compare and contrast Harlequin and Edinburgh models
6. Rod's work with Healf in Coq
7. Rod's top level GC algorithm proof outline
8. Planning


JOHN'S GOALS

The period up to the next MM/LFCS meeting is pretty much John's last
opportunity to contribute to the collaboration.  We therefore wanted to
give him the chance to state his goals for the next month and influence our
actions.

John said that he was very happy about the experience of collaborating with
us on the topic of memory management.  He also said that he felt that he'd
started a lot of things but not really finished anything.  He summarised
these:

 1. Lego verification of Benari's GC algorithm,
 2. consideration of methods for reasoning about imperative programming,
 3. the paper describing the memory management model, and
 4. the model of a GC in ML.

I ranked these in order 4, 2, 3, 1 considering the interests of the
Harlequin Memory Management Project.  I also said that the paper would be
best if narrowed down (or split up) just to cover the multi-level graph
model, since this was a feasable piece of work.


THE HARLEQUIN ML GC MODEL

Rather than describing the code, which had been read and understood by all
present, I attempted to communicate the reason that the code was written as
it was.

Within the Harlequin MM Project, ML is emerging as a tool for detailed
design and specification.  The ML code will most usefully contain the
essential concepts of the system, with all abstractions in place.  The idea
will be to model each concept as encapsulated pieces of ML, and demonstrate
the feasibility of the system by executing the model.  The ML is therefore
not an "implementation" of a GC.  I contains data structures which model
the state of the machine in an abstract way, and attempt to boild them down
to their essential properties.

Accordingly, note that the "Collector" functor is an early attempt at
distilling the essence of GC into one place.  The parameters to the functor
have nothing in particular to do with GC, but are algebraic (even
categorical) models of other parts of the system.

I hope that we can come up with a better description of the difference
between modelling and implementing something.

Rod and John said that they had spent about six man-hours understanding the
ML code I wrote.  I undertake to explain myself better, since this would
only take me a little extra time.


GLENN BRUNS' CCS GC

Glenn Bruns used CCS, temporal logic, and the Concurrency Workbench to
construct and verify a garbage collector with four cells.

                .---.
               /     \
              .       .
    acc_i  ---*  GC   *--- coll_i
              `       '
               \     /
                `---'

This diagrams shows the GC with two ports:

  acc_i        node i is accessible
  coll_i       node i is collected (reclaimed)

The modal pi calculus is used to specify conditions on the GC:

  always([acc(i)]ff \/ [coll(i)]ff)
    "All nodes are either not accessible or not collected."

  always([acc[i]]ff => eventually(coll(i)))
    "If a node is not accessible it is eventually collected."

Internally, the GC has three states, which I will not attempt to draw using
ASCII art.

  Mem has ports
    acc_i               node i is accessible
    color_i(c)          what is the colour of node i?
    wb_i                turn node i black (scan)
    makefree_i          free node i
    setcolor_i(c)       set the colour of node i to c
    mutator_ij          change i to point to j

  Mutator has ports
    mutator_ij          change i to point to j

  Collector has ports
    setcolor_i(c)       see above
    makefree_i           "
    color_i(c)           "
    wb_i                 "
    coll_i               "

Part of the definition of Collector:

  BlackenRoots(i) ::=
    if i > r then
      Propagate(0,1)
    else
      setcolor_i(black).BlackenRoots(i+1)

Glenn will forward the full CCS specification (a couple of pages) in mail.


THE EDINBURGH GC MODEL

John explained the GC model he'd implemented in ML.  John's model describes
some of the multi-level graph concepts developed in the MM paper, and the
concept of GC is not so centralized or abstract.  The model, for example,
could describe allocation or actual memory layout.  It really needs a
diagram to explain.


COMPARE AND CONTRAST

The Harlequin and Edinburgh ML code clearly has different aims.
Harlequin's code is more mathematical and algebraic, whereas the Edinburgh
code is more data-structure oriented and closer to an implementation.  The
Edinburgh code covers more of the concepts we've discussed in the
collaboration, wherewas the Harlequin code only deals with the essentials
of GC.  The Harlequin code is also aimed at fitting into our software
development process at a particular level.

We decided that it would be wasted effort to try and merge the two models
into one at this stage.  It would incur a heavy communications overhead,
and since both are only in their early stages the result is likely to be
some sort of weird mutant.  John will attempt to develop his model further,
and we can extract the lessons learned at a later date.


WORK WITH HEALF IN COQ

Rod visited Healf at INRIA and they worked on a small proof of part of a GC
in Coq, a proof assistant similar in some ways to Lego.


TOP LEVEL GC PROOF OUTLINE

Rod took a very simple formulation of the top-level loop of GC and
formulated an invariant on it.

  1. makeGrey root
  2. repeat {
  3.   let parent = getGrey()
  4.   in repeat {
  5.     let child = getWhiteChild parent
  6.     in makeGrey child
  7.   }
  8.   makeBlack parent
  9. }

Mutator may, at any point, delete an edge or insert and edge and, if the
child is white, make it grey.

The invariant:

  If a node is accessible from the root
  then either it is accessible from a grey node
           or it is black
  after line 1.

I pointed out that if nodes were naturally black, and line 1 was changed to:

  1. makeWhite everything; makeGrey root

then the "after line 1" clause could be deleted.

Unfortunately, the invariant isn't quite right, since it doesn't preclude a
white node being accessible from a black one, provided it is _also_
accessible from grey.

Rod went on to describe various lemmas about the invariant and the concept
of accessibility.  We went through these and commented on them.


PLANNING

The next meeting will be on Monday 21st August at Harlequin, Cambridge.  We
hope to include Healf.  Rod may bring Paul Jackson, recently of Cornell.

Rod is away 29th July to 14th August.

Harlequin
- Write up ideas of the role of ML
 - ideas workbench
 - controlling loss of abstraction in the implementation
- Comment ML model more in future to improve communication
- Develop the model further to include "memory management" in general
- Correct logical problems with the GC functor
- Attempt to F-type the Collector functor in order to make it more amenable
to verification
- Work out the procedure for getting clearance for dissemination of information

LFCS
- Plan how to hand work over to Healf
- John will work on his ML model
- John will write up ideas about machinery for reasoning about imperative
programs
- John and Rod will give some though as to the direction to take the
framework document in
- Rod will decide whether to bring Paul Jackson to the next meeting and
notify Harlequin

