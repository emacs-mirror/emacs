          MM/DYLAN MEETING ABOUT HEAP VISUALIZATION 1998-05-14
                        meeting.dylan.1998-05-14
                             incomplete doc
                            tony 1998-05-19

INTRODUCTION

.intro: Jonathan Bachrach <Jonathan>, Keith Playford <Keith>, Paul Howard 
<PHoward>, Tony Mann <Tony>, Sheep <Sheep>, Richard Kistruck <RichardK> and 
Richard Tucker <RIT> met to discuss possibilities for a Heap Visualization (HV) 
tool jointly developed by the MM & Dylan groups.


AGENDA

.agenda: The following topics were on the agenda:
  - Recap of motivation behind a jointly-developed tool
  - Brainstorm of ideas for tools
  - Priorities
  - Partitioning responsibilities between groups
  - Discussion of working practices
  - Timescales


MOTIVATION

.mot.req: Dylan have previously specified MM requirements for facilities to 
debug memory management problems, find references to objects, help with finding 
ways to shrink the heap, and measure the behaviour of the MM. (See req.dylan(6)
).

.mot.exist.mm: The MM group currently have some prototype tools for examining 
the contents of a heap over time, locating referenced but unused parts of the 
heap ("reachable garbage"), and also for observing fragmentation in a manually 
managed heap. These tools are used to post-analyze log files generated by 
applications. The log file would typically contain MPS "telemetry" data. 
Telemetry is currently generated by special varieties of the MPS which are 
significantly slower than release varieties.

.mot.exist.dylan: The Dylan group currently have some prototype tools for 
displaying the contents of a heap (by class) at a particular instant in time, 
and for finding trails of references to objects in the heap. These tools are 
used interactively from any debugger. The tools are not included with the 
standard Dylan runtime, and are built on top of core MPS facilities for heap 
traversal.  Additionally, The Dylan group have a general debugger which has 
knowledge of the Dylan object representation and a general object introspection 
capability.

.mot.ideal: The "ideal"  HV tool (i.e. the best tool we can conceive of 
implementing) would be an integrated suite of tools which can be invoked 
interactively. Information gleaned from the use of one tool could be used as 
input to another after some programmer-inspired deductive process. Ideally, the 
tool would not compromise performance of the application when it's not in use 
("pay as you go").

.mot.collab: We are conceiving a collaborative tool which is implemented via 
the Harlequin Dylan debugger infrastructure (using the "tether" to communicate 
between the application and the tool). This has potential advantages over 
either the existing MM and Dylan tools:-

.mot.adv.interactive: MM benefit from the tether because it is designed for 
interacting with a live application, which makes it more useful as a platform 
than a post-mortem log file (c.f. .mot.exist.mm). Although there's no 
theoretical reason why telemetry data must be examined post-mortem, MM have no 
current framework to process it either "live" or interactively. The tether also 
provides support for interactively examining/browsing objects, and hence widens 
the scope for tool integration.

.mot.adv.heap-access: MM benefit from the tether because it avoids the need to 
make a copy of the object graph, since the heap is directly visible via the 
debugger. The existing MM tools need to make their own private copy of the 
object graph. Hence the tether avoids duplication of large amounts of data. It 
also removes the need for the telemetry data which is used to control the 
construction of the copy of the heap - and this data is very high bandwidth.

.mot.adv.ubiquitous: Dylan benefit from having a tool that works with standard 
release builds of MPS and the Dylan runtime.

.mot.adv.experience: Dylan benefit from the work that Sheep has already done - 
for viewing the contents of the heap in useful ways, and for determining 
"reachable garbage". It is anticipated that this can be recreated for a 
tether-based tool.

.mot.adv.evolve: I expect that, of all known options, a tool built alongside 
the Dylan debugger will offer the fastest route to adoption by Harlequin's 
Dylan developers. Dylan and MM both benefit from early adoption and the 
establishment of an early evolution feedback path.


BRAINSTORM

.brainstorm.intent: There was a brainstorm of possible tools. This wasn't 
intended to be complete, or to supercede any previous discussion of what tools 
should look like. The intention was to flush out anything urgent, and to 
generate some useful new ideas. There's no implication that an idea is going to 
be implemented just because it was recorded here.  There was some discussion 
about what we might want HV tools for.

.categories: We distinguished 4 main categories of reasons for wanting to use a 
HV tool:-
  - Finding allocation hotspots (allocation profiling)
  - Finding unwanted references (what's making that garbage reachable?)
  - GC performance monitoring (stats about GC progress) A suggestion was made 
that this should be linked to sound, with the pitch/volume increasing as GC 
activity increased.
  - Analysing fragmentation (not really an issue for Dylan - and not discussed 
in depth)


.purpose.shrink: One main reason for wanting HV tools is to determine how to 
improve an application so that it runs with a smaller heap.

.purpose.shrink.what: Want to know what's in the heap at any moment, and how 
this varies over time.

.purpose.shrink.level: Want to be able to "level" the heap over time. E.g. 
minimize peaks in heap size; reach stability of heap size over time; fit within 
a particular size.

.purpose.shrink.garbage: Want to be able to track down those parts of the heap 
that are "reachable garbage", and hence permit program improvements so that 
those parts can be GCed. Here are some possible causes of reachable garbage 
(which implies some strategies for dealing with the problems):-
  - Not removing a reference to an object from a global data structure, despite 
expectations.
  - Not flushing caches
  - GC 'bugs' or conservatism preventing an object being thrown away

.idea.perspective: It would be useful if the tool was able to offer a 
perspective so that the user can concentrate on things s/he has "control" over. 
This implies a need to agglomorate data into categorizations that are useful to 
the user. E.g. it might be helpful to visualize the heap in terms of DFMC and 
non-DFMC objects, rather than per-class. Such categorizations might involve 
standard type-algebraic combinations of classes, or it might involve 
combinations of all classes defined in a particular set of libraries. Jonathan 
volunteered to write a paper on categorization.

.idea.audit.code: It would be useful to be able to "audit" MM usage of "my" 
code. E.g. how much allocation is happening for classes defined in my library; 
how much is my library responsible for allocation in general. This is closely 
related to allocation profiling - but implies a need for user categorization 
(see .idea.perspective).

.idea.audit.root: It would be useful to be able to determine which objects are 
transitively referenced from a set of roots. Similarly, it would be useful to 
be able to ask how much of the heap would die if a set of roots and/or objects 
were removed.

.idea.heap-diff: It would be useful to be able to perform "heap diffs" - which 
display the difference in heap contents between points in time. This might be 
achieved either by statically comparing 2 heap breakdowns (e.g. RIT's perl 
script), or incrementally (e.g. by tracking allocation/free events, or even 
using copy-on-write snapshot techniques).

.idea.intend-to-free: A programmer might like to assert that an object is about 
to become free, and expect some feedback if the object ever survives a GC. As a 
concrete example, Jonathan explained that the compiler currently walks 
compiler/DOOD data structures at the end of a compilation, and removes 
references to objects which are then expected to die. Conceivably, each removed 
object could be "registered for destruction" in much the same way that an 
object can be registered for finalization. Even the implementation could be 
similar - except that messages about objects on the destruction queue would be 
posted if the object survives a GC, rather than if it doesn't. The process of 
walking the data might potentially preserve references until the walk is 
complete, so there would be a need to delay the posting of messages before that 
time (e.g. by parking the GC).

.idea.non-perturb-gc: It would be useful to have a means of performing a 
non-perturbing GC which doesn't actually free or move any objects, but which 
distinguishes between live and dead objects. This would permit the client to 
compare the space overhead of the GC at a point in time against a perfect 
collector. It would also permit the analysis of the effect of individual 
program operations at freeing objects.

.idea.reverse-trace: It would be useful to have a mechanism for finding reverse 
pointers during a GC trace. A tool could then be efficiently built to follow 
reference trails from roots to objects.


PRIORITIES

.prio.dylan: The Dylan participants suggested the following priorities for tool 
development, in decreasing order of importance:-

.prio.dylan.1: Find reachable garbage. Initially this would involve the 
following steps:-
  - Invoke a tool to find what's in the heap
  - Developer attempts to determine what shouldn't be there
  - Invoke a tool to find out what references the object

.prio.dylan.2: Display heap breakdowns at different times. This would need a 
categorization mechanism. 

.prio.dylan.3: Display differences between heap contents at different times. 
(see .idea.heap-diff)

.prio.dylan.4: Look for "cold" parts of the heap. (I.e. revive Sheep's 
"temperature sensing" tool for finding reachable garbage).

.prio.mm: Tony suggested that MM should consider it a high priority to develop 
a GC monitoring tool, for displaying stats about when traces start and finish, 
how much was condemned, how much survived etc.



WORKING PRACTICES

.extend: The implementation possibilities for a tether-based HV toolset involve 
communication between the app and the environment by means of existing 
mechanisms, and by extensions to the set of spy calls and known breakpoints.

.responsibility.env: It was agreed that all MM implementation work in the 
environment would be implemented in separate libraries so that the 
responsibility for any particular library in the system is clear.

.responsibility.runtime: We didn't discuss how to separate responsibility for 
implementation work inside the Dylan app/runtime. This needs further thought. I 
am considering an idea that all MM work will be implemented in a separate DLL 
which can be dynamically loaded into a running Dylan app. The Dylan group could 
provide a spy call to load this DLL.


TIMESCALES

.spy-extend: Before any tool can be implemented, MM will need a means to define 
spy calls. Dylan must provide this. PHoward volunteered to work on this in the 
near future.

.stage1: It was suggested that the first release of a tether-based HV tool 
should be built on top of the console debugger rather than Harlequin Dylan, to 
avoid the need to integrate with environment protocols and productization 
constraints at an early stage. This would include a heap walker, root finder 
and GC monitor. It would probably be entirely text based - although it was 
observed that there is no practical obstacle to implementing GUI code (in DUIM) 
within the console debugger. More discussion is required before any timescales 
can be given.



