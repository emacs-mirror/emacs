          NOTES FROM THE MM/DYLAN WEAKNESS MEETING, 1997-02-04
                        meeting.dylan.1997-02-04
                               draft doc
                           richard 1997-02-04

INTRODUCTION

.intro: Richard Brooksby <richard> and David Jones <drj> met Tony Mann <tony> 
to discuss problems and solutions in the Dylan MM's support of weak tables.


COUNTING


Problem

.count.problem: Dylan code would like to have a count of the number of used 
entries in the weak table.  The GC may remove entries asynchronously.  How can 
a count be maintained?

.count.single: A single count field cannot be maintained by both Dylan and the 
MM without some locking on that field.  We do not want to introduce extra 
locking mechanisms between Dylan and the MM.


Solution

.count.two: Introduce _two_ count fields, one for Dylan and one for MM.  
.count.sum: The count of unused entries in the table will be the sum of the 
two.  .count.mm: The MM field will be updated atomically by the weak table 
scanner -- part of the Dylan Container Format code currently maintained by the 
MM Group.  The scanner will increment the MM's count every time it removes an 
entry from the table.  .count.mm.overflow: This count will never be decremented 
and may overflow modulo some power of two.  .count.dylan: The Dylan count will 
be incremented when an entry is removed by Dylan code and decremented when an 
entry is added.  .count.dylan.underflow: The Dylan count will tend to go 
negative and may underflow modulo the same power of two.  .count.approx: The 
sum of the two counts is a conservative approximation of the number of unused 
entries.  The reason it's approximate is that Dylan code may read the count 
just before the MM removes some entries.  .count.approx.no-problem: Tony says 
this is not a problem.


Problem

.race: There is a race between Dylan removing an entry from the table and the 
MM removing an entry.  They might both increment their counts, leading to a 
drift in the number of unused entries.


Solution

.race.load: Dylan code should load the weak reference it is about to remove 
into a non-weak reference (such as a register) before updating the table.  This 
guarantees that the MM won't try to remove the entry (because its referent is 
strongly referenced).  After removing the entry the Dylan code can drop the 
reference.


KEYS AND VALUES


Problem

.kv.problem: When a weak key dies its corresponding value should be removed.  
When a weak value dies its corresponding key should be removed.  
.kv.req-failure: This feature was not understood by the MM Group and is not 
easily supported by the MM design for handling weakness.

.kv.scan: Only the weak table scanner (see above) can act when a weak reference 
dies.  (Any further action is "finalization" which must be handled 
differently.)  All scanners operate under restrictions, including:

  .kv.scan.exc: The scanner may be running in exception context.
  .kv.scan.no-exc: The scanner may not cause another exception.

.kv.scan.no-poke: This means that it can't access other objects, because they 
may be protected.  (Wrappers are an exception, handled specially.  See solution 
2 below.)  This is a problem, because the keys and values are in separate 
vectors.  The scanner can't poke at one while scanning the other.


Solution 1: Exposing the Shield

.kv.shield: The MM has an internal mechanism for allowing temporary access to 
protected objects, called the "shield".  The interface to this could be exposed 
to the Dylan Container Format code so that it has the ability to update one 
vector while scanning the other.

There are two variations:

  .kv.shield.gen: We do this in general (i.e. for other MPS customers).
  .kv.shield.dylan: We allow this as a special hack for Dylan.

The main disadvantage is a significant complexity in the MPS interface, and 
quite a lot of change.


Solution 2: Specialized Pool Class 1

.kv.atom: The non-weak vector is allocated in a special pool whose pool class 
guarantees that it is not protected when the weak scanner is run.  This would 
be similar to the pool containing Dylan wrappers.

The main disadvantages are that a new pool class may need to be implemented, 
and that the GC pause time would be proportional to the number (total size) of 
weak vectors, since this pool would be scanned atomically.


Solution 3: Specialized Pool Class 2

.kv.unprot: The weak and non-weak vectors are allocated at once in a special 
pool whose pool class takes care of the removal of entries.  The allocation 
method would be pool class specific.

The pool would put a header on the vectors relating them to each other.  During 
scanning of the weak vector object the pool would temporarily lift the 
protection on the non-weak, allowing the scanner to remove entries at will.

The main disadvantages are that a new pool class would need to be implemented.  
This class is a bit tricky.


Solution 4: Mixed Rank Segments

.kv.gen: Generalize the Tracer to allow both weak and non-weak references in 
the same object.  The weak table can then be represented by a single vector, 
half of which is weak and half of which is non-weak.  The scanner for this 
table is at liberty to remove the non-weak reference when the weak one dies.

.kv.gen.nice: Mixed rank segments might be desirable for the MPS in general at 
some point in the future.  There are likely to be situations where they are 
needed.  Dylan almost needs them: The wrapper pointer from a weak table 
shouldn't really be weak.  Luckily it will also be in the weak table's class, 
which is non-weak, so it won't die.

The main disadvantage is that this makes the Tracer more complicated, and 
required a change in the Dylan table implementation.  Tony says that Kevin says 
that this change is not too costly, and provided that the weak and non-weak 
sections of the vector are separated (first and second half, for example) the 
implementation can still be shared by both weak tables, non-weak tables, and 
sets.


OTHER NOTES


.atomic-weakness: If the mutator (unprotectable references) are non-weak then 
weak references must be scanned atomically with respect to the mutator.  Proof: 
Suppose they aren't scanned atomically.  The mutator can be grey while there 
are grey weak references.  Therefore the mutator can load a weak reference 
before the weak references are scanned.  Therefore we can't assume that weak 
referents are dead if they are white.  Therefore weak references are not weak.  
Reductio ad absurdum.  QED


ACTIONS

.act.estimate: The MM Group will estimate the costs of the various solutions 
and inform the Dylan Group of the consequences.

