   NOTES FROM THE DYLAN WEAKNESS AND FINALIZATION MEETING, 1997-02-27
                        meeting.dylan.1997-02-27
                               draft doc
                           richard 1997-02-27

INTRODUCTION

.intro: Richard Brooksby <richard> and David Jones <drj> met Kevin Mitchell 
<mitchell> and Tony Mann <tony> to settle the details of the implementation of 
weakness and finalization.


WEAKNESS

.weak.alloc: Dylan's weak tables require a sort of local mini-finalization in 
which the death of the weak key removes the weak value or vice versa 
(meeting.dylan.1997-02-04.kv.problem).  This will be implemented by a 
specialized pool which will allocate both vectors of a table at the same time, 
with one weak and the other strong (meeting.dylan.1997-02-04.kv.unprot).  The 
pool will internally store the association between the vectors and ensure that 
the scanner of the weak vector can update the associated strong vector.  In 
particular, it will make sure the strong vector is exposed (unprotected) while 
the weak vector is being scanned.  The vectors will be in ordinary Dylan 
container format.

.weak.count: The counting mechanism described in 
meeting.dylan.1997-02-04.count.problem will not be solved initially.  We 
established that this was really a performance optimization which was unlikely 
to impact greatly on Dylan programmers.  The table library will maintain a 
count at the Dylan level, and will specify in documentation that size(table) >= 
actual number of elements, and table is really empty if (but not only if) 
empty(table).

.weak.splat: Entries in the vectors will be replaced with zero when they die of 
weakness.  Entries in the strong table will also be replaced with zero by the 
scanner when their associated weak entries die.  The MM Group will think about 
how to replace them with some other Dylan value, but this is not essential.  
This would probably involve some sort of closure on the format scan method.


FINALIZATION

.final.class: The pros and cons of Java-style class-based finalization vs. 
Moon-style instance-based finalization were discussed.  Class-based 
finalization can be implemented in terms of instance-based finalization.  
Optimizing class-based finalization would mean a fairly major change in work 
that is already mostly complete, so it was decided not to pursue it at present.

.final.multi: In order to maintain flexibility, the MPS Interface will 
guarantee that, if an object is registered for finalization N times, no more 
than N finalization messages will be sent.  We will not guarantee that exactly 
N messages will be sent.  Dylan will have to make a similar statement at their 
interface.

.final.other: Tony asked what happens if a non-managed object is registered for 
finalization.  Final references are under the same restrictions as weak 
references, so would be affected by an interface which declared regions to 
which references would be considered "legal".  Non-managed objects would never 
be queued for finalization, because they would never be candidates for 
recycling.  The MPS interface would not prevent them from being registered 
provided that the reference registered was legal.


ACTIONS

.act.doc.count: The Dylan Group will ensure that the specification of the 
"size" and "empty" methods on weak tables is documented.

.act.doc.final: The Dylan Group will ensure that the restrictions on objects 
registered more than once for finalization are documented.

.act.impl: The MM Group will implement weak table support as described (see 
request.dylan.170021, request.dylan.170123, and request.dylan.170124).

.act.regions: The MM Group will consider the validation of references by 
declaring regions to which they are allowed to refer outside the managed heap.

