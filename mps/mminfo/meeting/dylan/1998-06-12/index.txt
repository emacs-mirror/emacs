          MM/DYLAN MEETING ABOUT HEAP VISUALIZATION 1998-06-12
                        meeting.dylan.1998-06-12
                             incomplete doc
                            tony 1998-06-15

INTRODUCTION

.intro: Paul Howard <PHoward>, Tony Mann <Tony> and Sheep <Sheep> met to 
discuss current issues relating to the Heap Visualization (HV) tool being 
jointly developed by the MM & Dylan groups.


AGENDA

.agenda: The following topics were on the agenda:
  - Discussion of MM's tentative plans
  - Possibilities for using DUIM alongside the console debugger
  - How MM define spy calls etc.
  - How MM add new commands to the console debugger


PLANS

.plan: Sheep and Tony described the tentative plan for ongoing work on the HV 
tool.

.plan.tools: The intention is to provide 3 tools initially: (1) a heap analyser 
(similar to the one available in the Dylan runtime, but possibly extended to 
include user-specifiable categorizations), (2) a reference finder (similar to 
the one available in the Dylan runtime) and (3) a GC monitor, giving 
indications and statistics for GC traces. The initial development "environment" 
will be the console debugger. Further tools will evolve over time. The 
environment side of the tool will migrate to the real environment (Harlequin 
Dylan) over time.

.plan.impl: The principle implementational choice for each tool relates to 
which side of the tether each piece of functionality should reside. A major 
design consideration is to minimize the number of communications across the 
tether, since context switches are likely to be slow. 

.plan.impl.heap: For the heap analyser, the plan is for a function in the 
runtime to compute a table of data about the heap contents. This function will 
be called from the environment (as a spy function), and the code to display the 
results will be in the environment.

.plan.impl.finder: For the reference finder, the plan is similarly to compute 
the data (by repeatedly walking the heap) by means of a function in the 
runtime. This function will be called from the environment , and the code to 
display the results will be in the environment.

.plan.impl.monitor: The choices for implmenting the GC monitor are not yet 
settled. One possibility is that data will be collected and get buffered up in 
the runtime. When the buffer is full (or explicitly flushed), a hard-coded 
breakpoint will executed, and the environment will copy across the data and 
decode it. This mechanism may use the MPS telemetry stream. Alternatively, we 
might decide not to buffer the data, but to immediately indicate its 
availability by triggering a breakpoint (which might be a hard or soft 
breakpoint). Whatever the choice, the code to display the results will be in 
the environment.

.plan.impl.runtime: As much as possible of the code to implement the runtime 
side of the tools will be implemented in a separate DLL. This DLL will be 
entirely the responsibility of the MM group. It will use the dylan DLL - but no 
other DLL will use it. It will be loaded into a running Dylan application on 
demand (pay as you go). The Dylan DLL will continue to be the responsibility of 
the Dylan group - but MM may need to request new exports and functionality.

.plan.impl.environment: As much as possible of the code to implement the 
enviroment side of the tools will be implemented in a separate Dylan library.


DUIM

.duim.issue: It's hoped that the UI for the HV displays in the environment can 
be implemented as a GUI, using DUIM. There is an issue about thread 
synchronization if we do this, though. Currently the console debugger is single 
threaded, and hence the UI and the debugger functions are implicitly 
synchronized. A DUIM window would necessarily need to run in a separate thread, 
and hence require explicit synchronization.

.duim.opt: Four options were considered for DUIM usage using alternative means 
of synchronization:

.duim.opt.output: Option (1) is to use DUIM for output only (i.e. no command 
input). This implies that all commands remain synchronized with the debugger. 
DUIM provides support for synchronizing the output (we believe).

.duim.opt.queue: Option (2) is to use DUIM for both display and command input. 
Command input would insert command objects onto a command queue which would be 
processed by the debugger thread via a simple queue synchronization mechanism.

.duim.opt.multi: Option (3) is to make the console debugger multi-threaded, and 
to use the same sort of synchronization between the UI and the debugger threads 
as is used in Harlequin Dylan.

.duim.opt.hd: Option (4) is to give up on the console debugger, and to 
implement the initial tool directly in Harlequin Dylan.

.duim.opt.choice: We picked option 2 (.duim.opt.queue), since this gives 
maximum flexibility (along with option 3), but for a low synchronization cost.


DEFINING INTERFACES

.interface: Paul has already suggested an interface for defining spy functions 
and hard breakpoints in mail.phoward.1998-06-09.10-55(0) and 
mail.phoward.1998-06-10.14-44(0). These sound ideal for MM's purposes.


DEBUGGER COMMANDS

.command: Given the choice of synchronization (.duim.opt.queue), it's hoped 
that we can avoid any need to extend the syntax of the console debugger. 
Hopefully, all extensions can be achieved by subclassing and instantiating the 
<debugger-command> class. If we do need to extend the syntax, Paul volunteers 
to make the necessary changes on request.

.extending: Paul pointed out that since the console debugger is designed as a 
top-level library (devel-dbg-ui) is doesn't provide any useful exports, and 
isn't particularly useful as a base for extension by another library. Hence, 
the easiest way to extend it is by defining new commands within the library 
itself. Tony was hoping to avoid having libraries containing both MM & Dylan 
code - but this part of the implementation is temporary anyway so it doesn't 
matter too much. We agreed upon a way to make this work:

.extending.lid: MM can extend devel-dbg-ui without making any changes to the 
Dylan code by creating a new LID or HDP file for the library which uses 
additional files to define additional commands. By choosing a different name 
for the library (e.g. mps-debugger), MM can hopefully even avoid needing to 
concern themselves with issues of personal roots vs system roots.

.extending.minimum: As much of the new MM functionality as possible will be 
implemented in a new Dylan library (e.g. mps-tools) which is the responsibility 
of the MM group. This library will be used by mps-debugger. 


ACTIONS

.action.paul: Before MM can make any real progress, Paul must implement the 
interfaces to define spy functions, hard-coded breakpoints and new console 
debugger commands. He will also implement a spy function in the Dylan DLL which 
will dynamically load another DLL. He estimates that this will involve 5 days 
work.

.action.mm: Once there are facilities for defining new spy functions etc. MM 
can make independent progress. But Sheep will need to add to the set of exports 
in the Dylan DLL, and possibly add some new functions there. It was agreed that 
he would make these changes in a private copy of the Dylan runtime code, and 
then pass the information back to Paul (or someone else in the Dylan group) for 
inclusion into the Dylan sources.

.action.priorities: Paul is currently very busy with other Dylan work in the 
build up to the 1.1 release. He needs management guidance about what his 
priorities should be, and when he can schedule the MM work. Tony will raise 
this issue with DaveB.


