         NOTES FROM MEETING WITH PRODUCT MANAGEMENT, 1997-01-24
                       meeting.product.1997-01-24
                             incomplete doc
                           gavinm 1997-01-24

Introduction

Richard Brooksby <richard>, Jo Blishen <jblishen>, and Gavin Matthews <GavinM> 
met at Kings Buildings at 15:45.


Notes

JBlishen: Documentation's about flow of information.

Richard: A change is a change.  

I want to deal with Leah, and manage what she's doing.

JBlishen: This would be better as a Darwin thing, representing Darwin 
requirements.

Richard: it's the same with the MPS.  Is it a product in itself, or paart of 
oher products.  How do you schedule changes that affect other things?

JBlishen: Documentation have some ideas about using Darwin.

Richard: EP dothis the wrong way.  They flag things as requiring a doc change.  
What happens if there's a documentation only change.

Leah is quite happy about haver her management in with ours.  She thinks it's 
the best way.

Bob was worried about working with many different groups, with different 
systems.  I thought this made it worse in the long run.

I'm trying to get away with documentation being an afterthought.

JBlishen: Documentation and development both working from design.

Richard: Documentors can be good designers.

Leah will be over this year, and will have some outlines.

Andrew will be managing the book.  It will be shipped with the product.  Andrew 
is amenable to having documents in our information system.

JBlishen: Will the product be shipped with the book, or the other way round.

Richard: That's a quartet decision; it doesn't have to be taken now.

Richard: We don't have detailled requirements for a product.

JBlishen: That's Clive's job.

Richard: We have an analysis from Clive, that's about as far as he can go.  We 
need to refine the product requirements.

JBlishen: I need to know the scope of the work.

Richard: For example, people ask how many pools we'll ship with, and I say 
"about ten". This needs requirements and to be designed.

JBlishen: Dylan requirements are built up over time, as a history.

Richard: I tried to get requirements out of Dylan in 1994.  It was 1996 before 
I could write them down.

JBlishen: Give me a brief description of what we supply to Dylan.

Richard: When Dylan is running, there will be compiled Dylan code, making use 
of a run-time system, much like MLWorks.  As part of that, you need an MM; as 
part of that you need GC.

The Dylan run-time system goes on top of the MPS, and some Dylan format stuff.  
The MPS includes the AMC pool, the wrapper pool, the LO pool, and the MV pool 
and the MPM itself.  Dylans number one requirement is to allocate Dylan 
objects, the number two is to recycle them.  Dylan objects have a layout of 
memory, which is specified by the format.  The object points to a wrapper 
object, and has slots, and then a vector.  The wrapper object describes the 
layout, and points to the wrapper wrapper.  There is approximately one wrapper 
per type.  We don't get involved in the class system.

All this layout code is part of the Dylan format code, and the MPS doesn't care.

We agreed that Dylan would own this code, but we actually maintain it, because 
we know how to.  They ought to maintain it, but maybe this will never happen.

AMC is Automatic Mostly Copying.  This pool contains most Dylan objects.  
Almost everything goes in here.  AMC is reasonably general, but was designed 
for Dylan.  It can cope with ambiguous references, so we don't need details of 
the stack layout.  We can move the objects around.  Dylan is halfway between ML 
and C.  You know some things, but not others.  
We need to know the layout to find the pointers.  In Dylan, we don't understand 
the stack, but we do understand the heap.  Most objects can be moved around, 
but some can't.  A mostly-copying GC is semi-conservative.  

Objects live in a block; blocks live in a pool.  The block is the size of the 
object.  Address space -- space -- pool -- seg -- block -- obj -- word.  seg -- 
page-- word.

At the moment, the AMC pool is the default place for all objects, except for a 
couple of things.  

Pools are accessed via the MPM.  The MPM interface is (mostly) the same of each 
pool.  It supports methods like allocate.  All pools conform to the interface, 
but may add to it.  

An object can go in any pool, but the pools do different things to objects.  
You can have different instantiations of a pool(class) which can have different 
parameters, or be destroyed all at once.  Initially DYlan will use one AMC, and 
a couple of support pools.

JBlishen: The new technology is this MPM and the generic interfaces.  

Richard: Old systems would just have the pool.

JBlishen: They might have a couple of pools in combination.

Richard: Dylan doesn't see the MPM interface, it just talks to the run-time.  
We plan, as a long term requirement, to make this interface available to Dylan 
programmers. 

The wrapper pool could go in AMC, but there is an additional requirement that 
they don't move around.  This is so they can do a hash function, and never 
rehash.  They are still GCed.

JBlishen: Every time you implement a new pool, you have to work out the 
requirements for its behaviour.  

Richard: We only have a few.  For ML, we would do an entirely copying one.  MV 
is just like malloc, it is Manual Variable (sized object).  Some parts of the 
Dylan run-time use this.  LO is Leaf-Only and contains Dylan objects that don't 
contain pointers.  This pool is never protected.  We use protection to do 
incremental GC.  We can't do this if we're using foreign code, because it won't 
co-operate.  Objects passed over the FFI can't be protected.  We require that 
such object have no pointers.  Foreign code is not allowed to poke around with 
Dylan objects.

JBlishen: What is memory protection?

Richard: When you protect some memory, the next time some someone tries to 
access memory, the hardware catches it, and runs some other code, which can 
return, and the access code is restarted, and notices nothing.  The GC does a 
little work.

JBlishen: So the GC works where the program is most active?

Richard: Hitting the protection is quite expensive.  We try to predict, and 
work ahead of the program.  Virtual memory works the same way.

JBlishen: So GC happens just before memory is accessed?  IS that the best 
strategy?

Richard: It is if you need to limit pause times.  If you want best performance, 
you want to stop and complete the GC.  It's quite subtle what is suitable when.

The whole system is incremental.

JBlishen: So the MPM is incremental, but you could have one which wasn't.

Richard: The pools don't care much about whether it's incremental.

Incremental is a requirement from Dylan.  The MPM doesn't have to be 
incremental, it's a generalisation that you don't have to use.  It could be 
made configurable.

JBlishen: Were all these pools and requirements here at the start?

Richard: It's grown.

Any one release meets some of these requirements. 

JBlishen: Will any work need to be done in future release to meet any of the 
already met requirements.

Richard: If Dylan objects were changed, or if a bug were found, we would.

Only AMC copies at the moment, but LO could.

These requirements don't correspond one-to-one to bits of work.  

Root interface is more general that requirements, but meets them.

Validation is piggy-backing on memory manager.

What we lack, as a group, is a document describing how requirements fit in with 
the implementation. 

