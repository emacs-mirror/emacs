             MM/ASG MEETING AFTERNOON OF 1998-03-03 TUESDAY
                        meeting.asg.1998-03-03.2
                             incomplete doc
                           gavinm 1998-03-09

.intro: <cohn>, <richardk>, <gavinm>, <chrisg>, <tony>, <drj>

Lots of useful discussion, mostly digressing from the stated goal of
determining an initial set of actions. Ideas and actions described below,
to the best of my understanding.


1) MORTALITY ESTIMATION

.mort: MM can easily provide traces useful for mortality estimation in the
current GC. Not clear that successful estimation will generalize to
conditions when different organization or collection strategies are in
place, but it's an easy first step.

.mort.idea: We might characterise a reference as to whether or not it is
likely to be the sole reference to an object.

.mort.actions.1: MM to produce mortality traces (or code capable of
producing mortality traces?) for current MM algorithm for ASG. Traces to
include approximately

a) foundation size (ref set?)
b) stack depth
c) range of allocation times in set
d) range of last collection times in set
e) size of condemned set
f) size of reclaimed space

.mort.actions.2: ASG to make initial study on how accurately it can
estimate (f) from (a-e)


2) DEATH PREDICTION

.death: Changed terminology from "lifetime prediction" - it's really the
death of an object we're interested. Death prediction may be useful if done
in either of two ways:

.death.absolute: Death time may be predicted in terms of the time an object
is expected to die (e.g. after 4MB further allocations).

.death.relative: Death time may be predicted relative to a key object - "X
will die shortly after Y dies."

.death.actions: No actions defined yet


3) SCHEDULING COLLECTIONS
 
.collect.idea: Another indicator of when to collect is when the foundation
of a set decreases. 1) It'll be cheaper to collect and 2) it's more likely
to have dead members.

.collect.actions: No actions defined yet


4) ORGANISING COLLECTABLE SETS 

.organise:

.organise.actions: No actions defined yet


5) PARAMETER OPTIMISATION

.optimise:

.optimise.actions.1: MM to assist ASG (Pablo) in understanding parameters
(knobs) that can be easily altered in current MM system.

.optimise.actions.2: ASG to attempt automatic parameter optimization,
trying to find parameters that maximize performance (total runtime?) on set
of benchmark problems (compiling the Dylan library?).


6) PERFORMANCE

.perf: It's not clear yet which actions give the "biggest bang for the
buck" in improving MM/client performance. Tony and Gavin estimate that
Dylan compiler spends 20% total time in MM. It is unknown how much of that
would be saved by having perfect collection (neither too early nor too
late) or perfect organisation into sets. Determining this will require some
analysis and experimentation by MM.

.perf: It's become clear that performance isn't a single number, but an
entire curve that's measured as time/space used versus the resource demands
of the client. Need to further explore how performance is ranked.

.perf.depend: Items 1-4 above have strong performance dependencies,
depicted in the diagram below, where the tail of the arrow depends on the
head of the arrow. These dependencies suggest an ordering in projects
tackled, but don't necessitate it.

        .death < - .organise <- .mort <- .collect
                      ^-----------------

.perf.actions:

6a) MM to determine which of the priorities in
(meeting.asg.1998-03-02.priorities) they expect to allow greatest potential
for improveing performance.

6b) MM-ASG revisit priority list and previous meeting notes
(meeting.asg.1998-03-02.2) to decide on future action.


7) WHAT TO SCAN AND WHEN

.scan: Many ideas here, not clear how to proceed.

.scan.idea.1: Before flip, want to scan things not accessed soon. After
flip, scan things that will be accessed soon.

.scan.idea.2: One heuristic would be to scan descendents of top of stack
first. 

.scan.idea.3: Scan in order of priority queue. Each class has relative
priority of descendents, modulated by priority of referring object. Would
allow mixed DFS, BFS and other strategies.

.scan.actions: No actions defined yet.

