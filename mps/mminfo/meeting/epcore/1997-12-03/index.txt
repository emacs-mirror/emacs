                  MEETING ON MM/EP-CORE ON 1997-12-03
                       meeting.epcore.1997-12-03
                               draft doc
                            pekka 1997-12-03

INTRODUCTION

.intro: Pekka P. Pirinen <Pekka> met with David Gilday <DavidG> to discuss 
MM/EP-core requirements and techniques.


MEMORY PROTECTION

.multiprocessor: Multiprocessor RIP makes copies of all kinds of things in 
shared memory, including PS objects, but David says PS objects aren't accessed.

.tickle: There are two kind of tickles: one just drives output devices and the 
GUI, the other one might recursively invoke the interpreter as well.  MM only 
needs to call the first kind, so there are no protection problems.  In fact, 
currently there isn't even a reentrancy issue since output driving doesn't call 
the MPS at all.


MM DEBUGGING TOOLS

.use: David wasn't familiar with fenceposts and had only wanted to use tags 
once, but was prevented by the promises problem (request.epcore.170465).

.dynamic: Pekka described the dynamic control of checking in MPS, and David 
suggested that similar dynamic control for MM debugging features would be a 
Good Thing.


PERFORMANCE

.radiocas: req.epcore.170541 is not a real problem, but a profiling artifact.

.fragmentation: David noted that the specific case of fragmentation of the font 
cache is no worse with MPS than it was with EPMM.  However, Andy suspects at 
least one fragmentation problem is worse with MPS than EPMM.


FUTURE

.commitment: David was happy with the MPS, and positive about starting to use 
MPS features directly in the core RIP code.

.eulg: David asked whether it would be possible to write a glue layer that 
translated MPS calls to the old MM (instead of vice versa).  Pekka said that it 
should be possible modulo some debugging features, but stressed that it should 
not be necessary if the Core RIP group is firmly committed to MPS.  [We could 
possibly do this piece-by-piece as the core RIP starts using MPS directly.  
Pekka 1997-12-03]


VIRTUAL MEMORY ISSUES

.real-time: David explained that the RIP is a "pseudo-real-time" application in 
that when it is used to directly drive an output device, it must not fall 
behind.  This is why so much care is taken not to page (by keeping within a 
hard limit), and partial painting is preferred to taking the chance of 
thrashing during output.

.not-real-time: However, most end-users RIP to disk anyway, and in this case, 
the only thing that matters is the total throughput.  In this configuration, 
the output system still has to be real-time, but it won't start until it's got 
a whole page on disk.  [There are also plans to detach it totally into an 
indepependent program.  -- DavidG 1997-12-05]  So the RIP _could_ allow virtual 
memory paging, if necessary.

.real-real-time: David proposes that when the RIP acts as a real-time 
application, it should behave like one, locking down all the pages that it 
really needs.

.display-lists: David doesn't think that these can be sorted more cleverly than 
they already are.  The bottom line is that some pages could have every object 
intersecting every band, and the real-time constraint still has to be met.

.working-set: On PC, the RIP tells the operating system that all its pages 
belong to its working set [SetProcessWorkingSetSize], in order to avoid them 
being paged out.  The MPS has to achieve the same effect, one way or another.

