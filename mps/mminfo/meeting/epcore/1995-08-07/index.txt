         SUMMARY OF SECOND EP REQUIREMENTS MEETING, 1995-08-07
                       meeting.epcore.1995-08-07
                               draft doc
                           richard 1995-08-08

INTRODUCTION

.intro: On Monday 7th August 1995, Richard Brooksby, David Moore, David Jones, 
and Nick Barnes met Andy Cave to discuss EP's requirements for Memory 
Management.  We went through the goals (goal.ep(1)) and requirements 
(req.ep(1)) in order to investigate required functionality and stimulate 
discussion.

.scope: This meeting covered the goals, and the following requirements:

  - req.ep.fun.soft.manage.dl (Display List Management)
  - req.ep.fun.soft.manage.ps (PostScript VM Management)
  - req.ep.fun.soft.manage.fontcache (Font Cache Management)
  - req.ep.fun.soft.manage.general (General Management)

We agreed to have more meetings in the same week to cover the rest of the list.


GOALS

Andy agreed with the goals, but had a couple of minor suggestions. 
.goal.compete: For goal.ep.compete, he suggested that we might be able to use 
the MM as positive marketing, rather than just as prevention of negative 
publicity.  .goal.maintain: For goal.ep.maintain, he pointed out that there 
were no developers in EP assigned to the maintenance of MM, because it worked 
OK.  However, if there were a problem, developers would have to be 
requisitioned from their current duties, and so this situation is risky [my 
paraphrasing of his words].

.id: I quietly noted that "EP" stuff was tagged "ep".  In fact, we're involved 
in a relationship to supply MM for the Core RIP.  Perhaps a better identifier 
for this relationship is needed.


REQUIREMENTS

Display List Management

.dl.sizes: Objects in the display lists range from 8 bytes to 128Mb, but might 
conceivably get up to 1Gb in future.  32Mb images are fairly common.  Most 
objects are 8 bytes.

.dl.alloc.multi: Andy said that the RIP currently allocates multiple 8 byte 
objects for speed, and that multiple allocation would therefore be necessary.

.dl.freelast: The last object allocated is often freed almost immediately.  
(Other objects are freed rarely).  A special "free last" operation would 
therefore be useful.

.dl.free: Objects are sometimes freed in the middle of the display list, but 
these are usually large images and not small objects.

.dl.free.multi: The last few objects might need to be freed at once.

.dl.multi: The parallel has a "pipeline" (currently two deep) of display 
lists.  It will be necessary to manage multiple display list instances.

.dl.spinlock: In the parallel RIP the display list contains simple spinlocks.  
The memory must therefore be capable of supporting these.

.dl.nocomp: Compaction of the display list is unlikely to be necessary.

.dl.cdr: Nick suggested cdr-coding of link objects in the display list.  This 
might be worth investigating, but is unlikely to be a responsibility of the 
memory manager.

.dl.compress: Images are sometimes buffered to disk when memory is tight.  
Perhaps compression of display list objects could be used if it were cheaper.  
A cost/benefit analysis would need to be done at run-time.

PostScript Virtual Memory

Note: We deliberately did not discuss all the details of the different types of 
objects, their formats, and interactions.  This can be saved for a later date.  
The meeting concentrated on the main types of functionality that would be 
required.

.ps.sizes: The interpreter allocates objects of typical sizes: 8 bytes, 48 
bytes, 2048 bytes.  There is a 16-bit limit imposed in the language, so strings 
never exceed 64Kb, and arrays are never more than 64K elements long.  Arrays 
could be 64K*8b plus a small overhead, and dictionaries could be 64K*16b plus a 
small overhead.

.ps.save: Stack-like save/restore mechanism will be required.  .ps.save.check: 
Restore must check for invalid references beyond the save marker.  This is the 
first step to root management.  .ps.save.vers: Updatable PostScript objects 
must be versioned and rolled back on restore, except strings.

.ps.local: Local and global memory must be managed separately.  Save/restore 
does not affect global memory, except at levels zero and one.  The local and 
global memory are essentially instances of the same thing, so this is easy for 
the pool/class model.

.ps.rehash: The RIP currently hashes on pointers.  This could be changed, but 
if it isn't then there will need to be some sort of protocol for rehashing 
tables.  .ps.iter: The "for all" operator is an iterator on dictionaries which 
must reach all elements correctly even if a GC occurs.  There is some leeway 
here.

.ps.nozero: There are no zero-sized objects any more.

.ps.font: There can be between 1 and 10Mb of "composite font" information, 
which is never garbage, and is only freed by a restore operation.  These could 
be managed separately.

.ps.jobs: Typical jobs use between 100 and 300Kb of PSVM, with an extra 100 to 
200Kb burst when using fonts.  Jobs of 16Mb are "surprising".

Font Caches

.fontcache.sizes: Font cache objects are typically 1K, 64b, 128b, 32b and 
thereabouts.

.fontcache.jobs: The font cache memory is unbounded in size.  It can grow and 
grow, especially when using Japanese fonts.  We will have to cope with large 
volumes.

.fontcache.refs: Font cache entries are referenced from the display list, and 
from the "graphics state", an internal RIP object.

.fontcache.recycle: Font cache flushing and recycling would be nice, but is 
handled by the RIP itself at the moment, so the minimum functionality is a 
simple malloc/free interface.  However, GC, compression, and compaction of font 
caches is desirable.

General Temporary Memory

.general: A malloc/free interface is all that is needed.  The RIP does not use 
much of this.  Usually at most 100Kb total.


OTHER NOTES

.align: Objects are currently rounded and aligned to 8-byte boundaries.  This 
could be changed.

.phases: There are clear phases of processing, with different memory 
characteristics (interpret/render).  We could almost certainly benefit from 
knowing when these occur.

.prefetch: Large images, and other large objects, are generally accessed in 
linear order through memory.  There might be opportunities for optimization 
there.

