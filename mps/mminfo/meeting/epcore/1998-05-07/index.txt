                       VM ARENAS FOR SCRIPTWORKS
                       meeting.epcore.1998-05-07
                               draft doc
                          richardk 1998-05-07

.intro: Rit wanted to test vm arenas in SW; could he write this into SW_B1?  
Richardk wanted to collate info on why and how SW wants vm arenas.  Rit and 
RichardK talked with DRJ and GavinM.  Then went down to talk to EricP.  DTB and 
Andy (C) joined in.  It became an informal meeting.

.summary:
  - Rit will integrate vm arena in his local copy of SW_B1, for testing.
  - SW(trunk) now makes fewer large allocations.
  - SW's small footprint, to cooperate with other processes, is important.
  - SW<-->MPS communication is needed to decide how to make memory available.
  - SW<-->MPS communication is essential to prepare SW for increased paging.

.followup: RichardK will collate this info, and info from other mails and 
meetings and requirements, and ensure the persistent documents (eg. req.epcore) 
reflect this info, with appropriate links etc.

.write-up: This document is RichardK's write-up (procès-verbaux) of the 
meeting.  It has been written without reference to other documents.  [I'm sure 
many of these issues have been at least touched on before, but I wanted to make 
sure I captured everything ep said to us today before I searched for past 
discussions. richardk 1998-05-07].

.hist.0: Written and emailed to mm by richardk 1998-05-07.

.hist.1: Added "Effort" section at end.  richardk 1998-05-07.

.hist.2: Noted that avoiding untimely arena-extension and paging overhead is 
essential (.req.fun.comm.before-paging).  richardk 1998-05-07.


WHAT RICHARDK COULD REMEMBER

.goal.vm-arena.remember: Quick chat in home-hill suggested the main goal was to 
solve arena fragmentation.  Mal-scenario: there is nowhere to create a big 
segment, because the arena address space is fixed, and the gaps (contiguous 
ranges of free pages) between existing segments are numerous but too small.  So 
vm arenas should improve large-object (> default seg-size) allocation.


USING SW_B1 FOR TESTING VM ARENAS

.want.vm-arena.sw-b1: Rit wants to use SW_B1 if possible, because it gives 
comparison-continuity and is stable.

.anal.vm-arena.integrate.sw-b1: Work to integrate (start using) vm arenas in 
SW(trunk) was under SW bug 21456.  Integrating into SW_B1 shouldn't be hard.  
There's a small code-change in coreskin (NB: coregui -> coregui/coreskin split 
is not present in SW_B1).  EricP thought Pekka did some larger changes to glue 
code: ask Pekka or look at diffs.


LARGE ALLOCATIONS

.usage.large: What is the pattern of SW's use of large allocations?

.usage.large.image: In trunk, images are now tiled (broken into smaller 
sub-images).  Previously (SW_B1 certainly, and perhaps also SW_C?) images were 
single objects, and caused large allocations.

.usage.large.halftone-cache: DRJ said halftone-cache will request large 
allocation, but if this fails SW will ask for smaller pieces.

.need.large: EricP et al said that large allocations were much less critical 
now that the images are tiled.  But trapping still uses quite big objects and 
the code cannot be changed.


KEEP SMALL FOOTPRINT, DO NOT HOG MACHINE RESOURCES

.need.small-footprint: EricP and DTB emphasised that SW must be pro-social.  
(For some customers SW has the whole machine, but for others it doesn't).  SW 
should not take a larger memory-footprint than it needs at the moment.  SW 
should release memory for other processes to use when it can easily do so.

.scenario.small-footprint.multiple-sw: A big customer runs 4 copies of SW on a 
4-CPU machine with 256M of memory.  Big selling point if SW would share this 
256M sensibly.  Do not want to hard-wire only 64M per rip.

.scenario.small-footprint.helper-app: Customer runs SW as a helper-app to rip a 
few bits of PostScript, as part of using (say) FrameMaker or Photoshop 
[RichardK thinks there is not an actual customer who does this currently].  
Want rip to start with small footprint, be able to grow, but release memory 
once it is unused again.


WHY SW<-->MPS COMMUNICATION IS NECESSARY

.need.comm: There needs to be communication between SW and the MPS.  This point 
was made strongly by DTB and Andy, and it seems there's been some resistance 
from the MM group to providing this in the past.  FWIW, RichardK quite agrees 
that SW needs to work more closely with MPS than many simpler clients would.

.need.comm.make-mem-avail: When memory is tight, someone needs to make memory 
available.

.need.comm.make-mem-avail.decide: SW can trim font caches, or paint to disk.  
MPS can enlarge the arena (taking more segments from the OS).  Which is best?  
Communicate to decide.

.need.comm.make-mem-avail.prepare: At some times, preparation is necessary 
before a choice is acted on.[For instance: waiting for output to finish; see 
following paragraphs.  richardk 1998-06-03]

.need.comm.no-paging: Particularly: when SW is outputting to a setter it must 
not be slowed down by excessive paging.  (SW timing during output is often 
exceedingly close to failure, and must not get degraded).

.req.fun.comm.before-paging: SW must have a way to stop MPS from inducing 
paging, and/or a way to finish output before giving MPS the go-ahead to go 
beyond a 'safe' working set.  Essential.  It is believed that vm arenas in 
MM/EPCORE don't currently support this, and this could be a 'stop-ship' defect 
for SW 5.0.


HOW SW<-->MPS COMMUNICATION COULD WORK

.sugg.comm.ask: Simplest is for MPS to call out to SW, in the middle of trying 
to allocate an object, asking "I wish to extend arena like this, is that 
okay?".  SW may (a) say "go ahead" or (b) free some memory and say "no, try 
again" or (c) say "wait until I finish outputting this page".

.scenario.no-problem: MPS asks "can I extend" and SW sees that current 
footprint is small and says (a) "go ahead".

.scenario.sw-frees-fonts: MPS asks "can I extend" and SW frees 100M of font 
cache and says (b) "no, try again".

.scenario.sw-halts-while-outputting: MPS asks "can I extend" and SW sees that 
current footprint is about at real-RAM size, but it has nothing it can free (or 
not cheaply), _and_ a page is being sent to the setter.  So SW says (c) "wait 
until I finish outputting this page" or doesn't return yet or something.

.scenario.sw-allows-limited-extend: MPS asks "can I extend" and SW sees that 
current footprint is about at real-RAM size, but it has nothing that is cheap 
to free.  There is no output happening, and it is worth risking a bit of paging 
rather than doing an expensive partial paint, so SW replies (a) "go ahead".

.scenario.sw-frees-dl: MPS asks "can I extend" and SW sees that current 
footprint is already > real-RAM size, but it has nothing that is cheap to 
free.  There is no output happening, and so SW does a partial paint, and 
replies (b) "no, try again".

.scenario.sw-allows-huge-extend: MPS asks "can I extend" and SW sees that 
current footprint is already > real-RAM size, but it has nothing to free.  
There is no output happening.  We're trapping a complex job.  The best we can 
do is allow mem usage to bloat, so SW replies (a) "go ahead".


PROBLEMS AND ISSUES

.prob.ask: It might be hard/bad for the depths of MPS to call out to SW.  It 
might need re-entrancy constraints, which are hard when programming 
in-the-large.

.sugg.comm.fail-code: Instead, could return a failure code.  SW catches this, 
does decision and preparation, and re-requests the allocation.


EFFORT

.effort.meeting: The meeting took about 2 man-hours of MM time (Rit and 
RichardK, counting preparation for meeting).  It took about 2 man-hours of EP 
time (EricP and DTB with contributions from Andy (C)).

.effort.write-up: Write-up took 3 man-hours of RichardK's time, trying to get 
it to be clear and a complete capture including detailed scenarios.

.effort.followup: RichardK will do more followup.

.effort.just: Without this followup, there is a risk that SW's adoption of vm 
arenas will cause SW-customers to report bugs, which is baad.


