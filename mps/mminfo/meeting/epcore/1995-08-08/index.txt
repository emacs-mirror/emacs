          SUMMARY OF THIRD EP REQUIREMENTS MEETING, 1995-08-08
                       meeting.epcore.1995-08-08
                               draft doc
                           richard 1995-08-08

INTRODUCTION

.intro: On Tuesday 8th August 1995, Richard Brooksby, David Moore, Nick Barnes, 
and Tucker Withington met Andy Cave to discuss EP's requirements for Memory 
Management.  This meeting followed on from meeting.1995-08-07.  We continued to 
go though the requirements list (req.ep(1)).

.scope: This meeting covered the following areas of the requirements:

  - req.ep.fun.soft.compact to .env (remaining functional requirements)
  - req.ep.attr.quality.work (working ability)


REQUIREMENTS

.compact: This requirements should be removed.  There's no need to specify that 
we _must_ compact memory -- that's just an implementation technique for 
achieving throughput, which is specified later.

.low: Need to be able to set up low-memory condition callbacks on various 
levels.  In some modes, the RIP needs to be able to allocate bands down to the 
last byte of memory.

.prefetch: Cache of page prefetching would be nice.  The RIP has quite 
well-defined access patterns that we might be able to take advantage of.  We 
might be able to do prefetch if a thread are not blocked when another hits a 
page fault.

.unfetch: The RIP does quite a lot of one-shot sequential access to memory, and 
often knows when it doesn't need something for a while.  We might be able to 
take advantage of this to swap out, lower priority, or otherwise control memory.

.arena: The MM must manage a large fixed area of locked-in memory which is 
supplied at boot-up.

.psgc: PostScript defines operators for controlling GC: No GC, force GC, etc. 
(see PS reference man)

.log: The RIP uses internal benchmarking and writes results to a log file which 
is compared using a tool to measure performance regression.  The MM could 
contribute to this log, and this might be a good technique for us anyway.

.vis: Can we give some visual feedback while running?

.assert: We must be at least as assertive as the current RIP memory manager.

.check: We need to supply consistency checking on-demand, with controls over 
the complexity of those tests.

.diag: Diagnosis and analysis of usage not required, but would be nice.

.debug: Debugging support must be at least as good as the present system.  We 
must analyse it.

.env.lib: The RIP calls out to a list of "approved functions" (atan2, bzero, 
etc.) which are supplied by the skin.  The MM may only use these functions.  
(Ask Dave Earl for Core RIP manual.)  In particular there is no file system.  
EP might consider extending this set, but these should be avoided.

.env.strip: EP use a tool to strip symbols out of the RIP.  This probably won't 
affect us.

.env.c: The MM can be delivered as a standard linkable object file or library 
for the platform (with headers, of course).  This could be checked into HOPE as 
part of EP's build system.  We are not required to integrate our build system 
with theirs in any way.  Debug/speed/release target varieties will be needed -- 
we can decide on these later, and the list will no doubt change.

.work.speed: Must be at least as fast on:
 - Seybold tests (a new set of which may be coming out soon)
 - Gurber speedmass (killer jobs)
 - Some other customers in particular (ask which).

.work.few: We can afford to be "a few percent or a few seconds worse on jobs 
that people don't care about" (Andy).

.work.qa: We should talk to Peter Westlake about dividing upthe QA test suite 
and test categories.

.work.bench: Benchmarks are often run in single mode.

.work.rate: The work rate for particular benchmark jobs must be similar to 
current rate.  Jobs must be run in a consistent time -- roughly the same 
whenever the job is run.  A second or two either way probably won't matter.

.mail: See also Andy's mail about throughput (mail.andy.1995-08-08.10-47)

.tickle: The GC must tickle devices even if not RIPping.  Output plug-ins may 
still be operating.

.single: Explanation of "single" and "multiple" mode.  The RIP is producing 
page buffers (pgb).  In single mode it tries to rasterize as many bands as 
possible, scavenging as much memory as possible.  It may deliberately exhaust 
memory.  Mutli mode is decoupled, then the job is to produce page buffers as 
fast as possible on disk.

