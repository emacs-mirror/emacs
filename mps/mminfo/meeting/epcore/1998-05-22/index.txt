               MEETING.EPCORE.1998-05-22 -- SHADED FILLS
                       meeting.epcore.1998-05-22
                             incomplete doc
                          richardk 1998-10-09

[ This needs to be tidied up -- it languished awaiting corrections (which I 
still haven't done) and has only today been entered as a meeting.  WARNING!  
Some parts may be wrong.
- richardk 1998-10-09]

.intro: On 1998-05-22 RichardK chatted to Angus about shaded fills (a new 
feature of PostScript 3).  This document is a rough analysis of the 
implications for ScriptWorks memory usage.  In mail.richardk.1998-06-02.14-03, 
he asked Angus or PaulC to read this document and point out any gross 
mistakes.  [As far as I know, they didn't.  pekka 1998-12-17]

.sw-doc: In non-memory-related details this document may be somewhat
economical with the truth!  For more detailed and correct documentation
search for "Gouraud" in the ScriptWorks Information database in Spring.


SHADED FILLS IN POSTSCRIPT

.vignette: In PostScript Level 2, a path could only be filled with a single
flat color.  To achieve a shading effect, the PS job had to make a sequence
of elements of successive colors.  This sequence construct is called a
"vignette" or "graduated fill".

.shaded-fill: In PostScript 3, new PS operators etc (eg. "shfill") are
defined, which describe shaded fills using either (a) Gouraud-shaded
triangular patches or (b) rectangular patches (called "tensor patches")
with bezier-equations describing the color-gradation.

.gouraud: Gouraud shading means linearly interpolating color values in some
color space.  (As distinguished from, say, Phong shading, which
interpolates surface normals).  Gouraud shading is quite quick.


SHADED FILLS IN SCRIPTWORKS

.triangles: During interpretation, ScriptWorks decomposes each shaded fill
patch into a net of triangles that can be Gouraud-shaded in device
color-space, and adds these triangles to the display-list.

(.decomposition: Decomposition means replacing a single complicated
graphical element with a collection of simpler elements which can be
rendered quickly.  For example, ScriptWorks renders bezier-lines by
decomposing each one to a series of straight-line segments.  The
replacement (simple) elements are recursively subdivided, until they are
sufficiently fine-grained to approximate the original (complicated) element
to within a user-specified tolerance.  This is an exploratory process: SW
does not know in advance how much memory etc it will use to decompose an
element.)

.tri-data: ScriptWorks allocates memory for triangle-data during
decomposition of shaded fills.  There are three major lifetime patterns:

  .tri-data.dl: Some of this triangle-data will be part of the final
    display-list for the page, and is 'long-lived' as far as
    interpretation is concerned.

  .tri-data.decomp-control: Some of the triangle-data is only needed to
    control the process of recursive decomposition of a patch.  (SW must
    monitor how close-to-tolerance, in the color dimensions, the
    decomposition-approximation is).  Most of this data is thrown away when
    the patch is successfully decomposed.  Memory usage here may be
    approximately stack-like.

  .tri-data.seam-smoothing: Some of the triangle data may need to be
    kept, in order to influence the decomposition of neighbouring
    patches, and keep seams between neighbouring patches smooth.
    (Without this, gaps or edge-blemishes can occur).  For a grid of
    patches, up to one row-width of edge data may need to be kept at a
    time.  Memory usage pattern here may be 'rolling' or 'bi-stack'.

  .tri-data.misc: It should go without saying really, but there may well
    be time-interleaved allocations of other miscellaneous stuff too.

.tri-data.decomposition.note: Note that the desired color interpolation is
specified in user color-space, which may be highly non-linear when viewed
in device-space.  So even 'simple' PS-level triangular patches may require
a lot of decomposition.


IMPLICATIONS FOR OTHER PARTS OF SCRIPTWORKS

.pool: In which pool does ScriptWorks currently allocate .tri-data?

.affect.dl.more: The final display-list may be bigger, from containing many
individual triangle objects.  Or, to reduce overhead, SW may be written to
hold several triangle elements in a single collection-object.  [Is this
analogous to using threads for chained straight-line segments?  richardk
1998-05-22]  The memory usage pattern should be broadly similar to current
usage.

.affect.dl.promises: Using EPDL promises for collections of triangles might be 
good, but might break the current promise design because of the need to 
time-interleave other allocations.

.affect.dl.frag: Experience with time-interleaved allocation of non-dl objects 
and dl objects, e.g., with trapping, shows that risk of dl fragmentation needs 
to be considered. [I think this is untrue, at least trapping works fine.  pekka 
1998-12-17]

.affect.color-store: Potentially, each triangle vertex may have a unique
color, and require a unique entry in the color-store [pool?].  This allocation 
will (probably) be time-interleaved with allocating tri-data.

.affect.color-store.less: In order to reduce the count of unique colors, at
the expense of fidelity, ScriptWorks may round the color coordinates to
'round numbers'.  (I suppose this is "posterising"; see "masking of the
LSBs" in ScriptWorks Information).


ATTRIBUTE ESTIMATES

.est.dl-objects: In ripping his 'monster test-pages', Angus has seen over
10,000 triangles on the final display-list.

.est.total-bytes: For the same 'monster test-pages', using a bespoke
suballocator but adding individual triangles to the display-list, Angus has
seen the rip require 20 megabytes.

.est.sizes: How big are the various pieces of triangle-data, at various
times?  Is there a need to shrink objects (a la promises)?

.test-job: To help MM testing, please could EPCore provide MM with a
moderately tough shaded-fill test-job.


COMMERCIAL IMPACT

.use.demo: Shaded fills are a prominent feature of PostScript 3.
ScriptWorks has been demoed interpreting them.

.use.typical: Run-of-the-mill PS-producing applications, and PS-producing
drivers (ie. operating-system code), are likely to start using simple
shaded fills instead of PostScript Level 2 vignettes.

.use.drawing: Sophisticated drawing applications (including 3D modellers)
are likely to start generating large shaded fills (that is, with many
patches).

.use.tensor.rare: Opinion on tensor patches (type (b) in .shaded-fill
above) is that they are a bad compromise, being hard to use without giving
very good appearance.  The simpler triangular type will probably have more
commercial impact.

.use.competition: There is a risk that a 'killer job' will become famous
and widely used.  (There's a risk that we may produce just such a job to
show up our competitors! :-).  In this case performance of an atypical job
may be commercially important.

.use.custom: RichardK speculates: might some large rendering-software
vendor want ScriptWorks specifically for making hard-copy of on-screen
graphics?  In this case memory constraints might become stringent.


WORK AND DATES

.now: Epcore are well into the work, and it has already been demoed.

.suballocator: SW code currently uses a suballocator.  Angus would like to
throw this away (and use a standard MMI and/or MPS interface instead,
presumably).  This would require some analysis in cooperation with the MM
group.

.suballocator.note: The SW suballocator currently allocates chunks from the
temp pool, and maintains freeness with hybrid watermark and in-band
freelist.

.ship.beta: SW 5.0 Beta will be finalised mid- or end- June 1998.  Shaded
fills should work.

.ship: The first full release of SW with shaded fills will ship in SW 5.0.  
Shaded fills should work well.

