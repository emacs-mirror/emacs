                 MPS ALLOCATION POINT PROTOCOL MEETING
                       meeting.doc.1997-01-17.a-p
                             incomplete doc
                             lmb 1997-05-12

INTRODUCTION

.intro: Richard Brooksby and Leah Bateman met on 1997-01-17 so that Richard 
could explain the allocation point protocol.

.scope: This document covers Richard's explanations of the allocation point 
protocol. 

.readership: It is suitable as background reading for new staff members and as 
a basis for user documentation.

.issues.other-doc: When used as part of an intro to the MM product, this docu-
ment should be read in conjunction with design.mps.interface and various of 
the meeting.qa entries. Allocation points were formerly known as buffers. 

.issues.errors: If you note any errors in terminology, please point them out to 
Leah. 

.issues.syntax: The syntax of the pseudo-code has not yet been checked.


PURPOSE

.purpose: Allocation points improve performance in the following two ways:

* By avoiding locking synchronization.

* [???]


TYPE

.type: Allocation points are not abstract data types. Client programs can know 
the structure and directly modify fields, but must obey a certain protocol. 
There are four kinds of allocation:

* Two-phase allocations with loop

* Two-phase allocations that are always successful

* One-phase allocations

* Promises -- you can ask for a certain amount of memory. This type of alloca-
tion only deals with Limit (see below). [Need a lot more here.]

The pool you are using determines which allocation protocol you use; some 
pools require certain allocation protocols.

[We may want to include a discussion of "alloc". We may do all allocations 
using APs.]


STRUCTURE

.structure: Allocation points have a structure of three words -- Init, Alloc, 
and 
Limit. 


TWO-PHASE ALLOCATION PROTOCOLS

.phases: Two-phase allocation protocols have two possible actions: Reserve 
and Commit.


USING ALLOCATION POINTS

.use: You have five choices about how to use allocation points:

* Write his own code in C 

* Write his own code in assembler 

* Use our functions 

* Use our macros 

* Use our block macros

[.decision: The documentation should be able to give figures for deciding 
which of the five methods to use. 

.conditions: The documentation should also define the environments and con-
ditions under which the developer would want to use the five options listed 
above (e.g., if s/he is using threads, then s/he'd want to use Option X). Also, 
some constraints can be relaxed, depending on the environment in which the 
MPS is being used.]

[On the DEC Alpha, code can be optimized during runtime, so we have 
"memory barriers" that ensure that the code is executed in the order *we* 
specify. Need to fit this in somewhere.]


PSEUDO-CODE

.pseudo-code: The pseudo-code for an allocation point is as follows:

do { 
       res = mps_reserve(&p, ap, size) ;
       if {
            res != RES_OK, 
               do something ; } 
            else init(p) ; 
          } while (!mps_commit (ap, p, size)) ;

The last line means, "As long as the commit hasn't been performed, go back 
and do it over".

&p = please put the result also in p 

ap = the allocation point that the client programmer is dealing with 

size = the size of memory you want


RESULTS

.results: If the code fails, the client program doesn't get the memory it 
wants. 
If it succeeds, the memory is allocated in a block whose address is "p". "init" 
can be code written by the client programmer; it has to be filled in with an 
object.


INTERACTION WITH FORMATTED POOLS

.formatted-pools: The two-phase allocation protocol is used to accommodate
the needs of formatted pools. [The pool class documentation must tell which 
type of allocation protocol to use.] If the 
memory isn't formatted, the pool will be unhappy; the init phase clears the 
memory and formats it appropriately by putting a blank object in it.

.combination: If the client program is not using a formatted pool class, the 
reserve and the commit can be done at the same time.

.commit: After initialization, you can do the commit. The pool needs to know 
that the object has been initialized, and the commit informs the pool that the 
object is ready. If the commit fails, which should be rare, the memory is not 
allocated and you have to start from scratch. The code returns TRUE if okay, 
FALSE if it fails.

.commit.fail: Some pools need to have the commit fail. <This should be 
specified 
and explained in the documentation. We should also assure the reader that 
this is for efficiency's sake (i.e., their own good) and will happen very 
rarely.>


IMPLEMENTATION DETAILS

.details: A chunk of memory is passed to the client program, which can allo-
cate it using the protocol.

Doing a reserve increments Alloc (but not past Limit).

.reserve.code: Reserve:

T = A + size ; 
if (T > L || T <= A)      /* overflow check */ 
   res = mps_ap_fill(&p, ap, size)     /* ask MM to give you a 
                                                        bigger chunk of memory 
*/ 
else {
          A = T ; 
          P = I ; 
          res = OK ;
        }

Then the client initializes the memory, then commits it:

.commit.code: Commit:

A = I ;
if (L = 0) 
   b = mps_ap_trip(ap, &p, size)   /* calls MM */ 
else b = TRUE   /* b = boolean result */

.check.L: The pool can poke L to 0 whenever it likes in order to regain 
control, 
so the commit code has to check that the pool has not done this between the 
reserve phase and the commit phase. Whenever the MM is invoked, it can do 
whatever it likes, so the client cannot assume that LAI will stay the same. 
Outside of invoking the MM, Alloc and Init will not change unless the client
changes them. However, L can change at any point. The client is not 
allowed to change L itself; it can change Alloc and Init as long as it follows 
the 
protocol.

[For My Information: L goes to 0 when the GC "flips" because the MM can't scan
the client program's memory block, and so has to assume it's been junked. The 
MM 
therefore wants to reallocate the block and so takes it back from the client 
pro-
gram. The likelihood of this happening is pretty low.]

.atomic: The updates (writes) and reads of Alloc and Init have to be atomic 
with respect to threads. This means that the client program must read the 
whole thing at once (one instruction in machine code). [We might provide 
assembly language code for some processors.]


ALIGNMENT

.alignment.bkgrnd: Some processors require that you align accesses to mem-
ory; others just work better if you do. For example, a double precision 
floating 
point number must be aligned on a double boundary (that is, its address must 
be a multiple of 8). 

.alignment.pool-class: As a consequence of this, every pool class has an align-
ment. If the pool alignment is eight bytes, then all allocated objects must be 
eight bytes. If a six-byte object is allocated, two bytes are wasted. The pool 
class alignment is defined as part of the interface (MPS_PF_ALIGN) and is the 
default alignment for that pool.

.alignment.platform: The platform alignment is the maximum of all 
alignments on that platform. If objects are allocated at platform alignment, 
generally everything is allocated with no problems, but a lot of space is 
wasted.

.alignment.rounding: If the client allocates memory using an 
allocation function, the function sorts everything out for her. If she is using 
reserve and commit, she has to round allocations up to the pool alignment. 
Alloc and Init always need the correct alignment -- if the pool size is four 
bytes, 
then the size variable must be four bytes. Alignments of eight bytes mean the 
last three bits are 0, etc.


GROUP ALLOCATIONS

.group-alloc: The client is allowed to do a reserve for more than 
one object at once. The procedure is: 

1.  Alloc is bumped up as before.

2.  All objects are initialized.

3.  All objects are committed.

.group-alloc.warning: The client should be careful about doing this for
large numbers of objects (over half a page, or thereabouts), because it may 
cause external fragmentation. [This needs to be discussed in more detail.]


MACROS AND FUNCTIONS

C allows programmers to do the following:

in header: 
   foo /* function foo */
   foo /* macro foo */

in program:
   foo(x,y,z) /* calls macro */ 
   (foo)(x,y,z) /* calls function */

To call the function without using parentheses: 

   #undef foo foo(x,y,z)

In the reserve portion, the MM provides the following

functions:
   mps_reserve
   mps_commit 

and macros:
   MPS_RESERVE
   MPS_COMMIT

.macro.warning.side-effects: The difference between macros and functions is 
that macros may evaluate their arguments more than once. For example, the 
macro MPS_RESERVE(&p, ap, size++) expands into code that may contain 
size++ in more than one location, causing the compiler to evaluate it more 
than once. Therefore, clients should not use side effects in macros.

.macro.warning.l-values: In the block macro 
MPS_RESERVE_BLOCK(res_var, ptr_var, ap, size), the variables have to be 
l values -- that is, things that values can be assigned to -- because the 
compiler 
handles variables better than pointers.


SUMMARY OF RESTRICTIONS

* You have to initialize memory if you are using formatted pool classes.

* You cannot assume that the values of Alloc and Init will remain the same 
   if you invoke the MM.

* You cannot assume that the value of Limit will ever remain the same; you 
   have to check it before using it.

* You cannot change the value of Limit yourself.


