                      MPS FORMAT PROTOCOL MEETING
                     meeting.doc.1997-01-17.format
                             incomplete doc
                             lmb 1997-06-10

INTRODUCTION

.intro: Richard Brooksby and Leah Bateman met on 1997-01-16 to discuss for-
mats in the Memory Management product.

.scope: This document covers Richard's explanations of formats.

.readership: It is suitable as background reading for new staff members and as 
a basis for user documentation.

.issues.errors: If you note any errors in terminology, please point them out to 
Leah. 

MEETING CONTENTS

.def: Formats are objects that allow the client programmer to tell the MPS 
about object layouts. .existing: Currently, there is only one format, which is 
designed to tell the MPS where the references are in a client object (the MPS 
has to be able to find the references in an object to GC). .other.formats: 
Other 
formats may be implemented later. .example: For an example, Leah should 
look at the Dylan container format (design.dylan.container).

.writing: The programmer must write his own format code, following the 
guidelines set out below.

Methods in the existing format

.existing.methods: The one existing format contains pointers to code that 
allow the client programmer to manipulate the contents of the memory block 
opaquely. The format is a class, the blocks are instances of that class.

[above is either unclear or untrue, format is a datatype that is abstract to 
the client and concrete to the mps, formats are created from variants.  A 
variant is transparent both to client and MPS.  I suspect this paragraph is 
talking about the methods that comprise a format.  Each method is a pointer to 
a function (ie to some code) that the client has written.  typically the 
methods operate on blocks of memory (client objects).  The client has written 
the functions that manipulate the blocks of memory so the blocks are 
transparent to the client.  Use of the format allows the MPS to treat the 
blocks opaquely, because the MPS manipulates the blocks only by calling methods 
in the format.  -- drj 1997-07-04]

.existing.method-choice: The Dylan format contains methods that the Dylan 
GC needs; other formats apply to other GCs. The MPS calls these methods 
when it needs to perform an operation on an object. The methods in the cur-
rent format are:

Skip Skips a pointer from the beginning to the end of an 
object. Takes a pointer to the object and a size, which 
has to be encoded in the object or else determined some 
other way.

[skip takes just a pointer to the object, not a pointer and a size.  skip must 
(ie the client is obliged to write the function so that it) return a pointer to 
the end of the object.  Hence the size of the object must be encoded in the 
object or determinable some other way -- drj 1997-07-04]

Copy Makes a copy of the object in another location. Takes 
pointers to old and new locations.

Pad Makes a fake object. Takes a pointer and size; fills in a 
block of memory with the fake object. The fake object 
behaves just like a real one, but contains no data. This 
method is useful when you have a small bit of space left 
over somewhere, because then the program doesn't 
need to worry about the leftover space. (There are other 
reasons why this method is useful.) The fake object 
needs to be able to be as small as the alignment, which 
is quite small in programming terms (~4-8 bytes).

Fwd/Isfwd Used when the MPS wants to move an object to another 
location in memory. Fwd takes two pointers, to the old 
and new locations, and adds a "broken heart" (forward-
ing pointer) to the old location. The broken heart may 
have to be quite small (~a word in Dylan).

Isfwd gets a pointer to the object and returns "moved" 
or "not moved". It lets you distinguish between a bro-
ken heart and a real object.

[in the case where the object is in fact a broken heart isfwd also returns the 
new location.  This new location is (should be) the same as the new location 
that was passed to fwd when this broken heart was created (broken hearts are 
only ever created by calling fwd).  -- drj 1997-07-04]

Scan This is one of the most critical client functions. It has to 
be fast if the GC is going to be fast, because all objects 
will be scanned at some point. Takes an object and a 
function.

Scanning

.scanner.use: One use of the scanner is that the GC scans from the roots; 
another is to print or to draw a Watson-type chart. Regardless of use, the scan-
ning needs to be done and needs to be done fast.

.scanner.layout: The general layout of a scanner is as follows:

scan(obj, func) 

func(p1)

func(p2) 

etc. /* apply func on all pointers in object */

.scanner.roots: The material on scanning probably also applies to roots. 

.scanner.func: The function is something else that the MPS wants to do. It is 
not necessary for the client programmer to know what that action is.

Example of a scanner in pseudo-code

.scanner.ex.pseudo-code: A possible pseudo-code implementation of a scan-
ner is:

mps_res_t foo_scan(mps_fix_t fixer, mps_addr_t object)

 [decode object format] 

 MPS_SCAN_BEGIN(fixer) 

 [finds pointers] 

 if (MPS_FIX1(fixer, ptr)) /* test whether interesting */ 

  MPS_FIX2(fixer, ptr) /* if yes, then fix */ 

 if (res != RES_OK) 

  return res ; 

  etc. 

 MPS_SCAN_END(fixer) ; 

 return MPS_RES_OK ;

.scanner.fix-1: MPS_FIX1 is a fast test.

.scanner.fix-2: If MPS_FIX2 fails, then the scan has to start over. FIX could 
be a 
function, but ...

.scanner.begin-end: MPS_SCAN_BEGIN sets up local information used by 
FIX1 and FIX2, making things faster. MPS_SCAN_END takes the information 
changed by FIX1 and FIX2 and puts it aside for the MPS to come back to later. 
FIX1 and FIX2 may not be used except within SCAN_BEGIN and 
SCAN_END, which can only be used in scanning functions.

Scanner optimization

.scanner.speed: One way to make the scan fast is to avoid calling the function 
unless necessary. (FMI: The commonest case of this is when the object isn't 
going to die anyway.) When writing a scanner, the client programmer can use 
special macros to help optimize it.

.scanner.avoid: Writing good scanning functions is an art form. The client pro-
grammer wants to avoid using FIX2 unless necessary, and wants to avoid 
using too many local variables between SCAN_BEGIN and SCAN_END, 
because the number of registers is limited, and the scanner is faster if it can 
store all values in registers.

Example of a scanner using a simple Lisp object

.scanner.ex.lisp: The cons contains a magic bit that is clear if the object con-
tains any pointers, and set if it does not. If the bit is clear, then the 
scanner 
needs to fix the object. If not, the scanner can skip it. Because the object is 
so 
simple, the scanner can perform FIX1 and FIX2 at the same time.

pair_scan 

 if (flag) 

  MPS_SCAN_BEGIN(fixer) 

  res = MPS_FIX(...car) ; 

  if res = 

   res = MPS_FIX(...cdr) ; 

  if res = 

   MPS_SCAN_END(...) 

 etc.

More points about the methods in a format

New functions that manipulate objects in functions ???

.func-comb: Different formats may be combinations of different functions. The 
combination required depends on the pool class's requirements, which dictate 
which functions the programmer must write. The documentation should 
explain what combinations are required for each pool. (Ex: A pool class that 
doesn't use copying GC won't require Fwd, Isfwd.)

Relationship between formats and allocation points

.rel.ap: The client program must allocate and initialize, etc. before being 
able 
to run the scanner. Otherwise, the object will contain only junk.

Relationship between formats and incremental GC

.rel.inc-gc: The GC work is done in small chunks; the MPS decides when these 
chunks happen, and they can happen at any time. During a chunk of GC 
work, the MPS may need to use format information, so the format code must 
be completely independent of the rest of the client program's code.

.rel.inc-gc.protection: The MPS can use memory protection to see what has 
changed during IGC. For example, in tri-color marking, the MPS read-protects 
gray nodes so that black nodes can't read them. If a black node tries to read a 
gray node, the MPS has a chance to come along and change the gray node to 
black, if required. Another example is to write-protect a black child so that a 
gray parent can't write to it.

.rel.inc-gc.ex: NOT TO BE DOCUMENTED: An example of using a scanner is 
tri-color marking: FIX1 tells whether the node is white (if it's black or gray, 
it's 
not a candidate for recycling), and if so, FIX2 is run on the object to turn it 
gray. This works because the object is a pointer; otherwise, it wouldn't be 
scanned in the first place.

Restrictions on format code

.restr.independence: Format code may be called during an exception handler 
or a signal handler. For example, the MPS may protect the memory, in which 
case the client program can't see it. This causes an exception; the MPS handles 
the exception, finishes its work, removes the protection. Therefore, _the for-
mat code should be able to be run at any time, including in parallel with the 
main program_. It has to work properly even if the main code is changing the 
object when the format code is reading it.

[above is strictly true, but misleading.  last sentence in particular.  It is 
guaranteed that the format methods have exclusive access to the object for the 
duration of the call.  This guarantee may entail suspending arbitrary threads.  
This means that the methods that manipulate the object must not perform any 
sort of inter-thread locking or communication (since the other thread may be 
suspended and so may never release a lock or respond to communication for the 
duration of the call).  -- drj 1997-07-04]

.restr.visible: If a reference is hidden from the MPS, that reference becomes 
invalid. The program will probably continue to work for a while, but at some 
point, it will probably crash. "Hidden" means that the scanner isn't able to 
"fix" 
the reference. An example of how to avoid a hidden pointer in the Lisp object 
mentioned earlier (with the single difference that the bit is clear if the car 
is a 
reference, and set if both car and cdr are references) is to first set the cdr 
to 
zero, then set the bit, then make the cdr into a reference. Otherwise, the 
client 
program will end up with either a hidden pointer, or junk in the cdr that will 
cause the MPS to crash.

.restr.decoding: Therefore, the programmer needs to follow some simple 
rules. _The client program can keep any sort of reference in an object, but 
when you call FIX, it must have decoded it and changed it into a pointer_ 
("find pointer" = decode references). An example of decoding a reference 
might be when the scanner strips off a tag by copying the non-tag portion of 
the object to another location, making the tag section of the new location to 
zero, fixing the object, and copying it back.

.ex.doc: The documentation will need worked examples (bits of example code 
and a full example on the disk). It will also need a section containing tips 
for 
designing good formats, with a pointer to ???'s paper. 

