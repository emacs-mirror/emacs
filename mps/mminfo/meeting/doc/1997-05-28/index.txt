          NOTES FROM THE MM/DOCUMENTATION MEETING, 1997-05-28
                         meeting.doc.1997-05-28
                               draft doc
                           richard 1997-05-28

INTRODUCTION

.intro: Richard Brooksby <richard> met Leah Bateman <lmb> to cover general 
points needed to complete the reference documentation.


TIMESCALES

.time: At the request of the MM Quartet and EP, we are aiming to produce a 
first draft of reference documentation by the end of June 
(meeting.quartet.1997-05-13.doc.thumbnail).

.time.short: Because Leah has been pulled off the MM project, this 
documentation is likely to be of poor quality.


NOTES

.insert: Unless otherwise noted, all of this is suitable for editing and 
inserting into documentation.

.recommend: A list of recommendations might be a good thing to have.  Leah even 
suggests a chapter on good usage style.

.support: Customers can do what they like with the interface, but should be 
aware that they should do as we suggest if they want good support.

.space: At some point it's likely that "space" -> "arena".  .space.rule: As a 
general rule its probably a bad idea to use abstract(?) nouns ("space", "air", 
"water", etc.) as object type names.


INTERFACE CONVENTIONS


Naming

.naming: Covered by design.mps.interface.c.naming.  Add that we reserve the 
right to use "mps_" or "MPS_" for undocumented internal names, and the future 
versions might use symbols defined in current versions, but they will also 
begin "mps_" or "MPS_".


Opaque and Transparent

.opaque: Covered by mail discussion [insert tags here].


Result Code Return

.res: Operations which might fail return an result code, rather than a "special 
value" of the return type.  In other C interfaces it's common to do something 
like this:

  p = malloc(s);
  if(p == NULL) there was an error;
  otherwise p is meaningful

.res.special: Here, NULL is a special value.  We shun special values.  It's too 
easy to ignore them, then they trip you over later.  Also, there's not always 
one available.  There's only one special value in many cases, so you can't 
distinguish between different errors.  Other justification is given in 
book.maguire93 chapter 5.  (I think it's worth putting a reference in the doc.)

.res.code: There's a single fixed set of result codes defined in mps.h, all 
beginning "MPS_RES_".  .res.code.ok: MPS_RES_OK means "operation succeeded", 
and we guarantee it's zero, so we support this:

  res = mps_alloc(...);
  if(res) handle error;

as shorthand for:

  res = mps_alloc(...);
  if(res != MPS_RES_OK) handle error;

.res.code.meaning: The other codes have rough global meanings, but what they 
mean specifically depends on the method that they come from.  So, for example, 
MPS_RES_MEMORY indicates failure due to lack of memory, but might mean 
something in particular for some methods.  Each method should document the 
codes it could return and say what they mean.  A bit like Unix man pages for 
system calls (see mmap for an example).

.res.error-path: We recommend handling errors as explained in 
mail.richard.1996-11-06.09-05 (using error unwind paths).

.res.params: If the result code is non-zero (i.e. not MPS_RES_OK) then none of 
the input/output or output parameters will have been modified (see below).


Input/Output and Output Parameters

.io: We use I/O and O parameters where:
  - we need to return a value _and_ there may be an error case,
  - we need to return more than one value.

.io.out: An output parameter is really just a pointer to somewhere where the 
result can be stored.  You tell the function where to put the result.  For 
example:

  mps_addr_t p;

  res = mps_alloc(&p, pool, size);
  if(res) {
    /* p hasn't been touched in this case. */
    handle error;
  }

  /* p now contains the result, which is the address of the new block */
  /* in this case. */

Here, the first parameter of mps_alloc is an "output" parameter.  The value of 
p when mps_alloc is called isn't used by mps_alloc.  P is only modified if 
mps_alloc succeeds.

.io.io: An input/output parameter is very similar, except that the value _is_ 
used when the function is called.

  res = mps_fix(ss, &ref);

In this case the value of ref when mps_fix is called is significant.  mps_fix 
_may_ update ref, but only if res is MPS_RES_OK.  (Again, only if successful.)

.io.pun: It's tempting to use cast to change the type of a I/O or O parameter, 
like this:

  struct foo *fp;

  res = mps_alloc((mps_addr_t *)&fp, pool, sizeof(struct foo));
  if(res) ...

This is illegal in standard C (perhaps we should provide a reference to the 
standard).  This is a pun.  In fact, it will work on almost all architectures, 
but it relies on the fact that fp has the same underlying representation as an 
mps_addr_t.  It's not portable.  We don't support this usage.  You can do it, 
but be aware that you're taking a risk.  Instead, we recommend this:

  mps_addr_t p;
  struct foo *fp;

  res = mps_alloc(&p, pool, sizeof(struct foo));
  if(res) ...
  fp = (struct foo *)p;


Optional Argument Passing

.optarg: This hasn't been completely finalized, but this is what is likely to 
happen.  Something's going to happen.  .optarg.vararg: We'll probably eliminate 
all the "..." (varargs) from the interface (currently in mps_pool_create, 
mps_alloc, and mps_ap_create).  mps_space_create will probably gain optional 
arguments.

.optarg.struct: A set of optional arguments is passed to a function as a 
structure.  The idea being that the structure can contain default values which 
the client can override if they want.

.optarg.eg: When you create a pool, you might want a special alignment.  In the 
current interface there's no way of specifying one.  You don't always want it, 
so you don't want to have it always as an argument.

  mps_pool_create_opt_s opt_s;       /* the "option structure" */

  mps_pool_create_opt_init(&opt_s);  /* set it to default values */
  opt_s.alignment = 16;          /* override some particular argument */
  res = mps_pool_create(&pool, space, mps_class_mv(), &opt_s);

What this means is that the client cares about the alignment, and wants it to 
be 16, but doesn't care about any other options.  They will get the default 
values, whatever they are.  The specific options available, and what the 
restrictions on them are, will be be convered in the reference for that 
function.  So, the reference entry for mps_pool_create should describe 
mps_pool_create_opt_s, etc.

.optarg.naming: In general, the client must initialize an option structure 
using the right "init" method which will generally be called 
"<function>_opt_init".  .optarg.re-use: The option structure can be used many 
times if you want the same options over and over.  .optarg.mod: It won't be 
modified by calling the function.  .optarg.re-init: It can be re-initialized 
and used again.

.optarg.source: There might be some more info the mail proposal 
(mail.richard.1997-04-25.17-08) but it's a bit terse.


General Operations on Abstract Data Types (ADTs)

.adt.naming: Usually, where we've got some ADT it has a name like "pool".  
Objects of the type are of type "mps_pool_t" which is actually a pointer to a 
structure of type "mps_pool_s".  All the operations on that type begin 
"mps_pool".

.adt.create: To get an object you use the "mps_pool_create" method.  In 
general, this has a return parameter into which the new object is placed, and 
the other parameters supply say what it's made inside (e.g. the space) and 
other options or attributes it has.  For example, a pool is made in the space, 
and has a class as an attribute, an maybe some optional arguments (see above).

.adt.destroy: When you've finished with the object, it's destroyed using 
"mps_pool_destroy" which just takes the object as a parameter and doesn't fail.

.adt.finish: As a general rule, you must "finish off" the object before it is 
destroyed.  For example, you must destroy all the pools before you destroy the 
space (thus "finishing off" the space).  This has a kind of symmetry which 
helps you to get things correct and therefore improves reliability.  Maybe we 
should say what has to be done before a destroy in the reference manual entry.  
For example, all aps belonging to a pool must be destroyed before that pool is 
destroyed.


Macro Naming

.macro.std: We follow a convention that's almost exactly the same as the 
standard C library.  To quote 7.1.7:

  Any function declared in a header may additionally be implemented as a
  macro defined in the header, so a library function should not be declared
  explicitly if its header is included.  Any macro definition of a function
  can be supressed locally be enclosing the name of the function in
  parentheses, because the name is then not followed by the left parenthesis
  that indicates expansion of a macro function name.  [Continue quote.]
  ... Any invocation of a library function that is implemented as a macro
  shall expand to code that evaluates each of its arguments exactly once,
  fully protected by parentheses where necessary, so it is generally safe
  to use arbitrary expressions as arguments. ...

.macro.multi: In some cases an argument may be evaluated more than once, so 
it's not safe to have a side effect in an argument of such a method.  These 
special cases are documented in the reference entry (c.f. putc [standard.ansic 
7.9.7.8] or getc [7.9.7.5]).

.macro.call: If you definitely want to call the function, there are two ways:

  - you can undefine the macro, thus:

    #undef mps_reserve

    res = mps_reserve(...);  /* definitely calls the function */

  - you can put the name in parentheses, thus:

    res = (mps_reserve)(...);  /* definitely calls the function */

We recommend the latter.  [Maybe just quote more of the standard above, section 
7.1.7.]

.macro.check: We need to go back and make sure that's we've made it clear which 
functions might evaluate arguments more than once.

.macro.void: Technical detail for people writing macros mainly: Where there's a 
function that returns void, we may implement it as a macro which expands to a 
_statement_ (when terminated by a semicolon).  Therefore, it's not supported to 
use such functions where only an expression is valid, e.g. on the left-hand 
side of a comma.  Not this:

  (mps_tramp(...), ...)

but this is supported:

  mps_tramp(...);

.macro.special: The other macro kind is something which isn't a version of a 
function.  These are always written in all caps.  The exact details depend on 
the macro -- see the reference documentation.  For example, there's a macro 
which reserves (like mps_reserve) but isn't like a function syntactically, 
called MPS_RESERVE_BLOCK.  (Should be renamed to MPS_RESERVE imo.)


HEADER FILES

.h.main: The main interface is called "mps.h".  This is the only header that 
needs to be included to use the core MPS.

.h.prefix: We will always prefix headers with "mps" to avoid clashes.  We 
reserve the right to create new headers beginning "mps" in future versions.

.h.class: Pool class headers begin "mpsc".  So the header for Pool Class X is 
"mpscx.h".  That header contains the declaration of the pool class itself (i.e. 
mps_class_x()) and any class-specific stuff.

.h.target: We haven't resolved what we're going to do about "mpstd.h" and 
target detection.


PROTOCOLS

.prot: We're going to group symbols together with their protocols and probably 
write them together, which should make thing easier.


Allocation Point

mps_ap_t -- type
mps_ap_s -- transparent structure with fields init, alloc, limit
mps_ap_create -- make an AP
mps_ap_create_v -- probably obsoleted by optional arguments (see above)
mps_ap_destroy -- destroy an AP
mps_reserve -- might evaluate arguments multiply
mps_commit -- ditto
mps_ap_fill -- to be called if writing your own in-line methods
mps_ap_trip -- ditto
MPS_RESERVE_BLOCK -- special version of mps_reserve

Might be more to come here.  Don't know yet.

Should reserve and commit be ap_reserve and ap_commit?  Is that important?


Format

mps_fmt_t -- type for all formats
mps_fmt_s -- opaque structure
mps_fmt_A_t -- parameter for mps_fmt_create_A, type for format "variant" A
mps_fmt_A_s -- transparent structure for variant A, with fields
  align, scan, skip, copy, fwd, isfwd, pad
mps_fmt_scan_t -- type for format scanning functions
mps_fmt_skip_t -- type for format skipping functions
mps_fmt_copy_t -- type for format copying functions
mps_fmt_fwd_t -- type for format forwarding functions
mps_fmt_isfwd_t -- type for format forward test functions
mps_fmt_pad_t -- type for format padding functions
mps_fmt_create_A -- makes a mps_fmt_t out of an mps_fmt_A_t
mps_fmt_destroy -- destroy a format


Root

mps_root_t -- type for roots
mps_root_s -- opaque structure
mps_root_create_* -- functions for creating root variants
mps_root_destroy -- destroy a root
mps_root_scan_t -- type for "fmt" variant root scanning functions
mps_stack_scan_ambig -- only supported parameter for "reg" variant roots


Scan

(mps_fmt_scan_t)
(mps_root_scan_t)
MPS_SCAN_BEGIN, MPS_SCAN_END
MPS_FIX1, MPS_FIX2, MPS_FIX
mps_fix

(Will probably rename "fix" to "scan ref" or similar.)


Space

mps_space_t, mps_space_s, mps_space_create, mps_space_destroy.

(Probably want to add some more stuff to do with global control.  Stop 
collecting, how many collections, utility function, etc.)

mps_collections -- should be renamed


Pool

mps_pool_t -- type for pools
mps_pool_s -- opaque structure
mps_pool_create -- create a pool from a pool class
mps_pool_create_v -- obsoleted by optional arguments
mps_pool_destroy -- destroy a pool

(Probably want to add a bunch of stuff for getting information about pools, 
e.g. alignment, is this address in this pool, etc.)


Pool Alloc

mps_alloc -- general allocation
mps_alloc_v -- obsoleted by optional arguments
mps_free -- general allocation



Location Dependency

mps_ld_t -- type for LDs
mps_ld_s -- transparent structure with opaque fields
no create or destroy -- that's up to the client
mps_ld_reset
mps_ld_add
mps_ld_merge
mps_ld_isstale


Thread Registration

mps_tramp
mps_thread_reg
mps_thread_dereg


Assertion Handler

mps_assert_t
mps_assert_install
mps_assert_default


POOL CLASS DOCUMENTATION

.class.write: Richard will write up one pool class to shake out the details 
then we can use that as a template for future class documentation, rather than 
trying to do them all at once.

.class.points: Leah's list of points to cover, that Richard has previously said 
"would bein the class doc":

  Summary/overview
  Summary of features by level of use/feature chart
  List of compatible classes
  Description of interactions between classes
  Alignment
  Allocation points (and whether "commit" must fail)
  Format requirements
  Location dependencies
  For each level of use, need:
     Pool class description
     Benefits
     Class specific info
     Procedures
     Best uses of
        Circumstances
     Performance info
     Examples

  should look like data sheet


DEBUGGING/TROUBLESHOOTING INFO

.debug.mail: mail.richard.1997-04-25.16-25 describes a scheme that will 
probably be adopted.

.debug.rit: Richard and Leah will talk to Richard Tucker tomorrow morning to 
try to work out the "top N" likely assertions that users are likely to see.  We 
will document these up front, and add more to an on-line database as we 
accumulate experience with actual use.

.debug.format: Main heading would be the Id, then sub-headings by problem, with 
fields like:

  summary: one-line description of problem
  description: detailed description
  diagnosis: how to tell if this really is causing the assertion
  cure: how to fix it

.debug.ui: Message Ids should also appear in the graphical UI, for example, in 
the corner of dialog boxes, like this:



Example.

  1F48-0014-E


  1. The "size" parameter to mps_foo_bar is out of range

  Description

  Wibble wobble 7Mb this that the other too big blah blah.

  Diagnosis

  Put a conditional breakpoint on the call to mps_foo_bar to catch
  the value being passed and verify that it is in range.  In windbg
  you can do this by ...

  Cure

  You need to consider why you are passing this out-of-range value
  in your code.  If you are trying to get a very large foo you
  should be using mps_large_foo.


  2. The "size" parameter is of the wrong type

  etc.


CONCEPTS

.conc: Deferred work on Leah's concept draft in doc.mps.concepts.


SYMBOLS

.sym.progress: Leah reports that we have 20 symbols done and about 130 
remaining.

.sym.prod: Richard asked Leah to remind everyone about writing symbols by 
writing about the projected completion time, etc.

.sym.missing: Leah needs to look at the "plinth" interface (mpslib.h and 
mpsio.h) which we will probably merge.


ACTIONS

.act.outline: Leah will create outlines in design.product.doc.* for the various 
manuals.  [We've already created design.product.doc.ref-man.]

.act.intro: Leah will take the results of this meeting and edit into 
doc.mps.ref-man.* as part of filling in the reference manual outline 
(design.product.doc.ref-man).

.act.class: Richard will write up a pool class using Leah's check-list 
(.class.write).

.act.td: Richard will resolve the target detection issues and write up the 
design.

.act.optargs: Richard will resolve the optional argument passing conventions, 
cause the interface to be changed, and write up the design.

.act.prot: Leah will assign protocols as well as symbols, and keep them together.

.act.rit: Leah and Richard will meet Richard Tucker to discuss likely messages 
from the MPS.

.act.plinth: Richard will resolve the plinth issues and write up the design.

