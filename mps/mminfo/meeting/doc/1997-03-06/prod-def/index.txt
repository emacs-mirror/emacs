                         MM PRODUCT DEFINITION
                    meeting.doc.1997-03-06.prod-def
                             incomplete doc
                             lmb 1997-04-11

INTRODUCTION

.intro: Richard Brooksby and Leah Bateman met at Longstanton House on 
1997-03-06 to discuss the MM product.

At the moment, we have no documentation defining the product itself,
or even the requirements of the product.


.comp: COMPONENTS OF THE PRODUCT

.comp.sw: Software
.comp.doc: Documentation -- fairly well defined now [but needs
   refinement and justification --Leah]
.comp.support: Support (and training?  L5 usage)
.comp.manu: Manufacturing
.comp.mark: Marketing
.comp.sales: Sales

.comp.qa: The QA component spans all the above components.


SOFTWARE COMPONENTS

.sw.comp: The software will consist of:  [Need diagram.]

.lib: 1. Libraries containing the MM

.lib.MPM: a. MPM -- a library (linkable) and interface(s) 
.lib.pc: b. Pool classes
.lib.var: c. Varieties (debugging and release, both at various levels;
   these provide a tradeoff between checking and overhead; they're not
   the same as the Transducer's levels)
.lib.plat: d. Platforms -- W95, Intel + Win NT; Sun, SGI, Alpha, HP?

.lib.orth: Varieties and platforms are orthogonal to the MPM and pool
classes.

.MPM: a. MPM

   .MPM.if: The MPM could have a number of interfaces:
      .if.MPS: MPS interface -- flexible and complex (L2b)
      .if.malloc: malloc replacement interface for C and C++; replaces
         MM part of C standard (L1)
      .if.new-del: new and delete replacements for C++ (will release
         source for this and malloc; L1)
      .if.conv: convenience interface (aka EZ, for now; L2)
      .if.frustum: frustum interface -- for use in free-standing
         environments (L?)

   .if.frustum.def: Ideally, the frustum interface would operate
   without support from other libraries; in actuality, the
   dependencies to the outside world are known.  This allows the
   frustum interface to simulate being in a free-standing environment
   (as opposed to a hosted environment).

   .if.frustum.ex: Richard likes to use the example of a washing
   machine interface to illustrate the concept of the frustum
   interface.  The MPM could be put into a washing machine OS, but the
   engineer would have to write his own code to make an error light
   come on.

   .if.frustum.doc: The documentation for the frustum interface should
   be in an appendix.

   .if.doc.details: There are a number of interface details that need
   to be discussed, including:
      reserved symbols
      binary compatibility
      source compatibility
      version compatibility

.pc: b. Pool classes

   .if.interaction: In general, the user talks only to the MPM; he
   only interacts with the pool classes to determine their names.

   [architecture diagram for user]

   [table of pool class features]

   .pc.N: We might want to ship the N pool class with the product.
   When using N, all allocations fail.  Assertion [?].  The N class is
   useful for switching off bits of the program during development [to
   change the pool, just change the "create" statement].

   .pc.A: The A pool class doesn't have free.  This class is useful
   for fast allocation of objects that will all be deleted at once.

   .pc.AMC: The AMC pool class can't tolerate an unitialized object
   [i.e., it's formatted?].  Therefore, you have to use an allocation
   point with it, rather than alloc.

.tool: 2. The tool(s)

.tool.main: a. The main tool is likely to be the measurement tool
   that Tucker has prototyped.  .tool.main.purpose: Its purpose is
   statistical measurement and analysis.

   [measurement tool interface diagram]

   .tool.main.task: The measurement tool will allow you to:
      .data: look at the history of the MM
      .analysis: figure out why it behaves as it does
      .solution: provide suggestions as to how to fix the problem??

   You can then fix the problems.  The tool will provide quantitative
   results in the form of analysis plots.

   [some example plots; not a definitive list]

   .tool.main.app: The tool will be an application and will work
   similarly to a spreadsheet, in that it will allow you to load
   datasets and will then provide an analysis of them.

   .tool.main.live: Analysis of live data will probably not be a
   feature in the initial product, although it is a future req.

.tool.CM: b. There may also be a CustoMalloc tool that writes a
   pool interface for you to use to make your code go faster.
   .tool.CM.analysis: This tool will analyze the logs and try to find
   classes that can be allocated by different pools.  This works
   because there tends to be a dominant size of object; if so, it's
   best to use a fixed-size pool.

   .tool.CM.solution: The tool will then emit source code in the form
   of a header file to link to the program to make the program faster.
   .tool.CM.source.example: Basically, the tool changes malloc to a
   macro that is specialized for size; the source code might look
   something like:

      #define malloc(size)
         if (size=x)
            do s.t.
         else if (size=y)
            do s.t.
         etc.

   You would then recompile your source code with the new header.
   .tool.CM.doc-point: This tool is the same as the analysis tool, but
   with a built-in "good" analysis -- the documentation should make a
   point of this.

   .tool.other: There might be more tools, but probably not initially.
   All tools may fit into the same model of feedback.  The tools will
   probably be developed on Dylan and DUIM.

.demo: 3. Demos of the software

.demo.product: a. Product demo
   This demo will provide an overview of how to use the product.  It
   will probably be multimedia (e.g., slides or shows) and will not be
   very interactive.

.demo.utility: b. Side-by-side utility demos

   .adv: These demos will show the advantages of the HQN MM in the
   following ways:

      .adv.perf: performance -- show programs that were helped by
         using the MM
      .adv.stat: statistics for marketing [?]
      .adv.dev-cost: development cost -- complexity; makes solving a
         problem easier

   .demo.utility.list: The demos may include a GC demo, a memory pool
   demo, and a debugging demo (show a program that's hard to debug;
   plug in the MM and an assertion appears).

.demo.example: c. Demos/examples

   These will include both short and detailed demos (perhaps a Scheme
   interpreter?).


OTHER COMPONENTS

.comp.other: Other components of the product include:

.comp.other.support: Support -- We will provide support via telephones
and electronic mail.  The support personnel will take calls, enter
requests, and offer assistance to the users.

.comp.other.doc.db: Documentation -- We will have a message
(assertion) database.  .issue.db-mgr: We need to sort out a database
manager (central storage and organization).  .issue.db.update: The
database should be available [updatable?] via calls, email, the Web,
doc addenda, and an appendix.  .issue.db.serial-num: We may also have
serial numbers on dialogs to help with support.

.comp.other.manu: Packaging/Manufacturing -- The product name isn't
yet known, but the software will always be called the MPS.
.issue.binding: The types of binding for the documentation will affect
scheduling and packaging production.  .issue.scheduling: I need to
talk to the Product Manager about my scheduling concerns and other
issues.

