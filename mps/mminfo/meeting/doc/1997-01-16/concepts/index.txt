                          MPS CONCEPTS MEETING
                    meeting.doc.1997-01-16.concepts
                             incomplete doc
                             lmb 1997-05-14

INTRODUCTION

.intro: Richard Brooksby and Leah Bateman met on 1997-01-16 to discuss con-
cepts related to the Memory Management product.

.scope: This document covers Richard's explanations of the MPS and object-
oriented technology concepts. 

.readership: It is suitable as background reading for new staff members and 
as a basis for user documentation.

.issues.other-doc: When used as an intro to the MM product, this document 
should be read in conjunction with design.mps.interface and various of the 
meeting.qa entries. 

.issues.errors: If you notice any errors, please point them out to Leah. 


CONCEPTS

.mm: The Memory Manager

A piece of code (library) that you use to manage memory. The term is 
mostly interchangeable with MPS.

.space: Spaces

Objects that represent the state of the MPS. 

The MPS has a multiple spaces policy. It can be useful to have two active 
spaces, and to try different things out in them. The maximum number of 
spaces that the system can support is around 10.

You start a session by making a space and end the session by destroying 
the space. Even if you do not destroy it, it is guaranteed not to hang on to 
resources; but it is better to destroy it, to finish off properly. Before 
destroying
the space, you must first destroy all objects and data in it.

Spaces may not interact. However, they may conflict with each other in 
terms of resources.

Other types of objects are created "in the space". They are part of that 
world, and may interact and affect each other.

Using multiple spaces is an advanced technique.

.object: Object

[Different from a program's object. Program objects are referred to as 
"client objects" throughout this document; "MPS object" refers to an 
object in the sense of object-oriented programming. We need better ter-
minology for these concepts.]

.pool-class: Pool class

Code that dictates an MPS policy. Different pool classes are suitable for 
different purposes.

[Pool classes are sort of like the doc group's templates; you plug in some 
text (parameters) and create an instantiation of, say, release notes. The 
class dictates behavior; the object evidences behavior. 

At the moment, there are 5 pool classes, of which 3 are in common use. 
We would like to ship 6-10 or more.

Care must be taken to use the terms "pool" and "pool class" properly. 
Sometimes the MM developers refer to pool classes as just "pools".]

.policy: Policy

A way of handling program objects and memory blocks. Some examples 
of policies are whether the pool class garbage collects or not; whether the 
formats of the objects need to be known in advance; etc.

.pool: Pool

A pool class object plus parameters; a set of allocated memory blocks 
that behave according to class. The blocks may contain program objects; 
they are allocated and formatted by ?. A pool is managed using a partic-
ular policy and lives in a space. Multiple pools can coexist in one space.

.format: Format

An object that allows the MPS to understand how program objects are 
laid out. Some pool classes, called "formatted pool classes", require for-
mats; these are generally the pool classes that include garbage collection. 
The developer must tell the MPS the format. 

There is currently one format, but we may implement others in future. 
The current format tells where the pointers in the object are.

.alloc: Allocation

The act of finding a block of memory of a certain size on request.

.free: Freeing

The act of recycling a block of memory for later reuse.

.alloc-point: Allocation point

An object that allows the client program to do fast in-line groups of allo-
cations. The hands over a block of memory to the client application for 
allocation, with the requirement that the client application obey a certain 
protocol. Get an AP from a pool [? -- I think this means that the pool 
class defines the allocation point]. This is sort of a delegation token, or a 
channel that the client and pool can use to communicate without func-
tion calls.

[.message-passing: Aside: Message passing

The allocation point is a channel for messages passed between the client 
application and the MPS without calling functions.]

.root: Root [have to explain after user is familiar with GC]

An object that the client application creates in order to tell the MPS what 
objects are assumed to be alive. At the moment, the programmer has to 
explicitly declare the roots.

You can assume that some things are alive, such as registers; you never 
want to overwrite what is in a register. The programmer declares that other 
objects are alive. 

The Boehm collector assumes a lot of roots.

[.thread: Thread

Just like a process, except that it shares memory with other threads. It's a 
sort of multi-tasking inside a running program (process). It's useful for 
graphical user interfaces and sometimes for GCs.

When doing incremental GC, the MPS has to know all existing threads 
that might use memory. The client application can tell the MPS about the 
threads through an object called thread registration.]

.thread-reg: Thread registration

An object that the client programmer creates to tell the MPS what 
threads are around.

.loc-dep: Location dependency

Some pool classes move objects around and change the objects' 
addresses. If the client program uses the bit pattern of the address, this 
movement can be a problem. A location dependency lets the MPS 
inform the client program when program objects have been moved. It's 
an optimized way of moving things around (? -- in what way is it opti-
mized?).

.reg-file: Register File

Not yet implemented.

.fix: Fix

Not yet.

[.method: Method (aka message)

An operation you can perform on a program object. It's usually a func-
tion, but doesn't have to be; a function is just one implementation of a 
method.

.class: Classes

.instance: Instances 

.inher: Inheritance

.subclass: Subclasses

Behave like their parent classes, but with additional behavior (e.g., win-
dow vs. dialog).

.late-binding: Late-binding

.adt: ADT

Like an object; a data type is like a class. An ADT defines methods on 
that class; it doesn't know details (? -- of what?), just methods. It's not a 
class because it may not have all the properties of a class, such as inherit-
ance.]

.opaque-adt: Opaque ADT

[There's no way of hiding the implementation details of an ADT in C, so 
the MM Group hacked their objects to be opaque. We don't want users 
to poke around in ADTs because we don't support that behavior.

We've used ADTs to implement objects; a format is an ADT.]

.gen-method: Generic method

.protocol: Protocol


