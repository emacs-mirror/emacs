                               GC SAFETY
                     meeting.doc.1997-03-07.safety
                             incomplete doc
                             lmb 1997-04-11

INTRODUCTION

.intro: The MM Group and Leah Bateman met at Longstanton House on 1997-03-07 to 
discuss safe practice when using GC.


ROOTS

[three diagrams showing objects linked in various ways, but I don't remember 
what their point was]

.turing: (Turing completeness?) Undecidable problem:
     if (rest of program)
        obj A
     else obj B
[Don't remember what the point of this was, either]

.analysis.root: In general, you cannot analyze which objects are live and which 
are dead (find paper).  You have to tell the program which objects are roots; 
this is very complicated.

.death.object: Objects can die in the following ways:
   .overwrite: A reference to the object is overwritten (usually by another 
reference)
   .removal: A root is removed
   .parent: The object's only parent (often a register) dies

.root.reg: In one sense, the only roots are registers; that is, a program can 
only use values that can be referenced from the registers.

[diagram of how all values can be referenced from registers]

.root.reg.prob: This is the logical way of thinking about the problem; however, 
the practice is much more tricky.  One example of a difficulty is that a 
multi-threaded program has multiple sets of registers that the kernel keeps 
track of.  Multi-processing OSs also sometimes do (but often they don't because 
they are acting as Virtual Machines).

.root.specify: It isn't possible to do this in practice; we have to tell the 
program to tell us what the roots are, and to be conservative in determining 
them.

[diagram of practical example]

.root.stack: The MPS assumes nothing about stacks.  The client has to create a 
root from the stack, if necessary.  .root.Boehm: We might provide a Boehm 
layer, which assumes that everything is a root.  .root.var: Global variables 
are not on the stack, they're in memory.  You must declare them to the MPS.  
.root.other: There might be other roots, as well.

.root.create: To create a root, use the function mps_create_root.  There are 
many different types of symbol, depending on the type of root you want to 
create.


SAFETY

.safety.prob: Unsafe practice occurs when the GC throws away a live object.

.cause.main: The main cause of this is that you have not set up the roots 
correctly.  .cause.sec: A secondary cause is that you have not used formats 
correctly, and as a result, have lost a reference.  .cause.underlying: In both 
cases, the underlying truth is that if the GC cannot see references, it will 
kill objects.  .safety.no-hide: Therefore, you must never hide an object from 
the GC.  (See ? for more details.)


HOW TO AVOID HIDING REFERENCES FROM THE GC

.hide.incr-gc: In incremental GC, you must never hide references (except when 
you call a halt (critical period), and you must unhide the references before 
ceasing the halt).  However, the MM only acts during a load/store or a call to 
the MM.

.hide.non-incr-gc: In non-incremental GC, the GC only looks at references 
during calls to the MM.

.hide.thread: The use of threads makes things much more difficult.

.hide.truth: Truth condition: When the MM is running, everything you want to 
keep must be reachable.

[example diagram]

The object 573 must appear somewhere that is reachable from a root.

.hide.ex: If a root dies or a reference is erased, there is no pointer to the 
file (or to an object somewhere on the network, or to a pipe, or another 
process, or something printed on the screen or paper).  The GC will not look at 
the file automatically, but you can tell it to do so (this would be a good 
example).

.ref.ambig: An ambiguous reference is something that might not be a reference 
-- for example, a register.  .ref.exact: An exact reference is something that 
is definitely a reference; the GC will keep it alive, but may move the object 
and change the reference transparently.

.hide.rule.general: The general rule is that you can hide a reference if you 
have another, ambiguous reference to the same object that is visible to the GC.

[example diagram]

.hide.rule.ex: If object 647 moves, then the non-root reference will not be 
changed.  This is similar to realloc in C.

.hide.encode: You can also hide a reference by reformatting or encoding it.

[example diagram: lists that are doubly linked using XOR]

.hide.encode.ex.1: The GC cannot read the pointers because they are encoded.

[example diagram: ??]

.hide.encode.ex.2: Instead of keeping an explicit pointer to the start of array 
B, keep it through math (should reference paper).

.hide.encode.scan: The point is that, for each object, we will pick pointers 
(done by scanning) to keep alive; every type of object has its own scan method 
that decodes pointers and tells the GC about them.  .hide.encode.scan.simple: 
If you use a simple scan, the GC will look at the references and treat them as 
pointers if they point to the bottom of an object.  .hide.encode.scan.decode: 
If you encode a reference, you must have a scanner to decode it.  
.hide.encode.scan.stack: The most common source of problems is the stack 
scanner; if a reference is encoded and stored in a local variable, things get 
screwed up.

[example diagram]

.hide.encode.scan.ex: Add 7 to each object; the scanner has to subtract 7 in 
order to work properly.

.ref.encode: Basically, an encoded reference is one that is not represented as 
the address of the object.


LOCATION DEPENDENCIES

.ld.exact.right: The MM reserves the right to change the location of exact 
pointers; if you just treat them as pointers, you'll be all right.

[diagram]

.ld.exact.prob: SUM = A + B (checksum)
If A or B moves, the checksum is screwed up; it remains the same, but it 
doesn't reflect reality.  This is likely to happen when you are using hash 
tables, for example.

.ld.exact.reliance: You must not rely on the literal value of an exact 
reference.  .ld.ambig.reliance: The MPS will not move ambiguous references, so 
if you make ambiguous references to A and B in the example above, they won't 
move.  .ld.ambig.reliance.max: It is best to avoid making too many ambiguous 
references; 10 or 20 will be all right.

.ld.pc-dep: Location dependencies are pool-class-dependent.  The pool class 
catalog should discuss them.

.ld.notif: You can also use location dependencies to let you know when an 
object moves, as follows:
   Make an LD.
   Put references in it to objects you want to keep.
   Ask the LD later if those objects have moved.
   The LD answers "maybe" or "no".
.ld.notif.design: LDs are designed to answer "no" as often as possible.


ASIDE ON POOL CLASSES

.pc.dep: Almost everything is pool class-dependent; the class entries should 
contain examples.  .pc.attr.doc: We should document the attributes of pools in 
separate sections (scannable/unscannable, managed/unmanaged, 
protected/unprotected).  .live.quiz: Aside: RIT created a cute quiz asking 
which objects are dead, and why.


BACK TO SAFETY

.boehm.dis: Many people may just want to use the Boehm collector, but we should 
discourage this.

.safety.example: A specific real-life example of safety:

.ex.Dylan.stack: In Dylan, the stack is not made scannable (that is, it's not 
an ambiguous root).  .ex.Dylan.root: Instead, special areas are roots.  
.ex.Dylan.root.adv: This helps make the GC's job easier and more efficient; 
there are additional advantages if the roots are exact.

[example diagram]

.ex.Dylan.accntng: You have to be sure to keep track of things in the root 
area.  If you put new things into the root area or into a location that the 
root can access, you have to use this code:

   res = mps_alloc(&r[3], pool, size)

When alloc returns, the result is in r[3].

.ex.Dylan.accntng.prob: You cannot use:

   mps_alloc(&x, etc.)
   ...
   r[3] = x ;

If you are using incremental GC, it doesn't work because of the gap between 
allocation and assignment to the root area.  Using reserve/commit is similar.

y = f(x)
load reg from x
push reg onto stack
call f
store reg in y

.ex.asynch.prob: What if the GC happens between the second and last commands?  
There will be a hidden reference in the register; you can't write with an 
asynchronous GC and only have exact roots.  (.gc.asynch:
Asynchronous GC is incremental GC or GC with multiple threads.)  
.ex.high-level-lang: The point is that, when you're working with high level 
languages, you have to use synchronous GC or declare registers as ambiguous 
roots.


SUMMARY

.root.declare: You must declare roots.  Use a version of mps_create_root.

.ref.hide: You must never hide a reference from the GC.  .ref.hide.def:
Hiding references includes:
   ? [point of first 9 paragraphs in last section, above]
   Reformatting or encoding the reference -- you must have a scanner that 
decodes the reference.

.ref.reliance: You must not rely on the literal value of an exact reference, 
because the MPS might move it.

.high-level-lang: When working with high level languages, you have to use 
synchronous GC or declare registers as ambiguous roots.

