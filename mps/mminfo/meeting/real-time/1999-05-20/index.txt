                    SUMMARY OF REAL-TIME GC MEETING
                      meeting.real-time.1999-05-20
                             incomplete doc
                            tony 1999-05-21

INTRODUCTION

.intro: David Jones <drj>, Pekka Pirinen <pekka>, Tony Mann <tony>, Richard 
Tucker <rit>, met with Andys Sizer <andys> and Martin Simmons <martin> to 
discuss possibilities for providing real-time GC solutions with MPS in the Java 
marketplace. 

Start time: 1999-05-20 at 14:00
Duration: Just over 2 hours

PURPOSE

.purpose: Preparatory discussion about real-time GC issues, to help us to 
ultimately present one or more practical options to the quartet for providing 
real-time GC solutions with MPS in the Java marketplace.

AGENDA

.agenda: The meeting covered the following areas:

  What do we guess are the Java market's requirements for real-time

  What could we achieve with MPS
    How do we do it
    How much effort

  Particular strengths of MPS 


SUMMARY

.requirements: We discussed the following requirements that are plausible, but 
we might or might not want to support:
Mixed language 
Ambiguous references 
JVM (only)
Multi-threads (either with or without some control or introspection of the 
scheduler)
Mixed real-time / efficient GC support for separate subsystems in a system
Multiprocessor hardware
Special hardware support (e.g. a GC coprocessor)
Smoothness
Throughput
Latency (either via interruptability or via bounded pauses)

.soft: We discussed the ways in which a soft RT requirement might be supported:
Might fail to meet RT target some percentage of the time by taking too long.
Might fail to meet RT target some percentage of the time by giving up.

.specify: We discussed the ways in which a client might specify a real-time 
requirement:
Advanced specification (configuration time)
Initialization-time specification (at arena creation time)
Dynamic re-specification (runtime API)

.feedback: We didcussed mechanisms for the GC to feedback information about 
problems with RT targets:-
Fail an alloc
Post onto message queue
Asynchronous callback (useful where problems are not related to an allocation 
request)

.framework: We discussed the possible strength of the MPS framework for 
providing flexibility. An observation is that many systems have subsystems with 
important real-time requirements, but most of the system has no special 
requirements and would prefer not to pay a cost for supporting them. The idea 
behind the J-consortium's RT-Java core is to exploit this. MPS's flexibility 
could potentially offer a 3-tier approach with a manually managed core, a 
real-time GC profile, and some efficient "vanilla" pools which support non-RT 
GC. This could even generalize to n-tier with multiple GC profiles. This fits 
in well with the J-consortium ideas.

.devel.must: We discussed the following general areas where we expect to be 
doing design work:
Counters and metering
Software barriers
Write-barrier only collection
Analysis of bounds for control paths
Finer grain refsets (may not be able to use VM address space)
Locus manager (simple, bounded. again might not be able to use VM address space)
Strategy manager
Support for exact collection
New GC algorithm

.devel.possible: We discussed the following general areas where there's a 
possibility we should do design work:
Interruptible stack scan
Special support for large objects
Finer grain locks
Non-blocking allocator for RT-Java core

.approach.core: An obvious initial approach is to provide MM support for a RT 
core for Java. This doesn't require real-time GC, but does associate MPS with 
real-time solutions. This is low development effort, so looks attractive.

.approach.rt-gc: We should look at an approach involving real-time GC. There 
are lots of options - but an evolutionary first step might look something like 
this:
Fixed latency guarantee (some no of ms for an allocation and for a read / write 
barrier)
Standard computing platform (no special hardware)
Smoothness?
Throughput: Some guarantee of % time in GC, given a steady state alloc pattern.



ACTIONS

.actions:
Look at real-time GC algorithms, pick one, and designe MPS support for it
cost the design work for the areas in .devel.must (and any from .devel.possible 
that we need)



