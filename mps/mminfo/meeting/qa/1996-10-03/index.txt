                TRANSCRIPT OF MM/QA MEETING, 1996-10-03
                         meeting.qa.1996-10-03
                               draft doc
                           richard 1996-10-03

INTRODUCTION

.intro: This is an approximate transcript of a meeting between Richard Brooksby 
<richard> and Richard Tucker <rit> in order to explain an overview of the 
interface to the MPS.

.form: It takes the form of a question-and-answer session.  Rit's questions are 
in square brackets.  Richard's answers are in plain text.


SUMMARY

.summary: The meeting covered concepts and justification of design, but not the 
specific details of the interface.  .useful: This text might be useful as an 
introduction for a documentor, or source material for user documentation.


TRANSCRIPT

I assume some knowledge about what memory management _is_.

The design is based on the idea that no one memory manager fits all 
circumstances.  (No one policy can meet all requirements.)  The MM provides 
selectable, interchangeable memory management policies.

The policies "manage" areas of memory in different ways.  More specifically, 
each policy is represented by a "Memory Pool Class" which manages a "Memory 
Pool".  In OO terminology, a pool is an instance of a pool class.

The idea is that you select one or more pool classes which are appropriate for 
your program's behaviour and requirements.  For example, if you need automatic 
MM (GC) you'll need to choose a pool class which implements that.  Typical 
programs have dominant numbers of objects that are the same size.  These can be 
managed by a fixed-size policy efficiently, which will improve the performance 
of a program.

[Do I need to make a design decision where I say "there are these kinds of 
objects: I'm going to have to allocate them to different pools of memory, and 
for each pool of memory I'm going to have to choose a pool class to manage 
it."?  I might have two pools with different parameters. Is that true?]

Each pool (instance of pool class) can be parametrised differently.  For 
example, if you have two different dominant fixed sizes of objects, you can 
make two pools which are instances of the fixed-size pool class, but with 
different parameters.

[The choice is to do that or use a different class and put them all together.  
Sometimes that's a good idea.]

You don't have to specify total amounts of memory to pools.  Each pool 
dynamically adapts to the situation, and will obtain extra memory resources 
from the OS as necessary, and return them when appropriate (see below).

[If I've got a number of types of objects which require GC and are of fixed 
size, when should I split them up?]

Because the pools are more-or-less interchangeable, you can make a decision 
about how to split them later in development.  You choose a generic policy 
initially, then specialise when you requirements become clearer.

You talk to the pools through a "generic function" interface which doesn't have 
to know which specific policy you're talking to.  So you can change the policy 
you've chosen without changing most of the code which uses the pool.  This is 
to allow experimentation and "late-binding" design.

Memory management decisions are hard.  This mechanism prevents mistakes from 
making decisions too early.

[I'd like not to have to worry.]

You don't have to worry unless you find that you're not meeting your 
requirements with a generic policy.  Sometimes the system can't adapt and meet 
your requirements.  You'll need to specialise in order to tighten things up.  
Essentially, by doing that, you're providing extra information that the system 
can't deduce itself.

[Both for each individual object I could provide information, but also when I 
specify a pool I'm providing information about the objects?]

Most of the time, you only specify information about a pool as a whole, which 
is "typical" information about the object you're going to put in it.  If you've 
got two sorts of objects which are different you just make two pools.  Pools 
are reasonably lightweight, so making many shouldn't matter much.

[Might I have a pool for each kind of tag?  (Type?)]

It depends.  If your "strings", say, have properties which can give you a bonus 
in some way, e.g. they aren't updated, and don't point to other objects, then 
you may be able to get an efficiency gain be separating them out.  The problem 
is knowing when that's appropriate.  We need to document a lot of advice about 
strategies for improving a system based on knowledge about the objects the 
program allocates.

[In theory it should also help with debugging because it might be able to find 
memory leaks, because feedback can talk about pools and stuff.]

Sort of.

[What kinds of properties of objects does the MM deal with?]

Size is critical, or rather, distribution of sizes, because of the fact the 
size of the resource is important, and for fragmentation reasons.  You can 
easily run into problem with using much more memory than you expected because 
of fragmentation.

For GC, the "graph" of objects is critical.  That means you should think about 
the pointers in the object.  Whether it has any.  How easy and fast can you 
locate them.  Are they formatted simple or do they need decoding, etc.  You can 
win by separating strings, for example, because they are "leaf" objects and 
don't contain pointers.

[Are there some ways in which I can't encode pointer info?]

No.  For "formatted" pool classes you supply a method table (called the 
"format") which tells the pool how to manipulate the objects.  This table 
includes methods for scanning (for pointers), copying, moving, sizing, etc.

[And updating?]

We only "fix" pointer in objects in order to GC.  We don't change the object or 
the graph as far as the program is concerned.  (Except weak and final.)  The 
scanning method includes updating the pointers.

So, pointers are important for GC, but it's mainly object "type" (as far the 
program is concerned) that determines object format, so it may be advantageous 
to separate objects of different types into different pools and parametrise 
them by special optimised formats by type.

[Is there a restriction about the graph and pool boundaries?]

No.  This is a major breakthrough of our software.  Different GC and non-GC 
policies can co-operate transparently and efficiently.

[Time is an important property, surely?]

Yes!  That's very important.  When an object is allocated, and how long it will 
be around, is very important.  You can create temporary pools and discard their 
entire contents at once, for example.  Or you can allocate and free in a 
stack-based or otherwise restricted manner.  Or you can not free at all and 
allow the GC to work it out.  Obviously these concerns are central to the 
choice of policy.  The MM is in the job of managing memory to meet requirements 
in the face of a changing situation.  That's the whole essence.  So the 
dynamic, time-based properties of object are very important indeed.

The more that the programmer can express about time and object the more we can 
do.  With complete information about the future we could optimise everything in 
advance(!)  In practice, the MM has to make predictions based on the 
information it's got and do the best it can.

If there's a mapping from, say, type to longevity, then a GC can benefit a lot 
from knowing about it.  There's also a possibility of relating objects 
themselves.  e.g. these objects will all die at once (or are just likely to).

So, essentially the memory manager uses information about objects in order to 
make decisions based on predictions in order to optimise resource usage.

[Can objects change in size?]

Not really.  You can make a new copy?

[Can I demand things like: "here's an object and I always want to be able to 
access it straight away?".  Or even in GC, might I want to know that there 
won't be CPU interruptions during certain periods?]

There's sort of interface for this because you can say that certain roots 
mustn't be protected, so you can always access them.  But yes, there could be a 
more sophisticated interface for this kind of thing.  People might well want it.

[That's all I can think about in terms of properties of objects.  Do I have to 
declare all these pools at the beginning?]

No, you can dynamically create and destroy pools, and in fact, anything else.  
The MM is designed to be "stateless" internally, so you can use multiple 
instances of it, or start it again, or whatever.  This is achieved by having an 
explicit object which represents the global state of the MM.  It's called the 
"space" object.

So generally, when you start using the MM, you create a single space, and then 
create pools in the space, etc.  Some specialised applications might want to 
destroy the space and recreate it, or create several spaces, but the MM is 
basically designed to operate with a single space.

If you have several software components in the same process, and they're all 
using the same MM, each one might well have its own space of pools.  The spaces 
won't interfere with each other, so this achieves modularity of MM between 
software components.

In general, the MM is designed to be "friendly", so it doesn't hog global 
resources such as address space, or signal handlers, etc.  It will co-exist 
happily with most software which is also friendly.  Some memory managers assume 
that they are in control of everything.

[It relies on being able to generate some kind of call when memory is accessed?]

It uses whatever mechanism is provided by the OS to do memory protection and 
handle memory access.  Naturally, it does this efficiently, because often 
memory access faults are expensive to process.  So yes, it does make use of 
signal handlers.

[Signal handlers weren't designed for that purpose?]

Signal and fault handling mechanisms were kind of designed to handle fatal 
errors, rather than being part of the running of a program.  So they're often 
implemented inefficiently, in spite of the fact that VM in the OS has to handle 
them.

[So there's a lot of freedom about what kind of objects, and by giving it 
tables of methods I can teach it whatever my representation is...]

You don't to tell it about representation.  If you have a conservative GC you 
can ask it to make assumptions.  e.g. anything that looks like a pointer to an 
object should be treated as one (and not altered).

[In a sense that's a format.]

Yes.

[Do I have to use the MM exclusively for everything?]

No.

[What constraints are there on the other stuff?]

If you're using a GC, then you've got to declare "roots", which are all the 
references to objects managed by a GC pool class which you want to remain 
correct.  In other words, you don't want objects referenced by those to go 
away.  Those kinds of things are:

  1. some pointers somewhere in memory (e.g. a little vector of pointers),
  2. a bunch of formatted objects,
  3. the state of a thread, including the stack and registers,
  4. anything else, by writing your own root-scanning function.

[Do you always have to use 3, because your compiler might optimise stores away?]

No, this isn't true.  For example, in C, if you take the address of a variable 
then the compiler is constrained to keep the variable up to date under certain 
circumstances.  However, you have to be _very_ careful.  If you're using using 
incremental GC then the MM might look at things when the compiler didn't 
expect, and things will go wrong.  When using incremental GC you almost 
certainly must declare thread state as a root.

Non-incremental GC will occur during a function call to the MM (e.g. on 
request, or during allocation, etc.).  So C knows to store things in addressed 
variables during those calls, so you can deal with it.

For example, a common C virtual machine declares a stack-within-stack of 
roots.  e.g.

  struct stack_frame {val *next, locals[N];};
  struct stack_frame *sp;

  main()
  {
    ...
    mps_root_create_table(..., &sp);
    ...
  }

  foo(...)
  {
    struct stack_frame frame;
    frame.next = sp;
    sp = &frame;
    /* Do stuff using locals.  A GC can safely happen because sp points
       at frame, so the compiler must write local values back to the frame
       before any side-effect can happen. */
    sp = frame.next;
  }

This sort of things is safe, so you can do without scanning the real processor 
state.  You only need the VM state.  This isn't terribly good for ordinary 
programming, but is fine for a virtual machine which is the output of a 
compiler, for example.

In normal programming you'll want to include the processor state for 
convenience.  It's helps the compiler optimise, and it's necessary for 
asynchronous MM operation, such as incremental GC.

[Can you do other asynchronous stuff?]

You might incrementally compact without GCing.

[If I have manual management and free something that's pointed to then that's 
my own fault?]

Yes.  That's the "dangling pointer" bug.  There's nothing we can do except 
perhaps detect you and warn you in a debugging capacity.  This is the sort of 
thing that memory debuggers, such as "Purify", do all the time.  It's kind of 
their main function.  We're aiming at a different market: GC, and performance 
optimisation.  No one else has really done that yet.

[Are you thinking of people writing things from scratch?]

Yes and no.  In order to use our MM to the full, they'll need to convert over 
to our interface.  However, we hope to provide some easier interfaces, e.g. 
"malloc" and "free" so that they can just drop-in replace something.  We could 
also provide an interface which is compatible with Great Circle, or a 
Boehm-like interface (just "malloc", no "free").  Boehm makes very few 
assumptions, so it has little information to go on.  We hope to gain more info 
and therefore do a better job.

