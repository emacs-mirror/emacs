                 NOTES FROM A MM/QA MEETING, 1996-10-16
                         meeting.qa.1996-10-16
                               draft doc
                             rit 1996-10-21

INTRODUCTION

.intro: These notes are from a meeting between richard and rit, to explain how 
to use the interface to the MPS.

.form: Question and answer to begin with, then rough notes.

SUMMARY

.summary: We began by talking about testing strategies, and then moved on to 
consider specific details of the MPS interface (C header files) and the correct 
way to use it.

.referenced: During the meeting we looked at design.mps.interface and 
impl.h.mps.

NOTES

Questions about MM interface and module structure:

Q: Can you tell me about the different components that fit together to make the 
MM products, and how they connect?

A: Fit together in what way? The architecture or which bits come on a 
distribution?

Q: I mean the architecture. Or rather, can you give me components separately 
for me to test?

A: Er, yes, but you need to test the delivered product. That means you should 
take a distribution and test it. And the other thing is, you might build it 
specially, just for testing it. That way you could test bits of it, compiling 
for example just one module. You can have any breakdown you want. We haven't 
decided exactly what the distributions are like. For Dylan we have, and also 
for EP, so you can take those bits. Dylan & EP: a single linkable library, 
_but_ we decide the configuration, not them. A customer would want to 
reconfigure things.

Q: What I really meant to ask was: I want to test certain features of the MM, 
for example core features which should be in all the different versions. So I 
could just run the same tests on all the different distributions, if the 
interfaces are similar enough. Or is there a way I could just test core 
functionality, and then add the, as it were, front-ends for the different 
products on? Assuming that is, that they are just front-ends.

A: That's a process quesiton. Can you assume any commonality between products? 
I think the answer is, it's dangerous to do so, because defects might manifest 
themselves in different areas. They're not necessarily confined. You should 
really run all the tests on everything we release. The thing which the customer 
gets should itself have been tested. So yes, you can test the trunk, but that's 
not sufficient for proper releases.

Q: Ok, but are the different products' interfaces similar enough that running 
the same test on all of them is feasible.

A: Yes. Near enough. The interface has settled down enough now to make this 
possible.

Q: So I could write tests of core functionality, but run them on all the 
distributions?

A: Yeah, more than that you could write tests of generic MM functionality that 
you expect from any MM, and run them on our products and rival products also. 
You might want to benchmark malloc & free tests, and similarly for GC. GC has 
common problems (cf Java email) and so you can compare product with rivals. Of 
course you're really testing whether release meets requirements; you have to 
judge how much you can bring in from your common test suite, and how much you 
have to write specifically.

Q: Do you have that requirements that say: must compare well with other MM 
products?

A: No, but we will. Things like: must be as fast as _X_ in all respects.

Q: Do we have the relevant rival products?

A: Clive is getting some. You should stratify your tests: this is a common MM 
test, this is a test for all Harlequin MM version, this is a test for Dylan 
only &c. If you categorize them you'll know what to do.

Q: My plan was to begin with common MM tests like: is the graph preserved, can 
it cope with big/small objects, etc. Because
 a) they're functional, hence easier to test
 b) they're all critical requirements
 c) they don't require me to learn all about Dylan, PS, &c.

A: And d) the requirements change, but some things won't. Those basic 
requirements are almost certainly not going to change, so it's best to get them 
done first.

Q: So let's talk about the interface. What functions are there, when do I need 
to call them &c?

A: The only interface we have at the moment is the C interface -- like most C 
interfaces it's a (group of) header files. The important one is mps.h, which 
has all the core stuff in.

Q: Is that the same in each product?

A: ... probably. Depends on the exact requirements. We'd like it to be the 
same, yes.

Q: Does it tell me all about trampolines, and so on.

A: it has the protocol defined, but it's not going to explain it to you.

Q: I would have thought that the fact that you have to call the trampoline, 
then x, then y is part of the interface description.

A: Ok, terminology:

Interface -> protocol
             binary interface
             source interface

+ protocol: the order in which you must do things. You must x, then y, &c.
+ binary interface: layout of objects, linkable symbols, calling conventions
+ source interface: header file, allow compilation.

binary interface is a function of header file + compiler that you're using -- 
they determine the interface, otherwise you would't be able to compile.

The protocol is a function of the documentation. It's the semantics. A common 
mistake is to document the binary interface and not the protocal.

Q: And you've made this mistake?

A: No.

Q: So you have protocol documentaion?

A: A bit. Some of it's out of date.

<< rit now reads design.mps.interface, which contains some explanations
   of protocol. The basics of spaces, pools and buffers are explained
   (with examples); missing are formats, scanning functions, location
   dependency and thread registration (an area which rit feels shaky in).
nb: mps = memory pool system >>

Q: how do formats work?

A: A format is a structure which defines the format of the user's objects. 
Normally, you'd specify a format as a parameter to a pool, as a way of telling 
the pool that all the objects you're going to put it in have that format. Most 
of the format is in fact pointers to functions, a bit like a method table for 
the object. This means that you can pretty much do what you want -- encode it 
how you like.
Example: the Dylan object format [design.dylan.format]. For Dylan, there's a 
bunch of code in impl.c.fmtdy which declares that format.

Q: do you always the same elements in a format?

A: No. But yes for the time being. The interface is designed to be extensible.

----------------------------------------------------------

[The q&a format didn't seem appropriate beyond this point,
 except occasionally. What follows is my notes from reading
 through impl.h.mps with richard.]

INTERFACE SPECIFICS

[All symbols begin mps_, so I'll miss that bit out sometimes.]

Examples of things I might put in a format:

scan, skip, copy -- these are functions. Also alignment.

actually, roots and registers also have scanning functions.

n.b. size of objects isn't strictly in 'format' but is a pool parameter.

 - skip gives pointer one off end of object
 - scan applies fix to all references in the object
 - copy copies object to a new location (is this necessary?)
 - pad creates a dummy object (that skip will pass and scan will skip)
 - fwd replaces object with a broken heart containing a reference to somewhere
 - isfwd looks up forwarding addres (0 if none)

broken heart: an object which skip and scan will skip, but isfwd will retrieve 
a forwarding value from. Forwarding pointers, once written, never change. [This 
is not true, if there are multiple traces in progress!  Pekka 1998-01-19]

Broken hearts and forwarding pointers are part of the GC's state, not the 
object graph.

n.b. fix doesn't necessarily 'move', just 'make it live'. The client doesn't 
need to know what it does.

Q: what restrictions are there about how I can store pointers?
A: none, provided you can find them with scan.
    [n.b. there _are_ restrictions about the _act_ of
     storing (and reading) references, if not about the
     form those references take. I must talk to richard
     about this.]

Q: If I choose to store pointers as relative values, then I'll need copy. 
Someone might want to do that.
A: Yes. I think Henry Baker proposed some technique involving relative pointers.

Q: What do they [references] have to point to?
A: other objects, but not necessarily base addresses -- it depends on the pool 
the other objects are stored in. Another pool could be storing objects in a 
completely different way -- that's not your business.

[rit to read overview.ideas]

Q: Ok, so with the pools you currently have, what can I point to?
A: The base address. The main GCing pool we have is the Dylan one. That only 
allows base-address pointers.

Q: Hang on, how come you only have GC for a specifically Dylan pool?
A: Actually, it's called the AMC (automatic mostly copying) pool. It's more 
general than Dylan but is designed for them.

Q: This question of where pointers point is a question about pools, not formats.
A: Right. Imagine an abstract type called reference. The MM as a whole 
restricts what a reference can be -- it has to be an address. The choice is 
made for efficiency. The interpretation by the pool of the type reference is up 
to the pool, or rather it's between the pool and the client.

Q: But the address is also used to determine which pool it belongs to.
A: Yes. That's why it's defined as an address.

Q: Do you expect to implement any other kinds of pools?
A: Yes. But no clear plans right now.

Scan state is the closure of the fix function. You're given it as a parameter 
to scan, and you pass it on to the fix macro. [Technical
note: it actually contains the fix function itself.] [Theoretical note: since 
it's a closure, it really _is_ a function.]

Scan is meant to scan lots of objects at once: it takes a base address and a 
limit (one off the last object it should scan).

At present, there's one kind of format called A, and it goes with all the 
current pools. But in future there could me more, and for each pool you'd need 
a format of the appropriate type.

Alignment is a power of 2 (bytes).

ignore mps_space_create_wmem -- it's for ep and means use this particular bit 
of real memory (base to base+size)

Make a pool with mps_pool_create. Takes a class_t (a pool class) and other 
parameters, e.g. format.

alloc(&p, pool, size, ...)   ... is pool_specific: allocate for any pool that 
supports it. For example, the AMC pool doesn't -- you have to use a buffer. You 
could have a conservative pool that supported it.

free may either be ignored or cause an error, or it might work. Depends on the 
pool. Pool argument to free is provided for sanity. Free also takes a size, the 
meaning of which is pool-dependent.

Convention for argument ordering: out then in.
subordering: object you're dealing with, then context.

format_create_X takes a format_X )parameters) and makes a format from it, 
associated with a particular space. The format_X can be destroyed afterwards if 
you like.

You must destroy a format, when you've finished with it. i.e. after you destroy 
any associated pool or other thing using it,
and before you destroy the space which owns it. n.b: check this.

POOL CLASSES -- including restrictions on object format

APs (Allocation Points) specify pool and rank (and more, possibly). You must 
destroy before the pools, but you can destroy when objects from it are still 
alive. "A communication channel, not a container."

---- a _rank_ is a property of a reference. All references have a rank.
There are four defined: ambiguous, exact, weak and final.

References don't change their rank.

ambiguous: words which might be refs, but the manager can't prove
 that they are. [Sensible not to update them]
exact: it's a reference to an object
final: it's a reference to an object
weak: it's a reference to an object (or null) but won't keep the
      object alive.

Q: It's the different between exact and final:
A: you get told when only final (and possibly weak) references to
 an object are left. The purpose is to detect when objects are
 nearly dead. (Though of course you can treat it how you like.)
 How you are told and how often &c isn't defined yet.
 There will be more restriction on final references that haven't
 been sorted out yet.

Q: why don't malloc (and free) know anything about ranks?
A: good question

Restriction ('not entirely necessary'): you can't mix ranks within an object, 
or use different rank in references in objects that came from the same AP.

In practice, it's rare to allocate anything except exact. [Ambiguous if you're 
being conservative.]

ROOTS

you can create a root at any time. n.b. possibly not yet! you shouldn't declare 
an object that could get GCed to be a root. A root is really a function that 
finds references.

everything in a root (like an object) is the same rank

most general: root_create(&root, space, rank, rm, root_scan, p, size)
 - you provide a scanning function root_scan
 + & specify a root mode rm
 p and s get passed to root_scan.

result (in root) is a root_t (pointer).

Q: why two things, p and s, not 1 or 5?
A: richard's opinion: useful to pass a pointer to something (your
   object with stuff in you need) and an index into an array (e.g.
   if you have several things with some shared data p and some individual
   settings specified by s).

more specific cases (you could do them with root_create):  from a table from 
registers

you must destroy all roots before destroying the space

root mode: a set of flag (bitmapped) like: don't protect this, &c. (probably an 
enum in the file)

Scanning functions:

Register scanning: stack_scan_ambig is the only supported register
 function. It's OS and architecture dependent (and possibly compiler
 dependent). MM provide it, 'cos it's hard to write and hard to
 specify an interface for it. e.g to declare registers as roots:

 mps_root_create_reg(&root, space, AMBIG, 0, thread, mps_stack_scan_ambig, p)

 what is p?

Root scanning and Object scanning are the same. Also see Pool Classes for 
specifics.

------

Trampoline: mps_tramp(&p, function, p, s)
 void *p is the result (of function), which is called as
  function(p, s)
 p,s are what you like
 It's called inside the trampoline, where all MM takes place.

 Typically, your whole program would be in 'function'.
 Each thread must be in its own trampoline.

Q: What can you do outside the trampoline?
A: Haven't documented it yet, and it might be platform dependent,
   but the safest answer is: nothing to do with MM.

n.b. can't always detect whether we're in the trampoline, so no assertion 
checks for it.

on windows only, the trampoline is also provided with a macro.

Dylan care about trampoline call overheads, 'cos they want to put it across 
foreign function calls. Therefore they want it inlined. This requirement 
extends to anything callable from outside.

It's ok to be inside >1 trampoline.

In fact, trampoline may not be necessary if you're not using windows.

On unix, there's an interaction between the trampoline and signal handlers 
which might affect your program if you're unlucky.

THREADS

threads which might access MMed memory must be registered. (We might relax this 
a bit -- only when doing incremental GC is it necessary.) You register it by 
calling, from the new thread,
 thread_reg(&p, space) result is a handle on the thread (used only for 
deregistration and stack scanning). you must deregister threads with 
thread_dereg(p), before they die. All threads must be deregistered before you 
destroy the space. (in particular, callable libraries will have to register 
their threads).

Location dependency

see document from drj -- guide.mps.ld
 ld_reset, ld_add, ld_isstale are the functions used. The client
 has to provide space for the ld, and a backup lookup method
 (and the ability to reconstruct the hash table -- potentially
 expensive) if things are stale.
 n.b.: A simple but crap implementation would satisfy the
 description: ld_isstale always returning non-zero unless no adds
 have been done since the last reset.

No restrictions about lds crossing pool boundaries. Presumably, addresses added 
to a ld should be addresses of objects in the space -- is this a requirement?

No support for relative dependencies, except by adding both object addresses to 
the ld.

Not clear whether the ld alters the collection strategy or it just used to 
inform the client when things have moved. Experiment on this.

Writing scanning functions: writing a fast scanner is very important -- you're 
going to scan everything in the heap sooner or later. The interface we've 
defined is designed to be fast. In your scanner you go
 MPS_SCAN_BEGIN(mps_ss)     [that's the scanning state in there] then in your 
scanning code you can call the functions
 MPS_FIX1(mps_ss, ref) and MPS_FIX2(mps_ss, &ref) At the end you go
 MPS_SCAN_END(mps_ss)

For convenience, MPS_FIX combines FIX1 and FIX2.

FIX1 -- returns non-zero if you need to call FIX2 FIX2 -- does the fixing, 
updating ref. result is error code, which if not RES_OK should be returned from 
SCAN (preferably straight away).

If your format encodes the graph other than as addresses, you need to decode to 
a temporary ref, fix, then encode back again.

Restrictions on what you can do in a scanner:
Your scanner can look at the memory you've been asked to look at (base-limit), 
look at global memory not managed by mps, and possibly look at certain other 
objects (to do with protection). You can call fix. That's about it. It must be 
reentrant. You can't call library code, long jump, do any other MM operations 
or start new threads.

------------------------------
Assertion handling:
 can override the handler mps_assert_t is the assertion handler type,

 (*mps_assert_t)(const char *cond, const char *id, const char *file,
                 unsigned int line);

cond = condition which failed id   = reference for where it happened [req/d by 
Harlequin support] file = source file in which it occurred line = line number

Default handler is returned by mps_assert_default(), and it exits with message 
on sterr. mps_assert_install(handler) replaces the handler and returns the old 
one. It's global.

--------------------------------

[Later, we talked about some particular areas: error codes and pool classes:]

ERROR CODES

The following are general meanings; specifics depend on each call

OK -- success. guaranteed to be zero (for 'if' &c)
FAIL -- unknown failure. Should never happen.
RESOURCE -- lack of resources, e.g. lack of address space, lock handles,
            threads &c.
MEMORY -- unable to get more memory from the operating system (usually
          means lack of backing store).
LIMIT -- internal limitation, such as #objects exceeds limit for a particular
         pool.
UNIMPL -- should never see this, unless documented for future expansion
IO -- i/o error from OS. Infrequent because not much i/o is done, but
      will be caused if /etc/passwd doesn't exist.

Q: what happens when you run out of space in a fixed-size arena?

After calling an MPS function,

If you get OK, you can continue.
If you don't: any return parameters will not be changed [are any non-return 
parameters ever changed?], and the operation didn't succeed. As far as 
possible, the system will be back in the state it was just before you called. 
Sometimes this isn't quite possible, but the user shouldn't notice.

RESOURCE, MEMORY and I/O don't indicate that a retry will necessarily fail. The 
others do.

(n.b. out of reserve and commit, it's reserve that can return an error code.)

POOL CLASSES

Pool classes 16/10/96 (from talking with richard)

(i) implemented (p) planned

MFS (i) manual fixed small ~formatted a&f ~ap
MFL (p) manual fixed large ~formatted a&f ~ap
MV  (i) manual variable ~formatted a&f ~ap
N   (i) null (a&f ap ~formatted ~fixed gc [incr?] for pedants)
LO  (i) automatic leaf-only formatted inc ~a&f ap
AMC (i) automatic mostly copying formatted incr ~a&f ap
A   (p) allocate only a(&~f) ap

scannable pools: AMC (would Lisp people want a fixed pool here?)
pools with (incr) gc: AMC, LO
pools with copying: AMC
pools with ap: AMC, LO (N)
pools with a(&f): MFS, MFL, MV, N 

MFS manual malloc and free. fixed size, fairly small objects. small means quite 
a few will fit on a page. 1K is not small. 32 bytes is small. 256 bytes is 
about the biggest you could sensibly use. (this is advice, not a restriction) 
It stores control information with the objects (same page) and therefore for VM 
purposes the locality is good. For large objects you'd be swapping in a page 
per object just looking at the control information.

MFL would be size independent & store control information not with the objects. 
Isn't necessarily bad for small objects.

MV variable size objects -- basic replacement for malloc & free. possible 
variants later. It stores control information away from the objects, so it's 
good when traversing freelists, and good for allocating when you're using VM 
heavily. You _can_ free parts of objects that aren't the whole object (any 
parts you like, as long as they have aligned boundaries).

N can't hold anything -- internal limit to zero content "this pool holds no 
objects of any size you like"

AMC designed for Dylan, but with more general application all objects in the 
pool are formatted with format A, and are either exact or weak. They may be 
relocated. Allows ambiguous references (i.e. references into pool that are 
ambiguous), but they have a cost (hence "mostly copying"). It's incrementally 
gced. References into an AMC pool must be to the base address of an object.

LO is a formatted pool of objects without references. They can be skipped but 
not scanned, (i.e. LO never calls scan) (nevertheless it currently takes format 
A formats). Allows ambiguous references. It's incrementally gced. At the moment 
it doesn't move objects around, and it doesn't read-protect (or write-protect) 
its objects, and commit always succeeds. [These properties are for Dylan (& 
others) to be able to pass objects to foreign functions which may access them 
from outside the trampoline.] References into a LO pool must be to the base 
address of an object.

A allocate only. Not gced. Useful because you can allocate a bunch of objects 
and then throw them away all at once, by destroying the pool (more efficient 
than using other pools).

---
Alignment "an important concept for all pools"

A pool's alignment dictates the form of the addresses that it will give out. 
The pool-allocated blocks' base addresses' n bottom bits will be zero. Some 
pools (which?) may also restrict sizes to be aligned. Reserve must use aligned 
sizes (this is the client's responsibility).

There is a maximum alignment (ought to be exported to the user -- it's actually 
the system page alignment). The minimum alignment is 1 (byte). The default 
alignment is whatever the largest alignment required by an ordinary processor 
instruction (such as a compiler might generate) is. It's the same as whatever 
malloc (the system one) does.

At the moment, you cannot specify alignment in general. There should be one 
with create-pool.

Q: what sizes does a fixed-size pool allow (especially w.r.t. alignment)?

---
each pool has an interface in, eg, mpscamc.h, which will define a function 
returning the pool class object (passed to pool_create), e.g. mps_class_amc(), 
and may include special methods for this class. ---

"There ought to be general methods for pools to do things
 like ask about size, VM, &c." -- richard
Presumably this has to go with tools development.

