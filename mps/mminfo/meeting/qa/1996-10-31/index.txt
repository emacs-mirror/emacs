    MM/QA: NOTES ON LOAD AND STORE RESTRICTIONS IN MPS-MANAGED POOLS
                         meeting.qa.1996-10-31
                               draft doc
                             rit 1996-10-31

INTRODUCTION

.intro: These are notes made during a meeting between Richards Brooksby 
<richard> and Tucker <rit> to talk about the consequences of memory protected 
pools on what load and store operations can be done.

LOAD AND STORE

Load and store to a pool that's using protection might do arbitrary things 
before the actual load/store happens. THey might move objects around, but 
hopefully in a way that's transparent. For example, any load or store might 
change every exact/final/weak reference in the system. You've got to make sure 
that all your references can be found by the memory manager ("are scannable") 
otherwise some of them might get changed inconsistently with others. 
Essentially that's it, but there's a lot of ramifications.

If you put a pointer somewhere where the MM can't see it, the object can vanish 
at almost any time (alternatively, the pointer becomes invalid). Therefore you 
must keep all your pointers visible at all times, and not hide or encode them 
in some non-scannable way. The exception to this is: if you have an ambiguous 
reference that's visible, you can hide other references to the same object 
without them becoming invalid. That's essentially it. But what does this mean 
as far as the user's concerned?

Actually, you shouldn't assume that this movement is only going to happen at 
loads and stores -- if you're in a multi-threaded environment, or are running 
spy programs for debugging, &c, it could happen at any time. Another way of 
putting it: the memory manager is continuously asynchronously changing all the 
references, such that equal references remain equal and point to the objects 
they used to.

n.b. in theory your compiler might hide references which you didn't want it to 
(optimization). There's no guarantee that this won't happen, and therefore no 
guarantee that you can get things right. But 99.99% of the time you're ok, 
because almost never does this happen. See paper by Ellis and Detlefs ~called 
"A modest proposal for C and C++ compilers".

Above remarks apply to incremental gc. If you're not using incremental gc, you 
can hide references as long as they're not hidden at the point the gc occurs. 
In MLWorks, for example, we don't scan the C-state (stack) for pointers. We 
make sure that all the pointers that are around are stored in root values 
before any allocation takes place (gc only on allocation). This is quite a 
reasonable technique, but can require effort to apply. See guide.ml.alloc for 
details.

.act.protection: At the moment there's no specification of when the trampoline 
needs to be called, which (and when) threads need to be registered, and when 
protection means you need to be careful in the ways described above. What is 
needed is a specification of which pools use protection. richard to get such a 
specification.



