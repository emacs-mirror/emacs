           MM/QA: NOTES ON USING HOPE TO ARRANGE TEST SUITES
                         meeting.qa.1996-10-30
                               draft doc
                             rit 1996-10-30

INTRODUCTION

.intro: These are notes made (immediately) after a meeting between Richards 
Brooksby <richard> and Tucker <rit> to talk about how revision control, and 
specifically hope, might be used to manage tests.

.motivation: For repeatability of testing, it is important that we keep all 
tests used and keep records of what tests were used when on which releases of 
which products. A revision control system can help to track this information.

REVISION CONTROL SYSTEMS

.rc.concept.compound: A compound is a group of items (files or other compounds) 
which together make up a larger unit. You'd use a compound to represent the 
fact that some programs make up the source for a product, or that some tests 
make a suite that would be used together.

.rc.concept.tree: To each compound there corresponds a tree, showing its 
development over time. Typically we have the root at the bottom and imagine it 
growing upwards. A change to a member of a compound, or directly to the 
compound itself, grows the tree by adding a 'delta' to the end of one of its 
branches. New branches are formed by specifying a point in the tree's history 
and making changes from there. After such a split, separate branches develop 
independently.

.rc.concept.checkpoint: A checkpoint is a named point in history on a 
particular branch. It's used to 'snapshot' the state of a compound, and may be 
created at the time to which it refers or afterwards (though not, presumably, 
before).

RC FOR TESTING

.independence.cons: The test suites must change as the products do, so it might 
be possible to use the same tree to keep track of test as well as product 
branches. It would then be very easy to see which tests applied to a particular 
point on the tree.

.independence.pros: But product development doesn't parallel test development 
that closely, and there may be conceptual classes of tests which don't fit into 
the product development tree. In this case, core MPS tests will apply across 
all MM products, for example, whereas some tests will be specific to a 
particular product.

.test-sets: rit envisages having sets of tests for different products, and sets 
of test which are common across two or more products. Simplest form: MPS tests, 
Dylan tests, ML tests, &c. Each set could be a hope compound. Within the sets, 
there may well be a classification into different kinds of tests (e.g. boundary 
value, protocol, stress) but this need not be reflected in the hope structure. 
Keep it simple.

.test-references: There must be a correspondance between points in the product 
tree and points in the test trees. A good way might be to store in the product 
tree the names and versions of tests used at each point, e.g. {core 4.3, Dylan 
2.1}.

.test-log: There also must be a record of the results of tests. But tests 
results from later versions are not later versions of the earlier test results, 
so hope is probably not the best place for this to go. Rather, a series of 
documents recording: date, product-version, tests carried out (compound and 
version) and summary of results (plus other notes as required) would suffice. 
These documents must also record what system, environment and compilers were 
used for testing, as these may not be deducable from the test tree. If each 
test produces separate output we may want somewhere to archive these as well.

CONCLUSIONS

.independence.conclusion: It's better to keep the development tree and test 
tree separate.

.act.rit: rit will read a bit about hope, and think a bit more about 
requirements, before taking any further action.


