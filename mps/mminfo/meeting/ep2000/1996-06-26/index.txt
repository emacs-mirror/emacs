  NOTES FROM IMPROMPTU EP 2000 OBJECT STORE DESIGN MEETING, 1996-06-26
                       meeting.ep2000.1996-06-26
                               draft doc
                            nickb 1996-06-29

.intro: On Wednesday 26th June 1996, Nick Barnes met Angus Duggan to discuss 
the design of the EP 2000 "object store" infrastructure. The meeting was 
informal and impromptu, requested by Angus to seek advice on memory-management 
related issues arising in the design. These notes are informal minutes of the 
meeting. 

.ep2000: EP 2000 is the name attached to plans for the future of EP products. 
The name, and everything associated with it, is company confidential. The 
bottom line is that the RIP is being redesigned from the ground up, to be 
modular, parallelizable, and other groovy things. It is such a fundamental 
redesign that the implementation language is still to be decided. See messages 
from Angus in harlqn.ep-2000 for more details.

.ostore: The various modules of the RIP running on one (possibly SMP) machine 
will be supported by some common infrastructure ("Module Resource Manager": 
MRM). Included in this infrastructure is an "object store", into which go any 
objects which are of interest to more than one module. This object store will 
be GCed.

.not.mm-epcore: This is not to be confused with the MM/EP-core product, which 
may still be used inside the "interpreter" module. The object store manager 
operates at a higher level, with larger granularity.

.who: The object store manager may be written by the MM group (as a new and 
separate project) or may be home-grown by EP people (possibly with advice and 
guidance from MM).

.handle: Each object in an object store will be accessed by modules using its 
"handle". The structure of handles is yet to be determined. A handle will be 
made by instantiating a 'class' of object (a "method table"). Objects 
themselves may be instantiated lazily or speculatively (with a forcing 
operation applicable to handles).

.object.format: Each object will include its "type" (possibly including a 
pointer to the method table), a "private data table", and an "attributes" 
section (like a LISP property list).  Angus said that, if required by the GC, 
each object could have a separate "reference section" for object handles, with 
indices into that reference section in its private data. It is certainly the 
case that scanning formats would be simple and statically known and ambiguous 
slots rare or nonexistent.

.dylan: Nick outlined the Dylan object format, which is not utterly different 
from this, to explain that using a reference section was not necessary 
(although it would simplify scanning &c). Nick described the way in which we 
implement the Dylan MM, to show that we have a great deal of format 
independence. There's no particular requirement from EP 2000 for a full OO 
system with inheritance &c; the requirements are much simpler.

.roots: There will not be any need to find roots in registers, stack frames, 
&c. New handles which are not yet referred to by other objects will have 
special treatment (we discussed a couple of obvious possibilities).

.lock: Modules will be required to lock objects when writing to them. While an 
object is locked, it should be immobile.

.distrib: The RIP may be distributed. Each machine will have its own MRM and 
object store. The object stores on separate machines will communicate to 
support a distributed RIP. We talked about distributed GC for a while.

.distrib.simple: The RIP could avoid the difficult aspects of DGC (e.g. have a 
"no cycles" rule, or duplicate objects, &c), or use a restricted solution (e.g. 
have some restriction on the presence and GCability of cycles, with forced 
migration), or a full-blown solution.

.distrib.job: In Nick's opinion the job processing nature of RIPs might provide 
natural points at which to do the hard parts of DGC if it were desirable (e.g. 
"this job is over, try doing a DGC on objects from it now").

.disk: Objects may also reside on disk (or, equivalently, objects which refer 
to disk resources may have finalizers to free those resources). The universal 
use of handles helps somewhat with this. We talked a bit about swizzling.

.timescale: EP 2000's timescale, as extrapolated by Angus, goes like this: the 
high-level design will be finished this summer. A first implementation of the 
MRM comes next, followed by some simple modularization. It should be possible 
to build a RIP using the EP 2000 structure in mid-97. By mid-98 there should be 
an EP 2000 RIP which could be distributed. The final product is aimed for sale 
at DRUPA 2000 (mid-2000). Some preliminary products will arrive before then.

