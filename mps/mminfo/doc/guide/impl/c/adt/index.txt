       GUIDELINES FOR IMPLEMENTATION IN C -- ABSTRACT DATA TYPES
                            guide.impl.c.adt
                              draft guide
                           richard 1995-10-16

INTRODUCTION

.scope: Many modules in the Memory Manager implement "Abstract Data Types", 
i.e. objects whose internal structure is hidden from the client, and which may 
only be manipulated using function-like "methods". This document describes the 
type and structure declarations, and their placement.

.readership: This document is intended for anyone working on or with MM Group C 
source.


MODULE

.module: ADTs are usually associated with a module that provides the 
implementation or the methods.  For example, the implementation of Foo may be 
in foo.c.  The interface may be in foo.h or in common headers.

.module.plat: Sometimes an ADT's implememtation must be platform specific.  In 
this case, the implementations would be in foo<platform>.c.  Any generic 
implementation would be in fooan.c.  The interface, being consistent, would 
still be in foo.h (or common headers).


THE TYPE OF AN ADT

.type: Abstract data types are usually implemented as a pointer to a C struct.  
Externally this can be declared as an incomplete type in the interface header, 
in the form:

  typedef FooStruct *Foo;
 
along with the declarations of the methods available on the type Foo. The 
declaration which defines "FooStruct" is placed in the implementation, _not_ in 
a header, unless:
  - The structure definition is required for function-style macro methods; or
  - The module has "friends" who require direct access to the type internals.  

This mechanism works because ANSI C permits "incomplete types" -- pointers to 
structures which have not yet been defined. The intention appears to be to 
allow recursive data structures, but the mechanism can be (ab)used to implement 
abstraction by simply never defining the structure in code which has no right 
to access it.

There are some exceptions, naturally. Some types are actually single in-line 
objects. The obvious example is the "abstract" data type which is actually an 
"int". In this case, we simply declare it like this: 

  typedef int Bar;

and pretend that it's abstract to all intents and purposes. Of course, there 
will be no structure declaration for this anywhere. The naming and structuring 
of methods is the same as for a structured type, so Bar could easily become 
structured if necessary.  [ Not true; it cannot be mutated by value; assignment 
loses identity ]


STRUCTURE

.struct: The structure declaration is of the form: 

  typedef struct FooStruct
  {
  ... /* fields */
  } FooStruct;

.sig: The first field of an abstract data type structures shall be of type Sig 
and will be initialised to a signature constant, unique to the class, which is 
mnemonic when represented in hexedecimal (see guide.hex.trans).


METHODS

.method: There are certain methods typicaly to most ADTs. See 
guide.impl.c.naming.method for naming conventions.

[Create, Init, Finish, Destroy, Check]

.method.check: Every implementation of an abstract data type shall provide a 
method to check instances of that class, called <adt>Check.  It shall received 
an instance of the ADT, and return a Bool indicating validity.  It should check 
every field, using appropriate support macros (see design.mps.check for an 
example).  Its complexity shall be O(1).

.method.init: Every implementation of an abstract data type shall have a 
function to initialise an instance of that class; the function name shall be of 
the form "<type>Init"; the function shall receive an (uninitialised) instance 
of the class as its first input parameter; the function return shall be of type 
Res.

.method.create: The implementation of an abstract data type shall have a method 
to create an instance of that class (constructor); the function name shall be 
of the form "<type>Create"; the function shall return an instance of the class 
as its first output parameter; the function return shall be of type Res. The 
creation function of an abstract data type shall invoke the initialisation and 
checking methods.

.method.finish: The implementation of an abstract data type shall have a 
function to destroy an instance of that class (destructor); the function name 
shall be of the form "<type>Finish"; the function shall receive an instance of 
the class as its first input parameter.  It shall also finish all fields of the 
type, as appropriate.  [What about Destroy?]

.method.general: Any function which operates on, or returns data from an 
abstract data type should be considered to be a method on that class, where 
appropriate; the function name shall commence with the class name; the function 
should received an instance of the class as its first input parameter.

