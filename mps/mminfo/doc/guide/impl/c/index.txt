                   GUIDELINES FOR IMPLEMENTATION IN C
                              guide.impl.c
                              draft guide
                           richard 1995-07-28

INTRODUCTION

.scope: This document describes the C coding conventions used by the Memory 
Management Project.  The style is applied uniformly to all sources which make 
up Memory Management products, except where it is necessary to adopt other 
styles in order to interface with client code.

.readership: This document is intended for anyone who works on or with MM Group 
C source code.


JUSTIFICATION

.just: A consistent C style contributes greatly toward the high quality of 
Memory Management products.  C sources should be clear, while avoiding the many 
many pitfalls built into the language.

A consistent style assists in making the source clear by using layout, naming, 
and interface conventions to assist in communicating the intent of the 
programmer.  The effect is to reduce the number of defects, by preventing their 
introduction when modifying code, and by increasing the effectiveness of code 
review.

It is also sometimes necessary to process the code automatically.  For example, 
we have benefitted from automatic instrumentation of validation checks.  
Sometimes it is necessary to change all the code because it uses some support 
mechanism which has changed.  It is extremely useful to be able to do this, and 
a consistency style is very important.  The only alternative is a complete C 
parser!  (Oh, for LISP!)


CONTENTS

.contents: This guide is divided into sections:
  - guide.impl.c.adt: Abstract Data Type
  - guide.impl.c.format: Format
  - guide.impl.c.naming: Naming
  - guide.impl.c.pp: Preprocessing

[ Need more on details of overall file format.  How about a couple of 
templates?  GavinM 1997-06-16 ]
---
[Most of the list below has been incorporated, but there may be stuff left.  
GavinM 1997-06-14]

[This document isn't finished by a long way.  Here is my brainstorm outline of 
thing which need to be included.  It isn't complete either, but it might help.  
If you thing of things which aren't included here, mail me. -- richard, 
1995-08-07]

  MODULE                Using C to implement modularity
    INTERFACE           The header as a module interface
      FORM              The form of an interface
        LEADER          The leader comment
          TAG  Include document tag at top left
          STATUS  Follow tag by status
          TYPE          Follow status by type
          TITLE         Title of interface
          COPYRIGHT     Copyright message
          HOPEID        The HOPE identifier
          SUMMARY       One-sentence summary
          DESC          Detailed description
            LIMIT       Description of limitations
            IMPORT      Description of dependencies
          NOTES         Future issues and notes
        REPEAT          Prevent repeated inclusion using #ifdef name_h / #endif
        IMPORT          Importing other interfaces
          STD           Include std.h first
          LOCAL         Local imports come next
          SYSTEM        System header imports: limits.h and stddef.h, others 
via lib.h
          RECURSIVE     Don't rely on recursive imports: import everything you 
need
        TEMPLATE        A template for interfaces
      MACROS            Use of macros in interfaces
        INLINE          Controlling inlining of macros DEBUG_NOINLINE
        BACKUP          Methods must have corresponding functions
      ADT               Abstract Data Types
        TYPE            The type declaration
          FORM          Form is  "typedef struct XXXStruct *XXX;"
          NAMING        Type naming
          DOC           Documenting the type declaration
        STRUCT          Exposed structure declarations
          FORM          Form is "typedef struct XXXStruct {<fields>} XXXStruct;"
          NAMING        Structure naming
          UNIONS        Distinguished union naming
          DOC           Documenting the structure declaration
            PROTO       The protocol for accessing structure fields
            HIDDEN      Fields the client really shouldn't touch
        METHOD          Interfaces to methods on types
          FORM          Form of method prototypes is "extern XXXYYYY(<params>);"
            NAME        Naming of methods
            EXTERN      Write extern, don't rely on implicit extern
            ERROR       Returning Run-time error codes
            PARAM       The parameter list
              NAME      Naming parameters
              ORDER     The order of parameters
              INOUT     Semantics of in, out, and in/out parameters
          NORMAL        Conventional boilerplate methods expected on types
            CREATE      Create: allocate and initialize
            DESTROY     Destroy: finish and deallocate
            INIT        Initialize
            FINISH      Finish: de-initialize
            DESCRIBE    Describe: dump a textual description to a stream
            ISVALID     The validation method
          GET           The form of getter methods is "extern yyy XXXYYY(XXX 
xxx);"
            NAME        Naming getter methods
            PARAM       Parameters to getter methods
            RETURN      Return values from getter methods
            EFFECT      Side effects
          SET           Setter methods are "extern void XXXYYY(XXX xxx, YYY 
yyy);"
            NAME        Naming setter methods
            PARAM       Parameters to setter methods
            RETURN      Setter methods return void
            EFFECT      Side effects in setter methods
          GENERAL       General other methods
    IMPLEMENTATION       Multiple implementations of modules
      FORM              The form of implementations
        LEADER          The leader comment
          TITLE         Implementation title
          COPYRIGHT     Copyright message
          HOPEID        The HOPE identifier
          SUMMARY       One-sentence summary
          DESC          Detailed description
            STRUCT      Description and justification of data structures
            ALGS        Description and justification of algorithms used
            LIMIT       Description and justification of limitations
            IMPORT      Description of dependencies
          NOTES         Future issues and notes
        TEMPLATE        A template for implementations
      ADT               Implementing abstract data types
        STRUCT          Hidden structure declarations
        METHOD          Implementation of methods on types

 Debugging
  Assertion
  Signatures
   Object type identification at run-time
   Debugging methods
   Valid for dynamic scope of object
  Flags
 Solid coding
  Return error codes
  Return values by reference
   Don't set until successful
  Validity checks before _anything_
  Validity checks on return
  for loops must be trivial [I suggest "canonical", the intent is to have all 
for loops go from 0 to (n-1) for some obvious n -- drj 1998-08-18]
  Avoid ? : except when very small
  No side effects in expressions [what?  like assignment (which is an 
expression) and function calls?  I think this is referring to ++ -- and the 
assignment ops being used not at top level -- drj 1998-08-18]
  Bools only in conditionals
  Don't side-effect parameters except as the primary operation
  Paste only invalid code

