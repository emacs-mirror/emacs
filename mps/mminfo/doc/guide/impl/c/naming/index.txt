              GUIDELINES FOR IMPLEMENTATION IN C -- NAMING
                          guide.impl.c.naming
                            incomplete guide
                           richard 1995-08-07

INTRODUCTION

.scope: This document describe the MM Group conventions for the naming of C 
source code identifiers and files.

.readership: This document is intended for anyone working on or with MM Group C 
source code.


FILE NAMING

.file: The full name (including hierarchical position) of a source file is 
determined by the particular build system.  This documentation deals with the 
"base name" of the file.  See proc.build.

.file.fat: Source file names must be at most eight characters long, and should 
contain only lower-case letters and digits.  This ensures portability to 
primitive file systems such as MS-DOS FAT and certain CDROM file systems.

.file.base: The name of the source file is derived from the module that it 
implements.  For example, the interface to the "Deque" abstract data type is 
called "deque.h".  If the type name is too long, truncate it.  Don't try to 
compress it by, say, removing the vowels.

.file.env: If the implementation depends on the execution environment, the file 
name must include two-letter "target codes" which indicate the dependency.  The 
target codes are part of the build system.  To form the qualified name, 
truncate the module name and append the target codes.  For example, the SunOS 
implementation of virtual memory mapping is called "vmsu.c".

.file.ansi: ANSI C portable implementations of modules use "an" as the target.  
So the portable implementation of locks is called "lockan.c".


IDENTIFIERS


General Conventions for Identifiers

.ident.caps: Identifiers which are made up of more than one word use 
capitalization to indicate the word boundaries, and not underscores.  For 
example: "DequeNodeElement".  See .macro.special for an exception.

.ident.module: Identifiers which are exported from a module are prefixed with 
the module identifier.  For example, "PoolCreate" is part of the Pool module.  
See guide.impl.c.adt.method.

.ident.extern: Identifiers which have external linkage start with an upper case 
letter.  These are the things which are exported from a module.

.ident.static: Identifiers with file scope but static linkage (i.e. local to a 
module) start with a lower-case letter.  They are not exported from the 
module.  [ Apparently this convention is widely disregarded.  GavinM 1997-06-19 
]

.ident.auto: Automatic (local) variables start with a lower-case letter.  Where 
possible, these should be short single words anyway.

.ident.param: Function formal parameters are named like automatic variables.

.ident.field: Structure or union fields start with a lower case letter.

.ident.struct: Structure tag identifiers and their corresponding structure 
types are suffixed with "Struct" to ensure that broken compilers don't confuse 
them with union or enum tags.  [broken compilers can't be the reason, the 
standard requires only one tag namespace shared by struct union and enum: ISO C 
clause 6.1.2.3 -- drj 1998-09-28]

.ident.union: Union tag identifiers are suffixed with "Union" to ensure that 
broken compilers don't confuse them with struct or enum tags.

.ident.enum: Enumeration tag identifiers are suffixed with "Enum" to ensure 
that broken compilers don't confuse them with struct or union tags.  Note that 
the tagged enumerations are deprecated in general.  Because in general one 
can't tell what the enumerated type is (compatible with).  Use enums to declare 
symbolic names for constant ints, but use the int type (or some typedef) where 
you want to use them.

.ident.const: Constants (including enumeration members) are composed of an 
string (common to any related values), capitalised as for .ident.extern or 
.ident.static, plus a suffix entirely from the upper case (with underscores 
between words).

.ident.length: Identifiers must never exceed 40 characters in length.  [Ideally 
this would be 31, from the minimum number of significant characters in an 
internal identifier specified in ISO C section 5.2.4.1.  gavinm 1998-10-30]


Conventions for Type Identifiers

.type.adt: Abstract data types (usually pointers to aggregates, see 
guide.impl.c.adt) begin with upper case.  Try to use a single word, so that the 
type name is clear when it is used as a prefix for methods.

.type.adt-aggregate.relate: The type name for an adt should be a prefix of the 
underlying type where the underlying type is an aggregate.  Eg, Pool and 
PoolStruct.

.type.struct: Structure types are suffixed with "Struct" so that it is clear 
what they are aggregates when declared.  For example:

  typedef struct DequeNodeStruct {
    Deque deque;                  /* pointer to head, or DequeNone */
    DequeNode next, prev;         /* pointers to adjacent nodes */
  } DequeNodeStruct;

.type.union: Union types are suffixed with "Union" in a manner similar to 
structure types (.ident.type.struct).


Conventions for Macro Identifiers

.macro: Macros are funny things, and it is important that their usage is clear 
and unambiguous.  Naming conventions are used to make sure you know when you're 
doing something with a macro that needs care.

.macro.method: Macros which are in-line versions of methods are named in the 
same way as methods.  They are equivalent to some function identifier with 
external linkage.  This is the same and the ANSI library; see standard.ansic, 
section 7.1.7.

.macro.const: Macros which are constant values are named like constant 
identifiers (see .ident.const).  They are equivalent to an exported constant 
variable (these are rare in C, because macros are cheaper).

.macro.special: Macros which have special "macroid" behaviour, such as 
manipulating syntax or splicing tokens, are all in upper case.  These are the 
macros you need to be very careful about using, since they aren't like ordinary 
functions at all.  Multiple word special macros use underscores to distinguish 
the words.


Method Naming Conventions

.method: Methods are functions or macros which operate on abstract data types 
(see guide.impl.c.adt).

.method.prefix: A method is prefixed by the name of the type on which it 
operates.  For example, "DequeCreate" is the "Create" method for the "Deque" 
type.  The method name will usually be a verb clause (but see .method.get).

.method.pred: Predicates are called "IsXXX" where XXX is an adjective 
describing the property being tested (e.g. "ArenaIsMapped").

.method.get: Getter methods (which retrieve values from objects) are usually 
called "XXX", where XXX is a noun clause describing the value which is 
returned.  For example, "ArenaGrainShift" returns the granularity shift of an 
Arena object.  If this would clash with a verb clause (see .method.prefix), 
e.g. Init, "Get" may be used as for .method.set.

.method.set: Setter methods (which update objects with values) are called 
"SetXXX", where XXX is named like a getter method.


Parameter Naming Conventions

.param.in: Parameters for input only are named like local variables.

.param.out: Parameters for output (pointers to values updated on success) are 
suffixed with "Return".

.param.inout: Parameters for both input and output (pointers to values to be 
read and updated on success) are suffixed "IO".

