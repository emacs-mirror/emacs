            GUIDELINES FOR IMPLEMENTATION IN C -- FORMATTING
                          guide.impl.c.format
                              draft guide
                           richard 1995-08-07

INTRODUCTION

.scope: This document describes the MM Group conventions for the general format 
of C source code.

.readership: This document is intended for anyone working on or with MM Group C 
source code.


History

.hist.4: Increased the line length to 80, changed the case block style, and 
added expression breaking rule.  pekka 2000-03-13


GENERAL FORMATTING CONVENTIONS


Line Width

.width: Lines should be no wider than 80 characters.


White Space

.space.notab: No tab characters should appear in the source files.  Ordinary 
spaces should be used to indent and format the sources.  Tab characters are 
displayed differently on different platforms, and sometimes translated back and 
forth, destroying layout information.

.space.punct: There should always be whitespace after commas and semicolons and 
similar punctuation.

.space.op: Put white space around operators in expressions, except when 
removing it would make the expression clearer by binding certain 
sub-expressions more tightly.  For example:

  foo = x + y*z;


Sections and Paragraphs

.section: Source files can be thought of as breaking down into "sections" and 
"paragraphs".  A section might be the leader comment of a file, the imports, or 
a set of declarations which are related.

.section.space: Precede sections by two blank lines (except the first one in 
the file, which should be the leader comment in any case).

.section.comment: Each section should start with a banner comment (see 
.comment.banner) describing what the section contains.

.para: Within sections, code often breaks down into natural units called 
"paragraphs".  A paragraph might be a set of strongly related declarations 
(Init and Finish, for example), or a few lines of code which it makes sense to 
consider together (the assignment of fields into a structure, for example).

.para.space: Precede paragraphs by a single blank line.


Statements

.statement.one: Generally only have at most one statement per line.  In 
particular the following are deprecated:

  if(thing) return;  

  a=0; b=0;

  case 0: f = inRampMode ? AMCGen0RampmodeFrequency : AMCGen0Frequency;

.statement.one.why: Debuggers can often only place breakpoints on lines, not 
expressions or statements within a line.  The "if(thing) return;" is a 
particularly important case, if thing is a reasonably rare return condition 
then you might want to breakpoint it in a debugger session.  Annoying because
"if(thing) return;" is quite compact and pleasing otherwise.

.statement.one.exception: There's one exception but it's really only for 
pedants.  Other people wouldn't notice anyway.  Multiple case statements 
sharing the same body are allowed on the one line:

  switch(c) {
  case '0': case '1': case '2': case '3':
  case '4': case '5': case '6': case '7':
    is_octal = 1;
  }


Indentation

.indent: Indent code blocks by two spaces.  For example:

  if(res != ResOK) {
    SegFinish(&span->segStruct);
    PoolFreeP(MV->spanPool, span, sizeof(SpanStruct));
    return(res);
  }

Usually, it is possible to determine the correct indentation for a line by 
looking to see if the previous line ends with a semicolon.  If it does, indent 
to the same amount, otherwise indent by two more spaces.  The exceptions are 
open braces, which are at the same level as the previous line but cause the 
next to be indented (unless using .brace.otb), and close brace, which is 
outdented to match the controlling statement.

.indent.elseif: As a special exception to the indentation rule above, an else 
may be immediately followed by an if, in which case the if body is at the same 
level as the previous if body.  For example:

  if(j == block->base) {
    if(j+step == block->limit)
      putc('@', stream);
    else
      putc('[', stream);
  } else if(j+step == block->limit) {
    putc(']', stream);
    pop_bracket();
  } else if(j > block->base && j < block->limit)
    putc('=', stream);
  else
    putc('.', stream);

.indent.label: All label statements are indented (i.e. actually "outdented" 
with respect to nearby code) to the same level as the surrounding block.  This 
includes "goto" labels, case labels, and switch default labels (these are all 
label statements in the terminology of the standard).  For example:

  result foo(void)
  {
    statement();
    if(error) goto foo;
    statement();
    return OK;

  foo:
    unwind();
    return ERROR;
  }

and...

  switch(s) {
  case SPONG:
    ...;
    break;

  default:
    UNREACHED;
  }


.indent.cont: If an expression or statement won't fit on a single line, indent 
the continuation lines by two spaces, unless you're breaking a parameter list 
or other parenthesized expression, in which case indent so that the 
continuation lines up just after the open parenthesis.  For example:

  PoolClassInit(&PoolClassMVStruct,
                "MV", init, finish, allocP, freeP,
                NULL, NULL, describe, isValid);

Note that when breaking an expression it is clearer to place the operator at 
the start of the continuation line:

  CHECKL(AddrAdd((Addr)chunk->pageTableMapped,
                 BTSize(chunk->pageTablePages))
         <= AddrAdd(chunk->base, chunk->ullageSize));


Positioning of Braces

.brace: Two brace placements are allowed.  These have been chosen not to clash 
with one another, and can also help to convey information in the vertical 
spacing of the code.  With switch and case statements it can get confusing.  
See .brace.case below.  
.brace.otb: "One True Brace" (or OTB) places the open brace after the control 
statement, separated by a space, and when there is an else, places that after 
the close brace.  For example:

  if(isBase) {
    new->base = limit;
    new->limit = block->limit;
    block->limit = base;
    new->next = block->next;
    block->next = new;
  } else {
    new->base = block->base;
    new->limit = base;
    block->base = limit;
    new->next = block;
    *prev = new;
  }

The same applies to struct, enum, union, and function definitions.

.brace.otb.split: There is a further division of the OTB style.

.brace.otb.most: The "At Most One True Brace" allows one to have an if 
statement with a block statement in one tail and an unblocked statement in the 
other.  Like this:

  if(isBad) {
    FooBar();
    BarFoo();
  } else
    Zing();

.brace.otb.exactly: The "Exactly One True Brace" does not admit the mixture of 
braces and not-braces in "if"s.  The above example in EOTB would be:

  if(isBad) {
    FooBar();
    BarFoo();
  } else {
    Zing();
  }

.brace.otb.more: There are further refinements according to whether you admit 
any non-braced statements in "if"s, "while"s, and so on.


.brace.block: The "block" style places the brace on a separate line, thusly:

  while(node != DequeSentinel(&pool->segDeque))
  {
    DequeNode next = DequeNodeNext(node);
    Seg seg = DequeNodeElement(Seg, poolDeque, node);

    DequeNodeRemove(node);
    SegFinish(seg);

    node = next;
  }


.brace.case: If you need to put braces around the "contents" of a case 
statement (inside a switch) then do it like this:

  switch(s) {
  case WIBBLE:
  case WOBBLE: {
    int local;
    ...;
  } break;
  default:
    /* ... */
  }

.brace.case.why: If you followed the general brace style rigidly then you'd get:

  switch(s) {
  case WOBBLE: {
      int local;
      ...;
  } break;
  }

(with the two '}' in the same column) or...

  switch(s) {
  case WOBBLE:
    {
      int local;
      ...;
    }
    break;
  }

both of which look ugly.


Formatting Comments

.comment: There are three types of comments: banners, paragraph comments, and 
columnar comments.

.comment.banner: Banner comments come at the start of sections.  A banner 
comment consists of a heading usually composed of a symbol, an em-dash (--) and 
an short explanation, followed by English text which is formatted using 
conventional text documentation guidelines (see guide.text).  The open and 
close comment tokens ("/*" and "*/") are placed at the top and bottom of a 
column of asterisks.  The text is separated from the asterisks by one space.  
Place a blank line between the banner comment and the section it comments.  For 
example:
---
/* BlockStruct --  Block descriptor
 *
 * The pool maintains a descriptor structure for each 
 * contiguous allocated block of memory it manages.  
 * The descriptor is on a simple linked-list of such 
 * descriptors, which is in ascending order of address.
 */

typedef struct BlockStruct
---

.comment.para: Paragraph comments come at the start of paragraphs in the code.  
A paragraph comment consists of formatted English text, with each line wrapped 
by the open and close comment tokens ("/*" and "*/").  (This avoids problems 
when cutting and pasting comments.)  For example:

  /* If the freed area is in the base sentinel then insert */
  /* the new descriptor after it, otherwise insert before. */
  if(isBase) {

.comment.column: Columnar comments appear in a column to the right of the 
code.  They should be used sparingly, since they clutter the code and make it 
hard to edit.  Use them on variable declarations and structure, union, or enum 
declarations.  They should start at least at column 32, and should be terse 
descriptive text.  Abandon English sentence structure if this makes the comment 
clearer.  Don't write more than one line.  Here's an example:

  typedef struct PoolMVStruct
  {
    Pool blockPool;           /* for block descriptors */
    Pool spanPool;            /* for span descriptors */
    size_t extendBy;          /* size to extend pool by */
    size_t avgSize;           /* estimate of allocation size */
    size_t maxSize;           /* estimate of maximum size */
    Addr space;               /* total free space in pool */
    Addr lost;                /* lost when free can't allocate */
    struct SpanStruct *spans; /* span chain */
  } PoolMVStruct;

