          GUIDELINES FOR IMPLEMENTATION IN C -- MISCELLANEOUS
                           guide.impl.c.misc
                            incomplete guide
                           gavinm 1997-07-31

INTRODUCTION

.scope: This document is a bucket for miscellaneous guidelines for C 
implementations, so they are kept pending their organisation into other 
documents.

.readership: This document is intended for any MM developer.


GUIDELINES

.enum.type: Never use enumerated types.  This is because which type the 
enumerated type is compatible with is not portable; it can very from 
implementation to implementation and from enum to enum within a implementation.

.enum.members: Using an enum specifier to declare identifiers as enumerated 
members (effectively integer constants) is fine and good practice.

.enum.example.bad: So this forbids "enum foo {bar, baz};" and "typedef enum 
{bar, baz} foo;" because that declares foo to be an enumerated type.

.enum.example.good: Allowed is "enum {bar, baz};".  bar and baz are declared as 
int constants; no enumerated type is usefully declared (in particular no type 
is named).

.output.update: Avoid updating output or input-output parameters in more than 
one place.

.return.multiple: Avoid multiple returns in one function.  [I disagree on this 
one, one of my bugbears about pascal is the "goto end" effect because you can't 
have multiple returns.  It's often simply convenient to exit from a loop by 
using "return", especially when the function is some sort of search function  
drj 1998-08-18]

.output.read: Never read from an output parameter.  It may be in write-only 
memory.

.return.void.explicit: Even functions returning void should have a return 
statement.  Just to show that you care.

.single-step: Consider trying to debug the code in a line-based single-step 
debugger where breakpoints can only be placed at line boundaries.  Avoid having 
more than one side-effect in one statement.  Avoid having a conditional and its 
consequence on the same line.

.prototype.parameters: Function prototypes in external header files should not 
have named parameters (except in a function definition where they are 
necessary, but you won't see many of those in an external header file).  This 
covers function prototypes used to declare functions and to declare pointers to 
functions.  See mail.richard.1997-10-22.10-56(0) and 
mail.richard.1997-10-24.07-36(0).  This is because: a) header files are for 
compilers not humans, b) naming parameters is no substitute for real 
documentations, c) (the killer) the C preprocessor can macro substitute the 
parameter names.

