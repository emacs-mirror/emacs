                       PROSPECTUS FOR THE MM BOOK
                        project.book.prospectus
                              obsolete doc
                            nick 1997-05-02

Prospectus: 
Programming Effectively with Garbage Collection
A Handbook for Dynamic Object-Oriented Programming
by P. T. Withington and Andrew Shires

ptw@harlequin.com and andrews@harlequin.com 

Harlequin, Inc.
One Cambridge Center
Cambridge, MA 02142
617-374-2400
This is a prospectus for a book about programming in languages that use or can 
use garbage collection, or automatic memory management. Its audience will 
consist of a wide range of programmers, but principally those working in C++, 
C, and Java.
The book has the working title Programming Effectively with Garbage Collection, 
with a subtitle "A Handbook for Dynamic Object-Oriented Programming". We are 
considering other titles, and will discuss them later in this prospectus. 
1.  Introduction
What is garbage collection? 
Garbage collection is a form of memory management in computer programs. Memory 
management is the task of efficiently utilizing the memory allocated to a 
program to achieve its goals. 
Although computer memories keep getting bigger and cheaper, memory is still a 
relatively scarce resource in computing, because the problems computers are 
asked to solve, and the programs that solve them, always seem to grow to exceed 
the memory available. Because of this, careful memory management is a 
necessity. 
There are essentially two kinds of memory management: manual and automatic. In 
manual memory management, which is the standard in most programming languages, 
memory allocation is completely under programmer control. Recently, mainstream 
programming communities have begun to see automatic memory management - 
commonly known as garbage collection - as another way of tackling the problem. 
It makes memory management the responsibility of the programming language 
instead.
Automatic memory management is a fundamental part of new, dynamic 
object-oriented languages like Java and Dylan, and it is also attracting 
interest in the C and C++ communities. Other established languages - such as 
Lisp, Smalltalk, ML, Prolog, and even the PostScript™ language - manage memory 
automatically.
More on manual and automatic memory management
Manual memory management can lead to efficient use of memory, but it becomes 
increasingly difficult - and dangerous - as programs grow in complexity. 
Academic and industry studies show that many programming projects consume up to 
40% of their resources trying to manage memory correctly. Studies also show 
that a significant portion of program errors are due to incorrect manual 
management of memory, such as discarding a data structure that is still in use. 
In automatic memory management, the programming language run-time system 
automatically discovers unused memory (garbage) and recycles it for future use 
by the program. Automatic management can greatly reduce program development 
time and programming errors by freeing the programmer from the burdensome tasks 
of manual management. 
But automatic management also has its costs. To get the best performance from 
an automatically managed system, programmers need some understanding of how the 
automatic system works, and may need to understand how to tune their code to 
work with it efficiently. 
Goal of the book
Most programmers are familiar with manual memory management techniques, but 
know comparatively little about automatic memory management. This book will 
show programmers how they can adapt their programming styles to get the best 
performance from automatic memory management. 
2.  Harlequin and the authors
Harlequin is an international software company that creates products in the 
electronic publishing and symbolic processing fields. Its ScriptWorks RIP is a 
major software component of printers and imagesetters from the major 
manufacturers of printing equipment. It supplies symbolic processing tools in 
Common Lisp, Dylan, Standard ML, and other programming languages. It also 
produces data analysis applications used by the intelligence community.
The authors are Harlequin employees.
P. T. Withington Designer and developer in Harlequin's memory management group. 
Has written several garbage collection systems, and has been programming in 
garbage-collected languages for 25 years. Currently developing automatic 
memory-management systems and tools at Harlequin. Co-author of Dylan 
Programming, Addison Wesley, 1996. 
Andrew Shires Technical writer for four years in Harlequin's documentation 
group. Has written documentation for Harlequin's object-oriented and functional 
programming-language products. Familiar with C++, C, Java, Dylan, and other 
programming languages. 
3.  Overview of the book
Harlequin's goals for this book
Harlequin wants this book to:
• Publicize Harlequin as an expert in memory management
• Enable readers to become effective users of garbage-collected languages 
• Teach readers about memory management technologies and techniques 
Length 
The book will be approximately 260 pages. See "Outline" on page 7. 
Audience of the book
The book is aimed at all programmers working with or contemplating work with 
garbage-collected languages. These programmers include those using the new, 
dynamic, object-oriented languages like Java and Dylan, where garbage 
collection is a standard feature, and those using established languages like 
C++ and C, where garbage collection is steadily growing more popular.
C++, C, and Java programmers are the principal audience of the book. A large 
number of programmers in these communities are meeting automatic memory 
management for the first time. 
Many C++ and C programmers have extensive experience of those languages under 
manual memory management, but since automatic memory management is only now 
becoming available for them, they will not yet know how to use it effectively. 
Automatic memory management is not the only feature of Java that will be new to 
many of the programmers adopting it. But while much has been written about 
Java, automatic memory management issues still need thorough treatment.
Our audience also includes programmers using Dylan, Lisp, ML, and the 
PostScript language, all of which provide automatic memory management as a 
standard feature. 
The book will be valuable to these and indeed all readers with an interest in 
automatic memory management, because one of our aims is to illustrate the broad 
nature of memory management issues. Memory management issues affect most 
languages, and most can use automatic management techniques to address them. 
Approach
The book is styled as a "recipe book" with solutions to typical problems that 
programmers encounter when programming naively in automatic memory systems. We 
will demonstrate each problem by an example that will help readers identify 
similar issues in their own programs. 
We will begin by introducing a model of automatic memory management to help 
readers understand how it works. We will also provide the code of a simple 
example garbage collector in an appendix, for readers who find it easier to 
grasp computing concepts by examining a program. 
The example garbage collector may be coded in more than one language; C, C++, 
and Java are likely candidates. If the example collectors add too many pages to 
the book, we can consider putting some of them on the proposed CD-ROM only. See 
"CD-ROM", below. 
We will then contrast automatic management with manual management, and examine 
automatic management's benefits and pitfalls. We will examine each pitfall in 
detail, using a program example that demonstrates the problem and which is then 
fixed to ameliorate the problem. In conclusion, we will present a rule of thumb 
explaining how to avoid the problem. We will write our program examples mostly 
in C++, Java, and C. We will write some examples in less mainstream languages, 
but will also present C++, Java, or C equivalents. 
Later sections of the book will contain more advanced material. We will examine 
ways of working with a garbage collector to improve application performance. 
Again, we will draw examples from popular languages and collectors. We will 
also introduce measurement and analysis tools that can be used to tune 
automatic memory performance, and give several examples of their use to solve 
typical performance problems.
CD-ROM
The book will include a CD-ROM that contains the example code from the book and 
example garbage collectors.
We are keen to use Java for writing a garbage collector for a toy language. The 
collector will use graphics to illustrate garbage collection in action. We 
would like to include this on the CD-ROM, and on the World Wide Web pages 
proposed in "Web sites for this book", below. 
The CD-ROM could also include all or part of the Harlequin's Memory Management 
Reference, a comprehensive collection of memory management information written 
in HTML and available on the World Wide Web at 
<URL:http://www.harlequin.com/mm/reference/> 
The exact contents of the CD-ROM must be agreed upon by Harlequin's management 
and the publisher.
Production of the book
We plan to deliver FrameMaker files to the publisher. The book will contain 
text, tables, probably screen captures, and possibly figures drawn in a 
graphics editor. We do not expect to use color. 
Web sites for this book
We expect both Harlequin and the publisher to publicize this book on the World 
Wide Web. We expect to include on these Web sites the following kinds of 
information about the book: title, preface, table of contents, one or two 
chapters, some of the book's examples, information about the authors, and links 
to Harlequin's and the publisher's home pages.
Other possible titles for the book
This prospectus uses the working title: 
Programming Effectively with Garbage Collection 
A Handbook for Dynamic Object-Oriented Programming
We are considering other titles. Another possibility is to use a subtitle that 
names languages used by the target audience, at the expense of some generality. 
For example:
Programming Effectively with Garbage Collection 
A Handbook for C++ and Java Programmers
We would like to find a more concise title, perhaps using the subtitle to 
convey some of the same information. For example:
Effective Garbage Collection 
How to Program Efficiently and Effectively in C++, Java, and Dylan 
We are also considering this title:
Effective Garbage Collection 
How to Program Efficiently and Effectively in Garbage-Collected Languages
4.  Outline
Front matter: table of contents, preface, etc. (8 pages estimated)
Part I. About This Book (6 pages planned)
A. Who should read this book? (2)
B. What you need to know to understand this book (2)
C. Where to go for more information (2)
Part II. About Garbage Collection (30 pages planned)
A. GC is a form of memory management (7)
B. Who needs GC, and why? (23)
Part III. Using Garbage Collection (28 pages planned)
A. Pre-requisites (4)
B. GC at work (11)
C. Guidelines for using GC (13)
Part IV. Managing Your Memory (95 pages planned)
A. Understanding your programming language's memory model (21)
B. Simple management techniques (31)
C. Working with the GC (43)
Part V. Measurement and Analysis (58 pages planned)
A. Models (7)
B. Simple measurement and analysis (11)
C. Tuning (11)
D. Tools (29)
Part VI. Appendix: How GC works (24 pages planned)
A. Introduction to GC theory (13)
B. A simple GC (11)
Index (8 pages estimated)
Total: 257 pages.


