                 HARLEQUIN MEMORY POOL SYSTEM INTERFACE
                               impl.h.mps
                              accepted doc
                           gavinm 1996-07-23

     1 /*  impl.h.mps:
     2  *
     3  *           HARLEQUIN MEMORY POOL SYSTEM INTERFACE
     4  *
     5  *  $HopeName: MMsrc!mps.h(trunk.10) $
     6  *
     7  *  Copyright (C) 1996 Harlequin Group, all rights reserved
     8  */
     9 
    10 #ifndef mps_h
    11 #define mps_h
    12 
    13 #include "mpstd.h"              /* detect platform */
    14 #include <stddef.h>
    15 #include <stdarg.h>
    16 #include <limits.h>
    17 #ifdef MPS_PF_W3I3MV
    18 #include <windows.h>            /* needed for SEH filter type */
    19 #endif /* MPS_PF_W3I3MV */
    20 
    21 
    22 /* Macro Support */
    23 
    24 #define MPS_BEGIN       do {
    25 #define MPS_END         } while(0)
    26 
    27 
    28 /* Abstract Types
    29  *
    30  * Objects with these types are handles on internal MPS objects
    31  * and should not be manipulated by the client except via methods
    32  * provided in this interface, or where otherwise noted.
    33  */
    34 
    35 typedef struct mps_space_s  *mps_space_t;  /* space */
    36 typedef struct mps_pool_s   *mps_pool_t;   /* pool */
    37 typedef struct mps_fmt_s    *mps_fmt_t;    /* object format */
    38 typedef struct mps_root_s   *mps_root_t;   /* root */
    39 typedef struct mps_class_s  *mps_class_t;  /* pool class */
    40 typedef struct mps_thr_s    *mps_thr_t;    /* thread registration */
    41 typedef struct mps_ap_s     *mps_ap_t;     /* allocation point */
    42 typedef struct mps_ld_s     *mps_ld_t;     /* location dependency */
    43 typedef struct mps_reg_s    *mps_reg_t;    /* register file */
    44 typedef struct mps_ss_s     *mps_ss_t;     /* scan state */
    45 
    46 
    47 /* Concrete Types
    48  *
    49  * These types are defined to make the intention of the prototype
    50  * declarations clearer, and are not intended to be abstract types.
    51  * The boolean type can be used as int, etc.
    52  */
    53 
    54 typedef MPS_T_WORD mps_word_t;  /* machine word (target dep.) */
    55 typedef int mps_bool_t;         /* boolean (int) */
    56 typedef int mps_res_t;          /* result code (int) */
    57 typedef unsigned mps_shift_t;   /* shift amount (unsigned int) */
    58 typedef void *mps_addr_t;       /* managed address (void *) */
    59 typedef int mps_mc_t;           /* message code (int) */
    60 typedef size_t mps_align_t;     /* alignment (size_t) */
    61 typedef unsigned mps_rm_t;      /* root mode */
    62 
    63 
    64 /* Result Code Type
    65  *
    66  * The result code type is an alias of int, and may be used as such.
    67  * It is defined so that the intention of the prototype declarations
    68  * is clear.
    69  *
    70  * .result-codes: Keep in sync with impl.h.res.result-codes
    71  */
    72 
    73 enum
    74 {
    75   MPS_RES_OK = 0,               /* success */
    76   MPS_RES_FAIL,                 /* unspecified failure */
    77   MPS_RES_RESOURCE,             /* unable to obtain resources */
    78   MPS_RES_MEMORY,               /* unable to obtain memory */
    79   MPS_RES_LIMIT,                /* internal limitation reached */
    80   MPS_RES_UNIMPL,               /* unimplemented facility */
    81   MPS_RES_IO                    /* system I/O error */
    82 };
    83 
    84 
    85 /* Reference Ranks
    86  *
    87  * The rank type is an alias of int, but should _not_ be used as such,
    88  * as it may change in a future interface version.
    89  *
    90  * .ranks: Keep in sync with impl.h.mpmty.ranks
    91  */
    92 
    93 typedef int mps_rank_t;
    94 enum
    95 {
    96   MPS_RANK_AMBIG = 0,           /* ambiguous reference */
    97   MPS_RANK_EXACT = 1,           /* exact reference */
    98   MPS_RANK_WEAK = 2,            /* weak reference */
    99   MPS_RANK_FINAL = 3            /* final reference */
   100 };
   101 
   102 
   103 /* Root Modes
   104  *
   105  * A root mode is the logical OR of MPS_RM_* constants.
   106  *   MPS_RM_CONST  references in the root will not by updated by
   107  *                 the client code while the root exists.
   108  *   MPS_RM_PROT   the memory manager may use hardware memory
   109  *                 protection in order to perform incremental
   110  *                 scannning of the root.  This is not recommended
   111  *                 for areas of memory which are accessed frequently.
   112  *
   113  * .rm: Keep in sync with impl.h.mpmty.rm
   114  */
   115 
   116 #define MPS_RM_CONST    ((mps_rm_t)1)
   117 #define MPS_RM_PROT     ((mps_rm_t)2)
   118 
   119 
   120 /* Allocation Point
   121  *
   122  * The fields of the ap structure may be accessed directly by the
   123  * client in a restricted manner described in the MPS Interface
   124  * documentation, in order to perform fast in-line allocation.
   125  *
   126  * .ap: Keep in sync with impl.h.buffer.ap.
   127  */
   128 
   129 typedef struct mps_ap_s {       /* allocation point descriptor */
   130   mps_addr_t init;              /* limit of initialized memory */
   131   mps_addr_t alloc;             /* limit of reserved memory */
   132   mps_addr_t limit;             /* limit of buffered memory */
   133 } mps_ap_s;
   134 
   135 
   136 /* Location Dependency
   137  *
   138  * The fields of the ld structure should not be accessed by the client.
   139  * The structure definition is provided so that the client code can
   140  * in-line it into other structures, such as pointer hash-tables.
   141  *
   142  * .ld: Keep in sync with impl.h.ld.struct.
   143  */
   144 
   145 typedef struct mps_ld_s {       /* location dependency descriptor */
   146   mps_word_t w0, w1;
   147 } mps_ld_s;
   148 
   149 
   150 /* Format and Root Method Types */
   151 /* .fmt-methods: Keep in sync with impl.h.mpmty.fmt-methods */
   152 
   153 typedef mps_res_t  (*mps_root_scan_t)  (mps_ss_t mps_ss,
   154                                         void *p, size_t s);
   155 typedef mps_res_t  (*mps_fmt_scan_t)   (mps_ss_t mps_ss,
   156                                         mps_addr_t base,
   157                                         mps_addr_t limit);
   158 typedef mps_res_t  (*mps_reg_scan_t)   (mps_ss_t mps_ss,
   159                                         mps_reg_t mps_reg,
   160                                         void *p);
   161 typedef mps_addr_t (*mps_fmt_skip_t)   (mps_addr_t object);
   162 typedef void       (*mps_fmt_copy_t)   (mps_addr_t old, mps_addr_t new);
   163 typedef void       (*mps_fmt_fwd_t)    (mps_addr_t old, mps_addr_t new);
   164 typedef mps_addr_t (*mps_fmt_isfwd_t)  (mps_addr_t object);
   165 typedef void       (*mps_fmt_pad_t)    (mps_addr_t base, size_t size);
   166 
   167 
   168 /* Scan State
   169  *
   170  * The fields of the ss structure should not be accessed by the client
   171  * except via macros supplied in this interface.
   172  *
   173  * See also impl.c.mpsi.check.ss and impl.h.trace.ss.
   174  */
   175 
   176 typedef struct mps_ss_s {
   177   mps_res_t (*fix)(mps_ss_t mps_ss, mps_addr_t *ref_io);
   178   mps_word_t w0, w1, w2;
   179 } mps_ss_s;
   180 
   181 
   182 /* Format Variants */
   183 
   184 typedef struct mps_fmt_A_s *mps_fmt_A_t;
   185 typedef struct mps_fmt_A_s {
   186   mps_align_t     align;
   187   mps_fmt_scan_t  scan;
   188   mps_fmt_skip_t  skip;
   189   mps_fmt_copy_t  copy;
   190   mps_fmt_fwd_t   fwd;
   191   mps_fmt_isfwd_t isfwd;
   192   mps_fmt_pad_t   pad;
   193 } mps_fmt_A_s;
   194 
   195 
   196 /* Internal Definitions
   197  *
   198  * The following block of definitions are internal to the MPS Interface
   199  * and should not be used by the client code.  They are subject to
   200  * change and must not be relied upon.
   201  */
   202 
   203 extern mps_res_t mps_ap_fill(mps_addr_t *p_o, mps_ap_t mps_ap,
   204                              size_t size);
   205 extern mps_bool_t mps_ap_trip(mps_ap_t mps_ap, mps_addr_t p,
   206                               size_t size);
   207 
   208 #ifdef MPS_PF_W3I3MV
   209 extern LONG mps_SEH_filter(LPEXCEPTION_POINTERS info,
   210                            void **hp_o, size_t *hs_o);
   211 extern void mps_SEH_handler(void *p, size_t s);
   212 #endif /* MPS_PF_W3I3MV */
   213 
   214 
   215 /* Assertion Handling */
   216 
   217 typedef void (*mps_assert_t)(const char *cond,
   218                              const char *id,
   219                              const char *file,
   220                              unsigned line);
   221 
   222 extern mps_assert_t mps_assert_install(mps_assert_t handler);
   223 extern mps_assert_t mps_assert_default(void);
   224 
   225 
   226 /* Spaces */
   227 
   228 extern mps_res_t mps_space_create_wmem(mps_space_t *mps_space_o,
   229            mps_addr_t base, size_t size);
   230 extern mps_res_t mps_space_create(mps_space_t *mps_space_o);
   231 extern void mps_space_destroy(mps_space_t mps_space);
   232 
   233 
   234 /* Object Formats */
   235 
   236 extern mps_res_t mps_fmt_create_A(mps_fmt_t *mps_fmt_o,
   237                                   mps_space_t mps_space,
   238                                   mps_fmt_A_t mps_fmt_A);
   239 extern void mps_fmt_destroy(mps_fmt_t mps_fmt);
   240 
   241 
   242 /* Pools */
   243 
   244 extern mps_res_t mps_pool_create(mps_pool_t *mps_pool_o,
   245                                  mps_space_t mps_space,
   246                                  mps_class_t class, ...);
   247 extern mps_res_t mps_pool_create_v(mps_pool_t *mps_pool_o,
   248                                    mps_space_t mps_space,
   249                                    mps_class_t class,
   250                                    va_list args);
   251 extern void mps_pool_destroy (mps_pool_t mps_pool);
   252 
   253 extern mps_res_t mps_alloc(mps_addr_t *p_o,
   254                            mps_pool_t mps_pool,
   255                            size_t size, ...);
   256 extern mps_res_t mps_alloc_v(mps_addr_t *p_o,
   257                              mps_pool_t mps_pool,
   258                              size_t size,
   259                              va_list args);
   260 extern void mps_free(mps_pool_t mps_pool, mps_addr_t p, size_t size);
   261 
   262 
   263 /* Allocation Points */
   264 
   265 extern mps_res_t mps_ap_create(mps_ap_t *mps_ap_o, mps_pool_t mps_pool,
   266                                mps_rank_t mps_rank, ...);
   267 extern mps_res_t mps_ap_create_v(mps_ap_t *mps_ap_o, mps_pool_t mps_pool,
   268                                  mps_rank_t mps_rank, va_list args);
   269 extern void mps_ap_destroy(mps_ap_t mps_ap);
   270 
   271 extern mps_res_t (mps_reserve)(mps_addr_t *p_o, mps_ap_t mps_ap,
   272                                size_t size);
   273 extern mps_bool_t (mps_commit)(mps_ap_t mps_ap, mps_addr_t p,
   274                                size_t size);
   275 
   276 #define mps_reserve(_p_o, _mps_ap, _size) \
   277   ((char *)(_mps_ap)->alloc + (_size) > (char *)(_mps_ap)->alloc && \
   278    (char *)(_mps_ap)->alloc + (_size) <= (char *)(_mps_ap)->limit ? \
   279      ((_mps_ap)->alloc = \
   280        (mps_addr_t)((char *)(_mps_ap)->alloc + (_size)), \
   281       *(_p_o) = (_mps_ap)->init, \
   282       MPS_RES_OK) : \
   283      mps_ap_fill(_p_o, _mps_ap, _size))
   284 
   285 #define mps_commit(_mps_ap, _p, _size) \
   286   ((_mps_ap)->init = (_mps_ap)->alloc, \
   287    (_mps_ap)->limit != 0 || mps_ap_trip(_mps_ap, _p, _size))
   288 
   289 /* MPS_RESERVE_BLOCK provides an in-line allocation block which */
   290 /* may produce superior code to the mps_reserve macro if the */
   291 /* client's compiler cannot do adequate common subexpression */
   292 /* elimination. */
   293 
   294 #define MPS_RESERVE_BLOCK(_res_v, _p_v, _mps_ap, _size) \
   295   MPS_BEGIN \
   296     char *_alloc = (char *)(_mps_ap)->alloc; \
   297     char *_next = _alloc + (_size); \
   298     if(_next > _alloc && _next <= (char *)(_mps_ap)->limit) { \
   299       (_mps_ap)->alloc = (mps_addr_t)_next; \
   300       (_p_v) = (_mps_ap)->init; \
   301       (_res_v) = MPS_RES_OK; \
   302     } else \
   303       (_res_v) = mps_ap_fill(&(_p_v), _mps_ap, _size); \
   304   MPS_END
   305 
   306 
   307 /* Root Creation and Destruction
   308  *
   309  * mps_root_create creates the most general type of root: a scanning
   310  * function with two closure elements, p and s.
   311  *
   312  * mps_root_create_table creates a root from a block of memory which
   313  * contains a contiguous array of references.  Pages containing table
   314  * roots may be protected by the MPS if MPS_RM_PROT is set in the
   315  * root mode.
   316  *
   317  * mps_root_create_fmt creates a root from a block of memory which
   318  * contains formatted objects.  Pages containing fmt roots may be
   319  * protected by the MPS if MPS_RM_PROT is set in the root mode.
   320  *
   321  * mps_root_create_reg creates a root which will be used to scan
   322  * the registers of a thread.  (Often it will scan the stack, too.)
   323  */
   324 
   325 extern mps_res_t mps_root_create(mps_root_t *mps_root_o,
   326                                  mps_space_t mps_space,
   327                                  mps_rank_t mps_rank,
   328                                  mps_rm_t mps_rm,
   329                                  mps_root_scan_t mps_root_scan,
   330                                  void *p, size_t s);
   331 extern mps_res_t mps_root_create_table(mps_root_t *mps_root_o,
   332                                        mps_space_t mps_space,
   333                                        mps_rank_t mps_rank,
   334                                        mps_rm_t mps_rm,
   335                                        mps_addr_t *base, size_t size);
   336 extern mps_res_t mps_root_create_fmt(mps_root_t *mps_root_o,
   337                                      mps_space_t mps_space,
   338                                      mps_rank_t mps_rank,
   339                                      mps_rm_t mps_rm,
   340                                       mps_fmt_scan_t mps_fmt_scan,
   341                                      mps_addr_t base,
   342                                      mps_addr_t limit);
   343 extern mps_res_t mps_root_create_reg(mps_root_t *mps_root_o,
   344                                      mps_space_t mps_space,
   345                                      mps_rank_t mps_rank,
   346                                      mps_rm_t mps_rm,
   347                                      mps_thr_t mps_thr,
   348                                      mps_reg_scan_t mps_reg_scan,
   349                                      void *reg_scan_p);
   350 extern void mps_root_destroy(mps_root_t root);
   351 
   352 extern mps_res_t mps_stack_scan_ambig(mps_ss_t ss, mps_reg_t reg,
   353                                       void *p);
   354 
   355 
   356 /* Protection Trampoline and Thread Registration */
   357 
   358 extern void (mps_tramp)(void **r_o,
   359                         void *(*f)(void *p, size_t s),
   360                         void *p,
   361                         size_t s);
   362 
   363 #ifdef MPS_PF_W3I3MV
   364 
   365 #define mps_tramp(_r_o, _f, _p, _s) \
   366   MPS_BEGIN \
   367     void *_hp; size_t _hs; \
   368     __try { \
   369       *(_r_o) = (*(_f))(_p, _s); \
   370     } __except(mps_SEH_filter(GetExceptionInformation(), &_hp, &_hs)) { \
   371       mps_SEH_handler(_hp, _hs); \
   372     } \
   373   MPS_END
   374 
   375 #else /* MPS_PF_W3I3MV */
   376 
   377 #define mps_tramp(_r_o, _f, _p, _s) \
   378   MPS_BEGIN \
   379     *(_r_o) = (*(_f))(_p, _s); \
   380   MPS_END
   381 
   382 #endif /* MPS_PF_W3I3MV */
   383 
   384 extern mps_res_t mps_thread_reg(mps_thr_t *mps_thr_o,
   385                                 mps_space_t mps_space);
   386 extern void mps_thread_dereg(mps_thr_t mps_thr);
   387 
   388 
   389 /* Location Dependency
   390  *
   391  * The address must be added to the ld _before_ a dependency it made
   392  * on its value (e.g. before hashing it) in order to avoid a race.
   393  */
   394 
   395 extern void mps_ld_reset(mps_ld_t mps_ld, mps_space_t space);
   396 extern void mps_ld_add(mps_ld_t mps_ld,
   397                        mps_space_t mps_space,
   398                        mps_addr_t addr);
   399 extern mps_bool_t mps_ld_isstale(mps_ld_t mps_ld,
   400                                  mps_space_t mps_space,
   401                                  mps_addr_t addr);
   402 
   403 extern mps_word_t mps_collections(mps_space_t mps_space);
   404 
   405 /* Messages (Notification of Asynchronous Events) */
   406 
   407 typedef void (*mps_msg_handler_t)(mps_space_t *mps_space,
   408                                   mps_mc_t mps_mc,
   409                                   void *msg_data);
   410 
   411 extern mps_bool_t mps_msg_next(mps_space_t mps_space,
   412                                mps_mc_t *mps_mc_o,
   413                                void **msg_data_o);
   414 extern mps_bool_t mps_msg_peek(mps_space_t mps_space,
   415                                mps_mc_t *mps_mc_o,
   416                                void **msg_data_o);
   417 
   418 extern mps_msg_handler_t
   419   mps_msg_handler(mps_space_t mps_space,
   420                   mps_msg_handler_t mps_msg_handler);
   421 
   422 /* Scanner Support */
   423 
   424 extern mps_res_t mps_fix(mps_ss_t mps_ss, mps_addr_t *ref_io);
   425 
   426 #define MPS_SCAN_BEGIN(_mps_ss) \
   427   MPS_BEGIN \
   428     mps_word_t _mps_w0 = (_mps_ss)->w0; \
   429     mps_word_t _mps_w1 = (_mps_ss)->w1; \
   430     mps_word_t _mps_w2 = (_mps_ss)->w2; \
   431     mps_word_t _mps_wt; \
   432     {
   433 
   434 #define MPS_FIX1(_mps_ss, _mps_ref) \
   435   (_mps_wt = 1uL<<((mps_word_t)(_mps_ref)>>_mps_w0&(MPS_WORD_WIDTH-1)), \
   436    _mps_w2 |= _mps_wt, \
   437    _mps_w1 & _mps_wt)
   438 
   439 #define MPS_FIX2(_mps_ss, _mps_ref_io) \
   440   ((*(_mps_ss)->fix)(_mps_ss, _mps_ref_io))
   441 
   442 #define MPS_FIX(_mps_ss, _mps_ref_io) \
   443   (MPS_FIX1(_mps_ss, *(_mps_ref_io)) ? \
   444    MPS_FIX2(_mps_ss, _mps_ref_io) : MPS_RES_OK)
   445 
   446 #define MPS_SCAN_END(_mps_ss) \
   447    } \
   448    (_mps_ss)->w2 = _mps_w2; \
   449   MPS_END
   450 
   451 
   452 #endif /* mps_h */

