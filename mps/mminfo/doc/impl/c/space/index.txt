                          SPACE IMPLEMENTATION
                              impl.c.space
                               draft impl
                             dsm 1996-08-14

     1 /* impl.c.space: SPACE IMPLEMENTATION
     2  *
     3  * $HopeName: MMsrc!space.c(trunk.23) $
     4  * Copyright (C) 1996 Harlequin Group, all rights reserved
     5  *
     6  * This is the implementation of the Space module.
     7  *
     8  * DESIGN
     9  *
    10  * design.mps.space (This document does not exist).
    11  * design.mps.thread is relevant to to the functions SpaceEnter and
    12  * SpaceLeave in this file.
    13  *
    14  * NOTES
    15  *
    16  * .non-mod: The Space structure has many fields which properly belong
    17  * to other modules (see impl.h.mpmst); SpaceCreate contains code which
    18  * breaks the usual module abstractions.  Such instances are documented
    19  * with a tag to the relevent module implementation.
    20  *
    21  * TRANSGRESSIONS
    22  *
    23  * .static: Static data is used in SpaceAccess (in order to find the
    24  * appropriate space) and SpaceCreate (in order to get a fresh serial
    25  * number.
    26  */
    27 
    28 
    29 #include "mpm.h"
    30 
    31 
    32 SRCID(space, "$HopeName: MMsrc!space.c(trunk.23) $");
    33 
    34 static Bool spaceRingInit = FALSE;
    35 static RingStruct spaceRing;
    36 static Serial spaceSerial;
    37 static LockStruct spaceRingLock;
    38 
    39 Bool SpaceCheck(Space space)
    40 {
    41   CHECKL(space != NULL);
    42   CHECKS(Space, space);
    43   CHECKL(space->serial < spaceSerial);
    44   CHECKL(RingCheck(&space->globalRing));
    45   CHECKD(Arena, &space->arenaStruct);
    46   CHECKL(RingCheck(&space->rootRing));
    47   CHECKL(RingCheck(&space->poolRing));
    48   CHECKL(RingCheck(&space->threadRing));
    49   CHECKL(RingCheck(&space->formatRing));
    50   CHECKD(Lock,  &space->lockStruct);
    51   if(space->poolReady)
    52     CHECKD(MV, &space->controlPoolStruct);
    53   return TRUE;
    54 }
    55 
    56 /* This is called when a protected address is accessed.  The mode
    57  * corresponds to which mode bits need to be cleared in order
    58  * for the access to continue.
    59  */
    60 Bool SpaceAccess(Addr addr, AccessSet mode)
    61 {
    62   Pool pool;
    63   Seg seg;
    64   Ring node;
    65 
    66   LockClaim(&spaceRingLock);
    67   node = RingNext(&spaceRing);
    68   while(node != &spaceRing) {
    69     Space space = RING_ELT(Space, globalRing, node);
    70 
    71     SpaceEnter(space);
    72     AVERT(Space, space);
    73     if(SegOfAddr(&seg, space, addr)) {
    74       LockRelease(&spaceRingLock);
    75       pool = seg->pool;
    76       /* An access in a different thread may have already caused
    77        * the protection to be cleared.  This avoids calling
    78        * PoolAccess on protection that has already been cleared on
    79        * a separate thread
    80        */
    81       mode &= seg->pm;
    82       if(mode)
    83         PoolAccess(pool, seg, mode);
    84       SpaceLeave(space);
    85       return TRUE;
    86     }
    87     SpaceLeave(space);
    88 
    89     node = RingNext(node);
    90   }
    91 
    92   LockRelease(&spaceRingLock);
    93   return FALSE;
    94 }
    95 
    96 Res SpaceCreate(Space *spaceReturn, Addr base, Size size)
    97 {
    98   Res res;
    99   Space space;
   100   Size i;
   101   
   102   AVER(MPMCheck());
   103 
   104   if(!spaceRingInit) {       /* Race condition */
   105     LockInit(&spaceRingLock);
   106     LockClaim(&spaceRingLock);
   107     spaceRingInit = TRUE;
   108     RingInit(&spaceRing);
   109     spaceSerial = (Serial)0;
   110     ProtSetup();
   111   } else
   112     LockClaim(&spaceRingLock);
   113 
   114   /* If we are passed a (non-zero) size value (from
   115    * mps_space_create_wmem), then use that, otherwise use a default size
   116    * (from impl.h.mpmconf).
   117    */
   118   res = ArenaCreate(&space, size ? size : ARENA_SIZE, base);
   119   if(res != ResOK)
   120     goto failArenaCreate;
   121 
   122   RingInit(&space->globalRing);
   123   RingInit(&space->poolRing);
   124   space->poolSerial = (Serial)0;
   125   RingInit(&space->rootRing);
   126   space->rootSerial = (Serial)0;
   127   RingInit(&space->threadRing);
   128   space->threadSerial = (Serial)0;
   129   RingInit(&space->formatRing);
   130   space->formatSerial = (Serial)0;
   131   space->busyTraces = TraceSetEMPTY;    /* impl.c.trace */
   132   LockInit(&space->lockStruct);
   133   space->insideShield = FALSE;          /* impl.c.shield */
   134   space->shCacheI = 0;
   135   space->shDepth = 0;
   136   space->suspended = 0;
   137   for(i = 0; i <SHIELD_CACHE_SIZE; i++)
   138     space->shCache[i] = (Seg)0;
   139   space->pollThreshold = (Size)0;
   140   space->insidePoll = FALSE;
   141   space->epoch = (Epoch)0;              /* impl.c.ld */
   142   space->prehistory = RefSetEmpty;
   143   for(i = 0; i < SPACE_LD_LENGTH; ++i)
   144     space->history[i] = RefSetEmpty;
   145   space->poolReady = FALSE;
   146 
   147   space->sig = SpaceSig;
   148   space->serial = spaceSerial;
   149   ++spaceSerial;
   150 
   151   res = PoolInit(&space->controlPoolStruct.poolStruct, space,
   152                  PoolClassMV(),
   153                  SPACE_CONTROL_EXTENDBY, SPACE_CONTROL_AVGSIZE,
   154                  SPACE_CONTROL_MAXSIZE);
   155   if(res != ResOK)
   156     goto failControlInit;
   157   space->poolReady = TRUE;
   158 
   159   RingAppend(&spaceRing, &space->globalRing);
   160 
   161   AVERT(Space, space);
   162 
   163   *spaceReturn = space;
   164   res = ResOK;
   165   goto return_e;
   166 
   167   NOTREACHED;
   168 
   169 failControlInit:
   170   ArenaDestroy(space);
   171 failArenaCreate:
   172 return_e:
   173   LockRelease(&spaceRingLock);
   174   return res;
   175 }
   176 
   177 
   178 void SpaceDestroy(Space space)
   179 {
   180   AVERT(Space, space);
   181   AVER(!space->insidePoll);
   182   AVER(!space->insideShield);
   183 
   184   LockClaim(&spaceRingLock);
   185   RingRemove(&space->globalRing);
   186   LockRelease(&spaceRingLock);
   187 
   188   PoolFinish(&space->controlPoolStruct.poolStruct);
   189   LockFinish(&space->lockStruct);
   190   RingFinish(&space->poolRing);
   191   RingFinish(&space->formatRing);
   192   RingFinish(&space->rootRing);
   193   RingFinish(&space->threadRing);
   194   RingFinish(&space->globalRing);
   195 
   196   ArenaDestroy(space);
   197 }
   198 
   199 void SpaceEnter(Space space)
   200 {
   201   AVER(space->sig == SpaceSig);
   202   LockClaim(&space->lockStruct);
   203   ShieldEnter(space);
   204 }
   205 
   206 void SpaceLeave(Space space)
   207 {
   208   AVERT(Space, space);
   209   ShieldLeave(space);
   210   ProtSync(space);
   211   LockRelease(&space->lockStruct);
   212 }
   213 
   214 /* Noddy collection policy -- condemn everything in the world! */
   215 static Res SpaceCollect(Space space)
   216 {
   217   Ring node;
   218   TraceId ti;
   219   RefSet condemned;
   220   Res res;
   221 
   222   res = TraceCreate(&ti, space);
   223   if(res != ResOK) goto failTraceCreate;
   224 
   225   condemned = RefSetEmpty;
   226 
   227   node = RingNext(SpacePoolRing(space));
   228   while(node != SpacePoolRing(space)) {
   229     Ring next = RingNext(node);
   230     Pool pool = RING_ELT(Pool, spaceRing, node);
   231     RefSet c;
   232 
   233     if((pool->class->attr & AttrGC) != 0) {
   234       res = PoolCondemn(&c, pool, space, ti);
   235       if(res != ResOK) goto failCondemn;
   236       condemned = RefSetUnion(condemned, c);
   237     }
   238 
   239     node = next;
   240   }
   241 
   242   if(condemned != RefSetEmpty) {
   243     res = TraceFlip(space, ti, condemned);
   244     if(res != ResOK) goto failTraceFlip;
   245   } else {
   246     TraceDestroy(space, ti);
   247   }
   248 
   249   return ResOK;
   250 
   251 failTraceFlip:
   252 failCondemn:
   253   /* .improve.undo-condemn: This is unsatisfactory as pools which
   254    * successfully completed a condemn aren't given a chance to
   255    * release any resources they may have allocated. */
   256   TraceDestroy(space, ti);
   257 failTraceCreate:
   258   return res;
   259 }
   260 
   261 void SpacePoll(Space space)
   262 {
   263   TraceId ti;
   264   Size interval;
   265   Size size;
   266 
   267   AVERT(Space, space);
   268 
   269   size = ArenaCommitted(space);
   270   if(space->insidePoll || size < space->pollThreshold)
   271     return;
   272 
   273   space->insidePoll = TRUE;
   274   interval = SPACE_POLL_MAX;
   275 
   276   if(space->busyTraces == TraceSetEMPTY)
   277     (void)SpaceCollect(space);
   278 
   279   for(ti = 0; ti < TRACE_MAX; ++ti)
   280     if(TraceSetIsMember(space->busyTraces, ti)) {
   281       Size i = TracePoll(space, ti);
   282       if(i < interval)
   283         interval = i;
   284     }
   285 
   286   space->insidePoll = FALSE;
   287   size = ArenaCommitted(space);
   288   space->pollThreshold = size + interval;
   289 }
   290 
   291 Res SpaceDescribe(Space space, Lib_FILE *stream)
   292 {
   293   Ring node;
   294 
   295   AVERT(Space, space);
   296   AVER(stream != NULL);
   297 
   298   Lib_fprintf(stream, "Space 0x%lX {\n", (unsigned long)space);
   299 
   300   node = RingNext(&space->rootRing);
   301   while(node != &space->rootRing)
   302   {
   303     Root root = RING_ELT(Root, spaceRing, node);
   304     RootDescribe(root, stream);
   305     node = RingNext(node);
   306   }
   307 
   308   node = RingNext(&space->poolRing);
   309   while(node != &space->poolRing)
   310   {
   311     Pool pool = RING_ELT(Pool, spaceRing, node);
   312     PoolDescribe(pool, stream);
   313     node = RingNext(node);
   314   }
   315 
   316   Lib_fprintf(stream, "} Space 0x%lX\n", (unsigned long)space);
   317 
   318   return ResOK;
   319 }
   320 
   321 Res SpaceAlloc(Addr *baseReturn, Space space, Size size)
   322 {
   323   Addr base;
   324   Res res;
   325   Pool pool;
   326 
   327   AVERT(Space, space);
   328   AVER(baseReturn != NULL);
   329   AVER(size > 0);
   330 
   331   pool = MVPool(&space->controlPoolStruct);
   332   res = PoolAlloc(&base, pool, size);
   333   if(res != ResOK) return res;
   334 
   335   *baseReturn = base;
   336   return ResOK;
   337 }
   338 
   339 void SpaceFree(Space space, Addr base, Size size)
   340 {
   341   Pool pool;
   342   AVERT(Space, space);
   343   AVER(base != NULL);
   344   AVER(size > 0);
   345 
   346   pool = MVPool(&space->controlPoolStruct);
   347   PoolFree(pool, base, size);
   348 }

