              ELECTRONIC PUBLISHING "VIRTUAL MEMORY" CLASS
                            impl.c.poolepvm
                             incomplete doc
                           gavinm 1997-09-15

     1 /* impl.c.poolepvm: ELECTRONIC PUBLISHING "VIRTUAL MEMORY" CLASS
     2  *
     3  * $HopeName: MMsrc!poolepvm.c(trunk.3) $
     4  * Copyright (C) 1997 The Harlequin Group Limited.  All rights reserved.
     5  *
     6  * READERSHIP
     7  *
     8  * .readership: Any MPS developer
     9  *
    10  * DESIGN
    11  *
    12  * .design: see design.mps.poolams and design.mps.poolepvm.
    13  *
    14  * This is the implementation of the PostScript Virtual Memory pool
    15  * class for MM/EP-core.  */
    16 
    17 
    18 #include "mpm.h"
    19 #include "mps.h"
    20 #include "mpscepvm.h"
    21 
    22 
    23 SRCID(poolepvm, "$HopeName: MMsrc!poolepvm.c(trunk.3) $");
    24 
    25 
    26 /* signatures */
    27 
    28 #define EPVMGroupSig    ((Sig)0x519EBF39) /* SIGnature EPVM Group */
    29 #define EPVMSaveSig     ((Sig)0x519EBF35) /* SIGnature EPVM Save */
    30 #define EPVMSig         ((Sig)0x519EBF33) /* SIGnature EPVM */
    31 
    32 
    33 /* structure pointer types */
    34 
    35 typedef struct EPVMGroupStruct *EPVMGroup;
    36 typedef struct EPVMSaveStruct *EPVMSave;
    37 typedef struct EPVMStruct *EPVM;
    38 
    39 
    40 /* structures */
    41 
    42 /* EPVMGroupStruct: one per segment */
    43 
    44 typedef struct EPVMGroupStruct {
    45   Sig sig;
    46   Seg seg;                      /* segment of group's memory */
    47   EPVMSave save;                /* owning save structure */
    48   RingStruct saveRing;          /* ring of groups at this save level */
    49   Count grains;                 /* number of grains in this group */
    50   BT allocTable;                /* set if grain is allocated */
    51 
    52   /* design.mps.poolams.one-condemn */
    53   Bool marked;                  /* has been marked since last scan */
    54   BT markTable;                 /* set if grain marked */
    55   BT scanTable;                 /* set if grain scanned */
    56 } EPVMGroupStruct;
    57 
    58 
    59 /* EPVMSaveStruct: one per save level per pool.
    60  * 
    61  * design.mps.poolepvm.decide.simple.save.segments
    62  * design.mps.poolepvm.decide.simple.save.head
    63  * design.mps.poolepvm.low.size
    64  */
    65 
    66 typedef struct EPVMSaveStruct {
    67   Sig sig;                      /* impl.h.misc.sig */
    68   Index level;                  /* save level */
    69   Size size;                    /* total size of segs at this level */
    70   EPVM epvm;                    /* owning epvm */
    71   RingStruct groupRing;         /* ring of groups at this level */
    72 } EPVMSaveStruct;
    73 
    74 
    75 /* EPVMStruct -- PostScript Virtual Memory pool instance structure */
    76 
    77 typedef struct EPVMStruct {
    78   PoolStruct poolStruct;        /* generic pool structure */
    79   Format format;                /* format of objects in this pool */
    80   Shift grainShift;             /* log2 of grain size */
    81   ActionStruct actionStruct;    /* action of collecting this pool */
    82   Index saveLevel;              /* current save level */
    83   Index maxSaveLevel;           /* maximum save level */
    84   EPVMSaveStruct *saves;        /* pointer to array of save structs */
    85   Size size;                    /* total segment size */
    86   Sig sig;                     /* design.mps.pool.outer-structure.sig */
    87 } EPVMStruct;
    88 
    89 
    90 /* prototype the check function here; definition is at the end of the
    91  * file, after the declaration of the pool class structure. */
    92 
    93 static Bool EPVMCheck(EPVM epvm);
    94 
    95 
    96 /* macros to get between child and parent structures */
    97 
    98 #define PoolPoolEPVM(pool) PARENT(EPVMStruct, poolStruct, pool)
    99 #define EPVMPool(epvm)      (&(epvm)->poolStruct)
   100 
   101 #define ActionEPVM(action) PARENT(EPVMStruct, actionStruct, action)
   102 #define EPVMAction(epvm)    (&(epvm)->actionStruct)
   103 
   104 
   105 /* macros for manuevering about between structures: */
   106 
   107 #define EPVMSegGroup(seg)          ((EPVMGroup)SegP(seg))
   108 #define EPVMSavePool(save)         EPVMPool((save)->epvm)
   109 #define EPVMGroupEPVM(group)       ((group)->save->epvm)
   110 #define EPVMGroupArena(group)      PoolArena(SegPool((group)->seg))
   111 #define EPVMArena(epvm)            PoolArena(EPVMPool(epvm))
   112 #define EPVMSaveArena(save)        EPVMArena((save)->epvm)
   113 #define EPVMLevelSave(epvm,level)  (&(epvm)->saves[level])
   114 #define EPVMCurrentSave(epvm)      (&(epvm)->saves[(epvm)->saveLevel])
   115 
   116 /* macros for abstracting index/address computations: */
   117 
   118 /* only use when size is a multiple of the grain size */
   119 #define EPVMGrains(epvm,size)       ((size) >> (epvm)->grainShift)
   120 
   121 #define EPVMGroupBase(group)       SegBase(EPVMGroupArena(group),      \
   122                                           (group)->seg)
   123 
   124 #define EPVMGroupLimit(group)      SegLimit(EPVMGroupArena(group),     \
   125                                            (group)->seg)
   126 
   127 #define EPVMGroupShift(group)      (EPVMGroupEPVM(group)->grainShift)
   128 
   129 #define EPVMGroupOffset(group, addr) AddrOffset(EPVMGroupBase(group),  \
   130                                                addr)
   131 
   132 #define EPVMGroupAddr(group, offset) AddrAdd(EPVMGroupBase(group),     \
   133                                              offset)
   134 
   135 #define EPVMAddrIndex(group,addr) ((Index)(EPVMGroupOffset(group,addr) \
   136                                           >> EPVMGroupShift(group)))
   137 
   138 #define EPVMIndexAddr(group,index) EPVMGroupAddr(group,                \
   139                                                (index) <<              \
   140                                                EPVMGroupShift(group))
   141 
   142 #define EPVMBufferScanLimIndex(group, buffer)                          \
   143                        EPVMAddrIndex(group, BufferScanLimit(buffer))
   144 #define EPVMBufferLimitIndex(group, buffer)                            \
   145                        EPVMAddrIndex(group, BufferLimit(buffer))
   146 
   147 /* macros for telling and changing the colour of a grain or range of
   148  * grains. The idea is that the main body of code doesn't know about
   149  * the tables at all. See design.mps.poolepvm.low.macro */
   150 
   151 #define EPVMMarked(group,index)  BTGet((group)->markTable, index)
   152 #define EPVMScanned(group,index)  BTGet((group)->scanTable, index)
   153 #define EPVMAlloced(group,index)  BTGet((group)->allocTable, index)
   154 
   155 /* design.mps.poolams.invariant.grey */
   156 #define EPVMIsGrey(group, index) (EPVMMarked(group,index) &&           \
   157                                   !(EPVMScanned(group, index)))
   158 
   159 
   160 /* design.mps.poolams.invariant.grey */
   161 /* design.mps.poolams.invariant.black */
   162 #define EPVMGreyBlacken(group, index)                                  \
   163            BEGIN                                                       \
   164              BTSet((group)->scanTable, index);                         \
   165            END
   166 
   167 /* design.mps.poolams.invariant.white */
   168 /* design.mps.poolams.invariant.grey */
   169 #define EPVMWhiteGrey(group, index)                                    \
   170            BEGIN                                                       \
   171              BTSet((group)->markTable, index);                         \
   172            END
   173 
   174 /* design.mps.poolams.invariant.white */
   175 /* design.mps.poolams.invariant.free */
   176 #define EPVMWhiteFree(group, index)                                    \
   177            BEGIN                                                       \
   178              BTSet((group)->scanTable, index);                         \
   179              BTRes((group)->allocTable, index);                        \
   180            END
   181 
   182 /* design.mps.poolams.invariant.free */
   183 #define EPVMRangeIsFree(group, base, limit)                            \
   184             (BTIsResRange((group)->markTable, base, limit) &&          \
   185              BTIsSetRange((group)->scanTable, base, limit) &&          \
   186              BTIsResRange((group)->allocTable, base, limit))
   187 
   188 /* design.mps.poolams.invariant.black */
   189 #define EPVMRangeIsBlack(group, base, limit)                           \
   190             (BTIsSetRange((group)->markTable, base, limit) &&          \
   191              BTIsSetRange((group)->scanTable, base, limit) &&          \
   192              BTIsSetRange((group)->allocTable, base, limit))
   193 
   194 /* design.mps.poolams.invariant.black */
   195 /* design.mps.poolams.invariant.free */
   196 #define EPVMRangeIsBlackOrFree(group, base, limit)                     \
   197             (BTIsSetRange((group)->scanTable, base, limit) &&          \
   198              BTRangesSame((group)->allocTable, (group)->markTable,     \
   199                           base, limit))
   200 
   201 /* black -> white, free -> free, see design.mps.poolams.invariant */
   202 #define EPVMRangeColourCondemn(group, base, limit)                     \
   203            BEGIN                                                       \
   204              BTResRange((group)->markTable, base, limit);              \
   205              BTCopyInvertRange((group)->allocTable, (group)->scanTable,\
   206                                base, limit);                           \
   207            END
   208 
   209 /* design.mps.poolams.invariant.free */
   210 #define EPVMRangeFree(group, base, limit)                              \
   211            BEGIN                                                       \
   212              BTResRange((group)->markTable, base, limit);              \
   213              BTSetRange((group)->scanTable, base, limit);              \
   214              BTResRange((group)->allocTable, base, limit);             \
   215            END
   216 
   217 /* design.mps.poolams.invariant.black */
   218 #define EPVMRangeBlacken(group, base, limit)                           \
   219            BEGIN                                                       \
   220              BTSetRange((group)->markTable, base, limit);              \
   221              BTSetRange((group)->scanTable, base, limit);              \
   222              BTSetRange((group)->allocTable, base, limit);             \
   223            END
   224 
   225 /* design.mps.poolams.invariant.free */
   226 #define EPVMFindFreeRange(basep, limitp, group, grains)                \
   227              BTFindLongResRange(basep, limitp, (group)->allocTable,    \
   228                                 0, (group)->grains, grains);
   229 
   230 
   231 /* EPVMSaveCheck -- check the save level structure */
   232 
   233 static Bool EPVMSaveCheck(EPVMSave save)
   234 {
   235   CHECKS(EPVMSave, save);
   236   CHECKU(EPVM, save->epvm);
   237   CHECKL(save->level < save->epvm->maxSaveLevel);
   238   CHECKL(save->size <= save->epvm->size);
   239   if (save->level > save->epvm->saveLevel) /* nothing at this level */
   240     CHECKL(save->size == 0);
   241 
   242   CHECKL(SizeIsAligned(save->size, ArenaAlign(EPVMSaveArena(save))));
   243   CHECKL(RingCheck(&save->groupRing));
   244   
   245   return TRUE;
   246 }
   247 
   248 /* EPVMGroupCheck -- check the group */
   249 
   250 static Bool EPVMGroupCheck(EPVMGroup group)
   251 {
   252   CHECKS(EPVMGroup, group);
   253   CHECKL(SegCheck(group->seg));
   254   CHECKL(EPVMSegGroup(group->seg) == group);
   255   CHECKU(EPVMSave, group->save);
   256   CHECKL(RingCheck(&group->saveRing));
   257   CHECKL(EPVMPool(EPVMGroupEPVM(group)) ==
   258          SegPool(group->seg));
   259 
   260   CHECKL(group->grains ==
   261          (SegSize(EPVMGroupArena(group), group->seg) >>
   262           EPVMGroupShift(group)));
   263   CHECKL(group->grains > 0);
   264   CHECKL(group->save->size >=
   265          SegSize(EPVMGroupArena(group), group->seg));
   266 
   267   if (SegWhite(group->seg) != TraceSetEMPTY)
   268     /* design.mps.poolams.one-condemn */
   269     CHECKL(TraceSetSingle(SegWhite(group->seg)));
   270 
   271   /* buffers only on the current save level */
   272   if (SegBuffer(group->seg) != NULL)
   273     CHECKL(EPVMGroupEPVM(group)->saveLevel == group->save->level);
   274 
   275   CHECKL(BoolCheck(group->marked));
   276   /* design.mps.poolams.bt-check */
   277   CHECKL(group->allocTable != NULL);
   278   CHECKL(group->markTable != NULL);
   279   CHECKL(group->scanTable != NULL);
   280 
   281   return TRUE;
   282 }
   283 
   284 
   285 /* EPVMGroupCreate -- create a single group */
   286 
   287 static Res EPVMGroupCreate(EPVMGroup *groupReturn, EPVMSave save,
   288                            Pool pool, Size size, RankSet rankSet)
   289 {
   290   EPVMGroup group;
   291   EPVM epvm;
   292   Res res;
   293   Arena arena;
   294   Seg seg;
   295   void *p;                      /* for allocating the group header */
   296   
   297   AVER(groupReturn != NULL);
   298   AVERT(EPVMSave, save);
   299   AVERT(Pool, pool);
   300   AVER(EPVMSavePool(save) == pool);
   301   AVER(RankSetCheck(rankSet));
   302   AVER(size > 0);
   303 
   304   epvm = PoolPoolEPVM(pool);
   305   AVERT(EPVM,epvm);
   306   
   307   arena = PoolArena(pool);
   308   
   309   size = SizeAlignUp(size, ArenaAlign(arena));
   310   if (size == 0)
   311     return ResMEMORY; /* overflow in alignment computation */
   312   
   313   res = ArenaAlloc(&p, arena, (Size)sizeof(EPVMGroupStruct));
   314   if (res != ResOK)
   315     goto failGroup;
   316   group = (EPVMGroup)p;
   317 
   318   res = SegAlloc(&seg, SegPrefDefault(), arena, size, pool);
   319   if (res != ResOK)
   320     goto failSeg;
   321   
   322   group->seg = seg;
   323   SegSetP(seg, (void*)group);
   324   SegSetRankSet(seg, rankSet);
   325   if (rankSet != RankSetEMPTY) /* see design.mps.seg.field.rankSet */
   326     SegSetSummary(seg, RefSetUNIV);
   327 
   328   group->grains = size >> epvm->grainShift;
   329   group->marked = FALSE; /* design.mps.poolams.marked.unused */
   330 
   331   res = BTCreate(&group->allocTable, arena, group->grains);
   332   if (res != ResOK)
   333     goto failAlloc;
   334 
   335   res = BTCreate(&group->markTable, arena, group->grains);
   336   if (res != ResOK)
   337     goto failMark;
   338 
   339   res = BTCreate(&group->scanTable, arena, group->grains);
   340   if (res != ResOK)
   341     goto failScan;
   342   /* design.mps.poolams.invariant.create */
   343   EPVMRangeFree(group, 0, group->grains);
   344 
   345   epvm->size += size;
   346 
   347   group->save = save;
   348   RingInit(&group->saveRing);
   349   RingAppend(&save->groupRing, &group->saveRing);
   350   save->size += size;
   351 
   352   group->sig = EPVMGroupSig;
   353   AVERT(EPVMGroup, group);
   354 
   355   *groupReturn = group;
   356   return ResOK;
   357   
   358   /* keep the destructions in step with EPVMGroupDestroy */
   359 failScan:
   360   BTDestroy(group->markTable, arena, group->grains);
   361 failMark:
   362   BTDestroy(group->allocTable, arena, group->grains);
   363 failAlloc:
   364   SegFree(arena, seg);
   365 failSeg:
   366   ArenaFree(arena, group, (Size)sizeof(EPVMGroupStruct));
   367 failGroup:
   368   AVER(res != ResOK);
   369   return res;
   370 }
   371 
   372 
   373 /* EPVMGroupDestroy -- destroy a single group */
   374 
   375 static void EPVMGroupDestroy(EPVMGroup group)
   376 {
   377   EPVM epvm;
   378   EPVMSave save;
   379   Arena arena;
   380   Size size;
   381   Seg seg;
   382 
   383   AVERT(EPVMGroup, group);
   384   save = group->save;
   385   AVERT(EPVMSave, save);
   386   epvm = save->epvm;
   387   AVERT(EPVM, epvm);
   388   arena = PoolArena(EPVMPool(epvm));
   389   AVERT(Arena, arena);
   390 
   391   seg = group->seg;
   392   if (SegBuffer(seg) != NULL)
   393     BufferDetach(SegBuffer(seg), EPVMPool(epvm));
   394 
   395   RingRemove(&group->saveRing);
   396   RingFinish(&group->saveRing);
   397 
   398   size = SegSize(arena, group->seg);
   399   AVER(epvm->size >= size);
   400   AVER(save->size >= size);
   401   epvm->size -= size;
   402   save->size -= size;
   403 
   404   group->sig = SigInvalid;
   405 
   406   /* keep the destructions in step with EPVMGroupCreate failure cases */
   407   BTDestroy(group->scanTable, arena, group->grains);
   408   BTDestroy(group->markTable, arena, group->grains);
   409   BTDestroy(group->allocTable, arena, group->grains);
   410   SegFree(arena, group->seg);
   411   ArenaFree(arena, group, (Size)sizeof(EPVMGroupStruct));
   412 }  
   413 
   414 
   415 /* EPVMSaveInit -- initialize a save structure */
   416 
   417 static void EPVMSaveInit(EPVM epvm, Index level)
   418 {
   419   EPVMSave save = EPVMLevelSave(epvm, level);
   420 
   421   RingInit(&save->groupRing);
   422   save->epvm = epvm;
   423   save->level = level;
   424   save->size = 0;
   425   save->sig = EPVMSaveSig;
   426   AVERT(EPVMSave, save);
   427 }
   428 
   429 /* EPVMInit -- the pool class initialization method.
   430  * 
   431  *  Takes three additional arguments: the format of the objects
   432  * allocated in the pool, the maximum save level, and the current save
   433  * level.  design.mps.poolams.init.  */
   434   
   435 static Res EPVMInit(Pool pool, va_list arg)
   436 {
   437   EPVM epvm;
   438   void *p;
   439   Res res;
   440   Index i;
   441   mps_epvm_save_level_t maxSaveLevel, saveLevel;
   442 
   443   AVERT(Pool, pool);
   444 
   445   epvm = PoolPoolEPVM(pool);
   446 
   447   epvm->format = va_arg(arg, Format);
   448   AVERT(Format, epvm->format);
   449 
   450   maxSaveLevel = va_arg(arg, mps_epvm_save_level_t);
   451   epvm->maxSaveLevel = maxSaveLevel;
   452   AVER(epvm->maxSaveLevel == maxSaveLevel);
   453   AVER(epvm->maxSaveLevel > 0);
   454 
   455   saveLevel = va_arg(arg, mps_epvm_save_level_t);
   456   epvm->saveLevel = saveLevel;
   457   AVER(epvm->saveLevel == saveLevel);
   458   AVER(epvm->saveLevel < epvm->maxSaveLevel);
   459 
   460   res = ArenaAlloc(&p, PoolArena(pool),
   461                    (Size)(sizeof(EPVMSaveStruct) * epvm->maxSaveLevel));
   462   if (res != ResOK)
   463     return res;
   464   epvm->saves = p;
   465 
   466   for (i=0; i < epvm->maxSaveLevel; i++)
   467     EPVMSaveInit(epvm, i);
   468 
   469   pool->alignment = epvm->format->alignment;
   470   epvm->grainShift = SizeLog2(PoolAlignment(pool));
   471 
   472   ActionInit(EPVMAction(epvm), pool);
   473 
   474   epvm->size = 0;
   475 
   476   epvm->sig = EPVMSig;
   477   AVERT(EPVM, epvm);
   478 
   479   return ResOK;
   480 }
   481 
   482 
   483 /* EPVMSaveDiscard(epvm, level) discards all the groups at that save
   484  * level. */
   485 
   486 static void EPVMSaveDiscard(EPVMSave save)
   487 {
   488   Ring ring, node, next;           /* for iterating over the groups */
   489 
   490   AVERT(EPVMSave, save);
   491   /* destroy all the groups */
   492   ring = &save->groupRing;
   493   node = ring->next;
   494   while(node != ring) {
   495     EPVMGroup group = RING_ELT(EPVMGroup, saveRing, node);
   496     next = node->next;
   497     EPVMGroupDestroy(group);
   498     node = next;
   499   }
   500 
   501   AVER(save->size == 0);
   502 }
   503 
   504 /* EPVMFinish -- the pool class finishing method.
   505  * 
   506  * Destroys all the groups in the pool. Can't invalidate the EPVM until
   507  * we've destroyed all the groups, as it may be checked.
   508  */
   509 
   510 static void EPVMFinish(Pool pool)
   511 {
   512   EPVM epvm;
   513   Index i;
   514 
   515   AVERT(Pool, pool);
   516   epvm = PoolPoolEPVM(pool);
   517   AVERT(EPVM, epvm);
   518 
   519   for (i=0; i < epvm->maxSaveLevel; i++) {
   520     EPVMSave save = EPVMLevelSave(epvm, i);
   521     EPVMSaveDiscard(save);
   522     RingFinish(&save->groupRing);
   523     save->sig = SigInvalid;
   524   }
   525 
   526   ArenaFree(PoolArena(pool), epvm->saves,
   527             (Size)(sizeof(EPVMSaveStruct) * epvm->maxSaveLevel));
   528 
   529   ActionFinish(EPVMAction(epvm));
   530   /* can't invalidate the EPVM until we've destroyed all the groups */
   531   epvm->sig = SigInvalid;
   532 }
   533 
   534 
   535 /* EPVMGroupAlloc -- attempts to allocate an area of at least the given
   536  * size in the given group.
   537  * 
   538  *  If successful, makes that area black and returns the base and
   539  *  limit grain indices of the area.  */
   540 
   541 static Bool EPVMGroupAlloc(Index *baseReturn, Index *limitReturn,
   542                           EPVMGroup group, Size size)
   543 {
   544   EPVM epvm;
   545   Size grains;
   546   Bool b;                       /* can we allocate in this group? */
   547   Index base, limit;
   548 
   549   AVER(baseReturn != NULL);
   550   AVER(limitReturn != NULL);
   551   AVERT(EPVMGroup, group);
   552 
   553   epvm = EPVMGroupEPVM(group);
   554   AVERT(EPVM, epvm);
   555 
   556   AVER(size > 0);
   557   AVER(SizeIsAligned(size, PoolAlignment(EPVMPool(epvm))));
   558 
   559   grains = EPVMGrains(epvm, size);
   560   AVER(grains > 0);
   561   if (grains > group->grains)
   562     return FALSE;
   563 
   564   b = EPVMFindFreeRange(&base, &limit, group, grains);
   565   if (!b)
   566     return FALSE;
   567 
   568   AVER(EPVMRangeIsFree(group, base, limit));
   569   /* design.mps.poolams.invariant.black, */
   570   /* design.mps.poolams.invariant.alloc */
   571   EPVMRangeBlacken(group, base, limit);
   572 
   573   *baseReturn = base;
   574   *limitReturn = limit;
   575   return TRUE;
   576 }
   577 
   578 
   579 /* EPVMBufferFill -- the pool class buffer fill method.
   580  * 
   581  * Iterates over the segments at the current save level looking for
   582  * space. See design.mps.poolams.fill */
   583 
   584 static Res EPVMBufferFill(Seg *segReturn,
   585                          Addr *baseReturn, Addr *limitReturn,
   586                          Pool pool, Buffer buffer, Size size)
   587 {
   588   Res res;
   589   EPVM epvm;
   590   EPVMSave save;
   591   EPVMGroup group;
   592   Seg seg;
   593   Ring node;                    /* for iterating over the segments */
   594   Index base, limit;
   595   RankSet rankSet;
   596   Bool b;                       /* the return value of EPVMGroupAlloc */
   597 
   598   AVER(segReturn != NULL);
   599   AVER(baseReturn != NULL);
   600   AVER(limitReturn != NULL);
   601   AVERT(Buffer, buffer);
   602   AVER(size > 0);
   603 
   604   AVERT(Pool, pool);
   605   epvm = PoolPoolEPVM(pool);
   606   AVERT(EPVM, epvm);
   607   AVER(SizeIsAligned(size, PoolAlignment(pool)));
   608 
   609   save = EPVMCurrentSave(epvm);
   610   AVERT(EPVMSave, save);
   611 
   612   rankSet = BufferRankSet(buffer);
   613 
   614   RING_FOR(node, &save->groupRing) {
   615     group = RING_ELT(EPVMGroup, saveRing, node);
   616     AVERT(EPVMGroup, group);
   617     seg = group->seg;
   618     if (SegBuffer(seg) == NULL &&
   619         SegRankSet(seg) == rankSet) {
   620       b = EPVMGroupAlloc(&base, &limit, group, size);
   621       if (b)
   622         goto found;
   623     }
   624   }
   625 
   626   /* no group has enough room; make a new group */
   627   res = EPVMGroupCreate(&group, save, pool, size, rankSet);
   628   if (res != ResOK)
   629     return res;
   630   b = EPVMGroupAlloc(&base, &limit, group, size);
   631   
   632 found:
   633   AVER(b);
   634   *segReturn = group->seg;
   635   *baseReturn = EPVMIndexAddr(group, base);
   636   *limitReturn = EPVMIndexAddr(group, limit);
   637   return ResOK;
   638 }
   639 
   640 
   641 /* EPVMBufferEmpty -- the pool class buffer empty method
   642  * 
   643  * Checks that the buffer is still black, and frees the unused part of
   644  * the buffer.
   645  */
   646 
   647 static void EPVMBufferEmpty(Pool pool, Buffer buffer)
   648 {
   649   EPVM epvm;
   650   Addr init, limit;
   651   Index initIndex, limitIndex;
   652   Seg seg;
   653   EPVMGroup group;
   654 
   655   AVERT(Pool, pool);
   656   epvm = PoolPoolEPVM(pool);
   657   AVERT(EPVM, epvm);
   658   AVERT(Buffer,buffer);
   659   AVER(!BufferIsReset(buffer));
   660   AVER(BufferIsReady(buffer));
   661   
   662   seg = BufferSeg(buffer);
   663   group = EPVMSegGroup(seg);
   664   AVERT(EPVMGroup, group);
   665   AVER(group->seg == seg);
   666   
   667   init = BufferGetInit(buffer);
   668   limit = BufferLimit(buffer);
   669 
   670   AVER(AddrIsAligned(init, PoolAlignment(pool)));
   671   AVER(AddrIsAligned(limit, PoolAlignment(pool)));
   672 
   673   if (init == limit)
   674     return;
   675 
   676   initIndex = EPVMAddrIndex(group, init);
   677   limitIndex = EPVMAddrIndex(group, limit);
   678 
   679   /* design.mps.poolams.invariant.black */
   680   /* design.mps.poolams.invariant.alloc */
   681   AVER(EPVMRangeIsBlack(group, initIndex, limitIndex));
   682 
   683   /* design.mps.poolams.invariant.empty */
   684   EPVMRangeFree(group, initIndex, limitIndex);
   685 }
   686 
   687 
   688 /* EPVMRangeCondemn -- condemns a part of a group
   689  * 
   690  * Split out of EPVMCondemn because it's used in more than one place.
   691  */
   692 
   693 static void EPVMRangeCondemn(EPVMGroup group, Index base, Index limit)
   694 {
   695   if (base != limit) {
   696     AVER(base < limit);
   697     AVER(limit <= group->grains);
   698     
   699     /* either black or free, see design.mps.poolams.invariant */
   700     AVER(EPVMRangeIsBlackOrFree(group, base, limit));
   701     
   702     EPVMRangeColourCondemn(group, base, limit);
   703   }
   704 }
   705 
   706 
   707 /* EPVMCondemn -- the pool class segment condemning method
   708  * 
   709  * See design.mps.poolams.condemn
   710  */
   711 
   712 static Res EPVMCondemn(Pool pool, Trace trace, Seg seg, Action action)
   713 {
   714   EPVMGroup group;
   715   Buffer buffer;                /* the seg's buffer, if it has one */
   716 
   717   AVERT(Pool, pool);
   718 
   719   AVERT(Trace, trace);
   720   AVER(SegCheck(seg));
   721   AVERT(Action, action);
   722 
   723   group = EPVMSegGroup(seg);
   724   AVERT(EPVMGroup, group);
   725   AVER(group->seg == seg);
   726 
   727   /* design.mps.poolams.one-condemn */
   728   AVER(SegWhite(seg) == TraceSetEMPTY);
   729 
   730   buffer = SegBuffer(seg);
   731   if (buffer != NULL) { /* design.mps.poolams.condemn.buffer */
   732     Index scanLimitIndex, limitIndex;
   733     scanLimitIndex = EPVMAddrIndex(group, BufferScanLimit(buffer));
   734     limitIndex = EPVMAddrIndex(group, BufferLimit(buffer));
   735     
   736     EPVMRangeCondemn(group, 0, scanLimitIndex);
   737     EPVMRangeCondemn(group, limitIndex, group->grains);
   738   } else { /* condemn whole seg */
   739     EPVMRangeCondemn(group, 0, group->grains);
   740   }
   741 
   742   group->marked = FALSE; /* design.mps.poolams.marked.condemn */
   743 
   744   /* design.mps.poolams.condemn.white */
   745   SegSetWhite(seg, TraceSetAdd(SegWhite(seg), trace->ti));
   746 
   747   return ResOK;
   748 }
   749 
   750 
   751 /* EPVMGrainFunction is the type of the function which EPVMIterate
   752  * applies to each live grain in a group.
   753  * 
   754  * See design.mps.poolepvm.low.iterate
   755  */
   756 
   757 typedef Res
   758 (*EPVMGrainFunction)(EPVMGroup group, /* the group */
   759                      Index i,         /* the grain index */
   760                      void *closure);  /* the iteration closure */
   761 
   762 
   763 /* EPVMIterate -- applies a function to each allocated grain in a group
   764  * 
   765  * EPVMIterate (group, f, closure) applies f to all the
   766  * allocated grains in the group. See design.mps.poolepvm.low.iterate
   767  */
   768 
   769 static Res EPVMIterate(EPVMGroup group,
   770                        EPVMGrainFunction f,
   771                        void *closure)
   772 {
   773   Res res;
   774   Index i = 0;
   775   Seg seg = group->seg;
   776   
   777   while (i < group->grains) {
   778     Buffer buffer = SegBuffer(seg);
   779 
   780     if ((buffer != NULL) &&
   781         (i == EPVMBufferScanLimIndex(group, buffer)) &&
   782         (i < EPVMBufferLimitIndex(group, buffer))) {
   783         i = EPVMBufferLimitIndex(group, buffer);
   784     } else {
   785       /* not in the buffer */
   786       AVER((buffer == NULL) ||
   787            (i < EPVMBufferScanLimIndex(group, buffer)) ||
   788            (i >= EPVMBufferLimitIndex(group, buffer)));
   789 
   790       if (EPVMAlloced(group, i)) { /* there is an object here */
   791         res = (*f)(group, i, closure);
   792         if (res != ResOK)
   793           return res;
   794       }
   795       ++ i;
   796     }
   797   }
   798   AVER(i == group->grains);
   799   return ResOK;
   800 }
   801 
   802 
   803 /* EPVMBlackenObject -- blacken a single object (if it is grey).
   804  * 
   805  * This is the object function passed to EPVMIterate by EPVMBlacken.
   806  * It just blackens the object if it is grey. It takes no closure.
   807  */
   808 
   809 static Res EPVMBlackenObject(EPVMGroup group,
   810                             Index i, void *clos)
   811 {
   812   AVERT(EPVMGroup, group);
   813   AVER(i < group->grains);
   814   AVER(clos == NULL);
   815 
   816   /* if the object is grey, make it black */
   817   if (EPVMIsGrey(group, i))
   818     EPVMGreyBlacken(group, i);
   819 
   820   return ResOK;
   821 }
   822 
   823 /* EPVMBlacken -- the pool class segment blackening method
   824  *
   825  * See design.mps.poolams.blacken
   826  */
   827 
   828 static void EPVMBlacken(Pool pool, TraceSet traceSet, Seg seg)
   829 {
   830   AVERT(Pool, pool);
   831   AVER(TraceSetCheck(traceSet));
   832   AVER(SegCheck(seg));
   833 
   834   /* only do anything if the bitmaps apply to one of these traces. */
   835   /* see design.mps.poolams.invariant.object */
   836   if (TraceSetInter(SegWhite(seg), traceSet) != TraceSetEMPTY) {
   837     EPVMGroup group = EPVMSegGroup(seg);
   838     Res res;
   839 
   840     AVERT(EPVMGroup, group);
   841 
   842     res = EPVMIterate(group, EPVMBlackenObject, NULL);
   843     AVER(res == ResOK); /* EPVMBlackenObject always returns ResOK */
   844 
   845     group->marked = FALSE; /* design.mps.poolams.blacken.marked */
   846   }
   847 }
   848 
   849 /* The closure of the object scanning function */
   850 
   851 struct EPVMScanClosureStruct {
   852   ScanState ss;
   853   Bool scanAllObjects; /* scan non-grey objects? */
   854 };
   855 
   856 typedef struct EPVMScanClosureStruct *EPVMScanClosure;
   857 
   858 
   859 /* EPVMScanObject -- scan a single object
   860  * 
   861  * This is the object function passed to EPVMIterate by EPVMScan.
   862  */
   863 
   864 static Res EPVMScanObject(EPVMGroup group,
   865                          Index i, void *clos)
   866 {
   867   Format format;
   868   EPVMScanClosure closure;
   869   Bool grey;
   870 
   871   AVERT(EPVMGroup, group);
   872   AVER(i < group->grains);
   873 
   874   /* check the closure */
   875   AVER(clos != NULL);
   876   closure = clos;
   877   AVERT(ScanState, closure->ss);
   878   AVER(BoolCheck(closure->scanAllObjects));
   879 
   880   format = EPVMGroupEPVM(group)->format;
   881   AVERT(Format, format);
   882 
   883   grey = EPVMIsGrey(group, i);
   884   
   885   if (grey || closure->scanAllObjects) {     /* scan the grain */
   886     Addr p = EPVMIndexAddr(group, i);
   887     Addr q = AddrAdd(p, format->alignment);
   888     Res res = (*format->scan)(closure->ss, p, q);
   889     if (res != ResOK)
   890       return res;
   891   }
   892 
   893   if (grey) /* blacken the grain */
   894     EPVMGreyBlacken(group, i);
   895 
   896   return ResOK;
   897 }
   898 
   899 
   900 /* EPVMScan -- the pool class segment scanning method
   901  *
   902  * See design.mps.poolams.scan
   903  */
   904 
   905 static Res EPVMScan(ScanState ss, Pool pool, Seg seg)
   906 {
   907   Res res;
   908   EPVMGroup group;
   909   struct EPVMScanClosureStruct closureStruct;
   910 
   911   AVERT(ScanState, ss);
   912   AVERT(Pool, pool);
   913   AVER(SegCheck(seg));
   914   group = EPVMSegGroup(seg);
   915   AVERT(EPVMGroup, group);
   916 
   917   /* design.mps.poolams.scan.all */
   918   closureStruct.scanAllObjects =
   919     (TraceSetDiff(ss->traces, SegWhite(seg)) != TraceSetEMPTY);
   920   closureStruct.ss = ss;
   921 
   922   if (closureStruct.scanAllObjects) { /* design.mps.poolams.scan.all */
   923 
   924     res = EPVMIterate(group, EPVMScanObject, &closureStruct);
   925     if (res != ResOK)
   926       return res;
   927     group->marked = FALSE;
   928     
   929   } else { /* design.mps.poolams.scan.iter */
   930 
   931     AVER(group->marked); /* we're only scanning if something is grey */
   932     do { /* design.mps.poolams.marked.scan */
   933       group->marked = FALSE; 
   934       res = EPVMIterate(group, EPVMScanObject, &closureStruct);
   935       if (res != ResOK) {
   936         group->marked = TRUE; /* design.mps.poolams.marked.scan.fail */
   937         return res;
   938       }
   939     } while(group->marked);
   940 
   941   }
   942 
   943   /* If the scanner didn't scan all the objects then the */
   944   /* summary of the unscanned objects must be added into the scan */
   945   /* state summary, so that it's a valid summary of the entire */
   946   /* segment on return.  See design.mps.poolams.summary.scan.part. */
   947   if(!closureStruct.scanAllObjects)
   948     ScanStateSetSummary(ss, RefSetUnion(ScanStateSummary(ss),
   949                                         SegSummary(seg)));
   950 
   951   return ResOK;
   952 }
   953 
   954 
   955 /* EPVMFix -- the pool class fixing method */
   956 
   957 static Res EPVMFix(Pool pool, ScanState ss, Seg seg, Ref *refIO)
   958 {
   959   EPVMGroup group;
   960   Index i;                      /* the index of the fixed grain */
   961   Ref ref;
   962   Bool alloc;                   /* is this grain allocated? */
   963 
   964   AVERT(Pool, pool);
   965   AVERT(ScanState, ss);
   966   AVER(SegCheck(seg));
   967   AVER(refIO != NULL);
   968   group = EPVMSegGroup(seg);
   969   AVERT(EPVMGroup, group);
   970   
   971   ref = *refIO;
   972   i = EPVMAddrIndex(group, ref);
   973   alloc = EPVMAlloced(group, i);
   974   
   975   ss->wasMarked = TRUE;
   976 
   977   switch (ss->rank) {
   978   case RankAMBIG:
   979     /* not a real pointer if not allocated or not aligned */
   980     if((!alloc) || !AddrIsAligned((Addr)ref, PoolAlignment(pool)))
   981       break;
   982 
   983     /* falls through */
   984   case RankEXACT:
   985   case RankFINAL:
   986   case RankWEAK:
   987     /* a real reference must be both allocated and aligned */
   988     AVER(alloc);
   989     AVER(AddrIsAligned((Addr)ref, PoolAlignment(pool)));
   990     if(!EPVMMarked(group, i)) {
   991       ss->wasMarked = FALSE;
   992       if(ss->rank == RankWEAK) { /* then splat the reference */
   993         *refIO = (Ref)0;
   994       } else {
   995         /* turn this grain grey */
   996         EPVMWhiteGrey(group, i);
   997         /* turn this segment grey */
   998         SegSetGrey(seg, TraceSetUnion(SegGrey(seg), ss->traces));
   999         /* mark it for scanning - design.mps.poolams.marked.fix */
  1000         group->marked = TRUE;
  1001       }
  1002     }
  1003     break;
  1004   default:
  1005     NOTREACHED;
  1006   }
  1007 
  1008   return ResOK;
  1009 }
  1010 
  1011 
  1012 /* EPVMReclaimObject -- inspect a single object for reclamation
  1013  * 
  1014  * This is the object function passed to EPVMIterate by EPVMReclaim.
  1015  */
  1016 
  1017 static Res EPVMReclaimObject(EPVMGroup group,
  1018                             Index i, void *clos)
  1019 {
  1020   Bool *anySurvivorsP;      /* update to true if the object survives */
  1021   Bool marked, scanned;
  1022 
  1023   AVERT(EPVMGroup, group);
  1024   AVER(i < group->grains);
  1025 
  1026   /* check closure */
  1027   AVER(clos != NULL);
  1028   anySurvivorsP = clos;
  1029   AVER(BoolCheck(*anySurvivorsP));
  1030 
  1031   marked = EPVMMarked(group, i);
  1032   scanned = EPVMScanned(group, i);
  1033 
  1034   AVER(!EPVMIsGrey(group, i)); /* no grey objects now */
  1035   
  1036   if (!marked && !scanned) { /* then we can free it */
  1037     /* design.mps.poolams.invariant.free */
  1038     EPVMWhiteFree(group, i);
  1039   } else { /* the object survived collection */
  1040     AVER(marked && scanned);
  1041     *anySurvivorsP = TRUE;
  1042   }
  1043   return ResOK;
  1044 }
  1045 
  1046 
  1047 
  1048 /* EPVMReclaim -- the pool class reclamation method */
  1049 
  1050 static void EPVMReclaim(Pool pool, Trace trace, Seg seg)
  1051 {
  1052   EPVMGroup group;
  1053   Res res;
  1054   Bool anySurvivors;            /* did anything survive */
  1055 
  1056   AVERT(Pool, pool);
  1057   AVERT(Seg, seg);
  1058 
  1059   group = EPVMSegGroup(seg);
  1060 
  1061   AVER(group->marked == FALSE); /* design.mps.poolams.marked.reclaim */
  1062 
  1063   anySurvivors = FALSE;
  1064 
  1065   res = EPVMIterate(group, EPVMReclaimObject, &anySurvivors);
  1066   AVER(res == ResOK); /* EPVMReclaimObject always returns ResOK */
  1067 
  1068   if ((SegBuffer(seg) == NULL) && !anySurvivors)
  1069      /* design.mps.poolams.reclaim.empty */
  1070     EPVMGroupDestroy(group);
  1071   else
  1072     /* design.mps.poolams.reclaim.unwhite */
  1073     SegSetWhite(seg, TraceSetDel(SegWhite(seg), trace->ti));
  1074 }
  1075 
  1076 /* EPVMBenefit -- the pool class benefit computation method.
  1077  *
  1078  * GCs are initiated manually by mps_epvm_collect. We never want the
  1079  * space poll to initiate a GC, so we always return 0.0 here. */
  1080 
  1081 static double EPVMBenefit(Pool pool, Action action)
  1082 {
  1083   EPVM epvm;
  1084 
  1085   AVERT(Pool, pool);
  1086   epvm = PoolPoolEPVM(pool);
  1087   AVERT(EPVM, epvm);
  1088   AVERT(Action, action);
  1089   AVER(epvm == ActionEPVM(action));
  1090   
  1091   return 0.0;
  1092 }
  1093 
  1094 
  1095 /* the different colours of grains. Only used for description. 
  1096  * design.mps.poolepvm.low.describe */
  1097 
  1098 enum {
  1099   EPVM_WHITE,
  1100   EPVM_GREY,
  1101   EPVM_BLACK,
  1102   EPVM_FREE,
  1103   EPVM_ILLEGAL
  1104 };
  1105 
  1106 /* EPVMGrainColour -- find the colour of a single grain.
  1107  * 
  1108  * See design.mps.poolams.invariant
  1109  * This is only used when describing the pool; in general this class
  1110  * uses macros like EPVMIsGrey, which go faster. See also
  1111  * design.mps.poolepvm.low.describe.
  1112  */
  1113 
  1114 static int EPVMGrainColour(EPVMGroup group, Index index)
  1115 {
  1116   Bool mark, scan, alloc;
  1117 
  1118   /* don't check the group, as EPVMGroupCheck calls this */
  1119   AVER(index < group->grains);
  1120 
  1121   mark = EPVMMarked(group, index);
  1122   scan = EPVMScanned(group, index);
  1123   alloc = EPVMAlloced(group, index);
  1124   
  1125   if (mark) {     /* mark */
  1126     if (scan) {   /* mark, scan */
  1127       if (alloc)
  1128         return EPVM_BLACK;       /*  mark,  scan,  alloc: black */
  1129       else
  1130         return EPVM_ILLEGAL;
  1131     } else {      /* mark, !scan */
  1132       if (alloc)
  1133         return EPVM_GREY;        /*  mark, !scan,  alloc: grey */
  1134       else
  1135         return EPVM_ILLEGAL;
  1136     } 
  1137   } else {        /* !mark */
  1138     if (scan) {   /* !mark, scan */
  1139       if (alloc)
  1140         return EPVM_ILLEGAL;
  1141       else
  1142         return EPVM_FREE;        /* !mark,  scan, !alloc: free */
  1143     } else {      /* !mark, !scan */
  1144       if (alloc)
  1145         return EPVM_WHITE;       /*  mark, !scan,  alloc: white */
  1146       else
  1147         return EPVM_ILLEGAL;
  1148     }
  1149   }
  1150 }
  1151 
  1152 /* EPVMGroupDescribe -- describe an EPVM group. */
  1153 
  1154 static Res EPVMGroupDescribe(EPVM epvm, EPVMGroup group,
  1155                              mps_lib_FILE *stream)
  1156 {
  1157   Res res;
  1158   Seg seg;
  1159   Buffer buffer;               /* the segment's buffer, if it has one */
  1160   Index i;
  1161 
  1162   AVERT(EPVM, epvm);
  1163   AVERT(EPVMGroup, group);
  1164   seg = group->seg;
  1165   AVER(SegCheck(seg));
  1166   AVER(EPVMGroupEPVM(group) == epvm);
  1167   /* can't check stream, as there are no conditions on mps_lib_FILE * */
  1168 
  1169   buffer = SegBuffer(seg);
  1170 
  1171   if (buffer != NULL)
  1172     AVERT(Buffer, buffer);
  1173 
  1174   res = WriteF(stream,
  1175                "EPVM Group $P {\n", (WriteFP)group,
  1176                "  seg $P [$A,$A)\n",
  1177                (WriteFP)seg,
  1178                EPVMGroupBase(group), EPVMGroupLimit(group),
  1179                "  EPVM $P\n", (WriteFP)epvm,
  1180                "  grains $W\n", (WriteFW)group->grains,
  1181                "  tables: alloc $P, mark $P, scan $P\n",
  1182                  (WriteFP)group->allocTable,
  1183                  (WriteFP)group->markTable,
  1184                  (WriteFP)group->scanTable,
  1185                "  map: \n",
  1186                NULL);
  1187                
  1188   for (i=0 ; i < group->grains; ++ i) {
  1189     int colour;
  1190     char c = 0;
  1191     if (i % 64 == 0) {
  1192       res = WriteF(stream, "\n  ", NULL);
  1193       if (res != ResOK)
  1194         return res;
  1195     }
  1196     if (buffer != NULL) {
  1197       Index baseIndex = EPVMAddrIndex(group, BufferBase(buffer));
  1198       Index limitIndex = EPVMAddrIndex(group, BufferLimit(buffer));
  1199       Index scanLimIndex = EPVMAddrIndex(group,BufferScanLimit(buffer));
  1200       Index initIndex = EPVMAddrIndex(group, BufferGetInit(buffer));
  1201       Index allocIndex = EPVMAddrIndex(group, BufferAlloc(buffer));
  1202 
  1203       if (i == limitIndex)
  1204         c = ']';
  1205       else if (i == baseIndex)
  1206         c = '[';
  1207       else if (i == scanLimIndex)
  1208         c = '<';
  1209       else if (i == initIndex)
  1210         c = '|';
  1211       else if (i == allocIndex)
  1212         c = '>';
  1213 
  1214       if (c != 0) {
  1215         res = WriteF(stream, "$C", c, NULL);
  1216         if (res != ResOK)
  1217           return res;
  1218       }
  1219     }
  1220 
  1221     colour = EPVMGrainColour(group, i);
  1222     switch(colour) {
  1223     case EPVM_FREE:
  1224       c = '.';
  1225       break;
  1226     case EPVM_WHITE:
  1227       c = '-';
  1228       break;
  1229     case EPVM_GREY:
  1230       c = '+';
  1231       break;
  1232     case EPVM_BLACK:
  1233       c = '*';
  1234       break;
  1235     case EPVM_ILLEGAL: /* maybe we're in the middle of debugging */
  1236       c = '!';
  1237       break;
  1238     default:
  1239       NOTREACHED;
  1240     }
  1241     res = WriteF(stream, "$C", c, NULL);
  1242     if (res != ResOK)
  1243       return res;
  1244   }
  1245 
  1246   res = WriteF(stream, "\n} EPVM Group $P\n", (WriteFP)group);
  1247   if (res != ResOK)
  1248     return res;
  1249 
  1250   return ResOK;
  1251 }
  1252 
  1253 
  1254 /* EPVMDescribe -- the pool class description method.
  1255  * 
  1256  * Iterates over the segments, describing all of them.
  1257  */
  1258 
  1259 static Res EPVMDescribe(Pool pool, mps_lib_FILE *stream)
  1260 {
  1261   EPVM epvm;
  1262   Ring node;
  1263   Res res;
  1264   Index i;
  1265 
  1266   AVERT(Pool, pool);
  1267   epvm = PoolPoolEPVM(pool);
  1268   AVERT(EPVM, epvm);
  1269   /* can't check stream, as there are no conditions on mps_lib_FILE * */
  1270 
  1271   res = WriteF(stream,
  1272                "EPVM $P {\n", (WriteFP)epvm,
  1273                "  pool $P ($U)\n",
  1274                (WriteFP)pool, (WriteFU)pool->serial,
  1275                "  size $W\n",
  1276                (WriteFW)epvm->size,
  1277                "  format $P ($U)\n",
  1278                (WriteFP)epvm->format, (WriteFU)epvm->format->serial,
  1279                "  grain shift $U\n", (WriteFU)epvm->grainShift,
  1280                "  action $P ($U)\n",
  1281                (WriteFP)EPVMAction(epvm),
  1282                (WriteFU)EPVMAction(epvm)->serial,
  1283                "  save level $U (max $U)\n",
  1284                (WriteFU)epvm->saveLevel, (WriteFU)epvm->maxSaveLevel,
  1285                NULL);
  1286   if (res != ResOK)
  1287     return res;
  1288 
  1289   res = WriteF(stream,
  1290                "  saves and segments\n"
  1291                "  [* = black, + = grey, - = white, . = free, ! = bad,\n"
  1292                "  buffers: [ = base, < = scan limit, | = init,\n"
  1293                "           > = alloc, ] = limit\n",
  1294                NULL);
  1295   if (res != ResOK)
  1296     return res;
  1297 
  1298   for(i=0; i < epvm->maxSaveLevel; i++) {
  1299     EPVMSave save = EPVMLevelSave(epvm, i);
  1300     AVERT(EPVMSave, save);
  1301     res = WriteF(stream,
  1302                  "  level $U:\n",
  1303                  save->level,
  1304                  "    size $U\n",
  1305                  save->size,
  1306                  "    segments:\n",
  1307                  NULL);
  1308     if (res != ResOK)
  1309       return res;
  1310     RING_FOR(node, &save->groupRing) {
  1311       EPVMGroup group = RING_ELT(EPVMGroup, saveRing, node);
  1312       EPVMGroupDescribe(epvm, group, stream);
  1313     }
  1314   }
  1315 
  1316   res = WriteF(stream, "} EPVM $P\n",(WriteFP)epvm, NULL);
  1317   if (res != ResOK)
  1318     return res;
  1319 
  1320   return ResOK;
  1321 }
  1322 
  1323 
  1324 /* PoolClassEPVMStruct -- the pool class descriptor */
  1325 
  1326 static PoolClassStruct PoolClassEPVMStruct = {
  1327   PoolClassSig,
  1328   "EPVM",                     /* name */
  1329   sizeof(EPVMStruct),         /* size */
  1330   offsetof(EPVMStruct, poolStruct),      /* offset */
  1331   AttrFMT | AttrSCAN | AttrBUF | AttrBUF_RESERVE | AttrGC | AttrINCR_RB,
  1332   EPVMInit,                  /* init */
  1333   EPVMFinish,                /* finish */
  1334   PoolNoAlloc,               /* design.mps.poolams.no-alloc */
  1335   PoolNoFree,                /* design.mps.poolams.no-free */
  1336   PoolTrivBufferInit,        /* design.mps.poolams.triv-buffer-init */
  1337   EPVMBufferFill,            /* bufferFill */
  1338   EPVMBufferEmpty,           /* bufferEmpty */
  1339   PoolTrivBufferFinish,      /* design.mps.poolams.triv-buffer-finish */
  1340   PoolTrivTraceBegin,        /* design.mps.poolams.triv-trace-begin */
  1341   EPVMCondemn,               /* condemn */
  1342   PoolTrivGrey,              /* design.mps.poolams.triv-grey */
  1343   EPVMBlacken,               /* blacken */
  1344   EPVMScan,                  /* scan */
  1345   EPVMFix,                   /* fix */
  1346   EPVMReclaim,               /* reclaim */
  1347   PoolTrivTraceEnd,          /* design.mps.poolams.triv-trace-end */
  1348   EPVMBenefit,               /* benefit */
  1349   EPVMDescribe,              /* describe */
  1350   PoolClassSig               /* impl.h.mpm.class.end-sig */
  1351 };
  1352 
  1353 
  1354 /* EPVMCheck -- the check method for an EPVM */
  1355 
  1356 static Bool EPVMCheck(EPVM epvm)
  1357 {
  1358   Index i;
  1359   Size size;
  1360 
  1361   CHECKS(EPVM, epvm);
  1362   CHECKD(Pool, EPVMPool(epvm));
  1363   CHECKL(EPVMPool(epvm)->class == &PoolClassEPVMStruct);
  1364   CHECKD(Format, epvm->format);
  1365   CHECKL((PoolAlignment(EPVMPool(epvm)) >> epvm->grainShift) == 1);
  1366   CHECKL(PoolAlignment(EPVMPool(epvm)) == epvm->format->alignment);
  1367   CHECKD(Action, EPVMAction(epvm));
  1368   CHECKL(EPVMAction(epvm)->pool == EPVMPool(epvm));
  1369   CHECKL(SizeIsAligned(epvm->size, ArenaAlign(EPVMArena(epvm))));
  1370   CHECKL(epvm->saveLevel < epvm->maxSaveLevel);
  1371   CHECKL(epvm->saves != NULL);
  1372 
  1373   /* design.mps.poolepvm.low.size */
  1374   size = 0;
  1375   for (i=0; i < epvm->maxSaveLevel; i++) {
  1376     EPVMSave save = EPVMLevelSave(epvm, i);
  1377     CHECKD(EPVMSave, save);
  1378     CHECKL(save->level == i);
  1379     size += save->size;
  1380   }
  1381   CHECKL(size == epvm->size);
  1382 
  1383   return TRUE;
  1384 }
  1385 
  1386 
  1387 /* mps_class_epvm -- return the pool class descriptor to the client */
  1388 
  1389 mps_class_t mps_class_epvm(void)
  1390 {
  1391   return (mps_class_t)&PoolClassEPVMStruct;
  1392 }
  1393 
  1394 
  1395 /* mps_epvm_check: check a given pointer.
  1396  * 
  1397  * design.mps.poolepvm.low.check.
  1398  */
  1399 
  1400 mps_bool_t mps_epvm_check(mps_pool_t *mps_pool_o,
  1401                           mps_epvm_save_level_t *mps_level_o,
  1402                           mps_arena_t mps_arena,
  1403                           mps_addr_t mps_addr)
  1404 {
  1405   Index level;
  1406   Pool pool;
  1407   EPVMGroup group;
  1408   Seg seg;
  1409   Bool b;
  1410   Addr a;
  1411   
  1412   Arena arena = (Arena)mps_arena;
  1413   ArenaEnter(arena);
  1414   
  1415   AVER(mps_pool_o != NULL);
  1416   AVER(mps_level_o != NULL);
  1417   AVER(mps_addr != NULL);
  1418 
  1419   a = mps_addr;
  1420   b = SegOfAddr(&seg, arena, a);
  1421   if (b == FALSE)
  1422     goto returnFalse;
  1423   
  1424   pool = SegPool(seg);
  1425   if (pool->class != &PoolClassEPVMStruct)
  1426     goto returnFalse;
  1427 
  1428   group = EPVMSegGroup(seg);
  1429   AVERT(EPVMGroup, group);
  1430   level = group->save->level;
  1431   *mps_pool_o = (mps_pool_t)pool;
  1432   *mps_level_o = (mps_epvm_save_level_t)level;
  1433   ArenaLeave(arena);
  1434   return TRUE;
  1435 
  1436 returnFalse:
  1437   ArenaLeave(arena);
  1438   return FALSE;
  1439 }
  1440 
  1441 
  1442 /* mps_epvm_save -- increment the save level */
  1443 
  1444 void mps_epvm_save(mps_pool_t mps_pool)
  1445 {
  1446   Pool pool = (Pool)mps_pool;
  1447   EPVM epvm;
  1448   EPVMSave save;
  1449   Ring node;
  1450   Arena arena;
  1451 
  1452   AVER(CHECKT(Pool, pool));
  1453   arena = PoolArena(pool);
  1454   ArenaEnter(arena);
  1455 
  1456   AVERT(Pool, pool);
  1457   AVER(pool->class == &PoolClassEPVMStruct);
  1458   epvm = PoolPoolEPVM(pool);
  1459   AVERT(EPVM, epvm);
  1460 
  1461   /* detach any buffers */
  1462   save = EPVMCurrentSave(epvm);
  1463   RING_FOR(node, &save->groupRing) {
  1464     EPVMGroup group = RING_ELT(EPVMGroup, saveRing, node);
  1465     Buffer buffer = SegBuffer(group->seg);
  1466     if (buffer != NULL)
  1467       BufferDetach(buffer, pool);
  1468   }
  1469 
  1470   ++ epvm->saveLevel;
  1471   AVER(epvm->saveLevel < epvm->maxSaveLevel);
  1472   ArenaLeave(arena);
  1473 }
  1474 
  1475 /* mps_epvm_restore -- return to an earlier save level and discard the
  1476  * more recent levels.
  1477  */
  1478 
  1479 void mps_epvm_restore(mps_pool_t mps_pool,
  1480                       mps_epvm_save_level_t mps_level)
  1481 {
  1482   Pool pool = (Pool)mps_pool;
  1483   EPVM epvm;
  1484   Arena arena;
  1485   Index level = (Index) mps_level;
  1486   Index i;
  1487 
  1488   AVER(CHECKT(Pool, pool));
  1489   arena = PoolArena(pool);
  1490   ArenaEnter(arena);
  1491 
  1492   AVERT(Pool, pool);
  1493   AVER(pool->class == &PoolClassEPVMStruct);
  1494   AVER(level == mps_level);
  1495   epvm = PoolPoolEPVM(pool);
  1496   AVERT(EPVM, epvm);
  1497   AVER(level < epvm->saveLevel);
  1498 
  1499   i = level+1;
  1500   while(i <= epvm->saveLevel) {
  1501     EPVMSaveDiscard(EPVMLevelSave(epvm, i));
  1502     ++ i;
  1503   }
  1504   epvm->saveLevel = level;
  1505   ArenaLeave(arena);
  1506 }
  1507 
  1508 
  1509 /* mps_epvm_size -- return the total segment size of the pool */
  1510 
  1511 size_t mps_epvm_size(mps_pool_t mps_pool)
  1512 {
  1513   Pool pool = (Pool)mps_pool;
  1514   EPVM epvm;
  1515   Arena arena;
  1516   size_t size;
  1517 
  1518   AVER(CHECKT(Pool, pool));
  1519   arena = PoolArena(pool);
  1520   ArenaEnter(arena);
  1521 
  1522   AVERT(Pool, pool);
  1523   AVER(pool->class == &PoolClassEPVMStruct);
  1524   epvm = PoolPoolEPVM(pool);
  1525   AVERT(EPVM, epvm);
  1526   size = epvm->size;
  1527   AVER(size == epvm->size);
  1528 
  1529   ArenaLeave(arena);
  1530 
  1531   return size;
  1532 }
  1533 
  1534 
  1535 /* mps_epvm_collect -- collect a pool
  1536  *
  1537  * design.mps.poolepvm.low.collect.
  1538  */
  1539 
  1540 mps_res_t mps_epvm_collect(mps_pool_t mps_pool)
  1541 {
  1542   Res res;
  1543   Pool pool = (Pool)mps_pool;
  1544   EPVM epvm;
  1545   Arena arena;
  1546   Trace trace;
  1547 
  1548   AVER(CHECKT(Pool, pool));
  1549   arena = PoolArena(pool);
  1550   ArenaEnter(arena);
  1551 
  1552   AVERT(Pool, pool);
  1553   AVER(pool->class == &PoolClassEPVMStruct);
  1554   epvm = PoolPoolEPVM(pool);
  1555   AVERT(EPVM, epvm);
  1556 
  1557   TraceCreate(&trace, arena, &epvm->actionStruct);
  1558   
  1559   while(trace->state != TraceFINISHED) {
  1560     res = TracePoll(trace);
  1561     AVER(res == ResOK);
  1562   }
  1563 
  1564   TraceDestroy(trace);
  1565 
  1566   ArenaLeave(arena);
  1567   return MPS_RES_OK;
  1568 }

