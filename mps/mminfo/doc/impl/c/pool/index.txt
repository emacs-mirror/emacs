                          POOL IMPLEMENTATION
                              impl.c.pool
                              accepted doc
                           gavinm 1996-07-30

     1 /* impl.c.pool: POOL IMPLEMENTATION
     2  *
     3  * $HopeName: MMsrc!pool.c(trunk.14) $
     4  * Copyright (C) 1994,1995,1996 Harlequin Group, all rights reserved
     5  *
     6  * This is the implementation of the generic pool interface.  The
     7  * functions here dispatch to pool-specific methods.
     8  */
     9 
    10 #include "mpm.h"
    11 
    12 SRCID(pool, "$HopeName: MMsrc!pool.c(trunk.14) $");
    13 
    14 
    15 Bool PoolClassCheck(PoolClass class)
    16 {
    17   CHECKS(PoolClass, class);
    18   CHECKL(class->name != NULL);
    19   CHECKL(class->size >= sizeof(PoolStruct));
    20   CHECKL(class->offset <= (size_t)(class->size - sizeof(PoolStruct)));
    21   CHECKL(class->init != NULL);
    22   CHECKL(class->finish != NULL);
    23   CHECKL(class->alloc != NULL);
    24   CHECKL(class->free != NULL);
    25   CHECKL(class->bufferInit != NULL);
    26   CHECKL(class->bufferFinish != NULL);
    27   CHECKL(class->bufferFill != NULL);
    28   CHECKL(class->bufferTrip != NULL);
    29   CHECKL(class->bufferExpose != NULL);
    30   CHECKL(class->bufferCover != NULL);
    31   CHECKL(class->condemn != NULL);
    32   CHECKL(class->grey != NULL);
    33   CHECKL(class->scan != NULL);
    34   CHECKL(class->fix != NULL);
    35   CHECKL(class->reclaim != NULL);
    36   CHECKL(class->access != NULL);
    37   CHECKL(class->describe != NULL);
    38   CHECKL(class->endSig == PoolClassSig);
    39   return TRUE;
    40 }
    41 
    42 Bool PoolCheck(Pool pool)
    43 {
    44   CHECKS(Pool, pool);
    45   CHECKU(Space, pool->space);
    46   CHECKL(pool->serial < pool->space->poolSerial);
    47   CHECKD(PoolClass, pool->class);
    48   CHECKL(RingCheck(&pool->spaceRing));
    49   CHECKL(RingCheck(&pool->bufferRing));
    50   CHECKL(AlignCheck(pool->alignment));
    51   return TRUE;
    52 }
    53 
    54 
    55 /* PoolInitV -- initialize a pool
    56  *
    57  * Initialize the generic fields of the pool.  The pool gets the
    58  * default alignment initially.
    59  */
    60 
    61 Res PoolInit(Pool pool, Space space, PoolClass class, ...)
    62 {
    63   Res res;
    64   va_list args;
    65   va_start(args, class);
    66   res = PoolInitV(pool, space, class, args);
    67   va_end(args);
    68   return res;
    69 }
    70 
    71 Res PoolInitV(Pool pool, Space space, PoolClass class, va_list args)
    72 {
    73   Res res;
    74 
    75   AVER(pool != NULL);
    76   AVERT(Space, space);
    77 
    78   pool->class = class;
    79   pool->space = space;
    80   RingInit(&pool->spaceRing);
    81   RingInit(&pool->bufferRing);
    82   pool->alignment = ARCH_ALIGN;
    83 
    84   pool->sig = PoolSig;
    85   pool->serial = space->poolSerial;
    86   ++space->poolSerial;
    87 
    88   AVERT(Pool, pool);
    89 
    90   /* Do class-specific initialization. */
    91   res = (*class->init)(pool, args);
    92   if(res != ResOK)
    93     goto failInit;
    94 
    95   RingAppend(SpacePoolRing(space), &pool->spaceRing);
    96   return ResOK;
    97 
    98 failInit:
    99   pool->sig = SigInvalid;
   100   RingFinish(&pool->bufferRing);
   101   RingFinish(&pool->spaceRing);
   102   return res;
   103 }
   104 
   105 
   106 Res PoolCreate(Pool *poolReturn, PoolClass class, Space space, ...)
   107 {
   108   Res res;
   109   va_list arg;
   110   va_start(arg, space);
   111   res = PoolCreateV(poolReturn, class, space, arg);
   112   va_end(arg);
   113   return res;
   114 }
   115 
   116 Res PoolCreateV(Pool *poolReturn, PoolClass class,
   117                   Space space, va_list arg)
   118 {
   119   Res res;
   120   Pool pool;
   121   Addr base;
   122 
   123   AVER(poolReturn != NULL);
   124   AVERT(Space, space);
   125 
   126   /* Allocate the pool instance structure with the size requested */
   127   /* in the pool class. */
   128   res = SpaceAlloc(&base, space, class->size);
   129   if(res != ResOK) return res;
   130 
   131   /* Calculate the adress of the generic pool structure within the */
   132   /* instance by using the offset information from the class. */
   133   pool = (Pool)AddrAdd(base, class->offset);
   134 
   135   /* Initialize the pool. */  
   136   res = PoolInitV(pool, space, class, arg);
   137   if(res != ResOK) {
   138     SpaceFree(space, base, class->size);
   139     return res;
   140   }
   141   
   142   *poolReturn = pool;  
   143   return ResOK;
   144 }
   145 
   146 
   147 void PoolFinish(Pool pool)
   148 {
   149   PoolClass class;
   150 
   151   AVERT(Pool, pool);  
   152   
   153   class = pool->class;
   154 
   155   /* Do any class-specific finishing. */
   156   (*class->finish)(pool);
   157   
   158   /* Detach the pool from the space, and unsig it. */
   159   RingRemove(&pool->spaceRing);
   160   pool->sig = SigInvalid;
   161   
   162   /* Finish the generic fields. */
   163   RingFinish(&pool->bufferRing);
   164   RingFinish(&pool->spaceRing);
   165 }
   166 
   167 void PoolDestroy(Pool pool)
   168 {
   169   PoolClass class;
   170   Space space;
   171   Addr base;
   172 
   173   AVERT(Pool, pool);  
   174   
   175   class = pool->class;
   176   space = pool->space;
   177 
   178   /* Finish the pool instance structure. */
   179   PoolFinish(pool);
   180 
   181   /* Free the pool instance structure. */
   182   base = AddrSub((Addr)pool, class->offset);
   183   SpaceFree(space, base, class->size);
   184 }
   185 
   186 
   187 Res (PoolAlloc)(Addr *pReturn, Pool pool, Size size)
   188 {
   189   Res res;
   190 
   191   AVER(pReturn != NULL);
   192   AVERT(Pool, pool);
   193   AVER(size > 0);
   194 
   195   res = (*pool->class->alloc)(pReturn, pool, size);
   196   if(res != ResOK) return res;
   197 
   198   /* Make sure that the allocated address was in the pool's memory. */
   199   AVER(PoolHasAddr(pool, *pReturn));
   200 
   201   return ResOK;
   202 }
   203 
   204 void (PoolFree)(Pool pool, Addr old, Size size)
   205 {
   206   AVERT(Pool, pool);
   207   AVER(old != (Addr)0);
   208   AVER(PoolHasAddr(pool, old));
   209   (*pool->class->free)(pool, old, size);
   210 }
   211 
   212 Res (PoolCondemn)(RefSet *condemnedReturn, Pool pool,
   213                   Space space, TraceId ti)
   214 {
   215   AVERT(Pool, pool);
   216   return (*pool->class->condemn)(condemnedReturn, pool, space, ti);
   217 }
   218 
   219 void (PoolGrey)(Pool pool, Space space, TraceId ti)
   220 {
   221   AVERT(Pool, pool);
   222   (*pool->class->grey)(pool, space, ti);
   223 }
   224 
   225 Res (PoolScan)(ScanState ss, Pool pool, Bool *finishedReturn)
   226 {
   227   AVERT(Pool, pool);
   228   return (*pool->class->scan)(ss, pool, finishedReturn);
   229 }
   230 
   231 Res (PoolFix)(Pool pool, ScanState ss, Seg seg, Addr *refIO)
   232 {
   233   AVERT(Pool, pool);
   234   return PoolFix(pool, ss, seg, refIO);
   235 }
   236 
   237 void (PoolReclaim)(Pool pool, Space space, TraceId ti)
   238 {
   239   AVERT(Pool, pool);
   240   (*pool->class->reclaim)(pool, space, ti);
   241 }
   242 
   243 void (PoolAccess)(Pool pool, Seg seg, AccessSet mode)
   244 {
   245   AVERT(Pool, pool);
   246   (*pool->class->access)(pool, seg, mode);
   247 }
   248 
   249 
   250 Res PoolDescribe(Pool pool, Lib_FILE *stream)
   251 {
   252   int e;
   253   Res res;
   254   AVERT(Pool, pool);
   255   AVER(stream != NULL);
   256 
   257   e = Lib_fprintf(stream,
   258                   "Pool %p {\n"
   259                   "  Class %s\n"
   260                   "  alignment %lu\n",
   261                   pool,
   262                   pool->class->name,
   263                   (unsigned long)pool->alignment);
   264   if(e < 0) return ResIO;
   265 
   266   res = (*pool->class->describe)(pool, stream);
   267   if(res != ResOK) return res;
   268 
   269   e = Lib_fprintf(stream, "} Pool %p\n", pool);
   270   if(e < 0) return ResIO;
   271 
   272   return ResOK;
   273 }
   274 
   275 
   276 /* Thread safe */
   277 Space (PoolSpace)(Pool pool)
   278 {
   279   return pool->space;
   280 }
   281 
   282 
   283 Res PoolSegAlloc(Seg *segReturn, Pool pool, Size size)
   284 {
   285   Res res;
   286   Seg seg;
   287   Space space;
   288 
   289   AVER(segReturn != NULL);
   290   AVERT(Pool, pool);
   291   space = PoolSpace(pool);
   292   AVER(SizeIsAligned(size, ArenaAlign(space)));
   293 
   294   res = SegAlloc(&seg, space, size, pool);
   295   if(res != ResOK)
   296     return res;
   297 
   298   seg->pool = pool;
   299 
   300   *segReturn = seg;
   301   return ResOK;
   302 }
   303 
   304 
   305 void PoolSegFree(Pool pool, Seg seg)
   306 {
   307   Space space;
   308 
   309   AVERT(Pool, pool);
   310 
   311   space = PoolSpace(pool);
   312 
   313   ShieldFlush(space);
   314 
   315   SegFree(space, seg);
   316 }
   317 
   318 
   319 Bool PoolOfAddr(Pool *poolReturn, Space space, Addr addr)
   320 {
   321   Seg seg;
   322 
   323   AVER(poolReturn != NULL);
   324 
   325   if(SegOfAddr(&seg, space, addr)) {
   326     *poolReturn = seg->pool;
   327     return TRUE;
   328   }
   329 
   330   return FALSE;
   331 }
   332 
   333 
   334 Bool PoolHasAddr(Pool pool, Addr addr)
   335 {
   336   Pool addrPool;
   337   Space space;
   338 
   339   AVERT(Pool, pool);
   340 
   341   space = PoolSpace(pool);
   342   if(PoolOfAddr(&addrPool, space, addr) && addrPool == pool)
   343     return TRUE;
   344   else
   345     return FALSE;
   346 }
   347 
   348 
   349 Align (PoolAlignment)(Pool pool)
   350 {
   351   AVERT(Pool, pool);
   352   return pool->alignment;
   353 }
   354 
   355 
   356 /* PoolNo*, PoolTriv* -- Trivial and non-methods for Pool Classes
   357  *
   358  * If a pool class doesn't implement a method, and doesn't expect it
   359  * to be called, it should use a non-method (PoolNo*) which will cause
   360  * an assertion failure if they are reached.
   361  *
   362  * If a pool class supports a protocol but does not require any more
   363  * than a trivial implementation, it should use a trivial method
   364  * (PoolTriv*) which will do the trivial thing.
   365  */
   366 
   367 Res PoolNoAlloc(Addr *pReturn, Pool pool, Size size)
   368 {
   369   AVER(pReturn != NULL);
   370   AVERT(Pool, pool);
   371   AVER(size > 0);
   372   NOTREACHED;
   373   return ResUNIMPL;
   374 }
   375 
   376 void PoolNoFree(Pool pool, Addr old, Size size)
   377 {
   378   AVERT(Pool, pool);
   379   AVER(old != NULL);
   380   AVER(size > 0);
   381   NOTREACHED;
   382 }
   383 
   384 void PoolTrivFree(Pool pool, Addr old, Size size)
   385 {
   386   AVERT(Pool, pool);
   387   AVER(old != NULL);
   388   AVER(size > 0);
   389   NOOP;                         /* trivial free has no effect */
   390 }
   391 
   392 Res PoolNoBufferInit(Pool pool, Buffer buf)
   393 {
   394   AVERT(Pool, pool);
   395   NOTREACHED;
   396   return ResUNIMPL;
   397 }
   398 
   399 Res PoolTrivBufferInit(Pool pool, Buffer buf)
   400 {
   401   AVERT(Pool, pool);
   402   return ResOK;
   403 }
   404 
   405 void PoolNoBufferFinish(Pool pool, Buffer buf)
   406 {
   407   AVERT(Pool, pool);
   408   AVERT(Buffer, buf);
   409   NOTREACHED;
   410 }
   411 
   412 void PoolTrivBufferFinish(Pool pool, Buffer buf)
   413 {
   414   AVERT(Pool, pool);
   415   AVERT(Buffer, buf);
   416 }
   417 
   418 Res PoolNoBufferFill(Addr *baseReturn, Pool pool, Buffer buffer, Size 
size)
   419 {
   420   AVER(baseReturn != NULL);
   421   AVERT(Pool, pool);
   422   AVERT(Buffer, buffer);
   423   AVER(size > 0);
   424   NOTREACHED;
   425   return ResUNIMPL;
   426 }
   427 
   428 Bool PoolNoBufferTrip(Pool pool, Buffer buffer, Addr base, Size size)
   429 {
   430   AVERT(Pool, pool);
   431   AVERT(Buffer, buffer);
   432   AVER(base != NULL);
   433   AVER(size > 0);
   434   NOTREACHED;
   435   return FALSE;
   436 }
   437 
   438 void PoolNoBufferExpose(Pool pool, Buffer buffer)
   439 {
   440   AVERT(Pool, pool);
   441   AVERT(Buffer, buffer);
   442   NOTREACHED;
   443 }
   444 
   445 void PoolNoBufferCover(Pool pool, Buffer buffer)
   446 {
   447   AVERT(Pool, pool);
   448   AVERT(Buffer, buffer);
   449   NOTREACHED;
   450 }
   451 
   452 Res PoolNoDescribe(Pool pool, Lib_FILE *stream)
   453 {
   454   AVERT(Pool, pool);
   455   AVER(stream != NULL);
   456   NOTREACHED;
   457   return ResUNIMPL;
   458 }
   459 
   460 Res PoolTrivDescribe(Pool pool, Lib_FILE *stream)
   461 {
   462   int e;
   463   AVERT(Pool, pool);
   464   AVER(stream != NULL);
   465   e = Lib_fprintf(stream, "  No class-specific description 
available.\n");
   466   if(e < 0)
   467     return ResIO;
   468   return ResOK;
   469 }
   470 
   471 Res PoolNoCondemn(RefSet *condemnedReturn, Pool pool, Space space, 
TraceId ti)
   472 {
   473   AVER(condemnedReturn != NULL);
   474   AVERT(Pool, pool);
   475   AVERT(Space, space);
   476   AVER(TraceIdCheck(ti));
   477   NOTREACHED;
   478   return ResUNIMPL;
   479 }
   480 
   481 void PoolNoGrey(Pool pool, Space space, TraceId ti)
   482 {
   483   AVERT(Pool, pool);
   484   AVERT(Space, space);
   485   AVER(TraceIdCheck(ti));
   486   NOTREACHED;
   487 }
   488 
   489 Res PoolNoScan(ScanState ss, Pool pool, Bool *finishedReturn)
   490 {
   491   AVERT(ScanState, ss);
   492   AVERT(Pool, pool);
   493   AVER(finishedReturn != NULL);
   494   NOTREACHED;
   495   return ResUNIMPL;
   496 }
   497 
   498 Res PoolNoFix(Pool pool, ScanState ss, Seg seg, Ref *refIO)
   499 {
   500   AVERT(Pool, pool);
   501   AVERT(ScanState, ss);
   502   AVERT(Seg, seg);
   503   AVER(refIO != NULL);
   504   NOTREACHED;
   505   return ResUNIMPL;
   506 }
   507 
   508 void PoolNoReclaim(Pool pool, Space space, TraceId ti)
   509 {
   510   AVERT(Pool, pool);
   511   AVERT(Space, space);
   512   AVER(TraceIdCheck(ti));
   513   NOTREACHED;
   514 }
   515 
   516 void PoolNoAccess(Pool pool, Seg seg, AccessSet mode)
   517 {
   518   AVERT(Pool, pool);
   519   AVERT(Seg, seg);
   520   NOTREACHED;
   521 }

