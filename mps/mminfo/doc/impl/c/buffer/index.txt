                    ALLOCATION BUFFER IMPLEMENTATION
                             impl.c.buffer
                             accepted impl
                           gavinm 1996-08-20

     1 /* impl.c.buffer: ALLOCATION BUFFER IMPLEMENTATION
     2  *
     3  * $HopeName: MMsrc!buffer.c(trunk.11) $
     4  * Copyright (C) 1996 Harlequin Group, all rights reserved
     5  *
     6  * This is the interface to allocation buffers.
     7  *
     8  * An allocation buffer is an interface to a pool which provides
     9  * very fast allocation, and defers the need for synchronization in
    10  * a multi-threaded environment.
    11  *
    12  * Pools which contain formatted objects must be synchronized so
    13  * that the pool can know when an object is valid.  Allocation from
    14  * such pools is done in two stages: reserve and commit.  The client
    15  * first reserves memory, then initializes it, then commits.
    16  * Committing the memory declares that it contains a valid formatted
    17  * object.  Under certain conditions, some pools may cause the
    18  * commit operation to fail.  (See the documentation for the pool.)
    19  * Failure to commit indicates that the whole allocation failed and
    20  * must be restarted.  When a pool with commit failure, the
    21  * allocation sequence could look something like this:
    22  *
    23  * do {
    24  *   res = BufferReserve(&p, buffer, size);
    25  *   if(res != ResOK) return res;       // allocation fails, reason res
    26  *   initialize(p);                     // p now points at valid object
    27  * } while(!BufferCommit(buffer, p, size));
    28  *
    29  * Pools which do not contain formatted objects can use a one-step
    30  * allocation as usual.  Effectively any random rubbish counts as a
    31  * "valid object" to such pools.
    32  *
    33  * An allocation buffer is an area of memory which is pre-allocated
    34  * from a pool, plus a buffer descriptor, which contains, inter
    35  * alia, four pointers: base, init, alloc, and limit.  Base points
    36  * to the base address of the area, limit to the last address plus
    37  * one.  Init points to the first uninitialized address in the
    38  * buffer, and alloc points to the first unallocated address.
    39  *
    40  *    L . - - - - - .
    41  *      |           |
    42  *      |   junk    |
    43  *      |           |       the "busy" state, after Reserve
    44  *    A |-----------|
    45  *      |  uninit   |
    46  *    I |-----------|
    47  *      |   init    |
    48  *      |           |
    49  *    B `-----------'
    50  *
    51  *    L . - - - - - .
    52  *      |           |
    53  *      |   junk    |
    54  *      |           |       the "ready" state, after Commit
    55  *  A=I |-----------|
    56  *      |           |
    57  *      |           |
    58  *      |   init    |
    59  *      |           |
    60  *    B `-----------'
    61  *
    62  * Access to these pointers is restricted in order to allow
    63  * synchronization between the pool and the client.  The client may
    64  * only write to init and alloc, but in a restricted and atomic way
    65  * detailed below.  The pool may read the contents of the buffer
    66  * descriptor at _any_ time.  During calls to the fill and trip
    67  * methods, the pool may update any or all of the fields
    68  * in the buffer descriptor.  The pool may update the limit at _any_
    69  * time.
    70  *
    71  * Only one thread may use a buffer at once, unless the client
    72  * places a mutual exclusion around the buffer access in the usual
    73  * way.  In such cases it is usually better to create one buffer for
    74  * each thread.
    75  *
    76  * Here are pseudo-code descriptions of the reserve and commit
    77  * operations.  These may be implemented in-line by the client.
    78  * Note that the client is responsible for ensuring that the size
    79  * (and therefore the alloc and init pointers) are aligned according
    80  * to the buffer's alignment.
    81  *
    82  * Reserve(buf, size)                   ; size must be aligned to pool
    83  *   if buf->limit - buf->alloc >= size then
    84  *     buf->alloc +=size                ; must be atomic update
    85  *     p = buf->init
    86  *   else
    87  *     res = BufferFill(&p, buf, size)  ; buf contents may change
    88  *
    89  * Commit(buf, p, size)
    90  *   buf->init = buf->alloc             ; must be atomic update
    91  *   if buf->limit == 0 then
    92  *     b = BufferTrip(buf, p, size)     ; buf contents may change
    93  *
    94  * The pool must allocate the buffer descriptor and initialize it by
    95  * calling BufferInit.  The descriptor this creates will fall
    96  * through to the fill method on the first allocation.  In general,
    97  * pools should not assign resources to the buffer until the first
    98  * allocation, since the buffer may never be used.
    99  *
   100  * The pool may update the base, init, alloc, and limit fields when
   101  * the fallback methods are called.  In addition, the pool may set
   102  * the limit to zero at any time.  The effect of this is either:
   103  *
   104  *   1. cause the _next_ allocation in the buffer to fall through to
   105  *      the buffer fill method, and allow the buffer to be flushed
   106  *      and relocated;
   107  *
   108  *   2. cause the buffer trip method to be called if the client was
   109  *      between reserve and commit.
   110  *
   111  * A buffer may not be relocated under other circumstances because
   112  * there is a race between updating the descriptor and the client
   113  * allocation sequence.
   114  */
   115 
   116 #include "mpm.h"
   117 
   118 SRCID(buffer, "$HopeName: MMsrc!buffer.c(trunk.11) $");
   119 
   120 
   121 Ring BufferPoolRing(Buffer buffer)
   122 {
   123   AVERT(Buffer, buffer);
   124   return &buffer->poolRing;
   125 }
   126 
   127 Pool (BufferPool)(Buffer buffer)
   128 {
   129   AVERT(Buffer, buffer);
   130   return buffer->pool;
   131 }
   132 
   133 
   134 /* BufferCreate -- create an allocation buffer in a pool
   135  *
   136  * The buffer structure is allocated from the space control pool,
   137  * and initialized with generic valid contents.  If the pool
   138  * provides a bufferInit method then it is called and may perform
   139  * additional initialization, otherwise the base, init,
   140  * alloc, and limit fields are set to zero, so that the fill method
   141  * will get called the first time a reserve operation is attempted.
   142  *
   143  * Iff successful, *bufferReturn is updated with a pointer to the
   144  * buffer descriptor, and ResOK is returned.
   145  */
   146 
   147 Res BufferCreate(Buffer *bufferReturn, Pool pool, Rank rank)
   148 {
   149   Res res;
   150   Buffer buffer;
   151   Space space;
   152 
   153   AVER(bufferReturn != NULL);
   154   AVERT(Pool, pool);
   155   AVER((pool->class->attr & AttrBUF) != 0);
   156   
   157   space = PoolSpace(pool);
   158 
   159   /* Allocate the buffer structure. */  
   160   res = SpaceAlloc((Addr *)&buffer, space, sizeof(BufferStruct));
   161   if(res != ResOK) return res;
   162 
   163   /* Initialize the generic fields of the buffer. */
   164   buffer->base = 0;
   165   buffer->pool = pool;
   166   buffer->space = space;
   167   buffer->ap.init = 0;
   168   buffer->ap.alloc = 0;
   169   buffer->ap.limit = 0;
   170   buffer->alignment = pool->alignment;
   171   buffer->exposed = FALSE;
   172   buffer->seg = NULL;
   173   buffer->rank = rank;
   174   buffer->shieldMode = AccessSetEMPTY;
   175   buffer->grey = TraceSetEMPTY;
   176   buffer->p = NULL;
   177   buffer->i = 0;
   178   RingInit(&buffer->poolRing);
   179 
   180   /* Dispatch to the pool class method to perform any extra */
   181   /* initialization of the buffer. */
   182   res = (*pool->class->bufferInit)(pool, buffer);
   183   if(res != ResOK) {
   184     SpaceFree(space, (Addr)buffer, sizeof(BufferStruct));
   185     return res;
   186   }
   187 
   188   /* Now that it's initialized, sign the buffer and check it. */
   189   buffer->sig = BufferSig;
   190   buffer->serial = pool->bufferSerial;
   191   ++pool->bufferSerial;
   192   AVERT(Buffer, buffer);
   193 
   194   /* Attach the initialized buffer to the pool. */
   195   RingAppend(&pool->bufferRing, &buffer->poolRing);
   196 
   197   *bufferReturn = buffer;
   198   return ResOK;
   199 }
   200 
   201 
   202 /* BufferDestroy -- destroy an allocation buffer
   203  *
   204  * Destroy frees a buffer descriptor.  The buffer must be in the
   205  * "ready" state, i.e. not between a Reserve and Commit.  Allocation
   206  * in the area of memory to which the descriptor refers must cease
   207  * after Destroy is called.
   208  *
   209  * Destroying an allocation buffer does not affect objects which have
   210  * been allocated, it just frees resources associated with the buffer
   211  * itself.
   212  *
   213  * The pool class's bufferDestroy method is called and then the
   214  * buffer structure is uninitialized and freed.
   215  */
   216 
   217 void BufferDestroy(Buffer buffer)
   218 {
   219   Space space;
   220   Pool pool;
   221 
   222   AVERT(Buffer, buffer);
   223 
   224   /* Make a copy of the space before the buffer gets finished. */
   225   space = buffer->space;
   226   pool = buffer->pool;
   227 
   228   AVER((pool->class->attr & AttrBUF) != 0);
   229   AVER(BufferIsReady(buffer));
   230   AVER(buffer->exposed == FALSE);
   231 
   232   /* Detach the buffer from its owning pool. */
   233   RingRemove(&buffer->poolRing);
   234   
   235   /* Dispatch to the pool class method to finish the buffer. */
   236   (*pool->class->bufferFinish)(pool, buffer);
   237 
   238   /* Unsign the finished buffer. */
   239   buffer->sig = SigInvalid;
   240   
   241   /* Finish off the generic buffer fields and deallocate the */
   242   /* buffer structure. */
   243   RingFinish(&buffer->poolRing);
   244   SpaceFree(space, (Addr)buffer, sizeof(BufferStruct));
   245 }
   246 
   247 
   248 Bool BufferCheck(Buffer buffer)
   249 {
   250   CHECKS(Buffer, buffer);
   251   CHECKU(Pool, buffer->pool);
   252   CHECKL(buffer->serial < buffer->pool->bufferSerial);
   253   CHECKU(Space, buffer->space);
   254   CHECKL(RingCheck(&buffer->poolRing));
   255   CHECKL(TraceSetCheck(buffer->grey));
   256   CHECKL(buffer->base <= buffer->ap.init);
   257   CHECKL(buffer->ap.init <= buffer->ap.alloc);
   258   CHECKL(buffer->ap.alloc <= buffer->ap.limit || buffer->ap.limit == 0);
   259   CHECKL(buffer->alignment == buffer->pool->alignment);
   260   CHECKL(AlignCheck(buffer->alignment));
   261   CHECKL(AddrIsAligned(buffer->base, buffer->alignment));
   262   CHECKL(AddrIsAligned(buffer->ap.init, buffer->alignment));
   263   CHECKL(AddrIsAligned(buffer->ap.alloc, buffer->alignment));
   264   CHECKL(AddrIsAligned(buffer->ap.limit, buffer->alignment));
   265   if(buffer->seg != NULL) {
   266     CHECKL(SegCheck(buffer->seg));
   267     CHECKL(buffer->rank == buffer->seg->rank);
   268   }
   269   return TRUE;
   270 }
   271 
   272 
   273 /* BufferSet/Reset -- set/reset a buffer
   274  *
   275  * Set sets the buffer base, init, alloc, and limit fields so that
   276  * the buffer is ready to start allocating in area of memory.  The
   277  * alloc field is a copy of the init field.
   278  *
   279  * Reset sets the buffer base, init, alloc, and limit fields to
   280  * zero, so that the next reserve request will call the fill
   281  * method.
   282  *
   283  * BufferIsReset returns TRUE iff the buffer is in the reset state,
   284  * i.e.  with base, init, alloc, and limit set to zero.
   285  */
   286 
   287 void BufferSet(Buffer buffer, Seg seg, Addr base, Addr init, Addr limit)
   288 {
   289   AVERT(Buffer, buffer);
   290 
   291   buffer->seg = seg;
   292   buffer->base = base;
   293   buffer->ap.init = init;
   294   buffer->ap.alloc = init;
   295   buffer->ap.limit = limit;
   296 }
   297 
   298 void BufferReset(Buffer buffer)
   299 {
   300   AVERT(Buffer, buffer);
   301 
   302   buffer->seg = NULL;
   303   buffer->base = 0;
   304   buffer->ap.init = 0;
   305   buffer->ap.alloc = 0;
   306   buffer->ap.limit = 0;
   307 }
   308 
   309 
   310 /* Buffer Information
   311  *
   312  * BufferPoolRing is a convenience function for accessing the ring
   313  * node which attaches a buffer descriptor to a pool.
   314  *
   315  * BufferPool returns the pool to which a buffer is attached.
   316  *
   317  * BufferIsReady returns TRUE iff the buffer is not between a
   318  * reserve and commit.  The result is only reliable if the client is
   319  * not currently using the buffer, since it may update the alloc and
   320  * init pointers asynchronously.
   321  *
   322  * BufferAP returns the APStruct substructure of a buffer.
   323  *
   324  * BufferOfAP is a thread-safe (impl.c.mpsi.thread-safety) method of
   325  * getting the buffer which owns an APStruct.
   326  *
   327  * BufferSpace is a thread-safe (impl.c.mpsi.thread-safety) method of
   328  * getting the space which owns a buffer.
   329  */
   330 
   331 Bool BufferIsReset(Buffer buffer)
   332 {
   333   AVERT(Buffer, buffer);
   334 
   335   if(buffer->base == 0 &&
   336      buffer->ap.init == 0 &&
   337      buffer->ap.alloc == 0 &&
   338      buffer->ap.limit == 0)
   339     return TRUE;
   340 
   341   return FALSE;
   342 }
   343 
   344 
   345 Bool BufferIsReady(Buffer buffer)
   346 {
   347   AVERT(Buffer, buffer);
   348 
   349   if(buffer->ap.init == buffer->ap.alloc)
   350     return TRUE;
   351 
   352   return FALSE;
   353 }
   354 
   355 AP BufferAP(Buffer buffer)
   356 {
   357   AVERT(Buffer, buffer);
   358   return &buffer->ap;
   359 }
   360 
   361 /* This method must be thread-safe.  See impl.c.mpsi.thread-safety. */
   362 Buffer BufferOfAP(AP ap)
   363 {
   364   return PARENT(BufferStruct, ap, ap);
   365 }
   366 
   367 /* This method must be thread-safe.  See impl.c.mpsi.thread-safety. */
   368 Space BufferSpace(Buffer buffer)
   369 {
   370   return buffer->space;
   371 }
   372 
   373 
   374 /* BufferReserve -- reserve memory from an allocation buffer
   375  *
   376  * This is a provided version of the reserve procedure described
   377  * above.  The size must be aligned according to the buffer
   378  * alignment.  Iff successful, ResOK is returned and
   379  * *pReturn updated with a pointer to the reserved memory.
   380  * Otherwise *pReturn it not touched.  The reserved memory is not
   381  * guaranteed to have any particular contents.  The memory must be
   382  * initialized with a valid object (according to the pool to which
   383  * the buffer belongs) and then passed to the Commit method (see
   384  * below).  Reserve may not be applied twice to a buffer without a
   385  * commit in-between.  In other words, Reserve/Commit pairs do not
   386  * nest.
   387  */
   388 
   389 Res BufferReserve(Addr *pReturn, Buffer buffer, Word size)
   390 {
   391   Addr next;
   392 
   393   AVER(pReturn != NULL);
   394   AVERT(Buffer, buffer);
   395   AVER(size > 0);
   396   AVER(SizeIsAligned(size, BufferPool(buffer)->alignment));
   397   AVER(BufferIsReady(buffer));
   398 
   399   /* Is there enough room in the unallocated portion of the buffer to */
   400   /* satisfy the request?  If so, just increase the alloc marker and */
   401   /* return a pointer to the area below it. */
   402 
   403   next = AddrAdd(buffer->ap.alloc, size);
   404   if(next > buffer->ap.alloc && next <= buffer->ap.limit)
   405   {
   406     buffer->ap.alloc = next;
   407     *pReturn = buffer->ap.init;
   408     return ResOK;
   409   }
   410 
   411   /* If the buffer can't accommodate the request, fall through to the */
   412   /* pool-specific allocation method. */
   413 
   414   return BufferFill(pReturn, buffer, size);
   415 }
   416 
   417 
   418 /* BufferFill -- refill an empty buffer
   419  *
   420  * If there is not enough space in a buffer to allocate in-line,
   421  * BufferFill must be called to "refill" the buffer.  (See the
   422  * description of the in-line Reserve method in the leader comment.)
   423  */
   424 
   425 Res BufferFill(Addr *pReturn, Buffer buffer, Word size)
   426 {
   427   Res res;
   428   Pool pool;
   429 
   430   AVER(pReturn != NULL);
   431   AVERT(Buffer, buffer);
   432   AVER(size > 0);
   433   AVER(SizeIsAligned(size, BufferPool(buffer)->alignment));
   434   AVER(BufferIsReady(buffer));
   435 
   436   pool = BufferPool(buffer);
   437   res = (*pool->class->bufferFill)(pReturn, pool, buffer, size);
   438 
   439   AVERT(Buffer, buffer);
   440 
   441   return res;
   442 }
   443 
   444 
   445 /* BufferCommit -- commit memory previously reserved
   446  *
   447  * Commit notifies the pool that memory which has been previously
   448  * reserved (see above) has been initialized with a valid object
   449  * (according to the pool to which the buffer belongs).  The pointer
   450  * p must be the same as that returned by Reserve, and the size must
   451  * match the size passed to Reserve.
   452  *
   453  * Commit may not be applied twice to a buffer without a reserve
   454  * in-between.  In other words, objects must be reserved,
   455  * initialized, then committed only once.
   456  *
   457  * Commit returns TRUE iff successful.  If commit fails and returns
   458  * FALSE, the client may try to allocate again by going back to the
   459  * reserve stage, and may not use the memory at p again for any
   460  * purpose.
   461  *
   462  * Some classes of pool may cause commit to fail under rare
   463  * circumstances.
   464  */
   465 
   466 Bool BufferCommit(Buffer buffer, Addr p, Word size)
   467 {
   468   AVERT(Buffer, buffer);
   469   AVER(size > 0);
   470   AVER(SizeIsAligned(size, BufferPool(buffer)->alignment));
   471 
   472   /* If a flip occurs before this point, the pool will see init */
   473   /* below the object, so it will be trashed and the commit */
   474   /* must fail when trip is called.  The pool will also see */
   475   /* a pointer p which points to the invalid object at init. */
   476 
   477   AVER(p == buffer->ap.init);
   478   AVER(AddrAdd(buffer->ap.init, size) == buffer->ap.alloc);
   479 
   480   /* Atomically update the init pointer to declare that the object */
   481   /* is initialized (though it may be invalid if a flip occurred). */
   482 
   483   buffer->ap.init = buffer->ap.alloc;
   484 
   485   /* **** Memory barrier here on the DEC Alpha. */
   486 
   487   /* If a flip occurs at this point, the pool will see init */
   488   /* above the object, which is valid, so it will be collected */
   489   /* the commit must succeed when trip is called.  The pointer */
   490   /* p will have been fixed up. */
   491 
   492   /* trip the buffer if a flip has occurred. */
   493 
   494   if(buffer->ap.limit == 0)
   495     return BufferTrip(buffer, p, size);
   496 
   497   /* No flip occurred, so succeed. */
   498 
   499   return TRUE;
   500 }
   501 
   502 
   503 /* BufferTrip -- act on a tripped buffer
   504  *
   505  * The pool which owns a buffer may asyncronously set the buffer limit
   506  * to zero in order to get control over the buffer.  If this occurs
   507  * after a Reserve, then the Commit method calls BufferTrip.  (See
   508  * the description of the in-line Commit in the leader comment.)
   509  */
   510 
   511 Bool BufferTrip(Buffer buffer, Addr p, Word size)
   512 {
   513   Pool pool;
   514 
   515   AVERT(Buffer, buffer);
   516   AVER(size > 0);
   517   AVER(SizeIsAligned(size, BufferPool(buffer)->alignment));
   518 
   519   pool = BufferPool(buffer);
   520   return (*pool->class->bufferTrip)(pool, buffer, p, size);
   521 }
   522 
   523 
   524 /* BufferShieldExpose/Cover -- buffer shield control
   525  *
   526  * BufferExpose guarantees that buffered memory is exposed between a
   527  * reserve and commit operation.  BufferCover guarantees that
   528  * buffered memory is covered.
   529  */
   530 
   531 void BufferExpose(Buffer buffer)
   532 {
   533   Pool pool;
   534 
   535   AVERT(Buffer, buffer);
   536 
   537   buffer->exposed = TRUE;
   538   pool = BufferPool(buffer);
   539   (*pool->class->bufferExpose)(pool, buffer);
   540 }
   541 
   542 void BufferCover(Buffer buffer)
   543 {
   544   Pool pool;
   545 
   546   AVERT(Buffer, buffer);
   547 
   548   buffer->exposed = FALSE;
   549   pool = BufferPool(buffer);
   550   (*pool->class->bufferCover)(pool, buffer);
   551 }
   552 
   553 
   554 Res BufferDescribe(Buffer buffer, Lib_FILE *stream)
   555 {
   556   AVERT(Buffer, buffer);
   557   AVER(stream != NULL);
   558 
   559   Lib_fprintf(stream,
   560              "Buffer %p {\n"
   561              "  Pool %p\n"
   562              "  alignment %lu\n"
   563              "  base 0x%lX  init 0x%lX  alloc 0x%lX  limit 0x%lX\n"
   564              "  grey 0x%lX  shieldMode %lu"
   565              "} Buffer %p\n",
   566              (void *)buffer,
   567              (void *)BufferPool(buffer),
   568              (unsigned long)buffer->alignment,
   569              (unsigned long)buffer->base,
   570              (unsigned long)buffer->ap.init,
   571              (unsigned long)buffer->ap.alloc,
   572              (unsigned long)buffer->ap.limit,
   573              (unsigned long)buffer->grey,
   574              (unsigned long)buffer->shieldMode,
   575              (void *)buffer);
   576 
   577   return ResOK;
   578 }

