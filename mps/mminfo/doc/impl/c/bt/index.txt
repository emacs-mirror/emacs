                               BIT TABLES
                               impl.c.bt
                              accepted doc
                           gavinm 1997-05-12

     1 /* impl.c.bt: BIT TABLES
     2  *
     3  * $HopeName: MMsrc!bt.c(trunk.4) $
     4  * Copyright (C) 1997 Harlequin Group, all rights reserved
     5  *
     6  * READERSHIP
     7  *
     8  * .readership: Any MPS developer
     9  *
    10  * DESIGN
    11  *
    12  * .design: see design.mps.bt
    13  *
    14  * PURPOSE
    15  *
    16  * The Bit Tables modules is provides centrally functions for
    17  * manipulating tables of bits.  Such tables are often used to provide 
some
    18  * sort of mapping or set functionality (for example, a table of mark 
bits
    19  * in a mark and sweep pool may use bit tables).
    20  */
    21 
    22 
    23 #include "mpm.h"
    24 
    25 SRCID(bt, "$HopeName: MMsrc!bt.c(trunk.4) $");
    26 
    27 
    28 Size BTSize(unsigned long n)
    29 {
    30   AVER(n+MPS_WORD_WIDTH-1 > n);
    31 
    32   return (n+MPS_WORD_WIDTH-1)/MPS_WORD_WIDTH*sizeof(Word);
    33 }
    34   
    35 int (BTGet)(BT t, Index i)
    36 {
    37   AVER(t != NULL);
    38   /* Can't check i */
    39 
    40   return BTGet(t, i);
    41 }
    42   
    43 void (BTSet)(BT t, Index i)
    44 {
    45   AVER(t != NULL);
    46   /* Can't check i */
    47 
    48   BTSet(t, i);
    49 }
    50 
    51 void (BTRes)(BT t, Index i)
    52 {
    53   AVER(t != NULL);
    54   /* Can't check i */
    55 
    56   BTRes(t, i);
    57 }
    58 
    59 void BTSetRange(BT t, Index i, Index j)
    60 {
    61   AVER(t != NULL);
    62   AVER(i < j);
    63 
    64   for( ; i < j; ++i) {
    65     BTSet(t, i);
    66   }
    67 }
    68 
    69 void BTResRange(BT t, Index i, Index j)
    70 {
    71   AVER(t != NULL);
    72   AVER(i < j);
    73 
    74   for( ; i < j; ++i) {
    75     BTRes(t, i);
    76   }
    77 }
    78 
    79 Bool BTFindResRange(Index *iReturn, Index *jReturn,
    80                     BT t, unsigned long s, unsigned long n)
    81 {
    82   unsigned long i = 0;
    83 
    84   AVER(iReturn != NULL);
    85   AVER(jReturn != NULL);
    86   AVER(t != NULL);
    87   AVER(n <= s);
    88   AVER(n > 0);
    89 
    90   /* remember, s is the size of the table */
    91   while(i < s) {
    92     if(!BTGet(t, i)) {
    93       unsigned long j = i;
    94       do {
    95         ++j;
    96       } while(j < s && !BTGet(t, j));
    97       if(j - i >= n) {
    98         /* found sufficiently long run */
    99         *jReturn = j;
   100         *iReturn = i;
   101         return TRUE;
   102       }
   103       i = j;
   104       continue;         /* necessary, consider j == s */
   105     }
   106     /* wasn't long enough */
   107     ++i;
   108   }
   109   AVER(i == s);
   110 
   111   return FALSE;
   112 }
   113 

