                        RECURSIVE LOCKS IN WIN32
                             impl.c.locknt
                               draft impl
                             dsm 1995-10-12

/*  impl.c.locknt
 *
 *                  RECURSIVE LOCKS IN WIN32
 *
 *  $HopeName$
 *
 *  Copyright (C) 1995 Harlequin Group, all rights reserved
 *
 *  These are implemented using critical sections.
 *  See the Microsoft Win32 API Programmer's Reference.
 *
 *  Critical sections support recursive locking, so the implementation
 *  could be trivial.  This implementation counts the claims to provide
 *  extra checking.  It also never recursively calls critical sections:
 *  they have some undocumented (small) limit on number of recursive claims.
 */

#include "std.h"
#include "lock.h"
#include "lockst.h"

#ifndef OS_NT
#error "locknt.c is specific to Win32 but OS_NT not defined"
#endif

#include <windows.h>

#ifdef DEBUG_SIGN
static SigStruct LockSigStruct;
#endif

void LockInit(Lock lock)
{
  lock->claims = 0; 
  InitializeCriticalSection(&lock->cs);
#ifdef DEBUG_SIGN
  SigInit(&LockSigStruct, "Lock");
  lock->sig = &LockSigStruct;
#endif
  AVER(ISVALID(Lock, lock));
}

void LockFinish(Lock lock)
{
  AVER(lock->claims == 0);
  DeleteCriticalSection(&lock->cs);
#ifdef DEBUG_SIGN
  lock->sig = SigInvalid;
#endif
}

void LockClaim(Lock lock)
{
  AVER(ISVALID(Lock, lock));
  EnterCriticalSection(&lock->cs);
  AVER(lock->claims == 0);
  lock->claims = 1;        
}

void LockRelease(Lock lock)
{
  AVER(ISVALID(Lock, lock));
  AVER(lock->claims == 1);
  lock->claims = 0;
  LeaveCriticalSection(&lock->cs);
}

void LockClaimRecursive(Lock lock)
{
  AVER(ISVALID(Lock, lock));
  if(lock->claims == 0)
    EnterCriticalSection(&lock->cs);
  ++lock->claims;
}

void LockReleaseRecursive(Lock lock)
{
  AVER(ISVALID(Lock, lock));
  --lock->claims;
  AVER(lock->claims >= 0);
  if(lock->claims == 0)
    LeaveCriticalSection(&lock->cs);
}

Bool LockIsValid(Lock lock, ValidationType validParam)
{
#ifdef DEBUG_SIGN
  AVER(ISVALIDNESTED(Sig, lock->sig));
#endif
  AVER(lock->claims >= 0);
  return TRUE;
}  

