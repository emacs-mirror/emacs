                      MANUAL FIXED SMALL UNIT POOL
                             impl.c.poolmfs
                               draft doc
                           gavinm 1996-09-17

     1 /* impl.c.poolmfs: MANUAL FIXED SMALL UNIT POOL
     2  *
     3  * $HopeName: MMsrc!poolmfs.c(trunk.13) $
     4  * Copyright (C) 1994,1995,1996 Harlequin Group, all rights reserved
     5  *
     6  * This is the implementation of the MFS pool class.
     7  *
     8  * DESIGN
     9  *
    10  * .design.misplaced: This design is misplaced, it should be in a
    11  * separate document.
    12  *
    13  * MFS operates in a very simple manner: each segment is divided into
    14  * units.  Free units are kept on a linked list using a header stored
    15  * in the unit itself.  The linked list is not ordered; allocation and
    16  * deallocation simply pop and push from the head of the list.  This is
    17  * fast, but successive allocations might have poor locality if
    18  * previous successive frees did.
    19  *
    20  * .restriction: This pool cannot allocate from the space control
    21  * pool (as the control pool is an instance of PoolClassMV and MV uses
    22  * MFS in its implementation), nor can it allocate sub-pools, as that
    23  * causes allocation in the control pool.
    24  *
    25  * Notes
    26  *
    27  * .freelist.fragments: The simple freelist policy might lead to poor
    28  * locality of allocation if the list gets fragmented.
    29  * 
    30  * .buffer.not: This pool doesn't support fast cache allocation, which
    31  * is a shame.
    32  */
    33 
    34 
    35 #include "mpm.h"
    36 #include "poolmfs.h"
    37 
    38 SRCID(poolmfs, "$HopeName: MMsrc!poolmfs.c(trunk.13) $");
    39 
    40 
    41 /*  == Round up ==
    42  *
    43  *  Rounds n up to the nearest multiple of unit.
    44  */
    45 
    46 #define ROUND(unit, n)  ((n)+(unit)-1 - ((n)+(unit)-1)%(unit))
    47 
    48 #define PoolPoolMFS(pool)       PARENT(MFSStruct, poolStruct, pool)
    49 
    50 
    51 /*  == Free List Structure ==
    52  */
    53 
    54 typedef struct MFSHeaderStruct {
    55   struct MFSHeaderStruct *next;
    56 } HeaderStruct, *Header;
    57 
    58 
    59 
    60 #define UNIT_MIN        sizeof(HeaderStruct)
    61 
    62 MFSInfo MFSGetInfo(void)
    63 {
    64   static const struct MFSInfoStruct info =
    65   {
    66     /* unitSizeMin */   UNIT_MIN
    67   };
    68   return &info;
    69 }
    70 
    71 
    72 Pool (MFSPool)(MFS mfs)
    73 {
    74   AVERT(MFS, mfs);
    75   return &mfs->poolStruct;
    76 }
    77 
    78 
    79 static Res MFSInit(Pool pool, va_list arg)
    80 {
    81   Size extendBy, unitSize;
    82   MFS mfs;
    83   Space space;
    84 
    85   AVER(pool != NULL);
    86 
    87   extendBy = va_arg(arg, Size);
    88   unitSize = va_arg(arg, Size);
    89 
    90   AVER(unitSize >= UNIT_MIN);
    91   AVER(extendBy >= unitSize);
    92   
    93   mfs = PoolPoolMFS(pool);
    94   space = PoolSpace(pool);
    95 
    96   mfs->unroundedUnitSize = unitSize;
    97 
    98   unitSize = SizeAlignUp(unitSize, ARCH_ALIGN);
    99   extendBy = SizeAlignUp(extendBy, ArenaAlign(space));
   100 
   101   mfs->extendBy = extendBy;
   102   mfs->unitSize = unitSize;
   103   mfs->unitsPerSeg = extendBy/unitSize;
   104   mfs->freeList = NULL;
   105   mfs->segList = (Seg)0;
   106   mfs->sig = MFSSig;
   107 
   108   AVERT(MFS, mfs);
   109 
   110   return ResOK;
   111 }
   112 
   113 
   114 static void MFSFinish(Pool pool)
   115 {
   116   Seg seg;
   117   MFS mfs;
   118 
   119   AVERT(Pool, pool);
   120   mfs = PoolPoolMFS(pool);
   121   AVERT(MFS, mfs);
   122 
   123   seg = mfs->segList;
   124   while(seg != NULL) {
   125     Seg nextSeg = (Seg)seg->p;   /* .seg.chain */
   126     PoolSegFree(pool, seg);
   127     seg = nextSeg;
   128   }
   129 
   130   mfs->sig = SigInvalid;
   131 }
   132 
   133 
   134 /*  == Allocate ==
   135  *
   136  *  Allocation simply involves taking a unit from the front of the 
freelist
   137  *  and returning it.  If there are none, a new segment is allocated.
   138  */
   139 
   140 static Res MFSAlloc(Addr *pReturn, Pool pool, Size size)
   141 {
   142   Header f;
   143   Res res;
   144   MFS mfs;
   145 
   146   AVERT(Pool, pool);
   147   mfs = PoolPoolMFS(pool);
   148   AVERT(MFS, mfs);
   149 
   150   AVER(pReturn != NULL);
   151   AVER(size == mfs->unroundedUnitSize);
   152 
   153   f = mfs->freeList;
   154 
   155   /* If the free list is empty then extend the pool with a new segment. 
*/
   156 
   157   if(f == NULL)
   158   {
   159     Seg seg;
   160     Word i, unitsPerSeg;
   161     Size unitSize;
   162     Addr base;
   163     Header header = NULL, next;
   164     Space space;
   165 
   166     /* Create a new segment and attach it to the pool. */
   167     res = PoolSegAlloc(&seg, pool, mfs->extendBy);
   168     if(res != ResOK)
   169       return res;
   170 
   171     /* .seg.chain: chain segs through seg->p */
   172     seg->p = (void *)mfs->segList;
   173     mfs->segList = seg;
   174 
   175     /* Sew together all the new empty units in the segment, working down 
*/
   176     /* from the top so that they are in ascending order of address on 
the */
   177     /* free list. */
   178 
   179     space = PoolSpace(pool);
   180     unitsPerSeg = mfs->unitsPerSeg;
   181     unitSize = mfs->unitSize;
   182     base = SegBase(space, seg);
   183     next = NULL;
   184 
   185 #define SUB(b, s, i)    ((Header)AddrAdd(b, (s)*(i)))
   186 
   187     for(i=0; i<unitsPerSeg; ++i)
   188     {
   189       header = SUB(base, unitSize, unitsPerSeg-i - 1);
   190       AVER(AddrIsAligned(header, pool->alignment));
   191       AVER(AddrAdd((Addr)header, unitSize) <= SegLimit(space, seg));
   192       header->next = next;
   193       next = header;
   194     }
   195 
   196 #undef SUB
   197 
   198     /* The first unit in the segment is now the head of the new free 
list. */
   199     f = header;
   200   }
   201 
   202   AVER(f != NULL);
   203 
   204   /* Detach the first free unit from the free list and return its 
address. */
   205 
   206   mfs->freeList = f->next;
   207 
   208   *pReturn = (Addr)f;
   209   return ResOK;
   210 }
   211 
   212 
   213 /*  == Free ==
   214  *
   215  *  Freeing a unit simply involves pushing it onto the front of the
   216  *  freelist.
   217  */
   218 
   219 static void MFSFree(Pool pool, Addr old, Size size)
   220 {
   221   Header h;
   222   MFS mfs;
   223 
   224   AVERT(Pool, pool);
   225   mfs = PoolPoolMFS(pool);
   226   AVERT(MFS, mfs);
   227 
   228   AVER(old != (Addr)0);
   229   AVER(size == mfs->unroundedUnitSize);
   230 
   231   /* .freelist.fragments */
   232   h = (Header)old;
   233   h->next = mfs->freeList;
   234   mfs->freeList = h;
   235 }
   236 
   237 
   238 static Res MFSDescribe(Pool pool, mps_lib_FILE *stream)
   239 {
   240   MFS mfs;
   241   Res res;
   242 
   243   AVERT(Pool, pool);
   244   mfs = PoolPoolMFS(pool);
   245   AVERT(MFS, mfs);
   246 
   247   AVER(stream != NULL);
   248 
   249   res = WriteF(stream,
   250                "  unrounded unit size $W\n", 
(Word)mfs->unroundedUnitSize,
   251                "  unit size $W\n",           (Word)mfs->unitSize,
   252                "  segment size $W\n",        (Word)mfs->extendBy,
   253                "  units per segment $U\n",   (unsigned 
long)mfs->unitsPerSeg,
   254                "  free list begins at $P\n", (void *)mfs->freeList,
   255                "  seg list begin at $P\n",   (void *)mfs->segList,
   256                NULL);
   257   if(res != ResOK) return res;
   258 
   259   return ResOK;
   260 }
   261 
   262 
   263 static PoolClassStruct PoolClassMFSStruct = {
   264   PoolClassSig,
   265   "MFS",                                /* name */
   266   sizeof(MFSStruct),                    /* size */
   267   offsetof(MFSStruct, poolStruct),      /* offset */
   268   AttrALLOC | AttrFREE,                 /* attr */
   269   MFSInit,                              /* init */
   270   MFSFinish,                            /* finish */
   271   MFSAlloc,                             /* alloc */
   272   MFSFree,                              /* free */
   273   PoolNoBufferInit,                     /* bufferInit */
   274   PoolNoBufferFinish,                   /* bufferFinish */
   275   PoolNoBufferFill,                     /* bufferFill */
   276   PoolNoBufferTrip,                     /* bufferTrip */
   277   PoolNoBufferExpose,                   /* bufferExpose */
   278   PoolNoBufferCover,                    /* bufferCover */
   279   PoolNoCondemn,                        /* condemn */
   280   PoolNoGrey,                           /* grey */
   281   PoolNoScan,                           /* scan */
   282   PoolNoFix,                            /* fix */
   283   PoolNoReclaim,                        /* reclaim */
   284   PoolNoAccess,                         /* access */
   285   MFSDescribe,                          /* describe */
   286   PoolClassSig                          /* impl.h.mpmst.class.end-sig */
   287 };
   288 
   289 
   290 PoolClass PoolClassMFS(void)
   291 {
   292   return &PoolClassMFSStruct;
   293 }
   294 
   295 Bool MFSCheck(MFS mfs)
   296 {
   297   Space space;
   298 
   299   CHECKS(MFS, mfs);
   300   CHECKD(Pool, &mfs->poolStruct);
   301   CHECKL(mfs->poolStruct.class == &PoolClassMFSStruct);
   302   CHECKL(mfs->unroundedUnitSize >= UNIT_MIN);
   303   CHECKL(mfs->extendBy >= UNIT_MIN);
   304   space = PoolSpace(&mfs->poolStruct);
   305   CHECKL(SizeIsAligned(mfs->extendBy, ArenaAlign(space)));
   306   CHECKL(SizeAlignUp(mfs->unroundedUnitSize, mfs->poolStruct.alignment) 
==
   307   mfs->unitSize);
   308   CHECKL(mfs->unitsPerSeg == mfs->extendBy/mfs->unitSize);
   309   if(mfs->freeList != NULL) {
   310     /* free list is stored in the pool's managed memory */
   311     CHECKL(PoolHasAddr(&mfs->poolStruct, (Addr)mfs->freeList));
   312   }
   313   if(mfs->segList != (Seg)0) {
   314     CHECKL(SegCheck(mfs->segList));
   315   }
   316   return TRUE;
   317 }

