                   MEMORY POOL SYSTEM INTERFACE LAYER
                              impl.c.mpsi
                               draft doc
                           gavinm 1996-08-07

     1 /* impl.c.mpsi: MEMORY POOL SYSTEM INTERFACE LAYER
     2  *
     3  * $HopeName: MMsrc!mpsi.c(trunk.16) $
     4  * Copyright (C) 1996 Harlequin Group, all rights reserved.
     5  *
     6  * PURPOSE
     7  *
     8  * .purpose: This code bridges between the MPS interface to C,
     9  * impl.h.mpsi, and the internal MPM interfaces, as defined by
    10  * impl.h.mpm.  .purpose.check: It performs checking of the C client's
    11  * usage of the MPS Interface.  .purpose.thread: It excludes multiple
    12  * threads from the MPM by locking the Space (see .thread-safety).
    13  *
    14  * NOTES
    15  *
    16  * .thread-safety: Most calls through this interface lock the space
    17  * and therefore make the MPM single-threaded.  In order to do this
    18  * they must recover the space from their parameters.  Methods such
    19  * as ThreadSpace() must therefore be callable when the space is
    20  * _not_ locked.  These methods are tagged with the tag of this note.
    21  *
    22  * .lock-free: Certain functions inside the MPM are thread-safe and do
    23  * not need to be serialized by using locks.  They are tagged with this
    24  * the tag of this note.
    25  *
    26  * .form: Almost all functions in this implementation simply cast their
    27  * arguments to the equivalent internal types, and cast results back
    28  * to the external type, where necessary.  Only exceptions are noted
    29  * in comments.
    30  *
    31  * TRANSGRESSIONS (rule.impl.trans)
    32  *
    33  * .check.protocol: (rule.impl.req) More could be done in this code to
    34  * check that protocols are obeyed by the client.  It probably doesn't
    35  * meet checking requirements.
    36  *
    37  * .varargs: (rule.universal.complete) The varags passed to mps_alloc(_v)
    38  * and mps_ap_create(_v) are ignored at the moment.  None of the pool
    39  * implementations use them, and they're not passed through.
    40  *
    41  * .poll: (rule.universal.complete) Various allocation methods call
    42  * SpacePoll to allow the MPM to "steal" CPU time and get on with
    43  * background tasks such as incremental GC.  This mechanism hasn't been
    44  * well thought out.
    45  *
    46  * .root-mode: (rule.universal.complete) The root "mode", which specifies
    47  * things like the protectability of roots, is ignored at present.  This
    48  * is because the MPM doesn't ever try to protect them.  In future, it
    49  * will.
    50  *
    51  * .reg-scan: (rule.universal.complete) At present, we only support
    52  * register scanning using our own ambiguous register and stack scanning
    53  * method, mps_stack_scan_ambig.  This may never change, but the way the
    54  * interface is designed allows for the possibility of change.
    55  *
    56  * .msg.unimpl: (rule.universal.complete) Aynchronous messages from the
    57  * MPS to the client are not implemented.
    58  */
    59 
    60 #include "mpm.h"
    61 #include "mps.h"
    62 
    63 SRCID(mpsi, "$HopeName: MMsrc!mpsi.c(trunk.16) $");
    64 
    65 
    66 /* mpsi_check -- check consistency of interface mappings
    67  *
    68  * .check.purpose: The mpsi_check function attempts to check whether
    69  * the defintions in impl.h.mpsi match the equivalent definition in
    70  * the MPM.  It is checking the assumptions made in the other functions
    71  * in this implementation.
    72  *
    73  * .check.macros: The CHECK* macros use some C trickery to attempt to
    74  * verify that certain types and fields are equivalent.  The do not
    75  * do a complete job.  This trickery is justified by the security gained
    76  * in knowing that impl.h.mps matches the MPM.  See also
    77  * mail.richard.1996-08-07.09-49.  [This paragraph is intended to
    78  * satisfy rule.impl.trick.]
    79  *
    80  * .check.empty: Note that mpsi_check compiles away to almost nothing.
    81  */
    82 
    83 #define CHECKLVALUE(lv1, lv2) \
    84   (sizeof((lv1) = (lv2)), sizeof((lv2) = (lv1)), TRUE)
    85 
    86 #define CHECKTYPE(t1, t2) \
    87   (sizeof(t1) == sizeof(t2) && \
    88    CHECKLVALUE(*((t1 *)0), *((t2 *)0)))
    89 
    90 #define CHECKFIELDAPPROX(s1, f1, s2, f2) \
    91   (sizeof(((s1 *)0)->f1) == sizeof(((s2 *)0)->f2) && \
    92    offsetof(s1, f1) == offsetof(s2, f2))
    93 
    94 #define CHECKFIELD(s1, f1, s2, f2) \
    95   (CHECKFIELDAPPROX(s1, f1, s2, f2) && \
    96    CHECKLVALUE(((s1 *)0)->f1, ((s2 *)0)->f2))
    97 
    98 static Bool mpsi_check(void)
    99 {
   100   /* Check that external and internal result codes match. */
   101   CHECKL(CHECKTYPE(mps_res_t, Res));
   102   CHECKL(MPS_RES_OK == ResOK);
   103   CHECKL(MPS_RES_FAIL == ResFAIL);
   104   CHECKL(MPS_RES_RESOURCE == ResRESOURCE);
   105   CHECKL(MPS_RES_MEMORY == ResMEMORY);
   106   CHECKL(MPS_RES_LIMIT == ResLIMIT);
   107   CHECKL(MPS_RES_UNIMPL == ResUNIMPL);
   108   CHECKL(MPS_RES_IO == ResIO);
   109 
   110   /* Check that external and internal rank numbers match. */
   111   CHECKL(CHECKTYPE(mps_rank_t, Rank));
   112   CHECKL(MPS_RANK_AMBIG == RankAMBIG);
   113   CHECKL(MPS_RANK_EXACT == RankEXACT);
   114   CHECKL(MPS_RANK_WEAK == RankWEAK);
   115   CHECKL(MPS_RANK_FINAL == RankFINAL);
   116 
   117   /* The external idea of a word width and the internal one */
   118   /* had better match. */
   119   CHECKL(MPS_WORD_WIDTH == WORD_WIDTH);
   120   CHECKL(sizeof(mps_word_t) == sizeof(void *));
   121   CHECKL(CHECKTYPE(mps_word_t, Word));
   122 
   123   /* Check ap_s/APStruct compatibility by hand */
   124   /* .check.ap: See also impl.h.buffer.ap. */
   125   CHECKL(sizeof(mps_ap_s) == sizeof(APStruct));
   126   CHECKL(CHECKFIELD(mps_ap_s, init,  APStruct, init));
   127   CHECKL(CHECKFIELD(mps_ap_s, alloc, APStruct, alloc));
   128   CHECKL(CHECKFIELD(mps_ap_s, limit, APStruct, limit));
   129 
   130   /* Check ss_s/ScanStateStruct compatibility by hand */
   131   /* .check.ss: See also impl.h.trace.ss. */
   132   CHECKL(CHECKFIELDAPPROX(mps_ss_s, fix, ScanStateStruct, fix));
   133   CHECKL(CHECKFIELD(mps_ss_s, w0, ScanStateStruct, zoneShift));
   134   CHECKL(CHECKFIELD(mps_ss_s, w1, ScanStateStruct, condemned));
   135   CHECKL(CHECKFIELD(mps_ss_s, w2, ScanStateStruct, summary));
   136 
   137   /* Check ld_s/LDStruct compatibility by hand */
   138   /* .check.ld: See also impl.h.ld.struct */
   139   CHECKL(sizeof(mps_ld_s) == sizeof(LDStruct));
   140   CHECKL(CHECKFIELD(mps_ld_s, w0, LDStruct, epoch));
   141   CHECKL(CHECKFIELD(mps_ld_s, w1, LDStruct, rs));
   142 
   143   return TRUE;
   144 }
   145 
   146 
   147 mps_assert_t mps_assert_install(mps_assert_t handler)
   148 {
   149   AVER(handler != NULL);
   150   return AssertInstall(handler);
   151 }
   152 
   153 mps_assert_t mps_assert_default(void)
   154 {
   155   return AssertDefault();
   156 }
   157 
   158 
   159 mps_res_t mps_space_create_wmem(mps_space_t *mps_space_o,
   160                                 mps_addr_t base, size_t size)
   161 {
   162   Space *spaceReturn = (Space *)mps_space_o;
   163 
   164   /* This is the first real call that the client will have to make, */
   165   /* so check static consistency here. */
   166   AVER(mpsi_check());
   167 
   168   AVER(spaceReturn != NULL);
   169   AVER(base != NULL);
   170 
   171   return SpaceCreate(spaceReturn, (Addr)base, (Size)size);
   172 }
   173 
   174 mps_res_t mps_space_create(mps_space_t *mps_space_o)
   175 {
   176   Space *spaceReturn = (Space *)mps_space_o;
   177 
   178   /* This is the first real call that the client will have to make, */
   179   /* so check static consistency here. */
   180   AVER(mpsi_check());
   181 
   182   AVER(spaceReturn != NULL);
   183 
   184   return SpaceCreate(spaceReturn, (Addr)0, (Size)0);
   185 }
   186 
   187 void mps_space_destroy(mps_space_t mps_space)
   188 {
   189   Space space = (Space)mps_space;
   190   AVERT(Space, space);
   191   SpaceDestroy(space);
   192 }
   193 
   194 
   195 /* mps_fmt_create_A -- create an object format of variety A
   196  *
   197  * .fmt.create.A.purpose: This function converts an object format
   198  * spec of variant "A" into an MPM Format object.  See
   199  * design.mps.interface.c.fmt.extend for justification of the
   200  * way that the format structure is declared as "mps_fmt_A".
   201  */ 
   202 
   203 mps_res_t mps_fmt_create_A(mps_fmt_t *mps_fmt_o,
   204                            mps_space_t mps_space,
   205                            mps_fmt_A_t mps_fmt_A)
   206 {
   207   Format *formatReturn = (Format *)mps_fmt_o;
   208   Space space = (Space)mps_space;
   209   Res res;
   210   SpaceEnter(space);
   211   AVER(mps_fmt_A != NULL);
   212   res = FormatCreate(formatReturn,
   213                      (Space)mps_space,
   214                      (Align)mps_fmt_A->align,
   215                      (FormatScanMethod)mps_fmt_A->scan,
   216                      (FormatSkipMethod)mps_fmt_A->skip,
   217                      (FormatMoveMethod)mps_fmt_A->fwd,
   218                      (FormatIsMovedMethod)mps_fmt_A->isfwd,
   219                      (FormatCopyMethod)mps_fmt_A->copy,
   220                      (FormatPadMethod)mps_fmt_A->pad);
   221   SpaceLeave(space);
   222   return res;
   223 }
   224 
   225 void mps_fmt_destroy(mps_fmt_t mps_fmt)
   226 {
   227   Format format = (Format)mps_fmt;
   228   Space space = FormatSpace(format);
   229   SpaceEnter(space);
   230   AVERT(Format, format);
   231   FormatDestroy((Format)mps_fmt);
   232   SpaceLeave(space);
   233 }
   234 
   235 
   236 mps_res_t mps_pool_create(mps_pool_t *mps_pool_o,
   237                           mps_space_t mps_space,
   238                           mps_class_t mps_class, ...)
   239 {
   240   Pool *poolReturn = (Pool *)mps_pool_o;
   241   Space space = (Space)mps_space;
   242   PoolClass class = (PoolClass)mps_class;
   243   va_list args;
   244   Res res;
   245 
   246   SpaceEnter(space);
   247 
   248   AVER(poolReturn != NULL);
   249   AVERT(Space, space);
   250   AVERT(PoolClass, class);
   251 
   252   va_start(args, mps_class);
   253   res = PoolCreateV(poolReturn, class, space, args);
   254   va_end(args);
   255 
   256   SpaceLeave(space);
   257   return res;
   258 }
   259 
   260 mps_res_t mps_pool_create_v(mps_pool_t *mps_pool_o,
   261                             mps_space_t mps_space,
   262                             mps_class_t mps_class,
   263                             va_list args)
   264 {
   265   Pool *poolReturn = (Pool *)mps_pool_o;
   266   Space space = (Space)mps_space;
   267   PoolClass class = (PoolClass)mps_class;
   268   Res res;
   269 
   270   SpaceEnter(space);
   271 
   272   AVER(poolReturn != NULL);
   273   AVERT(Space, space);
   274   AVERT(PoolClass, class);
   275 
   276   res = PoolCreateV(poolReturn, class, space, args);
   277 
   278   SpaceLeave(space);
   279   return res;
   280 }
   281 
   282 void mps_pool_destroy(mps_pool_t mps_pool)
   283 {
   284   Pool pool = (Pool)mps_pool;
   285   Space space = PoolSpace(pool);
   286 
   287   SpaceEnter(space);
   288 
   289   AVERT(Pool, pool);
   290   PoolDestroy(pool);
   291 
   292   SpaceLeave(space);
   293 }
   294 
   295 
   296 mps_res_t mps_alloc(mps_addr_t *p_o,
   297                     mps_pool_t mps_pool,
   298                     size_t size, ...)
   299 {
   300   Pool pool = (Pool)mps_pool;
   301   Space space = PoolSpace(pool);
   302   Res res;
   303 
   304   SpaceEnter(space);
   305 
   306   SpacePoll(space);                     /* .poll */
   307 
   308   AVER(p_o != NULL);
   309   AVERT(Pool, pool);
   310   AVER(size > 0);
   311   /* Note: class may allow unaligned size, see */
   312   /* design.mps.class-interface.alloc.size.align. */
   313 
   314   /* See .varargs. */
   315   res = PoolAlloc((Addr *)p_o, pool, size);
   316 
   317   SpaceLeave(space);
   318   return res;
   319 }
   320 
   321 mps_res_t mps_alloc_v(mps_addr_t *p_o,
   322                       mps_pool_t mps_pool,
   323                       size_t size, va_list args)
   324 {
   325   Pool pool = (Pool)mps_pool;
   326   Space space = PoolSpace(pool);
   327   Res res;
   328 
   329   SpaceEnter(space);
   330 
   331   SpacePoll(space);                     /* .poll */
   332 
   333   AVER(p_o != NULL);
   334   AVERT(Pool, pool);
   335   AVER(size > 0);
   336   UNUSED(args);
   337   /* Note: class may allow unaligned size, see */
   338   /* design.mps.class-interface.alloc.size.align. */
   339 
   340   /* See .varargs. */
   341   res = PoolAlloc((Addr *)p_o, pool, size);
   342 
   343   SpaceLeave(space);
   344   return res;
   345 }
   346 
   347 void mps_free(mps_pool_t mps_pool, mps_addr_t p, size_t size)
   348 {
   349   Pool pool = (Pool)mps_pool;
   350   Space space = PoolSpace(pool);
   351 
   352   SpaceEnter(space);
   353 
   354   AVERT(Pool, pool);
   355   AVER(size > 0);
   356   /* Note: class may allow unaligned size, see */
   357   /* design.mps.class-interface.alloc.size.align. */
   358 
   359   PoolFree(pool, (Addr)p, size);
   360   SpaceLeave(space);
   361 }
   362 
   363 
   364 mps_res_t mps_ap_create(mps_ap_t *mps_ap_o, mps_pool_t mps_pool,
   365                         mps_rank_t mps_rank, ...)
   366 {
   367   AP *apReturn = (AP *)mps_ap_o;
   368   Pool pool = (Pool)mps_pool;
   369   Rank rank = (Rank)mps_rank;
   370   Space space = PoolSpace(pool);
   371   Buffer buf;
   372   Res res;
   373   va_list args;
   374 
   375   SpaceEnter(space);
   376 
   377   AVER(apReturn != NULL);
   378   AVERT(Pool, pool);
   379 
   380   /* See .varargs. */
   381   va_start(args, mps_rank);
   382   res = BufferCreate(&buf, pool, rank);
   383   va_end(args);
   384   if(res != ResOK)
   385     return res;
   386 
   387   *apReturn = BufferAP(buf);
   388   SpaceLeave(space);
   389   return MPS_RES_OK;
   390 }
   391 
   392 mps_res_t mps_ap_create_v(mps_ap_t *mps_ap_o, mps_pool_t mps_pool,
   393                           mps_rank_t mps_rank, va_list args)
   394 {
   395   AP *apReturn = (AP *)mps_ap_o;
   396   Pool pool = (Pool)mps_pool;
   397   Rank rank = (Rank)mps_rank;
   398   Space space = PoolSpace(pool);
   399   Buffer buf;
   400   Res res;
   401 
   402   SpaceEnter(space);
   403 
   404   AVER(apReturn != NULL);
   405   AVERT(Pool, pool);
   406   UNUSED(args);
   407 
   408   /* See .varargs. */
   409   res = BufferCreate(&buf, pool, rank);
   410   if(res != ResOK)
   411     return res;
   412 
   413   *apReturn = BufferAP(buf);
   414   SpaceLeave(space);
   415   return MPS_RES_OK;
   416 }
   417 
   418 void mps_ap_destroy(mps_ap_t mps_ap)
   419 {
   420   Buffer buf = BufferOfAP((AP)mps_ap);
   421   Space space = BufferSpace(buf);
   422 
   423   SpaceEnter(space);
   424 
   425   AVERT(Buffer, buf);
   426   BufferDestroy(buf);
   427   SpaceLeave(space);
   428 }
   429 
   430 
   431 /* mps_reserve -- allocate store in preparation for initialization
   432  *
   433  * .reserve.call: mps_reserve does not call BufferReserve, but instead
   434  * uses the in-line macro from impl.h.mps.  This is so that it calls
   435  * mps_ap_fill and thence SpacePoll (.poll).  The consistency checks here
   436  * are the ones which can be done outside the MPM.  See also 
.commit.call.
   437  */
   438 
   439 mps_res_t (mps_reserve)(mps_addr_t *p_o, mps_ap_t mps_ap, size_t size)
   440 {
   441   mps_res_t res;
   442 
   443   AVER(p_o != NULL);
   444   AVER(size > 0);
   445   AVER(mps_ap != NULL);
   446   AVER(mps_ap->init == mps_ap->alloc);
   447 
   448   MPS_RESERVE_BLOCK(res, *p_o, mps_ap, size);
   449 
   450   return res;
   451 }
   452 
   453 
   454 /* mps_commit -- commit initialized object, finishing allocation
   455  *
   456  * .commit.call: mps_commit does not call BufferCommit, but instead
   457  * uses the in-line commit macro from impl.h.mps.  This is so that it
   458  * calls mps_ap_trip and thence SpacePoll in future (.poll).  The
   459  * consistency checks here are the ones which can be done outside the
   460  * MPM.  See also .reserve.call.
   461  */
   462 
   463 mps_bool_t (mps_commit)(mps_ap_t mps_ap, mps_addr_t p, size_t size)
   464 {
   465   AVER(mps_ap != NULL);
   466   AVER(p != NULL);
   467   AVER(size > 0);
   468   AVER(p == mps_ap->init);
   469   AVER((void *)((char *)mps_ap->init + size) == mps_ap->alloc);
   470 
   471   return mps_commit(mps_ap, p, size);
   472 }
   473 
   474 
   475 /* mps_ap_fill -- called by mps_reserve when an AP hasn't enough space
   476  *
   477  * .ap.fill.internal: Note that mps_ap_fill should never be "called"
   478  * directly by the client code.  It is invoked by the mps_reserve macro.
   479  */
   480 
   481 mps_res_t mps_ap_fill(mps_addr_t *p_o, mps_ap_t mps_ap, size_t size)
   482 {
   483   Buffer buf = BufferOfAP((AP)mps_ap);
   484   Space space = BufferSpace(buf);
   485   Res res;
   486 
   487   SpaceEnter(space);
   488 
   489   SpacePoll(space);                     /* .poll */
   490 
   491   AVER(p_o != NULL);
   492   AVERT(Buffer, buf);
   493   AVER(size > 0);
   494   AVER(SizeIsAligned(size, BufferPool(buf)->alignment));
   495 
   496   res = BufferFill((Addr *)p_o, buf, size);
   497 
   498   SpaceLeave(space);
   499   return res;
   500 }
   501 
   502 
   503 /* mps_trip -- called by mps_commit when an AP is tripped
   504  *
   505  * .ap.trip.internal: Note that mps_ap_trip should never be "called"
   506  * directly by the client code.  It is invoked by the mps_commit macro.
   507  */
   508 
   509 mps_bool_t mps_ap_trip(mps_ap_t mps_ap, mps_addr_t p, size_t size)
   510 {
   511   Buffer buf = BufferOfAP((AP)mps_ap);
   512   Space space = BufferSpace(buf);
   513   Bool b;
   514 
   515   SpaceEnter(space);
   516 
   517   AVERT(Buffer, buf);
   518   AVER(size > 0);
   519   AVER(SizeIsAligned(size, BufferPool(buf)->alignment));
   520 
   521   b = BufferTrip(buf, (Addr)p, size);
   522   SpaceLeave(space);
   523   return b;
   524 }
   525 
   526 
   527 mps_res_t mps_root_create(mps_root_t *mps_root_o,
   528                           mps_space_t mps_space,
   529                           mps_rank_t mps_rank,
   530                           mps_rm_t mps_rm,
   531                           mps_root_scan_t mps_root_scan,
   532                           void *p, size_t s)
   533 {
   534   Root *rootReturn = (Root *)mps_root_o;
   535   Space space = (Space)mps_space;
   536   Rank rank = (Rank)mps_rank;
   537   Res res;
   538 
   539   SpaceEnter(space);
   540 
   541   AVER(rootReturn != NULL);
   542   AVERT(Space, space);
   543   AVER(mps_root_scan != NULL);
   544   AVER(mps_rm == (mps_rm_t)0);
   545 
   546   /* See .root-mode. */
   547   res = RootCreate(rootReturn, space, rank,
   548                  (RootScanMethod)mps_root_scan, p, s);
   549   SpaceLeave(space);
   550   return res;
   551 }
   552 
   553 mps_res_t mps_root_create_table(mps_root_t *mps_root_o,
   554                                 mps_space_t mps_space,
   555                                 mps_rank_t mps_rank,
   556                                 mps_rm_t mps_rm,
   557                                 mps_addr_t *base, size_t size)
   558 {
   559   Root *rootReturn = (Root *)mps_root_o;
   560   Space space = (Space)mps_space;
   561   Rank rank = (Rank)mps_rank;
   562   Res res;
   563 
   564   SpaceEnter(space);
   565 
   566   AVER(mps_root_o != NULL);
   567   AVERT(Space, space);
   568   AVER(base != NULL);
   569   AVER((unsigned long)size > 0);
   570 
   571   /* Note, size is the length of the array at base, not */
   572   /* the size in bytes.  However, RootCreateTable expects */
   573   /* base and limit pointers.  Be careful. */
   574 
   575   /* See .root-mode. */
   576   res = RootCreateTable(rootReturn, space, rank,
   577                         (Addr *)base, (Addr *)base + size);
   578   SpaceLeave(space);
   579   return res;
   580 }
   581 
   582 mps_res_t mps_root_create_fmt(mps_root_t *mps_root_o,
   583                               mps_space_t mps_space,
   584                               mps_rank_t mps_rank,
   585                               mps_rm_t mps_rm,
   586                               mps_fmt_scan_t mps_fmt_scan,
   587                               mps_addr_t base,
   588                               mps_addr_t limit)
   589 {
   590   Root *rootReturn = (Root *)mps_root_o;
   591   Space space = (Space)mps_space;
   592   Rank rank = (Rank)mps_rank;
   593   FormatScanMethod scan = (FormatScanMethod)mps_fmt_scan;
   594 
   595   AVER(mps_root_o != NULL);
   596   AVERT(Space, space);
   597   AVER(scan != NULL);
   598   AVER(base != NULL);
   599   AVER(base < limit);
   600 
   601   /* See .root-mode. */
   602   return RootCreateFmt(rootReturn, space, rank, scan,
   603                        (Addr)base, (Addr)limit);
   604 }
   605 
   606 mps_res_t mps_root_create_reg(mps_root_t *mps_root_o,
   607                               mps_space_t mps_space,
   608                               mps_rank_t mps_rank,
   609                               mps_rm_t mps_rm,
   610                               mps_thr_t mps_thr,
   611                               mps_reg_scan_t mps_reg_scan,
   612                               void *reg_scan_p)
   613 {
   614   Root *rootReturn = (Root *)mps_root_o;
   615   Space space = (Space)mps_space;
   616   Rank rank = (Rank)mps_rank;
   617   Thread thread = (Thread)mps_thr;
   618   Res res;
   619 
   620   SpaceEnter(space);
   621 
   622   AVER(mps_root_o != NULL);
   623   AVERT(Space, space);
   624   AVERT(Thread, thread);
   625   AVER(mps_reg_scan != NULL);
   626   AVER(mps_reg_scan == mps_stack_scan_ambig); /* .reg.scan */
   627   AVER(reg_scan_p != NULL); /* stackBot */
   628   AVER(rank == MPS_RANK_AMBIG);
   629   AVER(mps_rm == (mps_rm_t)0);
   630 
   631   /* See .root-mode. */
   632   res = RootCreateReg(rootReturn, space, rank, thread,
   633                     (RootScanRegMethod)mps_reg_scan,
   634                     reg_scan_p);
   635   SpaceLeave(space);
   636   return res;
   637 }
   638 
   639 
   640 /* mps_stack_scan_ambig -- scan the thread state ambiguously
   641  *
   642  * See .reg-scan.
   643  */
   644 
   645 mps_res_t mps_stack_scan_ambig(mps_ss_t mps_ss,
   646                                mps_reg_t mps_reg, void *p)
   647 {
   648   ScanState ss = (ScanState)mps_ss;
   649   Thread thread = (Thread)mps_reg;
   650   return ThreadScan(ss, thread, p);
   651 }
   652 
   653 
   654 void mps_root_destroy(mps_root_t mps_root)
   655 {
   656   Root root = (Root)mps_root;
   657   Space space = RootSpace(root);
   658   SpaceEnter(space);
   659   AVERT(Root, root);
   660   RootDestroy(root);
   661   SpaceLeave(space);
   662 }
   663 
   664 
   665 void (mps_tramp)(void **r_o,
   666                  void *(*f)(void *p, size_t s),
   667                  void *p,
   668                  size_t s)
   669 {
   670   /* No parameter validation is possible.  We place no constraints on */
   671   /* the value of these parameters. */
   672 
   673   ProtTramp(r_o, f, p, s);
   674 }
   675 
   676 
   677 mps_res_t mps_thread_reg(mps_thr_t *mps_thr_o,
   678                          mps_space_t mps_space)
   679 {
   680   Thread *threadReturn = (Thread *)mps_thr_o;
   681   Space space = (Space)mps_space;
   682   Res res;
   683 
   684   SpaceEnter(space);
   685 
   686   AVER(mps_thr_o != NULL);
   687   AVERT(Space, space);
   688 
   689   res = ThreadRegister(threadReturn, space);
   690   SpaceLeave(space);
   691   return res;
   692 }
   693 
   694 void mps_thread_dereg(mps_thr_t mps_thr)
   695 {
   696   Thread thread = (Thread)mps_thr;
   697   Space space = ThreadSpace(thread);
   698   SpaceEnter(space);
   699   ThreadDeregister(thread, space);
   700   SpaceLeave(space);
   701 }
   702 
   703 void mps_ld_reset(mps_ld_t mps_ld, mps_space_t mps_space)
   704 {
   705   Space space = (Space)mps_space;
   706   LD ld = (LD)mps_ld;
   707   SpaceEnter(space);
   708   LDReset(ld, space);
   709   SpaceLeave(space);
   710 }
   711 
   712 
   713 /* mps_ld_add -- add a reference to a location dependency
   714  *
   715  * See .lock-free.
   716  */
   717 
   718 void mps_ld_add(mps_ld_t mps_ld, mps_space_t mps_space, mps_addr_t addr)
   719 {
   720   Space space = (Space)mps_space;
   721   LD ld = (LD)mps_ld;
   722   LDAdd(ld, space, (Addr)addr);
   723 }
   724 
   725 
   726 /* mps_ld_isstale -- check whether a location dependency is "stale"
   727  *
   728  * See .lock-free.
   729  */
   730 
   731 mps_bool_t mps_ld_isstale(mps_ld_t mps_ld,
   732                           mps_space_t mps_space,
   733                           mps_addr_t addr)
   734 {
   735   Space space = (Space)mps_space;
   736   LD ld = (LD)mps_ld;
   737   Bool b;
   738   b = LDIsStale(ld, space, (Addr)addr);
   739   return (mps_bool_t)b;
   740 }
   741 
   742 mps_res_t mps_fix(mps_ss_t mps_ss, mps_addr_t *ref_io)
   743 {
   744   mps_res_t res;
   745 
   746   MPS_SCAN_BEGIN(mps_ss) {
   747     res = MPS_FIX(mps_ss, ref_io);
   748   } MPS_SCAN_END(mps_ss);
   749 
   750   return res;
   751 }
   752 
   753 mps_word_t mps_collections(mps_space_t mps_space)
   754 {
   755   Space space = (Space)mps_space;
   756   return SpaceEpoch(space);  /* thread safe: see impl.h.space.epoch.ts */
   757 }
   758 
   759 
   760 /* Unimplemented -- see .msg.unimpl */
   761 
   762 mps_bool_t mps_msg_next(mps_space_t mps_space,
   763                         mps_mc_t *mps_mc_o,
   764                         void **msg_data_o)
   765 {
   766   NOTREACHED;
   767   return FALSE;
   768 }
   769 
   770 
   771 /* Unimplemented -- see .msg.unimpl */
   772 
   773 mps_bool_t mps_msg_peek(mps_space_t mps_space,
   774                     mps_mc_t *mps_mc_o,
   775                     void **msg_data_o)
   776 {
   777   NOTREACHED;
   778   return FALSE;
   779 }
   780 
   781 
   782 /* Unimplemented -- see .msg.unimpl */
   783 
   784 mps_msg_handler_t mps_msg_handler(mps_space_t mps_space,
   785                                   mps_msg_handler_t mps_handler)
   786 {
   787   NOTREACHED;
   788   return NULL;
   789 }

