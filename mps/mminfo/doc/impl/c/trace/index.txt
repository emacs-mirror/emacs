                     GENERIC TRACER IMPLEMENTATION
                              impl.c.trace
                               draft impl
                             drj 1995-10-26

     1 /*  impl.c.trace
     2  *
     3  *                GENERIC TRACER IMPLEMENTATION
     4  *
     5  *  $HopeName$
     6  *
     7  *  Copyright (C) 1995 Harlequin Group, all rights reserved
     8  *
     9  */
    10 
    11 #include "std.h"
    12 #include "lib.h"
    13 #include "mpmconf.h"
    14 #include "ref.h"
    15 #include "refsig.h"
    16 #include "trace.h"
    17 #include "space.h"
    18 #include "pool.h"
    19 #include "root.h"
    20 #include "rootst.h"
    21 #include <limits.h>
    22 
    23 
    24 #ifdef DEBUG_SIGN
    25 static SigStruct TraceSigStruct;
    26 static SigStruct TraceSetSigStruct;
    27 #endif
    28 
    29 
    30 #define TRACEBIT(id) ((Addr)(1uL << (id)))
    31 
    32 
    33 #ifdef DEBUG_ASSERT
    34 
    35 Bool TraceIdIsValid(TraceId id, ValidationType validParam)
    36 {
    37   AVER(id < TRACE_MAX);
    38   return TRUE;
    39 }
    40 
    41 Bool TraceSetIsValid(TraceSet set, ValidationType validParam)
    42 {
    43   AVER(set != NULL);
    44 #ifdef DEBUG_SIGN
    45   AVER(ISVALIDNESTED(Sig, &TraceSetSigStruct));
    46   AVER(set->sig == &TraceSetSigStruct);
    47 #endif
    48   AVER(TRACE_MAX >= ADDRWIDTH || set->bits < TRACEBIT(TRACE_MAX));
    49   return TRUE;
    50 }
    51 
    52 Bool TraceIsValid(Trace trace, ValidationType validParam)
    53 {
    54   RefRank rank;
    55   AVER(trace != NULL);
    56 #ifdef DEBUG_SIGN
    57   AVER(ISVALIDNESTED(Sig, &TraceSigStruct));
    58   AVER(trace->sig == &TraceSigStruct);
    59 #endif
    60   AVER(ISVALIDNESTED(TraceId, trace->id));
    61   AVER(ISVALIDNESTED(DequeNode, &trace->spaceDeque));
    62   AVER(ISVALIDNESTED(Space, trace->space));
    63 /*  AVER(ISVALIDNESTED(RefSig, trace->condemned)); */
    64   for(rank = 0; rank < RefRankMAX; ++rank)
    65     AVER(trace->gray[rank].marked >= trace->gray[rank].scanned);
    66   return TRUE;
    67 }
    68 
    69 #endif /* DEBUG_ASSERT */
    70 
    71 
    72 Error TraceSetInit(TraceSet set)
    73 {
    74   AVER(set != NULL);
    75 
    76   /* Addr is used to implement the TraceSet as a bitset. */
    77   /* Check that it is big enough. */
    78   AVER(TRACE_MAX <= ADDRWIDTH);
    79 
    80   set->bits = (Addr)0;
    81 
    82 #ifdef DEBUG_SIGN
    83   SigInit(&TraceSetSigStruct, "TraceSet");
    84   set->sig = &TraceSetSigStruct;
    85 #endif
    86 
    87   AVER(ISVALID(TraceSet, set));
    88 
    89   return ErrSUCCESS;
    90 }
    91 
    92 void TraceSetFinish(TraceSet set)
    93 {
    94   AVER(ISVALID(TraceSet, set));
    95 #ifdef DEBUG_SIGN
    96   set->sig = SigInvalid;
    97 #endif
    98 }
    99 
   100 void TraceSetAdd(TraceSet set, TraceId id)
   101 {
   102   AVER(ISVALID(TraceSet, set));
   103   AVER(ISVALID(TraceId, id));
   104   
   105   set->bits |= TRACEBIT(id);
   106 }
   107 
   108 void TraceSetDelete(TraceSet set, TraceId id)
   109 {
   110   AVER(ISVALID(TraceSet, set));
   111   AVER(ISVALID(TraceId, id));
   112   
   113   set->bits &= ~TRACEBIT(id);
   114 }
   115 
   116 Bool TraceSetIsMember(TraceSet set, TraceId id)
   117 {
   118   AVER(ISVALID(TraceSet, set));
   119   AVER(ISVALID(TraceId, id));
   120   
   121   return (set->bits & TRACEBIT(id)) != 0;
   122 }
   123 
   124 static Bool find(TraceSet set, TraceId *idReturn)
   125 {
   126   TraceId id;
   127   for(id = 0; id < TRACE_MAX; ++id)
   128     if(!TraceSetIsMember(set, id)) {
   129       *idReturn = id;
   130       return TRUE;
   131     }
   132   return FALSE;
   133 }
   134 
   135 Error TraceInit(Trace trace, Space space)
   136 {
   137   RefRank rank;
   138   TraceId id;
   139 
   140   /* .single-collection */
   141   AVER(TRACE_MAX == 1);
   142 
   143   AVER(trace != NULL);
   144   AVER(ISVALID(Space, space));
   145 
   146   if(!find(SpaceTraceSet(space), &id))
   147     return ErrLIMIT;
   148 
   149   DequeNodeInit(&trace->spaceDeque);
   150   trace->id = id;
   151   trace->space = space;
   152   trace->condemned = RefSigEmpty(SpaceArena(space));
   153   for(rank = 0; rank < RefRankMAX; ++rank) {
   154     trace->gray[rank].scanned = 0;
   155     trace->gray[rank].marked = 0;
   156   }
   157 
   158 #ifdef DEBUG_SIGN
   159   SigInit(&TraceSigStruct, "Trace");
   160   trace->sig = &TraceSigStruct;
   161 #endif
   162   
   163   AVER(ISVALID(Trace, trace));
   164 
   165   TraceSetAdd(SpaceTraceSet(space), id);
   166   DequeAppend(SpaceTraceDeque(space), &trace->spaceDeque);
   167   
   168   return ErrSUCCESS;
   169 }
   170 
   171 void TraceFinish(Trace trace)
   172 {
   173   AVER(ISVALID(Trace, trace));
   174 
   175 #ifdef DEBUG_ASSERT
   176   {
   177     RefRank rank;
   178 
   179     /* Check that all scanning has been done. */
   180     for(rank = 0; rank < RefRankMAX; ++rank)  
   181       AVER(trace->gray[rank].scanned == trace->gray[rank].marked);
   182   }
   183 #endif
   184 
   185   DequeNodeRemove(&trace->spaceDeque);
   186   TraceSetDelete(SpaceTraceSet(trace->space), trace->id);
   187 
   188 #ifdef DEBUG_SIGN
   189   trace->sig = SigInvalid;
   190 #endif
   191 }  
   192 
   193 
   194 Error TraceCreate(Trace *traceReturn, Space space)
   195 {
   196   Error e;
   197   Trace trace;
   198   Pool controlPool;
   199 
   200   AVER(traceReturn != NULL);
   201   AVER(ISVALID(Space, space));
   202   
   203   controlPool = SpaceControlPool(space);
   204 
   205   e = PoolAllocP((void **)&trace, controlPool, sizeof(TraceStruct));
   206   if(e != ErrSUCCESS) return e;
   207   
   208   e = TraceInit(trace, space);
   209   if(e != ErrSUCCESS) {
   210     PoolFreeP(controlPool, (void *)trace, sizeof(TraceStruct));
   211     return e;
   212   }
   213   
   214   *traceReturn = trace;
   215   return ErrSUCCESS;
   216 }
   217 
   218 
   219 void TraceDestroy(Trace trace)
   220 {
   221   Pool controlPool;
   222   AVER(ISVALID(Trace, trace));
   223   controlPool = SpaceControlPool(trace->space);;
   224   TraceFinish(trace);
   225   PoolFreeP(controlPool, (void *)trace, sizeof(TraceStruct));
   226 }
   227 
   228 
   229 Error TraceDescribe(Trace trace, LibStream stream)
   230 {
   231   RefRank rank;
   232 
   233   AVER(ISVALID(Trace, trace));
   234   
   235   LibFormat(stream,
   236             "Trace %p {\n"
   237             "  space = %p\n"
   238             "  condemned refsig = %lX\n",
   239             (void *)trace,
   240             (unsigned long)trace->id,
   241             (void *)trace->space,
   242             (unsigned long)trace->condemned);
   243   
   244   LibFormat(stream, "  rank    marked   scanned\n");
   245   for(rank = 0; rank < RefRankMAX; ++rank)
   246     LibFormat(stream, "  %4d  %8lX  %8lX\n",
   247               rank,
   248               (unsigned long)trace->gray[rank].marked,
   249               (unsigned long)trace->gray[rank].scanned);
   250 
   251   LibFormat(stream, "} Trace %p\n", (void *)trace);
   252 
   253   return ErrSUCCESS;
   254 }
   255 
   256 
   257 TraceId TraceTraceId(Trace trace)
   258 {
   259   AVER(ISVALID(Trace, trace));
   260   return trace->id;
   261 }
   262 
   263 
   264 void TraceCondemn(Trace trace, RefSig refsig)
   265 {
   266   AVER(ISVALID(Trace, trace));
   267   trace->condemned = refsig;
   268 }
   269 
   270 
   271 void TraceMark(Trace trace, RefRank rank, Addr count)
   272 {
   273   AVER(ISVALID(Trace, trace));
   274   AVER(ISVALID(RefRank, rank));
   275   AVER(count > 0);
   276   
   277   trace->gray[rank].marked += count;
   278 }
   279 
   280 void TraceScan(Trace trace, RefRank rank, Addr count)
   281 {
   282   AVER(ISVALID(Trace, trace));
   283   AVER(ISVALID(RefRank, rank));
   284   AVER(count > 0);
   285   
   286   trace->gray[rank].scanned += count;
   287 }
   288 
   289 
   290 Error TraceFix(Trace trace, RefRank rank, Ref *refIO)
   291 {
   292   Arena arena;
   293   Pool pool;
   294   Ref ref;
   295 
   296   AVER(ISVALID(Trace, trace));
   297   AVER(ISVALID(RefRank, rank));
   298   AVER(refIO != NULL);
   299 
   300   arena = SpaceArena(trace->space);
   301   ref = *refIO;
   302   if(RefSigIsMember(trace->condemned, arena, ref))
   303     if(PoolOfAddr(&pool, arena, ref))
   304       return PoolFix(pool, trace, rank, arena, refIO);
   305 
   306   return ErrSUCCESS;
   307 }
   308 
   309 
   310 Error TraceRun(Trace trace)
   311 {
   312   Error e;
   313   RefRank rank;
   314   
   315   AVER(ISVALID(Trace, trace));
   316   
   317   rank = 0;
   318   while(rank < RefRankMAX) {
   319 
   320     if(trace->gray[rank].scanned < trace->gray[rank].marked) {
   321       Deque deque;
   322       DequeNode node;
   323       
   324       deque = SpaceRootDeque(trace->space);
   325       node = DequeFirst(deque);
   326       while(node != DequeSentinel(deque)) {
   327         DequeNode next = DequeNodeNext(node);
   328         Root root = DequeParent(Root, spaceDeque, node);
   329         
   330         e = RootScan(root, trace, rank);
   331         if(e != ErrSUCCESS)
   332    return e;
   333         
   334         node = next;
   335       }
   336 
   337       deque = SpacePoolDeque(trace->space);
   338       node = DequeFirst(deque);
   339       while(node != DequeSentinel(deque)) {
   340         DequeNode next = DequeNodeNext(node);
   341         Pool pool = DEQUENODEELEMENT(Pool, spaceDeque, node);
   342       
   343         e = PoolScan(pool, trace, rank);
   344         if(e != ErrSUCCESS)
   345    return e;
   346 
   347         node = next;
   348       }
   349       
   350       rank = 0;
   351     }
   352     else
   353       ++rank;
   354   }
   355 
   356 #ifdef DEBUG_ASSERT
   357   for(rank = 0; rank < RefRankMAX; ++rank)
   358     AVER(trace->gray[rank].scanned == trace->gray[rank].marked);
   359 #endif
   360   
   361   return ErrSUCCESS;
   362 }

