                          PROTECTION FOR SUNOS
                             impl.c.protsu
                             accepted impl
                           gavinm 1996-09-24

     1 /* impl.c.protsu: PROTECTION FOR SUNOS
     2  *
     3  * $HopeName: MMsrc!protsu.c(trunk.6) $
     4  *
     5  * Copyright (C) 1995 Harlequin Group, all rights reserved
     6  *
     7  * .hack.sigdfl: GCC 2.5.8 produces a warning when we use SIG_DFL with
     8  * -Wstrict-prototypes, which we want.  SIG_DFL is just zero, so we
     9  * have our own definition.  We don't expect SIG_DFL to change, because
    10  * that would break SunOS binaries.  *sigh*
    11  */
    12 
    13 #include "mpm.h"
    14 #include <stdlib.h>
    15 #include <sys/mman.h>
    16 #include <signal.h>
    17 
    18 #ifndef MPS_OS_SU
    19 #error "protsu.c is SunOS 4 specific, but MPS_OS_SU is not set"
    20 #endif
    21 
    22 SRCID(protsu, "$HopeName: MMsrc!protsu.c(trunk.6) $");
    23 
    24 
    25 /* .hack.sigdfl */
    26 #ifndef SIG_DFL
    27 #error "protsu.c expected SIG_DFL to be declared by signal.h"
    28 #else
    29 #undef SIG_DFL
    30 #define SIG_DFL         ((handler_t)0)
    31 #endif
    32 
    33 
    34 /* Fix up unprototyped system calls.  */
    35 /* Note that these are not fixed up by std.h because that only fixes */
    36 /* up discrepancies with ANSI. */
    37 
    38 extern int mprotect(caddr_t addr, int len, int prot);
    39 extern int getpagesize(void);
    40 extern int getpid(void);
    41 typedef void (*handler_t)(int sig, int code,
    42                           struct sigcontext *scp, char *addr);
    43 
    44 
    45 /* Pointer to the previously-installed signal handler, as returned by */
    46 /* signal(3).  See ProtSetup. */
    47 
    48 static handler_t sigNext = NULL;
    49 
    50 
    51 /* sigHandle -- protection signal handler
    52  *
    53  * This is the signal handler installed by ProtSetup to deal with
    54  * protection faults.  It is installed on the SIGSEGV signal.
    55  * It decodes the protection fault details from the signal context
    56  * and passes them to FaultDispatch, which attempts to handle the
    57  * fault and remove its cause.  If the fault is handled, then
    58  * the handler returns and execution resumes.  If it isn't handled,
    59  * then sigHandle does its best to pass the signal on to the
    60  * previously installed signal handler (sigNext).
    61  *
    62  * .sigh.addr: This code assumes that the system will decode the
    63  * address of the protection violation.  SunOS doesn't document
    64  * when this will or will not happen.
    65  *
    66  * .sigh.decode: We can't determine the access mode (read, write, etc.)
    67  * without decoding the faulting instruction.  We don't bother to do
    68  * this yet.  It can be done later, if necessary.
    69  *
    70  * .sigh.size: We also assume that the access only affects the page
    71  * of the faulting address, i.e. is a single word access or a double-
    72  * aligned double-word access.
    73  */
    74 
    75 static void sigHandle(int sig, int code,
    76                       struct sigcontext *scp, char *addr)
    77 {
    78   AVER(sig == SIGSEGV);
    79   AVER(scp != NULL);
    80 
    81   if(code == SEGV_PROT) {
    82     AccessSet mode;
    83     AVER(addr != SIG_NOADDR);           /* .sigh.addr */
    84     mode = AccessREAD | AccessWRITE;    /* .sigh.decode */
    85     if(SpaceAccess((Addr)addr, mode))   /* .sigh.size */
    86       return;
    87   }
    88 
    89   /* The exception was not handled by any known protection structure, */
    90   /* so throw it to the previously installed handler. */
    91   (*sigNext)(sig, code, scp, addr);
    92 }
    93 
    94 
    95 /* sigDefault -- default signal handler
    96  *
    97  * This is a signal handler used as sigNext if the previous handler
    98  * returned by signal(3) was SIG_DFL.  It does its best to get to
    99  * the default handler, which will probably dump core.
   100  */
   101 
   102 static void sigDefault(int sig, int code,
   103                        struct sigcontext *scp, char *addr)
   104 {
   105   UNUSED(sig);
   106   UNUSED(code);
   107   UNUSED(scp);
   108   UNUSED(addr);
   109 
   110   (void)signal(SIGSEGV, SIG_DFL);
   111   kill(getpid(), SIGSEGV);
   112   NOTREACHED;
   113   abort();
   114 }
   115 
   116 
   117 /* ProtSetup -- global protection setup
   118  *
   119  * Under SunOS, the global setup involves installing a signal handler
   120  * on SIGSEGV to catch and handle protection faults (see sigHandle).
   121  * The previous handler is recorded so that it can be reached from
   122  * sigHandle if it fails to handle the fault.
   123  *
   124  * NOTE: There are problems with this approach:
   125  *   1. we can't honor the wishes of the sigvec(2) entry for the
   126  *      previous handler,
   127  *   2. what if this thread is suspended just after calling signal(3)?
   128  *      The sigNext variable will never be initialized!
   129  */
   130 
   131 void ProtSetup(void)
   132 {
   133   handler_t next;
   134 
   135   next = signal(SIGSEGV, sigHandle);
   136 
   137   if(next == SIG_DFL)           /* suicide function */
   138     sigNext = sigDefault;
   139   else if(sigNext != sigHandle) /* already installed? */
   140     sigNext = next;
   141 }
   142 
   143 
   144 /* ProtSet -- set the protection for a page
   145  *
   146  * This is just a thin veneer on top of mprotect(2).
   147  */
   148 
   149 void ProtSet(Addr base, Addr limit, AccessSet mode)
   150 {
   151   int flags;
   152 
   153   AVER(sizeof(int) == sizeof(Addr));
   154   AVER(base < limit);
   155   AVER(base != 0);
   156   AVER(AddrOffset(base, limit) <= INT_MAX); /* should be redundant */
   157 
   158   flags = PROT_READ | PROT_WRITE | PROT_EXEC;
   159   if((mode & AccessWRITE) != 0)
   160     flags = PROT_READ | PROT_EXEC;
   161   if((mode & AccessREAD) != 0)
   162     flags = PROT_NONE;
   163 
   164   if(mprotect((caddr_t)base, (int)AddrOffset(base, limit), flags) != 0)
   165     NOTREACHED;
   166 }
   167 
   168 
   169 /* ProtSync -- synchronize protection settings with hardware
   170  *
   171  * This does nothing under SunOS.
   172  */
   173 
   174 void ProtSync(Space space)
   175 {
   176   NOOP;
   177 }
   178 
   179 
   180 /* ProtTramp -- protection trampoline
   181  *
   182  * The protection trampoline is trivial under SunOS, as there is nothing
   183  * that needs to be done in the dynamic context of the mutator in order
   184  * to catch faults.  (Contrast this with Win32 Structured Exception
   185  * Handling.)
   186  */
   187 
   188 void ProtTramp(void **resultReturn, void *(*f)(void *, size_t),
   189                void *p, size_t s)
   190 {
   191   AVER(f != NULL);
   192   AVER(resultReturn != NULL);
   193 
   194   *resultReturn = (*f)(p, s);
   195 }

