                      MPS-BASED MALLOC REPLACEMENT
                          impl.c.mpsmal.dropin
                             incomplete doc
                           gavinm 1997-10-14

     1 /* impl.c.malloc: MPS-based malloc replacement
     2  *
     3  * $HopeName: MMsrc!mpsmal.c(MMdevel_dropin.5) $
     4  * Copyright (C) 1997 Harlequin Group, all rights reserved.
     5  * 
     6  * .readership: shipped as a part of the product
     7  * .sources: design.product.soft.drop.manual
     8  */
     9 
    10 #include <stdlib.h> /* malloc, free, calloc, realloc */
    11 #include <stddef.h> /* size_t, NULL */
    12 #include <string.h> /* memset */
    13 #include <assert.h> /* assert */
    14 #include "mps.h"
    15 #include "mpscmv.h"
    16 
    17 /* memset has no prototype in SunOS4 headers. */
    18 #ifdef MPS_OS_SU
    19 extern void *memset(void *, int, size_t);
    20 #endif
    21 
    22 
    23 /* header_s -- Block header
    24  * 
    25  * .header: Each block allocated needs to remember its size, so we add
    26  * a header to keep it in.  HEADER_BLOCK and BLOCK_HEADER translate
    27  * between a pointer to the header and a pointer to the block (what
    28  * the caller of malloc gets).
    29  */
    30 
    31 typedef struct header_s {
    32   size_t size;
    33 } header_s;
    34 
    35 #define HEADER_SIZE \
    36   ((sizeof(header_s) + MPS_PF_ALIGN - 1) & ~(MPS_PF_ALIGN - 1))
    37 #define HEADER_BLOCK(header) \
    38   ((void *)((char *)(header) + HEADER_SIZE))
    39 #define BLOCK_HEADER(block) \
    40   ((header_s *)((char *)(block) - HEADER_SIZE))
    41 
    42 
    43 /* State variables */
    44 
    45 static int inited = 0;         /* whether we have initialized the pool */
    46 static mps_space_t space;
    47 static mps_pool_t pool;
    48 
    49 
    50 /* init -- Initialization function
    51  *
    52  * Create a space and a pool of class MV, to be used by malloc.
    53  */
    54 
    55 static mps_res_t init(void)
    56 {
    57   mps_res_t res;
    58 
    59   assert(!inited);
    60 
    61   res = mps_space_create(&space);
    62   if(res) return res;
    63 
    64   res = mps_pool_create(&pool, space, mps_class_mv(),
    65                         (size_t)65536, (size_t)32, (size_t)65536);
    66   if(res) {
    67     mps_space_destroy(space);
    68     return res;
    69   }
    70 
    71   inited = 1;
    72   return MPS_RES_OK;
    73 }
    74 
    75 
    76 /* calloc -- allocate space for an array [7.10.3.1] */
    77 
    78 #define size_tHALF_SIZE (sizeof(size_t) * 8 / 2) /* half the width of 
size_t */
    79 #define size_tSQRT ((size_t)1 << size_tHALF_SIZE)
    80 
    81 void *(calloc)(size_t nmemb, size_t size)
    82 {
    83   size_t nmembHi, sizeHi;  /* the high half-words of the arguments */
    84   size_t nmembLo, sizeLo;    /* the low half-words of the arguments */
    85   size_t total_size;
    86   void *res;
    87 
    88   if(size == 0 || nmemb == 0) return NULL;
    89 
    90   /* Check that the multiplication won't overflow. */
    91   /* .improve.calloc-check: On platforms where you can guarantee the */
    92   /* existence of an integer type twice the size of size_t, this could */
    93   /* just do something like: */
    94   /*   (bigint)nmemb * (bigint)size < (bigint)SIZE_T_MAX */
    95   nmembHi = nmemb >> size_tHALF_SIZE;
    96   nmembLo = nmemb & (size_tSQRT - 1);
    97   sizeHi = size >> size_tHALF_SIZE;
    98   sizeLo = size & (size_tSQRT - 1);
    99   /* At least one of the high half-words must be zero, or we will 
overflow. */
   100   /* If one of them is non-zero, a further check is needed. */
   101   if(!((nmembHi == 0 && sizeHi == 0)
   102        || /* OK, let's do it the hard way. */
   103        (nmembHi == 0
   104  /* Now we know the value of nmemb * size * 2^-size_tHALF_SIZE will */
   105  /* fit into size_t, compute it and verify that its high half is 0. */
   106  /* The multiplications below can't overflow, all args < size_tSQRT. */
   107  && nmemb * sizeHi + ((nmemb * sizeLo) >> size_tHALF_SIZE) <  size_tSQRT)
   108        || /* Or the same thing with nmemb and size swapped. */
   109        (sizeHi == 0
   110  && nmembHi * size + ((nmembLo * size) >> size_tHALF_SIZE) < 
size_tSQRT)))
   111     return NULL;
   112 
   113   total_size = nmemb * size;
   114   res = (malloc)(total_size);
   115   if(res == NULL) return res;
   116 
   117   memset(res, 0, total_size);
   118 
   119   return res;
   120 }
   121 
   122 
   123 /* free -- deallocate space pointed to [7.10.3.2] */
   124 
   125 void (free)(void *ptr)
   126 {
   127   size_t size;
   128   header_s *header;
   129 
   130   if(ptr == NULL) return;
   131 
   132   header = BLOCK_HEADER(ptr);
   133   size = header->size;
   134 
   135   /* detect double frees */
   136   assert(size != 0);
   137   header->size = 0;
   138 
   139   mps_free(pool, header, size);
   140 }
   141 
   142 
   143 /* (malloc) -- allocate space for an object [7.10.3.3] */
   144 
   145 void *(malloc)(size_t size)
   146 {
   147   mps_res_t res;
   148   header_s *header;
   149   size_t total;
   150   void *p;
   151 
   152   if(size == 0) return NULL;
   153 
   154   total = size + HEADER_SIZE;
   155   /* .header.overflow: If adding the header causes the size to overflow 
*/
   156   /* then the request cannot be satisfied. */
   157   if(total <= size) return NULL;
   158 
   159   if(!inited) {
   160     res = init();
   161     if(res) return NULL;
   162   }
   163 
   164   res = mps_alloc(&p, pool, total);
   165   if(res) return NULL;
   166 
   167   header = p;
   168   header->size = total;
   169 
   170   return HEADER_BLOCK(header);
   171 }
   172 
   173 
   174 #define min(a, b) (((a) < (b)) ? (a) : (b))
   175 
   176 
   177 /* realloc -- change size of object [7.10.3.4] */
   178 
   179 void *(realloc)(void *ptr, size_t size)
   180 {
   181   header_s *header;
   182   size_t oldSize;
   183 
   184   if(ptr == NULL) return (malloc)(size);
   185 
   186   /* Get the size and check that it's not a free block. */
   187   header = BLOCK_HEADER(ptr);
   188   oldSize = header->size;
   189   assert(oldSize != 0);
   190 
   191   if(size == oldSize - HEADER_SIZE) return ptr;
   192 
   193   if(size != 0) {
   194     void *newBlock;
   195 
   196     newBlock = (malloc)(size);
   197     if(newBlock != NULL) {
   198       memcpy(newBlock, ptr, min(oldSize - HEADER_SIZE, size));
   199       header->size = 0;
   200       mps_free(pool, header, oldSize);
   201     }
   202     return newBlock;
   203   } else {
   204     header->size = 0;
   205     mps_free(pool, header, oldSize);
   206     return NULL;
   207   }
   208 }

