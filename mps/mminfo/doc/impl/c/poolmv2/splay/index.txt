                        MANUAL VARIABLE POOL, II
                          impl.c.poolmv2.splay
                               draft impl
                           gavinm 1998-06-26

     1 /* impl.c.poolmv2: MANUAL VARIABLE POOL, II
     2  *
     3  * $HopeName: MMsrc!poolmv2.c(MMdevel_gavinm_splay.17) $
     4  * Copyright (C) 1998 Harlequin Group plc.  All rights reserved.
     5  *
     6  * .readership: any MPS developer
     7  *
     8  * .purpose: A manual-variable pool designed to take advantage of
     9  *  placement according to predicted deathtime.
    10  *
    11  * .design: See design.mps.poolmv2
    12  */
    13 
    14 #include "mpm.h"
    15 #include "poolmv2.h"
    16 #include "mpscmv2.h"
    17 #include "abq.h"
    18 #include "meter.h"
    19 
    20 SRCID(poolmv2, "$HopeName: MMsrc!poolmv2.c(MMdevel_gavinm_splay.17) $");
    21 
    22 /* Signatures */
    23 
    24 
    25 #define MV2Sig ((Sig)0x5193F299) /* SIGnature MV2 */
    26 
    27 
    28 /* Private prototypes */
    29 
    30 
    31 typedef struct MV2Struct *MV2;
    32 static Res MV2Init(Pool pool, va_list arg);
    33 static Bool MV2Check(MV2 mv2);
    34 static void MV2Finish(Pool pool);
    35 static Res MV2BufferFill(Seg *segReturn,
    36                          Addr *baseReturn, Addr *limitReturn,
    37                          Pool pool, Buffer buffer, Size minSize);
    38 static void MV2BufferEmpty(Pool pool, Buffer buffer);
    39 static void MV2Free(Pool pool, Addr base, Size size);
    40 static Res MV2Describe(Pool pool, mps_lib_FILE *stream);
    41 static Res MV2SegAlloc(Seg *segReturn, MV2 mv2, Size size, Pool pool);
    42 static void MV2SegFree(MV2 mv2, Seg seg);
    43 static Bool MV2ReturnBlockSegs(MV2 mv2, CBSBlock block, Arena arena);
    44 static void MV2NoteNew(CBS cbs, CBSBlock block);
    45 static void MV2NoteDelete(CBS cbs, CBSBlock block);
    46 static void ABQRefillIfNecessary(MV2 mv2, Size size);
    47 static Bool ABQRefillCallback(CBS cbs, CBSBlock block, void *closureP,
    48                               unsigned long closureS);
    49 static Res MV2ContingencySearch(CBSBlock *blockReturn, CBS cbs,
    50                                 Size min);
    51 static Bool MV2ContingencyCallback(CBS cbs, CBSBlock block, void 
*closureP,
    52                                    unsigned long closureS);
    53 static Bool MV2CheckFit(CBSBlock block, Size min, Arena arena);
    54 static MV2 PoolPoolMV2(Pool pool);
    55 static Pool MV2Pool(MV2 mv2);
    56 static ABQ MV2ABQ(MV2 mv2);
    57 static CBS MV2CBS(MV2 mv2);
    58 static MV2 CBSMV2(CBS cbs);
    59 static SegPref MV2SegPref(MV2 mv2);
    60 
    61 
    62 /* Types */
    63 
    64 
    65 typedef struct MV2Struct 
    66 {
    67   PoolStruct poolStruct;
    68   CBSStruct cbsStruct;          /* The coalescing block structure */
    69   ABQStruct abqStruct;          /* The available block queue */
    70   SegPrefStruct segPrefStruct;  /* The preferences for segments */
    71   /* design.mps.poolmv2:arch.parameters */
    72   Size minSize;                 /* Pool parameter */
    73   Size meanSize;                /* Pool parameter */
    74   Size maxSize;                 /* Pool parameter */
    75   Count fragLimit;              /* Pool parameter */
    76   /* design.mps.poolmv2:arch.overview.abq.reuse.size */
    77   Size reuseSize;               /* Size at which blocks are recycled */
    78   /* design.mps.poolmv2:arch.ap.fill.size */
    79   Size fillSize;                /* Size of pool segments */
    80   /* design.mps.poolmv2:arch.contingency */
    81   Size availLimit;              /* available >= availLimit => 
contingency */
    82   /* design.mps.poolmv2:impl.c.free.merge.segment.overflow */
    83   Bool abqOverflow;             /* ABQ dropped some candidates */
    84   /* design.mps.poolmv2:arch.ap.no-fit.* */
    85   Bool splinter;                /* Saved splinter */
    86   Seg splinterSeg;              /* Saved splinter seg */
    87   Addr splinterBase;            /* Saved splinter base */
    88   Addr splinterLimit;           /* Saved splinter size */
    89 
    90   /* pool accounting --- one of these first four is redundant, but
    91      size and available are used to implement fragmentation policy */
    92   Size size;                    /* size of segs in pool */
    93   Size allocated;               /* bytes allocated to mutator */
    94   Size available;               /* bytes available for allocation */
    95   Size unavailable;             /* bytes lost to fragmentation */
    96   
    97   /* pool meters*/
    98   METER_DECL(segAllocs);
    99   METER_DECL(segFrees);
   100   METER_DECL(bufferFills);
   101   METER_DECL(bufferEmpties);
   102   METER_DECL(poolFrees);
   103   METER_DECL(poolSize);
   104   METER_DECL(poolAllocated);
   105   METER_DECL(poolAvailable);
   106   METER_DECL(poolUnavailable);
   107   METER_DECL(poolUtilization);
   108   /* abq meters */
   109   METER_DECL(finds);
   110   METER_DECL(overflows);
   111   METER_DECL(underflows);
   112   METER_DECL(refills);
   113   METER_DECL(refillPushes);
   114   METER_DECL(refillOverflows);
   115   METER_DECL(refillReturns);
   116   /* fragmentation meters */
   117   METER_DECL(perfectFits);
   118   METER_DECL(firstFits);
   119   METER_DECL(secondFits);
   120   METER_DECL(failures);
   121   /* contingency meters */
   122   METER_DECL(emergencyContingencies);
   123   METER_DECL(fragLimitContingencies);
   124   METER_DECL(contingencySearches);
   125   METER_DECL(contingencyHardSearches);
   126   /* splinter meters */
   127   METER_DECL(splinters);
   128   METER_DECL(splintersUsed);
   129   METER_DECL(splintersDropped);
   130   METER_DECL(sawdust);
   131   /* exception meters */
   132   METER_DECL(exceptions);
   133   METER_DECL(exceptionSplinters);
   134   METER_DECL(exceptionReturns);
   135   
   136   Sig sig;
   137 } MV2Struct;
   138 
   139 
   140 static PoolClassStruct PoolClassMV2Struct =
   141 {
   142   PoolClassSig,
   143   "MV2",                        /* name */
   144   sizeof(MV2Struct),            /* size */
   145   offsetof(MV2Struct, poolStruct), /* offset */
   146   /* --- should we implement AttrALLOC? */
   147   AttrFREE | AttrBUF | AttrBUF_RESERVE,/* attr */
   148   MV2Init,                      /* init */
   149   MV2Finish,                    /* finish */
   150   PoolNoAlloc,                  /* alloc */
   151   MV2Free,                      /* free */
   152   PoolTrivBufferInit,           /* bufferInit */
   153   MV2BufferFill,                /* bufferFill */
   154   MV2BufferEmpty,               /* bufferEmpty */
   155   PoolTrivBufferFinish,         /* bufferFinish */
   156   PoolNoTraceBegin,             /* traceBegin */
   157   PoolNoAccess,                 /* access */
   158   PoolNoWhiten,                 /* whiten */
   159   PoolNoGrey,                   /* mark */
   160   PoolNoBlacken,                /* blacken */
   161   PoolNoScan,                   /* scan */
   162   PoolNoFix,                    /* fix */
   163   PoolNoFix,                    /* emergency fix */
   164   PoolNoReclaim,                /* relcaim */
   165   PoolNoBenefit,                /* benefit */
   166   PoolNoAct,                    /* act */
   167   PoolNoWalk,                   /* walk */
   168   MV2Describe,                  /* describe */
   169   PoolClassSig                  /* impl.h.mpmst.class.end-sig */
   170 };
   171 
   172 
   173 /* Macros */
   174 
   175 
   176 /* .trans.something the C language sucks */
   177 #define unless(cond) if (!(cond))
   178 #define when(cond) if (cond)
   179 
   180 
   181 /* Accessors */
   182 
   183 
   184 static MV2 PoolPoolMV2(Pool pool) 
   185 {
   186   return PARENT(MV2Struct, poolStruct, pool);
   187 }
   188 
   189 
   190 static Pool MV2Pool(MV2 mv2) 
   191 {
   192   return &mv2->poolStruct;
   193 }
   194 
   195 
   196 static ABQ MV2ABQ(MV2 mv2)
   197 {
   198   return &mv2->abqStruct;
   199 }
   200 
   201 
   202 static CBS MV2CBS(MV2 mv2) 
   203 {
   204   return &mv2->cbsStruct;
   205 }
   206 
   207 
   208 static MV2 CBSMV2(CBS cbs)
   209 {
   210   return PARENT(MV2Struct, cbsStruct, cbs);
   211 }
   212 
   213 
   214 static SegPref MV2SegPref(MV2 mv2)
   215 {
   216   return &mv2->segPrefStruct;
   217 }
   218 
   219 
   220 /* Methods */
   221 
   222 
   223 /* MV2Init -- initialize an MV2 pool
   224  *
   225  * Parameters are:
   226  * minSize, meanSize, maxSize, reserveDepth, fragLimit
   227  */
   228 static Res MV2Init(Pool pool, va_list arg)
   229 {
   230   Arena arena;
   231   Size minSize, meanSize, maxSize, reuseSize, fillSize;
   232   Count reserveDepth, abqDepth, fragLimit;
   233   MV2 mv2;
   234   Res res;
   235 
   236   AVERT(Pool, pool);
   237   mv2 = PoolPoolMV2(pool);
   238   /* can't AVERT mv2, yet */
   239   arena = PoolArena(pool);
   240   AVERT(Arena, arena);
   241   
   242   /* --- Should there be a ResBADARG ? */
   243   minSize = va_arg(arg, Size);
   244   unless (minSize > 0)
   245     return ResLIMIT;
   246   meanSize = va_arg(arg, Size);
   247   unless (meanSize >= minSize)
   248     return ResLIMIT;
   249   maxSize = va_arg(arg, Size);
   250   unless (maxSize >= meanSize)
   251     return ResLIMIT;
   252   /* --- check that maxSize is not too large */
   253   reserveDepth = va_arg(arg, Count);
   254   unless (reserveDepth > 0)
   255     return ResLIMIT;
   256   /* --- check that reserveDepth is not too large or small */
   257   fragLimit = va_arg(arg, Count);
   258   unless (fragLimit >= 0 && fragLimit <= 100)
   259     return ResLIMIT;
   260 
   261   /* see design.mps.poolmv2:arch.parameters */
   262   fillSize = SizeAlignUp(maxSize, ArenaAlign(arena));
   263   /* see design.mps.poolmv2:arch.fragmentation.internal */
   264   reuseSize = 2 * fillSize;
   265   abqDepth = (reserveDepth * meanSize + reuseSize - 1) / reuseSize;
   266   /* keep the abq from being useless */
   267   if (abqDepth < 3)
   268     abqDepth = 3;
   269 
   270   res = CBSInit(arena, MV2CBS(mv2), &MV2NoteNew, &MV2NoteDelete,
   271                 reuseSize, TRUE);
   272   if (res != ResOK)
   273     goto failCBS;
   274   
   275   res = ABQInit(arena, MV2ABQ(mv2), abqDepth);
   276   if (res != ResOK)
   277     goto failABQ;
   278 
   279   {
   280     RefSet refset;
   281     /* --- Loci needed here, what should the pref be? */
   282     /* --- why not SegPrefDefault(MV2SegPref)? */
   283     *MV2SegPref(mv2) = *SegPrefDefault();
   284     /* +++ Get own RefSet */
   285     refset = RefSetComp(ARENA_DEFAULT_REFSET);
   286     SegPrefExpress(MV2SegPref(mv2), SegPrefRefSet, (void *)&refset);
   287   }
   288 
   289   mv2->reuseSize = reuseSize;
   290   mv2->fillSize = fillSize;
   291   mv2->abqOverflow = FALSE;
   292   mv2->minSize = minSize;
   293   mv2->meanSize = meanSize;
   294   mv2->maxSize = maxSize;
   295   mv2->fragLimit = fragLimit;
   296   mv2->splinter = FALSE;
   297   mv2->splinterSeg = NULL;
   298   mv2->splinterBase = (Addr)0;
   299   mv2->splinterLimit = (Addr)0;
   300   
   301   /* accounting */
   302   mv2->size = 0;
   303   mv2->allocated = 0;
   304   mv2->available = 0;
   305   mv2->availLimit = 0;
   306   mv2->unavailable = 0;
   307   
   308   /* meters*/
   309   METER_INIT(mv2->segAllocs, "segment allocations");
   310   METER_INIT(mv2->segFrees, "segment frees");
   311   METER_INIT(mv2->bufferFills, "buffer fills");
   312   METER_INIT(mv2->bufferEmpties, "buffer empties");
   313   METER_INIT(mv2->poolFrees, "pool frees");
   314   METER_INIT(mv2->poolSize, "pool size");
   315   METER_INIT(mv2->poolAllocated, "pool allocated");
   316   METER_INIT(mv2->poolAvailable, "pool available");
   317   METER_INIT(mv2->poolUnavailable, "pool unavailable");
   318   METER_INIT(mv2->poolUtilization, "pool utilization");
   319   METER_INIT(mv2->finds, "ABQ finds");
   320   METER_INIT(mv2->overflows, "ABQ overflows");
   321   METER_INIT(mv2->underflows, "ABQ underflows");
   322   METER_INIT(mv2->refills, "ABQ refills");
   323   METER_INIT(mv2->refillPushes, "ABQ refill pushes");
   324   METER_INIT(mv2->refillOverflows, "ABQ refill overflows");
   325   METER_INIT(mv2->refillReturns, "ABQ refill returns");
   326   METER_INIT(mv2->perfectFits, "perfect fits");
   327   METER_INIT(mv2->firstFits, "first fits");
   328   METER_INIT(mv2->secondFits, "second fits");
   329   METER_INIT(mv2->failures, "failures");
   330   METER_INIT(mv2->emergencyContingencies, "emergency contingencies");
   331   METER_INIT(mv2->fragLimitContingencies, "fragmentation limit 
contingencies");
   332   METER_INIT(mv2->contingencySearches, "contingency searches");
   333   METER_INIT(mv2->contingencyHardSearches, "contingency hard searches");
   334   METER_INIT(mv2->splinters, "splinters");
   335   METER_INIT(mv2->splintersUsed, "splinters used");
   336   METER_INIT(mv2->splintersDropped, "splinters dropped");
   337   METER_INIT(mv2->sawdust, "sawdust");
   338   METER_INIT(mv2->exceptions, "exceptions");
   339   METER_INIT(mv2->exceptionSplinters, "exception splinters");
   340   METER_INIT(mv2->exceptionReturns, "exception returns");
   341 
   342   mv2->sig = MV2Sig;
   343 
   344   AVERT(MV2, mv2);
   345   return ResOK;
   346 
   347 failABQ:
   348   CBSFinish(MV2CBS(mv2));
   349 failCBS:
   350   AVER(res != ResOK);
   351   return res;
   352 }
   353 
   354 
   355 /* MV2Check -- validate an MV2 Pool
   356  */
   357 static Bool MV2Check(MV2 mv2)
   358 {
   359   CHECKS(MV2, mv2);
   360   CHECKD(Pool, &mv2->poolStruct);
   361   CHECKL(mv2->poolStruct.class == &PoolClassMV2Struct);
   362   CHECKD(CBS, &mv2->cbsStruct);
   363   /* CHECKL(CBSCheck(MV2CBS(mv2))); */
   364   CHECKD(ABQ, &mv2->abqStruct);
   365   /* CHECKL(ABQCheck(MV2ABQ(mv2))); */
   366   CHECKD(SegPref, &mv2->segPrefStruct);
   367   CHECKL(mv2->reuseSize >= 2 * mv2->fillSize);
   368   CHECKL(mv2->fillSize >= mv2->maxSize);
   369   CHECKL(mv2->maxSize >= mv2->meanSize);
   370   CHECKL(mv2->meanSize >= mv2->minSize);
   371   CHECKL(mv2->minSize > 0);
   372   CHECKL(mv2->fragLimit >= 0 && mv2->fragLimit <= 100);
   373   CHECKL(mv2->availLimit == mv2->size * mv2->fragLimit / 100);
   374   CHECKL(BoolCheck(mv2->abqOverflow));
   375   CHECKL(BoolCheck(mv2->splinter));
   376   if (mv2->splinter) {
   377     CHECKL(AddrOffset(mv2->splinterBase, mv2->splinterLimit) >=
   378            mv2->minSize);
   379     /* CHECKD(Seg, mv2->splinterSeg); */
   380     CHECKL(SegCheck(mv2->splinterSeg));
   381     CHECKL(mv2->splinterBase >= SegBase(mv2->splinterSeg));
   382     CHECKL(mv2->splinterLimit <= SegLimit(mv2->splinterSeg));
   383   }
   384   CHECKL(mv2->size == mv2->allocated + mv2->available +
   385          mv2->unavailable);
   386   /* --- could check that sum of segment sizes == mv2->size */
   387   
   388   /* --- check meters? */
   389 
   390   return TRUE;
   391 }
   392 
   393 
   394 /* MV2Finish -- finish an MV2 pool
   395  */
   396 static void MV2Finish(Pool pool)
   397 {
   398   MV2 mv2;
   399   Arena arena;
   400   Ring ring;
   401   Ring node, nextNode;
   402   
   403   AVERT(Pool, pool);
   404   mv2 = PoolPoolMV2(pool);
   405   AVERT(MV2, mv2);
   406   arena = PoolArena(pool);
   407   AVERT(Arena, arena);
   408 
   409   EVENT_P(MV2Finish, mv2);
   410 
   411   /* Free the segments in the pool */
   412   ring = PoolSegRing(pool);
   413   RING_FOR(node, ring, nextNode) {
   414     MV2SegFree(mv2, SegOfPoolRing(node));
   415   }
   416 
   417   /* Finish the ABQ and CBS structures */
   418   ABQFinish(arena, MV2ABQ(mv2));
   419   CBSFinish(MV2CBS(mv2));
   420 
   421   mv2->sig = SigInvalid;
   422 }
   423 
   424 
   425 /* MV2BufferFill -- refill an allocation buffer from an MV2 pool
   426  *
   427  * See design.mps.poolmv2:impl.c.ap.fill
   428  */
   429 static Res MV2BufferFill(Seg *segReturn,
   430                          Addr *baseReturn, Addr *limitReturn,
   431                          Pool pool, Buffer buffer, Size minSize)
   432 {
   433   Seg seg;
   434   MV2 mv2;
   435   Res res;
   436   Addr base, limit;
   437   Arena arena;
   438   Size alignedSize, fillSize;
   439   CBSBlock block;
   440 
   441   AVER(segReturn != NULL);
   442   AVER(baseReturn != NULL);
   443   AVER(limitReturn != NULL);
   444   AVERT(Pool, pool);
   445   mv2 = PoolPoolMV2(pool);
   446   AVERT(MV2, mv2);
   447   AVERT(Buffer, buffer);
   448   AVER(BufferIsReset(buffer));
   449   AVER(minSize > 0);
   450   AVER(SizeIsAligned(minSize, pool->alignment));
   451 
   452   arena = PoolArena(pool);
   453   fillSize = mv2->fillSize;
   454   alignedSize = SizeAlignUp(minSize, ArenaAlign(arena));
   455 
   456   /* design.mps.poolmv2:arch.ap.no-fit.oversize */
   457   /* Allocate oversize blocks exactly, directly from the arena */
   458   if (minSize > fillSize) {
   459     res = MV2SegAlloc(&seg, mv2, alignedSize, pool);
   460     if (res == ResOK) {
   461       base = SegBase(seg);
   462       /* only allocate this block in the segment */
   463       limit = AddrAdd(base, minSize);
   464       mv2->available -= alignedSize - minSize;
   465       mv2->unavailable += alignedSize - minSize;
   466       AVER(mv2->size == mv2->allocated + mv2->available +
   467            mv2->unavailable);
   468       METER_ACC(mv2->exceptions, minSize);
   469       METER_ACC(mv2->exceptionSplinters, alignedSize - minSize);
   470       goto done;
   471     }
   472     /* --- There cannot be a segment big enough to hold this object in
   473        the free list, although there may be segments that could be
   474        coalesced to do so. */
   475     AVER(res != ResOK);
   476     return res;
   477   }
   478 
   479   /* design.mps.poolmv2:arch.ap.no-fit.return */
   480   /* Use any splinter, if available */
   481   if (mv2->splinter) {
   482     base = mv2->splinterBase;
   483     limit = mv2->splinterLimit;
   484     if(AddrOffset(base, limit) >= minSize) {
   485       seg = mv2->splinterSeg;
   486       mv2->splinter = FALSE;
   487       METER_ACC(mv2->splintersUsed, AddrOffset(base, limit));
   488       goto done;
   489     }
   490   }
   491   
   492   /* Attempt to retrieve a free block from the ABQ */
   493   ABQRefillIfNecessary(mv2, minSize);
   494   res = ABQPeek(MV2ABQ(mv2), &block);
   495   if (res != ResOK) {
   496     METER_ACC(mv2->underflows, minSize);
   497     /* design.mps.poolmv2:arch.contingency.fragmentation-limit */
   498     if (mv2->available >=  mv2->availLimit) {
   499         METER_ACC(mv2->fragLimitContingencies, minSize);
   500         res = MV2ContingencySearch(&block, MV2CBS(mv2), minSize);
   501     }
   502   }
   503   else {
   504     METER_ACC(mv2->finds, minSize);
   505   }
   506 found:
   507   if (res == ResOK) {
   508     base = CBSBlockBase(block);
   509     limit = CBSBlockLimit(block);
   510     {
   511       Bool b = SegOfAddr(&seg, arena, base);
   512       AVER(b);
   513     }
   514     /* Only pass out segments --- may not be the best long-term policy
   515      */
   516     {
   517       Addr segLimit = SegLimit(seg);
   518 
   519       if (limit <= segLimit) {
   520         /* perfect fit */
   521         METER_ACC(mv2->perfectFits, AddrOffset(base, limit));
   522       }
   523       else if (AddrOffset(base, segLimit) >= minSize) {
   524         /* fit in 1st segment */
   525         limit = segLimit;
   526         METER_ACC(mv2->firstFits, AddrOffset(base, limit));
   527       }
   528       else {
   529         /* fit in 2nd second segment */
   530         base = segLimit;
   531         {
   532           Bool b = SegOfAddr(&seg, arena, base);
   533           AVER(b);
   534         }
   535         segLimit = SegLimit(seg);
   536         if (limit > segLimit)
   537           limit = segLimit;
   538         METER_ACC(mv2->secondFits, AddrOffset(base, limit));
   539       }
   540     }
   541     {
   542       Res r = CBSDelete(MV2CBS(mv2), base, limit);
   543       AVER(r == ResOK);
   544     }
   545     goto done;
   546   }
   547   
   548   /* Attempt to request a block from the arena */
   549   /* see design.mps.poolmv2:impl.c.free.merge.segment */
   550   res = MV2SegAlloc(&seg, mv2, fillSize, pool);
   551   if (res == ResOK) {
   552     base = SegBase(seg);
   553     limit = SegLimit(seg);
   554     goto done;
   555   }
   556   
   557   /* Try contingency */
   558   METER_ACC(mv2->emergencyContingencies, minSize);
   559   res = MV2ContingencySearch(&block, MV2CBS(mv2), minSize);
   560   if (res == ResOK){
   561     goto found;
   562   }
   563 
   564   /* --- ask other pools to free reserve and retry */
   565   METER_ACC(mv2->failures, minSize);
   566   AVER(res != ResOK);
   567   return res;
   568   
   569 done:
   570   *segReturn = seg;
   571   *baseReturn = base;
   572   *limitReturn = limit;
   573   mv2->available -= AddrOffset(base, limit);
   574   mv2->allocated += AddrOffset(base, limit);
   575   AVER(mv2->size == mv2->allocated + mv2->available +
   576        mv2->unavailable);
   577   METER_ACC(mv2->poolUtilization, mv2->allocated * 100 / mv2->size);
   578   METER_ACC(mv2->poolUnavailable, mv2->unavailable);
   579   METER_ACC(mv2->poolAvailable, mv2->available);
   580   METER_ACC(mv2->poolAllocated, mv2->allocated);
   581   METER_ACC(mv2->poolSize, mv2->size);
   582   METER_ACC(mv2->bufferFills, AddrOffset(base, limit));
   583   EVENT_PPWAW(MV2BufferFill, mv2, buffer, minSize, base,
   584               AddrOffset(base, limit));
   585   AVER(AddrOffset(base, limit) >= minSize);
   586   return ResOK;
   587 }
   588 
   589 
   590 /* MV2BufferEmpty -- return an unusable portion of a buffer to the MV2
   591  * pool
   592  *
   593  * See design.mps.poolmv2:impl.c.ap.empty
   594  */
   595 static void MV2BufferEmpty(Pool pool, Buffer buffer)
   596 {
   597   MV2 mv2;
   598   Seg seg;
   599   Addr base, limit;
   600   Size size;
   601 
   602   AVERT(Pool, pool);
   603   mv2 = PoolPoolMV2(pool);
   604   AVERT(MV2, mv2);
   605   AVERT(Buffer, buffer);
   606   AVER(!BufferIsReset(buffer));
   607   AVER(BufferIsReady(buffer));
   608 
   609   seg = BufferSeg(buffer);
   610   base = BufferGetInit(buffer);
   611   limit = BufferLimit(buffer);
   612   size = AddrOffset(base, limit);
   613   
   614   EVENT_PPW(MV2BufferEmpty, mv2, buffer, size);
   615   if (size == 0)
   616     return;
   617 
   618   mv2->available += size;
   619   mv2->allocated -= size;
   620   AVER(mv2->size == mv2->allocated + mv2->available +
   621        mv2->unavailable);
   622   METER_ACC(mv2->poolUtilization, mv2->allocated * 100 / mv2->size);
   623   METER_ACC(mv2->poolUnavailable, mv2->unavailable);
   624   METER_ACC(mv2->poolAvailable, mv2->available);
   625   METER_ACC(mv2->poolAllocated, mv2->allocated);
   626   METER_ACC(mv2->poolSize, mv2->size);
   627   METER_ACC(mv2->bufferEmpties, size);
   628 
   629   /* design.mps.poolmv2:arch.ap.no-fit.splinter */
   630   if (size < mv2->minSize) {
   631     Res res = CBSInsert(MV2CBS(mv2), base, limit);
   632     AVER(res == ResOK);
   633     METER_ACC(mv2->sawdust, size);
   634     return;
   635   }
   636 
   637   METER_ACC(mv2->splinters, size);
   638   /* design.mps.poolmv2:arch.ap.no-fit.return */
   639   if (mv2->splinter) {
   640     Size oldSize = AddrOffset(mv2->splinterBase, mv2->splinterLimit);
   641 
   642     /* Old better, drop new */
   643     if (size < oldSize) {
   644       Res res = CBSInsert(MV2CBS(mv2), base, limit);
   645       AVER(res == ResOK);
   646       METER_ACC(mv2->splintersDropped, size);
   647       return;
   648     }
   649     else {
   650       /* New better, drop old */
   651       Res res = CBSInsert(MV2CBS(mv2), mv2->splinterBase,
   652      mv2->splinterLimit);
   653       AVER(res == ResOK);
   654       METER_ACC(mv2->splintersDropped, oldSize);
   655     }
   656   }
   657 
   658   mv2->splinter = TRUE;
   659   mv2->splinterSeg = seg;
   660   mv2->splinterBase = base;
   661   mv2->splinterLimit = limit;
   662 }
   663 
   664 
   665 /* MV2Free -- free a block (previously allocated from a buffer) that
   666  * is no longer in use
   667  *
   668  * see design.poolmv2.impl.c.free
   669  */
   670 static void MV2Free(Pool pool, Addr base, Size size)
   671 { 
   672   MV2 mv2;
   673   Addr limit;
   674 
   675   AVERT(Pool, pool);
   676   mv2 = PoolPoolMV2(pool);
   677   AVERT(MV2, mv2);
   678   AVER(base != (Addr)0);
   679   AVER(size > 0);
   680 
   681 
   682   /* We know the buffer observes pool->alignment  */
   683   size = SizeAlignUp(size, pool->alignment);
   684   limit = AddrAdd(base, size);
   685   METER_ACC(mv2->poolFrees, size);
   686   mv2->available += size;
   687   mv2->allocated -= size;
   688   AVER(mv2->size == mv2->allocated + mv2->available +
   689        mv2->unavailable);
   690   METER_ACC(mv2->poolUtilization, mv2->allocated * 100 / mv2->size);
   691   METER_ACC(mv2->poolUnavailable, mv2->unavailable);
   692   METER_ACC(mv2->poolAvailable, mv2->available);
   693   METER_ACC(mv2->poolAllocated, mv2->allocated);
   694   METER_ACC(mv2->poolSize, mv2->size);
   695   
   696   /* design.mps.poolmv2:arch.ap.no-fit.oversize.policy */
   697   /* Return exceptional blocks directly to arena */
   698   if (size > mv2->fillSize) {
   699     Seg seg;
   700     {
   701       Bool b = SegOfAddr(&seg, PoolArena(pool), base);
   702       AVER(b);
   703     }
   704     AVER(base == SegBase(seg));
   705     AVER(limit <= SegLimit(seg));
   706     mv2->available += SegSize(seg) - size;
   707     mv2->unavailable -= SegSize(seg) - size;
   708     AVER(mv2->size == mv2->allocated + mv2->available +
   709          mv2->unavailable);
   710     METER_ACC(mv2->exceptionReturns, SegSize(seg));
   711     if (SegBuffer(seg) != NULL)
   712       BufferDetach(SegBuffer(seg), MV2Pool(mv2));
   713     MV2SegFree(mv2, seg);
   714     return;
   715   }
   716   
   717   {
   718     Res res = CBSInsert(MV2CBS(mv2), base, limit);
   719     AVER(res == ResOK);
   720   }
   721 }
   722 
   723 
   724 /* MV2Describe -- describe an MV2 pool
   725  */
   726 static Res MV2Describe(Pool pool, mps_lib_FILE *stream)
   727 {
   728   Res res;
   729   MV2 mv2;
   730 
   731   AVERT(Pool, pool);
   732   mv2 = PoolPoolMV2(pool);
   733   AVERT(MV2, mv2);
   734   AVER(stream != NULL);
   735 
   736   res = WriteF(stream,
   737         "MV2 $P\n{\n", (WriteFP)mv2,
   738         "  minSize: $U \n", (WriteFU)mv2->minSize,
   739         "  meanSize: $U \n", (WriteFU)mv2->meanSize,
   740         "  maxSize: $U \n", (WriteFU)mv2->maxSize,
   741         "  fragLimit: $U \n", (WriteFU)mv2->fragLimit,
   742         "  reuseSize: $U \n", (WriteFU)mv2->reuseSize,
   743         "  fillSize: $U \n", (WriteFU)mv2->fillSize,
   744         "  availLimit: $U \n", (WriteFU)mv2->availLimit,
   745         "  abqOverflow: $S \n", mv2->abqOverflow?"TRUE":"FALSE",
   746         "  splinter: $S \n", mv2->splinter?"TRUE":"FALSE",
   747         "  splinterSeg: $P \n", (WriteFP)mv2->splinterSeg,
   748         "  splinterBase: $A \n", (WriteFA)mv2->splinterBase,
   749         "  splinterLimit: $A \n", (WriteFU)mv2->splinterLimit,
   750         "  size: $U \n", (WriteFU)mv2->size,
   751         "  allocated: $U \n", (WriteFU)mv2->allocated,
   752         "  available: $U \n", (WriteFU)mv2->available,
   753         "  unavailable: $U \n", (WriteFU)mv2->unavailable,
   754         NULL);
   755   if(res != ResOK)
   756     return res;
   757 
   758   res = CBSDescribe(MV2CBS(mv2), stream);
   759   if(res != ResOK)
   760     return res;
   761 
   762   res = ABQDescribe(MV2ABQ(mv2), stream);
   763   if(res != ResOK)
   764     return res;
   765 
   766   /* --- deal with non-Ok res's */
   767   METER_WRITE(mv2->segAllocs, stream);
   768   METER_WRITE(mv2->segFrees, stream);
   769   METER_WRITE(mv2->bufferFills, stream);
   770   METER_WRITE(mv2->bufferEmpties, stream);
   771   METER_WRITE(mv2->poolFrees, stream);
   772   METER_WRITE(mv2->poolSize, stream);
   773   METER_WRITE(mv2->poolAllocated, stream);
   774   METER_WRITE(mv2->poolAvailable, stream);
   775   METER_WRITE(mv2->poolUnavailable, stream);
   776   METER_WRITE(mv2->poolUtilization, stream);
   777   METER_WRITE(mv2->finds, stream);
   778   METER_WRITE(mv2->overflows, stream);
   779   METER_WRITE(mv2->underflows, stream);
   780   METER_WRITE(mv2->refills, stream);
   781   METER_WRITE(mv2->refillPushes, stream);
   782   METER_WRITE(mv2->refillOverflows, stream);
   783   METER_WRITE(mv2->refillReturns, stream);
   784   METER_WRITE(mv2->perfectFits, stream);
   785   METER_WRITE(mv2->firstFits, stream);
   786   METER_WRITE(mv2->secondFits, stream);
   787   METER_WRITE(mv2->failures, stream);
   788   METER_WRITE(mv2->emergencyContingencies, stream);
   789   METER_WRITE(mv2->fragLimitContingencies, stream);
   790   METER_WRITE(mv2->contingencySearches, stream);
   791   METER_WRITE(mv2->contingencyHardSearches, stream);
   792   METER_WRITE(mv2->splinters, stream);
   793   METER_WRITE(mv2->splintersUsed, stream);
   794   METER_WRITE(mv2->splintersDropped, stream);
   795   METER_WRITE(mv2->sawdust, stream);
   796   METER_WRITE(mv2->exceptions, stream);
   797   METER_WRITE(mv2->exceptionSplinters, stream);
   798   METER_WRITE(mv2->exceptionReturns, stream);
   799   
   800   res = WriteF(stream, "}\n", NULL);
   801   if(res != ResOK)
   802     return res;
   803 
   804   return ResOK;               
   805 }
   806 
   807 
   808 /* Pool Interface */
   809 
   810 
   811 /* PoolClassMV2 -- the Pool (sub-)Class for an MV2 pool
   812  */
   813 PoolClass PoolClassMV2(void)
   814 {
   815   return &PoolClassMV2Struct;
   816 }
   817 
   818 
   819 /* MPS Interface */
   820 
   821 
   822 /*
   823  * mps_class_mv2 -- the class of an mv2 pool
   824  */
   825 mps_class_t mps_class_mv2(void)
   826 {
   827   return (mps_class_t)(PoolClassMV2());
   828 }
   829 
   830 
   831 /* MPS Interface extensions --- should these be pool generics? */
   832 
   833 
   834 /* mps_mv2_size -- number of bytes committed to the pool
   835  */
   836 size_t mps_mv2_size(mps_pool_t mps_pool)
   837 {
   838   Pool pool;
   839   MV2 mv2;
   840 
   841   pool = (Pool)mps_pool;
   842 
   843   AVERT(Pool, pool);
   844   mv2 = PoolPoolMV2(pool);
   845   AVERT(MV2, mv2);
   846 
   847   return (size_t)mv2->size;
   848 } 
   849 
   850 
   851 /* mps_mv2_free_size -- number of bytes comitted to the pool that are
   852  * available for allocation
   853  */
   854 size_t mps_mv2_free_size(mps_pool_t mps_pool)
   855 {
   856   Pool pool;
   857   MV2 mv2;
   858 
   859   pool = (Pool)mps_pool;
   860 
   861   AVERT(Pool, pool);
   862   mv2 = PoolPoolMV2(pool);
   863   AVERT(MV2, mv2);
   864 
   865   return (size_t)mv2->available;
   866 }
   867 
   868 
   869 /* Internal methods */
   870 
   871 
   872 /* MV2SegAlloc -- encapsulates SegAlloc with associated accounting and
   873  * metering
   874  */
   875 static Res MV2SegAlloc(Seg *segReturn, MV2 mv2, Size size, Pool pool)
   876 {
   877   Res res = SegAlloc(segReturn, MV2SegPref(mv2), size, pool);
   878 
   879   if (res == ResOK) {
   880     Size segSize = SegSize(*segReturn);
   881     
   882     /* see design.mps.poolmv2:arch.fragmentation.internal */
   883     AVER(segSize >= mv2->fillSize);
   884     mv2->size += segSize;
   885     mv2->available += segSize;
   886     mv2->availLimit = mv2->size * mv2->fragLimit / 100;
   887     AVER(mv2->size == mv2->allocated + mv2->available +
   888          mv2->unavailable);
   889     METER_ACC(mv2->segAllocs, segSize);
   890   }
   891   return res;
   892 }
   893   
   894 
   895 /* MV2SegFree -- encapsulates SegFree with associated accounting and
   896  * metering
   897  */
   898 static void MV2SegFree(MV2 mv2, Seg seg) 
   899 {
   900   Size size = SegSize(seg);
   901 
   902   mv2->available -= size;
   903   mv2->size -= size;
   904   mv2->availLimit = mv2->size * mv2->fragLimit / 100;
   905   AVER(mv2->size == mv2->allocated + mv2->available +
   906        mv2->unavailable);
   907   SegFree(seg);
   908   METER_ACC(mv2->segFrees, size);
   909 }
   910 
   911 
   912 /* MV2ReturnBlockSegs -- return (interior) segments of a block to the
   913  * arena
   914  */
   915 static Bool MV2ReturnBlockSegs(MV2 mv2, CBSBlock block, Arena arena) 
   916 {
   917   Addr base, limit;
   918   Bool success = FALSE;
   919     
   920   base = CBSBlockBase(block);
   921   limit = CBSBlockLimit(block);
   922 
   923   while (base < limit) {
   924     Seg seg;
   925     Addr segBase, segLimit;
   926       
   927     {
   928       Bool b = SegOfAddr(&seg, arena, base);
   929       AVER(b);
   930     }
   931     segBase = SegBase(seg);
   932     segLimit = SegLimit(seg);
   933     if (base <= segBase && limit >= segLimit) {
   934       {
   935         Res r = CBSDelete(MV2CBS(mv2), segBase, segLimit);
   936         AVER(r == ResOK);
   937       }
   938       MV2SegFree(mv2, seg);
   939       success = TRUE;
   940     }
   941     base = segLimit;
   942   }
   943 
   944   return success;
   945 }
   946 
   947 
   948 /* MV2NoteNew -- callback invoked when a block on the CBS >= reuseSize
   949  */
   950 static void MV2NoteNew(CBS cbs, CBSBlock block) 
   951 {
   952   Res res;
   953   MV2 mv2;
   954   
   955   AVERT(CBS, cbs);
   956   mv2 = CBSMV2(cbs);
   957   AVERT(MV2, mv2);
   958   AVERT(CBSBlock, block);
   959   AVER(CBSBlockSize(block) >= mv2->reuseSize);
   960 
   961   res = ABQPush(MV2ABQ(mv2), block);
   962   /* See design.mps.poolmv2:impl.c.free.merge */
   963   if (res != ResOK) {
   964     Arena arena = PoolArena(MV2Pool(mv2));
   965     CBSBlock oldBlock;
   966     {
   967       Res r = ABQPeek(MV2ABQ(mv2), &oldBlock);
   968       AVER(r == ResOK);
   969     }
   970     /* --- This should always succeed */
   971     (void)MV2ReturnBlockSegs(mv2, oldBlock, arena);
   972     res = ABQPush(MV2ABQ(CBSMV2(cbs)), block);
   973     if (res != ResOK) {
   974       unless(MV2ReturnBlockSegs(mv2, block, arena)) {
   975         mv2->abqOverflow = TRUE;
   976         METER_ACC(mv2->overflows, CBSBlockSize(block));
   977       }
   978     }
   979   }
   980 }
   981 
   982 
   983 /* MV2NoteDelete -- callback invoked when a block on the CBS <=
   984  * reuseSize
   985  */
   986 static void MV2NoteDelete(CBS cbs, CBSBlock block)
   987 {
   988   AVERT(CBS, cbs);
   989   AVERT(MV2, CBSMV2(cbs));
   990   AVERT(CBSBlock, block);
   991   AVER(CBSBlockSize(block) < CBSMV2(cbs)->reuseSize);
   992   
   993   {
   994     Res res = ABQDelete(MV2ABQ(CBSMV2(cbs)), block);
   995     AVER(res == ResOK || CBSMV2(cbs)->abqOverflow);
   996   }
   997 }
   998 
   999 
  1000 /* ABQRefillIfNecessary -- refill the ABQ from the CBS if it had
  1001  * overflown and is now empty
  1002  */
  1003 static void ABQRefillIfNecessary(MV2 mv2, Size size) 
  1004 {
  1005   AVERT(MV2, mv2);
  1006   AVER(size > 0);
  1007 
  1008   if (mv2->abqOverflow && ABQIsEmpty(MV2ABQ(mv2))) {
  1009     mv2->abqOverflow = FALSE;
  1010     METER_ACC(mv2->refills, size);
  1011     CBSIterateLarge(MV2CBS(mv2), &ABQRefillCallback, NULL, 0);
  1012   }
  1013 }
  1014 
  1015 
  1016 /* ABQRefillCallback -- called from CBSIterate at the behest of
  1017  * ABQRefillIfNecessary
  1018  */
  1019 static Bool ABQRefillCallback(CBS cbs, CBSBlock block, void *closureP,
  1020                               unsigned long closureS)
  1021 {
  1022   Res res;
  1023   MV2 mv2;
  1024   
  1025   AVERT(CBS, cbs);
  1026   mv2 = CBSMV2(cbs);
  1027   AVERT(MV2, mv2);
  1028   AVERT(ABQ, MV2ABQ(mv2));
  1029   AVERT(CBSBlock, block);
  1030   AVER(CBSBlockSize(block) >= mv2->reuseSize);
  1031   UNUSED(closureP);
  1032   UNUSED(closureS);
  1033 
  1034   METER_ACC(mv2->refillPushes, ABQDepth(MV2ABQ(mv2)));
  1035   res = ABQPush(MV2ABQ(mv2), block);
  1036   if (res != ResOK) {
  1037     if (MV2ReturnBlockSegs(mv2, block, PoolArena(MV2Pool(mv2)))) {
  1038       METER_ACC(mv2->refillReturns, CBSBlockSize(block));
  1039       return TRUE;
  1040     }
  1041     else {
  1042       mv2->abqOverflow = TRUE;
  1043       METER_ACC(mv2->refillOverflows, CBSBlockSize(block));
  1044       return FALSE;
  1045     }
  1046   }
  1047 
  1048   return TRUE;
  1049 }
  1050   
  1051 
  1052 /* Closure for MV2ContingencySearch */
  1053 typedef struct MV2ContigencyStruct *MV2Contigency;
  1054 
  1055 typedef struct MV2ContigencyStruct 
  1056 {
  1057   CBSBlock blockReturn;
  1058   Arena arena;
  1059   Size min;
  1060   /* meters */
  1061   Count steps;
  1062   Count hardSteps;
  1063 } MV2ContigencyStruct;
  1064 
  1065 
  1066 /* MV2ContingencySearch -- search the CBS for a block of size min
  1067  */
  1068 static Res MV2ContingencySearch(CBSBlock *blockReturn, CBS cbs, Size min)
  1069 {
  1070   MV2ContigencyStruct cls;
  1071 
  1072   cls.blockReturn = NULL;
  1073   cls.arena = PoolArena(MV2Pool(CBSMV2(cbs)));
  1074   cls.min = min;
  1075   cls.steps = 0;
  1076   cls.hardSteps = 0;
  1077   
  1078   CBSIterate(cbs, &MV2ContingencyCallback, (void *)&cls, (unsigned 
long)sizeof(cls));
  1079   if (cls.blockReturn != NULL) {
  1080     AVER(CBSBlockSize(cls.blockReturn) >= min);
  1081     METER_ACC(CBSMV2(cbs)->contingencySearches, cls.steps);
  1082     if (cls.hardSteps) {
  1083       METER_ACC(CBSMV2(cbs)->contingencyHardSearches, cls.hardSteps);
  1084     }
  1085     *blockReturn = cls.blockReturn;
  1086     return ResOK;
  1087   }
  1088     
  1089   return ResFAIL;
  1090 }
  1091 
  1092 
  1093 /* MV2ContingencyCallback -- called from CBSIterate at the behest of
  1094  * MV2ContingencySearch
  1095  */
  1096 static Bool MV2ContingencyCallback(CBS cbs, CBSBlock block, void 
*closureP,
  1097                                    unsigned long closureS)
  1098 {
  1099   MV2Contigency cl;
  1100   Size size;
  1101   
  1102   AVERT(CBS, cbs);
  1103   AVERT(CBSBlock, block);
  1104   AVER(closureP != NULL);
  1105   AVER(closureS == sizeof(MV2ContigencyStruct));
  1106 
  1107   cl = (MV2Contigency)closureP;
  1108   size = CBSBlockSize(block);
  1109   
  1110   cl->steps++;
  1111   if (size < cl->min)
  1112     return TRUE;
  1113 
  1114   /* verify that min will fit when seg-aligned */
  1115   if (size >= 2 * cl->min) {
  1116     cl->blockReturn = block;
  1117     return FALSE;
  1118   }
  1119   
  1120   /* do it the hard way */
  1121   cl->hardSteps++;
  1122   if (MV2CheckFit(block, cl->min, cl->arena)) {
  1123     cl->blockReturn = block;
  1124     return FALSE;
  1125   }
  1126   
  1127   /* keep looking */
  1128   return TRUE;
  1129 }
  1130 
  1131 
  1132 /* MV2CheckFit -- verify that segment-aligned block of size min can
  1133  * fit in a candidate CBSblock
  1134  */
  1135 static Bool MV2CheckFit(CBSBlock block, Size min, Arena arena)
  1136 {
  1137   Addr base = CBSBlockBase(block);
  1138   Addr limit = CBSBlockLimit(block);
  1139   Seg seg;
  1140   Addr segLimit;
  1141   {
  1142     Bool b = SegOfAddr(&seg, arena, base);
  1143     AVER(b);
  1144   }
  1145   segLimit = SegLimit(seg);
  1146 
  1147   if (limit <= segLimit) {
  1148     if (AddrOffset(base, limit) >= min)
  1149       return TRUE;
  1150   }
  1151 
  1152   if (AddrOffset(base, segLimit) >= min)
  1153     return TRUE;
  1154 
  1155   base = segLimit;
  1156   {
  1157     Bool b = SegOfAddr(&seg, arena, base);
  1158     AVER(b);
  1159   }
  1160   segLimit = SegLimit(seg);
  1161 
  1162   if (AddrOffset(base, limit < segLimit ? limit : segLimit) >= min)
  1163     return TRUE;
  1164 
  1165   return FALSE;
  1166 }
  1167 
  1168 
  1169 
  1170 
  1171 
  1172   
  1173 

