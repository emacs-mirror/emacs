                          RING IMPLEMENTATION
                              impl.c.ring
                             accepted impl
                           gavinm 1996-09-24

     1 /* impl.c.ring: RING IMPLEMENTATION
     2  *
     3  * $HopeName: MMsrc!ring.c(trunk.3) $
     4  * Copyright (C) 1995 Harlequin Group, all rights reserved.
     5  *
     6  * .def: Rings are circular doubly-linked lists of ring "nodes".  The 
nodes
     7  * are fields of structures which are the "elements" of the ring.
     8  *
     9  * .ex: For example:
    10  *
    11  *   typedef struct FooStruct *Foo;     the element type
    12  *   typedef struct FooStruct {         the element structure
    13  *     int baz, bim;
    14  *     RingStruct ring;                 the ring node
    15  *     float bip, bop;
    16  *   } FooStruct;
    17  *
    18  * .def.singleton: A "singleton" ring is a ring containing one node, 
whose
    19  * previous and next nodes are itself.
    20  *
    21  * .rationale: Because ring nodes are in-lined in their parent
    22  * structures the do not need to be managed.  This is especially useful
    23  * in avoiding re-entrancy and bootstrapping problems in the memory
    24  * manager.  Rings also provide flexible insertion and deletion because
    25  * the entire ring can be found from any node.
    26  *
    27  * .where.type: The Ring type is defined in impl.h.mpmtypes.
    28  * .where.struct: The RingStruct structure is defined in impl.h.mpmst.
    29  */
    30 
    31 #include "mpm.h"
    32 
    33 SRCID(ring, "$HopeName: MMsrc!ring.c(trunk.3) $");
    34 
    35 
    36 /* RingCheck, RingCheckSingle -- check the validity of a ring node
    37  *
    38  * RingCheck performs a consistency check on the ring node. 
    39  * RingCheckSingle performs the same check, but also checks that
    40  * the ring node is a singleton (.def.singleton).
    41  */
    42 
    43 Bool RingCheck(Ring ring)
    44 {
    45   CHECKL(ring != NULL);
    46   CHECKL(ring->next != NULL);
    47   CHECKL(ring->next->prev == ring);
    48   CHECKL(ring->prev != NULL);
    49   CHECKL(ring->prev->next == ring);
    50   return TRUE;
    51 }
    52 
    53 Bool RingCheckSingle(Ring ring)
    54 {
    55   CHECKL(RingCheck(ring));
    56   CHECKL(ring->next == ring);
    57   CHECKL(ring->prev == ring);
    58   return TRUE;
    59 }
    60 
    61 
    62 /* Ringinit -- initialize a ring node
    63  *
    64  * A ring node is intialized to be a singleton (.def.singleton).
    65  */
    66 
    67 void (RingInit)(Ring ring)
    68 {
    69   RingInit(ring);                       /* impl.h.mpm.init */
    70 }
    71 
    72 
    73 /* RingFinish -- finish a ring node
    74  *
    75  * The ring node must be a singleton to be finished (.def.singleton).
    76  */
    77  
    78 void (RingFinish)(Ring ring)
    79 {
    80   RingFinish(ring);                     /* impl.h.mpm.finish */
    81 }
    82 
    83 
    84 /* RingAppend -- add a ring node to the end of a ring
    85  *
    86  * The "new" node is added immediately previous to the "ring"
    87  * node, so that it appears at the end of the ring.  The "new" 
    88  * node must be a singleton (.def.singleton).
    89  */
    90 
    91 void (RingAppend)(Ring ring, Ring new)
    92 {
    93   RingAppend(ring, new);                /* impl.h.mpm.append */
    94 }
    95 
    96 
    97 /* RingRemove -- remove a node from a ring
    98  *
    99  * The "old" node is removed from the ring it occupies, and becomes
   100  * a singleton (.def.singleton).  (This has no effect if it is already
   101  * one.)
   102  */
   103 
   104 void (RingRemove)(Ring old)
   105 {
   106   RingRemove(old);                      /* impl.h.mpm.remove */
   107 }
   108 
   109 
   110 /* RingNext -- get the next element of a ring */
   111 
   112 Ring (RingNext)(Ring ring)
   113 {
   114   return RingNext(ring);                /* impl.h.mpm.next */
   115 }
   116 
   117 
   118 /* RING_ELT -- get the ring element structure
   119  *
   120  * _type must be the type of a pointer to the enclosing structure,
   121  * _field is the name of the ring structure field within it, and
   122  * _ring is the ring node.  The result is a pointer to the enclosing
   123  * structure.
   124  */
   125 
   126 /* RING_ELT has no function, and is defined in impl.h.mpm. */
   127 
   128 
   129 /* RING_FOR -- ring iterator construct
   130  *
   131  * This is a for-loop iterator construct for rings.  _var is the
   132  * iteration variable (of type Ring) to use.  The behaviour is
   133  * undefined if the ring is modified during the iteration.
   134  *
   135  * .ring_for.ex: For example:
   136  *
   137  *   Ring ring;
   138  *   RING_FOR(ring, &foo->barRing) {
   139  *     Bar bar = RING_ELT(Bar, FooRing, ring);
   140  *     frob(bar);
   141  *   }
   142  */
   143 
   144 /* RING_FOR has no function, and is defined in impl.h.mpm. */

