                       MANUAL RANK GUARDIAN POOL
                         impl.c.poolmrg.message
                              accepted doc
                           gavinm 1997-09-03

     1 /* impl.c.poolmrg
     2  * 
     3  * MANUAL RANK GUARDIAN POOL
     4  * 
     5  * $HopeName: MMsrc!poolmrg.c(MMdevel_drj_message.9) $
     6  * Copyright (C) 1997 The Harlequin Group Limited.  All rights reserved.
     7  *
     8  * READERSHIP
     9  *
    10  * .readership: Any MPS developer.
    11  * 
    12  * DESIGN
    13  * 
    14  * .design: See design.mps.poolmrg.
    15  *
    16  * NOTES
    17  * 
    18  * .improve.rank: At the moment, the pool is a guardian for the final
    19  * rank.  It could be generalized to be a guardian for an arbitrary
    20  * rank (a guardian for RankEXACT would tell you if the object was
    21  * ambiguously referenced, for example).  The code that would need to be
    22  * modified bears this tag.
    23  *
    24  * .check-index: The number of guardians per segment is derived from
    25  * the pool.  As most of the code doesn't have access to the pool,
    26  * and knowledge of this derivation should be localised, the indexes 
    27  * are often unvalidated.
    28  */
    29 
    30 
    31 #include "mpm.h"
    32 #include "poolmrg.h"
    33 
    34 SRCID(poolmrg, "$HopeName: MMsrc!poolmrg.c(MMdevel_drj_message.9) $");
    35 
    36 
    37 #define MRGSig          ((Sig)0x519369B0) /* SIGnature MRG POol */
    38 
    39 
    40 /* Types */
    41 
    42 typedef struct MRGStruct {
    43   PoolStruct poolStruct;       /* generic pool structure */
    44   RingStruct entry;            /* design.mps.poolmrg.poolstruct.entry */
    45   RingStruct free;             /* design.mps.poolmrg.poolstruct.free */
    46   RingStruct group;            /* design.mps.poolmrg.poolstruct.group */
    47   Size extendBy;               /* design.mps.poolmrg.extend */
    48   Sig sig;                     /* impl.h.mps.sig */
    49 } MRGStruct;
    50 
    51 #define PoolPoolMRG(pool) PARENT(MRGStruct, poolStruct, pool)
    52 
    53 static Pool MRGPool(MRG mrg);
    54 
    55 /* enumerate the states of a Guardian */
    56 enum {
    57   MRGGuardianFree,
    58   MRGGuardianPrefinal,
    59   MRGGuardianFinal,
    60   MRGGuardianPostfinal
    61 };
    62 
    63 typedef struct LinkStruct {
    64   int state;                     /* Free, Prefinal, Final, Postfinal */
    65   union LinkUnion {
    66     MessageStruct messageStruct; /* state = Final */
    67     RingStruct linkRing;         /* state e {Free, Prefinal} */
    68   } the;
    69 } LinkStruct;
    70 typedef union LinkUnion LinkUnion;
    71 typedef LinkStruct *Link;
    72 
    73 #define linkOfMessage(message) \
    74   PARENT(LinkStruct, the, ((LinkUnion *)(message)))
    75 #define linkOfRing(ring) \
    76   PARENT(LinkStruct, the, ((LinkUnion *)(ring)))
    77 
    78 
    79 #define MRGGroupSig     ((Sig)0x5193699b) /* SIGnature MRG GrouP */
    80 
    81 typedef struct MRGGroupStruct {
    82   Sig sig;                      /* impl.h.misc.sig */
    83   RingStruct group;             /* design.mps.poolmrg.group.group */
    84   Seg refSeg;                   /* design.mps.poolmrg.group.segs */
    85   Seg linkSeg;                  /* design.mps.poolmrg.group.segs */
    86 } MRGGroupStruct;
    87 typedef MRGGroupStruct *MRGGroup;
    88 
    89 
    90 /* Forward declarations */
    91 
    92 static MessageClassStruct MRGMessageClassStruct;
    93 static PoolClassStruct PoolClassMRGStruct;
    94 static Bool MRGGroupCheck(MRGGroup group);
    95 static Bool MRGCheck(MRG mrg);
    96 
    97 
    98 /* design.mps.poolmrg.guardian.assoc */
    99 
   100 static Ref *refOfLink(Link link, Space space)
   101 {
   102   Seg seg;
   103   Bool b;
   104   Link linkBase;
   105   Index index;
   106   MRGGroup group;
   107   Ref *refBase;
   108 
   109   AVER(link != NULL); /* Better checks done by SegOfAddr */
   110   AVERT(Space, space);
   111 
   112   b = SegOfAddr(&seg, space, (Addr)link);
   113   AVER(b);
   114   linkBase = (Link)SegBase(space, seg);
   115   index = link - linkBase; /* .check-index */
   116 
   117   AVER(SegPool(seg)->class == &PoolClassMRGStruct);
   118   group = (MRGGroup)SegP(seg);
   119   AVERT(MRGGroup, group);
   120   AVER(group->linkSeg == seg);
   121 
   122   refBase = (Ref *)SegBase(space, group->refSeg);
   123   return &refBase[index];
   124 }
   125 
   126 static Link linkOfRef(Ref *ref, Space space)
   127 {
   128   Seg seg;
   129   Bool b;
   130   Ref *refBase;
   131   Index index;
   132   MRGGroup group;
   133   Link linkBase;
   134 
   135   AVER(ref != NULL); /* Better checks done by SegOfAddr */
   136   AVERT(Space, space);
   137 
   138   b = SegOfAddr(&seg, space, (Addr)ref);
   139   AVER(b);
   140   refBase = (Ref *)SegBase(space, seg);
   141   index = ref - refBase; /* .check-index */
   142 
   143   AVER(SegPool(seg)->class == &PoolClassMRGStruct);
   144   group = SegP(seg);
   145   AVERT(MRGGroup, group);
   146   AVER(group->refSeg == seg);
   147 
   148   linkBase = (Link)SegBase(space, group->linkSeg);
   149   return &linkBase[index];
   150 }
   151 
   152 
   153 static void MRGGroupDestroy(MRGGroup group, MRG mrg)
   154 {
   155   Pool pool;
   156 
   157   AVERT(MRGGroup, group);
   158   AVERT(MRG, mrg);
   159 
   160   pool = MRGPool(mrg);
   161   RingRemove(&group->group);
   162   PoolSegFree(pool, group->refSeg);
   163   PoolSegFree(pool, group->linkSeg);
   164   SpaceFree(PoolSpace(pool), (Addr)group, (Size)sizeof(MRGGroupStruct));
   165 }
   166 
   167 static Res MRGGroupCreate(MRGGroup *groupReturn, MRG mrg)
   168 {
   169   Ref *refBase;
   170   Count guardians;       /* guardians per seg */
   171   Index i;
   172   Link linkBase;
   173   MRGGroup group;
   174   Pool pool;
   175   Res res;
   176   Seg linkSeg;
   177   Seg refSeg;
   178   Size linkSegSize;
   179   Space space;
   180   void *v;
   181 
   182   AVER(groupReturn != NULL);
   183   AVERT(MRG, mrg);
   184 
   185   pool = MRGPool(mrg);
   186   space = PoolSpace(pool);
   187   res = SpaceAlloc(&v, space, (Size)sizeof(MRGGroupStruct));
   188   if(res != ResOK)
   189     goto failSpaceAlloc;
   190 
   191   group = v;
   192   res = PoolSegAlloc(&refSeg, SegPrefDefault(), pool, mrg->extendBy);
   193   if(res != ResOK)
   194     goto failRefSegAlloc;
   195 
   196   guardians = mrg->extendBy / sizeof(Ref);     /* per seg */
   197   linkSegSize = guardians * sizeof(LinkStruct);
   198   linkSegSize = SizeAlignUp(linkSegSize, ArenaAlign(space));
   199   res = PoolSegAlloc(&linkSeg, SegPrefDefault(), pool, linkSegSize);
   200   if(res != ResOK)
   201     goto failLinkSegAlloc;
   202 
   203   /* Link Segment is coerced to an array of LinkStructs, */
   204   /* each one is appended to the free Ring using the linkRing. */
   205   /* The ref part of each guardian is cleared. */
   206 
   207   AVER(guardians > 0);
   208   linkBase = (Link)SegBase(space, linkSeg);
   209   refBase = (Ref *)SegBase(space, refSeg);
   210 
   211   for(i=0; i<guardians; ++i) {
   212     RingInit(&linkBase[i].the.linkRing);
   213     linkBase[i].state = MRGGuardianFree;
   214     RingAppend(&mrg->free, &linkBase[i].the.linkRing);
   215     refBase[i] = 0;
   216   }
   217   AVER((Addr)(&linkBase[i]) <= SegLimit(space, linkSeg));
   218   AVER((Addr)(&refBase[i]) <= SegLimit(space, refSeg));
   219   /* design.mps.seg.field.rankSet.start */
   220   SegSetRankSet(refSeg, RankSetSingle(RankFINAL));
   221   /* design.mps.seg.field.summary.start */
   222   SegSetSummary(refSeg, RefSetUNIV);
   223 
   224   group->refSeg = refSeg;
   225   group->linkSeg = linkSeg;
   226   SegSetP(refSeg, group);
   227   SegSetP(linkSeg, group);
   228   RingInit(&group->group);
   229   RingAppend(&mrg->group, &group->group);
   230   group->sig = MRGGroupSig;
   231 
   232   return ResOK;
   233 
   234 failLinkSegAlloc:
   235   PoolSegFree(pool, refSeg);
   236 failRefSegAlloc:
   237   SpaceFree(space, (Addr)group, (Size)sizeof(MRGGroupStruct)); 
   238 failSpaceAlloc:
   239   AVER(res != ResOK);
   240   return res;
   241 }
   242 
   243 /* finalize the indexth guardian in the group */
   244 static void MRGFinalize(Space space, MRGGroup group, Index index)
   245 {
   246   Link link, linkBase;
   247   Message message;
   248 
   249   AVERT(Space, space);
   250   AVERT(MRGGroup, group);
   251   /* .check-index */
   252 
   253   linkBase = (Link)SegBase(space, group->linkSeg);
   254   link = &linkBase[index];
   255 
   256   /* only finalize it if it hasn't been finalized already */
   257   if(link->state != MRGGuardianFinal) {
   258     AVER(link->state == MRGGuardianPrefinal);
   259     RingRemove(&link->the.linkRing);
   260     link->state = MRGGuardianFinal;
   261     message = &link->the.messageStruct;
   262     MessageInit(space, message, &MRGMessageClassStruct);
   263     MessagePost(space, message);
   264   }
   265 }
   266 
   267 static Res MRGGroupScan(ScanState ss, MRGGroup group, MRG mrg)
   268 {
   269   Res res;
   270   Space space;
   271   Ref *refBase;
   272   Count guardians;
   273   Index i;
   274 
   275   AVERT(ScanState, ss);
   276   AVERT(MRGGroup, group);
   277   AVERT(MRG, mrg);
   278 
   279   space = PoolSpace(MRGPool(mrg));
   280 
   281   guardians = mrg->extendBy / sizeof(Ref);     /* per seg */
   282   AVER(guardians > 0);
   283   refBase = (Ref *)SegBase(space, group->refSeg);
   284   TRACE_SCAN_BEGIN(ss) {
   285     for(i=0; i<guardians; ++i) {
   286       if(!TRACE_FIX1(ss, refBase[i]))
   287         continue;
   288       res = TRACE_FIX2(ss, &refBase[i]);
   289       if(res != ResOK) 
   290         return res;
   291       
   292       if(ss->rank == RankFINAL && !ss->wasMarked) { /* .improve.rank */
   293         MRGFinalize(space, group, i);
   294       }
   295     }
   296   } TRACE_SCAN_END(ss);
   297 
   298   return ResOK;
   299 }
   300 
   301 
   302 static Res MRGInit(Pool pool, va_list args)
   303 {
   304   MRG mrg;
   305   
   306   AVER(pool != NULL); /* Can't check more; see pool contract @@@@ */
   307   UNUSED(args);
   308   
   309   mrg = PoolPoolMRG(pool);
   310 
   311   RingInit(&mrg->entry);
   312   RingInit(&mrg->free);
   313   RingInit(&mrg->group);
   314   mrg->extendBy = ArenaAlign(PoolSpace(pool));
   315   mrg->sig = MRGSig;
   316 
   317   AVERT(MRG, mrg);
   318 
   319   return ResOK;
   320 }
   321 
   322 static void MRGFinish(Pool pool)
   323 {
   324   MRG mrg;
   325   Ring node;
   326 
   327   AVERT(Pool, pool);
   328   mrg = PoolPoolMRG(pool);
   329   AVERT(MRG, mrg);
   330 
   331   node = RingNext(&mrg->group);
   332   while(node != &mrg->group) {
   333     Ring next = RingNext(node);
   334     MRGGroup group = RING_ELT(MRGGroup, group, node);
   335     MRGGroupDestroy(group, mrg);
   336 
   337     node = next;
   338   }
   339   mrg->sig = SigInvalid;
   340 }
   341 
   342 static Pool MRGPool(MRG mrg)
   343 {
   344   AVERT(MRG, mrg);
   345   return &mrg->poolStruct;
   346 }
   347 
   348 static Res MRGAlloc(Addr *pReturn, Pool pool, Size size)
   349 {
   350   MRG mrg;
   351   MRGGroup junk;                /* .group.useless */
   352   Res res;
   353   Ring f;
   354   Space space;
   355   Link link;
   356   Ref *ref;
   357 
   358   AVER(pReturn != NULL);
   359   AVERT(Pool, pool);
   360   AVER(size == sizeof(Ref));   /* design.mps.poolmrg.alloc.one-size */
   361 
   362   mrg = PoolPoolMRG(pool);
   363   AVERT(MRG, mrg);
   364 
   365   space = PoolSpace(pool);
   366 
   367   f = RingNext(&mrg->free);
   368 
   369   /* design.mps.poolmrg.alloc.grow */
   370 
   371   if(f == &mrg->free) {                 /* (Ring has no elements) */
   372     /* .group.useless: group isn't used */
   373     res = MRGGroupCreate(&junk, mrg);   
   374     if(res != ResOK) 
   375       return res;
   376     
   377     f = RingNext(&mrg->free);
   378   }
   379   AVER(f != &mrg->free);
   380 
   381   link = linkOfRing(f);
   382   AVER(link->state == MRGGuardianFree);
   383   /* design.mps.poolmrg.alloc.pop */
   384   RingRemove(f);
   385   link->state = MRGGuardianPrefinal;
   386   RingAppend(&mrg->entry, f);
   387 
   388   /* design.mps.poolmrg.guardian.ref.alloc */
   389   ref = refOfLink(link, space);
   390   AVER(*ref == 0);
   391   *pReturn = (Addr)ref;
   392 
   393   return ResOK;
   394 }
   395 
   396 static void MRGFree(Pool pool, Addr old, Size size)
   397 {
   398   MRG mrg;
   399   Space space;
   400   Seg seg;
   401   Bool b;
   402   Link link;
   403   Ref *ref;
   404 
   405   AVERT(Pool, pool);
   406   AVER(old != (Addr)0);
   407   AVER(size == sizeof(Ref));
   408 
   409   mrg = PoolPoolMRG(pool);
   410   AVERT(MRG, mrg);
   411 
   412   ref = (Ref *)old;
   413 
   414   space = PoolSpace(pool);
   415   b = SegOfAddr(&seg, space, old);
   416   AVER(b);
   417 
   418   /* design.mps.poolmrg.guardian.ref.free */
   419   link = linkOfRef(ref, space);
   420 
   421   AVER(link->state == MRGGuardianPostfinal);
   422   RingInit(&link->the.linkRing);
   423   link->state = MRGGuardianFree;
   424   RingAppend(&mrg->free, &(link->the.linkRing));
   425   {
   426     RefSet sum = RefSetEMPTY;
   427     sum = SegSummary(seg);
   428     sum = RefSetAdd(space, sum, (Addr)0);
   429     TraceSetSummary(space, seg, sum);
   430     ShieldExpose(space, seg);
   431     *ref = 0;     /* design.mps.poolmrg.free.overwrite */
   432     ShieldCover(space, seg);
   433   }
   434 }
   435 
   436 /* Describe
   437  *
   438  * This could be improved by implementing MRGSegDescribe
   439  * and having MRGDescribe iterate over all the pool's segments.
   440  */
   441 static Res MRGDescribe(Pool pool, mps_lib_FILE *stream)
   442 {
   443   MRG mrg;
   444   Ring r;
   445   Space space;
   446   Ref *ref;
   447 
   448   AVERT(Pool, pool);
   449   /* Cannot check stream */
   450 
   451   mrg = PoolPoolMRG(pool);
   452   AVERT(MRG, mrg);
   453 
   454   space = PoolSpace(pool);
   455 
   456   WriteF(stream, "  extendBy $W\n", mrg->extendBy, NULL);
   457   WriteF(stream, "  Entry queue:\n", NULL);
   458   RING_FOR(r, &mrg->entry) {
   459     ref = refOfLink(linkOfRing(r), space);
   460     WriteF(stream,
   461            "    at $A ref $A\n",
   462            (WriteFA)ref, (WriteFA)*ref,
   463            NULL);
   464   }
   465 
   466   return ResOK;
   467 }
   468 
   469 static Res MRGScan(ScanState ss, Pool pool, Seg seg)
   470 {
   471   MRG mrg;
   472   Res res;
   473   MRGGroup group;
   474 
   475   AVERT(ScanState, ss);
   476   AVERT(Pool, pool);
   477   AVERT(Seg, seg);
   478 
   479   mrg = PoolPoolMRG(pool);
   480   AVERT(MRG, mrg);
   481 
   482   AVER(SegRankSet(seg) == RankSetSingle(RankFINAL));
   483   AVER(TraceSetInter(SegGrey(seg), ss->traces) != TraceSetEMPTY);
   484   group = (MRGGroup)SegP(seg);
   485   AVER(seg == group->refSeg);
   486 
   487   res = MRGGroupScan(ss, group, mrg);
   488   if(res != ResOK) 
   489     return res;
   490 
   491   return ResOK;
   492 }
   493 
   494 
   495 /* Implementation of MRG's MessageClass */
   496 
   497 /* deletes the message (frees up the memory) */
   498 static void MRGMessageDelete(Message message)
   499 {
   500   Ref *ref;
   501   Bool b;
   502   Space space;
   503   Link link;
   504   Seg seg; 
   505 
   506   AVERT(Message, message);
   507 
   508   space = MessageSpace(message);
   509 
   510   b = SegOfAddr(&seg, space, (Addr)message);
   511   AVER(b);
   512   AVER(SegPool(seg)->class == &PoolClassMRGStruct);
   513 
   514   link = linkOfMessage(message);
   515   MessageFinish(message);
   516   AVER(link->state == MRGGuardianFinal);
   517   link->state = MRGGuardianPostfinal;
   518   ref = refOfLink(link, space);
   519   PoolFree(SegPool(seg), (Addr)ref, sizeof(Ref));
   520 }
   521 
   522 static void MRGMessageFinalizationRef(Ref *refReturn,
   523                                       Space space, Message message)
   524 {
   525   Link link;
   526   Ref *ref;
   527 
   528   AVER(refReturn != NULL);
   529   AVERT(Space, space);
   530   AVERT(Message, message);
   531 
   532   AVER(message->type == MessageTypeFinalization);
   533 
   534   link = linkOfMessage(message);
   535   AVER(link->state == MRGGuardianFinal);
   536   ref = refOfLink(link, space);
   537   AVER(*ref != 0);
   538   *refReturn = *ref;
   539 }
   540 
   541 
   542 static MessageClassStruct MRGMessageClassStruct = {
   543   MessageClassSig,             /* sig */
   544   "MRGFinal",                  /* name */
   545   MRGMessageDelete,            /* Delete */
   546   MRGMessageFinalizationRef,   /* FinalizationRef */
   547   MessageClassSig              /* design.mps.message.class.sig.double */
   548 };
   549 
   550 static PoolClassStruct PoolClassMRGStruct = {
   551   PoolClassSig,                         /* sig */
   552   "MRG",                                /* name */
   553   sizeof(MRGStruct),                    /* size */
   554   offsetof(MRGStruct, poolStruct),      /* offset */
   555   AttrSCAN | AttrALLOC | AttrFREE | AttrINCR_RB,
   556   MRGInit,                              /* init */
   557   MRGFinish,                            /* finish */
   558   MRGAlloc,                             /* alloc */
   559   MRGFree,                              /* free */
   560   PoolNoBufferInit,                     /* bufferInit */
   561   PoolNoBufferFill,                     /* bufferFill */
   562   PoolNoBufferEmpty,                    /* bufferEmpty */
   563   PoolNoBufferFinish,                   /* bufferFinish */
   564   PoolNoTraceBegin,                     /* traceBegin */
   565   PoolNoCondemn,                        /* condemn */
   566   PoolTrivGrey,                         /* grey */
   567   MRGScan,                              /* scan */
   568   PoolNoFix,                            /* fix */
   569   PoolNoReclaim,                        /* reclaim */
   570   PoolNoTraceEnd,                       /* traceEnd */
   571   PoolNoBenefit,                        /* benefit */
   572   MRGDescribe,                          /* describe */
   573   PoolClassSig                          /* impl.h.mpmst.class.end-sig */
   574 };
   575 
   576 PoolClass PoolClassMRG(void)
   577 {
   578   return &PoolClassMRGStruct;
   579 }
   580 
   581 /* .check.norecurse: the expression &mrg->poolStruct is used instead of
   582  * the more natural MRGPool(mrg).  The latter results in infinite
   583  * recursion because MRGPool calls MRGCheck.
   584  */
   585 static Bool MRGCheck(MRG mrg)
   586 {
   587   Space space;
   588 
   589   CHECKS(MRG, mrg);
   590   CHECKD(Pool, &mrg->poolStruct);
   591   CHECKL(mrg->poolStruct.class == &PoolClassMRGStruct);
   592   CHECKL(RingCheck(&mrg->entry));
   593   CHECKL(RingCheck(&mrg->free));
   594   CHECKL(RingCheck(&mrg->group));
   595   space = PoolSpace(&mrg->poolStruct);  /* .check.norecurse */
   596   CHECKL(mrg->extendBy == ArenaAlign(space));
   597   return TRUE;
   598 }
   599 
   600 
   601 static Bool MRGGroupCheck(MRGGroup group)
   602 {
   603   CHECKS(MRGGroup, group);
   604   CHECKL(RingCheck(&group->group));
   605   CHECKL(SegCheck(group->refSeg));
   606   CHECKL(SegCheck(group->linkSeg));
   607   return TRUE;
   608 }

