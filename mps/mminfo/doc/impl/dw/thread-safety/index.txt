                       SUPPORT FOR THREAD SAFETY
                         impl.dw.thread-safety
                             temporary impl
                             dsm 1995-09-08

This is my prototype implementation.  It takes the form of a hacked up
version of dw.c.

/*  ==== DYLANWORKS RUN-TIME SYSTEM INTERFACE ====
 *
 *  $Id: dw.c,v 1.5 1995/08/22 10:25:00 drj Exp $
 *
 *  Copyright (C) 1995 Harlequin Group, all rights reserved
 *
 *  This is the implementation of the interface between the DylanWorks
 *  run-time system and the Memory Manager.
 *
 *  The code here doesn't do much, and never should.  It is only here
 *  to make initial integration with DylanWorks easier by removing some
 *  of the burden from the Dylan Group.
 *
 *  The interface is implemented using two pools: one AMC pool, which holds
 *  the objects and wrappers, and an MV pool for miscellaneous object.  In
 *  future the wrappers will need to be managed in a separate pool from the
 *  objects to avoid read barrier problems for the collector.
 */

#include "std.h"
#include "space.h"
#include "pool.h"
#include "poolamc.h"
#include "poolmv.h"
#include "root.h"
#include "format.h"
#include "mm.h"
#include "dwformat.h"
#include "lock.h"
#include <stddef.h>
#include <stdlib.h>
#include <string.h>


/*  == Magic Numbers ==
 *
 *  CARDSIZE is 32 because the current implementation of the AMC pool doesn't
 *  pack more than one object onto a card when forwarding.  EXTENDBY is a
 *  guess.  The MISC parameters are also guesses, but don't matter much
 *  because the Dylan run-time system hardly uses the misc pool.
 */

#define CARDSIZE        ((size_t)32)
#define EXTENDBY        ((size_t)65536)

#define MISCEXTENDBY    ((size_t)16384)
#define MISCAVGSIZE     ((size_t)32)
#define MISCMAXSIZE     ((size_t)65536)


/*  == Artificial Failure ==
 *
 *  The Reserve operations deliberately fail every so often in order to
 *  make sure that DylanWorks is behaving itself.  FAILPERIOD is the
 *  interval between these artificial failures.  The committed object is
 *  deliberately overwritten with a useless object so that Dylan can't make
 *  use of it by accident.  FailWrapper is a wrapper for this object, which
 *  is a non-traceable vector.
 */

#define FAILPERIOD      100

typedef unsigned long word;
static word *ww, *ntvWrap, *oneWrap;


#define TARG_CHECK (ErrSUCCESS == MMSUCCESS && \
                    ErrFAILURE == MMFAILURE && \
                    ErrRESOURCE == MMRESOURCE && \
                    ErrRESMEM == MMRESMEM && \
                    ErrLIMIT == MMLIMIT && \
                    ErrUNIMPLEMENTED == MMUNIMPLEMENTED && \
                    ErrIO == MMIO)

/* move to dw.h */
void MMScanStacks(void *p, int i, Fixes fixes);

/*  == Default Error Handler ==
 *
 *  This is the default error handler initially installed for all the allocation
 *  interfaces in mm.h.  It prints a message on the standard error stream then
 *  calls abort().
 */

static void defaultHandler(MMError e,
                           const char *errorName, const char *errorDesc,
                           const char *opName, size_t size)
{
  fprintf(stderr,
          "**** %s:%d:%s: request for %lu bytes failed -- aborting\n"
          "**** Description:\n%s\n",
          opName, (int)e, errorName, (unsigned long)size,
          errorDesc);
  abort();
  NOTREACHED;
}


static SpaceStruct spaceStruct;    /* MM state object */
static FormatStruct formatStruct;  /* DylanWorks container format */
static Pool mainPool, wrapperPool, miscPool;
static MMAllocHandler mainHandler = defaultHandler;
static MMAllocHandler wrapperHandler = defaultHandler;
static MMAllocHandler miscHandler = defaultHandler;
static Root stackRoot;             /* Root object representing the stacks */
static void *lastP = NULL;         /* Last reserved address, or NULL if none */
static size_t lastSize = 0;
static unsigned failTick = 0;      /* see FAILPERIOD above */
static LockStruct lockStruct;      /* global lock used on all functions */
static DequeStruct threadDeque;    /* deque of MM threads */
#include "windows.h"
static CONTEXT context;

/*  == Initialize Memory Manager ==
 *
 *  The MM is automatically initialized when first used, to make things
 *  easier for the Dylan guys.  This function sets up the object format,
 *  pools, and stack root object.
 */
/* Why no finish?? */
MMError MMinit(void)
{
  Error e;

  AVER(TARG_CHECK);

  /* ContextFlags determine what is recorded by GetThreadContext.
     This should be set to whichever bits of the context that need
     to be recorded.  This should include:
     .context.sp: the sp and
     .context.regroots: the registers that might contain roots.
     see winnt.h for description of CONTEXT and ContextFlags.
     The sp is given by CONTEXT_CONTROL.
     Tony says the root registers are Edi, Esi, Ebx, Edx, Ecx, Eax 
     these are given by CONTEXT_INTEGER.
   */
  context.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
  DequeInit(&threadDeque);
  LockInit(&lockStruct);

  e = SpaceInit(&spaceStruct);
  if(e != ErrSUCCESS) return(e);
    
  DWFormatInit(&formatStruct);

  /* Create the AMC pool for objects and wrappers */
  e = PoolCreate(&mainPool, PoolClassAMC(), &spaceStruct,
                 CARDSIZE, EXTENDBY, &formatStruct);
  if(e != ErrSUCCESS) {
    SpaceFinish(&spaceStruct);
    return(e);
  }
  
  wrapperPool = mainPool;
  
  /* Create the MV pool for miscellaneous objects. */
  e = PoolCreate(&miscPool, PoolClassMV(), &spaceStruct,
                 MISCEXTENDBY, MISCAVGSIZE, MISCMAXSIZE);
  if(e != ErrSUCCESS) {
    PoolDestroy(mainPool);
    SpaceFinish(&spaceStruct);
    return(e);
  }

  /* Create a Root object for ambiguously scanning the stack. */
  e = RootCreateFun(&stackRoot, SpaceControlPool(&spaceStruct),
                    RootMUTABLE, MMScanStacks, NULL, 0);
  if(e != ErrSUCCESS) {
    PoolDestroy(miscPool);
    PoolDestroy(mainPool);
    SpaceFinish(&spaceStruct);
    return(e);
  }

  /* Intialize wrapper wrapper */
  
  e = PoolAllocP((void **)&ww, miscPool, sizeof(word)*6);
  if(e != ErrSUCCESS) {
    PoolDestroy(miscPool);
    PoolDestroy(mainPool);
    SpaceFinish(&spaceStruct);
    return(e);
  }
  
  ww[0] = (word)ww;             /* wrapper wrapper's wrapper is self */
  ww[1] = (word)ww;             /* junk user field */
  ww[2] = (3uL << 2) | 2uL;     /* three patterned fields in fixed part */
  ww[3] = 0uL;                  /* non-traceable variable part */
  ww[4] = (1uL << 2) | 1uL;     /* one pattern follows */
  ww[5] = 1uL;                  /* user field is traceable */
  
  /* Initialize the one-word object wrapper used for failure */

  e = PoolAllocP((void **)&oneWrap, miscPool, sizeof(word)*5);
  if(e != ErrSUCCESS) {
    PoolDestroy(miscPool);
    PoolDestroy(mainPool);
    SpaceFinish(&spaceStruct);
    return(e);
  }

  oneWrap[0] = (word)ww;        /* wrapper wrapper */
  oneWrap[1] = (word)ww;        /* junk user field */
  oneWrap[2] = 0uL;             /* no fixed part in vector */
  oneWrap[3] = 7uL;             /* no variable part */
  oneWrap[4] = 1uL;             /* no patterns */
 
  /* Initialize non-traceable vector wrapper used for artificial failure */

  e = PoolAllocP((void **)&ntvWrap, miscPool, sizeof(word)*5);
  if(e != ErrSUCCESS) {
    PoolDestroy(miscPool);
    PoolDestroy(mainPool);
    SpaceFinish(&spaceStruct);
    return(e);
  }

  ntvWrap[0] = (word)ww;        /* wrapper wrapper */
  ntvWrap[1] = (word)ww;        /* junk user field */
  ntvWrap[2] = 0uL;             /* no fixed part in vector */
  ntvWrap[3] = 0uL;             /* non-traceable vector */
  ntvWrap[4] = 1uL;             /* no patterns */
 
  SpaceRootAttach(&spaceStruct, stackRoot);

  return(ErrSUCCESS);
}


/*  == Common Allocation Function ==
 *
 *  All the allocation interfaces in mm.h share the same code.  This
 *  function allocates from a pool, calling the an error handler if the
 *  allocation fails.
 */

static Bool alloc(void **pReturn, Pool *pool, size_t size,
                  MMAllocHandler handler, const char *opName)
{
  Error e;
  void *p;

  e = PoolAllocP(&p, *pool, size);
  if(e != ErrSUCCESS) {
    (*handler)((MMError)e, ErrorName(e), ErrorDesc(e), opName, size);
    return(FALSE);
  }

  *pReturn = p;
  return(TRUE);
}


void *MMReserveObject(size_t size)
{
  void *p;

  LockClaim(&lockStruct);

  AVER(lastP == NULL);
  AVER(lastSize == 0);
  AVER(size >= sizeof(Addr));
  AVER(ISALIGNED(formatStruct.alignment, size));

  if(!alloc(&p, &mainPool, size, mainHandler, "MMReserveObject")) {
    LockRelease(&lockStruct); /* error to call commit after failure?? */
    return(NULL);
  }

  lastP = p;
  lastSize = size;

  /* Lock held until Commit, protecting lastP and lastSize */

  return(p);
}

int MMCommitObject(void *p, size_t size)
{
  AVER(lastP != NULL);
  AVER(p == lastP);
  AVER(size == lastSize);
  AVER(PoolHasAddr(wrapperPool, (Addr)p));
  AVER(ISALIGNED(formatStruct.alignment, size));
  AVER(!(*formatStruct.isNotObject)((Addr)p));
  AVER((*formatStruct.length)((Addr)p) == (Addr)size);
  AVER(failTick < FAILPERIOD);

  lastP = NULL;
  lastSize = 0;
  
  /* Artificially fail commit every so often.  Wipe out the failed */
  /* object so it can't be used. */
  ++failTick;
  if(failTick == FAILPERIOD) {
    failTick = 0;

    if(size == sizeof(Addr))
      ((word *)p)[0] = (word)oneWrap;
    else {
      ((word *)p)[0] = (word)ntvWrap;
      ((word *)p)[1] = ((size/sizeof(word)-2) << 2) | 1uL;
      memset((char *)p + sizeof(word)*2, 0xFA, size - sizeof(word)*2);
    }

    LockRelease(&lockStruct);
    return(0);
  }

  LockRelease(&lockStruct);
  return(1);
}

MMAllocHandler MMReserveObjectHandler(MMAllocHandler handler)
{
  MMAllocHandler h;

  LockClaim(&lockStruct);  
  h = mainHandler;
  mainHandler = handler;

  LockRelease(&lockStruct);
  return(h);
}


void *MMReserveWrapper(size_t size)
{
  void *p;
  LockClaim(&lockStruct);

  AVER(lastP == NULL);
  AVER(lastSize == 0);
  AVER(size >= sizeof(Addr));
  AVER(ISALIGNED(formatStruct.alignment, size));

  if(!alloc(&p, &wrapperPool, size, wrapperHandler, "MMReserveWrapper")) {
    LockRelease(&lockStruct);
    return(NULL);
  }

  lastP = p;
  lastSize = size;

  return(p);
}

int MMCommitWrapper(void *p, size_t size)
{
  AVER(lastP != NULL);
  AVER(p == lastP);
  AVER(size == lastSize);
  AVER(PoolHasAddr(wrapperPool, (Addr)p));
  AVER(ISALIGNED(formatStruct.alignment, size));
  AVER(!(*formatStruct.isNotObject)((Addr)p));
  AVER((*formatStruct.length)((Addr)p) == (Addr)size);
  AVER(failTick < FAILPERIOD);

  lastP = NULL;
  lastSize = 0;

  /* Artificially fail commit every so often.  Wipe out the failed */
  /* object so it can't be used. */
  ++failTick;
  if(failTick == FAILPERIOD) {
    failTick = 0;

    if(size == sizeof(Addr))
      ((word *)p)[0] = (word)oneWrap;
    else {
      ((word *)p)[0] = (word)ntvWrap;
      ((word *)p)[1] = ((size/sizeof(word)-2) << 2) | 1uL;
      memset((char *)p + sizeof(word)*2, 0xFA, size - sizeof(word)*2);
    }

    LockRelease(&lockStruct);
    return 0;
  }

  LockRelease(&lockStruct);
  return(1);
}

MMAllocHandler MMReserveWrapperHandler(MMAllocHandler handler)
{
  MMAllocHandler h;
  LockClaim(&lockStruct);

  h = wrapperHandler;
  wrapperHandler = handler;
 
  LockRelease(&lockStruct);
  return(h);
}


void *MMAllocMisc(size_t size)
{
  void *p;
  LockClaim(&lockStruct);
  
  if(!alloc(&p, &miscPool, size, miscHandler, "MMAllocMisc")) {
    LockRelease(&lockStruct);
    return(NULL);
  }

  LockRelease(&lockStruct);
  return(p);
}


MMAllocHandler MMAllocMiscHandler(MMAllocHandler handler)
{
  MMAllocHandler h;
  LockClaim(&lockStruct);
  h = miscHandler;
  miscHandler = handler;
  LockRelease(&lockStruct);
  return(h);
}

void MMFreeMisc(void *old, size_t size)
{
  LockClaim(&lockStruct);
  
  PoolFreeP(miscPool, old, size);
  LockRelease(&lockStruct);
}


MMError MMDescribe(FILE *stream)
{
  Error e;
  LockClaim(&lockStruct);
  
  e =SpaceDescribe(&spaceStruct, stream);
  
  LockRelease(&lockStruct);
  return((MMError)e);
}


unsigned MMCollectCount(void)
{
  return(PoolAMCCollections(mainPool));
}


static void scanStatic(void *p, int i, Fixes fixes)
{
  Addr base = (Addr)p;
  Addr limit = base + i * sizeof(Addr);
  
  while(base != limit)
  {
    AVER(base < limit);
    base = (*formatStruct.scan)(base, fixes);
  }
}


MMError MMRootStatic(void *base, void *limit)
{
  Error e;
  Root root;
  LockClaim(&lockStruct);

  AVER(ISALIGNED(sizeof(Addr), (Addr)base));
  AVER(ISALIGNED(sizeof(Addr), (Addr)limit));

  e = RootCreateFun(&root, SpaceControlPool(&spaceStruct),
                    RootEXACT | RootFIXABLE | RootMUTABLE,
                    scanStatic,
                    base, (int)(((Addr)limit - (Addr)base) / sizeof(Addr)));
  if(e != ErrSUCCESS) {
    LockRelease(&lockStruct);
    return((MMError)e);
  }

  SpaceRootAttach(&spaceStruct, root);

  LockRelease(&lockStruct);
  return(MMSUCCESS);
}


MMError MMRootStaticImmutable(void *base, void *limit)
{
  LockClaim(&lockStruct);
#ifndef DEBUG_ASSERT
  UNUSED(base);
  UNUSED(limit);
#endif

  AVER(ISALIGNED(sizeof(Addr), (Addr)base));
  AVER(ISALIGNED(sizeof(Addr), (Addr)limit));

  LockRelease(&lockStruct);
  return(MMSUCCESS);
}


MMError MMRootAmbig(void *base, void *limit)
{
  Error e;
  Root root;
  LockClaim(&lockStruct);

  e = RootCreateTable(&root, SpaceControlPool(&spaceStruct),
                      RootMUTABLE,
                      (Addr *)base, (Addr *)limit);
  if(e != ErrSUCCESS) {
    LockRelease(&lockStruct);
    return((MMError)e);
  }

  SpaceRootAttach(&spaceStruct, root);

  LockRelease(&lockStruct);
  return(MMSUCCESS);
}


MMError MMRootExact(void *base, void *limit)
{
  Error e;
  Root root;
  LockClaim(&lockStruct);

  e = RootCreateTable(&root, SpaceControlPool(&spaceStruct),
                      RootEXACT | RootFIXABLE | RootMUTABLE,
                      (Addr *)base, (Addr *)limit);
  if(e != ErrSUCCESS) {
    LockRelease(&lockStruct);
    return((MMError)e);
  }

  SpaceRootAttach(&spaceStruct, root);

  LockRelease(&lockStruct);
  return(MMSUCCESS);
}

/* == dwnt.c == */

typedef struct MMThreadStruct {
  DequeNodeStruct deque;
  HANDLE handle;   /* Handle of thread */
  DWORD id;        /* Thread id of thread */
  void *stackBot;  /* bottom of stack i.e. most hidden */
} MMThreadStruct;

typedef MMThreadStruct *MMThread;

/* Scans region [base,limit) upwards */
static void scanRegion(Addr *base, Addr *limit, Fixes fixes)
{
  AVER(base != NULL);
  AVER(limit!= NULL);

  AVER(base <= limit);

  while(base < limit) {
    FixesApply(fixes, base, *base);
    ++base;
  }
}

void MMScanStacks(void *p, int i, Fixes fixes)
{
  DequeNode node;
  DWORD id;

  id = GetCurrentThreadId();
  node = DequeFirst(&threadDeque);
  while(node != DequeSentinel(&threadDeque)) {
    DequeNode next = DequeNodeNext(node);
    MMThread thread;
    thread = DequeNodeElement(MMThread, deque, node);

    if(id != thread->id){
      AVER(GetThreadContext(thread->handle, &context)); /* error ??*/
      /* .stack.descend */
      scanRegion((Addr *)context.Esp, thread->stackBot, fixes);

      /* This scans the registers.  It could decide which
         register to scan more accurately. */
      scanRegion((Addr *)&context,
                 (Addr *)((char *)&context + sizeof(CONTEXT)), fixes);

    } else {
      Addr marker; /* .stack.get-sp-hack */
      /* Need to make sure registers saved as well
       * This does not do that. */
      /* Tony says that no roots will be in registers when dylan
       * calls MM layer.  But of course if there is an exception
       * then we must be able to scan registers if this is allowed
       * to cause a scan
       */
      scanRegion(&marker, thread->stackBot, fixes);  /* .stack.descend */
    }

    node = next;
  }
}

void SuspendThreads(){
  DequeNode node;
  DWORD id;

  id = GetCurrentThreadId();
  node = DequeFirst(&threadDeque);
  while(node != DequeSentinel(&threadDeque)) {
    DequeNode next = DequeNodeNext(node);
    MMThread thread;

    thread = DequeNodeElement(MMThread, deque, node);
    if(id != thread->id) {
      AVER(0xFFFFFFFF != SuspendThread(thread->handle));
    }
    node = next;
  }
}

void ResumeThreads(){ /* only a bit like Suspend Threads */
  DequeNode node;
  DWORD id;

  id = GetCurrentThreadId();
  node = DequeFirst(&threadDeque);
  while(node != DequeSentinel(&threadDeque)) {
    DequeNode next = DequeNodeNext(node);
    MMThread thread;

    thread = DequeNodeElement(MMThread, deque, node);
    if(id != thread->id) {
      AVER(0xFFFFFFFF != ResumeThread(thread->handle));
    }
    node = next;
  }
}

/* Return FALSE if not my exception */
static int handleFault(MMThread thread, int iswrite, Addr address){
  /* In future call Arena Fault Handler. */
  NOTREACHED;
  return(1); 
}

static LONG WINAPI SEHfilter(MMThread thread, LPEXCEPTION_POINTERS info)
{
  LPEXCEPTION_RECORD er;
  DWORD iswrite;
  DWORD address;

  er = info->ExceptionRecord;

  if(er->ExceptionCode!=EXCEPTION_ACCESS_VIOLATION)
    return(EXCEPTION_CONTINUE_SEARCH);
   
  AVER(er->ExceptionFlags==0); /* continuable exception */

  /* er->ExceptionRecord is pointer to next exception in chain */
  /* er->ExceptionAddress is where exception occurred */

  AVER(er->NumberParameters>=2);

  iswrite = er->ExceptionInformation[0]; /* 0 read; 1 write */
  AVER(iswrite==0||iswrite==1);

  address = er->ExceptionInformation[1];

  {
    LONG action;

    LockClaim(&lockStruct);
    
    /* In future call Arena Fault Handler. */
    if(handleFault(thread, (int)iswrite, address))
      action = EXCEPTION_CONTINUE_EXECUTION;  
    else 
      action = EXCEPTION_CONTINUE_SEARCH; /* ?? */

    LockRelease(&lockStruct);
    return(action);
  }
}

/* MMContinueReturn type is temporary */
MMError MMCallProgram(MMContinueReturn *valueReturn,
                      MMContinue dylanProgram,
                      void *parameter)
{
  Error e;
  MMThread thread;
  HANDLE procHandle;
  void *marker; /* .stack.get-sp-hack */

  LockClaim(&lockStruct);
  
  AVER(valueReturn != NULL);
  
  e = PoolAllocP(&thread, miscPool, sizeof(MMThreadStruct));
  if(e != ErrSUCCESS) goto return_e;

  /* We need to duplicate the handle as the handle given by
   * GetCurrentThread() does not necessarily give us
   * THREAD_SUSPEND_RESUME access
   */
  procHandle = GetCurrentProcess();
  AVER(DuplicateHandle(procHandle, GetCurrentThread(), procHandle,
                       &thread->handle, THREAD_ALL_ACCESS,
                       FALSE, 0));

  thread->id = GetCurrentThreadId();
  thread->stackBot = &marker; /* .stack.get-sp-hack */

  DequeNodeInit(&thread->deque);
  DequeAppend(&threadDeque,&thread->deque);

  LockRelease(&lockStruct);

  __try {
    /* should valueReturn be updated here? 
       See guide.impl.c ("Don't set until successful") */
    *valueReturn = dylanProgram(parameter);
  }
  __except(SEHfilter(thread,GetExceptionInformation()))
  { AVER(0); }

  LockClaim(&lockStruct);
  
  DequeNodeRemove(&thread->deque);
  DequeNodeFinish(&thread->deque);

  PoolFreeP(miscPool, thread, sizeof(MMThreadStruct));

  e = ErrSUCCESS;
return_e:
  LockRelease(&lockStruct);
  return(e);
}

