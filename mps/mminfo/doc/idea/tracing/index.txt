                                TRACING
                              idea.tracing
                               draft idea
                           richard 1995-07-28

MM.IDEA.TRACING  Tracing


SUMMARY

The client may choose to manage sets of objects using different memory
management policies, some of which may include garbage collection.  To
recycle storage, the memory manager must trace the graph of live
objects across pools.  This is an efficient way for policies to
communicate in order to trace the graph.


DESCRIPTION

The process of tracing the graph of objects is divided into two
abstract operations: scan and fix.

      Object
      .--------.            Object.Scan(Object)
      |        |                applies Fix to references in object
      |   *--------->
      |        |
      |   *--------->
      |        |
      |   *--------->
      `--------'

An object may contain references to other objects.  If the object is
live, then these references must be located in order to determine that
its children are live.  This is done by the scan function.  Since
objects may be in different format, and the references within them
stored in different ways, the scan function is determined by the type
of the object.  In other words, it is a generic function which
dispatches on the object type.  Scanning the object may update it,
because the references inside it are fixed up.  Scanning is
idempotent.

                     Pool
                     .----------------.     Fix(Reference)
                     |                |       check reference is interesting
                     |                |       dispatch to pool's fixer
     Reference       |   Object       |
     .-----.         |   .-------.    |
     |  *--------------->|       |    |
     `-----'         |   |       |    |
                     |   |       |    |
                     |   `-------'    |
                     |                |
                     `----------------'

When a reference is found in a live object it must be fixed.  In other
words, action must be taken to ensure that it is not recycled.  This
is done by the fix function.  Since objects may be managed by
different policies, the fix function is determined by who is managing
the object.  In other words, it is a generic function which dispatches
on the object pool.  Fixing the reference may change it, particularly
if it is being managed by a copying collector.  Fixing is idempotent.

  Scan : object -> object * greylist
  Fix  : reference -> reference * greylist

The scan/fix loop is the most critical loop in the memory manager.  It
is vital that scanning an object is very fast.  It is therefore vital
that fixing a reference is as cheap as possible.

The fix function will only ever update pointers to areas of memory
which are currently condemned, i.e. under consideration for recycling.
The scanner can test whether or not a reference refers to such an area
inline, provided that the representation is compact enough.  This
optimisation is provided by Zones, and a fast mapping from address to
segment provided by the Arena Manager.


JUSTIFICATION

MM.REQ.DYLAN.MM.RECLAIM, MM.REQ.ADAPT.MM.RECLAIM (Automatic memory
recycling): Tracing is the implementation of memory recycling.

MM.REQ.ADAPT.CONTROL.FLEX (Flexibility to meet a wide range of
end-user requirements): The scan/fix abstraction allows the user to
operate multiple policies and still get automatic memory recycling.

