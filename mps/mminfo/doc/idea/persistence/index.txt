                   SUPPORT FOR PERSISTENCE FOR DYLAN
                            idea.persistence
                            incomplete idea
                            tony 2000-03-02

SUMMARY

.summary: The Dylaners implement persistence for compiler databases via "DOOD" 
(the Dylan Object Oriented Database) which uses an object walker written in 
Dylan. The object walker is quite expensive, since it uses hashtables to map 
objects to addresses on a disk (which also serves the purpose of avoiding 
dumping an object more than once). It should be possible to support this much 
more efficiently in MPS. 

.start-point: If we were to provide support for save-image in Lisp (see 
idea.save-image(0)), we might expect to have the ability to dump a graph of 
objects from some roots, and to be able to restore those objects later into an 
equivalent root set. Assume we have to means to do this. Here we look at a way 
we could extend that facility to provide a dump of a more limited graph for 
Dylan.


DESCRIPTION

From: tony@harlequin.co.uk (Tony Mann)
To: Jonathan Bachrach <jonathan@harlequin.co.uk>
Subject: Re: really want persistent pool
Date: Tue, 22 Jun 1999 14:33:50 GMT
Cc: tony@harlequin.co.uk

On Tue, 22 Jun 1999 09:32:19 -0400, Jonathan Bachrach
<jonathan@harlequin.co.uk> wrote:

> tony,
> 
> the more i think about it the more i'm really into doing a persistent
> pool.  let me know what the plan might be.

OK in principle. I'm keen on the idea, and if our priorities don't get
reassigned we should be able to schedule it reasonably soon. But there's some
doubt about that last bit atm.

Here's a sketch of my thinking so far. Note that it doesn't involve a
persistent pool as such. Rather we're talking about a mechanism for adding
persistence support to the GC in general:-


We implement persistence by inventing a new "rank" in MPS. Ranks are the
mechanism for ordering the GC trace. Currently we have ranks in the following
order: Ambig, Exact, Final, Weak (used for ambiguous roots, normal objects,
finalization & weakness respectively). I propose adding a new rank "Persist"
between ranks Ambig & Exact.

When you want to dump a tree of objects, you must first declare a root (or
multiple roots) at rank Persist. We achieve the dump by performing a full
garbage collection:

 1. As normal, we do stack scanning first, and pin anything which must be
    pinned.

 2. Next we start tracing from the persistent root(s). Any objects which are 
    encountered are copied to a segment of rank Persist if possible. If the
    object can't be copied (e.g. because it has been pinned or because it's in
    a non-moving pool) then it is marked specially by some means instead.

 3. We finish the GC for all other ranks (which doesn't involve copying any
    further objects to segments at rank persist).

 4. Finally, we write all the data in persistent segments, and also any
    specially marked objects to a persistent heap file. We'd expect excellent
    locality as there should be few specially marked objects, and the
    persistent segments should be contiguous.

Step 4 is basically the save-image step that Lisp would use. However, we don't
dump the whole heap - just those bits that are reachable in this special way.

The persistent heap file can be read back in to a process provided that the
process contains an equivalent set of MPS pools, and an equivalent set of
persistent roots. At read-back time the roots will be updated, and objects may
end up being relocated in memory by another process that looks much like GC.
This is basically the same as a Lisp load-image.

Notes: the Dylan format code would need to be aware about rank Persist in order
to perform any special tracing. This is where any special support for proxy
objects or inter-DB references would be implemented. We'd provide a mechanism
so that format code could give up the MPS lock and call back into Dylan so that
you can implement this using Dylan code if you want.

This is still early days in the design process - but I'd welcome any feedback
from you now as to whether you think the approach sounds OK.


-- Tony

