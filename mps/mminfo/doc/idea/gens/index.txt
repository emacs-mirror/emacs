                        GENERALIZED GENERATIONS
                               idea.gens
                               draft idea
                           richard 1995-07-28

SUMMARY

This is a generalization of conventional generational collectors which
groups objects into sets with associated information which gives a
prediction of the time of death for those objects.  The collector can
then perform an approximate cost/benefit analysis of attempting to
collect each set.


DESCRIPTION

A conventional generational collector has a linear ordering of
"generations" (often only two).  Objects are "promoted" or "tenured"
from younger to older generations if they live long enough.  The idea
is that objects which live for time T are quite likely to live for
time 2T, so they are not worth examining before that time.
Essentially the age of the object is used to predict its time of
death.

   .-----.
   |     | Gen 2, collected with period NNT
   |     |
   `-----'
      ^
      | promotion
   .-----.
   |     | Gen 1, collected with period NT
   |     |
   `-----'
      ^
      | promotion
   .-----.
   |     | Gen 0, collected with period T
   |     |
   `-----'
      ^
      | allocation

In the scheme illustrated above the generation "number" is an
indication of the age of the generation contents, and therefore a
predicted time of death.  The generations are condemned at periods
derived from their number, usually with an exponential decay.  This is
the scheme used by MLWorks, a particularly fine language to apply the
method to.

A more advanced idea is to allow the collector to choose any division
of objects into sets according to its adaptive knowledge about
predictors of their death time.  For example, the collector could
group objects by their type, shape, size, age, allocator, or
combinations of such parameters.  The concept of generation is
therefore inverted: it is a grouping by time of death, not birth.

      .-----.       .-----.
      |     |       |Old  |
      |     |       |Pairs|
      `-----'       `-----'
         ^             ^        An instance of a dynamic scheme
         |             |        where one type of object has
      .-----.       .-----.     different death-rate characteristics
      |Other|       |Pairs|     to the others.
      |     |       |     |
      `-----'       `-----'
         ^             ^
          \"promotion"/
           \         /
             .-----.
             |     | Nursery, a semi-random assortment assortment
             |     |
             `-----'
                ^
                | allocation


The collector is attempting to satisfy a demand for memory from the
client while controlling resource consumption.  The tactical code of
the collector must decide which generations to condemn at the
beginning of each cycle.  The collector will have gathered statistical
information about the contents of each generation (size, type, etc.).
Previous collection cycles will have gathered experience about the
correlation between this information and time of object death.  The
tactical code combines these to decide on a course of action for the
next cycle.

The idea collector would make a completely accurate decision, and all
the objects in the condemned generations would be proved to be dead.
However, this will not occur in practice, and some objects will
survive.  This is the only opportunity to "promote" these surviving
objects to other generations based on new information available.  The
collector may have discovered that objects of a particular type
survive for some time, and will therefore group them together when the
opporrunity arises.  Of course, if an object survives then the very
fact that it did is information about that kind of object (and that is
the only fact taken into account by the traditional generational
collector).

In important concept in the implementation of such a collector is that
the generations are not "named" by, for example, a generation number.
The only information is that which is gathered about their contents,
and the tactical code decides on condemned sets and promotion paths
dynamically.

It is assumed that there exist useful subsets of the graph.


ISSUES

Which attributes of an object are important for predicting the time of
death?  The tactical code can select the significant ones at run-time,
but only from the set that have been implemented.  Measuring costs
time in critical loops in the code, so the set of attributes should be
as small as possible.  We need to measure many possible attributes and
learn which are important.

Writing the tactical code will be a challenge.

At may also be possible to prime the tactical system with empirical
information from our experience.  For exampple, we know that age is a
reasonable predictor of time of death, so perhaps that should be the
strongest initial working hypothesis.


JUSTIFICATION

MM.DYLAN.FUN.CONTROL.FLEX, MM.ADAPT.FUN.CONTROL.FLEX (Flexibility to
meet a range of end-user requirements): The tactical code groups
objects into sets in order to make predictions, and can therefore more
readily satisfy particular end-user requirements.

MM.DYLAN.FUN.CONTROL.DIAL, MM.ADAPT.FUN.CONTROL.DIAL (Measurement):
The collector is self-measuring, and can therefore easily provide
measurements to the client.

MM.DYLAN.ATTR.TIME.OVERHEAD (Dylan timing overhead attribute): The
tactical code is attempting to make best use of CPU time by only
condemning sets of objects it thinks are dead.  Dead objects cost
negligable amounts to collect compared to live objects, so the overall
time overhead should be reduced.

MM.DYLAN.ATTR.TIME.PAUSE (Dylan pause time attributes): Dividing
objects into sets for collection divides up the effort of collecting
the entire heap.  It is therefore possible that a non-incremental
generational collector could meet the pause time requirements,
provided the overhead of root scanning is not too high.

MM.DYLAN.ATTR.SPACE (Dylan timing space requirements): This scheme
_increases_ the space overhead, so this idea may impact negatively on
this requirement.  However, the overhead will be easily controllable
as a parameter to the tactics.

MM.ADAPT.FUN.CONTROL.KNOB (Control interface): The tactical code will
have a lot of scope for control in the way it makes decisions and
weights information gathered.

MM.ADAPT.FUN.MM.OPTIM (Dynamic optimization)

