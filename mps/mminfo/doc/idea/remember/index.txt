                            REMEMBERED SETS
                             idea.remember
                               draft idea
                           richard 1995-07-28

MM.IDEA.REMEMBER  Remembered Sets


SUMMARY

The cost of scanning can be significantly reduced by storing
"remembered sets" -- summaries of information about the references
stored in a particular subgraph.  The scanner is interested in the set
of references from the objects it is scanning to the objects which are
"interesting" to the current collections.  Since this corresponds
closely to the "interestingness" concept optimised by Zones
(mm/idea/zones) there is a highly efficient implementation using
Reference Signatures.


DESCRIPTION

              Set P                                   Set Q
        .----------------.                      .----------------.
        |  A-----------------------M------------------->E        |
        |  \             |                      |                |
        |   `>B<-----------------------N------------F            |
        |                |                      |                |
        |      C-------------------M------------------->G        |
        |      ^         |                      |                |
        |      `---D<------------------N-------------------H     |
        `----------------'                      `----------------'

In this diagram, the graph is divided into to subgraphs P and Q.  P
must be scanned in order to collect Q.  This process can be optimised
if we know exactly where the references from P to Q are.  The idea
here is to remember an approximation to the set of references labelled
M.

Using Zones, we can store the set of all Zones referenced by a set of
pointers in a single word called the Reference Signature.  If we store
the Reference Signature of P, then we can immediately tell whether or
not to scan the contents of P in order to collect Q.  If we sub-divide
P into smaller sets, then we can also decide quickly whether or not
each of them needs scanning.  A tree of signatures emerges, which
reduces the cost of scanning P from O(n) problem to O(log n).

              Set P {P,Q}                             Set Q {P}
        .----------------.                      .----------------.
  {P,Q} |  A-----------------------M------------------->E        | {}
        |- \ - - - - - - |                      |- - - - - - - - |
  {}    |   `>B<-----------------------N------------F            | {P}
        |- - - - - - - - |                      |- - - - - - - - |
  {Q}   |      C-------------------M------------------->G        | {}
        |- - - ^ - - - - |                      |- - - - - - - - |
  {P}   |      `---D<------------------N-------------------H     | {P}
        `----------------'                      `----------------'

In the diagram above the scan(P wrt. Q) only need scan A and D.

The Reference Signature can be accumulated by scan itself.  After
scanning A and D above it will have a new signature accumulated from
the new values of the references.  However, the signature is only
valid as long as the data in the object doesn't change.  A
write-barrier is installed on the objects.  When the barrier is hit,
the reference signature can be marked as invalid (or updated to be the
universal set) and the barrier removed.

Since the cost of a write-barrier is non-trivial, the collector must
decide whether or not to use this remembered set implementation.  The
cost of the barrier must be weighed against the cost of scanning and
the number of references present.  If there are a lot of references
then there's not much point trying to remember them.  If there are few
references then it is desirable to cut the cost of scanning by
remembering where they are.  However, this may be too expensive (or
too disruptive) in an area of the heap which is frequently updated by
the mutator.

In a traditional generational scheme older generations are assumed not
to refer to younger ones, and so it would be sensible to install a
barrier on the older ones.  However, in a more general scheme
(mm/idea/gens) the relationship is not so clear.  The decision should
be made dynamically using a cost/benefit analysis.


JUSTIFICATION

- Performance (reduce scanning time)
- Virtual memory efficiency (don't hit pages which aren't written)

