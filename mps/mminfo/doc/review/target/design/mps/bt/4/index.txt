         CANONICAL DOCUMENT FOR THE REVIEW OF DESIGN.MPS.BT(4)
                     review.target.design.mps.bt.4
                             incomplete doc
                             drj 1999-04-29

.source: This is a frozen copy of design.mps.bt(4) with added line numbers.  It 
is to be reviewed on 1999-04-29

     1  design.mps.bt(4)  draft doc
     2  
     3  BIT TABLES
     4  drj, 1997-03-04
     5  
     6  
     7  INTRODUCTION
     8  
     9  .readership: Any MPS developer.
    10  
    11  .intro: This is the design of the Bit Tables module.  Bit Tables are
    12  used in the MPS to represent a mapping from a set of integers which is
    13  an interval (intervals will usually the closed on the left and open on
    14  the right: [0,n)) to the set {FALSE, TRUE}.  This mapping can be
    15  considered as a linear array (table) of bits, with each bit
    16  corresponding to an integer from 0 up to, but not including, n.
    17  Unsurprisingly, the mapping is implemented using an array of n bits
    18  (using however many Words that requires in C).  A variety of operations
    19  are provided including: set, reset, and retrieve, individual bits; set
    20  and reset a contiguous range of bits; search for a contiguous range of
    21  reset bits; making a "negative image" copy of a range.
    22  
    23  
    24  HISTORY
    25  
    26  .history.0-3: The history for versions 0-3 is lost pending possible
    27  reconstruction.
    28  
    29  .history.4: Prepared for review.  Added full requirements section.  Made
    30  notation more consistent throughout.  Documented all functions.  drj
    31  1999-04-29
    32  
    33  
    34  DEFINITIONS
    35  
    36  .def.set: Set. To assign the value 1 or TRUE to a bit.
    37  
    38  .def.reset: Reset.  To assign the value 0 or FALSE to a bit.
    39  
    40  [consider using "fill/empty" or "mark/clear" instead of "set/reset",
    41  set/reset is probably a hangover from drj's z80 hacking days -- drj
    42  1999-04-26]
    43  
    44  .def.bt: Bit Table.  A Bit Table is a mapping from [0,n) to {0,1} for
    45  some n.  .def.bt.justify: They are called bit tables because a single
    46  bit can be used to encode whether the image of a particular integer
    47  under the map is 0 or 1.
    48  
    49  .def.range: Range.  A contiguous sequence of bits in a Bit Table.
    50  Ranges are typically specified as a base--limit pair where the range
    51  includes the position specified by the base, but excludes that specified
    52  by the limit (ie they are half-open intervals [base, limit)).
    53  
    54  
    55  REQUIREMENTS
    56  
    57  .req.bit: The storage for a Bit Table of n bits shall take no more than
    58  a small constant addition to the storage required for n bits.
    59  .req.create: A means to create Bit Tables.
    60  .req.destroy: A means to destroy Bit Tables.
    61  .req.ops: The following operations shall be supported:
    62    .req.ops.get: Get the values of a bit.  IE apply the mapping from an
    63  index i to its image in {0,1}
    64    .req.ops.set: Set a bit.  IE make the bit 1, such that under the
    65  mapping the bit's image is 1.
    66    .req.ops.reset: Reset a bit.  IE make the bit 0, such that under the
    67  mapping the bit's image is 0.
    68    .req.ops.set.range: Set a contiguous range of bits.
    69    .req.ops.reset.range: Reset a contiguous range of bits.
    70    .req.ops.test.range.set: Test whether a contiguous range of bits are
    71  all set.
    72    .req.ops.test.range.reset: Test whether a contiguous range of bits are
    73  all reset.
    74    .req.ops.test.range.same: Test whether two contiguous ranges (from
    75  different Bit Tables) are the same.
    76    .req.ops.find: Find a contiguous range (which we'll denote [i,j))  of
    77  at least 'length' reset bits:
    78      .req.ops.find.short.low: Of all ranges [i,j) with at least length
    79  reset bits, find the range with least j (find the leftmost range that
    80  has at least length reset bits and return just enough of that).
    81      .req.ops.find.short.high: Of all ranges [i, j) with at least length
    82  reset bits, find the range with greatest i (find the rightmost range
    83  that has at least length reset bits and return just enough of that).
    84      .req.ops.find.long.low: Of all ranges [i,j) with at least length
    85  reset bits, find a range with least i and of those find the one with
    86  greatest j (find the leftmost range that has at least length reset bits
    87  and return all of it).
    88      .req.ops.find.long.high: Of all ranges [i,j) with at least length
    89  reset bits, find a range with greatest j and of those return the one
    90  with least i (find the rightmost range that has at least length reset
    91  bits and return all of it).
    92    .req.ops.copy.invert: Copy a contiguous range of bits from one bit
    93  table to another inverting all the bits in the target copy (!).
    94  .req.speed: Operations shall take no more than a few memory operations
    95  per bit manipulated.
    96  .req.speed.fast: The following operations shall be very fast:
    97  
    98  BTFindShortResRange (the operation used to meet .req.ops.find.short.low)
    99  BTFindShortResRangeHigh (the operation used to meet
   100  .req.ops.find.short.high)
   101  
   102  These two are used by the client arena (design.mps.arena.client) and the
   103  VM arena (design.mps.arena.vm) for finding segments in page tables.
   104  They will be called with a length equal to the number of pages in a
   105  segment.  Typical values of this length depend on the pool classes used
   106  and their configuration, but we can expect length to be small (1 to 16)
   107  usually.  We can expect the Bit Table to be populated densely where it
   108  is populated at all, that is lots of runs of set bits.
   109  
   110  BTFindLongResRange (the operation used to meet .req.ops.find.long.low)
   111  
   112  Used in pool class AWL's allocator.  The length of range to be found
   113  will be the length of a dylan object in words (the mean length of a
   114  dylan object is about 10 words in so far as that might mean anything).
   115  
   116  
   117  BACKGROUND
   118  
   119  .background: Originally Bit Tables were used and implemented by
   120  PoolClassLO (design.mps.poollo).  It was decided to lift them out into a
   121  separate module when designing the Pool to manage Dylan Weak Tables
   122  which is also a mark and sweep pool and will make use of Bit Tables (see
   123  design.mps.poolawl).
   124  .background.analysis: analysis.mps.bt(0) contains some of the analysis
   125  of the design decisions that were and were not made in this document.
   126  
   127  
   128  CLIENTS
   129  
   130  .clients: Bit Tables are used throughout the MPS but the important uses
   131  are: In the client and VM arenas (design.mps.arena.client(0) and
   132  design.mps.arena.vm(1)) a bit table is used to record whether each page
   133  is free or not; several pool classes (PoolClassLO, PoolClassEPVM,
   134  PoolClassAMS) use bit tables to record which locations are free (and
   135  also to store colour).
   136  
   137  
   138  OVERVIEW
   139  
   140  .over: Mostly, the design is as simple as possible.  The significant
   141  complications are iteration (see .iteration below) and searching (see
   142  .fun.find-res-range below) because both of these are required to be
   143  fast.
   144  
   145  
   146  INTERFACE
   147  
   148  .if.representation.abstract: A Bit Table is represented by the type BT.
   149  
   150  .if.declare: The module declares a type BT and a prototype for each of
   151  the functions below.  The type is declared in impl.h.mpmtypes, the
   152  prototypes are declared in impl.h.mpm.
   153  
   154  .if.general.index: Many of the functions specified below take indexes.
   155  If otherwise unspecified an index must be in the interval [0,n) (note,
   156  up to, but not including, n) where n is the number of bits in the
   157  relevant Bit Table (as passed to the BTCreate function).
   158  .if.general.range: Where a range is specified by two indexes base and
   159  limit, base, which specifies the beginning of the range, must be in the
   160  interval [0,n), limit, which specifies the end of the range, must be in
   161  the interval [1,n] (note can be n), and base must be strictly less than
   162  limit (empty ranges are not allowed).  Sometimes i and j are used
   163  instead of base and limit.
   164  
   165  .if.create:
   166  Res BTCreate(BT *btReturn, Arena arena, Count n)
   167  
   168  Attempts to create a table from [0,n) in the arena control pool, putting
   169  the table in '*btReturn'. Returns ResOK if and only if the table is
   170  created OK.  The initial values of the bits in the table are undefined
   171  (so the client should probably call BTResRange on the entire range
   172  before using the BT).  Meets .req.create.
   173  
   174  .if.destroy:
   175  void BTDestroy(BT t, Arena arena, Count n);
   176  
   177  Destroys the table t, which must have been created with BTCreate
   178  (.if.create).  Meets .req.destroy.
   179  
   180  
   181  .if.size:
   182  size_t BTSize(unsigned long n);
   183  
   184  BTSize(n) returns the number of bytes needed for a bit table of n bits,
   185  ie the range [0,n).  It is a checked error (an assertion will fail) for
   186  n to exceed ULONG_MAX - MPS_WORD_WIDTH + 1.  This is used by clients
   187  that allocate storage for the BT themselves.  Before BTCreate and
   188  BTDestroy were implemented that was the only way to allocate a Bit
   189  Table, but is now deprecated.
   190  
   191  .if.get:
   192  int BTGet(BT t, Index i);
   193  
   194  BTGet(t, i) returns the ith bit of the table t (i.e. the image of i
   195  under the mapping).  Meets .req.ops.get.
   196  
   197  .if.set:
   198  void BTSet(BT t, Index i);
   199  
   200  BTSet(t, i) sets the ith bit of the table t (to 1).  BTGet(t, i) will
   201  now return 1.  Meets .req.ops.set.
   202  
   203  .if.res:
   204  void BTRes(BT t, Index i);
   205  
   206  BTRes(t, i) resets the ith bit of the table t (to 0).  BTGet(t, i) will
   207  now return 0.  Meets .req.ops.res.
   208  
   209  .if.set-range:
   210  void BTSetRange(BT t, Index base, Index limit);
   211  
   212  BTSetRange(t, base, limit) sets the range of bits [base, limit) in the
   213  table t.  BTGet(t, x) will now return 1 for base<=x<limit.  Meets
   214  .req.ops.range.set.
   215  
   216  .if.res-range:
   217  void BTResRange(BT t, Index base, Index limit);
   218  
   219  BTResRange(t, base, limit) resets the range of bits [base, limit) in the
   220  table t.  BTGet(t, x) will now return 0 for base<=x<limit.  Meets
   221  .req.ops.range.res.
   222  
   223  .if.test.range.set:
   224  Bool BTIsSetRange(BT bt, Index base, Index limit);
   225  
   226  Returns TRUE if all the bits in the range [base, limit) are set, FALSE
   227  otherwise.  Meets .req.ops.test.range.set.
   228  
   229  .if.test.range.reset:
   230  Bool BTIsResRange(BT bt, Index base, Index limit);
   231  
   232  Returns TRUE if all the bits in the range [base, limit) are reset, FALSE
   233  otherwise.  Meets .req.ops.test.range.reset.
   234  
   235  .if.test.range.same: 
   236  Bool BTRangesSame(BT BTx, BT BTy, Index base, Index limit);
   237  
   238  returns TRUE if BTGet(BTx,i) equals BTGet(BTy,i) for i in [base, limit),
   239  and false otherwise.  Meets .req.ops.test.range.same
   240  
   241  .if.find.general: There are four functions (below) to find reset ranges.
   242  All the functions have the same prototype (for symmetry):
   243  Bool find(Index *baseReturn, Index *limitReturn,
   244            BT bt,
   245            Index searchBase, Index searchLimit,
   246            unsigned long length);
   247  
   248  bt is the Bit Table in which to search.  searchBase and searchLimit
   249  specify a subset of the Bit Table to use, the functions will only find
   250  ranges that are subsets of [searchBase, searchLimit) (ie when set
   251  *baseReturn will never be less than searchBase and *limitReturn will
   252  never be greater than searchLimit).  searchBase, searchLimit specify a
   253  range that must conform to the general range requirements for a range
   254  [i,j), as per .if.general.range modified appropriately.  length is the
   255  number of contiguous reset bits to find; it must not be bigger than
   256  searchLimit - searchBase (that would be silly).  If a suitable range
   257  cannot be found the function returns FALSE (0) and leaves *baseReturn
   258  and *limitReturn untouched.  If a suitable range is found then the
   259  function returns the range's base in *baseReturn and its limit in
   260  *limitReturn and returns TRUE (1).
   261  
   262  .if.find-short-res-range:
   263  Bool BTFindShortResRange(Index *baseReturn, Index *limitReturn,
   264                           BT bt,
   265                           Index searchBase, Index searchLimit,
   266                           unsigned long length);
   267  
   268  BTFindShortResRange(&base, &limit, table, searchBase, searchLimit,
   269  length) finds a range of reset bits in the table, starting at searchBase
   270  and working upwards.  This function is intended to meet
   271  .req.ops.find.short.low so it will find the leftmost range that will do,
   272  and never finds a range longer than the requested length (the intention
   273  is that it will not waste time looking).
   274  
   275  .if.find-short-res-range-high:
   276  Bool BTFindShortResRangeHigh(Index *baseReturn, Index *limitReturn,
   277                               BT bt,
   278                               Index searchBase, Index searchLimit,
   279                               unsigned long length);
   280  
   281  BTFindShortResRangeHigh(&base, &limit, table, searchBase, searchLimit,
   282  length) finds a range of reset bits in the table, starting at
   283  searchLimit and working downwards. This function is intended to meet
   284  .req.ops.find.short.high so it will find the rightmost range that will
   285  do, and never finds a range londer than the requested length.
   286  
   287  .if.find-long-res-range:
   288  Bool BTFindLongResRange(Index *baseReturn, Index *limitReturn,
   289                          BT bt,
   290                          Index searchBase, Index searchLimit,
   291                          unsigned long length);
   292  
   293  BTFindLongResRange(&base, &limit, table, searchBase, searchLimit,
   294  length) finds a range of reset bits in the table, starting at searchBase
   295  and working upwards.  This function is intended to meet
   296  .req.ops.find.long.low so it will find the leftmost range that will do
   297  and returns all of that range (which can be longer than the requested
   298  length).
   299  
   300  .if.find-long-res-range-high:
   301  Bool BTFindLongResRangeHigh(Index *baseReturn, Index *limitReturn,
   302                              BT bt,
   303                              Index searchBase, Index searchLimit,
   304                              unsigned long length);
   305  
   306  BTFindLongResRangeHigh(&base, &limit, table, searchBase, searchLimit,
   307  length) finds a range of reset bits in the table, starting at
   308  searchLimit and working downwards.  This function is intended to meet
   309  .req.ops.find.long.high so it will find the rightmost range that will do
   310  and returns all that range (which can be longer than the requested
   311  length).
   312  
   313  .if.copy-invert-range:
   314  extern void BTCopyInvertRange(BT fromBT, BT toBT, Index base, Index
   315  limit);
   316  
   317  overwrites the ith bit of toBT with the inverse of the ith bit of
   318  fromBT, for all i in [base, limit).  Meets .req.ops.copy.invert.
   319  
   320  
   321  DETAILED DESIGN
   322  
   323  
   324  DataStructures
   325  
   326  .words: Bit Tables will be represented as (a pointer to) an array of
   327  Words.  There are no other datastructures.  .words.justify: Words are
   328  used as these will probably map to the object that can be most
   329  efficiently accessed on any particular platform.
   330  
   331  
   332  
   333  Functions
   334  
   335  .fun.size: BTSize.
   336  Since Bit Tables are an array of Words, the size of a Bit Table of n
   337  bits is simply the number of Words that it takes to store n bits times
   338  the number of bytes in a Word.  This is
   339  ceiling(n/MPS_WORD_WIDTH)*sizeof(Word).  .fun.size.justify: Since there
   340  can be at most MPS_WORD_WIDTH-1 unused bits in the entire table, this
   341  satisfies .req.bit.
   342  
   343  .index: The designs for the following functions use a decomposition of a
   344  bit-index, i, into two parts, iw, ib.  .index.word: iw is the
   345  "word-index" which is the index into the word array of the word that
   346  contains the bit referred to by the bit-index.  iw = i / MPS_WORD_WIDTH.
   347  Since MPS_WORD_WIDTH is a power-of-two, this is the same as iw = i >>
   348  MPS_WORD_SHIFT.  The latter expression is used in the code.
   349  .index.word.justify: The compiler is more likely to generate good code
   350  without the divide.  .index.sub-word: ib is the "sub-word-index" which
   351  is the index of the bit referred to by the bit-index in the above word.
   352  ib = i % MPS_WORD_WIDTH.  Since MPS_WORD_WIDTH is a power-of-two, this
   353  is the same as ib = i & ~((Word)-1<<MPS_WORD_SHIFT).  The latter
   354  expression is used in the code.  .index.sub-word.justify: The compiler
   355  is more likely to generate good code without the modulus.
   356  
   357  .index.justify.dubious: The above justifications are dubious; gcc 2.7.2
   358  (with -O2) running on a sparc (zaphod) produces identical code for the
   359  following two functions:
   360  
   361  unsigned long f(unsigned long i)
   362  { return i/32 + i%32; }
   363  
   364  unsigned long g(unsigned long i)
   365  { return (i>>5) + (i&31); }
   366  
   367  .iteration: Many of the following functions involve iteration over
   368  ranges in a Bit Table. This is performed on whole words rather than
   369  individual bits, whenever possible (to improve speed). This is
   370  implemented internally by the macros ACT_ON_RANGE & ACT_ON_RANGE_HIGH
   371  for iterating over the range forwards and backwards respectively. These
   372  macros do not form part of the interface of the module, but are used
   373  extensively in the implementation.  The macros are often used even when
   374  speed is not an issue because it simplifies the implementation and makes
   375  it more uniform.  The iteration macros take the parameters (base, limit,
   376  single_action, bits_action, word_action).
   377    
   378    base, limit are of type Index and define the range of the iteration
   379    single_action is the name of a macro which will be used for iterating
   380  over bits in the table individually. This macro must take a single Index
   381  parameter corresponding to the index for the bit.  The macro must not
   382  use break or continue because it will be called from within a loop from
   383  the expansion of ACT_ON_RANGE.
   384    bits_action is the name of a macro which will be used for iterating
   385  over part-words. This macro must take parameters (wordIndex, base,
   386  limit) where wordIndex is the index into the array of words, and base &
   387  limit befine a range of bits within the indexed word.
   388    word_action is the name of a macro which will be used for iterating
   389  over whole-words. This macro must take the parameter (wordIndex) where
   390  wordIndex is the index of the whole-word in the array.  The macro must
   391  not use break or continue because it will be called from within a loop
   392  from the expansion of ACT_ON_RANGE.
   393  
   394  If the range is sufficiently small only the single_action macro will be
   395  used as this is more efficient in practice.  The choice of what
   396  constitutes a small range is made entirely on the basis of experimental
   397  performance results (and currently, 1998-04-27, a "small range" is 6
   398  bits or fewer.  See change.mps.epcore.brisling.160181 for some
   399  justification).  Otherwise (for a bigger range) bits_action is used on
   400  the part words at either end of the range (or the whole of the range it
   401  if it fits in a single word), and word_action is used on the words that
   402  comprise the inner portion of the range.
   403  
   404  The implementation of ACT_ON_RANGE (and ACT_ON_RANGE_HIGH) is simple
   405  enough.  It decides which macros it should invoke and invokes them.
   406  single_action and word_action are invoked inside loops.
   407  
   408  
   409  .fun.get: BTGet.
   410  The bit-index will be converted in the usual way, see .index.  The
   411  relevant Word will be read out of the Bit Table and shifted right by the
   412  sub-Word index (this brings the relevent bit down to the least
   413  significant bit of the Word), the Word will then be masked with 1
   414  producing the answer.
   415  
   416  .fun.set: BTSet
   417  
   418  .fun.res: BTRes
   419  
   420  In both BTSet and BTRes a mask is constructed by shifting 1 left by the
   421  sub-word-index (see .index).  For BTSet the mask is ORed into the
   422  relevant word (thereby setting a single bit).  For BTRes the mask is
   423  inverted and ANDed into the relevant word (thereby resetting a single
   424  bit).
   425  
   426  .fun.set-range: BTSetRange
   427  
   428  ACT_ON_RANGE (see .iteration above) is used with macros that set a
   429  single bit (using BTSet), set a range of bits in a word, and set a whole
   430  word.
   431  
   432  .fun.res-range: BTResRange
   433  This is implemented similarly to BTSetRange (.fun.set-range) except
   434  using BTRes & reverse bit masking logic.
   435  
   436  .fun.test.range.set: BTIsSetRange
   437  ACT_ON_RANGE (see .iteration above) is used with macros that return
   438  FALSE unless all the relevant bits are set.
   439  
   440  .fun.test.range.reset: BTIsResRange
   441  as for BTIsSetRange (.fun.test.range.set above) but testing whether the
   442  bits are reset.
   443  
   444  .fun.test.range.same: BTRangesSame
   445  
   446  Uses ACT_ON_RANGE (see .iteration above) with the obvious
   447  implementation.  Should be fast - although there are no speed
   448  requirements.
   449  
   450  
   451  .fun.find: The four external find functions (BTFindShortResRange,
   452  BTFindShortResRangeHigh, BTFindLongResRange, BTFindLongResRangeHigh)
   453  simply call through to one of the two internal functions:
   454  BTFindResRange, BTFindResRangeHigh.   BTFindResRange and
   455  BTFindResRangeHigh both have the following prototype (with a different
   456  name obviously):
   457  
   458  Bool BTFindResRange(Index *baseReturn, Index *limitReturn,
   459                      BT bt,
   460                      Index searchBase, Index searchLimit,
   461                      unsigned long minLength,
   462                      unsigned long maxLength)
   463  
   464  There are two length parameters, one specifying the minimum length of
   465  the range to be found, the other the maximum length.  For BTFindShort*
   466  maxLength is equal to minLength when passed; for BTFindLong* maxLength
   467  is equal to the maximum possible range (searchLimit - searchBase).
   468  
   469  .fun.find-res-range: BTFindResRange
   470  Iterate within the search boundaries, identifying candidate ranges by
   471  searching for a reset bit.  The Boyer-Moore algorithm (reference
   472  please?) is used (it's particularly easy when there are only two
   473  symbols, 0 and 1, in the alphabet).  For each candidate range, iterate
   474  backwards over the bits from the end of the range towards the beginning.
   475  If a set bit is found, this candidate has failed and a new candidate
   476  range is selected.  If when scanning for the set bit a range of reset
   477  bits was found before finding the set bit, then this (small) range of
   478  reset bits is used as the start of the next candidate.  Additionally the
   479  end of this small range of reset bits (IE the end of the failed
   480  candidate range) is remembered so that we don't have to iterate over
   481  this range again.  But if no reset bits were found in the candidate
   482  range, then iterate again (starting from the end of the failed
   483  candidate) to look for one.  If during the backwards search no set bit
   484  is found, then we have found a sufficiently large range of reset bits;
   485  now extend the valid range as far as possible up to the maximum length
   486  by iterating forwards up to the maximum limit looking for a set bit.
   487  The iterations make use of the ACT_ON_RANGE & ACT_ON_RANGE_HIGH macros
   488  and hence are efficient at using whole words.  The macro
   489  ACTION_FIND_SET_BIT is used in the iterations, it efficiently finds the
   490  first (ie with lowest index or weight) set bit in a word or subword.  
   491  
   492  .fun.find-res-range.improve: Various other performance improvements have
   493  been suggested in the past, including some from request.epcore.170534.
   494  Here is a list of potential improvements which all sound plausible, but
   495  which have not led to performance improvements in practice:
   496  
   497  .fun.find-res-range.improve.step.partial: When the top index in a
   498  candidate
   499  range fails, skip partial words as well as whole words, using
   500  e.g. lookup tables.
   501  
   502  .fun.find-res-range.improve.lookup: When testing a candidate run,
   503  examine multiple bits at once (e.g. 8), using lookup tables for (e.g)
   504  index of first set bit, index of last set bit, number of reset bits,
   505  length of maximum run of reset bits.
   506  
   507  .fun.find-res-range-high: BTFindResRangeHigh
   508  Exactly the same algorithm as in BTFindResRange (see .fun.find-res-range
   509  above), but moving over the table in the opposite direction.
   510  
   511  .fun.copy-invert-range: BTCopyInvertRange.
   512  Uses ACT_ON_RANGE (see .iteration above) with the obvious
   513  implementation.  Should be fast - although there are no speed
   514  requirements.
   515  
   516  
   517  

