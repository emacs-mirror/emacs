                DESCRIPTION OF THE MPS SCANNING PROTOCOL
                         protocol.mps.scanning
                             incomplete doc
                            pekka 1998-01-27

BACKGROUND

.intro: @@@@


RELATIONSHIP TO OTHER PROTOCOLS

.rel.ap: The AP protocol ensures uninitialized (i.e., uncommitted) objects are 
never scanned.  [even if it does I'm not sure it should.  We have discussed in 
the past the idea of ambiguously scanning the stuff between init and alloc in 
the buffer, which would enable us to do a non-failing commit protocol on APs -- 
drj 1998-02-03]


SCANNING FUNCTIONS


.scanner.use: The purpose of scanning an object is to locate and process all 
the references in that object.  Scanning is usually done as a part of tracing.

.scanner.critical: Scanning is one of the most critical client functions.  In 
order for GC to proceed quickly, the scanner has to be fast, because all 
objects will be scanned at some point.  [Not true, we go into a lot of trouble 
to avoid scanning all objects.  It is, however, what the GC is doing most of 
the time.  Pekka 1997-10-27  All reachable objects will be scanned at some 
point because when they are created we make no assumptions about what they 
point to, just not as often as once per collection.  The only objects we don't 
scan are dead ones.  drj 1998-08-27]

.scanner.fix: References are indicated to the MPS by "fixing" them.  The MPS C 
interface provides a function called "mps_fix" that fixes a single reference, 
and several macros that can be used to do that more efficiently.

.scanner.layout: The general layout of a scan method is as follows:

Scan(ScanState, Base, Limit)
  for Object = each object between Base and Limit
    for Location = location of each reference in Object
      Fix(ScanState, Location)

This might modify the contents of the locations.

.scanner.decode: The references in the objects could be stored in a form that's 
different from the one supported by the MPS interface (see 
doc.mps.ref-man.concepts.reference for examples); in that case, the scan method 
has to decode the reference before passing it to Fix, and possibly re-encode 
the updated reference after Fix.  An example about stripping off a tag:
  1. copying the tag portion of the reference to another location, 
  2. removing the tag section of the old location,
  3. fixing the reference, and 
  4. copying the tag back.


Examples of a Scan Methods in C

.scanner.ex.simple: Here's a simple scan method:

mps_res_t foo_scan(mps_ss_t scan_state, mps_addr_t base, mps_addr_t limit)
{
  /* We have Objects which contain two pointer fields, left and right. */
  Object *obj;
  Object *obj_limit;

  obj_limit = limit;
  for(obj = base; obj < obj_limit; obj++) {
    if(mps_fix(scan_state, &obj->left) != MPS_RES_OK)
      return res;
    if(mps_fix(scan_state, &obj->right) != MPS_RES_OK)
      return res;
  }
  return MPS_RES_OK;
}

.scanner.res: If the fixing fails, the scan method must stop and return the 
error code (as in the code above).  Later, the scan method will (probably) be 
called again on the same object to complete the scanning.

.scanner.ex.faster: We can speed things up a bit by using the macros:

mps_res_t foo_scan(mps_ss_t scan_state, mps_addr_t base, mps_addr_t limit)
{
  Object *obj;
  Object *obj_limit;

  obj_limit = limit;
  MPS_SCAN_BEGIN(scan_state)
    for(obj = base; obj < obj_limit; obj++) {
      if(MPS_FIX(scan_state, &obj->left) != MPS_RES_OK)
        return res;
      if(MPS_FIX(scan_state, &obj->right) != MPS_RES_OK)
        return res;
    }
  MPS_SCAN_END(scan_state);
  return MPS_RES_OK;
}

.scanner.begin-end: MPS_SCAN_BEGIN sets up local information used by MPS_FIX, 
MPS_FIX1 and MPS_FIX2, making things faster.  MPS_SCAN_END completes the 
scanning started by MPS_SCAN_BEGIN.  The MPS_FIX macros may not be used except 
within MPS_SCAN_BEGIN and MPS_SCAN_END, which can only be used in scan methods.

.scanner.fix-1: Further speedups can be achieved by splitting MPS_FIX into two 
macros: MPS_FIX1 and MPS_FIX2.  MPS_FIX1 is a fast test to see if the reference 
is likely to be interesting to the MPS; if it returns false, the scanner can 
proceed to the next reference.  If it returns true, the scan method can apply 
further, slower tests to it, before deciding to invoke MPS_FIX2, which does the 
actual fixing.

.scanner.ex.pseudo-code: A general pseudo-code implementation of a scan method 
is:

mps_res_t foo_scan(mps_ss_t state, mps_addr_t base, mps_addr_t limit)
{
  [setup]
  MPS_SCAN_BEGIN(state)
    [loop over the objects]
      [find pointers in the object]
        if(MPS_FIX1(state, ptr)) /* test whether interesting to scanner */ {
          [possibly more format-specific tests]
          res = MPS_FIX2(state, &ptr) /* if yes, then fix */ 
          if(res != MPS_RES_OK)
            return res;
        }
  MPS_SCAN_END(state);
  return MPS_RES_OK;
}

.scanner.call: When using the macros, you can't directly use a separate 
function to do part of the scanning, because between MPS_SCAN_BEGIN and 
MPS_SCAN_END, the scan_state parameter is in a strange state, so you shouldn't 
pass it as an argument to a function.  However, if you want to split off part 
of the scanning to a separate function (say, because you have an embedded 
structure shared between two scan methods), you can pass the scan state using 
MPS_FIX_CALL.

mps_res_t foo_scan(mps_ss_t scan_state, mps_addr_t base, mps_addr_t limit)
{
  Object *obj;
  Object *obj_limit;
  mps_res_t res;

  obj_limit = limit;
  MPS_SCAN_BEGIN(scan_state)
    for(obj = base; obj < obj_limit; obj++) {
      if(MPS_FIX(scan_state, &obj->left) != MPS_RES_OK)
        return res;
      MPS_FIX_CALL(scan_state,
                   res = scan_data(scan_state, &obj->data));
      if(res != MPS_RES_OK) return res;
      if(MPS_FIX(scan_state, &obj->right) != MPS_RES_OK)
        return res;
    }
  MPS_SCAN_END(scan_state);
  return MPS_RES_OK;
}


Scanner Optimization

.scanner.speed: One way to make the scan fast is to avoid calling the mps_fix 
function unless necessary.  When writing a scanner, you can use the special 
macros described above -- MPS_SCAN_BEGIN, MPS_SCAN_END, MPS_FIX1, and MPS_FIX2 
-- to aid in optimizing the scanner code.  You can also try varying the order 
of your tests and MPS_FIX1 to see which is faster.

.scanner.avoid: Writing good scanning functions is an art form.  You should 
avoid invoking MPS_FIX2 unless necessary, and also avoid using too many local 
variables between SCAN_BEGIN and SCAN_END.  The latter constraint is useful 
because the number of registers is limited, and the scanner is faster if it can 
store all values in registers.


Example of a Scanner Using a Simple Lisp Object

.scanner.ex.lisp: The cons contains a bit that is clear if the object contains 
pointers, and set if it does not.  If the bit is clear, then the scanner needs 
to fix the object.  If the bit is set, the scanner can skip the object.  
Because the object is so simple, the scanner can perform FIX1 and FIX2 at the 
same time.

pair_scan 
  if (flag) 
    MPS_SCAN_BEGIN(fixer) 
      res = MPS_FIX(...car) ; 
      if res = ...
      res = MPS_FIX(...cdr) ; 
      if res = ...
   MPS_SCAN_END(...) 

[This is lousy.  Need more examples here (or somewhere).]


Restrictions on Scanners

.restr.visible: If a reference is hidden from the MPS -- that is, the scanner 
is unable to "fix" the reference -- then that reference might become invalid.  
The client program will probably continue to run for some time, but at some 
point, it will probably crash. 

.restr.example: An example of how to avoid a hidden pointer in the Lisp object 
mentioned earlier (with the single difference that the bit is clear if the car 
is a reference, and set if both car and cdr are references ["It's just the same 
except it's all different."  Pekka 1997-10-27]) is to first set the cdr to 
zero, then set the bit, then make the cdr into a reference.  Otherwise, the 
client program will end up with either a hidden pointer, or junk in the cdr 
that will cause the MPS to crash.

