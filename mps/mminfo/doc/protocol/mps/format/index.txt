                 DESCRIPTION OF THE MPS FORMAT PROTOCOL
                          protocol.mps.format
                             incomplete doc
                             lmb 1997-05-14

INTRODUCTION

.intro: This document describes the MPS format protocol.  The protocol provides 
a framework for communication between a client application and the MPS 
regarding the details of client object formats.  The protocol gives the client 
application a high degree of freedom in how the client objects are represented 
in memory, the primary concerns being the location of references in an object 
and the representation of references.


OVERVIEW

.overview: The need for some means of describing client objects comes from 
tracing.  When a client object is scanned, all the references in the object are 
scanned (the MPS provides a function that scans a single reference).  
Additionally, as part of a tracing process, the MPS may move objects; this 
movement entails adjusting all the references to each moved object.  This 
adjustment takes place when each reference is scanned.

In general, only the client application can say which fields in an object are 
references, and only the client application knows how references are 
represented in that object.  The format protocol provides a means by which this 
information can be communicated to the MPS.

.overview.capsule: The layout of client objects is contained in a format.  In 
the MPS C interface, a format is represented by an object of type "mps_fmt_t" 
(an opaque type).

.overview.methods: A format is a collection of methods and other (usually 
scalar) values which together describe (programmatically) the layout of client 
objects.  Details are given below.  Some typical methods might be to:

- calculate an object's length.
- locate all the references in an object.
- adjust the value of each reference in an object.
- make a copy of an object.
- delete an object and replace it with a "broken heart".  The client 
application must set up a broken heart so that it can be distinguished from 
ordinary client objects and contains a reference to an object.  

.overview.pools: Formats are used only by certain pool classes.  Typically a 
pool class that is collected or scanned will use a format.

.overview.pools.different: Different pool classes will use formats in different 
ways.  For example, a copying garbage-collected pool may need methods to: 

- calculate the length of an object.
- copy an object.
- scan an object.
- replace an object with a broken heart.

A non-moving mark-and-sweep pool, on the other hand, may only need methods to 
calculate the length of an object and to scan an object.

.overview.variant: To accommodate this variance in pool classes' needs, it is 
possible to construct formats from different collections of methods and 
values.  A specific collection of methods and values is called a format 
variant.  A format is constructed from a format variant.  A format variant is a 
transparent type; in the C interface, a format variant is an object of a 
particular structure type.  The client application must allocate store for, 
initialize, and destroy the format variant [confusion between a variant and a 
variant instance, too specific for overview.  Pekka 1997-10-27].  See 
"Variants", below, for more details.


USAGE OVERVIEW

.usage.pool-centric: If a pool class needs a format (in order to create a pool) 
then you must create a format using one of the creation methods, each of which 
creates a format from a specific variant.  The methods and values in a variant 
must be defined by the client application and must be defined prior to the 
creation of a variant.  The format must not be destroyed until all pools using 
that format have been destroyed; if the format is destroyed too early, 
undefined behavior will result.

.diagram: Linear "diagram" of format usage:  Time increases down the page.  
Ellipses represent time lapses.

- Create methods required for the variant, such as scan, skip, copy.  Typically 
these will be created statically (for example, compiled C code).
- Create other values required for the variant.  Typically these will be 
created statically.
...
- Create a variant [instance].
- Initialize the variant with the methods and values defined earlier.
...
- Create a format from the variant.
- Create a pool that uses the format (after this point the methods that you 
defined may get called by the MPS at any time).
...
- Use the pool (the methods you defined are called by the MPS).
...
- Destroy the pool.
- Destroy the format.


DETAILS

Creating and Destroying Formats

An object of type "mps_fmt_t" can be created using any one of a number of 
create methods.  Each create method's name begins with "mps_fmt_create_".  Each 
create method corresponds to a certain collection of different methods and 
values.  At the moment there are two create methods; "mps_fmt_create_A" for 
creating formats from instances of variant A and "mps_fmt_create_B" for 
creating formats from instances of variant B.

An object of type "mps_fmt_t" can be destroyed using "mps_fmt_destroy".  This 
works regardless of how the object format was created.

The lifetime of an object format is determined by what use the object format is 
put to.  Where the object format is the argument to a pool class's create 
method, then typically the lifetime of the object format must be at least the 
lifetime of the corresponding pool -- that is, the format must be created 
before the pool is created and destroyed after the pool is destroyed.


Variants

.existing: Currently, there are two format variants, A and B.  These are 
represented in the MPS C interface by the types mps_fmt_A_t and mps_fmt_B_t 
respectively.  They are similar and both designed for a pool with a copying 
garbage collection and allocation points.  They differ in that variant B has an 
extra method, class, for determining the class of an object.  .other.formats: 
Other formats may be implemented later.


Methods

.existing.method-choice: The MPS calls the methods in a format when it needs to 
perform an operation on an object.  The methods in the current format variant 
are:

Skip 
Skips a pointer over an object.  Takes a pointer to (the beginning of) the 
object and returns a pointer to the next object (that is, just after the end of 
this object, whether the next block in memory is allocated or not).

Copy 
Makes a copy of the object in another location.  Takes pointers to the old and 
new locations.  [Perhaps obsolete now?  Pekka 1998-01-19]

Pad 
Creates a dummy object.  Takes a pointer and size; fills in the block of memory 
with a dummy object.  The fake object should work just like a real one in all 
the other methods, but it shall contain no data.  This method is used by the 
MPS to fill in odd corners that need to be scannable.  The size is a multiple 
of the alignment set by the Align slot in the format, and might be equal to it. 
 Note that the other methods, except Copy and Fwd, might be called on a dummy 
object.

Fwd/Isfwd 
Used when the MPS has moved an object to a new location in memory.   Fwd takes 
a pointer to the object (at its old location) and a forwarding address.  It 
must replace the object at the old location with a "broken heart" of the same 
size, in which is stored the forwarding address.  Since any object (except a 
dummy padding object) may be forwarded, the format must be able to create a 
broken heart of the same size as any object.  Note that other format methods 
(except Copy) may be called on a broken heart.

Isfwd lets you distinguish between a broken heart and a real object.  It takes 
a pointer to the object and returns "moved" or "not moved"; if the object is, 
in fact, a broken heart, then isfwd returns a pointer to the new location, as 
well.  This new location is the same as the new location that was passed to fwd 
when the broken heart was created.

Align
This scalar value defines the alignment of objects allocated with this format.  
It should be large enough to satisfy the alignment requirements of any field in 
the objects, and it cannot be larger than the arena alignment [I don't see how 
the client could find this out?!  Pekka 1997-10-27].

Scan
Scan objects, locating all references and telling the MPS what they are.  Scan 
takes a scan state and two pointers, and scans the objects between the 
pointers.  Note that Scan methods are sometimes called on pad objects (in which 
case they should do nothing) and broken hearts (they should fix the forwarding 
pointer).  For more information on scanning, see .


Restrictions on All Format Methods

.restr.thread: It is guaranteed that format methods have exclusive access to 
the object for the duration of the call.  This guarantee may entail suspending 
arbitrary threads.  The methods that manipulate the object must not perform any 
sort of inter-thread locking or communication.

.restr.parallel: Format methods may be called during an exception handler or a 
signal handler.  For example, the MPS may protect the memory, in which case the 
client program cannot see it.  This causes an exception; the MPS handles the 
exception, finishes its work, and removes the protection.  Therefore, the 
format code should be able to be run at any time, including in parallel with 
the main program. 

.restr.reentrant: Format methods must be reentrant.

.restr.access: Format methods can access the memory they've been asked to look 
at and memory not managed by the MPS; they cannot in general access other 
objects managed by the MPS (unless they are unprotectable [this is an 
undocumented concept]).

.restr.call: Format methods can't call library code, perform a non-local exit, 
or do any MM operations (apart from fixing in Scan methods).


RELATIONSHIP BETWEEN FORMATS AND INCREMENTAL GC

.rel.inc-gc: Your format code must be completely independent of the rest of 
your code.  See also Restrictions on All Format Methods, above.

.rel.inc-gc.protection: The MPS can use memory protection to see what has 
changed during incremental GC.  For example, in tri-color marking, the MPS 
read-protects gray nodes so that black nodes cannot read them.  If a black node 
tries to read a gray node, the MPS has a chance to come along and change the 
gray node to black, if required.  Another example is to write-protect a black 
child so that a gray parent cannot write to it.  [Why do we need to say this 
here?  Pekka 1997-10-21]


RELATIONSHIP BETWEEN FORMATS AND ALLOCATION POINTS

.rel.ap: The AP protocol ensures uninitialized (i.e., uncommitted) objects are 
never scanned.  [Need to say something about the other methods.]

