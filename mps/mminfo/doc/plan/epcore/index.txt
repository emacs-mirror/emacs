                        PLAN FOR EP-CORE PROJECT
                              plan.epcore
                              obsolete doc
                            nickb 1996-09-06

INTRODUCTION

.scope: This is the plan for the MM/EP-core project. It shows how the goals of 
the project (goal.epcore) are to be fulfilled.

.readership: This document is intended for MM developers, MM
management, EP-core developers, EP management, and anyone interested
in the MM/EP-core project.

.hist.0: This document was hacked together by nickb.

.hist.1: NickB updated the release sections to reflect the current state more 
accurately. 1997-02-21.


REFERENCES

.ref: Many other documents have been constructed for the MM/EP-core
relationship. This document is, in part, a collection of references to
them.

.ref.goal: The MM/EP-core project goals are in goal.epcore.

.ref.req: The MM/EP-core requirements are in req.epcore. They have evolved 
throughout the design and implementation phases (see req.epcore.hist.*).

.ref.design: The MM/EP-core project design is in design.epcore.


DEFINITIONS

.def.old: "The old memory manager" is those parts of the core RIP
which did memory management before the MM/EP-core project was begun.
This is what the MM/EP-core project replaces.

.def.new: A "new memory manager" is a replacement for the old memory
manager supplied by the MM group. There are several of these.

.def.equiv: An "equivalent memory manager" is a new memory manager
which meets those requirements met by the old memory manager (e.g.
req.epcore.attr.run-time.seybold, but not req.epcore.fun.ps.gc).

.def.glue: "Glue" is code between the core RIP and the MM group's
memory pool system.

.def.mmi: The "Memory Management Interface", or "MMI", is an interface 
supported by both the old memory manager (.def.old) and the equivalent memory 
manager (.def.equiv).


CURRENT STATUS

.status.chart: See plan.epcore.chart.* for charts showing all the releases. We 
are currently between "prototype" and "equivalent". This chart (derived from 
plan.epcore.chart.changes) shows our current status:

                Release:        layered proto   *now*   equiv   trap   full

Requirement:

.fun.arena.extend               -       -       x       -       x       x
.fun.dl.multi.move              -       -       -       -       -       +
.fun.ps.gc                      -       -       -       -       -       x
.fun.ps.gc.op                   -       -       -       -       -       x
.fun.ps.hash                    -       -       -       -       -       x
.fun.ps.iter                    -       -       -       -       -       x
.fun.tmp.policy                 -       -       -       -       +       +
.fun.stat.policy                -       -       -       -       +       +
.fun.cache.multiple             -       -       -       -       +       +
.fun.cache.gc                   -       -       -       -       -       +
.fun.trap.alloc.zero            -       -       -       -       x       x
.fun.trap.realloc               -       -       -       -       x       x
.fun.trap.clear                 -       -       -       -       x       x
.fun.trap.multi                 -       -       -       -       x       x
.fun.alloc.threaded             -       -       -       -       +       +
.fun.tickle                     -       -       -       -       -       x
.fun.fragments                  -       -       -       -       +       +
.fun.control.slice              -       -       -       -       -       +
.fun.measure.dial.visual        -       -       -       -       -       x
.fun.measure.log                -       -       -       -       +       +
.fun.debug.check                -       -       -       x       x       x
.fun.debug.check.complexity     -       -       -       x       x       x
.fun.debug.settings             -       -       -       -       +       +
.fun.debug.diagnosis            -       -       -       -       +       +
.fun.debug.analysis             -       -       -       -       +       +
.fun.debug.support              -       -       x       x       x       x

.attr.run-time.*                x       ?       90%     x       x       x
.attr.tp.*                      x       ?       90%     x       x       x
.attr.idle                      -       -       -       -       +       +
.attr.tickle                    -       -       -       -       -       x
.attr.trap.speed                x       ?       x       x       x       x
.attr.footprint                 x       ?       x       x       x       x
.attr.rel                       -       ?       x       x       x       x
.attr.rel.state                 -       -       -       -       ?       ?

.dc.plat.soussc                 -       -       x       x       x       x
.dc.variety.debug.full          -       opt     opt     opt     opt     opt
.dc.lib.approved                x       -       x       x       x       x
.dc.link.object                 -       x       x       x       x       x

.prot.int.assert                -       -       x       x       x       x
.prot.coop.tickle               -       -       -       -       -       x

Key:            -       requirement not met
                x       requirement met
                +       requirement may be met, depending on future design
                ?       the requirement is met to an unknown extent
                opt     the requirement can be met easily on client request


VERSIONS

.release: There are five planned versionss: Layered, Prototype, Trapping, 
Pre-GC, and GC. Further versions are possible, to meet optional and nice 
requirements, or as requirements change. [Tags left as "release" because I'm 
lazy.  GavinM 1997-04-09]

   ----------------------------------------------------------------

.release.layered.what: The Layered Memory Manager is a modified version of the 
old memory manager which supports the MMI. There are some slight 
simplifications of the old code, losing some little-used functionality (mainly 
concerned with debugging) which does not fit the MMI. Later releases address 
problems caused by this.

.release.layered.not: The Layered Memory Manager does not include any new 
memory management code or functionality. It is a rearrangement of existing RIP 
memory management code to conform to a new interface.

.release.layered.use: Future RIP development should use the Layered Memory 
Manager, which will provide a stable memory management interface. Releases and 
upgrades to the RIP could include the Layered Memory Manager.

.release.layered.why: The Layered Memory Manager enables the later side-by-side 
testing of, and cutover to, a MM/EP-core memory manager. It provides a stable 
basis for run-time, throughput, and footprint comparison with any later 
release. It will greatly ease the integration of later releases.

.release.layered.when: The target date for the Layered Memory Manager was 
1996-03-01. It was actually released on 1996-04-17 
(mail.nickb.1996-04-17.09-43), with fixes continuing until 1996-05-23. See 
request 07660 in the ScriptWorks Product Evolution Database. 
   ----------------------------------------------------------------

.release.proto.name: Due to some confusion, various documents  also refer to 
this release as the "evaluation" release.

.release.proto.what: The Prototype Memory Manager is a simple-minded 
reimplementation of the memory management interface using Memory Management 
project tools. It  meets critical and essential non-GC functional requirements.

.release.proto.not: The Prototype Memory Manager does not necessarily meet 
run-time, throughput, footprint, GC, nice, or optional requirements.

.release.proto.use: The Prototype Memory Manager is not intended to be a part 
of any ScriptWorks product. RIP development should not use the Prototype Memory 
Manager.

.release.proto.why: The Prototype Memory Manager demonstrates the MM/EP-core 
development and release process. It demonstrates the portability of the MMI. It 
provides a means for testing bugs thought to lie in the old memory manager.

.release.proto.when: The target date for the Prototype Memory Manager was 
1996-04-01. It was actually released on 1996-07-12. See version.epcore.eval.

   ----------------------------------------------------------------

.release.equiv.what: The Equivalent Memory Manager is a complete replacement 
for the RIP memory management code, fitting the memory management interface. It 
will meet all non-GC non-trapping critical and essential requirements. Cutover 
is possible from the Layered Memory Manager to the Equivalent Memory Manager.

.release.equiv.not: The Equivalent Memory Manager will not necessarily meet any 
GC, trapping, nice, or optional requirements.

.release.equiv.use: After cutover, RIP development, testing, debugging, 
releases and upgrades will include the Equivalent Memory Manager. This is also 
true for later releases.

.release.equiv.why: The Equivalent Memory Manager allows cutover (see 
design.epcore.sol.mmi). This is necessary to ensure meeting performance 
requirements. It allows the MMI to evolve, incorporating new functionality not 
provided by the old memory manager. It demonstrates the ability of the MPS to 
meet our attribute requirements.

.release.equiv.when: The original target date for the Equivalent Memory Manager 
is 1996-06-01. It has now been 'rolled in' with the Trapping Memory Manager, 
below, and will not be release independently.

   ----------------------------------------------------------------

.release.trap.what: The Trapping Memory Manager will be a refinement of the 
Equivalent Memory Manager, to meet the trapping and arena extension 
requirements.

.release.trap.not: The Trapping Memory Manager will not do any garbage 
collection.

.release.trap.why: The Trapping Memory Manager provides the most urgently 
needed new memory management functionality for ScriptWorks (see 
meeting.epcore.1996-06-06).

.release.trap.when: The target date for the Trapping Memory Manager was 
1996-10-01. It was actually released (in 'beta') on 1997-02-14 (see 
mail.nickb.1997-02-17.11-36 and mail.nickb.1997-02-17.11-21). The intention is 
to make a final release of this memory manager before 1997-03-01.

   ----------------------------------------------------------------

.release.pre-gc.what: The Pre-GC Memory Manager will extend the Trapping Memory 
Manager with interface support for garbage collection.

.release.pre-gc.not: The Pre-GC Memory Manager will not actually do any garbage 
collection.

.release.pre-gc.why: The Pre-GC Memory Manager allows EP workers to develop the 
client-side code for garbage collection: root identification, GC invocation, 
&c. It gives MM workers a framework to test and debug development GC code.

.release.pre-gc.when: The target date for the Pre-GC Memory Manager is 
1997-03-14.

   ---------------------------------------------------------------

.release.gc.what: The GC Memory Manager will meet all of the critical and 
essential requirements. In particular, it will garbage collect PostScript 
Virtual Memory. It may also meet some nice and optional requirements.

.release.gc.why: The GC Memory Manager will support all of the project goals 
(see goal.epcore). It will protect ScriptWorks from failure and remove the risk 
of bad publicity due to lack of GC.

.release.gc.when: The target date for the GC Memory Manager is 1997-04-01.
 
  ----------------------------------------------------------------

.release.hist: Originally, there was no concrete idea about the
order or content of releases. The layered/proto/equiv/full sequence was devised 
by Nick Barnes in December 1995.  The "trapping" release was added to the 
schedule at the request of EP-core (meeting.epcore.1996-06-06).  There has been 
some slippage in planned release dates.

.release.chart: See plan.epcore.chart.full for a chart showing which 
requirements are satisfied by each release. plan.epcore.chart.summary 
summarizes the chart by grouping similar requirements. 
plan.epcore.chart.changes summarizes the summary by omitting requirements which 
are met in every release.


OUTSTANDING TASK LIST

.task: This is an out-of-date list of outstanding tasks, with requirements and 
estimates of effort (in days).

.task.gc.design: Design the mark/compacting GC for PSVM
Effort: 2

.task.gc.plan: Plan the GC release, with some intermediate releases. For 
instance: one with the MMI extensions but just stubs as implementation, one 
with a tracing interface
which just does checking, one which does GC but with lousy performance and no 
tickling, &c.
Effort: 2

.task.gc.mark: Refine the MPS as needed for mark/compacting GC.
Effort: 2

.task.gc.trace: Extend the MMI to do root tracing
Effort: 1

.task.gc.trace.rip: Change the core RIP to trace roots into PSVM
Effort: 2

.task.gc.control: Extend the MMI to invoke and control GC
Effort: 2

.task.gc.tickle: Extend the MMI and tweak the MPS so that the MPS can tickle 
the RIP.
Effort: 2

.task.gc.pool.ps: Write PSVM pools in the MPS (to replace those in the glue).
Effort: 5

.task.gc.pool.flex: Make the MMI more flexible about pools in general (e.g. 
make pool creation dynamic).
Effort: 4

.task.gc.evol: Make some evolutionary releases (see .task.gc.plan), 
Effort: 4

.task.gc.release: Release the GC MM.
Effort: 4

.task.misc.doc.mmi: Document the MMI for RIP workers (produce a document in 
Spring, replace comments in the .h files with a pointer to the Spring 
document), see mail.nickb.1996-04-17.17-09.
Effort: 1

.task.misc.doc.project: Document the MM/EP-core project for EP engineers (why 
it is needed, how it will change EP design, how it will change EP 
implementation, where to get all the gory details, who to interface to with 
questions). See mail.kap.1996-07-13.06-52.
Effort: 2

.task.misc.glue.review: Develop rules and checklists for reviewing glue code 
(see mail.richard.1996-07-12.14-47). 
Effort: 2

.task.misc.dial: Write a memory-mapping dial tool for debugging, like the one 
there used to be for the Mac. This is really work for the GUI group? It may 
affect MM/EP-core in as much as the performance of the debugging code may be 
unsatisfactory.
Effort: ???


.done: This is an incomplete list of completed tasks:

.done: This is a list of outstanding tasks, with requirements and estimates of 
effort (in days).

.done.equiv.misc.log: Make sure logging is correct (make allocations done by 
promises log a "-").
Requirement: req.epcore.attr.run-time.*
Effort: 0

.done.equiv.misc.lib: Write an implementation of the MPS library interface.
Requirement: req.epcore.dc.lib.approved
Effort: 0

.done.equiv.misc.plat: Porting work to the UltraSparc Sun C compiler platform. 
(req.epcore.dc.plat.soussc).
Effort: 1

.done.equiv.foot: Achieve performance comparable to layered with the same 
footprint. i.e. reduce fragmentation so that we don't paint-to-disk any more 
often. This is for req.epcore.attr.footprint, and can be divided into two 
parts: measurement and implementation:

.done.equiv.foot.measure: Measurement for this task can be approached in one of 
two ways: measuring fragmentation directly, or measuring the required footprint 
to RIP a job without paint-to-disk. Either way, the total estimated effort is 
about 3 days.

.done.equiv.foot.impl: Actually reducing footprint can only be done by 
improving placement of allocated objects, avoiding fragmentation. This can 
basically be achieved by allowing the client to express placement preferences.

.done.equiv.foot.impl.design: Design a preferences system for pools, segments, 
&c in the MPS (a lot of this has already been done).
Effort: ???

.done.equiv.foot.impl.arena: Write a real memory arena with preferences (and 
extensions for the trapping release, while we're at it).
Effort: ???

.done.equiv.foot.impl.extend: Extend existing MPS structures to support 
preferences.
Effort: ???

.done.equiv.foot.impl.int: Extend the MPS interface to support preferences.
Effort: ???

.done.equiv.perf: With the footprint equivalence achieved, test the MM for 
run-time and throughput.
Requirements: req.epcore.attr.tp.*, req.epcore.attr.run-time.*

.done.equiv.perf.log: Record MMI logs for all test jobs using the layered MM.
Effort: ???

.done.equiv.perf.compare: Use test logs to compare performance between layered 
and current.
Effort: ???

.done.equiv.perf.opt: Use some profiling tool to discover where time is spent 
and tweak those parts for speed.
Effort: ???

.done.equiv.release: Release the equivalent MM. See proc.epcore.release.
Effort: ???

.done.trap.extend: Extend the MMI to provide arena extension
Effort: 1

WORK TOTALS

.work: The following are out-of-date work totals for each release:

.work.equiv: 25 days
.work.trap: 11 days (or <= 7 if rolled in with equiv) 
.work.gc: 30 days
.work.misc: 5+???


SCHEDULE

.sched.people: People available for this work are: Nick B, Simon G, DRJ, Richard

.sched.trap: Blah blah blah

.sched.gc: Blah

.sched.more: Blah

