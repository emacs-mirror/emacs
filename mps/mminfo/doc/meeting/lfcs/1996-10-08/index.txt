                NOTES FROM MM/LFCS MEETING, 19996-10-08
                        meeting.lfcs.1996-10-08
                             incomplete doc
                           richard 1996-10-08

INTRODUCTION

Richard Brooksby, Brian Monahan, Healf Goguen.


AGENDA

Design of the model.
Brian's other stuff -- formal methods within the company.
Paper -- methodology of modelling.


BRIAN'S STUFF

Recently I've been doing a bit more on slightly formal methods related things.  
THer's a meeting I went to about two weeks ago out of which came a few 
pointers.  It seems to me that there's quite a lot of academic interest in 
applying theoretical computer science.  There doesn't seem to be as much 
industrial interest.  It seems to me that there are big problems.  The sort of 
tool that I'd be interested in helping to develop would be something pragmatic 
which in some sense takes code checking seriously.  In other words, 
LCLint-type-thing, but more smoothly integrated with debuggers and other tools 
that people currently have.  I see formal methods split into three strands.  1. 
straight theoretical computer sciecne, 2. describing systems at various levels, 
3. low-level code verification.  Semantic modelling cuts across some of this.  
The sort of thing that would make a difference would be something nearer the 
code end.  I have an interest in the logical description of systems, which 
requires good analyses and theorem provers (e.g. Lego).  The PVS proof of Paul 
could go into a Lego framework.  My interest is exactly in the middle of these 
two areas -- coding and verification.  I want to see what we could do in 
environments to support these activities better.  At the moment there's little 
support, but we might work on extended ML.  EML people are talking about being 
more generous about the sort of things they'd allow in their language, so 
perhaps they could deal with state.  This work may come up with an approach to 
that sort of thing which doesn't have burdens.

Healf: So, you're interest is in environments?

Out this work we could find ways of supporting this kind of analysis.  We could 
handle features of languages which traditionally cause problems for 
verification.

Richard: So it seems to me that this fit quite well with the idea of producing 
results in methodology.  If we can find a method then tools will follow.

Brian presents "A process algebra foundation for reasoning about core ELLA".


APPROACH TO VERIFICATION

 

On the left is the traditional view of program verification.  The result is a 
formal statement of correctness for a small part of the system.  The gap 
between implementation and verification is bridged by reaching up from the 
implementation, and sometimes little is learned in the process.  The cost is 
high per line of code.  The method is applicable to specialized areas.  The 
cost of changing the code is very high, so this form of verification results in 
a significant delay.

On the right is my proposed approach.  A "model" is developed which is 
verifiable, and represents essential facts and abstractions about the code.  
The gap between the model and the implementation is bridged semi-formally, with 
informal proofs and connections made between the code and the model.  The 
result is not a verified implementation, but an implementation with a higher 
confidence of quality throughout.  It can be applied to larged bodies of code, 
and a broader class of projects.  The cost per line is low.  This approach 
copes well with change in the implementation, because change in the model is 
much slower (the model expresses essential design).  The model is also a design 
document and a justification of the implementation.


MODELLING BARRIERS

The mutator is prevented from certain operations.  For example, it cannot load 
from a grey node.  The tracer must scan the node first.  This is expressed 
simply as a restriction on the sequence of interleaved mutator and tracer 
operations that are possible.  In reality, the tracer decides what to do based 
on what the mutator needs to progress.

