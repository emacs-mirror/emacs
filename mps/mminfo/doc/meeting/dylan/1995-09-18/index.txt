           SUMMARY OF DYLAN/MM INTERFACE MEETING, 1995-09-18
                        meeting.dylan.1995-09-18
                               draft doc
                             dsm 1995-09-19

INTRODUCTION

Richard, Tony and dsm met to discuss the MM/Dylan interface.  This summary is 
based on my notes but is largely from memory, and is not chronological.  We had 
a short follow-up meeting the following morning.


SUMMARY

.dw: There is currently a glue layer between Dylan and the MM (the "dw" part), 
that comprises of the container formats, and convenience functions, which are 
often wrappers to Dylan objects.  This is currently looked after by the MM 
group.

.dw.status: We discussed the possibility of handing this layer over to dylan.

Richard: Andy needs to be involved in agreeing definition and status of glue 
layer.

Tony: It would be more convenient from Dylan point of view for MM to handle it 
for the moment.

dsm: We should keep it until our MPS interface is more mature, but bare in mind 
that we may suddenly wish to remove the layer for performance reasons.

Richard: It is more work to maintain the two interfaces.  Our MPS interface 
will continually need to change as we get new requirements from new clients.

dsm: We could distinguish at least in our minds, the difference between the 
format stuff which is definitely Dylan specific and the glue stuff which just 
reflects our underlying interface.

Tony: Why is the indirection a cost where functions two interfaces are the same 
except for the name?

Richard: We do not have general tools to do the renaming.

.interface.scope: A GC interface may include:

  - allocation
  - read/write barriers
  - roots
  - rehashing
  - gc-cookies [what are these? -- richard]
  - finalisation
  - weakness
  - pools
  - performance monitoring
  - performance tuning
  - formats
  - debugging


CHANGES TO INTERFACE

.handles: MM: We would like to change interface to return a handle on the 
memory manager state.  Handles on pools and buffers are also needed.  Separate 
buffers are needed by each thread.

dsm notes: 

  mm = MMCreate();
  pool = PoolCreate(mm, poolclass, ...)
  buffer = BufferCreate(pool, ...)
  p = Reserve(buffer, ...)
  b = Commit(buffer, ...)

Each buffer may be used only in a single thread.  A thread may have many 
buffers.

.reserve-commit.interlude: dsm: Earlier Tony said between Reserve & Commit only 
copying of Dylan data goes on.  No thread synchronisation.  No external calls.

Tony: This is true at the moment.  Need to specify what is allowed to happen.

dsm notes: Only needed earlier restrictions for quick hack thread-safety.

.reserve-commit: Tony: Why do we actually need reserve and commit?

MM: We need it to sychronise creation of objects so that we do not see half 
created objects.

Tony: Can you not scan object ambiguously?

MM: Many improvements are possible, but this is an easy to provide and general 
mechanism.  This is not the ripest place for optimisation.

.atomic-update: Updates need to be atomic.  Dylan objects must be in valid 
format at all times.  Objects being created on Reserve do not, of course, need 
to be valid until Commit.

.aligned-access: dsm: Are all word accesses aligned?  In particular, do any 
reads or writes cross page boundaries.

Tony: Accesses not guaranteed to be aligned because C may access objects in 
words.

.tls: dsm: Earlier Tony said no roots in windows' thread local store (TLS).  
You mustn't have roots there.

Tony: No we don't.

dsm: Just checking.

Tony: We need to be able to implement our own thread local store.

dsm: Our interface allows you to do that.

.tramp: dsm: Current design of interface has an MMTrampoline function which 
calls a dylan function.

dsm notes:

  MMError MMTrampoline(void **valueReturn, void *(*dylanProgram)(void *), void 
*arg);

dsm: This must be called for each thread using the heap.  It serves the 
purposes of:

  .tramp.thread.reg: registering the thread -- we need handle to suspend/resume 
threads and scan there registers and stacks.

  .tramp.stack: records the top of the dylan functions stack for later 
scanning.  (Replaces MMRootStackBase.)

  .tramp.seh: installs a Structured Exception Handler around the function.

.tramp.cost: Tony: This is too expensive we need to have a low overhead when 
calling a Dylan function from a C function.  Would like separate thread 
registration and deregistration so this does not to be called multiple times 
per thread.

dsm: Not much hassle

.tramp.seh.cost: Tony: Worried about cost of installing SEH.

.tramp.access: dsm: Outside trampoline we are outside dylan world and nothing 
may access dylan heap.  Once inside the trampoline things may access the heap.

.c-direct-access.problem: Tony: C functions can read Dylan strings directly.

dsm: That's our memory, we may have protected it.  You mustn't do that as we 
need to have installed exception handler.

Tony: This optimisation is important.

.c-direct-access.solution: Possible solutions:

  1. Disallow C functions to access dylan strings directly, so that our current 
interface is adhered to.

  2. Work out better mechanism than SEH to handle exception handling.  This may 
allow us to catch any access to heap.

  3. Have dylan inform the MM of objects accessible from C.  We could ensure 
this memory is never protected.  This may cause more atomic scanning, making it 
difficult to meet pause time requirements.

  4. Allocate strings in such a way that they do not need protecting.  Separate 
buffers could be used for string (or leaf) allocation.  These types of objects 
do not need scanning and so would not need to protect pages with these objects 
on.

Tony unhappy about anything but 2. (also worried about .tramp.seh.cost)

dsm: I find SEH very unsatisfactory; it relies code behaving nicely and passing 
all access violation exceptions up to us.  But it is the best mechanism we have 
at the moment.

.thread.term: dsm: Earlier Tony said thread termination can assumed to be 
clean.  What if C programs mess around killing threads?

Tony: We can detect thread death and deregister the thread.

dsm: There is a critical region there.  We can check that the thread is alive 
when we try to suspend it.  [We need to work out how to ensure stack memory is 
around when we attempt to scan it.]

.error: Current mechanism where dylan installs a handler and calls it on error 
is OK.  .low-cond: Dylan would also like a low memory condition.  .error.other: 
May have other errors e.g. heap corrupt.

.roots: All roots are either declared explicity, or are on a thread's stack or 
in a thread's registers.

.root.reg.caller: dsm: Earlier Tony said that registers do not contain roots on 
calls to MM functions.

Tony: This may not be true on other platforms.  This is not true on the i386 
platform, sorry.

.root.reg.i3: The root registers on the 386 platforms are in Edi, Esi, Eax, 
Ebx, Ecx, Edx.  Edi and Esi are preserved on call to C.

FOLLOW UP

[dsm: I missed the begining of this conversation]

Re: .c-direct-access

Richard: We cannot guarantee .c-direct-access.solution.2.  We must be 
pessimistic about this.  Having a separate pool for dylan strings or leaf 
objects would make sense (.c-direct-access.solution.4).

Richard: We are persuing high-level contacts to get better info on exception 
handling.

Tony: Possibility of doing some kernel debugging.

Another possibility:
.c-direct-access.solution.5: Use SetUnhandledExceptionHandler.  This makes it 
difficult (or perhaps impossible) to use debugger.  Perhaps as emergency 
measure, or useful within Dylan's debugger.

.string-length: Tony mentioned compatibility with C strings caused a problem 
with difference in string length and byte-vector length.  It was noted that 
this is something that can be done more efficiently by changing the formats 
which are currently in interface code.

Tony: Also concerned about cost of trampoline (.tramp.cost)

MM: We will expose internals of trampoline, to aid efficient implementation and 
inlining, in particular of the structured exception handler.  Will probably 
also keep trampoline for convenience.


ACTIONS

Need to meet again to discuss:
  - weakness
  - finalisation

Need to work on an interface specification document with Bob Matthews [I have 
made this a priority, since I think this will be our best chance of shaking out 
requirements. -- richard].

