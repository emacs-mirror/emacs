                         NOTES ON DYLAN TESTING
                      meeting.qa-dylan.1997-01-03
                               draft doc
                             rit 1997-01-03

(I made these notes after talking to Tony Mann about testing the MM from Dylan. 
They are also available in the QA notebook.)

Using Dylan

The Dylan emulator runs on a unix system (possibly not SunOS); 128M 
recommended. It has an X-interface, so if running from a Mac or PC you need an 
X-server program. The emulator uses CL/CLOS, which provides its own memory 
management, so it's not possible to use it to test the MM directly. However, it 
would be useful for learning dylan, and is available now. [Do the Dylan group 
have some space on one of their machines?]

The compiler is a cross compiler, which runs (at least at present) from within 
the emulator---it compiles on unix but produces PC images. So to use it 
sensibly you need the above, plus a PC. You also need the PC development 
environment: SDK and the debugger. MSDN professional provides this and a lot of 
other junk. The compiler's not yet in a suitable state for people to use it.

[To learn Dylan, Apple Dylan may be the easiest way. Tucker knows about it (the 
Dylan group have a pre-powerPC technical release).]

Testing the MM in Dylan

Dylan group could perhaps provide a compiler with which different versions of 
the MM libraries could be linked, allowing speed &c comparisons of new 
releases. They are working on a statistical profiler to integrate with their 
debugger: it will interrupt the program at intervals, inspect the stack, and 
gather stats. It'll be able to see, for example, what proportion of time is 
spent inside the MM (whether from an explicit call or a trap). 

How Dylan uses the memory manager

Essentially, very simply. The only pool classes used are AMC and MV; MV for 
wrappers, which must not be protected (as scanning functions need to read them) 
and AMC for everything else. [Eventually instead of MV there should be a 
special wrapper pool -richard] Everything is put in one big pool. Roots are 
currently a bit messy: as well as the stack and registers being scanned 
ambiguously, so is a large [~900K -drj] table of static data, most of which 
points to itself, and which is rarely changed. This is rather inefficient, and 
it will be changed to a (I assume smaller) exact root eventually. Two features 
that Dylan uses a lot are threads (each with its own allocation point) and 
location dependencies. It's important to test these, especially threads which 
probably involved a lot of machine-specific code in the MPS.

It's hard to make generalizations about the kinds of objects stored and the 
references between them, as it all depends on the program being run. You can't 
necessarily say, for example, that most references are new->old. [richard 
suspects that a very large number of objects are pairs.]

Mark Tillotson said allocation speed was very important (and that inline 
allocation was too; at the moment extra interface layers mean than Dylan isn't 
getting the benefits of inlined RESERVE and COMMIT). He suggested 1 million 
small (~30 byte) objects per second would be nice. Tony agreed. [that's 30M a 
second---Richard Brooksby thought maybe 10M a second was more reasonable; 
either way, the current MM is a lot slower.]


