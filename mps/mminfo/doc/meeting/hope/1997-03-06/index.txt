                       HOW HOPE DO THEIR TESTING
                        meeting.hope.1997-03-06
                               draft doc
                             rit 1997-03-06

.intro: eddy gave rit a quick tour and demo of the hope test system. These are 
rit's brief notes of salient points.

.basis: Using a test system from GNU, written in tcl and expect. Runs on unix 
(only?).

.platform:, .product: The system is able to deal with multiple platforms and 
mutiple products, but hope don't make use of this: they have one platform 
'unix' and one product 'hope'. The platform-product file defines various test 
library procedures, then specifies the test set by listing various files of 
test suites to be run.

.test.arrangement: Tests are mostly arranged by the hope command that they 
test, with a few extra suites for stress testing and benchmarks. For each test 
suite, a file (potentially there could be more than one) contains a series of 
individual tests, which can be run in sequence (for the daily overnight 
testing) or individually as required.

.test.wrapper: Tests are written in tcl+expect, and use an interface layer of 
tcl-defined procedures to call hope, rather than give command lines directly. 
Each test has a name (a string) which explains what it does. E.g.
|
|   DoTest "add a spong to a wibble" 2 {
|     .
|     CreateCompound([NewComp 1])
|     .
|     .
|     .
|   }
|
Here DoTest is the test wrapper procedure, 2 is the number of clients (see 
below), CreateCompound is a library abstraction for the hope "create" command. 
NewComp is a gensym-type function that returns a new compound name.

.test.result: Each test gives a result: either pass or fail. If you want more 
information from a test (e.g. benchmark tests), then you can write it to a file 
as a side-effect. When a test fails, it _doesn't_ stop -- it just carries on. 
This is so that the next text in the file will get run anyway. This behaviour 
seems to be motivated by making the test system easy to write, rather than 
making it behave logically; usually after a failure, the rest of the test will 
be irrelevant and potentially misleading.

.file.log: Running any test creates a test log: a file which contains all the 
logging information output by hope in that test.

.file.summary: Running test suite creates a test summary file: summarises which 
tests in that suite passed and failed, without giving detailed info.

.file.report: Overnight testing create a test report: a table of numbers of 
passes and fails in the different suites, plus a graph of benchmark results. 
Tests are classified as: expected pass, expected fail, unexpected pass, 
unexpected fail.

.tool.expect: "expect" is an addition to tcl which provides a kind of switch on 
the result of a spawned command. You can switch on various kinds of result, 
including such things as:
 - regular expression matches
 - timeout
 - eof
 - buffer full
Each spawned command gives you a spawnID, and you can do an expect on several 
different spawnIDs at once if you don't know which will react first.

.test.model: Each hope test suite begins by starting n hope servers on a single 
machine. Each individual test then create m clients which can talk to them in 
various combinations. Usually, though, client i talks to server i all the time.


