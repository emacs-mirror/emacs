              NOTES FROM THE REHASHING MEETING, 1996-10-10
                       meeting.general.1996-10-10
                               draft doc
                           richard 1996-10-10

INTRODUCTION

.intro: Richard Brooksby <richard>, David Jones <drj>, and Tucker Withington 
<ptw> met to discuss Dylan hash table protocols and location dependency.


NOTES

1. hash states should have a class

e.g. <hash-state>

2. object-hash should take a hash-state and implicitly merge.

  define method object-hash (object :: <object>, hs :: <hash-state>) =>
    (id :: <integer>, hs :: <hash-state>)

object-hash-merge (an alternative) could be created to do this, but
this would be very painful and involve changes to table-protocol.  Don't do
this.

object-hash may or may not update the hash state.  You must use the return
value.  In our implementation we expect to update.

We observe that object-hash could be split into

  define method object-hash-state (object :: <object>, hs :: <hash-state>) =>
    hs :: <hash-state>;

and

  define method object-hash-id (object :: <object>) => id :: <integer>

The former updates the ld and the latter returns the hashed pointer.  There
is no need to pass or return a hash state during lookup in a table.  It is
only necessary on add to a table.  This optimization may not be worthwhile.

3. merge-hash-codes should be removed

Actually, we could supply an analogous operation, but it may only encourage
inefficient implementations of hash functions.  The only valid use would be
when parallel threads were used to hash parts of a large object and the
data dependency must be avoided.  In this case, the hash-state must be
shallow copied before the fork.  merge-hash-codes _could_ update one of its
arguments instead of consing.  It would probably have to be renamed to
merge-hash-codes!.  All this would need careful documentation.

4. $permanant-hash-state should be removed

This is redundant in our scheme.  The table code internally resets the
location dependency and passes it out to the hash function in the hash
protocol.  A hash function for a non-dependent object looks like this:

  define method thing-hash (thing :: <thing>, hs :: <hash-state>)
    values (really-hash (thing), hs);
  end method thing-hash;

5. Kim's interface is mostly internal and can be redefined.

We need to provide an internal interface which will give access to
operations on location dependency objects.  These objects may need a class
in Dylan.

6. We change things internally and let users suffer.

If we can't change the DRM definition of object-hash we still need to do so
internally if we are to have efficient tables.

7. Threading issues

lookup:
  hash
  really lookup
  stale?
  LOCK/RENDEZVOUS
  rehash
  UNLOCK

add:
  LOCK
  hash
  really add
  UNLOCK

8. We forsee no problematic interactions with weakness and/or finalization.


ACTIONS

1. Change the DRM.

2. Define alternative hashing interface for our own consumption.

3. Write C examples showing how to write add, lookup, rehash, and where to
put the ld.  Make sure lookup is O(n) at worst (lookup on rehash).

4. Discuss this stuff with Kevin.

5. Sort out Dylan table code and interface to mps_ld_*.

6. Change mps_ld_isstale to remove the pointer argument.  It is useless.

7. Add mps_ld_merge iff the Dylan merge function is kept.

