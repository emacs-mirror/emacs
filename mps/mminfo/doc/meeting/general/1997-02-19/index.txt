             NOTES FROM GENERAL DESIGN MEETING, 1997-02-19
                       meeting.general.1997-02-19
                               draft doc
                           richard 1997-02-19

INTRODUCTION

.intro: Richard Brooksby <richard> and Nick Barnes <nickb> met to discuss 
design issues arising from MM/EPCore work and mering it into the trunk of MM 
development.  David Jones <drj> and Gavin Matthews <gavinm> contributed.


AGENDA

1. Configuration.
2. Namespace clashes.
3. Optional argument passing conventions.


CONFIGURATION

.config: Richard had half-completed design.mps.config(0) in the morning, and 
had a complete outline.  He and Nick went over the document and resolved 
various issues, resulting in design.mps.config(1), still incomplete, but enough 
for Nick to work with.


NAMESPACE CLASHES

.name: Five methods of avoiding namespace clashes between MPS code and client 
code were identified and analysed.

.name.fix: Fix-as-you-go: When a clash occurs, change a name and re-release.  
This has no initial cost, but quite a high incremental cost.  It will also 
cause hassle for our customers.  In the long term it's unacceptable, but it's 
what we're going to do to sort out EP's immediate problems with the LockRelease 
identifier (see mail.davidg.1997-02-17.10-48 and subsequent messages in the 
thread).

.name.prefix: Prefix: Change all identifiers internal to the MPS (but external 
to MPS modules) to have a unique prefix such as "MPS".  This makes the source 
code quite a lot uglier.  It requires large amounts of change to source code.  
Whatever prefix we choose may clash with something else in future anyway 
(although it seems unlikely with "MPS").  It doesn't provide any security 
against reverse-engineering.

.name.obfusc: Obfuscating #defines: This is described in 
mail.nickb.1997-02-17.12-23 suggestion 3, and involves having a header which 
redefines our internal symbol names to be obscure unique identifiers such as 
MPS001, MPS002, etc. using the preprocessor.  This requires change to our 
convention for function-like macros, as observed in mail.nickb.1997-02-17.12-49
.  We would need to maintain this file of renamings.  It does give automatic 
security againt reverse-engineering.  We would need some procedure for checking 
that we hadn't forgotten to rename some symbol.

.name.link: Link editing: We could use the link editor (such as it is) on each 
platform to edit out the internal names.  This would be secure, and sounds like 
the right solution, except the link editor isn't actually capable of it on many 
platforms, so we'd probably have to write a tool ourselves.  We'd also have to 
maintain the mechanism as part of our build system, introducing a dependency on 
more tools, and effort in secondary development.

.name.single: Single source: Join all the source files together and compile 
them as a unit (when delivering to external customers), using C's "static" 
storage class to eliminate internal symbols.  This could be done by having a 
file containing #includes of the various source modules.  It requires a change 
to SRCID mechanism so that more than one SRCID is possible.  We'd need to 
introduce a new storage class which was actually a macro which expanded to 
"static" when joining and "" when compiling separately.  We would need to 
maintain module glomming file with #include "foo.c" etc.  It would be nice 
because we'd get the module configuration (design.mps.config.build.srcs) into 
the sources explicitly.  Some compilers may barf because of source code size.  
It may help when inlining in some compilers.  Compilation time wouldn't be that 
great.  The main problem is that it wouldn't work for non-C files such as our 
assembler sources.


OPTIONAL ARGUMENT PASSING CONVENTIONS

.opt: If we worry less about binary compatibility then the structure passing 
method seems more attractive, as proposed by Gavin in 
mail.gavinm.1997-02-13.14-31.  .opt.ver: Richard proposed deferring binary 
compatibility issues by implementing the version negotiation mechanism he 
documented in design.general.interface.durable.  .opt.set: The main remaining 
issue is to retain the ability to know whether an argument (requirement) was 
specified or not, and avoid using a special magic value to indicate the 
default.  This requires a flag on each field in the structure passed, but 
perhaps a helpful macro could be introduced to set it.  The client would say:

  mps_foo_opt_s foo_opt_s = FOO_OPT_INIT;
  MPS_OPT1(foo_opt_s, foo, bar, qux);
  foo(spong, wibble, &foo_opt_s);

and this would expand to:

  mps_foo_opt_s foo_opt_s = {{FALSE, NULL}, {FALSE, NULL}};
  do {
    foo_opt_s.bar.set = TRUE;
    foo_opt_s.bar.val = qux;
  } while(0);
  foo(spong, wibble, &foo_opt_s);

or alternatively, to:

  mps_foo_opt_s foo_opt_s = {0uL, NULL, NULL};
  do {
    foo_opt_s.set |= 1uL << OPT_BIT_foo_bar;
    foo_opt_s.bar = qux;
  } while(0);
  foo(spong, wibble, &foo_opt_s);

.opt.decide: In any case, the decision as to which mechanism to use depends on 
the weights we put on:

  1. client source code volume,

  2. client defects due to typechecking errors (static client defect detection),

  3. binary compatibility.

