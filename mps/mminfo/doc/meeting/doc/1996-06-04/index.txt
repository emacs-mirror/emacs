            SUMMARY OF MM/DOCUMENTATION MEETING, 1996-06-04
                         meeting.doc.1996-06-04
                               draft doc
                           richard 1996-06-04

INTRODUCTION

.intro: Richard Brooksby and Bob Mathews met at Longstanton House on 4 June
1996 to discuss documentation requirements for a forthcoming memory
management product.


LAUNCH DATE

.contract: Richard said that negotiations are under way with potential clients 
for
contract work by Harlequin on memory management services.  Richard
expects a decision within a few months on whether or not this work will
proceed.

.launch: If there is no contract work, Richard expects the launch of a memory
management product in early 1997 (probably first quarter).  If the
contract work proceeds, the launch will be delayed.  It will be possible to 
predict this once the MM Group have studied the contract requirements and 
planned that work.


USE LEVELS

.comp: The product will be a developer's tool consisting of a memory management
library and tools for measurement and tuning of memory use.  .level: The product
will accommodate five "levels of use":

.level.1: Use the product as a drop-in to an application, intended to provide
tangible improvement in memory use after no more than "one afternoon's
work".  We should be able to produce improved performance (speed) and reduced
fragmentation almost straight away.  The user might also immediately
benefit from the interface checking and assertions.

.level.2: Use the internal interface, but making only straightforward choices
among memory pools.  Note: We need to introduce the concept of garbage
collection at this level, and it must be easy for the customer to choose
a basic GC policy.

.level.3: Use the product's tools to inform the choice of policy.  The customer
should be able to do some profiling, study memory-allocation statistics,
etc.

.level.4: Use the product's tools to tune the memory management system.

.level.5: Use a custom solution developed by or with Harlequin.


COMPETITION AND PRODUCT PLACEMENT

.purify: Richard emphasized that the product is NOT intended to compete with
Purify.  We view Purify as a debugging tool, whereas the
memory management product is a "high-integrity performance tool".  Thus,
it could be complementary with Purify.  Richard warned that if the
memory management product is viewed as a debugging tool, potential
customers might well reject it in favor of Purify.

.compet: Richard said that there are two main competitors now:

.compet.smart: SmartHeap (http://www.microquill.com).  This is something like a
cross-platform replacement for malloc.  It does not go far beyond our
proposed use level 1, and it offers no GC.  It does a bit of level 2, in that 
you can choose to put some objects in fixed-size memory pools.

.compet.circle: Great Circle (http://www.geodesic.com).  This is a GC product.

.adv: Richard listed three advantages of our proposed product:

.adv.flex: Flexibility: we offer more choice of policies.

.adv.tools: Tools: we offer more measurement and tuning tools.

.adv.levels: Use levels: no competitor goes beyond our use level 2.


PLATFORMS

.pfm: The product will run initially on UNIX, NT, and Windows 95.  It may also
run on the Macintosh.  In typical use, the product will not require
reconfiguring or rebuilding operating-system kernels (though we might
advise this at use level 5).


MODEL OF USE

.adapt: Richard said that the product should be an "adaptive" system.  The user
sets requirements for memory use and performance, and the product's
tools do the low-level work required to meet those requirements.

.util: The ideal is that the user specifies a function of the current
attributes, and the product optimizes that function to meet the user's
requirements.

.tension: Bob said he foresaw a tension between the requirement that the 
product be
"smart" and easy to use on the one hand, and the tendency of engineers
in this area to distrust garbage collection and tools on the other.
Many engineers will want to get past the tools and get down to low-level
tweaking.

.grad: Richard and Bob agreed that the solution is to provide a gradation of
information levels, along the lines of the product's use levels.

For example, Richard suggested organizing much of the documentation for
each pool class explicitly according to level of use.  For each level,
the documentation could discuss the features, benefits, and procedures
available at that level.

.tables: Bob asked how users will decide which level is appropriate for them to
use.  Richard suggested that we provide, for each pool class, a table of
features by use level.


DOCUMENT SET

.set: We agreed on the following likely components of the product
documentation set:

.set.cat: Pool class catalog.  This is, conceptually, a loose-leaf binder
containing one module for each pool class.  The product will come bundled with 
up to twelve, by maybe we'll ship more as updates or extras.  The loose-leaf 
idea is to give the user the idea of an expandable tool kit.

.set.ref: Interface reference.  This is a collection of reference pages
documenting the product API.  We will probably organize this by
protocol.  The product will contain about 10 protocols, with a total of
perhaps 200 interface elements (functions, data types, etc.) within the
protocols.

.set.guide: Guide.  This document begins with a "quick start" explaining what 
the
user needs to do to achieve results in "one afternoon" at use level 1.
It proceeds to discuss concepts and how to use the product at the basic,
intermediate, and advanced levels of use.

.set.quick: Quick start.  We may produce a separate "quick start" document,
perhaps excerpted from early chapters of the guide.  We could ship this
booklet along with a demo CD-ROM to let potential customers try the
product.

.set.inst: Installation instructions.  Richard hopes that installation will be
so trivial that we can dispense with separate installation instructions,
documenting the installation in the guide.  Bob expressed doubt about this
and said it is likely we will need a separate, brief, document.

.set.relnotes: Release notes.

.set.help: Online help.


DOCUMENTATION FORMATS

.fmt: Bob said that our usual policy is to maintain documentation sources in
FrameMaker and to ship documentation in three formats:

.fmt.print: Printed books.

.fmt.ps: PostScript files.

.fmt.html: HTML, generated from the FrameMaker source by WebMaker.

.fmt.help: Bob said that when online help is required, we usually produce it in 
the
native help system for the platform.  For NT and Windows 95, this format
would, at present, most likely be Windows Help.  If there is a Macintosh
product, the format would most likely be balloon help.


POOL CLASS CATALOG ISSUES

.cat.tmpl: The main challenge for this document will be coming up with a design 
and
template for the description of each pool class.  We should begin as
soon as possible to experiment by documenting one or two pool classes.
Once we have established a design, writing the document should be
straightforward.

.cat.features: The description of each class may need to summarize, near the 
beginning,
the features available for each level of use.

.cat.levels: The bulk of the description for each class can possibly be 
organized
explicitly according to level of use.

.cat.interact: An important challenge will be managing information about 
interactions
among pool classes.  We must avoid an exponential problem of explaining
interactions of each class with every other class.  The hope here is
that the system architecture itself is sufficiently modular to limit the
extent of interaction problems and dependencies among pool classes.

.cat.design: Richard pointed out that the system itself is designed to reduce 
dependencies between pool classes to a minimum.  This is a fundamental part of 
the design.  If we find we have too many to document we should change the 
system, not the documentation.


INTERFACE REFERENCE ISSUES

.ref.tmpl: As with the pool class catalog, the most substantial effort with the
interface reference should be to come up with a design for the
description of each protocol and each element.  Once the design is
fixed, the documentation itself should be nearly mechanical.

.ref.eg: Descriptions should, where possible, include brief examples.


GUIDE ISSUES

.guide.effort: The guide is likely to require the most careful thought and 
perhaps the
greatest expenditure of time.

.guide.adv: Richard said that the guide should at each point emphasize the 
relevant
product advantages.  It should clearly state the goals and benefits of
each feature it discusses.  In this way it can promote the product and
even serve as a marketing document.  Richard pointed to the Purify guide
as a positive example of how this can be done.

.guide.lev: Richard believes that the guide should be organized by use level.  
He
has already produced a preliminary outline in this form.

.guide.task: We agreed that the guide needs to be task oriented.  Bob suggested 
that we
need to state what kinds of memory management problems the product can
solve at each use level.  For use level 1, it would be good to identify
some of the most common problems and to be able to demonstrate some
success in alleviating them in "one afternoon".  We should continue to
identify the sort of problems that can be solved at each use level.

.guide.ui: Bob said that the guide should avoid describing the user interface 
of the
tools.  The focus should be on how to use the tools to achieve tasks,
such as taking "slices" through the multidimensional space of memory
parameters.  Any information about the user interface should be confined
to online help.

.guide.eg: We need to think carefully about what kinds of examples to include in
the guide.  Examples are generally beneficial, but extended examples can
detract from the presentation of concepts.  Perhaps we should think
about developing one or more extended examples for a separate document.

One challenge with examples for this product is that no single example
can possibly be appropriate for the entire range of customers,
applications, and use levels.  Perhaps a series of briefer examples
would be more useful.


ONLINE HELP ISSUES

.help.pain: Bob told Richard that we have generally tried to do the minimum 
required
online help, particularly Windows Help.  This is mainly because online
help generally requires separate sources, and the tools for producing
it are not good.

.help.html: We discussed Microsoft's announced intentions to deliver future 
Windows
Help in (some) HTML format, but it is not likely that this will help us
for the early versions of this product.

.help.mac: Richard said that Macintosh balloon help is relatively easy to 
produce
and that some of the early tools prototypes on the Macintosh have
already incorporated balloon help.  If the text is generally applicable
to other platforms, we may be able to reuse much of it.

.help.inc:  More importantly, Richard said it would be possible for the 
development group to
write on-line help for each UI item as we go along, and then edit this
later.  This would help to reduce the burden.

.help.effort: We agreed that in principle each element of the user interface 
should
have online help.  However, because the customers are developers, they
probably do not expect extensive online help.  Bob suggested that any
intensive effort to develop online help will have to come at the price
of reduced effort on other aspects of the documentation.


RESOURCE ESTIMATES

.effort.draft: Bob estimated that the effort required to produce a shippable 
first draft
of all documents is on the order of 6 person-months.  Of this effort, Bob
sees more than half going to the guide and the pool class catalog.  This
estimate includes the following assumptions:

.effort.exp: An experienced and technically advanced writer, already employed at
Harlequin.  A new employee would require substantially more time,
perhaps an additional 2 person-months.

.effort.help: A minimum level of Windows Help, perhaps one topic for each tool.
Additional online help will require more time.

.effort.eg: Most examples developed and tested by software engineers, not by the
writer.

.effort.web: Sufficient WebMaker quality to produce acceptable HTML with minimal
manual effort or bug workarounds by the writer.


CONCLUSIONS

.hire: If we need to hire then we must hire right away.

