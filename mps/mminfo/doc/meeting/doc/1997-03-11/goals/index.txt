                     GOALS OF THE MM DOCUMENTATION
                      meeting.doc.1997-03-11.goals
                             incomplete doc
                             lmb 1997-04-11

INTRODUCTION

.intro: Richard Brooksby and Leah Bateman met at Longstanton House on
1997-03-11 to discuss the goals of the MM documentation.


INTRODUCTION TO GOALS

.group: Group Goals
   .product: Product Goals (derived in part from group goals)
      product.revenue: Revenue  $
      .product.image: Image  HQN $
      .product.promotion: Promote Promoting MM
      .product.improvement: Improve MPS improved
      .product.quality: Quality  Improve quality of customer's products
      .product.qol: QOL   Make life easier for customers

.just: Goals need justification.  For example, the justification for
Image is future prospects, goodwill, and other products.

.scale: Goals have an infinite scale.  Most are unreachable.

.req: Requirements are derived from goals and are measurable.  An
example of a requirement might be "req.usability: The user will be
able to do X in 6 hours time."


DOCUMENTATION GOALS IN TERMS OF PRODUCT REQUIREMENTS

[need diagram here]

.req.usability: Gilb states that one requirement of products is
usability.  .req.entry:, .req.learning:, .req.handling:,
.req.likeability: This requirement can be broken down into four
sub-requirements: the entry requirement (how much does the user have
to know to use the product at all?), the learning requirement,
handling ability, and likeability.

.req.usability.solution.doc: Documentation is a solution to the
product's usability requirement.  .req.usability.function:,
.req.usability.level: The product must be usable by function (GC,
tool, etc.) and by level.  .req.usability.solution.ROI-levels: ROI
levels are a solution to usability by function, risk [?].


DOCUMENTATION GOALS

In general:

.cost.min: Minimize cost of quality improvements to customers'
products.
   aka Minimize cost/benefit of using our product.
   aka Maximize quality improvement to the customers' product.
.mps.design.source: Act as good source for design of MPS.
.usability.reward: Make using the product rewarding, pleasant, and
fun.
.promotion: Promote the product and Harlequin.
   .promotion.solution: Solution: Pack Ch. 1 with high-level info.
   .promotion.req: Requirement: Evaluate well.

In terms of Gilb's product requirements:

.entry.min: Minimize entry requirement (broadens market, yields
revenue, promotion).
   req -- assumptions about user [?]  
.learning.min: Minimize learning requirement.
.handling.max: Maximize handling ability.
.likeability.max: Maximize likeability.


TESTING GOALS

.goal.test: If I achieve all/only these goals, will I be happy?


REQUIREMENTS

.model: Leah should look through an existing list of requirements,
such as the one in Gilb.

.breakdown: Requirements break into functional requirements and
attribute requirements.


FUNCTIONAL REQUIREMENTS

.req.func: Functional requirements are those bits of the product
that must exist; these requirements are boolean.  They are divided
into:
   .req.func.critical: critical -- a requirement that, if missing,
      causes the product to fail
   .req.func.essential: essential -- a requirement that must exist,
      but can be negotiated
   .req.func.optional: optional
   .req.func.nice: nice

.req.func.doc: The functional requirements for the documentation are
the components of the documentation set.  Some of these are:

.req.func.doc.ref: Reference material
   Interface (some critical, some essential)
   System requirements
   Environmental requirements
   etc.
.req.func.doc.intro: Planned introduction (=> user guide)
   Tasks to support
      Basic...Advanced
   Product information (support, installation, etc.)
   Legal information
   etc.

All of these should be broken down into more detail.  They need a
goal as a source.


ATTRIBUTE REQUIREMENTS

.req.attr: Attribute requirements are requirements that can be
quantified.  .req.attr.info.loc: An example of an embryonic attribute
requirement is that the user has to be able to locate task-related
information quickly in order to accomplish a task.
req.attr.info.loc.questions: This raises the questions:
   Which tasks?
   How quickly?  We need to derive a test.
   etc.

.req.attr.info.loc.solution: Solutions to this particular requirement
include:
   index
   table of contents
   page numbers
   section headings

.req.attr.exper: Another embryonic requirement is that the
documentation must assume that the user has no more than X amount of
experience.

req.attr.roi: Another is that the documentation must help to ensure an
ROI at each level.  Levels of use imply levels of both cost and
benefit.  .req.attr.roi.quant: A refinement of this requirement is
that the typical user must be able to work through the first level in
about 120 minutes and reach a comprehension level of X.

.req.attr.press: Another requirement is that the press must be able to
understand the product in 15 minutes.


RANDOM NOTES ABOUT REQUIREMENTS

.leadback: Everything in the outline should lead back to the
requirements.

.req.description: Nothing is about *what* the documentation is, it's
all about *how* it is.  Things specific to paper documentation are
probably not requirements, they're designs.  A requirement should
never dictate a single solution.

.anti: Anti-requirements -- things you explicitly want to avoid --
should also go into the requirements document.

.req.test: To develop tests, imagine a resettable slave in a box.
What would you want it to do?  What tests would you run?  These tests
might take the form of "Can achieve X after time T given starting
point P" or "Can convert N,000 lines of code that originally used
malloc".

