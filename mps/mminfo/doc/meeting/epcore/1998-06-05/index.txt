                  LIMITING TOTAL ALLOCATED IN AN ARENA
                       meeting.epcore.1998-06-05
                             incomplete doc
                          richardk 1998-06-05

.intro: DRJ, DTB, EricP, and RichardK met in the Oubliette.  We discussed using 
client-specified limits on total memory allocated from an arena, to mediate 
Client<-->MPS communication about memory pressure.

.source: Pivotal discussion is in meeting.epcore.1998-05-07.need.comm.  From 
that came request.epcore.160073, which was the basis for today's discussion.

.summary.max-allocated: SW can set a max_allocated limit for the arena, which 
is distinct from max_addrspace and is dynamically adjustable.  MPS fails any 
alloc that would exceed max_allocated, allowing SW to react (eg. by freeing 
caches or increasing max_allocated) and retry.

.summary.beyond-160073: In other words we endorsed what request.epcore.160073 
said as at 1998-06-04, with the following changes:
  - name "max_allocated" (instead of misleading "max_commit");
  - if client tries to set max_allocated lower than current allocated, fail;
  - max_allocated to be honoured by client arenas too (not just vm arenas).

.summary.deliver: This 160073 functionality should be in 
version.epcore.minnow.  This version of the interface may not be perfect and 
future improvements can be considered.

.summary.other.now: Other issues to address now:
  - keep client- and vm-arena interfaces similar;
  - ensure arena + pools free eagerly;
  - control of max_addrspace.

.summary.other.future: Other issues to consider for future work:
  - get arena to pre-reserve a minimum total memory;
  - keep more than two groups of objects separate;
  - are extensible client arenas already implemented?


ALTERATIONS TO 160073

.diff: The following alterations need to be made to request.epcore.160073.

.diff.name: Rename "max_commit" as "max_allocated".

(.diff.name.just: The terms "reserve" and "commit" are primarily used by MM for 
allocation-points; use to describe VM operations is rarer[and should be phased 
out IMHO.  richardk 1998-06-05].)

.diff.decrease-fail: If client tries to set max_allocated lower than current 
total allocated, MPS does not adjust max_allocated and returns failure code.

(.diff.decrease-fail.just: We choose .diff.decrease-fail because it is safe: 
the worst outcome of .diff.decrease-fail is that SW dies on the return code, or 
ignores it and fails to be alerted to increased total allocated (compromising 
performance).  For comparison: allowing setting max_allocated, and then failing 
every allocation until total allocated fell below it, could make SW fail in 
bizarre ways.)

.diff.client-arena: Client arenas will honour max_allocated too.[Perhaps all 
arenas should?  richardk 1998-06-05]  

(.diff.client-arena.just: The detriment of exceeding max_allocated in a 
vm-arena is increased paging.  The detriment in a client-arena is risk of 
increased fragmentation, as placement-policy becomes warped by extreme shortage 
of memory.  Both detriments are worth avoiding, and the same mechanism 
(max_allocated) suits both cases.  This also helps keep client- and vm-arena 
interfaces similar.)

.note.hit-detect.client: In discussion we assumed that MPS would report that 
max_allocated had been hit (ie. would have been exceeded) by returning a new 
return-code, ie. 
request.epcore.160073.sol.max-allocated-dyn.hit-detect.client.return-new.  This 
seems satisfactory.

.note.def.max_allocated: We haven't precisely defined what max_allocated 
means.  Is it sum of segment-sizes in the arena?  Is it sum of object sizes, 
without overhead?  Does it include control-objects or does it only measure 
client-requested objects?  Presumably it is a count of bytes.


OTHER ISSUES NOW

.unify.arena-interface: Different arena classes should have the same 
fucntionality and interface where possible.  For SW, source-level 
coompatibility of all variants of the MPS interface is desirable.

.eager-return: Ensure arena + pools free eagerly and return memory to 
operating-system so it is available for other processes.  See 
meeting.epcore.1998-05-07.need.small-footprint.  This should be in req.epcore.  
Are there any caveats?

.control.max-addrspace: Currently max_addrspace for an arena is a parameter 
("size") passed by the client when the arena is created.  It cannot be 
dynamically varied.  This okay for SW.  MPS cannot offer a good default for 
this value -- SW should arrive at a number somehow.  (SW will probably not need 
a gui for this number, but will read the value from a config file; this allows 
Hqn experimentation and OEM tweaking for very-large-RAM machines).  Dynamic 
variation is an issue for Dylan; future MPS may allow it.


OTHER ISSUES FOR THE FUTURE

.arena-minimum: It might be good for the arena to pre-reserve a minimum total 
memory.  This is important to prevent client being 'caught short'.  Currently 
MPS has no way to support this.  Could be important for multiple copies of SW 
on one machine.  Needs more investigation.

.separate: Separating objects is good when deathtimes are different.  
Particular case is SW font-caches: we want them to leave nice big holes when 
they are purged.  Minimise fragmentation.  We discussed three levels:

.separate.none: Currently font-cache isn't even in a separate pool.  Freeing it 
may produce only fragmented free-space.

.separate.pool: If font-cache was in a separate pool freeing it would produce 
at least whole pages of free-space.  This is page-sized 'fragmentation' but in 
a vm-arena it is not a problem because address-space is abundant (unless it 
isn't, eg. very-large-RAM machines); unused pages get unmapped.

.separate.locus: It would be possible to start putting font-cache in its own 
address-range.  MPS can't support this yet (it only supports 'top' and 'bottom' 
of memory, see request.epcore.170193.sol.epdl.low and request.epcore.160075).  
This only has benefit if address-space is constrained, such as in client-arena 
or in very-large-RAM machines.  Tony and RichardK discussed design 1998-06-03, 
but it's hard.  Needs more investigation.

.client-arena.extensible: DRJ remembers doing a code-review on dynamically 
extensible client-arenas that could accept a new chunk not contiguous with 
current chunks!  No-one else present had heard of this functionality existing!  
Need to investigate whether this is already available and usable.


EFFORT

.effort.meeting: The meeting took about 1h30, so 3 man-hours of MM time and 3 
man-hours of EP time.

.effort.write-up: Write-up took 3h30 of RichardK's time.

.effort.just: Needed for SW's successful adoption of vm arenas; see 
meeting.epcore.1998-05-07.effort.just.

