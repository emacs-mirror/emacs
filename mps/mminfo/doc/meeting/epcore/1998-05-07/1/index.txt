               EPCORE MEMORY LOGGING: ERICP'S WATCH CODE
                      meeting.epcore.1998-05-07.1
                               draft doc
                          richardk 1998-05-07

.intro: On 1998-05-07, Rit and Richardk asked EricP about the code that 
generates the ScriptWorks memory-log files, as used by Sheep's Fragmentor tool.

.code: See watson:/u/ericp/MM_Watch_Code/.

.instructions: Instructions are in the "usage.txt" file there.  
.intructions.gone: As at 1998-08-26 the instructions seem to have disappeared.  
An old copy is appended below in .instructions.old.

.output: The output gets written to the ScriptWorks LOGFILE (in SW folder).

.changes: To make a rip output this information, need to change 2 files in v20 
(possibly top_of_rip in control.c), and mm.h (the MMI header 
SW_common_export!mm.h), and recompile.

.instructions.old:
Using the mm_watch code to trace mm allocation in the corerip
-------------------------------------------------------------

1. Define USE_MM_DEBUGGING - eg as a MYDEF0 environment variable. This
   enables pool allocation totals, tagging, and installs a standard watch
   function which will be called for every mm_alloc, mm_free, or
   mm_truncate (or derivatives).

2. If live watching is required (whereby the entire list of current
   allocations is output) then insert

      mm_debug_watch_live( mm_trace ) ;

   where you require this output to be generated (and also remember to set
   the debug_mm_watchlevel variable, see step 5).

3. A clean rebuild of mm, v20, pdf and pdfout is then required.

4. Start the RIP.
   Note that although the mm debugging is now enabled, you won't get any
   output from the mm_trace routine until you set the global
   debug_mm_watchlevel to non-zero. This is best done by setting a breakpoint
   on the first (with respect to program control flow, within rip) instance
   of mm_debug_watch_live or at the beginning of top_of_rip() [in control.c].
   
5. Setting debug_mm_watchlevel
   The value this is set to determines the level of tracing reported and
   may be used to mask out unwanted mm tracing:
   
     1 => report mm_alloc calls
     2 => report mm_free calls
     4 => report mm_truncate calls (internal, issued by mm_dl_promise_end)
     8 => report live allocations from mm_debug_watch_live
   
   These may be combined, giving a valid range of 0 (no reporting) to 15
   (full). The default, 0, means that NO OUTPUT WILL BE GENERATED although
   the work of managing the tags corresponding to the allocations is still
   being done.

6. If the following assert is generated:

      "class_str table definition out of sync with mm_alloc_class_e -
       regenerate table"

   the class_str string table in mm\src\mmwatch.c is out of date with respect
   to the enumeration type it mirrors (mm_alloc_class_e in mm/export/mm_core.h)
   and needs to be regenerated (and the person who last changed the enumeration
   type without updating the string table shouted at!).
   
   To do this run the perl script mmallocclasses.pl (available in this
   directory) - under NT this would be something like:
   
      "perl mmallocclasses.pl < mm\export\mm_core.h > outputfile"
      
   Paste the output into mmwatch.c (instead of the existing definition of
   class_str), recompile, and try again.

7. Note that the output is written, buffered, to the mmlog file in the same
   folder/directory as the ScriptWorks binary. Any output should be flushed
   upon normal exit, but to force the file to be flushed and/or closed, call
   mm_trace_flush() or mm_trace_close() in the debugger. These routines will
   return 0 on success.
   
   Additionally, any existing mmlog file will be overwritten by the first
   watch output of a subsequent execution - so if you want to keep the output
   remember to take a copy of the mmlog file!

--

Any questions, phone/email me (x3829/ericp)
Eric.



