                    SUMMARY OF REAL-TIME GC MEETING
                      meeting.real-time.1999-05-13
                             incomplete doc
                            tony 1999-05-19

INTRODUCTION

.intro: David Jones <drj>, Pekka Pirinen <pekka>, Tony Mann <tony>, Richard 
Tucker <rit>, met with Andys Sizer <andys> and Martin Simmons <martin> to 
discuss possibilities for providing real-time GC solutions with MPS in the Java 
marketplace. The meeting was prompted by a request from the last quartet 
meeting, relayed to us by DaveB.

Start time: 1999-05-13 at 15:00
Duration: Just over 1 hour

PURPOSE

.purpose: Preparatory discussion about real-time GC issues, to help us to 
ultimately present one or more practical options to the quartet for providing 
real-time GC solutions with MPS in the Java marketplace.

AGENDA

.agenda: The meeting covered the following areas:

  What we mean by real-time, & what the issues are for GCs

  The current architecture of MPS, and the issues related to adding real-time 
support

  A quick overview of RCLE, its real-time requirements and solutions

  Directions taken by the Real-Time Java Working Group


SUMMARY

.issues: The main issues for real-time GC are latency and pacing. 
.issues.latency: Latency is a measure of the time denied to the mutator because 
of a unit of GC activity.  .issues.pacing: Pacing is concerned with the smooth 
interleaving of GC and mutator activity such that garbage is reclaimed without 
excessive memory usage. 

.rcle.latency: The worst-case latency of RCLE was determined by using hardware 
timers to measure code paths through the GC, and analysis of which paths will 
be involved in the worst case. Martin performed the measurements by hand for 
each code path. The latency requirements were that 95% of all GC slices should 
be less than 10ms, and 99.9% should be less than 50ms.

.rcle.pacing: The pacing of RCLE is controlled by a mechanism which calculates 
how much work must be done (based on past history) in a GC cycle. This comes up 
with 2 numbers: (1) the number of GC slices needed. (2) the length of a slice. 
The intention is that a slice is always just under 10ms. A feedback mechanism 
monitors performance during the GC cycle, and adjusts the rate upwards or 
downwards if necessary.  A new GC cycle starts immediately after the old one 
finishes. A significant problem is the difficulty of making an estimate at the 
beginning of a GC cycle for the expected liveness at the end. The liveness 
depends on the generation being collected, as well as the length of the GC 
cycle. It also depends on previous GC cycles.

.mps.latency: The latency of MPS as it stands is not easy to determine. It was 
designed for an average latency which is acceptable for interactive use. The 
worst-case behaviour is not well understood. The duration of significant code 
paths in MPS are not known. Additional issues are that MPS must run on multiple 
platforms, and paths are extensible via the framework (e.g. by the addition of 
pools or formats). Some possibilities were discussed for dealing with this - 
including (a) using a training run with each MPS configuration to compute the 
significant durations and create a configuration file, and (b) computing path 
durations dynamically at the start of each run.

.mps.pacing: The current GC scheduling facilities of MPS are rudimentary, and 
known to be too unsophisticated even for Dylan's use. The bad news is that we'd 
have to write pretty much all pacing code from scratch. The good news is that 
we won't be hampered by the legacy of MPS, and the fact that MPS is a framework 
and should be amenable to supporting this.

.java.real-time.core: The real-time Java working group currently have a 
proposal for a real-time core for Java which doesn't involve real-time GC. 
Conceptually the real-time core and vanilla Java are separated, run in separate 
threads, and have separate heaps. Vanilla Java may access core objects but not 
vice-versa. Vanilla Java may use core APIs, but not vice-versa. Objects in the 
core heap are never moved. They are not freed until they have been "unanchored" 
by an explicit API call from the core - and they may only then be reclaimed if 
there is no reference from vanilla Java. It's anticipated that many "core" 
applications will allocate objects during initialization only - and never 
dynamically allocate or free objects.

.java.real-time.profiles: The intention is that real-time GC does have a role 
to play in supporting more general real-time requirements by means of multiple 
real-time profiles. The details of these profiles have not yet been specified.

.java.possibilities: One possibility for MPS would be to provide a memory 
manager for core and vanilla Java via separate pools. This might require very 
little work, and doesn't need real-time support from the GC. It does achieve 
the goal of associating MPS with real-time Java, however. Other possibilities 
for supporting real-time profiles involve repackaging MPS as a real-time GC. We 
haven't yet determined what sort of requirements we could meet, or quantified 
the work of meeting them.


NEXT MEETING

.next-meeting: We will meet again to discuss more possibilities on Thursday 
1999-05-20 at 2pm.


