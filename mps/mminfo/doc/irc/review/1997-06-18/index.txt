            TRANSSCRIPT OF IRC CHANNEL #REVIEW ON 1997-06-18
                         irc.review.1997-06-18
                             incomplete doc
                           gavinm 1997-06-18

.logbot.14-31-19: JOIN

.logbot.14-31-21: This channel is logged to irc.review.1997-06-18

.drj.14-31-37: JOIN

.logbot.14-31-38: This channel is logged to irc.review.1997-06-18

.logbot.14-31-38.1: He probably just wants to take over my CELLS and then 
EXPLODE

.logbot.14-31-38.2:  inside me like a BARREL of runny CHOPPED LIVER!  Or maybe 
he'd

.logbot.14-31-38.3:  like to PSYCHOLOGICALLY TERRORIZE ME until I have no 
objection

.logbot.14-31-38.4:  to a RIGHT-WING MILITARY TAKEOVER of my apartment!!  I 
guess

.logbot.14-31-38.5:  I should call AL PACINO!

.ptw.14-32-19: JOIN

.logbot.14-32-21: This channel is logged to irc.review.1997-06-18

.ptw.14-33-56: 54 minutes, M: 3, m: 7, C: 0, q: 2, I: 11

.gavinm.14-34-04: 4M 14m 5q 3I -- 74 minutes

.drj.14-34-30: no idea how loing, M:1, m:5

.drj.14-34-43: I:2

.gavinm.14-35-03: I only reviewed lines 1-460

.drj.14-35-11: drj only review ed lines 609 down to 280ish

.nickb.14-35-44: JOIN

.logbot.14-35-45: This channel is logged to irc.review.1997-06-18

.logbot.14-35-45.1: I know things about TROY DONAHUE that can't even be 
PRINTED!!

.gavinm.14-35-51: TOPIC: Logging: Major issues

.drj.14-35-59: 236 M design here is critical 

.ptw.14-36-33: General M .req Are only ŒC¹ leaf objects supported by leaf 
pools, or are ŒDylan¹ leaf objects supported (despite their having a reference 
-- the wrapper).

.ptw.14-38-16: 132 M .clear Why is the allocated range not marked allocated?

.ptw.14-38-45: 529 M .design This seems like the wrong modularity, to have the 
pool know the semantics of WEAK

.ptw.14-39-14: ./

.drj.14-39-23: /

.drj.14-39-35: /say /

.gavinm.14-40-03: 181,188 M Modularity: BTSize return is not guaranteed to be 
rounded to the word size

.gavinm.14-40-42: 229 M Don't invalidate sig

.gavinm.14-41-11: 309 M Why such a weak check?

.gavinm.14-41-28: 386 M Don't check buffer

.drj.14-41-44: 177 nM this is a stupid trick

.drj.14-43-03: 358 m this should tagged and in the design

.drj.14-43-31: 393 q surely the size should already be aligned?

.drj.14-43-58: 515 m we seem to get from alignment the wrong place (pool not 
format)

.drj.14-45-01: design.mps.poollo I the whole question of alignment is unclear

.drj.14-45-15: 583 m justify not having a describe method

.drj.14-45-35: 588 m the function seems to be completely useless and so does 
impl.h.lo

.drj.14-45-53: ./

.ptw.14-45-59: design.mps.pool I  .def.leaf roots in pool must not move (or be 
updated in any way)

.nickb.14-46-11: PART

.ptw.14-46-17: design.mps.pool I  .overview.ms.justify what are the cons? cost 
of bit-tables?

.ptw.14-47-03: design.mps.pool I  if.init.format Format A needs a better 
descriptive name

.ptw.14-47-18: design.mps.pool I  Should there be a root structure associated 
with the pool that enumerates all the roots in objects in the pool?  That is 
scanned at Ambiguous time?

.ptw.14-47-42: design.mps.pool I  Should buffer allocation automatically 
capture roots?  E.g., should there be a separate buffer for each Dylan type so 
that the wrapper is known to be captured (and the wrapper can be AVERred to 
have no other roots in it)?

.ptw.14-48-15: design.mps.pool I  .group.diagram Fit to one page

.ptw.14-48-25: Segments I  How many pools need more than just a ³p² field.  
Would more pool-specific fields in segments descriptors be better than pools 
implementing groups?

.ptw.14-49-03: 46 m .purpose The purpose of a group is simply to associate the 
bit-tables with the segment.

.ptw.14-49-33: 98 m .clear non-descriptive names

.ptw.14-49-44: 116 m .clear This seems to be the wrong place to be checking this

.gavinm.14-49-50: - IN The concepts of groups should be glossed somewhere.

.ptw.14-50-05: 125 I  Bit tables should store their size

.ptw.14-50-12: 177 q .design Are separate allocated and mark tables necessary?  
Condemned=>Mark

.ptw.14-50-32: 231 m .clear This is not the reverse order in which members are 
allocated

.ptw.14-50-44: 266 q .clear Why would we try to reclaim a group that is 
buffered?

.ptw.14-51-03: 295 m .clear Needs a reference to trace design

.ptw.14-51-12: 298 I .design Should there be some hysteresis on destruction of 
groups?

.ptw.14-51-30: 487 I .clear trace->ti needs a more descriptive name

.ptw.14-51-39: 515 m .clear Explain what is being done, how this is an 
approximation

.ptw.14-51-48: 515 I .clear fix.protocol shoul have separate call for FINAL and 
WEAK to discover was-marked

.ptw.14-52-07: 521 m .clear Why are FINAL and WEAK the same as EXACT?

.ptw.14-52-25: ./

.gavinm.14-52-42: 50-51 m Type is inconsistent with design, but probably correct

.gavinm.14-52-53: 60 m Modularity breach: access of seg structure member buffer

.gavinm.14-53-05: 66 m Redundant parentheses

.gavinm.14-53-14: 78,79 I BTCheck?

.gavinm.14-53-25: 95 m Unnecessarily abbreviated formal parameter names

.gavinm.14-53-43: 125,226 q How expensive is this calculation compared with an 
extra field?

.drj.14-53-59: design.mps.poollo nI buffered memory should be allocated

.gavinm.14-54-00: 108,163 q Why does the client know about alignment on 
allocation, but not on creation?

.gavinm.14-54-28: 175 m Modularity: access of seg structure member p

.gavinm.14-54-29: 192 m Modularity: access of seg structure member white

.gavinm.14-54-43: 210,416 m Suggest: AVER(res != ResOK)

.gavinm.14-54-53: 250-251 m Odd unsymmetrical use of base and limit

.richard.14-54-56: JOIN

.logbot.14-54-58: This channel is logged to irc.review.1997-06-18

.logbot.14-54-58.1: I just had my entire INTESTINAL TRACT coated with TEFLON!

.gavinm.14-55-14: 243,254-257,264 m i and j are different types

.gavinm.14-55-35: 262 m Loop invariant

.gavinm.14-55-45: 280 m Suggest: AVER not marked

.gavinm.14-56-12: 295 m Modularity: access of seg structure member white

.drj.14-56-16: (we can't)

.gavinm.14-56-21: 297 m Suggest: AVER invariants for value of marked 

.drj.14-56-28: design.mps.poollo nI make it clear what happens with AMBIG fixes

.gavinm.14-56-38: 303,330 m static functions should start with a lower case 
letter

.gavinm.14-56-49: 339-340 I Could we have a more robust ring iterator?

.gavinm.14-57-01: 341-349 q Why not use part.impl.c.ring.iter

.gavinm.14-57-20: - q Why is This not impl.c.poollo?

.gavinm.14-57-40: design.mps.poollo.group.mark q Is the mark sense constant or 
alternating?  How do I tell what it means?

.gavinm.14-57-57: ./

.gavinm.15-03-19: top

.gavinm.15-03-31: TOPIC: Review: Brainstorm

.ptw.15-03-38: spin

.drj.15-03-59: ./

.ptw.15-04-37: Hello!

.gavinm.15-05-28: .ptw.14-38-16: 132 M .clear Why is the allocated range not 
marked allocated?

.drj.15-06-09: though this decision in the design

.drj.15-06-39: it is not necessarily

.ptw.15-06-43: It is not justified

.drj.15-06-46: the correct decision

.gavinm.15-07-06: Do we only ever allocate by buffering?

.ptw.15-07-10: Is that documented?

.drj.15-07-13: the only way to allocate is by buffering

.drj.15-07-47: design wasn't revised in view of subsequent experience

.ptw.15-08-09: So we don't have the case where we allocate "around" the buffer 
to avoid decaching the buffer on one big object?

.gavinm.15-08-18: DRJ: AWL treats the alloc bits as you might expect.

.ptw.15-08-35: It would seem more honest to mark buffered as allocated.

.gavinm.15-08-35: How did this ahppend?  How could it have been preented?

.drj.15-08-50: this design is first thing that came into drj's head

.gavinm.15-08-57: Perhaps some guidance onw riting this sort of pool?

.ptw.15-09-00: It would mean you wouldn't have to look at buffer specially later

.gavinm.15-09-11: Maybe we should only write things we've written before.

.drj.15-09-25: write it and then throw it away

.ptw.15-09-29: Perhaps modifying an existing pool rather than writing a new one?

.gavinm.15-09-29: Always throw away your first attempt.

.gavinm.15-09-38: Like PoolEPDL?

.drj.15-10-23: comparing AWL and LO would be interesting exercise

.gavinm.15-10-26: But this breaks our rule about don't copy-and-paste

.gavinm.15-10-35: Rather have common code.

.ptw.15-10-45: Yes we need a common M&S core

.drj.15-11-05: lein code ahs probabilty p of being wrong...

.ptw.15-11-25: WHy could this not be based on the copying pool?  You would not 
need the simplicity of M&S if you could base you rpool on a known working pool.

.drj.15-11-37: two liones have probabilty 2p(1-p) of exactly one being righty

.gavinm.15-11-41: Can we base pools on each other?

.gavinm.15-11-47: Could AWL and LO have used common code?

.ptw.15-12-14: At some point trying to create commonality leads to complexity

.drj.15-12-24: ptw is right.  is also intersting to write a mark and sweep pool.

.ptw.15-12-53: But it is the wave of the future -- component software

.gavinm.15-12-56: If p<.5, I'm right.

.drj.15-13-27: I thn kyou mean if p != 0.5

.gavinm.15-13-28: DRJ: Pool wasn't written with enough experience, or modified 
in the light of experience.

.drj.15-13-39: cut I can't remember what statement you made now...

.ptw.15-13-43: Pool or design?

.drj.15-13-49: design

.gavinm.15-13-52: 2p(1-p) ? p

.gavinm.15-13-52.1: 2p(1-p) > p

.drj.15-14-16: not that the design was written down before the pool as 
implemented.

.ptw.15-14-29: 2¢

.gavinm.15-14-48: DRJ: When you create a design of a new thing that is like an 
old thing, it is likely to be better in ways that can be applied to the old 
design.

.ptw.15-15-05: A common implementation can be improved simultaneously

.ptw.15-15-19: If you have a common implementation, there should on ly be one 
design!

.gavinm.15-15-23: What part of the process do we fit this followup into?

.drj.15-15-41: after having written the design... go and look at the designs it 
is siomilar to.

.ptw.15-16-05: New rule:  don't create a new design without justifying why 
existing design cannot be adapted to the task

.ptw.15-16-11: ./

.gavinm.15-16-11: Next issue

.gavinm.15-16-14: .ptw.14-38-45: 529 M .design This seems like the wrong 
modularity, to have the pool know the semantics of WEAK

.drj.15-16-17: yes ptw's ruler is good

.drj.15-16-20: ./

.ptw.15-16-23: !

.gavinm.15-17-01: Might we have common weak code?

.ptw.15-17-23: Is it just that the WEAK design is not finished?

.drj.15-17-48: either weak design is not finished or is not sufficiently well 
justified.

.gavinm.15-18-05: Ought to have design for ranks.

.gavinm.15-18-30: We certainly ought to have mor eplaceholders.

.ptw.15-19-01: Perhaps PTW should be better informed?

.gavinm.15-19-09: Is it possible to abstract knowledge about weakness outside 
specific pool classes?

.ptw.15-19-39: Yes.  Here the pool is fixing the reference from _another_ pool 
to meet the weak semantics.

.gavinm.15-19-43: PTW is in the intended readership.

.drj.15-19-46: certinly there are more abstract implementations of weak

.gavinm.15-20-03: Process improvements?

.ptw.15-20-07: To me, the pool the reference originates should be responsible

.drj.15-20-10: wrong design?

.ptw.15-20-22: More review

.gavinm.15-20-32: That's not what review's for.

.ptw.15-20-39: More peer review?

.gavinm.15-20-52: More RFC.

.drj.15-20-56: ah.  more design then.  experiemce at creating design will 
naturally lead to us writing better design.  surely

.gavinm.15-21-05: Perhaps we should have a proc.rfc

.ptw.15-21-14: Approval of designs before they can be implemented?

.gavinm.15-21-24: That would involve writing them.

.drj.15-21-28: ptw's suggestion about improving rfc is good

.ptw.15-21-42: Not neccessarily.  Must approval be on a written document?

.drj.15-22-00: usually designs are written in sketch first, surely this can vbe 
rfced before impl?

.ptw.15-22-04: Or must we just have buy-in from more than one member of the 
group?

.gavinm.15-22-10: It makes the justification natework harder.

.gavinm.15-22-19: It makes the justification network harder.

.drj.15-22-25: ...surely this can be RFCed before implemented

.ptw.15-22-31: Exaclyt

.gavinm.15-22-37: (See design.infosys.req.just)

.ptw.15-22-57: !

.gavinm.15-22-57: /

.ptw.15-23-15: Do we need a chief architect and a chief anti-architect?

.drj.15-23-33: tick

.gavinm.15-24-05: Partner-in-crime idea.

.ptw.15-24-21: responsibility for reviewing design must be assigned as a task.  
Devil's advocate.

.ptw.15-24-24: ./

.gavinm.15-24-27: /

.drj.15-24-33: ./

.drj.15-24-41: y

.gavinm.15-24-42: Review process.

.drj.15-25-01: would it possible to put the role documents so that each 
document is on line?

.drj.15-25-08: er, on one line, I meant

.gavinm.15-25-38: I find it helpful to remember what I'm doing by what I've 
been handed by me.

.drj.15-25-39: in general I still seem to have a mountain of paper.

.ptw.15-26-00: I can listen while I type, but I can't talk while I type.  Is 
this a problem?  Is the phone useful or useless?

.drj.15-26-16: this review spent ages looking through all the paper

.gavinm.15-26-17: I think about it.

.gavinm.15-26-23: /

.gavinm.15-26-26: Two of us didn't finish.

.gavinm.15-26-29: Why?

.drj.15-26-29: dunno.  I find I can only say what I'm typing if I am typing.

.ptw.15-26-38: I guess I would like a hardbound guide that I could mark with 
sticky notes.

.gavinm.15-26-38: I spent a lot of tim eon the design document..

.gavinm.15-26-45: Guide to what?

.drj.15-26-48: was kibbitzing dylan problem going on in same room

.gavinm.15-26-56: Ah,  You will.

.ptw.15-27-38: I took the liberty of reading the design document before review 
started (for the first time!)

.gavinm.15-27-43: The estimated checking time makes no allowance for source 
documents.

.gavinm.15-27-47: Is that right?

.drj.15-28-02: I think review shoudl include time for looking at source

.ptw.15-28-03: I wouldn not have finished otherwise.

.gavinm.15-28-25: /

.ptw.15-28-26: Is it really not allowed to "prepare" by reading source?

.gavinm.15-28-32: What about DRj's "stupid trick"

.ptw.15-28-48: Don't use stupid tricks?

.gavinm.15-28-52: PTW, yes.  It is.

.gavinm.15-28-58: (allowed)

.drj.15-29-04: I think ptw is right.  should eb allowed to read source before 
review

.gavinm.15-29-10: Predates BT module.

.drj.15-29-42: is annoying to right gotos and labels

.ptw.15-29-43: It's simply a buffer fill and allocate from buffer.

.gavinm.15-29-49: Wouldn't be an issue with a proper BT type.

.ptw.15-29-52: Maybe it is not a trick?

.drj.15-29-52: indeed it is

.ptw.15-30-38: If MPM had internal buffers, it would not be a trick.

.gavinm.15-30-51: Perhaps we should leap to optimise space and eliminate error 
handling prematurely?

.drj.15-31-12: of course, problem iwth buffers is that they need a moving MM to 
get lots of contiguous space to work efficiently.

.ptw.15-31-13: Perhaps we should have internal buffers because this will be a 
common problem.

.drj.15-31-16: bus soon

.gavinm.15-31-27: It's a general with internal data structures.

.gavinm.15-31-36: We don't handles them cleanly.

.ptw.15-31-43: Don't really need a moving mm if most of your internal 
structures stick around.

.gavinm.15-31-50: If only we had a memory manager.

.drj.15-31-50: EP have an atomic "allocate me this load of heterogenous objects"

.drj.15-31-59: (using an array of sizes as it happens

.ptw.15-32-03: And the ones that don't are "resourced"

.gavinm.15-32-06: That's a good idea.

.ptw.15-32-18: Yes.  EP's thing is just a buffer in disguise.

.drj.15-32-36: except tit can allocate each object in a different place.

.drj.15-32-43: s/tit/it

.ptw.15-32-51: Time pressure

.gavinm.15-32-58: BUt why doesn't this come up in writing?

.ptw.15-33-08: Human nature?

.drj.15-33-16: time now is more expensive than time in the future.

.ptw.15-33-35: Does an implementation have to get Approval before it can enter 
review?

.drj.15-33-41: time pressure, got to get bus now.  really

.gavinm.15-33-49: Review should only find defects that could reasonably have 
been found in writing.

.ptw.15-33-53: bye...

.gavinm.15-34-00: Richard: Review shouldn't find defects.

.ptw.15-34-15: .?|?||?|?|?|

.ptw.15-34-26: ./

.gavinm.15-34-27: Close.

.gavinm.15-34-31: Thanks.

.gavinm.15-35-04: PART


