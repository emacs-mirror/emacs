                   MEMORY MANAGEMENT PROJECT OVERVIEW
                            overview.general
                             incomplete doc
                             rom 1995-10-23

INTRODUCTION AND SCOPE

Scope

.scope: This document presents an overview of the memory management project.  
It outlines project goals, requirements, envisioned products, and key design 
choices.  It summarises the architecture of the memory management system.

Audience

.audience: This document is intended for all Harlequin readers.  It assumes no 
prior knowledge of the memory management project.  However, as an overview, it 
does not attempt to give full definitions for terms or to provide details in 
any area of discussion.  For definitions of terms, see the document 
glossary.glossary in the Memory Management Information System. For more 
complete discussion, see the cross-referenced documents for each section.

Document Conventions

.conv: This document is formatted according to the Memory Management 
Information System guidelines (see the document guide.text).  It contains 
cross-references to other documents in the system  Unless otherwise noted, 
these documents are available via the "Memory Management Information" database 
in Spring.

Document History

.hist.1: Bob Mathews wrote the initial draft of this document.


PRODUCT VISION

.vision.market: The memory management project has two varieties of product:
  - Internal products, for use as components or tools of other Harlequin 
products.
  - External products, to be sold or otherwise distributed independently 
outside Harlequin.

Internal Products

.vision.market.internal: Internal products meet the needs of other Harlequin 
products for memory management.  The following internal products are now under 
development:
  - A client to provide memory management for Harlequin's Dylan implementation.
  - A client to provide memory management for the ScriptWorks Core RIP.

External Products

.vision.market.external: External products are of several varieties:
  - Standalone Harlequin products.
  - Components that replace or supplement memory management services of 
products from other  companies.
  - Custom products and consultancy.

Specific external products have not yet been defined.


PROCESS

.process: The memory management project intends to have well-defined processes 
for development, documentation, testing, and review of products.  An important 
goal of making these processes explicit and rigorous is to ensure that products 
satisfy their requirements.  One requirement common to all products is high 
reliability.  Defining processes for producing products promotes reliability.

.process.develop: Following are some salient components of the development 
process:
  - Analysis of the product's requirements.
  - Specification of how the product will meet requirements.
  - Design of the architecture for implementing specifications.
  - Detailed design of components of the architecture.
  - Implementation.

For more discussion of the development process, see the document 
process.develop.

Process definitions for documentation, testing, review, and other areas are 
still being developed.


GOALS

Project Goals

The memory management project has the following general goals:

.goal.general.revenue: Make products for sale by Harlequin.
.goal.general.internal: Provide solutions for other groups within Harlequin.
.goal.general.central: Reduce duplicated effort within Harlequin.
.goal.general.quality: Improve the quality of solutions within Harlequin.
.goal.general.image: Broaden and improve the image of Harlequin.

For more discussion of general goals, see the document goal.general.

Goals for the Dylan Client

Following are the goals for the Dylan memory management client:

.goal.dylan.provide: Provide a memory management client for Dylan.
.goal.dylan.compete: Promote Dylan in the marketplace.
.goal.dylan.improve: Improve the system.

For more discussion of goals for the Dylan client, see the document goal.dylan.

Goals for the EP Client

Following are the goals for the EP memory management client:

.goal.ep.protect: Protect ScriptWorks from failure due to lack of garbage 
collection.
.goal.ep.downsize: Reduce size of machine needed to run ScriptWorks.
.goal.ep.compete: Remove the risk of bad publicity due to lack of garbage 
collection.
.goal.ep.maintain: Reduce the maintenance burden on EP.
.goal.ep.debug: Assist in the debugging of ScriptWorks.
.goal.ep.perform: Increase the performance of ScriptWorks.
.goal.ep.relate: Improve relationship/communication between SP and EP.
.goal.ep.improve: Improve the general MM system for other clients.

For more discussion of goals for the Dylan client, see the document 
goal.epcore.


KEY REQUIREMENTS

.req: This section presents the chief requirements for memory management 
products.  Each requirement can be further detailed, and the requirement or its 
components can be categorized as critical, essential, optional, or desirable. 
This categorization results in a weight or priority level for each 
requirement.  At present, weights have been assigned only to requirements for 
the EP client.

Requirements for Dylan

Following are the key requirements for the Dylan memory management client:

.req.dylan.rely: Reliability.

.req.dylan.perform: Acceptable performance.

.req.dylan.adapt: Adaptability to new requirements.

For more discussion of the requirements for the Dylan client, see the document 
req.dylan.

Requirements for EP

Following are the key requirements for the EP memory management client:

.req.epcore.fun.types: The Memory Manager shall manage the following types of 
memory, each with its own specialised set of requirements:
  - large-scale base memory (obtained by the RIP at start up),
  - display lists,
  - PostScript objects,
  - font caches,
  - temporary memory.

.req.epcore.fun.auto: The Memory Manager will provide automatic recycling of 
memory occupied by PostScript objects (garbage collection).

.req.epcore.fun.con: The Memory Manger will provide an interface which will 
allow control over management policy and attributes, and provide measurements.

.req.epcore.fun.debug: The Memory Manager will support the debugging of the RIP.

.req.epcore.attr.rel: As a baseline for reliability, the RIP mean time between 
failure due to the Memory Manager shall be no less than 16000 hours of 
continuous operation (that's approximately 100 weeks).

.req.epcore.attr.run-time: RIP run-time shall be no greater than at present 
when applied to individual Seybold Speed Tests, Genoa FTS and ATS tests, and 
defined tests from the ScriptWorks QA Tests Suite.

.req.epcore.attr.tp: RIP throughput shall be no less than at present when 
applied to aggregate Seybold Speed Tests, Genoa FTS and ATS tests, and defined 
aggregate subsets of the ScriptWorks QA Test Suite.

.req.epcore.attr.footprint: The total memory requirement of the RIP shall not 
increase in comparison with the existing system for the same jobs due to the 
new Memory Manager.

.req.epcore.plan.init: An initial Memory Manager which provides a subset of the 
functionality (but will meet the relevant attributes in full) shall be 
delivered in the first half of 1996, and if possible by the end of March.

.req.epcore.plan.full: The full Memory Manager including PostScript garbage 
collection shall be delivered before the end of 1996, and if possible by the 
end of September.

.req.epcore.plan.cutover: The replacement of the existing system shall be 
arranged so that either system can be used in the RIP, so that comparisons can 
be made between the two, both for acceptance testing and to reduce the risk of 
replacement.  The MM Group will produce a report on how this will be achieved.

For more discussion of the requirements for the EP client, see the document 
req.epcore.

Requirements for External Products

The requirements for external products have not yet been defined.  Following is 
a summary of likely general requirements:

.req.product.perform: Performance.

.req.product.adapt: Adaptability.

.req.product.flex: Flexibility.

.req.product.rely: Reliability.


DESIGN CHOICES

.idea: The process of satisfying requirements inevitably poses problems and 
demands choices among possible designs.  The project has generated a number of 
key ideas as solutions to problems and as choices for design decisions in 
memory management.  These ideas inform both process and architecture for the 
project and its products.

This section lists some of these key ideas.

Pool System

.idea.pools: Pools implement policies for managing memory and provide 
interfaces for allocating and freeing memory.  For more information, see the 
document idea.pools.

A System Open to Observation and Debugging

.idea.feedback: The system provides information about its operation that the 
developer can use to debug the system, analyse and tune its operation, and make 
policy choices.  For more information, see the document idea.feedback.

Component Framework

.idea.component: The memory management system is designed to be a component of 
an application and to interoperate with other application components.  For more 
information, see the documents idea.framework and idea.component.

Freestanding Implementation Making Conservative Use of the C Language

.idea.cc: To meet requirements for reliability and portability, the memory 
management system uses a conservative subset of the C language and safe, 
portable coding practices for its implementation.  For more information, see 
the document idea.cc.

Evolutionary Development

.idea.develop: The memory management system and its components evolve, with 
essential components implemented first, and additional or optional features 
added with demand and time.

Process for Quality

.idea.quality: The project defines processes for development and review, as 
well as rules, procedures, and guidelines for carrying out tasks at each stage 
of these processes.  The memory management information system is the repository 
for shared information and a vehicle for managing processes.

Appropriate Optimisation

.idea.optimize: The system optimises operations where feasible and where 
optimisation does not violate more critical requirements for reliability.

Simplicity

.idea.simple: Implementations are constructed from simply and clearly coded 
modules.  The project avoids convoluted and unnecessarily complex design and 
programming style.


ARCHITECTURE

.design.summary: This section summarises key elements of the architecture of 
the memory management system.  It does not offer full definitions of all terms 
or detailed design information.  For definitions, see the document 
glossary.glossary.  For detailed design, see the documents cross-referenced in 
this section.

Pool Classes and the Memory Pool Manager

.design.pool-class: A pool class represents a policy for managing memory.  
Examples of pool classes: allocate only; automatic mostly copying; manual fixed 
small memory.

.design.mpm: The memory pool manager (MPM) manages pool classes.  The client 
interacts with the MPM via an interface that provides operations for allocating 
(alloc) and and freeing (free) memory.

Pools and the Arena

.design.pool: A pool is an implementation of a pool class.  It manages one or 
more areas of memory.  It provides interfaces for alloc and free, for obtaining 
information, and for controlling behaviour.

.design.area: An area is a range of contiguous addresses in memory.

.design.block: A block is an area that is managed by a pool.

.design.arena: The arena area is a range of addresses reserved and used by the 
memory management system.

.design.segment: A segment is a block in the arena.

.design.arena.pool: The arena itself is a pool.  It provides an alloc/free 
interface for segments.  Other pools provide alloc/free for space within 
segments.  A pool can manage more than one segment, but a segment can be 
managed by only one pool.

.design.zone: The arena is partitioned into zones, one for each bit in the 
natural word size of the machine.  If the machine has 32-bit words, the arena 
has 32 zones.  Each arena address encodes the zone number in the middle of the 
address.

.design.refsig: A reference signature is a conservative approximation to a set 
of memory references.

.design.refset: A reference set is the concrete representation of a reference 
signature.  A reference set is implemented as a bit mask in which each bit 
represents a zone.  If the set includes a reference to a particular zone, the 
bit in the reference set that represents that zone is on; if a set includes no 
references to a particular zone, the bit that represents that zone is off.

Equivalence-Class Induced Multigraph

.design.graph: Object references form a graph.  It is possible to think of a 
partial graph of references as a block and to construct equivalent graphs of 
references among these blocks.  For instance, a page or a zone could be a 
block.  These graphs might form either partial or total orderings.

.design.graph.page: Example of use: each page might have a reference signature 
that represents pointers from objects on that page.

GC Tracing and Colour Model

.design.gc.colour: In Dijkstra's colour model, each object is one of three 
colours:
  - White: the object is not known not to be garbage
  - Gray: the object is a candidate for scanning
  - Black: the object has been scanned (and is not garbage)

.design.gc.proc.tracing: Using the colour model, we can define an abstract 
procedure for tracing:

  1. Colour roots gray.

  2.  while (there are gray objects)
         scan a gray object

         scan: Look for pointers in an object and fix them.
                  Turn the object black.

         fix: If object is white, colour it gray.
              If object is gray or black, do not change colour.

  3. When no more gray objects exist:
        Black objects are not garbage.
        White objects are garbage.

  Note: There are never pointers from black to white objects.

General Scanning Mechanism

.design.gc.scan: Each root, pool, and object has a conceptual scan method that 
knows how to find references to objects.  The scan method takes an object and a 
fix function.  It applies the fix function to the object's references.

  scan(object, fix)
    fix(p1)
    fix(p2)
    ...

  fix(p)
    if (isOld(p))
       (p -> fix)(p)

Generic GC

.design.gc.generic: The GC has several capabilities:
  - GC across pools with different GCs.
  - Multiple simultaneous collections.
This could allow low-priority, large collections while high-priority, small 
collections recycle most memory.

Incremental GC

.design.gc.incremental: An important  problem for incremental GC is how to 
maintain the invariant that there are no pointers from black to white objects.  
If this invariant is violated, some white objects may erroneously be declared 
garbage (because black objects are not scanned again).

.design.gc.barrier: There are two primary methods of maintaining this 
invariant, one using a read barrier and the other a write barrier.  These are 
fully described in the survey by Wilson referenced in the document paper.wil92.

Partial GC

.design.gc.condemn: The condemned set is a set of objects designated to be 
collected.  We choose such a set in the hope of reclaiming as many dead objects 
as possible.  The goal is to maximize the benefit of the GC.

.design.gc.condemn.collect: One method for collecting the condemned set is to 
colour all objects gray except those in the condemned set and then scan all 
gray objects to find pointers into the condemned set.

.design.gc.condemn.scan: Scanning all gray objects can consume a great deal of 
time.  Reference signatures and reference sets can be used in very fast tests 
to reduce the scanning time.

.design.gc.condemn.zone: For objects in the arena, one can tell from an address 
which zone an object is in.  If an entire zone is condemned, the address of an 
object can be used in a fast test to determine whether the object is in that 
zone.  This test can be used to avoid scanning all gray objects.  Reference 
signatures can be used to approximate the condemned set and to construct a 
remembered set.

Collections

.design.collect: A collection is a temporal instantiation of a collector.

.design.proc.collect: Following is the abstract procedure for collection:

  1. Flip
      Decide what to condemn.
      Condemn.
      Colour roots of collection gray.

  2. Trace
      Scan.
      Fix.

  3. Reclaim

