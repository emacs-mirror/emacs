                       THE LISP MACHINE STRATEGY
                         strategy.lisp-machine
                             incomplete doc
                            pekka 1998-04-27

REQUIREMENTS

.req.performance: Optimize the overall performance of the machine.

.req.memory: Don't run out of memory, if the mortality estimate given by the 
user is correct.

.req.paging: Use the paging support of the LispM.

.req.no-nailing: No nailing.


STRATEGY

.basics: Each generation has a capacity, and is collected if it exceeds its 
capacity.  Actually, if the nursury generation that feeds into it is at 
capacity, a collection is started, and all generations above it that are at or 
above capacity are also collected, up to the first unfull one.

.promotion: The topmost generation that participates in regular garbage 
collections was called "dynamic"; below it one could have a user-settable 
number of "ephemeral" generations (see book.symbolics90.14.III).  Usually, each 
ephemeral generation is promoted to the next and the topmost one to dynamic 
(see mail.ptw.1998-03-17.18-50 for details).

.cost: In the LispM, memory access was considered to be the dominant cost 
(especially since it might involve swapping), computational CPU cycles were 
ignored.


Dynamic generation

.goal: The goal is to start a collection as late as possible (to maximize the 
potential garbage) but not so late that you might run out of VM (in the LispM, 
VM footprint is limited by swap space).

.costs: scan is 1 read, copy and forward is read and 2 writes, so we estimate
  cCopy = 3 * cScan

.alloc-rate: The user can set the work factor parameter (default 4 w/s), that 
regulates how fast the mutator is allowed to cons compared to the collector's 
working speed
  sAlloc(bTrace, eTrace) <= tTrace / (WorkFactor * cScan)

.trace.survivors: Since there are no nailed objects, we can take sSurvivors = 
sCopied, so:
  sCopied = sCondemned * (1 - Mortality)

.trace.time: Using .trace.survivors and .costs in a.m.trace.time.1:
  tTrace = sFoundation * cScan + sCondemned * (1 - Mortality) * 4 * cScan

.start: Starts when the estimated sCons(bTrace, eTrace) = sFree.  We substitute 
.trace.survivors and the worst-case limit from .alloc-rate in a.m.trace.space.1:
  sCons(bTrace, eTrace)
    = sCondemned * (1 - Mortality) + tTrace / (WorkFactor * cScan)
    = sFoundation / WorkFactor
      + (1 + 4/WorkFactor) * sCondemned * (1 - Mortality)


Ephemeral generations

[missing]


ANALYSIS

[missing]

