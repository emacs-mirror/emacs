                      THE ARCHITECTURE OF THE MPS
                            design.mps.arch
                             incomplete doc
                           richard 1997-01-28

INTRODUCTION

.intro: This document is an overview of the design of the MPS, and a 
justification of that design based on the main MPS requirements.


REQUIREMENTS

.req: These are the critical requirements on the MPS.  More detailed 
requirements can be found in the document req.mps [except not yet].


Flexibility

.req.flex: The MPS must fit into a number of different products and meet 
differing requirements in diverse environments.  It must do this with as little 
modification as possible, so that it can be deployed at low cost.  Flexibility 
gives the MPS broad application, enlarging the market and allowing it to meet a 
range of requirements without extra development from the Memory Management 
Group.  It also reduces the need to maintain special versions of the MPS for 
different clients.

.req.flex.how: Flexibility is mainly provided by pool classes (...) and the 
generic function interface (...), but also by the adaptive scheduler (...) and 
utility function interface (...).


Adaptability

.req.adapt: The MPS should be easy to modify to work in new situations, i.e. it 
should cost little to modify.  This makes the MPS suitable for new applications 
and ensure it a long and useful life.

.req.adapt.how: Adaptibility is provided by [code quality, coding standards, 
justification] (...).


Reliability

.req.rel: Memory management problems are costly.  They are difficult to find 
and fix.  The MPS will be shipped to third and fourth parties, further 
increasing the cost of a defect.  Reliability is therefore very important to 
the viability of the MPS.

.req.rel.how: Reliability is provided by [formal review, incremental delivery, 
simplicity, design principles, conceptual integrity, assertion, coding 
standards, justification, testing].


Efficiency

.req.eff: Efficiency will always be required by clients; after all, memory 
management is about the efficient utilization of resources to meet requirements 
(...).  However, the tradeoffs between those requirements will differ from 
application to application, hence .req.flex and .req.adapt.  A generally 
efficient system will make it easier to meet these requirements.

.req.eff.how: Efficiency is provided by [reference signatures, directed 
optimization] (...)


ARCHITECTURE OVERVIEW

.fig.arch: Overview of the MPS Architecture

 - MPS Architecture Diagram 


Parts and Interfaces

.parts: The MPS consists of two main parts: the "Memory Pool Manager" (MPM) and 
the "pool classes".  .int.mps: The MPM communicates with the client code via 
the "MPS Interface".  .int.class: The MPM communicates with the pool classes 
via the "Pool Class Interface".  .int.os: The MPM communicates with the 
operating system via the "OS Interface".


Pools and Pool Classes

.pool-class: Each pool class may be instantiated zero or more times, creating a 
"pool".  A pool contains memory allocated by the client code.  The memory is 
managed according to the memory management policy implemented by its pool 
class.  For example, a pool class may implement a type of garbage collection, 
or manage a particular form of object efficiently.  Each pool can be 
instantiated with different parameters, creating variations on the policy.

.pool.mpm: The MPM contains the generic parts and the interfaces of the classes.


The Roles of the MPM

.mpm: The MPM has three roles:

  .mpm.co-ord: it co-ordinates the activities of the pools,
  .mpm.os: interfaces to the OS to obtain memory resources (amongst other 
things), and
  .mpm.int: it interfaces with the client code in order to provide it with 
memory management services.


Justification of the MPS Architecture

This architecture gives the MPS flexibility, it's primary requirement 
(.req.flex), by allowing an application of the memory manager to combine 
specialized behaviour implemented by pool classes in flexible configurations.  
It also contributes to adaptability (.req.adapt) because pool classes are less 
effort to implement than a complete new memory manager for each new 
application.  Reliability (.req.rel) is enhanced by the fact that the MPM code 
can be mature code even in new applications.  However, efficiency (.req.eff) is 
reduced by the extra layer of the MPM between the client code and the memory 
management policy.


Structure of the MPM

.mpm: The MPM itself has a complex structure.  You can consider it as a 
collection of frameworks to manage different aspects of memory management, 
together with a collection of interfaces to the client and the OS.

.mpm.framework: The major frameworks in the MPM are:

.mpm.framework.segment: The segment allocation framework is concerned with 
large-scale partitioning of the address space and the memory between different 
pools.  It is implemented mainly by arena classes (see design.mps.arena) and 
used by the pool classes.

.mpm.framework.manual: The manual allocation framework provides small-scale 
manual allocation services.  It is implemented by certain pool classes, and 
used mainly by the client.

.mpm.framework.collection: The collection framework integrates all GC 
activities in the system.  See design.mps.collection for details.

[@@@@ What other frameworks should we identify?]

.mpm.interface: The major interfaces provided by the MPM are:

.mpm.interface.finalization: Finalization services (see design.mps.finalize) 
are provided to the client through a generic interface.

.mpm.interface.shield: The shield interface abstracts access protection 
services provided by hardware and software barriers.  The pools inform the 
shield system about their needs and the shield system controls the barriers and 
the mutator to provide it.

[@@@@ What other interfaces should we identify?]


The Memory Hierarchy

.fig.units: Memory Units
 
 - Memory Unit Diagram 



ATTACHMENTS
   "Memory Unit Diagram"
   "MPS Architecture Diagram"

