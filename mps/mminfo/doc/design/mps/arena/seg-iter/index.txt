            DESIGN OF THE ARENA SEGMENT ITERATION PROTOCOL`
                       design.mps.arena.seg-iter
                             incomplete doc
                             drj 1997-06-10

INTRODUCTION

.readership: Any MPS developer.

.intro: This is the design of the Arena Segment Iteration Protocol.  The 
protocol allows other modules in the MPS to iterate over the segments in an 
Arena.


REQUIREMENTS

.req.complete: A segment that is alive at the beginning of the iteration and 
remains alive until the end of the iteration must be iterated over at least 
once during the iteration.

.req.once: During an iteration each segment is iterated over at most one time.

.req.seg-create: In the case where segments are created during the iteration it 
is not defined whether newly created segments are iterated over or not.

.req.seg-destroy: In the case where segments are destroyed during the iteration 
then they will not be iterated over after they have been destroyed.

.req.addr-order: The segments are iterated over in order of their base address 
(ie the base addresses of the segments iterated over form a monotonically 
increasing sequence).


INTERFACE

.if.first:

Bool SegFirst(Seg *segReturn, Space space);

If there are no segments in the space then this function returns FALSE and does 
not update *segReturn.  Otherwise it returns TRUE and updates *segReturn with 
the segment that has the least base address.

.if.next:

Bool SegNext(Seg *segReturn, Space space, Addr addr);

If there are no segments whose base address is (strictly) bigger than addr then 
this function returns FALSE and does not update *segReturn.  Otherwise it 
returns TRUE and updates *segReturn with the segment which of all the segments 
whose base address is bigger than addr has the least base address (ie the 
"next" segment in address order).


IMPLEMENTATION

.impl.class: SegFirst and SegNext are generic functions, the implementation is 
handled by the classes.


USAGE

.usage.typical:

void SpongSegs(Space space)
{
  Seg seg;
  Addr base;

  if(SegFirst(&seg, space)) {
    do {
      base = SegBase(space, seg);
      Spong(seg);  /* Spong may destroy seg */
    } while(SegNext(&seg, space, base));
  }
}

