                    ARENAVM HYSTERESIS DESIGN NOTES
                     design.mps.arena.vm.hysteresis
                             temporary doc
                             drj 1999-01-05

DEFINITIONS

.def.pte: PTE, Page Table Entry.  In C an object of type PageStruct.

.def.hfund: H-fund, Hysteresis fund.  A collection of pages that are free but 
still mapped.

.def.pthfs: Page Table Hysteresis Fund Summary.  (see .pthfs.bt below)

.def.latent: Pages in the Hysteresis Fund are described as Latent Pages.

.hfund.why.alloc: Allocating segments using pages in the H-fund avoids the 
overhead of having the map the pages.  .hfund.why.free: Freeing segments into 
the H-fund avoids the overhead of having to unmap the pages.

.hfund.whynot: The H-fund incurs a committed memory overhead.

.hfund.how: Pages in the H-fund are distinguished by their corresponding PTEs.  
In addition all such PTEs are linked onto a ring.


.pthfs.bt: PageTableHysteresisFundSummary bit-table with one bit corresponding 
to each page occupied by the page table (NB _not_ each PTE in the page table).  
Bit should indicate whether the corresponding page has PTEs that describe pages 
in the H-fund.  Probably the bit will be conservative in the sense bit==0 will 
indicate 0 PTEs describing H-fund pages, but bit==1 does not necessarily 
guarantee any PTEs describing H-fund pages.

.evict.bytablepage: Maybe the eviction algorithm could iterate over all pages 
in the pageTable for which the corresponding hasLatentPages bit is set.


TASKS

Tricky tasks.

.task.tricky: Task 5 (.task.5) looks a bit tricky.  Task 7 also, but probably a 
bit less than task 5.

.task.1: Fiddle PageStruct to discriminate between free unmapped and free 
mapped pages.  Pages that are free and mapped comprise the H-fund.  Add 
mechanism by which all pages in the H-fund can be iterated over.

.task.2: Add fields to ArenaVMStruct for the H-fund ring and size.  

.task.3: Add field to ChunkStruct for the PageTableHFundSummary Bit Table.  a 
better name would be good too.

.task.4: Add function that takes segment breaks it into pages and adds them 
into the H-fund. (called by SegFree).

.task.5: Add code/function to do whatever SegAlloc needs to do.  Take a range 
of addresses and for each page, map it or remove it from the H-fund as 
appropriate.  SegAlloc must be modified to cope with initial failure by purging 
H-fund and retrying.  Will also need to decide which PageTablePages need 
mapping.

.task.6: Add code to ChunkCreate/Destroy to setup/teardown the pthfs BT.

.task.7: code/function to purge H-fund.  unmap all pages in H-fund removing 
them from H-fund and possibly unmap corresponding PageTablePages.  Would be 
easier if H-fund ring in address order (but that might be undesirable for other 
reasons).

.task.8: Modify fast commit limit check in VMSegAllocComm.  If hysteresis fund 
is low it can still do an early check.  (Committed memory must increase by 
(size of segment - size of H-fund) if H-fun smaller than segment).

.task.9: Modify ArenaVMDescribe to display H-fund. (there is no ArenaVMDescribe 
and I'm not just about to write it).

.task.10: modidy mpsi.c and mps.h to add interface for setting and getting the 
commit slack limit.

.task.11: Add field to ArenaVMStruct record commit slack limit.

.task.12: Modify function which adds to H-fund to check commit slack limit and 
call purge as appropriate.


PLAN

Phase 1

no pages are ever unmapped.

.task.1
.task.2
.task.3
.task.4
.task.5 (no retrying because no purge)
.task.6
.task.8
.task.9

Phase 2

.task.7
.task.5 (rest of)
.task.10
.task.11
.task.12
.task.6 (rest of) prior to calling VMArenaChunkDestroy H-fund will need to be 
purged.


DECISIONS

.decide.sorted: Should be H-fund datastructure be sorted (by address of page)?  
Assume it is a Ring.
+ purge proceeds in address order maximising opportunitied to unmap several 
pages in a single OS call.
+ purge proceeds in address order simplifying the code which determines which 
PageTable Pages to unmap.
- insertion into the H-fund is expensive, O(H), H the size of the H-fund.

sorted: purge is O(H)
unsorted: purge is O(A), A the number of pages occupied by the PageTable  (same 
order as reserved addresses but a lot smaller).

I think keep it unsorted.  The cost of inserting into a sorted ring could be 
prohibitive, whereas the gains to be made are small.  Purge only needs iterate 
over the pagetable (and probably doesn't touch most of the pages).  Segments 
will have added all there pages to H-fund together so that unmapping case can 
be optimised in any case.

