                   DESIGN OF THE COOPERATIVE VM ARENA
                        design.mps.arena.coop-vm
                             incomplete doc
                             drj 1998-07-07

INTRODUCTION

.intro: This document describes the design of the VM arena as it relates to 
cooperative arenas.  By cooperative we mean that the arena is cooperative with 
respect to its consumption of virtual address (so it can cooperate with other 
libraries/DLLs/modules in the process).  We expect to be able to start with a 
small amount of reserved address space and reserve more address space as it is 
required.

[Really this design should be merged into the more sensibly named 
design.mps.arena.vm  drj 1998-01-07]

OVERVIEW

.overview: blah blah


REQUIREMENTS

.req: A cooperative arena impacts the following Dylan requirements: 
request.dylan.170029: Dylan Memory Manager does not meet 
req.dylan(5).attr.obj.max
request.dylan.170057: req.dylan(5).dc.env.self: Must work with other instances 
of itself (boring)
request.dylan.170028: req.dylan(5).attr.capacity (no limit on amount that can 
be allocated)
and the unifying
request.dylan.160065: VM Arena cannot start with a small reserved address space 
and expand

It also satisfies general MPS goals and requirements for flexibility and 
cooperativeness.


ARCHITECTURE

The VM Arena manages a number of Chunks (VMArenaChunk).  Each Chunk is a 
datastructure for managing a single contiguous range of virtual addresses.  
Chunks provide the basic services of segment allocation and freeing.

.chunk.map: The address space described by a chunk can be partitioned into two 
portions: those addresses used to store internal data structures for managing 
the address space itself, and those addresses that segments can occupy.  
.chunk.ullage: The former portion is called ullage.  It comprises: the 
VMArenaChunkStruct itself, an optional spare block (which is present in exactly 
one chunk and contains the parent Arena structure), the alloc bit table 
(chunk->allocTable), the page table mapped table (chunk->pageTableMapped), the 
latent page summary (chunk->noLatentPages), the page table (chunk->pageTable).  
.chunk.ullage.alloc: All of these of allocated at the beginning of the address 
space described by the chunk in that order (there's no strong reason why the 
ullage is at the beginning; it makes a couple of algorithms simpler).  They are 
contiguous save for internal fragmentation caused by alignment restrictions 
(significantly the pageTable is required to be page aligned).  See 
.chunk.struct below for a detailed description of the chunk struct itself.



DESIGN

Structure

.struct.vmarena:

VMArenaStruct

This structure is a descriptor for the vmArena.  It is an arena class structure 
so contains a generic ArenaStruct field (arena, see .struct.vmarena.arena 
below).

VMArenaStruct fields

.struct.vmarena.arena: arenaStruct.  Holds the generic ArenaStruct.

.struct.vmarena.primary: primary.  Holds the primary chunk.    There is exactly 
one primary chunk for each VMArena.  The important thing about the primary 
chunk is that it is the chunk that manages the memory on which the structure 
for the VMArenaStruct of the VMArena is stored (so it's important that you 
don't destroy the primary chunk unless you want to destroy the VMArena as well, 
for example).  The primary chunk is the first chunk created in the VMArena (but 
that's not so important).

.struct.vmarena.chunkring: chunkRing.  A ring containing all the chunks.

.struct.vmarena.chunkcache: chunkCache.  The datastructure used to manage the 
chunk cache.  Currently (1999-01-06) the cache has just one entry.  It is used 
for faster maps from address or segment to chunk.

.struct.vmarena.latentring: latentRing.  A ring containing all the latent pages 
(comprises the hysteresis fund).

.struct.vmarena.latentsize: latentSize.  Total size of all latent pages.

.struct.vmarena.committed: committed.  Size of RAM committed for this arena.

.struct.vmarena.blacklist: blacklist.  RefSet of blacklisted zones.  These are 
avoided (if possible) when allocating segments. 

.struct.vmarena.genrefset: GenRefSet.  An array which maps from generation 
number to the zones that are used by that generation.  
.struct.vmarena.genrefset.zoneset: The set of zones is represented using a 
RefSet.

.struct.vmarena.freeset: freeSet.  RefSet of free zones (zones containing no 
segments).  When new zones are required they are preferentially taken from here.

.struct.vmarena.extendby: extendBy.  The size of a new chunk.  
.struct.vmarena.extendby.init: Initially set to the user specified initial 
arena size.

.struct.vmarena.sig: sig.  A standard signature field, see design.mps.sig.


.struct.chunk:

VMArenaChunkStruct

This structure is the VMArenaChunk descriptor (or just "chunk descriptor").  It 
has many fields, mysterious and mellifluous:

.struct.chunk.sig: sig.  A standard signature field.  The signature for 
VMArenaChunks is 0x519A6B3C "SIGnature ARena VM Chunk".

.struct.chunk.vm: vm.  Holds the VM used in this chunk.  There is a one-one 
correspondence between VMs and Chunks.  The VM provides a thin (but portable) 
veneer over the OS mapping and reserving facilities and is used to actually 
commit memory, see design.mps.vm(0).

.struct.chunk.pagesize: pageSize.  (a cache of) The pageSize as returned by 
VMAlign.  .struct.chunk.pagesize.assume: Assumed not to vary across chunks (so 
vmArena->primary->pageSize will do wherever you need it), but stored in the 
chunk for reasons of poor modularity.  .struct.chunk.pagesize.assume.okay: This 
assumption boils down to VMAlign() being a constant function.  Which it is.

.struct.chunk.pageshift: pageShift.  Log_base_2 of pageSize.  Used in shifts.

.struct.chunk.vmarena: vmArena.  The parent vmArena.

.struct.chunk.arenaring: arenaRing.  Attachment point for chunks to the 
vmArena's ring.  See .struct.vmarena.chunkring above.

.struct.chunk.primary: primary.  A Boolean field which indicates whether this 
chunk is the primary chunk or not.  See .struct.vmarena.primary above.  Notice 
that technically this field is redundant (it is equivalent to chunk == 
chunk->vmArena->primary) but it defined for convenience.

.struct.chunk.inboot: inBoot.  A Boolean field which is set during the creation 
of the (parent) VMArena.  Normally a chunk's vmArena field points to the parent 
VMArena, however during the creation of the vmArena this cannot happen.  This 
field is used to manage that ugliness.  Mostly for checking.

.struct.chunk.base: base.  Cache of VMBase(->vm).

.struct.chunk.limit: limit.  Cache of VMLimit(->vm).

.struct.chunk.pages: pages.  The number of pages in the chunk.  Should be 
(->limit - ->base) / ->pageSize if all is well.

.struct.chunk.pagetable: pageTable.  The pageTable.  Holds all the PageStruct 
descriptors (which describe the disposition of the corresponding pages: 
allocated/free/etc, and form segments).

.struct.chunk.pagetablepages: pageTablePages.  The number of pages occupied by 
the pageTable.

.struct.chunk.pagetablemapped: pageTableMapped.  Has one bit per page occupied 
by the pageTable (ie pageTablePages bits).  (bit == 1) if and only if the 
corresponding page in the page table is mapped.

.struct.chunk.nolatentpages: noLatentPages.  A table which summarises latent 
pages in the pageTable.  This table has one bit per page occupied by the 
pageTable (ie pageTablePages bits).  (bit == 1) => none of the PageStruct 
descriptors on (or partially on) the corresponding page in the pageTable 
describe latentPages.  Note that the implication is only one way.

.struct.chunk.alloctable: allocTable.  The allocTable.  There is a bit for each 
page which indicates whether that page is allocated or not.  Unallocated pages 
may or may not be mapped.  Unallocated mapped pages are latent pages.

.struct.chunk.ullagesize: ullageSize.  The ullageSize field records the 
allocated size of the ullage (the datastructures used by the chunk to manage 
the address space, see .chunk.ullage above).

.struct.chunk.ullagepages: ullagePages.  The number of pages taken up by the 
ullage (which has size ->tablesSize), see .chunk.ullage above.  Should be 
->ullageSize / ->pageSize if all is well.  Mostly used to begin the search for 
free pages (see impl.c.arenavm.tablepages and impl.c.arenavm.alloc.skip).


.chunk.create:

VMArenaChunkCreate

This function creates a chunk.  .chunk.create.tricky: It's implementation is 
slightly tricky because there is small bootstrap problem: The Chunk has to be 
created and allocated using only services available from itself.  When this 
function is finished, a VMArenaChunkStruct has been created with an associated 
VM (see design.mps.vm).  The VMChunkStruct and associated tables have been 
allocated inside the memory described my the VMArenaChunk and the VM.

.chunk.create.tables: The VMChunkStruct, the optional spare block,  and the 
tables are placed at the base of the chunk.  .chunk.create.tables.map: 
Everything is mapped except the pageTable; that is mapped and unmapped as 
needed (see wherever partial mapping of the page table is explained).

.chunk.create.tables.diagram:
Here's a ClarisWorks diagram, showing the disposition of the structure and its 
tables after VMArenaChunkCreate:

(the diagram is currently (1998-01-07) out of date; it doesn't show spare block 
or the latent page summary table, and doesn't use the term ullage, see 
.chunk.map above)



SILLY NOTES

Functions modified for multiple chunks:

VMArenaReserved
VMArenaCommitted
INDEX_OF_ADDR
VMSegAlloc
VMSegFree
VMSegBase
VMSegLimit
VMSegSize
VMSegOfAddr
VMIsReservedAddr




ATTACHMENT
   "Arvmboot.cwk"

