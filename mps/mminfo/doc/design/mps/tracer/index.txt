                      THE DESIGN OF THE MPS TRACER
                           design.mps.tracer
                              obsolete doc
                           richard 1996-10-02

INTRODUCTION

This is my contribution to the field of garbage collection.


BACKGROUND THEORY


Purpose of Tracing

The Tracer is concerned with discovering the transitive closure of the 
"reference" relation (written "->").  To be more precise, it attempts to 
discover

  C intersection {N | R ->>* N}

where C is the "condemned set", N is a node, R is the "root node", and "->>*" 
is the transitive closure of "->>", a relation which is a superset of "->".

The condemned set is the set of nodes whose liveness we would like to 
determine.  In fact, we determine an approximation of reachability from the 
root, hence the "->>*" relation.  The root is the mutator's state.


Graphs

As far as the Tracer is concerned, the mutator's state is represented by a 
"graph" of objects, starting at a "root" node.  Objects which are not reached 
by the "->*" relation from the root cannot be reached by the mutator and must 
be dead.


 - Graph Diagram 

Reference Partitions

A reference partition is a "colouring" of the nodes in the graph of objects.  
Every object is either "black", "grey", or "white" for a particular partition.

A partition (B, G, W) of a directed graph is a reference partition if and only 
if there are no nodes in B which refer to a node in W, i.e., nothing black can 
point to anything white.

A partition is "initial" if and only if there are no black nodes -- (0, G, W).

A partition is "final" if and only if there are no grey nodes -- (B, 0, W).

If P is a predicate, we say some reference partition (B, G, W) is a reference 
partition "with respect to P" if and only if everything with P is in W.

If we can determine a reference partition (B, G, W) such that the roots are 
contained in B and G is empty then we can reclaim G.  Tracing is a way of doing 
this by refinement.  We start out by defining a partion (0, G, W) with respect 
to a "condemned" property.  This is trivially a reference partition. We then 
perform a series of operations that preserve the reference partition invariant 
by moving objects out of W and end up with (B, 0, W).

Typically the first transformation done by a GC is to move many objects from G 
to B.  These objects are those for which it can cheaply determine that they do 
not reference W.  (This includes the idea of "remembered sets".)


Objects and Properties

Properties are another way of defining a "colouring" of the nodes of a graph of 
objects.  We define a predicate "has property P", W(P) (or just P), on all 
nodes.  This automatically defines a reference partition with respect to that 
property.  It also defines a second predicate, "references P", R(P), which is 
true if an object refers to an object with property P.

Black objects don't reference white objects (by the definition of reference 
partitions).

  ForAll n : node . B(P)(n) => not R(P)(n)

Grey objects refer to white objects (by the definition of reference partitions).

  ForAll n : node . G(P)(n) => R(P)(n)

In fact, grey can be defined as objects which refer to white objects and aren't 
white themselves.

  ForAll n : node . G(P)(n) = R(P)(n) and not W(P)(n)

A white object may or may not refer to other white objects, so R(P) is 
independent of W(P).


 - Node Colour Diagram 


Mutator Actions

The root node includes all the mutator's state that it can act on directly.  In 
practice, this usually means it contains the registers of any processors, the 
stacks of threads, and global static data whose addresses are discoverable from 
the code that the processor can execute.  Essentially these are all the objects 
that are directly reachable from the processor registers.  The Tracer is not 
concerned with the reachability or liveness of these objects, only with that of 
objects which are reachable from them.

The mutator can only affect the graph adjacent to the root node, because the 
processor can only access memory relative to its registers.

ASSERTION: Complex addressing modes are equivalent to a sequence of these 
operations as far as the Tracer is concerned.  It this true?

.def.load: The "load" operation adds an edge from the root to an object by 
loading a reference from an object into the root.  This is equivalent to the 
mutator dereferencing a pointer.  If the mutator overwrites a reference in a 
register with the loaded reference then the operation is equivalent to a load 
followed by a drop.

Examples:

  x = y->z;

  ld [i4+4],i5

.fig.load: The mutator "load" operation


.def.store: The "store" operation adds an edge from an object adjacent to the 
root to another object adjacent to the root by storing a reference in that 
object.  If the mutator overwrites a reference in the object with the new 
reference then the operation is equivalent to a store followed by a splat.

Examples:

  y->z = x;

  ld i5,[i4+4]

.fig.store: The mutator "store" operation


.def.splat: The "splat" operation removes an edge from an object adjacent to 
the root to another object.

Examples:

  x->y = NULL;

  ld g0,[i4+4]

.fig.splat: The mutator "splat" operation
.def.drop: The "drop" operation removes an edge from the root to a node 
adjacent to the root.

Examples:

  x = NULL;

  or g0,1024,i4  (where i4 previously contained a pointer)

.fig.drop: The mutator "drop" operation

 - Mutator Action Diagrams  - Mutator Action Diagrams 


Tracing in Abstract

This section describes the tracing process step by step, in terms of the 
abstract idea of an object graph and a single reference partition which is 
refined in order to discover some unreachable nodes.

Initially the heap consists of some nodes whose connectivity has not yet been 
discovered.

.fig.trace.init: The initial graph before tracing


The condemned set is identified.  This is the set we want to attempt to 
recycle.  The whole heap is not condemned for several reasons, concerned with 
efficiency constraints:

  1. generational GC
  2. remembered set efficiency
  3. zones
  4. short-term recycling goals.

We define a new property "condemned".  The nodes in the condemned set are 
coloured "white" by assigning them the condemned property.  All other nodes are 
conservatively considered "grey" because they might refer to the condemned 
nodes.  At this stage the entire heap is R(condemned).  This forms an initial 
reference partition (0, G, W).

.fig.trace.condemn: The condemned set is identified
The reference partition is refined by the Tracer using any additional stored 
knowledge (remembered sets).  The aim is to reduce the grey set to minimum 
size, since the amount of work the Tracer has to do is proportional to the size 
of the grey set.  The refinement process must preserve the validity of the 
reference partition.

The Tracer may maintain a number of reference partitions at any one time.  If 
we notice that the condemned set is equal to an existing white set then we can 
just copy that reference partition.

Take the union of all properties of all objects in the condemned set.  It must 
be the case that any object which is black for _all_ those properties must be 
black for the condemned set.

Take the intersection of the properties of all objects in the condemned set.  
It must be the case that any object which is black for _any_ of those 
properties must be black for the condemned set.

In other words:

  S =  Union  props(n)
       n in C

  P =  Intersection  props(n)
          n in C

  ForAll n : node .

    [{  And   B(x)(n) } or {  Or    B(x)(n)  }]  =>  B(C)(n)
       x in S               x in P

In fact, we want both the set of nodes with any S, and the set of nodes with 
all P to be _minimal_supersets_ of C.  Perhaps there's a way of choosing the 
set of properties so that this is so?

We try to arrange that the zones are a minimal superset (e.g. generations 
uniquely occupy zones) and a maximal subset (there's nothing else in the zone).

.fig.trace.refine: The grey set is refined


The Tracer may decide to make progress at this stage by scanning grey nodes.  
Scanning a node "fixes" the references in that node.  Fixing a reference 
renders the referent non-white.  When all the references in a node are 
non-white it can be coloured black, preserving the validity of the reference 
partition.

.fig.trace.w-step: Grey nodes are blackened by scanning
While the roots are grey the mutator might try to alter the graph.  The only 
operation which would invalidate the reference partition would be a store of a 
white reference into a black node.  A "write barrier" is applied to black nodes 
to catch this operation.  If a black node is written to it is turned grey.  
There are several alternatives:

  1. turn the black node grey on any store to it,
  2. turn the black node grey only if a white reference is stored to it,
  3. turn the white node grey if a reference to it is stored in a black node.

In practice, we don't want to assume that we can obtain the reference being 
written, due to OS and hardware constraints, so we simply turn the black node 
grey, as shown in .fig.store.wb.

.fig.store.wb: The mutator "store" with write barrier


.fig.trace.store: A store hits the write barrier


At some point, the roots must be blackened.  The mutator is suspended (all 
threads are suspended) so that this can be done atomically with respect to the 
mutator.  Incrementally scanning the roots is possible, but is challenging.

.fig.trace.flip: The roots are blackened by scanning
While the roots are black, the mutator might try to alter the graph.  The only 
way that it can invalidate the reference partition is to load a white reference 
into the root from a grey object.  There are several options:

  1. "unflip", reverting the roots to grey,
  2. blacken the grey object before the mutator sees it.

In practice, we don't want to unflip because flipping is fairly costly and we 
want to make progress.  Instead, a "read barrier" is applied to all grey 
objects to catch the load and blacken the object before the mutator completes 
the load.

.fig.load.rb: The mutator "load" with read barrier


.fig.trace.load: A load hits the read barrier, causing further scanning
.fig.trace.r-step: Grey nodes are blackened by scanning


.fig.trace.r-step.2: More grey nodes are blackened
.fig.trace.r-step.3: More grey nodes are blackened
.fig.trace.end: No grey nodes remain, so tracing ends


.fig.trace.reclaim: Remaining white nodes are dead, and are recycled


 - Tracer Diagrams (Reduced)  - Tracer Diagrams (Reduced) 


Five Phase Collection

  1. Condemn

     The condemned set is chosen.  A condemned property is created
     and assigned to the nodes in the set, rendering then white.  A
     reference partition is deduced from other existing reference
     partitions.

     At this stage, the mutator is assumed to reference white objects.
     i.e., R(C)(root) -- roots are grey.

  2. W-Trace

     Grey objects are chosen and scanned, according to some sort of
     progress control.

     At this stage condemned objects cannot be moved, because the
     mutator might be able to see them, and we mustn't give the mutator
     an inconsistent view of the heap.  We could relax this restriction
     if the mutator were willing to recognize broken hearts or replicas.

     This is a good time to get all ambiguous scanning out of the way.

  3. Flip

     The roots are scanned, so that not R(C)(root) -- roots become black.

     This has to be an atomic action as far as the mutator is concerned,
     so threads must be suspended.

     To avoid excessive read barrier impact on the mutator, it is probably
     a good idea to scan other objects which are "near" the roots, or
     otherwise known to be likely to be accessed in the near future.

  4. R-Trace

     Grey objects are chosen and scanned, according to some sort of
     progress control.

     At this stage condemned objects can be relocated, because the
     mutator cannot see them.

  5. Reclaim

     When no grey objects are left the remaining white objects can be
     reclaimed.


SEGMENTS AND COLOUR

The mutator's objects are stored in "segments".  The arrangement of objects 
within a segment is determined by the class of the pool which owns the 
segment.  The pool provides methods for "scanning" the segment, and for 
"fixing" references to the segment.  Scanning a segment means applying the 
generic fix function to all references in that segment.

The segment is the smallest unit which can be protected.  Therefore, the colour 
of the entire segment matters in order to preserve the reference partitions.  
For example, if we expose references to white objects to the mutator then the 
mutator must be grey.  Since the mutator can see the whole page, the colour of 
all the references on the page must be considered together.


 - Segment Diagrams 

If the segment contains an object with property N then bit N of seg->has is 
set.  (It may be conservatively set anyway.)

If the segment contains an object with a reference to an object with property N 
then bit N if seg->refs is set.  (It may be set conservatively anyway.)

These bits represent a set of reference partitions, and the Tracer maintains 
them by using barriers.

Segments with seg->refs subset of mutator->refs are write protected.  When the 
mutator stores into a segment it is transferring an arbitrary reference from 
the root to an object in the segment (see .fig.store), so seg->refs is set to 
mutator->refs (and the protection can be removed).  This ensures that seg->refs 
is (conservatively) up to date and the reference partitions are preserved.

Note that it if the colour of the reference being written could be determined 
then seg->refs could be updated more accurately, but the result might be that 
the segment remained protected.  It is quite likely that the mutator will want 
to write to the segment again (due to locality of reference) so it's better to 
remove the protection and be conservative about the greyness of the segment.

Segments with seg->refs superset of mutator->refs are read protected.  When the 
mutator reads from a segment it is transferring an arbitrary reference from the 
segment to the root (see .fig.load).  The segment is scanned to reduce 
seg->refs as far as possible (i.e., for all condemned properties).  Then 
mutator->refs is unioned with seg->refs.  This ensures that mutator->grey is 
(conservatively) up to date and the reference partitions are preseved.

Note that an alternative is to set mutator->refs to seg->refs, "unflipping".  
However, scanning the roots to clear mutator->refs is expensive, so this is 
undesirable.

A second alternative, in the case of a condemned property is that if the 
reference being read could be determined and fixed, ensuring that it is 
non-white, so that mutator->refs is preserved.  However, this is difficult to 
decode on different platforms, and the mutator is likely to want to read from 
the segment again, so it's better to remove the protection.

"Fixing" is the operation of removing some properties from a referent, possibly 
updating the reference in the process.  "Scanning" is the operation of fixing 
all the references in an object.

The roots are scanned in order to clear bits in mutator->refs (i.e., to 
"blacken" to roots).  This is "flipping" for those bits.  A flip can only occur 
for a property that can be removed from referent objects by the Tracer, such as 
a the property of being condemned.

Being in a zone is a property.  A segment in zone N, and all the objects whose 
references are in zone N, is automatically white for that zone.  Segments which 
refer to zone N are grey for the zone.

A condemned property is assigned to a set of objects in order to try and kill 
them.  All other objects are assumed to be alive.  The set of segments which 
are grey w.r.t. the condemned property is deduced from the other properties, 
and is as small as possible.  (This is equivalent to the notion of a remembered 
set.)  The grey objects (which may well include the root) are scanned, and any 
objects referred to during scanning have have the condemned property removed 
(are removed from the white set).  There is no need to mark the object grey as 
its greyness w.r.t. the property has already been determined.  When no grey and 
non-white objects remain the white objects can be reclaimed.

When a segment is scanned all the references in it are examined.  This is an 
opportunity to calculate its greyness more accurately.  For each reference, the 
whiteness of the referent segment is unioned with the segment's greyness.  
[There's more to it than that, but I can't remember right now.]


IMPLEMENTATION NOTES

There is a dependency between typedef TraceSet and impl.c.mpm.check.ts.

ATTACHMENTS
   "ATT0KFKQ"
   "ATT3HOU7"
   "Segment Diagrams"
   "ATT57T9W"
   "ATTCWB3T"
   "Tracer Diagrams (Reduced)"
   "Mutator Action Diagrams"

