                         DESIGN OF SUN'S JVM GC
                           design.sun.java.gc
                             incomplete doc
                             drj 1999-02-24

The whole of the GC (more or less) is in 
javasrc/src/share/javavm/runtime/gc.c.  Unfortunately, there's a lot of 
initialization stuff there, too.  Bits and pieces are in share/javavm/include/
gc.h, share/javavm/include/interpreter.h, share/javavm/include/alloc_cache.h, 
share/javavm/include/vmprofiler.h, and <platform>/javavm/include/gc_md.h.


CONFIGURATION

Appear to be two heap layouts, keyed on PAGED_HEAPS.  !defined(PAGED_HEAPS) 
means contiguous heaps (memory-mapped).

Contiguous heaps (PAGED_HEAPS not defined) is the default.  See 
build/solaris/java/jvm/GNUmakefile where there is a line "PAGED_HEAPS = false".

Whole heap is one contiguous block separated into a handle area and an object 
area each contiguous and of a fixed size.  Diagram in gc.c, line 78.

When using PAGED_HEAPS appears to have a page table describing all pages 
between lowest and highest chunk (which could be the whole address space, I 
suppose).


INTERFACE


.if.interpreter: interpreter.h line 405 appears to prototype the interface that 
the interpreter uses from gc.c.

HObject *cacheAlloc(ExecEnv *ee, struct methodtable *mptr, long size);
JHandle *allocArray(ExecEnv *, int, int);
JHandle *allocObject(ExecEnv *, ClassClass *);
ClassClass *allocClass(ExecEnv *);
bool_t InitializeAlloc(long max, long min);
int64_t TotalObjectMemory(void);
int64_t FreeObjectMemory(void);
int64_t TotalHandleMemory(void);
int64_t FreeHandleMemory(void);
int tracegc;
void gc(unsigned int spaceRequested);
JHandle **newJNIWeakRef(ExecEnv *ee, JHandle *obj);
bool_t deleteJNIWeakRef(ExecEnv *ee, JHandle **handleP);
void RunFinalizersOnExit(void);
void InitializeRefs(void);
void EnableGC(ExecEnv *ee);
void DisableGC(ExecEnv *ee);
bool_t GCEnabled(ExecEnv *ee);
void heap_lock(ExecEnv *ee);
void heap_unlock(ExecEnv *ee);

.if.interpreter.more: There's more scattered all over interpreter.h:

bool_t verbosegc;
bool_t classgc;
typedef struct execenv ExecEnv;
bool_t isValidHandle(JHandle *h);
bool_t isObject(void * ptr);  /* Duplicated in gc.h */
bool_t isHandle(void * ptr);  /* Duplicated in gc.h */

.if.gc: gc.h defines (and sometimes implements) some more interface:

void lock_for_debugger(struct execenv *ee);
void unlock_for_debugger(struct execenv *ee);
void GCFreeClass(ClassClass *cb);
struct Hjava_lang_String * internString(struct Hjava_lang_String *str);
bool_t isObject(void *p);  /* Duplicated in interpreter.h */
bool_t isHandle(void *p);  /* Duplicated in interpreter.h */
void pin_object(void *obj);
void unpin_object(void *obj);
int pinned_object(void *obj);
float minHeapFreePercent;
float maxHeapFreePercent;
long minHeapExpansion;
long maxHeapExpansion;
jlong timeOfLastGC;
#define CHECK_INTERIOR_POINTERS

.if.cache: alloc_cache.h defines the per-thread allocation cache.

struct alloc_cache {...}
int allocCacheSize;
int allocLocalSize;
int allocHandleCount;
void allocCacheCleanup(struct alloc_cache *);

.if.md: gc_md.h defines configuration parameters, some platform-dependent, some 
not.
 
#define LDEBUG
#define TRACEGC
#undef TRACEMARK
#undef TRACEFREE
#undef TRACECOMPACT
#undef PDEBUG
#define OS_BLOCK_OVERHEAD  0     /* in bytes */
#undef WASTED_SPACE_IN_LEADER
#define PAGE_ALIGNMENT     (64 * 1024)  /* page size is the same. */
#define PTR_2_PAGE_SHIFT    (16)
#define MIN_OBJ_PAGES (2)   /* min # of pages to allocate for objects */
#define MIN_HANDLE_PAGES (2)   /* min # of pages to allocate for handles */

.if.hpi: share/hpi/include/hpi_impl.h defines the downward interface.  .if.hpi
.vm: These four have the role of the VM interface (see win32/hpi/src/
memory_md.h line 26 for details):

void * sysMapMem(size_t, size_t *);
void * sysUnmapMem(void *, size_t, size_t *);
void * sysCommitMem(void * ptr, size_t size, size_t * actual);
void * sysDecommitMem(void * ptr, size_t size, size_t * actual);

.if.hpi.manual: The rest is a manual allocation i/f.

void * sysMalloc(size_t);
void * sysRealloc(void*, size_t);
void sysFree(void*);
void * sysCalloc(size_t, size_t);
char * sysStrdup(const char * string);
void * sysAllocBlock(size_t, void**);
void sysFreeBlock(void *);

.if.jvmpi: vmprofiler.h contains some functions to implement a heap dumper 
(heap_lock and heap_unlock are also needed):

JHandle *jvmpi_obj_reverse_map(void *obj);
void jvmpi_in_dump_heap(bool_t flag);
ClassClass * jvmpi_get_object_info(JHandle *h, int *is_array, int *size);
unsigned long jvmpi_get_heap_size(void);

.if.jvmpi.callback: These are callbacks from the GC into JVMPI for producing 
dumps and traces:

void jvmpi_dump_add_trace(ExecEnv *ee);
void jvmpi_dump_add_root(JHandle *h, int kind, void *info, void *extra_info);
void jvmpi_dump_object(JHandle *h);
void jvmpi_new_arena(void);
void jvmpi_alloc_object(ExecEnv *ee, JHandle *h);
void jvmpi_free_object(JHandle *h);
void jvmpi_move_object(void *old, void *new);
void jvmpi_free_class(ClassClass *cb);
void jvmpi_gc_start(void);
void jvmpi_gc_finish(long used_objs, long used_obj_space, long total_obj_space);

.if.meter: There's a set of metering tools, turned on by HEAPMETER, but I can't 
find any prototypes, so I don't think those are used.

.if.flag: Defining DEBUG turns on all kinds of checks.  Undoubtedly there are 
other global flags.


Routines


.if.routines: Here's a description of each interface name (apart from some 
common types):


allocArray

defined in: share/javavm/runtime/gc.c line 1388

HObject *allocArray(ExecEnv *ee, int t, int l)

[from the comment in the source code] Allocate an array of type 't' with 
initial size 'l'.  This routine takes care of setting the method table pointer 
correctly.  It also takes into consideration any special sizing requirements, 
like those needed for arrays of classes.


alloc_cache

defined in: share/javavm/include/alloc_cache.h

struct alloc_cache {...}

The structure of a allocation cache, embedded in each thread (ExecEnv).  All 
fields are initialized to zero by the thread allocation routine.


void allocCacheCleanup(struct alloc_cache *);

defined in: share/javavm/runtime/alloc_cache.c

Finish an allocation cache.  Called when a thread dies.


allocCacheSize

defined in: share/javavm/runtime/gc.c

int allocCacheSize;

Refill size of an allocation cache.  Set by the -Xmc command line parameter, 
defaults to ALLOC_CACHE_SIZE (1024).


allocClass

defined in: share/javavm/runtime/gc.c line 1368

ClassClass *allocClass(ExecEnv *ee)

Allocates a class.  Calls through to cacheAlloc.  Seems to have some hackery to 
allocate the first class (java_lang_Class).


allocHandleCount

defined in: share/javavm/runtime/gc.c

int allocHandleCount;

Cache handle refill count.  Set by the -Xmh command line parameter, defaults to 
ALLOC_HANDLE_COUNT (ALLOC_CACHE_SIZE/8/3).


allocLocalSize

defined in: share/javavm/runtime/gc.c

int allocLocalSize;

Allocations smaller than this are attempted from local cache.  Use 0 to turn 
off cache allocation.  Must be less than cache size.  Set by the -Xml command 
line parameter, defaults to ALLOC_LOCAL_SIZE (ALLOC_CACHE_SIZE/4).


allocObject

defined in: share/javavm/runtime/gc.c line 1411

HObject *allocObject(ExecEnv *ee, ClassClass *cb)

Allocates an object, not an array.  Calls through to cacheAlloc.  Note that the 
size of an object is determined from its class (presumably represented in cb).  
This routine is also responsible for registering the object for finalization if 
it has a finalizer (in quite a baroque way, using execute_java_static_method).


cacheAlloc

defined in: share/javavm/runtime/gc.c

HObject *cacheAlloc(ExecEnv *ee, struct methodtable *mptr, long size)

Function for allocating an object from a thread's allocation cache.  (Analogous 
to mps_ap_reserve/commit.)


CHECK_INTERIOR_POINTERS

(not) defined in: share/javavm/include/gc.h line 79

#define CHECK_INTERIOR_POINTERS

Flag for recognizing interior pointers (from the stack, JNI, and some other 
stuff -- whatever is marked before the call fo ScanHeap).


classgc

defined in: share/javavm/runtime/globals.c line 31

boot_t classgc;

[From share/javavm/runtime/gc.c line 27] A flag for lightweight garbage 
collecting info.


deleteJNIWeakRef

defined in: share/javavm/runtime/gc.c line 438

bool_t deleteJNIWeakRef(ExecEnv *ee, JHandle **handleP);

Deallocates a JNIWeakRef; DeleteWeakGlobalRef in the JNI interface.


DisableGC

defined in: share/javavm/runtime/gc.c line 5313

void DisableGC(ExecEnv *ee);

Disables the GC.  gc_disable_count is incremented.  See .lock.gc.


EnableGC

defined in: share/javavm/runtime/gc.c line 5304

void EnableGC(ExecEnv *ee);

Enables the GC.  This function decreases the gc_disable_count by 1, when it 
reaches 0, the GC is enabled (by signalling a monitor).


ExecEnv

defined in: share/javavm/include/interpreter.h

typedef struct execenv ExecEnv;

This is the structure that stands for threads.  It includes an alloc_cache.  
All fields are initialized to zero (by the allocation routine).


FreeHandleMemory

defined in: share/javavm/runtime/gc.c line 885

int64_t FreeHandleMemory(void);

Of TotalHandleMemory that which is free.


FreeObjectMemory

defined in: share/javavm/runtime/gc.c line 873

int64_t FreeObjectMemory(void);

Of TotalObjectMemory that which is free.


gc

defined in: share/javavm/runtime/gc.c line 5077

void gc(unsigned int spaceRequested);

User interface entry point to explicit gc.  Calls gc0.  spaceRequested is the 
amount of contiguous object space (not counting the header) that is needed by 
the caller.


GCEnabled

defined in: share/javavm/runtime/gc.c line 5320

bool_t GCEnabled(ExecEnv *ee);

returns true if the GC is enabled.  I.e., iff gc_disable_count == 0.


GCFreeClass

defined in: share/javavm/runtime/gc.c line 5571

void GCFreeClass(ClassClass *cb);

Call FreeClass inside the heap lock and zero the class object.  Not clear why 
this is needed, unless it's simply deadlock avoidance, because the GC calls 
FreeClass inside the heap lock.


heap_lock

defined in: share/javavm/runtime/gc.c line 5341

void heap_lock(ExecEnv *ee);

Locks the heap against modification (alloc & GC).  alloc_caches are outside 
this lock.


heap_unlock

defined in: share/javavm/runtime/gc.c line 5346

void heap_unlock(ExecEnv *ee);

Undo heap_lock.


InitializeAlloc

defined in: share/javavm/runtime/gc.c line 5266

bool_t InitializeAlloc(long max_request, long min_request)

[from the source code comment] Initialize the Java heap.  Argument max_request 
is the maximum heap memory we are prepared to devote to the heap, and 
min_request is the minimum memory and amount allocated on startup.  The 
parameters usually come from the -Xms and -Xmx command-line options.

Uses initializeAlloc0 which is configuration-dependent.


InitializeRefs

defined in: share/javavm/runtime/gc.c line 3254

void InitializeRefs(void);

Initializes a whole load of global (static) class variables for variables 
reference classes and some other variables.

internString

@@@@

struct Hjava_lang_String * internString(struct Hjava_lang_String *str);

@@@@


isHandle

defined in: share/javavm/runtime/gc.c

bool_t isHandle(void *p);

A (conservative) handle test, based on what region of memory the pointer points 
to.  I.e., is this value a pointer to a handle?


isObject

defined in: share/javavm/runtime/gc.c

bool_t isObject(void *p)

A (conservative) object test, based on what region of memory the pointer points 
to.  I.e., is this value a pointer to an object?


isValidHandle

defined in: share/javavm/runtime/gc.c

bool_t isValidHandle(JHandle *h);

Is handle null or a valid handle (isHandle) pointing to an actual object (not a 
free handle)?


lock_for_debugger

defined in share/javavm/runtime/gc.c

void lock_for_debugger(struct execenv *ee);

Acquires all(?) the locks for the current thread, including the heap lock 
(heap_lock).  Used by the debugger to prevent another thread from holding any, 
while it's in the process of being suspended.


maxHeapExpansion

defined in: share/javavm/runtime/gc.c line 70

long maxHeapExpansion = 4 * 1024 * 1024;

Set by -Xmaxe option.


maxHeapFreePercent

defined in: share/javavm/runtime/gc.c line 68

float maxHeapFreePercent = (float)0.60;

Set by -Xmaxf option.


minHeapExpansion

defined in: share/javavm/runtime/gc.c line 69

long minHeapExpansion = 1 * 1024 * 1024;

Set by -Xmine option.


minHeapFreePercent

defined in: share/javavm/runtime/gc.c line 67

float minHeapFreePercent = (float)0.35;

Set by -Xminf option.


newJNIWeakRef

defined in: share/javavm/runtime/gc.c line 418

Allocates a new JNIWeakRef; NewWeakGlobalRef in the JNI interface..  
Initializes it and puts it on the global list of such things too.  Note that 
these are weaker than the reference objects.


RunFinalizersOnExit

defined in: share/javavm/runtime/gc.c line 5418

executes the java method java.lang.Ref.Finalizer.runFinalizersOnExit, via 
execute_java_static_method.


timeOfLastGC

defined in share/javavm/runtime/gc.c line 72

Exported through Java_sun_misc_GC_maxObjectInspectionAge in
share/native/sun/misc/gc.c.


TotalHandleMemory

defined in: share/javavm/runtime/gc.c line 879

int64_t TotalHandleMemory(void);

Uses TotalHandleCtr which, judging from share/javavm/runtime/gc.c line 2139, is 
the total amount of memory committed from the OS for handles.


TotalObjectMemory

defined in: share/javavm/runtime/gc.c line 867

int64_t TotalObjectMemory(void);

Uses TotalObjectCtr which, judging from share/javavm/runtime/gc.c line 2277, is 
the total amount of heap space mapped for use by objects.  It's therefore a bit 
like mps_arena_committed.


tracegc

defined in: share/javavm/runtime/gc.c line 242

Flag used when deciding to emit gc info.  Supposedly much more info than 
verbosegc.


pin_object

defined in: share/javavm/runtime/gc.c

void pin_object(void *obj)

Used by JNI to pin objects.  The JNI keeps track of how many times an object 
has been pinned (by means of a hash table), and only calls this once per object 
(this is the wrong i/f, the MM should take care of multiple pinning).


pinned_object

defined in: share/javavm/runtime/gc.c

int pinned_object(void *obj)

Used by JNI to find out if an object has been pinned.


unpin_object

defined in: share/javavm/runtime/gc.c

void unpin_object(void *obj)

Used by JNI to unpin objects.


verbosegc

defined in: share/javavm/runtime/globals.c line 29

[From share/javavm/runtime/gc.c line 27] A flag for lightweight garbage 
collecting info.


DETAILS


Initialization

.init: The GC system is initialized by calling InitializeAlloc (q.v.).


Entry

.entry: The major GC entry points are the functions gc and gc0.  gc locks the 
heap (HEAP_LOCK) and calls gc0.  gc0 calls gc_locked wrapped between calls to 
sysThreadSingle and sysThreadMulti which put the system into single-threaded 
mode (so the GC is called with all other threads stopped).  gc_locked is a 
piece of machine code that (on the SPARC) flushes the register windows then 
calls gc0_locked.  Hmm, they still don't dump the saved registers (callee 
save), perhaps this is a problem?

.entry.lock: gc0 uses lockGCLocks to hold some locks during GC (and releases 
them using unlockGCLocks).  lockGCLocks also checks that it's not already 
holding (some of) the locks, i.e., that GC was not invoked in the middle of 
certain structure-modifying operations (although the locks could be held for 
other reasons as well).

.lock.refs: The lock field of the Reference class (classJavaLangRefReference) 
is used to regulate access to the queue of enqueued reference objects (the 
pending field of the same class (an empty queue is null, but the last element 
is indicated by linking to itself)).  This is an object lock, not a static 
monitor.

.lock.class-table: BINCLASS_LOCK ensures that only one thread is updating the 
global class table (binclasses).  This lock is also grabbed by the GC to ensure 
that the GC always sees a valid global class table state.

.lock.class: LINKCLASS_LOCK ensures that only one thread updates per-class data 
when resolving symbolic references (this seems to mean the constant pool data 
and method block).  This lock is usually held only for a short period of time 
just to protect updating the class structures.  Unfortunately, this is dynamic 
data, allocated through sysCalloc at class load time.

.lock.thread: QUEUE_LOCK is used to regulate access to the thread queue and 
thread structures.  @@@@

.lock.cache: CACHE_LOCK is used to regulate access to the monitor cache.  
There's a comment in monitor_cache.c saying that on Green Threads the 
CACHE_LOCK is the scheduler lock -- this doesn't appear to be true.

.lock.gc: GC_DISABLE_LOCK is used to regulate access to gc_disable_count, and 
to notify GC when it changes.  lockGCLocks waits for it to be zero.


Mark bits

.mark: 1 mark bit per object is allocated (off to the side).


Scanning

.scan.root: MarkPtr is used to mark a pointer during "root scan".  It would 
appear that ValidHorO must be true before calling MarkPtr.

.scan.heap: Scanning algorithm appears to be locally recursive (from comment in 
share/javavm/runtime/gc.c line 316), but a depth counter is used to limit 
depth.  Located but unscanned handles are placed in a "deferred handle table" 
(effectively a grey list cache).


Interned strings

.intern: Judging from share/javavm/runtime/gc.c line 5035 interned strings 
would appear to be handled a bit more explicitly than is strictly necessary for 
a GC.  Why not just use weak tables?


References

.jniweakref: These are weaker than phantom references!  Note that they are 
processed after all reference classes in gc0_locked.

.phantom: The referent of phantom references really isn't cleared!  Why?  There 
can't be any way to tell from Java.


BUGS, KNICK-KNACKS, OBSCURITIES

.large: May not be able to allocate object bigger than 2^28 bytes in some 
configurations.

Does this code in cache_alloc:

size = ROUND_SIZE(size);
    if (size < 0) {  /* overflow */
        goto return_null;
    }
    
catch all overflow problems with size?  What if ROUND_SIZE(size) == 0?

.assume.charbit: Assumes the number of bits in a byte is 8.  I.e., that 
CHAR_BIT == 8.  [Where?

.assume.int.size: Assumes that "int" is big enough for object sizes.  Object 
headers use a 32-bit length field (with low bits stolen for other purposes).

.assume.long.size: Assumes unsigned long is the same size as pointers (in 
obj_swap and related, FAST_MONITOR code and related).

.bug.compact: The PAGED_HEAPS version of compactHeap is wrong if FAST_MONITOR 
is set, because it swaps the first word of the object (as documented), but 
REVERSE_SWAP swaps the monitor word.  It should use obj_swap.

.callee-save.not: On entry to the GC the callee save registers don't appear to 
be saved.  I would've expected to see something in solaris/javavm/runtime/
machgc_sparc.s for example.@@@@

.stack.win95: Before scanning the stack they bother to align the stack pointer 
(to sizeof(void *) as it happens), and claim it's important for Windows 95.  Oo 
er.  See share/javavm/runtime/gc.c line 2815.

.assume.void-star.pot: Assumes that sizeof(void *) is a power of 2.  See gc.c 
line 2817.


SYMBOLS


.symbols: Some random symbols in the GC explained:


ValidObject

defined in: share/javavm/include/gc.h line 228

A (conservative) object test, based on what region of memory the pointer points 
to.  I.e., is this value a pointer to an object.


ValidHandle

defined in: share/javavm/include/gc.h line 231

A (conservative) handle test, based on what region of memory the pointer points 
to.  I.e., is this value a pointer to a handle.


ValidHorO

defined in: share/javavm/include/gc.h line 234

A conservative test for handle or object.  I.e., is this value a pointer to a 
handle or an object.


threadStackBase

defined in: ?
declared in: share/javavm/include/threads.h

Used by GC to locate a threads stack


threadStackPointer

defined in?
declared in: share/javavm/include/threads.h

Used by GC to locate a thread's stack.


HandleTo

defined in share/javavm/include/oobj.h

Used to declare C struct types corresponding to object handles.


hdr

defined in: share/javavm/include/gc.h

A type.  Either int64_t or int32_t according to whether FAST_MONITOR is defined 
or not.


ROUND_SIZE

defined in: share/javavm/runtime/gc.c

Macro that rounds an object size up.  Includes hdr overhead and object grain 
padding.


markbits

defined in: share/javavm/runtime/gc.c

unknown purpose, but I betya it points to mark bits.


discoveredRefs

defined in: share/javavm/runtime/gc.c

Linked list containing all reference objects that survived the collection (used 
by processRefs).


refEnd

defined in: share/javavm/runtime/gc.c

A dummy object used as an end-list marker (who know why they don't just use 
NIL).


free_deferred_handle_list

defined in: share/javavm/runtime/gc.c

I assume it's the free list in the deferred handle table (a.k.a. grey list 
cache).


used_deferred_handle_list

defined in: share/javavm/runtime/gc.c

I assume it's the list of allocated entries (ie grey handles) in the deferred 
handle table.


cacheFillBlock

defined in: share/javavm/runtime/gc.c

analogous to mps_ap_fill?


gc0

defined in: share/javavm/runtime/gc.c line 5003

Internal interface to garbage collection (with heap lock held, cf. gc).


unhand

defined in: share/javavm/include/interpreter.h line 372

A macro that maps from an object's handle to the object itself.  Just a wrapper 
for member access obviously.


sizearray

defined in: share/javavm/runtime/gc.c line 1362

int sizearray(int t, int l)
(from the comment in the source code)
Calculate the size in bytes of an array of type t and length l.

The function is different for classes than other types.


markbits

defined in: share/javavm/runtime/gc.c line 226

A pointer to the array of markbits.  See also BITSPERMARK.


BITSPERMARK

defined in:  share/javavm/runtime/gc.c line 227

The number of bits in a *markbits (ie the number of bits per word).


TotalObjectCtr

defined in: share/javavm/runtime/gc.c line 230

size of the object space committed from the OS.


pendingRefs

defined in: share/javavm/runtime/gc.c line 292

Points to the static member pending of the class java.lang.ref.Reference, which 
is where GC stores the list of references to be enqueued.


clearMarkBits

defined in: share/javavm/runtime/gc.c line 891

Presumably it clears the mark bits.  Calls clearLocalMarkBits.  When using 
PAGED_HEAPS also "clear the pinned flag of each object chunk".


clearLocalMarkBits

defined in: share/javavm/include/gc.h line 

called only by clearMarkBits (in gc.c).  Has a trivial definition unless 
WASTED_SPACE_IN_LEADER is #defined.  Has a non-existant one otherwise (AFAICT).


scanThreads

defined in: share/javavm/runtime/gc.c line 2966

calls scanThread on each thread by using sysThreadEnumerateOver.


scanThread

defined in: share/javavm/runtime/gc.c line 2740

It scans a thread, ie the thread's preserved register context and the stack.  
This will turn into a root scanner for MPS.  Scans the C stack, the java stack, 
the allocation cache.


scanJavaFrame

defined in: share/javavm/runtime/gc.c line 2973

Scans a java stack frame.  It's a building block used by scanThread.


scanHeap

defined in: share/javavm/runtime/gc.c line 3062

Doesn't do what you think.  In particular in current configurations it does 
nothing at all.  The body is #ifdef'ed on CHECK_INTERIOR_POINTERS.  Calls 
MarkPtr on every object that has a mark bit somewhere in its middle (possibly 
including the base of the object as well).


MarkPtr

defined in: share/javavm/include/gc.h line 249 and line 337

Mark the object/handle in the markbits table.


IsMarked

defined in: share/javavm/include/gc.h line 251 and line 341

Returns 0 unless the object/handle has been marked.


scanHandles

defined in: share/javavm/runtime/gc.c line 3136

Scans over all the handles and recursively marks all marked objects.


markChildrenFromTop

defined in: share/javavm/runtime/gc.c line 3124

Marks the children of the first argument, and then pulls off handles from the 
deferred handle list marking children until there are no more handles.  What's 
the limit argument doing though; it's unused by markChildren which is just as 
well since it's passed a useless value from this routine.


markChildren

defined in: share/javavm/runtime/gc.c line 2524

limit argument is unused (but declared with "register"!).

This is a key function.  It scans over a handle/object pair performing all the 
necessary "fixing" (recursive marking in their terminology).  [What does the 
traceRefs argument mean?  scanHandles calls with it FALSE, preProcessSoftRef 
calls with it TRUE.@@@@]


REC_MARK

defined in: share/javavm/runtime/gc.c line 2503

This is the recursive marking procedure.  If the handle isn't marked, calls 
MarkPtr then PUSH_REC_MARK.  PUSH_REC_MARK is only called if the handle is 
_behind_ where the GC is up to in scanning the handles (since if the relevant 
handle is ahead, the GC will get to it anyway).


PUSH_REC_MARK

defined in: share/javavm/runtime/gc.c line 2495

Records a pending mark (i.e., a handle marked but not scanned) in a stack, but 
if the stack is full then calls MarkChildren directly.  The stack is maintained 
in the rec_mark_stk variable.  A handle is popped off the stack and processed 
whenever an object has been scanned (i.e., towards the end of markChildren).


obj_classblock

defined in: share/javavm/include/interpreter.h line 146

Accessor that retrieves the class descriptor (classblock or cb) given an object 
handle.  A couple of indirections.


obj_geth

defined in: share/javavm/include/gc.h line 139 and line 168 (variant on 
FAST_MONITOR)

Gets the header word of an object.


ALLOC_CACHE_BLOCK_TAG

defined in: share/javavm/runtime/gc.c line 673

This is a dummy type (value of methods field in handle structure) for denoting 
the spare block that the alloc cache is using.

#define ALLOC_CACHE_BLOCK_TAG   mkatype(T_MKTYPE(T_UINTEGER, 2), 1)


cbObjectOffsets

defined in: share/javavm/include/oobj.h line 311

gets the object_offsets field from the underlying class object.


ClassClass

defined in: share/javavm/include/oobj.h line 64

A (typedef for) the structure type corresponding to the handle for a class 
object (ie an instance of the java.lang.Class).


Classjava_lang_Class

defined in: share/javavm/include/oobj.h line 204

The structure type that describes a class object (n.b., the object itself, not 
the handle).  There are lots of fields.


CCIs

defined in: share/javavm/include/oobj.h line 362

Used to test bits in the class's flags field.  E.g CCIs(cb, Reference) checks 
the CCFIs_Reference bit (defined in oobj.h too) which is 0x08 and means 
(according to the comment) this is a (indirect, possibly trivial) subclass of 
Reference (java.lang.Reference?).


out_of_memory

defined in: ??

Use (by gc.c) to signal that the GC is out of memory.  As far as I can tell, it 
doesn't return.


h_len

defined in: share/javavm/include/gc.h line 183

Returns the size of an object (in bytes) given the header word.  See also 
obj_len which does the same but uses a pointer to the object instead (which 
points to the header word as it happens).


obj_len

defined in: share/javavm/include/gc.h line 201

Returns the size of an object (in bytes) given a pointer to it.


AllocHandle
HEAP_LOCK
KEEP_POINTER_ALIVE
MarkPtr
METHOD_FLAG_BITS
SetLimits
T_CLASS
T_MAXNUMERIC
T_SIZEFIELD
compactHeap
execute_java_static_method
expandMarkBits
initializeAlloc0
int2ll
manageAllocFailure
markChildren
markChildrenFromTop
mkatype
realObjAlloc
scanHandles
scanJNIGlobalRefs
scanMonitorCache
validatePool


