                   DESIGN OF SUN'S JVM OBJECT LAYOUT
                         design.sun.java.object
                             incomplete doc
                             drj 1999-02-24

INTRODUCTION

.intro: This document describes the object format and layout of objects in 
Sun's JVM.  The JVM from Sun's JDK 1.2 is described.


DETAILS

.handle: seems to use a handle and an object (judging from 
javasrc/src/share/javavm/include/gc.h)

.alloc-cache: per-thread allocation caches (like APs) can be used: 
share/javavm/include/alloc_cache.h

.handle.format: Handles consists of a pair of pointers.  In C each java class 
has a handle type for that class (at least conceptually).  The handle type is a 
structure type called H##T (e.g. Hjava_lang_object).  The structure types are 
declared using the HandleTo macro (defined in share/javavm/include/oobj.h).  
Each has a member obj pointing to the object (of the appropriate type for that 
class) and a member methods pointer to a methodtable (of type "struct 
methodtable").

.handle.generic: A generic handle is represented in C by the structure type 
JHandle.  Defined in share/javavm/include/oobj.h line 48, using the HandleTo 
macro:
struct Hjava_lang_Object {
  Classjava_lang_Object *obj;
  struct methodtable *methods;
}

.handle.pun: Often the methods member is co-opted to act as a link pointer when 
treating handles as linked-list elements.  There's no abstraction or change of 
type, so watch out! (see for example, the code in cacheAlloc to pop a handle 
off the free list, share/javavm/runtime/gc.c line 765).  .handle.pun.free: In 
particular, free entries in the handle table are linked through this field, and 
their obj field is set to 0.

.methodtable: The "struct methodtable" type is defined in share/javavm/include
/oobj.h line 126.  It has two members, "classdescriptor", "methods".  
classdescriptor is a pointer to ClassClass (being (an alias for) the type of a 
handle that refers to a class).  methods is a single element array of "struct 
methodblock".  It relies on the variable array at the end of struct hack.

.boring: The default case for an object seems to be described by code beginning 
at line 2601 of gc.c (and describes a really innefficient object format).  An 
object's class' object_offsets field (is either NULL indicating a leaf object 
or) points to a 0 terminated array of shorts.  Each short contains a byte 
offset into the object of a reference that should be marked.  All the offsets 
are biased by adding 1 to them so that 0 can be used to indicate the end of the 
array.

.diagram: Here's a diagram for normal (non-array) objects:

A handle (Hjava_lang_Object aka JHandle aka HObject)
+----------+
| .obj    ---> an object
+----------+
| .methods---. a method table
+----------+ |
             |
.------------'
|
|A method table (struct methodtable)
>+------------------+
 | .classdescriptor----.
 +------------------+  |
 | .methodblock[0]  |  |
 +------------------+  |
 | .methodblock[1]  |  |
 +------------------+  |
 | ...              |  |
                       |
.----------------------'
|
|
| A class handle (ClassClass aka Hjava_lang_Class)
`>+---------------+
  | .obj         ----. (points to the class object)
  +---------------+  |
  | .methods      |  |
  +---------------+  |
                     |
                     |
 .-------------------'  
 |
 | A class object (Classjava_lang_Class)
 `>+-------------------+
   | many fields ...   |
   +-------------------+
   | .object_offsets --------->(array of short)
   +-------------------+
   | ...               |


.array: In an array handle, the obj field points to the array body and the 
methods field contains length and element type (see mkatype in 
share/javavm/include/interpreter.h).  The array body has a normal header.  For 
arrays of instances, the type in the methods field is T_CLASS (the comment in 
share/javavm/include/typecodes.h is obsolete), and the actual element type is 
stored in the last element of the array (as a class handle); the array body is 
vector of handles.  .array.hack: Method tables are specially aligned so that 
normal object handles appear to have T_NORMAL_OBJECT as the type.

.map.tohandle: There doesn't appear to be any way to map from the object to the 
handle.  This could be problematic...

.object.header: Each object starts with a one-word (32-bit) header.  Here's an 
extract from share/javavm/include/gc.h:

 * ----------------------------------------------
 * | <--- length ---> | swapped | pinned | free |
 * ----------------------------------------------
 *  31              3          2        1      0

Or, if FAST_MONITOR is defined, a two-word header:

 * ----------------------------------------------
 * | <--- length ---> | swapped | pinned | free |
 * ----------------------------------------------
 *  31              3          2        1      0
 * -------------------------------------------------------------------
 * | heavy   | (struct execenv *ee) or (sys_mon_t *mid) |    zero    |
 * -------------------------------------------------------------------
 *         31 30                                       3   2   1   0

.object.header.bits: The bits in the header are used by gc.c only.  However, 
JNI needs an interface to find out if an object is pinned, and it's hard to see 
how that could be done effectively without a bit in the header.

.object.header.monitor: The two-word header supports fast locking, see 
win32/javavm/runtime/monitor_cache_md.c line 53 for details.

.handle.obj: The obj pointer in the handle points after the header.

