                  DESIGN OF THE MM/DYLANWORKS PROJECT
                              design.dylan
                             incomplete doc
                             drj 1996-10-07

INTRODUCTION

.readership: Intended to be read by any MM developer.

.intro: This document describes the high level design of the Dylan Memory 
Manager.  It describes on a broad scale how the components (of the MPS) go 
together to provide for Dylan's requirements.


REQUIREMENTS

.req: Dylan's requirements are documented in req.dylan.  Dylan is a dynamic 
object-oriented language and development system; most of the requirements are 
based around providing efficient GC.


MPS

.mps: The Dylan Memory Manager is a configuration of the MPS.

.native: Where convenient however, the Dylan runtime makes use of non-MPS 
memory management facilities.  The MPS is designed so that this should not be a 
problem.

.native.stack: In particular Dylan uses OS native threads and the threads use 
the OS native stack facilities.  The MPS does not interfere with this, but the 
stacks are typically registered as ambiguous roots.

.native.static: Objects statically built by the compiler are linked in the 
standard way in an executable's text, data, and other, segments.  The MPS does 
not interfere with this, but typically large areas of theses segments are 
registered as (precise) roots.

.native.alloc: Were it convenient it would be fine for Dylan to use malloc 
(from the Standard C library) or VirtualAlloc (from the Win32 interface) to 
obtain memory.  It is thought that Dylan do not currently do this.

.heap.format: Dylan objects that are allocated dynamically have a uniform 
container format described in design.dylan.container.
.heap.most: The bulk of (dynamically allocated) Dylan objects are allocated in 
an instance of Pool Class AMC.
.heap.leaf: Leaf objects (which in Dylan's case means objects whose class 
description precludes them from having references (to other objects) apart from 
the wrapper (see design.dylan.container)) are allocated in an instance of Pool 
Class AMCZ (they used to be allocated in Pool Class LO, but this was too 
inefficient).  This includes objects like strings (and buffers?).  Pool Class 
AMCZ takes advantage of the fact that the objects are leaf to optimise the 
management of them.
.heap.tables: Weak tables are allocated in an instance of Pool Class AWL.  This 
is because there are certain semantics associated with weak tables which the MM 
group chose to implement in a separate pool class.  This is likely to change in 
the future.  AWL is not particularly efficient and there may well be better 
ways to meet these requirements.

.root.stack: Native OS thread stacks are registered as ambiguous roots.
.root.data: (Some) Data segments in the process image are registered as precise 
roots.  Typically these roots are either a table of references, or a set of 
contiguous Dylan objects.
.root.teb: A block of miscellaneous data associated with each thread is 
registered as an ambigous root.


format.  aps. debugger.  finalization. low memory.  etc.

