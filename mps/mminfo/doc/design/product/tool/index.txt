                       DESIGN OF MM ANALYSIS TOOL
                          design.product.tool
                             incomplete doc
                       P T Withington 1997-04-23

INTRODUCTION

.scope: This document describes a design for a tool to analyze and tune memory 
behavior in order to optimize client programs of the MPS.  The tool is a 
component of the planned external product, intended to be used by more 
sophisticated users to maximize the benefit they receive from the product (see 
plan.product).

.readership: Readership: Any MM developer, analysis tool designers and 
implementors, analysis tool stakeholders.

.status: This document is an initial design based on a survey of internal 
clients (see analysis.task) and a prototype developed in CLIM.  This document 
will continue to evolve as we gain experience with the prototype and internal 
clients.

.source: This document is based on the following source documents:

 overview.mps.usage
 analysis.product
 analysis.task
 analysis.mps.events
 design.mps.io
 mail.richard.1996-08-23.13-30 "Information required from the 'model'"
 mail.richard.1996-09-27.16-44 "Modelling the MM state in the tools"
 mail.richard.1997-02-19.15-50 "Review: design.product.tool (Tool requirements)"


GOAL

.goal: A tool to support inspection and tuning of memory behavior


BACKGROUND

.background: The goal of the MM Product project is to create application memory 
management solutions for sale to programmers and OEM’s. The product will 
consist of a library of memory management code based on the MPS framework, a 
tool to gather, display, and analyze the data that can be gathered by the 
framework to aid in tuning the use of the framework, and associated 
documentation. For a full discussion, see analysis.product.

The MPS framework has significant flexibility which can be used to improve the 
performance of the client program. The analysis tool is the element in the 
measurement feedback loop that is used by the programmer to analyze the 
measurement data output by the MPS framework to determine possible changes in 
settings or the effect of changes in settings. For more information, see 
overview.mps.usage

This document describes the analysis tool.


REQUIREMENTS

This is a synopsis of the requirements as outlined in 
mail.richard.1997-02-19.15-50, which should become a separate document 
req.product.tool

.req.mps: work with the MPS
 mps.support: support MPS development

.req.platform: run on same platform used for program development and debugging 
[note this may or may not be the platform that the library runs on]
 .platform.client: client platform
 .platform.mps: MPS developer platform

.req.level: support intermediate or advanced level of use [not intended for 
trivial or basic use]

.req.feedback: support analysis and optimization of memory behavior of MPS 
clients

.req.dylan: integrate with Dylan development environment]


DESIGN

.design: The design of the analysis tool is object oriented. There are four 
primary classes of object that the user of the tool interacts with:
  - History -- a collection of measurement events
  - Filter -- a mechanism for choosing a subset of history events
  - Query -- an analysis of a history or subset
  - Plot -- a display of one or more queries

The analysis tool will have a graphical interface for the visual display of 
measurement information analyses. The user will be able to load multiple 
measurement sets, perform queries and analyses against these sets and display 
and explore the results. The graphical interface should make it easy to 
manipulate the model objects and relate those objects to the application being 
tuned.

The design of the analysis tool is given from the point of view that all 
possible measurement events are recorded during an application run, those 
events are subsequently parsed and loaded into the analysis tool, and filters 
are used to pick the subset of the data set that is of interest. Such a 
straightforward implementation might be possible if measurement recording 
overhead and the storage requirements for the analysis tool were not limiting 
factors. An actual implementation may have to consider how the data-reduction 
action of filters can be moved "upstream" ahead of the measurement event 
recording to reduce that overhead and the storage requirements.


History

.history: A history is a collection of MPS events (c.f., design.mps.io) that 
have been parsed by the analysis tool. The parsed history consists of both the 
raw events (which are used by queries and plots to connect back to the system 
being analyzed) and model objects, which represent reconstructions of key 
objects in the analyzed system.


Events

.events: The events of a history are as defined by design.mps.io. In general, 
events have a time stamp and a class. Each class of event may have further 
information, specific to that class. Many events also express a relationship -- 
parent-child, ownership, reference, etc.

The event processing mechanism must be flexible enough to easily allow the 
addition of new events.

Events include but are not limited to:
  - MM objects -- creation, destruction
  - Application objects -- creation, examination (scan), preservation ("fix"), 
destruction/reclaim
  - MM activity -- start, stop, state-change


Model Objects

.model: The model objects model the salient aspects of the objects in the 
application and memory manager under analysis as can be derived from the 
history events. Model objects include, but are not limited to:
  - Memory Manager
  - Space
  - Arena
  - Pool
  - Segment
  - Virtual Memory
  - Application Object
  - Application Annotation
  - Raw Event

Each model object has at a minimum an identifier that can uniquely identify it 
and a description that is easily recognizable by the user. The measurement 
interface allows application annotation of object creation so that model 
objects can be more easily related to application objects. For example, when a 
pool is created, the application may give the pool a string name, which will be 
emitted in the measurement history and is used in the model object identifier.

In addition each object has other attributes specific to its class. Note that 
because the model object represent a history, it is possible that there may be 
several incarnations of objects with similar or even identical attributes. For 
this reason, it is important that the object identification system be able to 
distinguish objects temporally.

.model.mm: Memory Manager: The memory manager object models an MM system for a 
particular history. Its identifier uniquely identifies the history it 
represents. Its other key attributes are the raw events from that history, and 
the Space object(s) that were created during the history.

.model.space: Space: The space object models an MM Space for a particular 
history. The MM Space represents the state of the entire MPS, it defines a 
client "session of use" with the MPS. In general, there is only one Space 
created per client program run. It is modeled because it is the top-level 
object that the client program interacts with.

Its identifier describes the space that it represents. Its other key attributes 
are the history it belongs to and the Arena object(s) and Virtual Memory that 
were created during the history.

.model.arena: Arena: The arena object models an MM Arena for a particular 
history. The MM Arena provides memory to all other parts of the MM in the form 
of segments. It is not an object that the client program interacts with 
directly, but it is modeled to reflect the global allocation of memory.

Its identifier describes the arena that it represents. Its other key attributes 
are the space it belongs to and the Segment objects that were created in it 
during the history. 

.model.pool: Pool: The pool object models an MM Pool for a particular history. 
MM Pools are the primary objects that the client program interacts with. The 
tunability of the MPS is primarily through the choice of particular pool 
classes and the appropriate use of those classes, thus the pool model object is 
the focus of many of the analyses that will be made.

Its identifier describes the class and pool that it represents. Its other key 
attributes are the space it belongs to and the Segment objects that were 
created for it during the history.

.model.seg: Segment: The segment object models an MM Segment (a range of 
memory) for a particular history. Segment objects are not directly visible to 
the client interface, but are modeled because they relate to the distribution 
of objects in memory.

Its identifier describes the segment that it represents. Its other key 
attributes are the pool that it belongs to.

.model.vm: Virtual Memory: The virtual memory object models the state of the 
application virtual memory system (as used by the MM) for a particular history.

Its identifier describes the virtual memory it represents. Its other key 
attributes are the space it belongs to and the pages that were created during 
the history.

.model.object: Application Object: The application object models an object as 
allocated by the application for a particular history. Its identifier describes 
the object it represents. Its other key attributes are the segment that it 
belongs to, its location, size, and (depending on the application annotation), 
type, creator, or other application-specific information.

.model.anno: Application Annotation: The application annotation object consists 
of a unique identifier and a string holding descriptive information. The 
application annotation object allows for general application annotations to be 
referenced more compactly by other events. These objects are not normally 
visible to the user.

.model.raw: Raw Event: The raw event object models the raw events that make up 
a particular history. Its identifier describes the type and time of the event. 
Its attributes are specific to the type of event.


Filter

.filter: The filters are a way of expressing a subset of the event history that 
is of interest. The general form of a filter is {<event-attribute> meets 
<criteria>}. A number of filters are built-in to the tool. It is desirable to 
have a simple filter language that allows custom filters to be easily built.

A filter takes as inputs a history and produces as output a subset of that 
history. The identity and description of the subset should reflect the history 
and filter it was derived from.

The built-in filters include but are not limited to:

  - Space -- objects and events associated with a particular space

  - Arena -- objects and events associated with a particular arena

  - Pool -- objects and events associated with a particular pool

  - Object attribute -- objects and events associated with a particular 
attribute
    These include: size, type, creator

  - Time -- object and event state at a particular time


Query

.query: A query is a computation on a history or filtered history that is used 
to produce a plot. Initially, the analysis tool should support 2-dimensional 
plotting of geometric shapes. The general form of a query is an arbitrary 
computation on a series of events yielding a series of coordinates or geometric 
shapes to plot. It is desirable to have a query language that allows custom 
queries to be easily built.

A query takes as inputs a history and produces as outputs an annotated plot 
sequence. [For introspection purposes, it is important that the results of the 
query be annotated with the events or model objects that each plot shape 
represents.] An annotated plot sequence is a sequence of geometric shapes given 
in terms of their shape class and coordinates and annotated with the event(s) 
they represent or are derived from.

The built-in queries include but are not limited to:

  - Total - A set of points <total of some attribute> vs. <time>
    variants include:
    o Total Space
    o Total Type
    o Total Creator

  - Distribution -- A set of points <value of some attribute> vs. <number>
    variants include:
    o Size Distribution
    o Type Distribution
    o Creator Distribution

  - Event -- A set of quadruples <attribute, time, attribute, time>
    variants include:
    o Lifetime -- <location, create time, location + size, delete time>
    o Data graph -- <source, create time, destination, delete time>


Plot

.plot: The plot is the visual display that the user interacts with. The plot is 
a plotting of the plot sequence generated by the query. There may be more than 
one query represented by a plot. The plot should have the ability to color-code 
and display reference axes. The plot should support zooming and scrolling. The 
plot should support "drilling" -- there should be an inspection tool that lets 
the user drill down through a plot to discover the data and events behind a 
particular graphic feature.

The built-in plots include but are not limited to:
  - Polygon -- connect the dots
  - Line -- i.e., a bar chart
  - "Piano Roll" -- rectangles plot quadruples
  - Movie -- a plot with a time scroll that displays changes over time (and 
permits forward and backward scrolling)


USER INTERFACE

.ui: Further study is required to create the best design for a graphical user 
interface.
As an initial draft, it is proposed that the interface provide a way to 
graphically:
  - browse the data sets as represented by histories and the model objects they 
comprise
  - apply a filter to a data set
  - apply a query to a data set or filtered data set
  - plot one or more queries
  - manipulate a plot — zoom, scroll, add axes, colors, etc.
  - investigate a plot — discover the data behind interesting features of the 
plot

Plot manipulation may be difficult with large or complex data sets. The user 
interface should support an “outlining” mode where plot data is summarized 
rather than graphically displayed to allow it to be more easily directly 
manipulated.

The user interface should support creating "test jigs" whereby a particular 
plot of queries and filters can be re-applied to new data sets. The user 
interface should support comparing of such plots in a way that differences are 
easily discovered.

