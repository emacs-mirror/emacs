                    THE DESIGN OF THE MPS USER GUIDE
                     design.product.doc.user-guide
                             incomplete doc
                             lmb 1997-10-28

NOTES

*  likely to require code examples

The guide should at each point emphasize the relevant product advantages.  It 
should clearly state the goals and benefits of each feature it discusses.


OUTLINE

   Title page
   Copyright page
   Table of contents

   Preface
      Audience (if necessary; incl. assumptions)
      Scope/Organization of manual (if necessary)
      Documentation conventions

   Ch. 1:  Introduction
              About the MPS
              The advantages of the MPS (and other advocacy)
                 High-integrity performance tool
                 USPs (how much can we include from analysis.product.sol.*?)
                    Choice of policy
                    Different combinations of policies, some w/GC
                    ROI/levels of use
                    Flexibility
                    Reliability/integrity
                    Portability
                    Efficiency
                    Tools
                    Adaptive system
                 ROI
                 Compatibility with other software
                    Purify
              Interface conventions (see doc.mps.ref-man.if-conv)
                 Symbol and header file names: mps* or MPS*
                 Macros and functions
                 Types
              Pointer to Ch. 2 (for eager users)
              Using this manual (by customer type, using standard notation and 
process charts)
                 Evaluator
                 OEM and Development Mgr
                 Developer
                 Testing Engineer
                 Systems Integrator
              The documentation set (ditto)
              Legal information
              Notes on licensing
              System requirements
              Notes on installation
              Contacting technical support

Section I: Using the MPS

   Ch. 2:  The First Day
              Overview
              Description of common problems
              Dropping the MPS into your code (source code included) *?
              Identifying problems using interface checking and assertions *?
              Fixing problems *? (improved performance, reduced fragmentation)
              ?Using the GMAT to check the fix?
              Using the Allocation Analyzer
                "Good" analysis
              ?Size class analysis?
              Some brief examples *?
              Summary of main points

   Ch. 3:  The First Two Weeks
              Overview
              Description of common problems
              Using the (or writing your own?) convenience interface (with 
source code) *
              The MPS interface *
                 (introduce the plinth interface briefly; XREF to app.)
              Choosing pool classes
                 (introduce GC)
              Using pools *
              Editing your own code
              Some brief examples *
              Summary of main points

   Ch. 4:  The First Month
              Overview
              Description of common problems
              Using the GMAT (with XREF to tool reference)
                 Providing views of and statistics for allocated space
                    Interpreting the results
                 Finding problem spots with the Memory Profiler
                    Interpreting the results
              Using protocols *
              Some brief examples *
              More about the MPS interface (making choices about how to use it) 
*
              Choosing pool classes in combination
              Summary of main points

   Ch. 5:  Long-term Use
              Overview
              Description of common problems
              Using the tool to tune the MPS (examining measurements)
              Even more about the MPS interface *
              Some brief examples *
              Summary of main points

   Ch. 6:  Beyond the MPS (HQN consulting)
              Tuning services
              Custom solutions

   Ch. 7:  Extended Examples

Section II: Protocols and Pools (most chapters will require one or more code 
examples)

   Ch. N:  Allocation Points
              Alloc
              Two-phase allocation protocol
                 When "commit" must fail
                 Environments and conditions under which to use the five 
options 
                    (write own code in C, write own code in assembler, etc.)
                    including figures
                 Group allocations
              Alignments and allocation points
   
Ch. N:  Formats
           Relation to allocation points
           Restrictions on format code
           How to write your own formats

   Ch. N:  Roots

   Ch. N:  Location Dependencies

   Ch. N:  Thread Registration

   etc.

   Ch. N:  Combining Protocols Sensibly

   Ch. N:  Pools and Pool Classes
              Attributes of pools

   Ch. N:  Using Protocols and Pool Classes in Combination

Section III: Debugging and Troubleshooting

   Ch. N:  Debugging When Using the MPM (with scripts?)
              pass/ignore SIGSEGV
              pass/ignore SIGFPE (if FPE -> conditions)

   Ch. N:  Troubleshooting? (split by levels of use; assertion, ID, ptr)
   
etc.

Appendixes

   App. A:  Platform Issues
                 In typical use, the product will not require reconfiguring or 
rebuilding operating-system kernels.
   App. B:  The Plinth Interface
   App. N:  The Assertion Database
   App. N:  For More Information
                 (references to books and papers, incl. the MM Reference)

   Glossary
   Bibliography
   Index

----------------------------------------------------------------

OTHER STUFF THAT NEEDS TO GO IN SOMEWHERE

defining an object format (symbol.mps.c.mps_align_t)
pool options (symbol.mps.c.mps_align_t)
allocation options (symbol.mps.c.mps_align_t)
scanning and updating of pointers (symbol.mps.c.mps_fix)
roots -- handling and debugging (meeting.doc.1997-03-06.notes)
GC safety (meeting.doc.1997-03-06.agenda.6)
varieties 
   optimized, asserted, metered, debugging, etc. (analysis.product.prod.sw.lib)
   full checking, partial checking <which group?> 
(meeting.doc.1997-03-11.user-prof.te.var)
   how to use to find problems (relink, run tests) 
(meeting.doc.1997-03-11.user-prof.te.var)
glue layers for compatibility with various language systems 
(analysis.product.prod.sw.lib)
trampoline (meeting.doc.1997-03-12.tramp.term)
reserved symbols (meeting.doc.1997-03-06.prod-def.if.doc.details)
binary/src/version compatibility 
(meeting.doc.1997-03-06.prod-def.if.doc.details)
modes of use (meeting.doc.1997-03-07.doc.modes-of-use, 
meeting.doc.1997-03-12.MPS.modes)
memory barriers and APs on the DEC Alpha (meeting.doc.1997-03-10)
information for controlling usage 
(meeting.doc.1997-03-11.user-prof.dev-man.control)
   avoiding abuse and sub-allocators
   guidelines for MPS usage and how to write them
   gathering and monitoring performance logs
   using performance logs for testing
integration of existing libraries, how to ("tolerant MM"?) 
(meeting.doc.1997-03-11.user-prof.sys-int.libs.tol)
uniform general integration policy (simplified by GC) 
(meeting.doc.1997-03-11.user-prof.sys-int.comp.policy)
may need OEM resale info (badging arrangements, acks, ptrs to Web site, splash 
screen materials)
   (meeting.doc.1997-03-11.user-prof.app-user.req.poss)
documentation for end/app users describing memory problems 
   (meeting.doc.1997-03-11.user-prof.app-user.req.def)
reports (meeting.doc.1997-03-11.user-prof.te.report.*, .fix.*)
   information to be included in reports
      assertion ID, message ID, information regarding faults, helpful
      information for developers, backtrace
   how to create diagnosis from reports
   suggested cures
specific instructions on how to change from malloc to MPS 
(meeting.doc.1997-03-11.user-prof.dev.adapt.malloc)
how to solve design and programming problems using the MPS
   (meeting.doc.1997-03-11.user-prof.dev.dev.prob)
design pattern doc, perhaps? (meeting.doc.1997-03-11.user-prof.dev.dev.prob)
optimization techniques (L3/4) (meeting.doc.1997-03-11.user-prof.dev.opt.*)
   how to measure current attributes using standard and MM tools
   examples of how to analyze and decide on a change
   examples of how to make the change
list of typical problems when adapting, creating, and optimizing 
   (meeting.doc.1997-03-11.user-prof.dev.debug.prob)
description of data structures (aka internal logs) 
(meeting.doc.1997-03-11.user-prof.dev.debug.struct)
information on log dumper (meeting.doc.1997-03-11.user-prof.product.req.new)
connection between never failing and having no result code 
(mail.gavinm.1997-05-28.??)


INTERNAL CUSTOMER REQUIREMENTS (from meeting.doc.1997-03-11.user-prof
   and analysis.task.2-3: Past Experience of Memory Problems)

performance info
risk assessment
own allocation sequences for invoking mps
profiling information (attribute control) from runtime system
info on possible facilities (e.g., saying when to GC)
typical problems
   fragmentation
   paging
   benchmarking/locking down memory
   memory-hungry compilers/pig-in-the-python
   why an application allocates as much as it does (frequency, size)
   routines for "free" and "new" too large
   premature death
   finding when a particular piece of memory had a specific value
      assigned to it
   inefficiencies in algorithms or implementations


TOOL TASKS (from design.product.tool and design.product.arch.soft.gmat)

how the tool works (?)
collecting data
loading data
browsing data
filtering data
   filter language?
querying data
   query language?
   types of query
      total
      distribution
      event
plotting results
   drilling
   types of plots
      polygon
      line
      piano roll
      movie   
   outlining mode
   creating "test jigs" (templates)
analyzing results
(decoding?  exporting?  storing?)


ADVOCACY AND OTHER CH. 1 STUFF (from meeting.doc.1997-03-11.user-prof)

fast track through evaluation for press
competitive analysis
   data as per SmartHeap
information on integration effort and time
information on reliability
smooth installation
little hassle in adaptation
easy maintenance
business-like analysis of effort, time, costs, and benefits
   list of advantages; see also m.d.97-03-11.u-p.sys-int.effort
      few bugs and leaks  (mgr)
      faster development  (mgr)
      better performance  (mgr)
      less support        (oem)
      less rework         (oem)
      higher productivity (oem)
how to train staff (high level); materials for doing so
materials for getting buy-in
evaluation period and risk-free trial deployment
   define goals.
   introduce a new layer, which is very cheap.
   compare and analyze against goals [compare what?]. 
   deploy.
   dissolve layer.


RECOMMENDATIONS SECTION

Punning: "You can do it, but be aware that you're taking a risk."
(from meeting.doc.1997-05-28.io.pun)

