                 THE DESIGN OF THE BOYER JAVA BENCHMARK
                      design.java-benchmark.boyer
                           incomplete design
                             lth 1998-07-21

INTRODUCTION

.intro: This document describes the Boyer benchmark and its use in the Java 
benchmark suite.  It is less a design document than an analysis and writeup, 
since the Boyer benchmark already exists and I just translated it.

.readership: MM group members.

.source: analysis.java-benchmark(1), design.java-benchmark.arch(1).


OVERVIEW

.overview: The Boyer benchmark was written by R Boyer and J Moore and was 
published by Richard Gabriel in his book (book.gabriel85).  The program is a 
simple theorem prover; Boyer and Moore used it as a theorem-proving benchmark 
but everyone else uses it as a garbage-collection benchmark.  The program 
published by Gabriel had some bugs, which were subsequently found by Henry 
Baker (@@@ reference to Lisp Pointers article).  In addition, even though the 
program was a difficult test for garbage collectors in 1985, it is not 
difficult for modern collectors.  Boyer has suggested adding a scaling 
parameter to the program to make it more difficult (@@@ reference??).

.bench.boyer.characteristics:  Memory use in Boyer are characterized in some 
detail in .pap.ch97.  Briefly, nboyer creates an irregularly growing data 
structure; sboyer creates an essentially strictly growing data structure.  The 
Boyer benchmark has an applicative flavor and may not be typical of Java 
programs; however, it does exercise the garbage collector, and may also be 
somewhat typical of the kinds of challenges a JVM is presented with when an 
applicative language is compiled to the JVM.  
.bench.boyer.desc: Each program is run with the scaling parameter taking on 
values from 0 through a user-specifiable maximum, for a user-specifiable number 
of iterations. 

.bench.boyer.analysis: The iterated boyer gives us ramped allocation patterns.  
(If the property lists are not mutated, they can stick around and provide some 
of that really old data!)

Every 1000 rewrites perform roughly the same amount of work.  Therefore, by 
recording the times for 1000 rewrites and looking at the distributions of 
these, we get a sense of GC pause times.

