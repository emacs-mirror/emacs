               "JACKDAW" VERSION OF DYLAN MEMORY MANAGER
                         version.dylan.jackdaw
                             incomplete doc
                           gavinm 1998-10-26

INTRODUCTION

.purpose: Provide stack pools and collection statistics.


RELEASES

.rel: The following releases have been made:
  release.dylan.jackdaw: Initial relase to QA
  release.dylan.jackdaw.1: Bug fix


RELEASE NOTES

.relnotes: This is an intelligent concatenation of the release notes of the 
actual release, prepared for forwarding to Dylan.

Version 2.3 of the Dylan Memory Manager (internally known as 
release.dylan.jackdaw.1) is now available for use by Dylan.  It is located in:
  \\bohm\MMdist\Dylan\release.dylan.2.3

Note that the PC used for distribution is changing from mnemosyne to bohm with 
this release.  All previous releases are now available on bohm.  Note that the 
folder formerly known as "Dylan Memory Manager" has been renamed "Dylan".  
Previous distributions are still available on mnemosyne, but this may be 
withdrawn in future without further warning.

This release is intended to provide new functionality for stack like allocation 
and destruction and to allow for gathering certain data regarding garbage 
collections.  

This release will again be VC5.0 only, which should not affect ordinary Dylan 
developers (as previously discussed).

Main features are:
  New result code: MPS_RES_PARAM
  New message type: Collection statistics
  New pool class: Stack Pool
  New allocation point protocol: Frames
  New allocation pattern: Ramp collect all
  New plinth functions: memcmp and memset
  Some bug fixes
  Revised debugger symbol list


New Result Code

There is new result code (a value in the type mps_res_t): MPS_RES_PARAM.  It is 
used to indicate that an operation failed because an invalid parameter was 
specified for the operation.  See symbol.mps.c.MPS_RES_PARAM(0) for details.  
In fact it is not expected currently that any function used by Dylan will 
return this error code, though in future it may well be returned.


New Message Type: Collection Statistics

A new message type for collection statistics is now available.  Details of its 
use are given in the following symbol documentation:
  symbol.mps.c.mps_message_type_gc(0)
  symbol.mps.c.mps_message_gc_condemned_size(0)
  symbol.mps.c.mps_message_gc_live_size(0) 
  symbol.mps.c.mps_message_gc_not_condemned_size(0) 


New Pool Class: Stack Pool

There is a new stack pool class: Stack No Check.

See symbol.mps.c.mps_class_snc(0) for details of the pool class, and 
guide.mps.stack-alloc(0) for a guide to usage.


New Allocation Point Protocol

There is a new stack discipline protocol associated with allocation points (to 
be used in conjuction with the Stack No Check pool class for stack like 
allocation).  See protocol.mps.alloc-point(0) (protocol.mps.alloc-point.stack 
in particular) for details of the protocol.  symbol.mps.c.mps_ap_frame_pop(0), 
symbol.mps.c.mps_ap_frame_push(0) for the associated functions.

In particular, the following pool classes support the frame protocol:
  symbol.mps.c.mps_class_snc(0)  
  symbol.mps.c.mps_class_amc(0)


New Allocation Pattern

There is a new allocation pattern type, like ramp allocation, but indicating 
the a full GC should be performed after the allocation pattern has ended.  See 
symbol.mps.c.mps_alloc_pattern_ramp_collect_all(0) for details.


New Plinth Functions

Unfortunately we have added two functions to the plinth: mps_lib_memcmp and 
mps_lib_memset.  These two functions should be implemented by the client in 
their plinth module.  The functions shoud behave as their ISO C counterparts 
memcmp and memset.  mps_lib_memcmp is documented in symbol.mps.c.mps_lib_memcmp
(0).  mps_lib_memset is documented in symbol.mps.c.mps_lib_memset(0).  These 
functions are only called by the MPS in Cool varieties (variety.ci).


Some bug fixes

In particular an incorrect MPS assertion firing when the dylan program attempts 
to access locations -1 to -4 has been suppressed.  This has come up recently in 
connexion with Dylan Bug #4184.


Debugger Symbol List

For the use of the debugger here is the list of functions that can be on the 
stack when the MPS may have a lock claimed (this has changed since the last 
publication of this list):
ArenaAccess
ArenaCreateV
ArenaDestroy
mps_alloc_v
mps_amc_apply
mps_ap_alloc_pattern_begin
mps_ap_alloc_pattern_end
mps_ap_alloc_pattern_reset
mps_ap_create
mps_ap_create_v
mps_ap_destroy
mps_ap_fill
mps_ap_fill_with_reservoir_permit
mps_ap_frame_pop
mps_ap_frame_push
mps_ap_trip
mps_arena_clamp
mps_arena_collect
mps_arena_commit_limit
mps_arena_commit_limit_set
mps_arena_committed
mps_arena_create_v
mps_arena_destroy
mps_arena_extend
mps_arena_formatted_objects_walk
mps_arena_park
mps_arena_release
mps_arena_reserved
mps_arena_roots_walk
mps_finalize
mps_fmt_create_A
mps_fmt_create_B
mps_fmt_destroy
mps_free
mps_ld_reset
mps_message_collection_stats_condemned_size
mps_message_collection_stats_live_size
mps_message_collection_stats_not_condemned_size
mps_message_discard
mps_message_finalization_ref
mps_message_gc_condemned_size
mps_message_gc_live_size
mps_message_gc_not_condemned_size
mps_message_get
mps_message_poll
mps_message_queue_type
mps_message_type
mps_message_type_enable
mps_pool_check_fenceposts
mps_pool_create_v
mps_pool_destroy
mps_reservoir_available
mps_reservoir_limit
------------------------------------------------------------------------
symbol.mps.c.MPS_RES_PARAM(0)  draft symbol

MPS C INTERFACE SYMBOL "MPS_RES_PARAM"
ptw, 1998-10-08


NAME

MPS_RES_PARAM


SUMMARY

"MPS_RES_PARAM" is a result code, indicating that an operation failed because 
an invalid parameter was specified for the operation.


ASSOCIATED PROTOCOLS

All.


TYPE

mps_res_t


RESOURCES

mps.h.


DESCRIPTION

This result code is returned if an operation could not be completed as 
requested because an invalid parameter was specified for the operation.  The 
precise meaning depends on the function that returned the code.  Refer to the 
documentation of that function for details.


EXAMPLE

switch(res = mps_pool_create_v(&pool, arena, class, params)) {
  case MPS_RES_PARAM: {
    bomb("Can't make a pool with those specifications");
  } break;
  ...
}


SEE ALSO

symbol.mps.c.mps_res_t
------------------------------------------------------------------------
symbol.mps.c.mps_message_type_gc(0)  incomplete symbol

DESCRIPTION OF THE MPS C INTERFACE SYMBOL "MPS_MESSAGE_TYPE_GC
gavinm, 1998-10-20


NAME

mps_message_type_gc


SUMMARY

"mps_message_type_gc" returns the type of garbage collection statistic messages.


ASSOCIATED PROTOCOLS

Message, gc.


SYNTAX

mps_message_type_t mps_message_type_gc()


RETURNED VALUES

The type of garbage collection statistic messages.


DESCRIPTION

"mps_message_type_gc" returns the type of garbage collection statistic 
messages.  Garbage collection statistic messages are used by the MPS to give 
the client information about garbage collections that have occurred.  Such 
information may be useful in analysing the client's memory usage over time.

The access methods specific to a message of this type are:

  mps_message_gc_live_size -- gives the total size of the condemned objects 
that survived the collection that generated the message

  mps_message_gc_condemned_size -- gives an approximate size for the set of 
objects condemned in the collection that generated the message.

  mps_message_gc_not_condemned_size -- gives an approximate size for the set of 
objects that were in collected pools, but were not condemned in the collection 
that generated the message.


EXAMPLE

{
  mps_message_t message;

  if(mps_message_get(&message, arena, mps_message_type_gc())) {
    size_t live, condemned, not_condemned;

    live = mps_message_gc_live_size(message);
    condemned = mps_message_gc_condemned_size(message);
    not_condemned = mps_message_gc_not_condemned_size(message);

    mps_message_discard(arena, message);

    process_collection_stats(live, condemned, not_condemned);
  }
}


ERROR HANDLING

Cannot fail.


SEE ALSO

mps_message_*, 

"Message Protocol", "GC Protocol"
------------------------------------------------------------------------
symbol.mps.c.mps_message_gc_condemned_size(0)  incomplete symbol

DESCRIPTION OF THE MPS C INTERFACE SYMBOL "MPS_MESSAGE_GC_CONDEMNED_SIZE"
gavinm, 1998-10-20


NAME

mps_message_gc_condemned_size


SUMMARY

"mps_message_gc_condemned_size" returns the "condemned size" property of the 
specified message in the specified arena.


ASSOCIATED PROTOCOLS

Message, GC.


SYNTAX

size_t mps_message_gc_condemned_size(mps_message_t message)


ARGUMENTS

message -- a message of a message type that supports this method


RETURNED VALUES

An approximate size for the set of objects condemned in the collection that 
generated the message.


DESCRIPTION

Currently, the only type of message that supports this property is 
mps_message_type_gc, such messages are generated whenever a garbage collection 
completes.  This method returns an approximation to the size of the set of 
objects that were condemned in that collection.


SEE ALSO

mps_message_*
------------------------------------------------------------------------
symbol.mps.c.mps_message_gc_live_size(0)  incomplete symbol

DESCRIPTION OF THE MPS C INTERFACE SYMBOL "MPS_MESSAGE_GC_LIVE_SIZE"
gavinm, 1998-10-20


NAME

mps_message_gc_live_size


SUMMARY

"mps_message_gc_live_size" returns the "live size" property of the specified 
message in the specified arena.


ASSOCIATED PROTOCOLS

Message, GC.


SYNTAX

size_t mps_message_gc_live_size(mps_message_t message)


ARGUMENTS

message -- a message of a message type that supports this method


RETURNED VALUES

The total size of the condemned objects that survived the collection that 
generated the message.


DESCRIPTION

Currently, the only type of message that supports this property is 
mps_message_type_gc, such messages are generated whenever a garbage collection 
completes.  This method returns the size of the set of objects that were 
condemned in that collection, but survived.


SEE ALSO

mps_message_*
------------------------------------------------------------------------
symbol.mps.c.mps_message_gc_not_condemned_size(0)  incomplete symbol

DESCRIPTION OF THE MPS C INTERFACE SYMBOL "MPS_MESSAGE_GC_NOT_CONDEMNED_SIZE"
gavinm, 1998-10-20


NAME

mps_message_gc_not_condemned_size


SUMMARY

"mps_message_gc_not_condemned_size" returns the "not condemned size" property 
of the specified message in the specified arena.


ASSOCIATED PROTOCOLS

Message, GC.


SYNTAX

size_t mps_message_gc_not_condemned_size(mps_message_t message)


ARGUMENTS

message -- a message of a message type that supports this method


RETURNED VALUES

An approximate size for the set of objects that were in collected pools, but 
were not condemned in the collection that generated the message.


DESCRIPTION

Currently, the only type of message that supports this property is 
mps_message_type_gc; such messages are generated whenever a garbage collection 
completes.  This method returns an approximation to the size of the set of 
objects that were in collected pools (so potentially subject to garbage 
collection), but were not condemned in that collection.


SEE ALSO

mps_message_*
------------------------------------------------------------------------
symbol.mps.c.mps_class_snc(0)  incomplete symbol

MPS C INTERFACE: MPS_CLASS_SNC
drj, 1998-10-16


NAME

mps_class_snc


SUMMARY

Returns the pool class object (of type mps_class_t) for the Stack No Check Pool 
Class.


ASSOCIATED PROTOCOLS

Pool Creation


SYNTAX

mps_class_t mps_class_snc(void)


ARGUMENTS

No arguments.


RETURNED VALUES

As summary; returns a pool class object.


RESOURCES

This symbol is declared in the header file mpscsnc.h [impl.h.mpscsnc].  That 
header file must be included before making any reference to this symbol.


DESCRIPTION

This function returns an object of type mps_class_t which represents the Stack 
No Check Pool Class.

This pool class requires an extra argument when used in mps_pool_create:

res = mps_pool_create(&pool, arena, mps_class_snc(), format);

The extra argument, format, should be of type mps_fmt_t and specifies the 
format of the objects allocated in the pool (in a similar way to 
mps_class_amc).  The format should provide at least the methods: scan, skip, 
pad.

An SNC pool is scannable, in that objects may contain references to objects in 
other pools that will keep those objects alive (depending on rank).  In this 
sense, an SNC pool is a de facto root.

Exact references may point to (the start of) objects in an SNC pool, but will 
have no effect on whether those objects are either scanned or kept alive.

If mps_ap_frame_pop is used on an allocation point in an SNC pool (after a 
corresponding call to mps_ap_frame_push), then the objects affected by the pop 
are effectively declared dead, and may be reclaimed by the collector.  Extant 
references to such objects from reachable or de facto alive objects are safe, 
but such other objects should be dead; that is, such references must never be 
used.

If an allocation point is created in an SNC pool, then the call to 
mps_ap_create will take as an additional parameter the rank (of type 
mps_rank_t) of references in the objects to be created in that allocation 
point.  Currently, only rank exact (mps_rank_exact()) is supported.

Objects in an SNC pool may not be registered for finalization.

Objects in an SNC pool will not move.


ERROR HANDLING

Cannot fail.


SEE ALSO

symbol.mps.c.mps_class_amc
symbol.mps.c.mps_ap_frame_pop(0)
symbol.mps.c.mps_ap_frame_push(0) 
symbol.mps.c.mps_ap_create
------------------------------------------------------------------------
guide.mps.stack-alloc(0)  incomplete doc

STACK ALLOCATION USING THE MPS
drj, 1998-10-23


INTRODUCTION

.intro: This document describes how to perform stack allocation using the MPS 
and what the options are.

.readership: Readership: Any MPS user.


TERMINOLOGY

.def.stack-allocation: "Stack allocation" is a memory management technique 
whereby objects are (or sometimes, can be) managed using a stack.


OVERVIEW

.overview: The MPS provides a means by which clients can declare that objects 
can be efficiently managed using stack-allocation (the stack protocol on APs, 
see protocol.mps.alloc-point.stack); the MPS also provides policies (pool 
classes) which when used with such declarations will manage objects as 
efficiently (or very nearly so) as stack allocation; the MPS also provides 
policies which honour the declarations but do not take advantage of them to 
manage the objects any more efficiently.  The MPS does not preclude the client 
from using the usual control or thread stacks for stack allocating objects.

.options: So if the client wishes to use stack allocation they have three 
options:

.option.client: Clients can stack allocate objects themselves, perhaps using 
the control stack.
.option.mps.fit: Clients can specify that the objects be managed using a pool 
which is designed to be used for efficient stack allocation.
.option.mps.nofit: Clients can specify that the objects be managed using a pool 
which is not designed to be used for efficient stack allocation.

.option.mps.notfit.why: The reasons for providing pool classes which are not 
designed to be used for efficient stack allocation are:
.option.mps.notfit.why.debug: We can provide pool classes which debug the 
client's use of the protocol to ensure that the client isn't cheating and help 
them find out how if they are.
.option.mps.notfit.why.interchange: The interchangeability of pool classes is 
increased.  The client can mix and match pool classes to see which gives the 
best overall performance or use a substitute pool class to work around problems 
in another.


STACK ALLOCATION

.broad: Clients wanting to use the MPS for stack allocation will need to do the 
following:

- Select a pool class to use.
- instantiate a pool, APs, object formats, and so on.
- allocate objects in the pool according to the stack protocol (see 
protocol.mps.alloc-point.stack).

.select.issues: The issues involved in selecting the pool are:
- can the allocation point stack protocol be used with the class?
- are the objects managed efficiently.

Currently (1998-10-23) all pool classes which provided allocation via 
allocation points understand the allocation point stack protocol.  However only 
Pool Class SNC will manage objects allocated using the stack protocol in a 
particuarly efficient way; the other pool classes essentially ignore the stack 
protocol - it will not affect they way they manage objects.


EXAMPLE

Using Pool Class SNC would be something like this:

/* Having create an arena, threads, roots, etc. */
/* Instantiate a pool and an AP. */
res = dylan_fmt(&format, arena);
if(res != MPS_RES_OK) abort();
res = mps_pool_create(&pool, arena, mps_class_snc(), format); /* Note 
mps_class_snc takes one extra argument which is a format */
if(res != MPS_RES_OK) abort();
res = mps_ap_create(&ap, pool, mps_rank_exact());
if(res != MPS_RES_OK) abort();
/* ... */

/* calls f in a stack frame so that all f's allocation (in the supplied ap) can 
be freed */
/* when it returns */
mps_res_t with_stack_extent(mps_ap_t ap, (void *f)(mps_ap_t, void *), void *c)
{
  mps_frame_t frame;

  res = mps_ap_frame_push(&frame, ap);
  if(res != MPS_RES_OK) return res;
  f(ap, c);
  res = mps_ap_frame_pop(ap, frame);
  if(res != MPS_RES_OK) return res;
  return MPS_RES_OK;
}
------------------------------------------------------------------------
protocol.mps.alloc-point(0)  incomplete doc

DESCRIPTION OF MPS ALLOCATION POINT PROTOCOL
drj; lmb, 1997-06-10


INTRODUCTION

.intro:  This document describes the protocols which can be used in conjuction 
with MPS allocation points.  Currently there are three protocols: 
reserve/commit allocation, stack discipline, allocation patterns.  
Reserve/commit allocation is intended to be used for fast (in particular lock 
free) allocation of formatted objects.  Stack discipline is intended to be used 
both for the fast freeing of object sets which obey a stack-like discipline and 
for declaring object sets to be mostly dead.  Allocation patterns can be used 
to declare particular idoms of object creation and destruction.  They aren't 
described in this document, but should be.  The "ramp" allocation pattern 
(which is a particular pattern) is described in 
protocol.mps.alloc-pattern-ramp(0).


DEFINITIONS

.def.ap: AP.  An abbreviation for Allocation Point.


TYPE

.type: Allocation points are not abstract data types.  There are some opaque 
aspects and some transparent aspects.  Client programs can know the structure 
and directly modify fields, but must obey certain protocols.

.type.structure: Allocation points have a structure of five words -- abstractly 
referred to as Init, Alloc, Limit, FramePointer, Enabled.

.type.structure.protocol: Not all the fields are used by all of the protocols.


CREATING AND DESTROYING

.create: An allocation point is created using mps_ap_create or 
mps_ap_create_v.  mps_ap_create takes a variable number of arguments; 
mps_ap_create_v is just the same as mps_ap_create except with the extra 
arguments passed as a single va_list argument.  The extra arguments are 
interpreted by the pool in a pool class dependent way.

.destroy: An allocation point is destroyed with mps_ap_destroy.  You cannot 
destroy an allocation point that is between reserve and commit.  Note that 
before you destroy a pool (mps_pool_destroy), you should destroy all allocation 
points in it.


USING ALLOCATION POINTS

.use: You have five choices about how to use allocation points:

.use.own.c: Write your own allocation point code in C 

.use.own.as: Write your own allocation point code in assembler 

.use.mps.fn: Use our functions 

.use.mps.macro: Use our macros 

.use.mps.macro-block: Use our block macros


ALLOCATION

.alloc: APs are primarily used to allocate objects:

.alloc.kind: There are four kinds of allocation (not all of these are carefully 
thought out or implemented):

.alloc.reserve-commit-loop: Two-phase allocations with loop

.alloc.reserve-commit-linear: Two-phase allocations that are always successful

.alloc.one-phase: One-phase allocations -- Reserve and Commit are done at the 
same time (see below).

.alloc.promise: Promises -- you can ask for a certain amount of memory.  This 
type of allocation only deals with Limit (see below). 

.alloc.class-dependent: The pool classes you are using determine which 
allocation protocols you can use; some pool classes require certain allocation 
protocols.

.alloc.speed: In general allocation using APs is intended to be fast.  This is 
achieved by:

.alloc.lock-free: By avoiding locking synchronization.

.alloc.inline: By avoiding function calls.



RESERVE/COMMIT

.reserve-commit: This part of the document describes the reserve/commit 
protocol.


Pseudo-code

.reserve-commit.pseudo-code: The pseudo-code for a reserve/commit sequence on 
an allocation point is as follows:

  do { 
    res = mps_reserve(&p, ap, size);
    if(res != RES_OK) {
      do something;
    }
    else init(p);
  } while (!mps_commit (ap, p, size));


.reserve-commit.reserve: If mps_reserve fails, the client program doesn't get 
the memory it needs.  If it succeeds, the memory is allocated in a block whose 
address is "p".

.reserve-commit.client-init: "init" is code that you write.  The memory has to 
be filled in with a correctly formatted object (the interpretation of 
"correctly formatted" will depend on the pool class used).

.reserve-commit.commit: After initialization, you can do the commit.  The pool 
needs to know that the object has been initialized, and the commit informs the 
pool that the object is ready.  If the commit fails, which should be rare (some 
pool classes may be able to guarantee that it never happens), the memory is not 
allocated and you have to start from scratch.  The code returns TRUE if okay, 
FALSE if it fails.


Pool Class Dependencies

.reserve-commit.pool-class.format: The initialization phase of reserve/commit 
depends on the format of the object being allocated.  Some pool classes may not 
be formatted (perhaps the objects have no references or are scanned 
ambiguously).  In this case the reserve and the commit can be done at the same 
time.

.reserve-commit.pool-class.commit: Some pool classes occasionally need to have 
the commit fail; other pool classes may be able to guarantee that commit will 
never fail.


Implementation Details

.reserve-commit.details: A chunk of memory is passed to the client application, 
which can allocate it using the protocol.

Doing a reserve increments Alloc (but not past Limit).

.reserve-commit.reserve.code: Reserve:

  T = Alloc + size;
  if(T > Limit || T <= Alloc)           /* overflow check */ 
    res = mps_ap_fill(&p, ap, size)     /* ask MM to give you a */
                                        /* bigger chunk of memory */ 
  else {
    Alloc = T;
    P = Init;
    res = OK;
  }

Then the client initializes the memory, then commits it:

.reserve-commit.commit.code: Commit:

  Alloc = Init;
  if(Limit = 0)
    b = mps_ap_trip(ap, &p, size)   /* calls MM */ 
  else b = TRUE   /* b = boolean result */

.reserve-commit.check.limit: The MPS can poke Limit to 0 whenever necessary in 
order to regain control, so the commit code has to check that the MPS has not 
done this between the reserve phase and the commit phase. Whenever the MM is 
invoked, it can do whatever it needs to, so the client cannot assume that the 
values of any of the AP's fields will stay the same.

Outside of invoking the MM, Alloc and Init will not change unless the client 
application changes them.  However, Limit can change at any point.  The client 
application is not allowed to change Limit; it can change Alloc and Init as 
long as it follows the protocol.

.reserve-commit.atomic: The updates (writes) and reads of Alloc and Init have 
to be atomic with respect to threads.  This means that the client application 
must read the whole field at once (one instruction in machine code).


Macros and Functions

.reserve-commit.c: The reserve/commit protocol is provided through the MPS C 
interface by the functions:

   mps_reserve
   mps_commit 

and macros:

   MPS_RESERVE
   MPS_COMMIT
   MPS_RESERVE_BLOCK

.reserve-commit.c.macro.side-effects: The difference between macros and 
functions is that macros may evaluate their arguments more than once.  For 
example, the macro MPS_RESERVE(&p, ap, size++) expands into code that may 
contain size++ in more than one location, causing the compiler to evaluate it 
more than once.  Therefore, you should not use side effects in macros.

.reserve-commit.macro.warning.l-values: In the block macro 
MPS_RESERVE_BLOCK(res_var, ptr_var, ap, size), the variables have to be 
l-values -- that is, things that values can be assigned to -- because the 
compiler handles variables better than pointers.


STACK DISCIPLINE

.stack: This part of the document describes the stack discipline protocol.

.stack.what: Stack discipline is a means by which object lifetimes can be 
declared to observe a stack-like behaviour.  By stack-like behaviour we mean 
that if a particular object is dead then all objects allocated since that 
object are dead as well (so one can imagine managing the objects using a 
stack).  In fact the protocol can be less strict about the liveness of the 
objects; it can be used to mean that all the objects allocated since a 
particular object are _likely_ to be dead rather than actually are dead.  Which 
of these two interpretations is used depends on the pool class involved.

.stack.frames: All APs have a stack of frames associated with them (if the 
function used in this protocol are not used then it isn't necessary to consider 
this stack of frames).  .stack.frames.inde: The stacks belonging to each AP are 
independent of each other.  .stack.frames.order: The frames in a stack are 
arranged in a partial order with a parent/child relationship (the stack frames 
form a tree).

.stack.frame.what: A frame is used to group a set of objects together.  The 
ordering of frames (see .stack.frames.order) provides a larger grouping.  
.stack.frame.why: The chief purpose of frames is so that a set of objects can 
be declared dead at once (so it provides a kind of mass free interface).

.stack.frame.current: Every AP has a current frame.  .stack.frame.current.top: 
Some pool classes may restrict the current frame to be the (unique) frame with 
no child (see the push operation below, .stack.frame.push), in this case the 
stack frames form a linear order.  .stack.frame.current.any: Other pool classes 
may allow the current frame to be selected from any of the frames in the 
stack.  .stack.frame.alloc: Objects that are allocated in an AP are allocated 
in the current frame.

.stack.frame.init: Initially, when APs are created they have a single frame; it 
is the current frame; this frame cannot be popped (see below).

.stack.frame.push: Stack frames are created and linked into the ordered tree 
with a push operation.  This create a new frame and makes it a child of the 
current frame; the newly created frame becomes the current frame  (Note that as 
observed above, .stack.frame.current.top, if the current frame always has no 
children then a linear ordering of the frames is formed).  The previously 
current frame is still valid and its objects are still alive.

.stack.frame.pop: The pop operation pops the stack back to a specified frame.  
The specified frame and all its descendents (ie its children and all their 
children transitively) become invalid; the objects in those frames are dead.  
If the frames form a linear order then the descendents of a particular frame 
are all the frames pushed since that one.  Actually the meaning associated with 
the objects in the frames is pool class dependent.  Some pool classes will use 
the pop operation to mean that all the denoted objects are dead and their 
storage space may be reclaimed; other pool classes use the pop operation to 
that the denoted objects are mostly dead (they are likely to be good candidates 
for garbage collection).  Consult the pool class documentation for details.


Implementation

.stack.c: The push and pop operations are provided in the MPS C interface in 
the form of the functions:

mps_ap_frame_push
mps_ap_frame_pop


ALIGNMENT

.alignment.background: Some processors require that you align accesses to 
memory; others just work better if you do.  For example, a double precision 
floating point number on many architectures must be aligned on a double 
boundary (that is, its address must be a multiple of 8).  Alignments of eight 
bytes mean the last three bits are 0, etc.

.alignment.pool-class: As a consequence of this, every pool has an alignment.  
If the pool alignment is eight bytes, then all allocated objects must be eight 
bytes.  If a six-byte object is allocated, two bytes are wasted.  A pool's 
alignment is should be available to the client through the interface, but is 
not.  Often this does not matter as for many pool classes clients can specify 
the pool's alignment when creating it (but crucially not for Pool Class MV).

.alignment.platform: MPS_PF_ALIGN is a C preprocessor symbol defined in mpstd.h 
which defines the MPS's notion of the platform alignment.  The platform 
alignment is the least common multiple (since we assume all alignments are 
powers of 2 this is the maximum) of all alignments on that platform.  If 
objects are allocated at platform alignment, generally everything is allocated 
with no problems, but a lot of space may be wasted.

.alignment.rounding: If the client application allocates memory using an 
allocation function, the function sorts everything out for it.  If it is using 
reserve and commit, it has to round allocations up to the pool alignment.  
Alloc and Init always need the correct alignment -- if the pool size is four 
bytes, then the size variable must be four bytes.


SUMMARY OF RESTRICTIONS

* You have to initialize memory if you are using formatted pool classes.

* You cannot assume that the values of Alloc and Init will remain the same if 
you invoke the MM.

* You cannot assume that the value of Limit will ever remain the same; you have 
to check it before using it.

* You cannot change the value of Limit yourself.
------------------------------------------------------------------------
symbol.mps.c.mps_ap_frame_pop(0)  incomplete symbol

MPS C INTERFACE: MPS_AP_FRAME_POP
drj, 1998-10-19


NAME

mps_ap_frame_pop


SUMMARY

Declares that a set of objects in a particular frame are dead or likely to be 
dead.


ASSOCIATED PROTOCOLS

AP Stack Protocol


TYPE

mps_res_t (mps_ap_frame_pop)(mps_ap_t /* ap */, mps_frame_t /* frame */)


ARGUMENTS

mps_ap_t ap
  The allocation point in which the frame was pushed.
frame
  The frame.


RETURNED VALUES

A result code in the usual way.


DESCRIPTION

This function pops the specified frame making its parent the current frame 
(frames are implicitly created using the push operation, see 
symbol.mps.c.mps_ap_frame_push).  Popping invalidates the specified frame and 
all frames pushed since the specified frame.  Popping the frame makes a 
declaration about the set of objects which were allocated in the specified 
frame and also all frames which were pushed since the specified frame.  It can 
be used to declare a set of objects dead or likely to be mostly dead; the exact 
interpretation of the declaration depends on pool class that the allocation 
point is in (the same pool class that that objects are in).  Typically pool 
classes which are mostly manually managed will use this declaration to mean 
that the objects are dead and their space can be reclaimed immediately, whereas 
pool classes which are mostly automatically managed will use this declaration 
to mean that the objects are likely to be mostly dead (the pool class may use 
this declaration to alter its collection decisions).  Consult the pool class 
documentation for details.

In general a frame other than the current frame can be popped (all frames 
pushed more recently will be invalidated as well, as described above), but a 
particular pool class may impose the restriction that only the current frame 
may be popped.  This restriction means that every push must have a 
corresponding pop.  Consult the pool class documentation for details.

It is illegal to pass invalid frames to any MPS function.  In particular it is 
not possible to pop frames out of order (so the sequence "A = push, B = push, 
pop A, pop B" is illegal) or to pop to the same frame twice (so the sequence "A 
= push, pop A, pop A" is illegal).

More comprehensive documentation is available in the protocol document (AP 
Stack Protocol).


SEE ALSO

mps.protocol.alloc-point.stack, symbol.mps.c.mps_ap_frame_push
------------------------------------------------------------------------
symbol.mps.c.mps_ap_frame_push(0)  incomplete symbol

MPS C INTERFACE: MPS_AP_FRAME_PUSH
drj, 1998-10-16


NAME

mps_ap_frame_push


SUMMARY

Declares a new frame as part of the AP stack protocol.


ASSOCIATED PROTOCOLS

AP Stack Protocol


TYPE

mps_res_t (mps_ap_frame_push)(mps_frame_t * /* frameReturn */, mps_ap_t /* ap  
*/);


ARGUMENTS

mps_frame_t *frameReturn
  The frame return parameter.  A new frame (declared by this function) is 
stored in this location if this function is successful.
mps_ap_t ap
  Allocation Point.  The allocation point in which the new frame is declared.


RETURNED VALUES

A result code in the usual way.  The creation of new frame objects (which is 
implicit in the action of this function) can consume resources, so this 
function can fail because there are insufficient resources.  This function may 
fail if the correct protocol is not followed by the client.


DESCRIPTION

This function declares a new frame in the specified allocation point, makes 
that new frame a child of the current frame, changes the current frame to be 
the newly created frame, and returns a handle to the frame.  Frames have two 
important features: A single frame identifies a set of objects (those objects 
that are "allocated in the frame") which can be destroyed (or declared dead) in 
a pop operation (see mps_ap_frame_pop); They are arranged in a partially 
ordered sequence (this is important when the pop operation is used).  A fuller 
and more useful description is found in the AP stack protocol document 
(protocol.mps.alloc-point.stack).


ERROR HANDLING

Errors can either be because the client hasn't followed the correct protocol in 
which case there isn't much that we can recommend or else because some needed 
resource isn't available.  The usual course of actions when short of resources 
is recommended [ha!].


SEE ALSO

symbol.mps.c.mps_ap_frame_pop, protocol.mps.alloc-point.stack
------------------------------------------------------------------------
symbol.mps.c.mps_class_amc(0)  incomplete symbol

MPS C INTERFACE: MPS_CLASS_AMC
gavinm, 1998-10-21


NAME

mps_class_amc


SUMMARY

Returns the pool class object (of type mps_class_t) for the Automatic Mostly 
Copying pool class.


ASSOCIATED PROTOCOLS

Pool Creation


SYNTAX

mps_class_t mps_class_amc(void)


ARGUMENTS

No arguments.


RETURNED VALUES

As summary; returns a pool class object.


RESOURCES

This symbol is declared in the header file mpscamc.h [impl.h.mpscamc].  That 
header file must be included before making any reference to this symbol.


DESCRIPTION

This function returns an object of type mps_class_t which represents the 
Automatic Mostly Copying pool class.

This pool class requires an extra argument when used in mps_pool_create:

res = mps_pool_create(&pool, arena, mps_class_amc(), format);

The extra argument, format, should be of type mps_fmt_t and specifies the 
format of the objects allocated in the pool.

An AMC pool is both scannable and collectable.  Objects may contain exact 
references to other objects that will preserve such other objects.  Objects may 
be reclaimed if they are not reachable from a root.  Objects may move during 
collection, unless reachable via a (direct) ambiguous reference.  Objects in an 
AMC pool may be registered for finalization.  Exact (that is, non-ambiguous) 
references into an object in an AMC pool must be to the start of the object.

The AMC pool class exploits assumptions about object lifetimes and 
inter-connection variously referred to as "the generational hypothesis".  In 
particular, the following tendencies will be efficiently exploited by such a 
pool:
  - Most objects die young;
  - Objects that don't die young will live a long time;
  - Most references are backwards in time.

mps_ap_frame_push and mps_ap_frame_pop may be used on an allocation point in an 
AMC pool.  They do not declare the affected objects to be definitely dead 
(compare with the SNC pool class), but have an undefined effect on the 
collection strategy.  

If an allocation point is created in an AMC pool, then the call to 
mps_ap_create will take no additional parameters.


ERROR HANDLING

Cannot fail.


SEE ALSO

symbol.mps.c.mps_ap_frame_pop(0)
symbol.mps.c.mps_ap_frame_push(0) 
symbol.mps.c.mps_ap_create
------------------------------------------------------------------------
symbol.mps.c.mps_alloc_pattern_ramp_collect_all(0)  incomplete symbol

MPS C INTERFACE: MPS_ALLOC_PATTERN_RAMP_COLLECT_ALL
gavinm, 1998-10-21


NAME

mps_alloc_pattern_ramp_collect_all


SUMMARY

Returns a ramp allocation pattern type indicating that a full GC should be done.


ASSOCIATED PROTOCOLS

GC, AP, ramps


SYNTAX

mps_alloc_pattern_t mps_alloc_pattern_ramp_collect_all();


ARGUMENTS

none


RETURNED VALUES

Returns the allocation pattern type for full collection ramps.


DESCRIPTION

This yields an allocation pattern for an AP that is similar to that returned by 
mps_alloc_pattern_ramp, in that it declares a ramp allocation pattern, but 
additionally indicates to the MPS that the next collection following the ramp 
should be a full GC.

This permits the client to indicate useful points for a full GC, either because 
most of the heap is likely to be dead, or because accurate statistics are 
required, with minimal perturbation of the GC strategy.

As usual, this allocation pattern should be used in matching 
mps_ap_alloc_pattern_begin and mps_ap_alloc_pattern_end pairs.  It may nest 
with, but should not otherwise overlap with allocation patterns of type 
mps_alloc_pattern_ramp.  In this case, the MPS may defer the full GC until 
after all ramp allocation patterns have ended.


EXAMPLE

{ 
  mps_ap_alloc_pattern_begin(ap, mps_alloc_pattern_ramp_collect_all());
  do_lots_of_work();
  mps_ap_alloc_pattern_end(ap, mps_alloc_pattern_ramp_collect_all());
  wait_for_collection_statistics_while_doing_other_allocation();
}

ERROR HANDLING

Cannot fail.


SEE ALSO

symbol.mps.c.mps_alloc_pattern_ramp
symbol.mps.c.mps_ap_alloc_pattern_begin
protocol.mps.alloc-pattern-ramp(0)
------------------------------------------------------------------------
symbol.mps.c.mps_lib_memcmp(0)  draft symbol

MPS C INTERFACE: MPS_LIB_MEMCMP
pekka, 1998-09-10


NAME

mps_lib_memcmp


SUMMARY

A plinth function similar to C's "memcmp".


ASSOCIATED PROTOCOLS

Plinth


SYNTAX

int mps_lib_memcmp(const void *s1, const void *s2, size_t n);


ARGUMENTS

s1, s2   pointers to memory blocks to be compared
n        length of the blocks, in bytes


RETURNED VALUES

An integer that is greater than, equal to, or less than zero, accordingly as 
the block pointed to by "s1" is greater than, equal to, or less than the block 
pointer to by "s2".


RESOURCES

mpslib.h


DESCRIPTION

This function is intended to have the same semantics as the "memcmp" function 
of the ANSI C standard (section 7.11.4.1).

Like other plinth features, it is used by the MPS and provided by the client 
(possibly using the ANSI plinth, mpsliban.c).


SEE ALSO

symbol.mps.c.mps_lib_memset, symbol.mps.c.mps_lib_memcpy, mpsliban.c
------------------------------------------------------------------------
symbol.mps.c.mps_lib_memset(0)  incomplete symbol

MPS C INTERFACE: MPS_LIB_MEMSET
gavinm, 1998-10-21


NAME

mps_lib_memset


SUMMARY

A plinth function similar to C's "memset".


ASSOCIATED PROTOCOLS

Plinth


SYNTAX

void *mps_lib_memcpy(void *s, int c, size_t n);


ARGUMENTS

s      destination of copy
c      byte (when converted to an unsigned char) to copy
n      length of the block, in bytes


RETURNED VALUES

Returns the value of s.


RESOURCES

mpslib.h


DESCRIPTION

This function is intended to have the same semantics as the "memset" function 
of the ANSI C standard (section 7.11.6.1).

Like other plinth features, it is used by the MPS and provided by the client 
(possibly using the ANSI plinth, mpsliban.c).


SEE ALSO

symbol.mps.c.mps_lib_memcpy, symbol.mps.c.mps_lib_memcmp, mpsliban.c

