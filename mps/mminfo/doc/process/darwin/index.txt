         MEMORY MANAGEMENT GROUP PRODUCT EVOLUTION USING DARWIN
                             process.darwin
                             incomplete doc
                           richard 1997-02-28

INTRODUCTION

.scope: This document provides an overview of how the Memory Management Group 
implements the product evolution process using the Spring Group's DARWIN 
database design.  The details of the implementation can be found in the various 
procedures described in proc.darwin.  

.purpose: This document serves as an introduction to MM Evolution, and a guide 
to its objectives and requirements.

.readership: Any MM Group member or associate, and anyone interested in the use 
of Darwin.

.hist.0: Drafted by Richard Brooksby <richard> and Gavin Matthews <gavinm> 
based on meeting.product.1997-01-08, mail.richard.1996-11-08.12-35, and in 
response to request.process.170171.

.hist.1: 1997-05-30  GavinM  Responded to feedback and incorporate changes to 
Change/QA status.

.hist.2: 1997-08-01  GavinM  Edits from review.process.darwin.1.


OVERVIEW

.over: DARWIN is a Spring database that models the evolution of intended and 
actual specifications of products across releases.  It also tracks the selected 
solutions and their implementation progress.  See the Darwin documentation for 
details.

.over.req: MM Evolution must satisfy the following requirements:
  .over.req.know: Everyone should know what he has to do;
  .over.req.drop: Requirements should not get lost;
  .over.req.comm: There should be a line of communication between the Product 
Manager and the Development Manager.

.over.cover: Evolution covers all aspects of products including software, user 
documentation, marketing materials, and other physical components.


Products

.over.product: A "product" is an intention to deliver a series of versions that 
satisfy the developing requirements that arise from a particular client 
relationship.  Darwin does not support products that depend on each other, or 
that incorporate each other; they must have independent releases.  In this 
respect, Darwin is more useful for requirements management than for 
configuration management.  Products are tagged as "product.<product>" in MM 
Evolution.  See also the Darwin documentation .  


Product Versions

.over.version: A product "version" is a specification for a deliverable and a 
set of releases.  Every product version has a statement of intent.  The 
versions of a product are the series of coherent stages in which the required 
functionality is evolved (see book.gilb88) as an ongoing process.  Product 
versions are tagged as "version.<product>.<version>" in MM Information. [refer 
to general and specific naming schemes too.  drj 1998-12-07][Nb, not a DARWIN 
term  drj 1998-12-07]


Releases

.over.release: A "release" is a reproducible instance of a deliverable, that is 
intended to satisfy the requirements of its version.  It is not necessary that 
a release be shipped to a customer.  QA can only be performed on releases.  
Every release has a date that is the planned execution of 
proc.release.handover, when all development on that release stops, and the 
release is handed over to QA.

Releases are tagged as "release.<product>.<version>[.<release serial>]" in MM 
Evolution.  The first release in a version has the implicit serial of "0", and 
subsequent releases in that version have unpadded serials from "1" onwards.  
[Note that some existing releases have had minor irregularities in the release 
serial portion of their tag.]

Successive releases within a version will be created in response to the 
rejection of changes by QA, and the creation of fix requests.  The Product 
Manager may also create releases in anticipation that these will inevitably 
occur, or as development milestones.

See also the Darwin documentation  on releases, and .tree below on the 
relationship between releases.


Requests

.over.request: A "request" represents a requirement on a product that is not 
satisfied by some release.  Requests come in two types:
  - A "Feature" request is an additional customer requirement (enhancement 
request), evolving the intended specification towards the customer's needs -- 
these are generally derived from req.<product>.*, which in turn are derived by 
the product manager from negotiation with the customer's representative;
  - A "Fix" request is a requirement that was intended to be met but wasn't 
(bug), evolving the actual specification towards the intended specification -- 
these generally come from QA, customer support, or internal defect detection.

In general, feature requests will typically be reported in one version and 
satisfied in another; fix requests will typically be reported and satisfied in 
different releases of the same version.

Requirements can also be either functional or attribute (see guide.req).  The 
set of requests should not be the only record of the intended specification.  
Requests should represent a specification change that is useful in itself, but 
that cannot usefully be partially satisfied.

Requests go through a defining phase where possible solutions are defined and 
analysed.  They then go through a scheduling phase where they either become 
active, suspended for the moment, or declined.  If active, then they will have 
associated changes.  Every request has an owner who is the person responsible 
for advancing it to the next stage.

Requests are tagged as "request.<product>.<request number>" in MM Evolution.  
The request number is a serial allocated automatically by Darwin, is unique 
within MM Evolution, and is generally six digits.  See also the Darwin 
documentation .


Changes

.over.change: A "change" represents the intention to satisfy a request in a 
release.  That intention is inherited transitively by any child releases (see 
.tree).  If a change is successful in satisfying the request (as determined by 
QA) then the actual specification is deemed to meet the intended specification 
for this request in this release (and its children).  All modifications to the 
product must be represented by changes, and hence by requests, and must 
therefore be satisfied in specific releases.  

A release may not have or inherit more than one change for the same request 
unless all prior changes were unsuccessful.  Apart from that restriction, a 
request may have many changes, each of which may satisfy the request using 
different solutions.  If a request is partially met by a change, then either 
the change must be rejected, or the request must be split. [make clearer, drj 
1998-12-07]

More than one change will be scheduled for the same request in two cases:
  - The request is being met in a patch (subsequent) release of a version, and 
also in a subsequent version that does not share working source with the patch 
release -- typically the first is the minimal change that meets requirements, 
and the second is "the right solution" that might perturb the system; or
  - It was scheduled for an earlier release in the same branch (an ancestor), 
but was rejected by QA.

Changes are scheduled for a release between its creation and its handover to 
QA.  During QA, the same changes (and the release itself) are QA'd.

Because changes are created by the Product Manager (see .role.pdm) and 
progressed by the Development Manager (see .role.dev-man), there may be a 
conflict between the desirability of satisfying a request in a release, and the 
reality of development resources.  The Development Manager can signal this to 
the Product Manager via an exception flag. [but we never use this exception 
flag mechanism?  drj 1998-12-07]

After a change is complete, and the release has been handed over to QA, the 
change is QA'd.  If it is rejected, the Product Manager (see .role.pdm) must 
determine whether to schedule a rework change for a subsequent release or 
abandon the intention to satisfy that request in that release branch.

Changes are tagged as "change.<product>.<version>[.<release serial>].<request 
number>" in MM Evolution.  See also the Darwin documentation .


Assignments

.over.assignment: An "assignment" is part of the work involved in completing a 
change.  There will be up to four assignments for any changes, related to the 
solutions defined for the request ["four" is an artefact of the current 
implementation of DARWIN in Lotus Notes, drj 1998-12-07].  Each assignment is 
assigned to a particular developer for implementation, and also an approver to 
determine whether the assignment has been successfully carried out.  

Assignments have an implementing phase during which development proceeds 
(although speculative development may occur in the waiting phase), a releasing 
phase during which the working source is perturbed, and an approving phase 
where the approver may return the assignment to the developer for reworking.  
The assignments for a release are completed and approved between the release 
entering the development phase, and its handover to QA.  

Assignments also have an optional reworking phase if they fail approval.  The 
justification for having a different phase rather than returning to the 
implementing or releasing phase, is to indicate that an inadequate attempt at 
the assignment modifications is visible in the working source.

Assignments are not currently represented by documents in MM Evolution, but are 
contained within the change form.


Workflow

.workflow: The following diagram gives an overview of the flow of work, and the 
relationships between the procedures and the statuses.  A guide to the 
procedures is available in proc.darwin.  All requests, releases, and 
assignments have a status indicating the stage they are at; this is indicated 
in the appropriate column.  Changes have two statuses, Dev (development) and 
QA.  The notes below explain aspects of this diagram.

.workflow.fig: 
 - Physiology (2.9) 

.workflow.many-to-one: In the diagram, the black and grey ovals represent where 
there is a many-to-one relationship between two columns.  The arrow cannot be 
followed into the second column until all the relevant entities in the first 
column have reach the indicated status (or any of the indicated statuses).

.workflow.auto: The Dev Status of a change is calculated automatically as the 
minimum status of all the assignments (in the order shown), or "Unassigned" if 
there are none.  In particular, it will reach "Complete" only when all 
assignments are complete.

.workflow.decision: In the diagram, when a procedure exits to several statuses 
in the same column, this indicates that the procedure involves a decision, and 
that precisely one of the exit statuses will be chosen.

.workflow.do-multiple: In the diagram, a double-headed arrow represents where a 
decision entails the execution of another procedure one or more times in the 
course of executing the decision procedure.  If the Request Manager decides to 
take a request to "Active" in proc.request.plan, or a change to "Rescheduled" 
in proc.change.replan, then he must execute proc.change.create one or more 
times.

.workflow.succession: Notice that, in this diagram, in almost all cases a 
status is followed by a procedure and vice versa.  The exceptions usually 
indicate a problem.  proc.release.qa is followed by proc.release.close and 
there is no way for the QA Manager to indicate to the Product Manager that the 
release has been fully QA'd.

.workflow.terminal: Terminal statuses are indicated by underlining.  Note that 
"Suspended" isn't really a terminal status for a request, but is considered so.

.workflow.inputs: Where a procedure has several inputs, this indicates that all 
the inputs must occur, before the procedure can be executed.

.workflow.active: Note that the distinction between "Scheduling" and "Active" 
for a request is slightly different from that documented in Darwin where the 
request transits when the first assignment is commenced.

.workflow.waiting: It is possible for the Product Manager to schedule changes 
for a request that is "Waiting" or "Defining", but this is not shown in this 
diagram.


THE RELEASE TREE

.tree: Releases form a tree within their product, and a series within their 
version.  The versions form a series within the product. 

.tree.darwin.fig:
  - Darwin Tree 
This diagram shows how the release tree for product.season relates to the 
versions.  It also shows how a feature request is intended to be met between 
versions, and a fix request is intended to be met both within a version and 
between versions.  It also shows how a change rejected by QA is rescheduled for 
a child release.

Progression up the diagram corresponds to evolution of the intended 
specification towards customer needs, while progression to the right 
corresponds to evolution of the actual specification towards the intended 
specification.

.tree.hope.fig: 
 - Hope Tree 
This diagram shows how the release tree shown above (.tree.darwin.fig) is 
mirrored in Hope.  Versions generally correspond to release branches (branches 
are shown as solid dots), within which modifications are made directly.  The 
actual releases correspond to checkpoints (shown as circles).  Changes made 
between versions are generally made on development branches (see 
proc.dev.branch), and merged back into the trunk (the vertical line).


ROLES

.role: There are seven roles associated with the process of product evolution.  
These don't need to be seven different people, but ought to be at least three 
because changes/assignments should be developed, approved, and QA'd by distinct 
people.

[ The procedure lists here should be reversed, by having an "actor" paragraph 
in each procedure.   Maybe. ]

.role.req: The Requester is the person who makes a request (see 
proc.request.create).  He may be in Product Management, Development, QA, Sales, 
Marketing, Customer Support (on behalf of a customer), or possibly an internal 
customer.  He is not responsible for ensuring that requests are valid and 
non-duplicate, but it is helpful if he can do this.

.role.pdm: The Product Manager is the person responsible for assigning requests 
for further definition (see proc.request.assign), determining in which releases 
a request should be met (see proc.request.plan), scheduling appropriate changes 
(see proc.change.create), replanning rejected changes (see proc.change.replan), 
closing old requests (see proc.request.close), creating releases (see 
proc.release.create), starting their development (see proc.release.begin), 
handing them over (see proc.release.handover), and closing old releases (see 
proc.release.close).  In the context of MM Evolution, he is not necessarily in 
Product Management, but is the person charged with managing requests and 
releases for a particular product.  [Should we divide this into Request Manager 
and Product Manager?  GavinM 1997-07-16]

.role.inv: The Investigator is responsible for defining, estimating, and 
selecting solutions for a particular request (see proc.request.define).  He is 
assigned by the Product Manager (see .role.pdm) and may be in Product 
Management or Development.  The Product Manager may do his own investigation.  
In some cases the solution may be obvious can this step can be omitted.

.role.dev-man: The Development Manager is responsible for creating assignments 
for a particular change (see proc.change.assign), and assigning Developers (see 
.role.dev) and Approvers (see .role.app) to them.  He need not be the manager 
of a development group, but should be the person charged with assigning effort 
for a particular product, and should be in Development.  Often the same person 
will act as both Product Manager and Development Manager, but the roles are 
distinct.  The Development Manager is sometimes known as the Project Manager.

.role.dev: The Developer is the person assigned by the Development Manager (see 
.role.dev-man) to perform a particular assignment (see proc.assignment.begin, 
proc.assignment.begin-checkin, proc.assignment.end, and proc.assignment.rework) 
 He will normally be in Development.

.role.app: The Approver is the person assigned by the Development Manager (see 
.role.dev-man) to approve a particular assignment (see 
.proc.assignment.approve).  He will normally be in Development and should be 
distinct from the assigned Developer (see .role.dev).

.role.qa: The Quality Assessor is responsible for performing Quality Assessment 
on either a change (see proc.change.qa) or a release (see proc.release.qa).  
Assignment of Quality Assessors is the responsibility of the QA Group (see 
proc.change.assign-qa), but the Product Manager will notice if it is not done, 
because he cannot close the release.  The assigned Quality Assessor for a 
change will normally be distinct from any Developers (see .role.dev) or 
Approvers (see .role.app) concerned.  He will normally be in the QA Group.

ATTACHMENTS
   "Hope Tree"
   "Darwin Tree"
   "Physiology (2.9)"

