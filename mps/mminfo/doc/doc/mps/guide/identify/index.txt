               IDENTIFYING AND CATEGORIZING MPS LIBRARIES
                         doc.mps.guide.identify
                               draft doc
                             drj 1998-08-27

INTRODUCTION

.intro: This document describes how to find out what version of the MPS a 
particular shipped library binary corresponds to.



PURPOSE

.purpose: The purpose of this document is to describe a means by which 
configurations, versions, and releases of the MPS can be identified.  Uses 
include: debugging, support, performance comparisons.



TERMINOLOGY

.product: "Product" is used to encompass a broad range of evolving 
configurations that are expected to meet the needs of a particular market 
sector.  The evolutionary stages of a product are divided into "versions" and 
"releases".  EPCore and Dylan use different products.

.version: A "version" of a product is a set of releases with the same intended 
specification.  Typically the releases will evolve towards the intended 
specification as bugs are discovered and removed.

.release: A "release" is a deliverable (but not necessarily delivered) instance 
of a product version.  It is intended to be reproducible and identifiable.

.variety: A release is often comprised of several "varieties" of essentially 
the same software.  The core functionality of the software remains the same 
across different varieties, what changes is the amount of debug information 
available, the amount of consistency checking performed, and the amount of 
telemetry produced.

.platform: A software execution environment which allows the execution of 
software with some of uniform interface.  We typically discuss platforms as 
being compatible at the binary or ABI level by specifying an operating system 
and a hardware architecture, additionally we (superfluously for the purposes of 
binary compatibility) include the compiler tools used to generate the 
software.  Examples are Sun Solaris (an OS) running on SPARC (an architecture) 
compiled using GNU GCC (a C compiler).


IDENTIFICATION

.categorize: A shipped MPS library binary can be categorized by the Product, 
Version, Release, Variety, and Platform.

.mechanism: The MPS library contains a string embedded in it which identifies 
all of the above.  The string can be identified because it has both of the 
following as substrings: .mechanism.what: "@(#)", this is compatible with the 
UNIX XPG4 what(1) utility; .mechanism.hqn: "HQNMPS", short for Harlequin MPS.  
.mechanism.decl: In addition the string is the value of a C object declared 
with the identifier MPSVersionString.  .mechanism.fun: The same string is 
returned from the function MPSVersion.

.how: So an MPS library can be identified by finding the string.  There are a 
number of ways to do this:

.how.grep: The string can be "grepped" out of the binary.

.how.grep.unix: On UNIX, we suggest:
  strings - mmdw.a | grep HQNMPS
or
  what mmdw.a | grep HQNMPS
where mmdw.a should be replaced with the pathname of whatever binary you are 
interested in.

.how.grep.pc: On Windows NT, we suggest:
  strings - mmdw.lib | grep HQNMPS
This relies on having the non-standard (but common and free) utilities "string" 
and "grep" installed.

.how.grep.mac: On a Mac, we suggest using HexEdit (it's a binary file editor).  
Open the library or executable and use Command-F to find the string "HQNMPS".  
.how.grep.mac.only: Unfortunately HexEdit is hardly standard issue.  Hassle a 
few Mac users until you find one with a copy.

.how.debug: A debugger can be used to access the C object:
.how.debug.string: By simply printing the value of MPSVersionString.
.how.debug.string.windbg: In WinDBG this would be "? MPSVersionString".
.how.debug.string.gdb: In GDB this would be "print MPSVersionString"
.how.debug.fun: By calling the function MPSVersion and printing its value.
.how.debug.fun.windbg: In WinDBG this would be "? MPSVersion()".
.how.debug.fun.gdb: In GDB this would be "print MPSVersion()".

