                       MPS INTERFACE CONVENTIONS
                        doc.mps.ref-man.if-conv
                             incomplete doc
                             lmb 1997-05-29

NAMING

.naming: The MPS interface naming convention resembles a conventional C, UNIX, 
or Posix convention. 

   - Identifiers are in lower case, except for macros that do not behave like 
functions,
     which are in upper case.
   - All publicised identifiers start with the prefix "mps_" or "MPS_". 
   - Types end with the suffix "_t", except for structure and union types; see 
below. 
   - Structure types and tags end with "_s". 
   - Union types and tags end with "_u".
   - Enumeration types are not used; there is no naming convention for them.  
[Perhaps reference an explanation of why we don't use enumeration types.  The 
reason from the inside is guide.impl.c.misc(0).enum.type.  drj 1999-02-08]

.naming.reserve: We reserve the right to use "mps_" or "MPS_" for undocumented 
internal names.  Future versions may use symbols that aren't defined in current 
versions, but they will also begin with "mps_" or "MPS_".  In addition, you 
should not use _mps_ for your own names if you are using our macros.


OPAQUE AND TRANSPARENT TYPES

.mps.types: Types declared in the MPS interface are of three sorts:

   - Transparent types
   - Opaque types
   - Derived types

.transparent: The transparent types, such as mps_res_t, are types whose 
implementation is deliberately exposed.  You may use properties of the 
underlying types to manipulate values of these types.  For instance:

- mps_addr_t is void*.  You may cast an mps_addr_t to a structure pointer, if 
you acquired it from an MPS allocation function (and you didn't specify an 
alignment that is too small for this type of structure).

- mps_bool_t is int.  You may combine mps_bool_t values with Boolean operators, 
use them as conditions, and so on.

You should still use the type name declared in mps.h when using the MPS 
interface (so, for instance, you should not use "int" where you mean 
"mps_res_t").

.opaque: The opaque types, such as mps_class_t, are declared as pointers to 
incomplete structure types (such as struct mps_class_s).  This means that the 
implementation of these types is invisible to you.  You should not use anything 
about the implementation of an opaque type.  The value of an opaque type might 
be NULL, or an invalid pointer (for instance, it might point to unmapped 
memory).  You cannot generate values of opaque type; only the MPS may generate 
them.  The value of an opaque type can only be used in a call to the MPS or a 
test for equality with another value of the same type.

.derived: The derived types, such as mps_ap_s, mps_assert_t, and 
mps_root_scan_t, are structure and function types based on transparent and 
opaque types and on built-in C types.  The degree to which you may or must 
depend upon the implementation of a derived type depends upon the type, and is 
covered by the documentation for the type.


RESULT CODE RETURN

.res: Operations that might fail return a result code, rather than a "special 
value" of the return type.  In other C interfaces, it is common to do the 
following:

  p = malloc(s);
  if (p == NULL) there was an error;
  otherwise p is meaningful

.res.special: Here, NULL is a special value.  We shun special values.  It is 
too easy to ignore them, and then they trip you up later.  Also, there is not 
always one available.  There is only one special value in many cases, so you 
cannot distinguish between different errors.  Other justification is given in 
Maguire, 1993, Chapter 5.

.res.code: There is a single fixed set of result codes defined in mps.h, all 
beginning "MPS_RES_".  .res.code.ok: MPS_RES_OK means "operation succeeded".  
We guarantee that MPS_RES_OK is zero, so we support the following code:

  res = mps_alloc(...);
  if(res) handle error;

as shorthand for:

  res = mps_alloc(...);
  if(res != MPS_RES_OK) handle error;

.res.code.meaning: The other codes have rough global meanings, but what they 
mean specifically depends on the method that they come from.  So, for example, 
MPS_RES_MEMORY indicates failure due to lack of memory, but might mean 
something in particular for some methods. 

.res.error-path: We recommend handling errors using error unwind paths.  That 
is, functions that could fail always return an error code and pass back return 
values via reference parameters.  In the event of an error, a function must 
leave the system in a state as if nothing has happened.  You can do this by 
constructing an "error path" at the end of the function that will unwind its 
effect, in a manner similar to an exception handler.

Here is what a typical function might look like:

  res_t frobulate(frob_t *frob_return, size_t s)
  {
    res_t res;
    frob_t frob;
    void *p;
    size_t i;

    ASSERT(frob_return != NULL);        /* see frob spec 1.3.4 */
    ASSERT(s > 0);                      /* see frob spec 1.3.5 */
    ASSERT(s < FROB_SIZE_LIMIT);        /* see frob spec 1.3.5 */

    res = alloc(&p, sizeof(frob_struct));
    if(res != RES_OK) goto fail_frob;
    frob = (frob_t)p;

    res = alloc(&p, sizeof(spong_struct) * s);
    if(res != RES_OK) goto fail_spong;
    frob->spong_vector = (spong_t)p;

    for(i = 0; i < s; ++i) {
      res = spong_splat(&frob->spong_vector[i]);
      if(res != RES_OK) goto fail_splats;
    }

    /* etc. */

    ASSERT(check_frob(frob));

    *frob_return = frob;                /* only update result on success */
    return RES_SUCCESS;

  fail_splats:
    /* spongs don't need to be unsplatted individually (spong spec 2.3.1), */
    /* so it's OK to just deallocate the spong vector. */
    dealloc((void *)frob->spong_vector);
  fail_spong:
    dealloc((void *)frob);
  fail_frob:
    return res;
  }

.res.params: If the result code is non-zero (that is, not MPS_RES_OK), then 
none of the input/output or output parameters will have been modified (see 
below).


INPUT/OUTPUT AND OUTPUT PARAMETERS

.io: We use I/O and O parameters where

   - we need to return a value _and_ there may be an error case.
   - we need to return more than one value.

.io.out: An output parameter is just a pointer to somewhere where the result 
can be stored.  You tell the function where to put the result.  For example:

  mps_addr_t p;

  res = mps_alloc(&p, pool, size);
  if(res) {
    /* p hasn't been touched in this case. */
    handle error;
  }

  /* p now contains the result, which is the address of the new block */
  /* in this case. */

Here, the first parameter of mps_alloc, p, is an "output" parameter.  The value 
of p when mps_alloc is called is not used by mps_alloc.  p is only modified if 
mps_alloc succeeds.

.io.io: An input/output parameter is very similar, except that the value _is_ 
used when the function is called.

  res = mps_fix(ss, &ref);

In this case the value of ref when mps_fix is called is significant.  mps_fix 
_may_ update ref, but only if res is MPS_RES_OK (that is, only if successful.)

Unless otherwise documented for a specific function, the pointers passed as 
input/output and output parameters must be valid pointers to storage of the 
correct type, and in particular must be non-null and correctly aligned.  In 
addition, input/output parameters must be pointers to storage containing valid 
values of the appropriate type.

.io.pun: It's tempting to use cast to change the type of a I/O or O parameter, 
like this:

  struct foo *fp;

  res = mps_alloc((mps_addr_t *)&fp, pool, sizeof(struct foo));
  if(res) ...

This is called a pun, and is illegal in standard C [xref to standard.ansic].  
In fact, it will work on almost all architectures, but it relies on the fact 
that fp has the same underlying representation as an mps_addr_t.  As a result, 
the code is not portable.  We do not support this usage.  Instead, we recommend 
this:

  mps_addr_t p;
  struct foo *fp;

  res = mps_alloc(&p, pool, sizeof(struct foo));
  if(res) ...
  fp = (struct foo *)p;


OPTIONAL ARGUMENT PASSING

[Optional arguments have not been implemented yet.]
.optarg.struct: You can pass a set of optional arguments to a function as a 
structure.  The structure can contain default values which the you can override 
if you want to.

.optarg.eg: For example, when you create a particular instance of a pool class, 
you might want a special alignment.  You do not always want this alignment when 
you create instances of the pool class, so you do not want to have it always as 
an argument.  You might use the following code to [do what?]:

  mps_pool_create_opt_s opt_s;       /* the "option structure" */

  mps_pool_create_opt_init(&opt_s);  /* set it to default values */
  opt_s.alignment = 16;          /* override some particular argument */
  res = mps_pool_create(&pool, space, mps_class_mv(), &opt_s);

What this means is that you care about the alignment, and want it to be 16, but 
do not care about any other options.  The other options will get the default 
values.  The specific options available, and what the restrictions on them are, 
are covered in the reference for that function.  

.optarg.naming: In general, you must initialize an option structure using the 
right "init" method, which will generally be called "<function>_opt_init".  
.optarg.re-use: The option structure can be used many times if you want the 
same options over and over.  .optarg.mod: It will not be modified by calling 
the function.  .optarg.re-init: It can be re-initialized and used again.


GENERAL OPERATIONS ON ABSTRACT DATA TYPES

.adt.naming: Usually, abstract data types (ADTs) have names like "pool".  
Objects of the type are of type "mps_pool_t", which is actually a pointer to a 
structure of type "mps_pool_s".  All the operations on that type begin with 
"mps_pool_".

.adt.create: To create an object, use the "mps_*_create" method.  In general, 
this has a return parameter into which the new object is placed, and the other 
parameters specify what it is created inside and other options or attributes it 
has.  For example, a pool is made in the space, and has a class as an 
attribute, and maybe some optional arguments (see above).

.adt.destroy: When you have finished with the object, it is destroyed using 
"mps_*_destroy", which takes the object as a parameter and doesn't fail.

.adt.finish: As a general rule, you must "finish off" the object before it is 
destroyed.  For example, you must destroy all the pools before you destroy the 
arena (thus "finishing off" the arena).  This has a kind of symmetry which 
helps you to get things correct and therefore improves reliability.


MACRO NAMING

.macro.intro: We use two kinds of macro.  One kind behaves like a function.  
The following paragraphs describe this type.

.macro.std: We follow a convention that's almost exactly the same as the 
standard C library.  To quote 7.1.7:

  Any function declared in a header may additionally be implemented as a
  macro defined in the header, so a library function should not be declared
  explicitly if its header is included.  Any macro definition of a function
  can be supressed locally be enclosing the name of the function in
  parentheses, because the name is then not followed by the left parenthesis
  that indicates expansion of a macro function name.  [Continue quote.]
  ... Any invocation of a library function that is implemented as a macro
  shall expand to code that evaluates each of its arguments exactly once,
  fully protected by parentheses where necessary, so it is generally safe
  to use arbitrary expressions as arguments. ...

.macro.multi: In some cases an argument may be evaluated more than once, so it 
is not safe to have a side effect in an argument of such a method.  These 
special cases are documented in the reference entry [see putc [standard.ansic 
7.9.7.8] or getc [7.9.7.5]].  [We need to go back and make sure that we've made 
it clear which functions might evaluate arguments more than once.]

.macro.call: If you definitely want to call the function, there are two ways:

   - You can undefine the macro as follows:

     #undef mps_reserve

     res = mps_reserve(...);  /* definitely calls the function */

   - You can put the name in parentheses, as follows:

     res = (mps_reserve)(...);  /* definitely calls the function */

We recommend the latter.  [Maybe just quote more of the standard above, section 
7.1.7.]

.macro.void: [Technical detail for people writing macros mainly:] When a 
function returns void, we may implement it as a macro that expands to a 
_statement_ (when terminated by a semicolon).  Therefore, it is not supported 
to use such functions where only an expression is valid -- for example, on the 
left-hand side of a comma.  This is not supported:

  (mps_tramp(...), ...)

but this is:

  mps_tramp(...);

.macro.special: The other kind of macro is not a version of a function.  These 
are always written in all caps.  The exact details depend on the macro; see the 
reference documentation.  For example, there is a macro that reserves (like 
mps_reserve) but does not behave like a function syntactically, called 
MPS_RESERVE_BLOCK.

.macro.expansion: Details of the macro expansion, although visible in the 
header file, are not part of the MPS interface, and might change between 
releases.  Don't rely on them, unless they are documented separately (as the 
internals of allocation points are).


HEADER FILES

.h.main: The main interface is called "mps.h".  This header contains all the 
core MPS interfaces.   In practice, you always need at least one arena class 
and one pool class header file as well.

.h.prefix: We will always prefix header file names with "mps" to avoid 
clashes.  We reserve the right to create new headers beginning with "mps" in 
future versions.

.h.class: Pool class headers begin with "mpsc".  So the header for Pool Class X 
is "mpscx.h".  Such a header contains the declaration of the pool class itself 
(that is, mps_class_x()) and any class-specific stuff.


SUMMARY OF INTERFACE CONVENTIONS

- The MPS interface naming convention resembles a conventional C, UNIX, or 
Posix convention.  We reserve the right to use mps_ or MPS_ for undocumented 
internal names.  In addition, you should not use _mps_ for your own names if 
you are using our macros.

- Types are transparent, opaque, or derived.  The implementations of 
transparent types are exposed; the implementations of opaque types are not.  
For information on derived types, consult the documentation for that type.

- Operations that might fail return a result code, rather than a "special 
value" of the return type.  The MPS uses a fixed set of result codes, all 
beginning "MPS_RES_".  MPS_RES_OK indicates success and is always 0.  The other 
codes have rough global meanings, but what they mean specifically depends on 
the method that they come from.

- We recommend handling errors using error unwind paths.

- We use I/O and O parameters where

   - we need to return a value _and_ there may be an error case.
   - we need to return more than one value.

An output parameter is a pointer to somewhere where the result can be stored.  
You tell the function where to put the result.  An input/output parameter is 
very similar, except that the value _is_ used when the function is called.  We 
do not support punning.

- You can pass a set of optional arguments to a function as a structure.  The 
structure can contain default values that you can override if you want to.

- ADTs are of type mps_*_t.  All operations on an ADT begin with mps_*.  To 
create or destroy an object, use mps_*_create or mps_*_destroy, respectively.  
You usually must finish off the object before you destroy it.

- The MPS's macro naming convention is almost the same as the standard C 
library's.  The exception is that, in some cases, MPS macros may be evaluated 
more than once, so it is not safe to have a side effect in an argument to such 
a method.  These special cases are documented in the reference entry.

