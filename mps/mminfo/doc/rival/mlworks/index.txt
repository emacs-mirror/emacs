                       MLWORKS GARBAGE COLLECTOR
                             rival.mlworks
                              obsolete doc
                           richard 1995-08-15

To: mm
Subject: ML GC fixup statistics
Date: Tue, 25 Jul 1995 16:29:03 +0100
From: Nick Barnes <nickb>

FYI:

I have re-instrumented the ML GC fixup routine to gather
statistics. This is for the SPARC/SunOS MLWorks batch compiler
recompiling itself:

Total calls of fixup .  .  .   :    279558463
  non-pointers                 :    133028395 (47.59%)
  not from space     .  .  .   :     41074083 (28.03% of ptrs)
    static objects             :            0 ( 0.00% of non-from ptrs)
  already evacuated  .  .  .   :     12225223 (11.59% of from ptrs)
  copied                       :     93230762 (88.41% of from ptrs)
    pairs            .  .  .   :     75309280 (80.78% of copied objs)
    pointers                   :     14970662 (16.06% of copied objs)
      records        .  .  .   :     13784350 (92.08% of copied ptrs)
      strings                  :      1160086 ( 7.75% of copied ptrs)
      reals          .  .  .   :            0 ( 0.00% of copied ptrs)
      code objects             :            0 ( 0.00% of copied ptrs)
      backptrs       .  .  .   :        21249 ( 0.14% of copied ptrs)
        evacuated              :        16404 (77.20% of backptrs seen)
      shared closures   .  .   :         4977 ( 0.03% of copied ptrs)
        steps                  :        25483 ( 5.120 per shared closure)
        evacuated    .  .  .   :         4212 (84.63% shared closures)
    ref ptrs                   :      2950820 ( 3.17% of copied objs)
      arrays and weak arrays   :      2950360 (99.98% copied ref ptrs)
      bytearrays   .  .  .     :          460 ( 0.02% copied ref ptrs)

  Total copy loop iterations   :     30916234 ( 0.111 per fixup)

Nick

---

To: mm
Subject: More MLWorks GC fixup statistics
Date: Wed, 26 Jul 1995 14:50:53 +0100
From: Nick Barnes <nickb>

Two test programs this time. The first is the MLWorks SPARC/SunOS
batch compiler compiling the whole MLWorks system for SPARC/SunOS. The
second is the MLWorks tty environment running a sizable test through
the Lego theorem prover.

MLWorks batch compiler:

uninstrumented time: 1595.2u 152.8s 1:07:43 43% 0+15800k 1763+1856io 2457pf+0w

Total calls of fixup .  .  .   :    362679977
  non-pointers                 :    171985954 (47.42%)
  not from space     .  .  .   :     50456372 (26.46% of ptrs)
    static objects             :            0 ( 0.00% of non-from ptrs)
  already evacuated  .  .  .   :     16306156 (11.63% of from ptrs)
  copied                       :    123931495 (88.37% of from ptrs)
    pairs            .  .  .   :    100025407 (80.71% of copied objs)
    pointers                   :     19928905 (16.08% of copied objs)
      records        .  .  .   :     18324306 (91.95% of copied ptrs)
      strings                  :      1578149 ( 7.92% of copied ptrs)
      reals          .  .  .   :            0 ( 0.00% of copied ptrs)
      code objects             :            0 ( 0.00% of copied ptrs)
      backptrs       .  .  .   :        21447 ( 0.11% of copied ptrs)
        evacuated              :        16512 (76.99% of backptrs seen)
      shared closures   .  .   :         5003 ( 0.03% of copied ptrs)
        steps                  :        24808 ( 4.959 per shared closure)
        evacuated    .  .  .   :         4232 (84.59% shared closures)
    ref ptrs                   :      3977183 ( 3.21% of copied objs)
      arrays and weak arrays   :      3976646 (99.99% copied ref ptrs)
      bytearrays   .  .  .     :          537 ( 0.01% copied ref ptrs)

  Total copy loop iterations   :     41377495 ( 0.114 per fixup)
  Total bytes copied           :   1354119136 ( 3.734 per fixup)

Lego:

uninstrumented time: 365.2u 17.4s 19:19 33% 0+20556k 261+0io 777pf+0w

Total calls of fixup .  .  .   :     48966306
  non-pointers                 :     13475451 (27.52%)
  not from space     .  .  .   :     17814184 (50.19% of ptrs)
    static objects             :            0 ( 0.00% of non-from ptrs)
  already evacuated  .  .  .   :      3606588 (20.40% of from ptrs)
  copied                       :     14070083 (79.60% of from ptrs)
    pairs            .  .  .   :     12820930 (91.12% of copied objs)
    pointers                   :      1193579 ( 8.48% of copied objs)
      records        .  .  .   :      1085403 (90.94% of copied ptrs)
      strings                  :        76581 ( 6.42% of copied ptrs)
      reals          .  .  .   :            0 ( 0.00% of copied ptrs)
      code objects             :            0 ( 0.00% of copied ptrs)
      backptrs       .  .  .   :        25766 ( 2.16% of copied ptrs)
        evacuated              :        18691 (72.54% of backptrs seen)
      shared closures   .  .   :         5829 ( 0.49% of copied ptrs)
        steps                  :        34686 ( 5.951 per shared closure)
        evacuated    .  .  .   :         4955 (85.01% shared closures)
    ref ptrs                   :        55574 ( 0.39% of copied objs)
      arrays and weak arrays   :        55428 (99.74% copied ref ptrs)
      bytearrays   .  .  .     :          146 ( 0.26% copied ref ptrs)

  Total copy loop iterations   :      3008191 ( 0.061 per fixup)
  Total bytes copied           :    136880448 ( 2.795 per fixup)

Nick

---

From: David Jones <drj>
Date: Wed, 2 Aug 95 17:03:29 BST
To: mm-discussion, nickb
Subject: Re:  More MLWorks GC fixup statistics

>From nickb Wed Jul 26 14:51:01 1995

> Two test programs this time. The first is the MLWorks SPARC/SunOS
> batch compiler compiling the whole MLWorks system for SPARC/SunOS. The
> second is the MLWorks tty environment running a sizable test through
> the Lego theorem prover.
> 
> MLWorks batch compiler:
> 
> uninstrumented time: 1595.2u 152.8s 1:07:43 43% 0+15800k 1763+1856io 2457pf+0w
> 
> Total calls of fixup .  .  .   :    362679977
>   non-pointers                 :    171985954 (47.42%)
>   not from space     .  .  .   :     50456372 (26.46% of ptrs)
>     static objects             :            0 ( 0.00% of non-from ptrs)
>   already evacuated  .  .  .   :     16306156 (11.63% of from ptrs)
>   copied                       :    123931495 (88.37% of from ptrs)
>     pairs            .  .  .   :    100025407 (80.71% of copied objs)
>     pointers                   :     19928905 (16.08% of copied objs)
>       records        .  .  .   :     18324306 (91.95% of copied ptrs)
>       strings                  :      1578149 ( 7.92% of copied ptrs)
>       reals          .  .  .   :            0 ( 0.00% of copied ptrs)
>       code objects             :            0 ( 0.00% of copied ptrs)
>       backptrs       .  .  .   :        21447 ( 0.11% of copied ptrs)
>         evacuated              :        16512 (76.99% of backptrs seen)
>       shared closures   .  .   :         5003 ( 0.03% of copied ptrs)
>         steps                  :        24808 ( 4.959 per shared closure)
>         evacuated    .  .  .   :         4232 (84.59% shared closures)
>     ref ptrs                   :      3977183 ( 3.21% of copied objs)
>       arrays and weak arrays   :      3976646 (99.99% copied ref ptrs)
>       bytearrays   .  .  .     :          537 ( 0.01% copied ref ptrs)
> 
>   Total copy loop iterations   :     41377495 ( 0.114 per fixup)
>   Total bytes copied           :   1354119136 ( 3.734 per fixup)

I'm currently thinking about what to measure in the DylanWorks Memory
Manager.

Are these the only things that you measure?  Why do you measure these
things?  Why don't you measure anything else?

How does knowing that only 26% of pointers are from-space pointers help
you optimise the code paths?  or knowing that most of the objects you
copy are pairs?

Do you want to know what the distribution of allocated object sizes is?

What would you measure in order that you had the most useful numbers to
help optimise your code?

--drj--

---

To: David Jones <drj>
Cc: mm-discussion
Subject: Re: More MLWorks GC fixup statistics 
Date: Wed, 02 Aug 1995 17:27:23 +0100
From: Nick Barnes <nickb>

A fine set of questions.

> Are these the only things that you measure? Why do you measure these
> things?

We have various means of measuring things. These are the (only)
results produced by one such means. Our means of measuring MM things
include:

1. instrumenting every path in the C version of 'fixup'. This produces
the results you have just seen. We do this in order to identify the
critical code paths in fixup (which for some ironic reason my fingers
are insisting on spelling 'fuxup' today :->). Thinking about numbers
like this has in the past reduced GC time by some tens of percent.

2. 'Space profiling'. This gathers information on data allocated into
each generation (where copying from a to b is counted as allocating in
b). It provides breakdowns by runtime object type ('pair', 'record',
'string', &c) and by allocating function. This should in theory be
useful for optimizing ML (mutator) code. In practice it is quite new
and has not been applied very much (besides, the ML code in the
compiler is already well tweaked).

3. 'Time profiling'. As far as the GC is concerned, this provides
information about time spent in the GC, broken down by phase and by
generation (orthogonally). This has been very useful in directing GC
optimising effort (a factor of nearly 2 has resulted from thinking
about results of GC time profiling).

4. 'Heap analysis'. This provides snapshot information about the
contents of the heap, broken down by runtime object type and
generation. It can also be applied to saved heaps. It is a bit
anachronistic and really should be folded into the space profiling
code. It has been very useful in directing efforts at reducing saved
heap sizes (a factor of 2 improvement has resulted from thinking about
numbers produced in this way).

> Why don't you measure anything else?

Whenever I think of something which might be useful to measure, I
measure it. The ones I still measure (above) are the ones I've found
useful. Roughly.

> How does knowing that only 26% of pointers are from-space pointers help
> you optimise the code paths?  or knowing that most of the objects you
> copy are pairs?

I would have to show you the code to give a detailed answer. Basically
the code of fixup is tree-shaped. These numbers tell us how to arrange
the internal graph of the tree (i.e. what decisions to take, in what
order). They also tell us, given the code and some assumptions about
CPI, how long we should spend in fixup. This can be compared with
reality.

> Do you want to know what the distribution of allocated object sizes is?

Not particularly. Allocated objects don't much concern me (I'm more
interested in objects which survive). I have some size distribution
information from the space profile (for instance, I can tell the
average size of allocated -- or surviving -- strings), but I haven't
found it very useful to date.

> What would you measure in order that you had the most useful numbers to
> help optimise your code?

If I knew that, I would measure it :-). So the above list is a partial
answer to your question.

Nick B

---

To: David Jones <drj>
Cc: mm-discussion
Subject: Re: More MLWorks GC fixup statistics 
Date: Wed, 02 Aug 1995 17:51:01 +0100
From: Nick Barnes <nickb>

> > Total calls of fixup .  .  .   :    362679977
> >   non-pointers                 :    171985954 (47.42%)
> >   not from space     .  .  .   :     50456372 (26.46% of ptrs)
> >     static objects             :            0 ( 0.00% of non-from ptrs)
> >   already evacuated  .  .  .   :     16306156 (11.63% of from ptrs)
> >   copied                       :    123931495 (88.37% of from ptrs)
> >     pairs            .  .  .   :    100025407 (80.71% of copied objs)
> >     pointers                   :     19928905 (16.08% of copied objs)
> >       records        .  .  .   :     18324306 (91.95% of copied ptrs)
> >       strings                  :      1578149 ( 7.92% of copied ptrs)
> >       reals          .  .  .   :            0 ( 0.00% of copied ptrs)
> >       code objects             :            0 ( 0.00% of copied ptrs)
> >       backptrs       .  .  .   :        21447 ( 0.11% of copied ptrs)
> >         evacuated              :        16512 (76.99% of backptrs seen)
> >       shared closures   .  .   :         5003 ( 0.03% of copied ptrs)
> >         steps                  :        24808 ( 4.959 per shared closure)
> >         evacuated    .  .  .   :         4232 (84.59% shared closures)
> >     ref ptrs                   :      3977183 ( 3.21% of copied objs)
> >       arrays and weak arrays   :      3976646 (99.99% copied ref ptrs)
> >       bytearrays   .  .  .     :          537 ( 0.01% copied ref ptrs)
> > 

> How does knowing that only 26% of pointers are from-space pointers help
> you optimise the code paths?  or knowing that most of the objects you
> copy are pairs?

To be more specific, before I measured anything like this (about 2
years ago), fixup was driven by a couple of big switches, something
like this:

switch (primary) {

  case PAIRPTR : 
        ...

  case POINTER :

    switch (secondary) {
      case RECORD :
         ...
      case STRING : 
      ...
   }
   ...
}

It now looks something like this:

if (primary == PAIRPTR) {
  ...
} else if (primary == POINTER) {
  ...
  if (secondary == RECORD) {
    ...
  } else if (secondary == STRING) {
    ...
  } else ...
} else if (primary == REFPTR) {
  ...
}

I also improved the outer control structure, by pulling the really
common case (non-pointers) out of the function call into a macro. As a
result the whole thing, in which we spend nearly all our GC time, goes
some tens of percent faster.

However, the improvement was not as striking as that which resulted
from rearranging the phases of a multi-generational GC. The time
profile told us (confirmed our suspicions) that we were spending a lot
of time scanning the foundation set when collecting older
generations. I rearranged it to collect younger generations before
older ones and the total GC time, max pause time, max heap size, &c
all improved dramatically. We now spend almost all our GC time (I
forget the number. 80%?) scanning to-space while collecting the
creation space.

Oh, I've thought of something I don't yet measure but intend to: what
is the age distribution of the objects which survive out of any given
generation? If the answer is as interesting as I suspect, we can get
another big improvement out of our GC by adopting some form of buckets
(as suggested by Richard).

Note: almost all of our measurements have come about because we have
come to suspect an inefficiency, and done measurements to test our
suspicions.

Nick B

