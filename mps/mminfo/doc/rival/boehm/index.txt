                        BOEHM'S CONSERVATIVE GC
                              rival.boehm
                               draft doc
                           richard 1995-08-02

INTRODUCTION

.intro: The Boehm-Demers-Weiser GC is a fully conservative collector designed 
to work in a "drop-in" fashion with C and C++ code and other language systems.  
The seminal paper is paper.bw88 "Garbage collection in an uncooperative 
environment"

.what.4.14: See mail.boehm.1999-04-20.18-19 for the announcement of the 4.14 
release of the collector.

.where: Boehm maintains a website regarding the collector: 
http://www.hpl.hp.com/personal/Hans_Boehm/gc/

 - Boehm.sit 

.great-circle: A version is commercially available, see rival.great-circle.

.parallel: There's also a parallel variant, devised by a Japanese group 
<URL:http://www.yl.is.s.u-tokyo.ac.jp/gc/>.  .distributed: The same group has 
also released a variant suitable for distributed use.   [This needs more 
evaluation.]

---
.notes.dsm: dsm: These are my rough notes on Boehm's collector
  Replacement for malloc
    does not attempt to reclaim all used space
    pointers to begining of live objects although some control for
    interior pointers given
  signal safe
    can allocate after signal
  test provided
  supported platforms include:
    Sun 4 under SunOS 4.X or Solaris2.X (with or without threads)
    Intel 386 or 486 under most operating systems, but not MSDOS.
        (Win32S is somewhat supported, so it is possible to
        build applications for Windows 3.1. ...)
    DECstations under Ultrix
    DEC Alpha running OSF/1
    SGI workstations under IRIX 4 & 5
    Apple Macintosh under A/UX or MacOS
  Dynamic libraries supported on some of these (not Win32s)
  Thread-safe on some machines
  C interface
    1)  GC_malloc(nbytes)
    2)  GC_malloc_atomic(nbytes) [efficiency - objects without pointers]
    3)  GC_realloc(object, new_size)
    4)  GC_free(object) [efficiency]
    5)  GC_expand_hp(bytes) [efficiency]
    6)  GC_malloc_ignore_off_page(bytes) [should use for >100k objects]
    7)  GC_set_warn_proc(proc)
    8) GC_enable_incremental()
    9) Several routines to allow for registration of finalization code.
    some tuning stuff
    lots of other junk
  C++ interface
  Find Leaks facility
  Incremental/generational collection
    Uses dirty information if available, this can be:
      provided by the OS as virtual dirty bits
      found by grubbing around in the processes memory via /proc
      using protection and fault handling
        OS may cause problems by reading or writing to protected pages
        not thread safe
    Stubborn objects (rarely changing objects with explict update i/f)
      are relied on for performance in absence of good VM support
  Problems
    Relies on language and/or programmer being nice with pointers
      Claims not to have had problems with any C compiler
  Performance
    % time required for collection constant across heap sizes
    Collection pauses will increase for larger heaps.
    On SPARCstation 2, collection times order of 300 msecs per MB of
      accessible memory that needs to be scanned.

.notes.chase: (from mail.ptw.1995-08-14.16-44)

To: info-dylan@cambridge.apple.com
Date: 7 Aug 1995 15:46:27 GMT
From: chase@centerline.com (David Chase)
Organization: CenterLine Software
Subject: Re: allocator and GC locality (was Re: cost of malloc)

Seeing as how there's been a perfectly adequate 32-bit Unix memory
allocator available from

  ftp.parc.xerox.com:pub/gc/gc.tar.Z

since about 1988, it seems like it would be unwise to write your
own.  (This memory allocator is also a garbage collector, but it is
trival to turn off the garbage collector and use it instead as a
fast, low-overhead malloc-style memory allocator.  At the time, it
was faster than ANY vendor-supplied malloc I could find, and it has
a very low overhead as well).  The fact that this is possible was
mentioned in Boehm and Weiser's Software Practice and Experience
paper (late 1988) where they describe use of garbage collection
techniques to implement a leak detector.

.analysis: Watching the performance monitor while running dylan with Boehm,
it's noticeable that the Boehm collector allocates memory in chunks of 2048K
and 64K. rit 1998-03-17

ATTACHMENT
   "Boehm.sit"

