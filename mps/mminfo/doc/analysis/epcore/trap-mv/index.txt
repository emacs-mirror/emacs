        CASE HISTORY OF FRAGMENTATION WHEN TRAPPING USES POOLMV
                        analysis.epcore.trap-mv
                               draft doc
                          richardk 1998-06-01

INTRODUCTION

.intro: This is a case history of pathological fragmentation.

.overview: When ScriptWorks trapping used the temp pool (class = poolmv) it had 
awful fragmentation.  The cause was poolmv's new placement policy, _not_ the 
segment-boundary problem.


TRAPPING REQUESTS

.obj: Trapping uses two sorts of objects:

 .obj.working: Working objects are large (several tens of K bytes) but 
short-lived.

 .obj.summary: Summary objects are small (a few bytes), but long-lived (they 
persist until trapping is completed).

.request.loop: Trapping loops round, allocating a working object, creating a 
summary of it, and freeing the working object.

.request.loop.larger: The next time round the loop, the working object created 
will be _slightly larger_ than it was the previous time.

.correlate.deathtime: The key point is that size is well correlated with 
deathtime.  An allocator that does not take advantage of this mixes very 
different sizes and (consequently) deathtimes.  This causes awful 
fragmentation.  [This is not true in general.  pekka 1998-12-11]


POOLMV PLACEMENT

.mv.placement.new-seg: Under poolmv's new placement policy, the allocator 
prefers allocating from the _newest_ segment.


NEW BEHAVIOUR

.place.working: A working object (which is large) often gets put at the start 
of a new segment, leaving a small splinter.

.place.summary: Under .mv.placement.new-seg, the summary is allocated from the 
splinter, immediately after the just-allocated working object.

.free.working: The working object is freed; the segment now contains only a 
summary.

.place.working.next: Because of .request.loop.larger, the next working object 
does not fit where the old working object was.  So it is placed in a new 
segment.

.frag: Consequently we get huge numbers of segments, each containing one 
summary object preceded and followed by free-space too small for a new working 
object.  The fragmentation is awful.

.seg-boundary: Note that segment-boundary fragmentation is _not_ the root cause.


OLD BEHAVIOUR

.mv.placement.old-seg: When poolmv was first written, its allocator preferred 
allocating from the oldest segment.

.frag.old: Under .mv.placement.old-seg, space for the (small) summary would 
have been found in an old segment, keeping it separate from the current working 
object.  In other words, it (unwittingly) used .correlate.deathtime to avoid 
fragmentation.

.mv.placement.change: Poolmv's placement policy was changed by nickb:
---
 [checkin] MMsrc!poolmv.c(MMdevel_sw_eq.4) 14-Feb-1997 13:16:38 BST nickb
 Replace RingAppend with RingInsert.
---
and checked in to the trunk:
---
 [checkin] MMsrc!poolmv.c(trunk.18) 04-Apr-1997 16:54:45 BST nickb
 Merging in EP changes from branch MMdevel_sw_eq
---
This was a speed optimisation, of which the only record seems to be 
mail.nickb.1997-02-14.14-14 "optimizing the trapping release".  There is no 
corresponding Change in MM Evolution or SW Evolution.  There is no helpful 
comment in the change logs.  In the source there is a comment saying "use 
RingInsert so that we examine this new span first when allocating" (where 
"span" ~= "segment").


USING EPDL

.epdl: ScriptWorks trunk trapping has now been changed to use an existing DL 
pool (class = poolepdl).  This works much better than the temp pool: why?

.epdl.segpref: Poolepdl gets low-address segments (by segpref).  So newer 
segments tend to have higher addresses.

.epdl.placement: Poolepdl keeps an address-ordered free list.  It searches from 
low-addresses, and allocates first-fit.  Combined with .epdl.segpref, this 
makes it "old-seg" placement.  Again, it (unwittingly) uses 
.correlate.deathtime to avoid fragmentation.


EVIDENCE

.evid: I (richardk) haven't actually stepped through executing code: the above 
analysis is from the source code, and from two other vital pieces of evidence:

.evid.no-interleave: Trapping allocation is not interleaved with any other 
allocation: see meeting.epcore.1998-04-27.alloc.

.evid.fragmentor: Using Sheep's pool-display tool "Fragmentor" with 
"trapping.log", the summary objects are clearly separated by large gaps.


CONCLUSIONS

.conclusion.risk: Awful fragmentation can be provoked by common request streams.

.conclusion.simple: Nonetheless, an extremely simple placement policy can 
('dumbly') take advantage of .correlate.deathtime, with great success.

.conclusion.change: Changing placement policy can radically impair performance.

.conclusion.consider: Any such changes should be carefully considered before 
being made.  How can we make such consideration effective?

.conclusion.cases: We should have a library of case-histories, describing the 
pattern of the request stream, and possible consequent behaviour.  [Which is 
why this document used to be called case.frag.trap.mv.  pekka 1998-12-11]

.conclusion.placement-policy: We should be familiar with the placement policies 
of our various pool classes.  A pool class's design and documentation should 
_clearly state_ its placement policy.

