                   IDEAS FOR FURTHER JAVA BENCHMARKS
                     analysis.java-benchmark.future
                             incomplete doc
                             lth 1998-09-24

SOME IDEAS FOR MORE JAVA BENCHMARKS

Threads and GC

It may be possible to measure whether, in a preemptively
multi-threaded system, all threads are halted when the GC runs.  For
example, it'd be possible to have a non-allocating thread that can
detect compuation rate unobtrusively, and run it concurrently with an
allocating thread.

This may make sense only on multi-processor machines, since otherwise
there will be no advantage to letting computation continue during
collection (modulo the GC thread waiting for page-ins?).



SOME NON-IDEAS FOR MORE JAVA BENCHMARKS

String.intern() does not need help from the garbage collector.

RMI distributed garbage collection does not need help from the garbage
collector beyond weak references and serialization; in Java 1.2 RMI
should therefore be implementable in Java.



BENCHMARK CALIBRATION 

The benchmarks must be calibrated to some particular platform.  The
platform is both hardware and Java system.  The platform should be an
example of "high-end common" hardware / software, e.g., in late 1998 we
might assume that such hardware would be:

 200 MHz Pentium II or Pentium Pro
 64 MB RAM
 256 KB cache (at least)
 Windows 95, Windows 98 or Windows NT 4.0

The parameters should be chosen so that the benchmarks are challenging
but run OK on the calibration platform.

But we could also assume "ho-hum common" hardware/software, i.e., the
kind of system anyone _running_ a Java program might have.  That might
be more informative, although the benchmark suite dates more quickly.
For example, in late 1998 we might assume that such hardware would be:

 133 MHz Pentium
 32 MB RAM
 64 KB cache
 Windows 95

In either case it's reasonable to calibrate to a common Java system,
which probably means IE4.0 for the browsers and JDK 1.1.{5,6} with JIT
for stand-alone systems.  Both are stable and available free of charge.

It seems the most important part of calibration is fitting the benchmark
in the available RAM so that it won't thrash to death.

Ideally, the benchmarks should be usefully runnable with default
settings on a fairly broad spectrum of hardware around the calibration
point.  So the programs should be calibrated to run for a while on the
calibration platform and use more memory that will usefully fit in
current lo/mid-range caches (1MB).


