             ANALYSIS OF THE GENERAL GOALS AND REQUIREMENTS
                     OF THE MEMORY MANAGEMENT GROUP
                            analysis.general
                             incomplete doc
                           richard 1996-06-27

[This document needs to be formatted, given an introduction, and tagged -- 
richard 1996-06-27]

Goals

  - To provide memory management which maximally contributes to the quality of 
the application, particularly in terms of performance, reliability, and time to 
market.

  - To provide a software framework to fit a wide range of requirements, both 
existing and future, internal and external.

  - Fit within the wider goals of the Memory Management Group. (See Memory 
Management Information, goal.general.)

Requirements

Flexibility

Each client of the memory manager has a different set of requirements.  Often 
these requirements conflict, and there is no solution that will fit them all.  
And yet it is a goal of the system to fit them.  The system must therefore be 
flexible enough to contain a range of solutions.

The model and design are based the important principle that there is no single 
solution to all memory management problems.  An optimisation for one client is 
often a pessimisation for another.  (There are proofs of this for some 
particular aspects, such as fragmentation [ref?].)  There are several classes 
of memory manager, each with many variations, and each has distinct properties 
which make it suitable for meeting its own set of requirements.

Adaptability

It is a goal of the system to meet future requirements.  We cannot predict 
exactly what they will be,  but we can predict the most important areas of 
concern and design adaptability in those areas.  For example, we know that 
speed is a very high priority for many applications of memory management, so we 
ensure that our design includes many opportunities for optimisation.  When the 
characteristics of the client become apparent, we are ready to improve the 
system so that its particular needs are best served.
In order to adapt the system the requirements have to be determined, and the 
system must be measured to see how well it meets them.  The system must 
therefore include tools for determining requirements and making adjustments.

To meet a range of client requirements, the system must provide for varying 
degrees of control.  An example of low-level control would be if the client 
wished to specify properties of the bit-pattern of the pointer to allocated 
memory, and relocate blocks explicitly.  An example of high-level control would 
be to require garbage collection and allow the system to relocate blocks 
transparently.

Interoperability

In order to ship a shrink-wrapped memory management product the system must be 
able to interface through accepted interfaces to various target languages.  In 
particular:

  - malloc/free (C, C++)

  - new/delete (C++)

In order to provide bespoke memory management solutions to internal and 
external clients, the system must be able to provide efficient custom 
interfaces for specific applications.  The most important such requirement is 
high-speed allocation.

Overheads (performance)

Memory management performance is often a tradeoff between space and time 
overheads (the ideal is of course zero for both).  The definition of time 
overhead depends on the application.  For example, time overhead can be defined 
as instructions-to-manage per object, or as total time spent in the memory 
manager vs. the rest of the application.  It is also useful to consider the 
time overhead within a certain period of time.  In interactive applications it 
is important that the application remain responsive.  Such a requirement might 
be expressed by stating that the memory manager may not prevent a response 
within a certain amount of time.

The memory manager must be fast enough to meet tight timing requirements, but 
it must also be possible to measure and adjust to differing requirements for 
time overheads.
Similarly, the definition of space overhead depends on the application.  Many 
applications are most interested in total footprint in order to run within 
hardware constraints.  Scalable applications (such as run-time systems) are 
interested in a bytes-per-object or a percentage overhead.

The memory manager must make efficient use of storage to meet tight space 
requirements, but it must also provide policies which vary the tradeoff between 
time and space in order to be suitable for different applications.

Reliability

Most applications are extremely sensitive to corruption of their memory.  Most 
programming languages and most applications assume that memory has a high 
intergrity.  A system which abstracts access to that memory in order to provide 
a service must have a similarly high integrity.  (Memory managers can also 
assist with the improvement of the integrity of the application.)

Reliability is usually expressed relative to time (mean time between failure, 
or MTBF) or the amount of work that the system has done.

The memory manager must have high reliability and integrity in order to meet 
the requirements of specialized applications in special circumstances.

