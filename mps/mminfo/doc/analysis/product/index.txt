                PROPOSAL FOR MEMORY MANAGEMENT PRODUCTS
                            analysis.product
                               draft doc
                           richard 1996-06-24

1. INTRODUCTION

1.1. Scope

.scope: This document is an analysis of the business options for products based 
on Harlequin's memory management technology and expertise.

1.2. Purpose

.purpose: The purpose of this document is:

  1. to provide senior management with information about memory management 
possibilities in order to inform strategic decisions;

  2. to obtain approval from senior management for the product vision;

  3. to obtain decisions from senior management;

  4. to provide the product development teams with analysis to ensure that 
development is directed towards product success.

1.3. Structure

  1. Introduction
  2. Executive Summary -- for busy executives
  3. Technical Background -- provides overview of technology
  4. Market Analysis -- description of markets, their requirements, and 
analysis thereof
  5. Key Solutions -- overview of solutions and their impact on requirements
  6. Products -- overviews of product alternatives and their business models
  7. Current Status -- a summary of where we stand today
  8. Decisions -- what decisions need to be made
  9. Conclusion

1.4. Readership

.readership:
  - Board
  - SP Divisional Management
  - Memory Management Product Management Quartet
  - Anyone involved in MM development, documentation, QA, marketing, or support.

This document is Harlequin company confidential.  It contains Trade Secret 
material and is protected by Trade Secret Privilege.

1.5. History

.hist.0: 1996-06-27: This document was written by Richard Brooksby with 
significant input from Clive Harris and the feedback of the whole Memory 
Management Group.


2. EXECUTIVE SUMMARY

A memory manager can improve performance and efficiency of applications, and 
also reduce development costs and time to market.

The Memory Management Group has developed advanced, flexible, adaptable, and 
efficient memory management technology which could be commercially exploited in 
a number of ways: principally as either a custom OEM solution or a 
"shrink-wrapped" product.

Market analysis indicates a shrink-wrapped product could bring in $300K in 1997 
rising to $1.2M by 2000, not including a possible 25% extra gained from 
consulting.

The OEM solution is less easy to analyse.

There is much work to be done and the project needs plenty of support to 
realise this potential.


3. TECHNICAL BACKGROUND

Memory management divides into three areas:

  1. memory management hardware (MMUs, SIMMs, refresh circuitry);

  2. operating system memory management (virtual memory, paging, segmentation, 
protection);

  3. application memory management (allocation, object management, garbage 
collection, debugging).

Harlequin's main strength is in the third area: application memory management, 
and garbage collection in particular.  We have some expertise in the second 
area, but mainly in how it interacts with the third.

Application memory management consists of efficiently obtaining and managing 
memory resources in order to satisfy an application's dynamically changing 
storage requirements, while obeying constraints on attributes such as total CPU 
overheads, interactive pause times, and total memory used.

The right memory management policy can dramatically improve the performance 
(and efficiency) of an application, especially when it is short of memory or 
has to operate under certain constraints.

A garbage collecting policy automatically recycles unused memory.  This can 
reduce development and rework effort.  In a complex application, keeping track 
of and recycling memory is difficult.  Automatically managing the process not 
only reduces the burden on the developer, but prevents common and troublesome 
bugs.  In many cases it is also more efficient.

Some languages require GC: Dylan, Java, LISP, ML, PostScript (level 2), Scheme, 
Smalltalk, etc.  Others have the capability to make use of it.

Memory management related tools can provide important feedback to the 
programmer about his application's behaviour, improving developer productivity 
and product quality.  Feedback can provide information for tuning of memory 
usage, general quantitative features of the program, and also debugging.


4. MARKET ANALYSIS

This section presents an initial discussion of the business options available 
to Harlequin for the external commercial exploitation of our memory management 
technology.


4.1. Trends

.trend.complex: Complex applications often suffer from memory management 
problems because of their complicated data structures.  C++ dominates the 
object oriented programming (OOP) market in spite of many flaws, one of them 
being that it does not provide an adequate memory management solution.  Complex 
applications in C++ therefore suffer particularly badly. The increasing 
acceptance of C++ and increasing complexity of applications creates a 
tremendous opportunity for commercial exploitation in the memory management 
field.

.trend.window: At the time of writing there is an open window of opportunity, 
but it may not stay open, and it is important that Harlequin establish itself 
in the area soon.

  - GC may become standard.  There is now a proposal before the ANSI committee 
to actively promote it, and Bjarne Stroustrup, the originator of C++ has often 
be quoted as saying that he expects GC to become a standard part of the 
language in future.

  - The Java phenomenon has the potential to convince developers of the 
benefits of automatic memory management.  On the other hand, bad memory 
management in Java implementations could damage the market.

  - Developers often write their own because provided systems aren't perceived 
as being sufficient.

Harlequin has an awesome opportunity to exploit these native trends in a 
growing, exciting industry by deploying technology developed by the Memory 
Management Group.  We are uniquely placed to build and deliver the world's best 
mousetrap.


4.2. Market Size

.market.size: The global market in memory management tools is approximately 
$30M to $40M and is growing annually at an estimated 25%.


.market.shares:
                      Estimated 1995 revenues by vendor

             Pure Software                                  $25M
             AIB (Sentinel)                                  $5M
             ParaSoft (Insight)                              $2M
             Others (Nu-Mega, MicroQuill, Geodesic etc)      $5M

             Total                                          $37M


.market.platforms:

           Estimated C/C++ Development Market Share, by platform

             Windows                                         80%
             Macintosh        10%
             SunOS                                          3.5%
             HP                                             2.5%
             Silicon Graphics                               1.5%
             DEC Alpha                                      1.5%
             Others                                           1%


4.3. Competition

4.3.1. Domains

.comp.dom: Available products tend to be focused on two partially overlapping 
domains:

  .comp.dom.debug: debugging and memory leak detection (Purify, Insight, 
Sentinel, BoundsChecker);

  .comp.dom.perform: performance optimisation and memory leak eradication 
(SmartHeap, Great Circle).

The latter domain is the more recent, and is the area into which our memory 
management technology most naturally fits.  Our two main direct competitors are 
likely to be SmartHeap and Great Circle (see below).

4.3.2. Third-party Products

.comp.prod: This is a brief description of the third party application memory 
management products which are known to us at the time of writing.  More 
detailed descriptions and analysis can be found in the Memory Management 
Information database, under rival.*.

.comp.prod.smartheap: SmartHeap (MicroQuill) is a heap manager that replaces 
that supplied by the C/C++ compiler vendors.  The main selling point is that 
SmartHeap is three times faster, especially when memory is tight and swapping 
occurs, when it is claimed to be up to 100 times faster.  SmartHeap also offers 
a "debug mode" in which it can detect simple misuses of memory, and memory 
leaks.  SmartHeap has a limited ability to support multiple memory "pools", and 
has two allocation policies.  These contribute to its efficiency.  Notably, 
SmartHeap does _not_ offer any tools to assist with tuning performance.  The 
run-time part of SmartHeap ships with the developer's application, 
royalty-free.  SmartHeap is available on Windows NT, Windows 95, Windows 
16-bit, OS/2 Warp, Power Mac, HP-UX 9.0, and SunOS 4.1.  (See also 
rival.smartheap, and the MicroQuill product information page 
<http://www.microquill.com/prodinfo.htm>.)

.comp.prod.heapagent: HeapAgent (MicroQuill) is dedicated heap error detection 
and diagnosis tool, the companion product to SmartHeap.  "The only 
memory-checking tool that is fast enough and unobtrusive enough to use every 
time you run your application."  MicroQuill claim that it includes intelligent 
agents that let you navigate from the point where symptoms were detected to the 
code that caused the errors.  To use HeapAgent to debug your application, you 
need to rebuild with the HeapAgent library, whereupon it becomes an integral 
part of the deployed application.

.comp.prod.gc: Great Circle (Geodesic Systems) is the first commercial product 
to offer garbage collection facilities to the C++ programmer, and is pitched as 
a memory leak _eliminator_.  "Just link your C/C++ program with Great Circle 
and all its memory leaks automatically disappear! It's that simple. We 
_guarantee_ it! You won't need to change a line of your code or sacrifice 
performance."  It offers a single garbage collection policy with a flexible 
interface to C++ which gives the developer reasonable control.  It also claims 
to eliminate "hangs" (i.e. long pauses) by using an incremental garbage 
collection method.  Great Circle is available on Windows NT, Windows 95, 
Windows 3.1 (if using Win32s), and SPARC workstations (presumably SunOS and/or 
Solaris).  They are working on  OS/2, NextStep, 16-bit DOS and Windows, 32-bit 
Extended DOS, and additional Unix workstations.  (See also rival.great-circle, 
and the Great Circle information page 
<http://www.geodesic.com/GreatCircle/index.html>.)

.comp.prod.purify: Purify (Pure Software) is an analysis tool which is applied 
to compiled programs in order to detect a range of run-time errors, but 
principally memory-related errors.  "Pure Software's Object Code Insertion 
technology (OCI) makes Purify the most comprehensive run-time and memory error 
detection tool available."  It is certainly the most widely known and respected 
tool, and its marketing and documentation is superb.  Purify is capable of 
checking third-party object code as well as the developer's code.  They claim 
that 7000 organizations now use Purify to assist in the debugging of their 
applications.  Purify is available on Sun SPARC Workstations running SunOS 4 or 
Solaris 2, HP9000 Series 700 workstations running HP-UX 8.07 and above, HP9000 
Series 800 workstations running HP-UX 9.0 and above, and SGI workstations 
running IRIX 5.2 and IRIX 5.3.  Pure has recently announced Purify for Windows 
NT.  (See also rival.purify, and the Purify Product Information page 
<http://www.pure.com/products/purify/index.html>.)

.comp.prod.boundschecker: BoundsChecker (NuMega Technologies) is a broad 
run-time error detection tool which monitors applications from the outside.  It 
provides broader error detection that the other products described here, but is 
Windows specific.  "BoundsChecker 4.0 is the most comprehensive automatic error 
detection product available for Windows developers."  BoundsChecker is tightly 
integrated with the Microsoft Visual C++ development environment.  (See also 
NuMega's home page <http://www.numega.com/>.)

.comp.prod.insure: Insure++ (ParaSoft) is ParaSoft's flagship product -- a 
comprehensive C++ developer's error detection tool which includes detection of 
memory related errors.  "Using Insure++, you will produce more robust, better 
optimized, and higher quality software."  The most significant and relevant 
thing about Insure++ is that is provides graphical tools for visualizing and 
analyzing memory usage.  It is the only tool known to do so.  Insure++ is 
available on Windows NT, Windows 95, Sun/Sparc (SunOS 4.x, Solaris 2.x), IBM 
RS/6000, DEC Alpha (Digital Unix, OpenVMS), HP 9000/7xx, Lynx Realtime OS, NEC, 
Pyramid, Sequent, Silicon Graphics, Intel x86 (SCO, Linux, BSD, etc.), and, 
they claim, "many more".  (See also ParaSoft's Insure++ product information 
page, <http://www.parasoft.com/insure++/index.html>.)

.comp.prod.ma: Memory Advisor (Platinum Herndon Labs) is another memory error 
detection tool.  It uses technology which Pure Software claims infringes their 
patents, and litigation is currently under way in the US courts.  It provides 
memory leak and corruption detection, as well as some tools for code coverage 
and testing.  "Memory Advisor is a run-time analysis tool that detects memory 
errors, such as reading uninitialized memory."  It claims to have a "graphical 
user interface", but in fact it is just text-in-a-window.  Memory Advisor is 
available on HP 9000/7xx and 8xx, HP/UX 9.x, 10.x, Sun SPARC, Solaris 2.x 
(SunOS 5.x), Solaris 1.x (SunOS 4.1.x), Data General AViiON (DG/UX 5.4), Data 
General Intel (DG/UX R4.11), DEC Alpha (DEC UNIX (OSF/1) AXP 3.x), IBM RS6000 
(AIX 3.2.5, 4.1), Intel 80x86 (Solaris/x86 2.x), SGI IRIX (IRIX 5.2, 5.3).  
(See Herndon Labs' products page <http://www.aib.com/html/prods.html>.)

4.3.3. Third-Party Analysis

.comp.analysis: The chart below shows the feature and platform coverage of 
these products.  It's easy to see that most of the tools currently on the 
market are concerned with memory leak and other error detection, and not 
peformance analysis and optimisation, or garbage collection.

.comp.analysis.tool-port: The platform coverage of the third-party products is 
also fairly poor.  Harlequin's memory management technology is highly portable, 
though the limiting factor may be the portability of acompanying graphical 
tools.


.comp.feature-chart:
 Product Feature and Platform Chart

 - Feature Chart 2 


4.4. Market Segments

.market.segs: This section examines the customers who might benefit from a 
memory management product, and what their requirements are in this area.

4.4.1. OEMs

.market.seg.oem:

  - Competetive advantage
  - Case-by-case technical requirements
  - Harlequin must be responsive to individual requirements
  - Overheads of "buying in" must be low
  - Good communication lines with Harlequin
  - Early initial delivery followed by responsive adaptation
  - Concentration on OEM's core competencies
  - Demonstrable advantages

4.4.2. Programmer

.market.seg.programmer:

  - Improved productivity
  - Fast and easy deployment of tools
  - Absolute reliability of memory manager
  - To focus on application functionality, not bookkeeping
  - To get it right first time
  - Control over the way memory is used
  - Control over process of using tools
  - Evidence of the benefits of tools
  - Tools he can rely on
  - Sexy tools

4.4.3. Development Manager

.market.seg.devman:

  - To hit targets and make deadlines
  - Productivity from programmers
  - Absolute reliability of application components
  - Reduction of development costs
  - Reduction of rework costs
  - Reduction of porting costs
  - Application performance
  - Proof of benefits of tools
  - Guarantees

4.4.4. QA Team

.market.seg.qa:

  - Requirements met at minimum cost
  - Verification that application meets requirements
  - Post-optimisation
  - Quality

4.4.5. User of MM Product-enhanced Application

.market.seg.user:

  - Smooth running
  - Reliability
  - Performance
  - Efficiency

4.4.6. User Managers

.market.seg.user-manager:

  - Better use of resources: spend less on memory
  - Fewer hitches with applications

4.4.7. Systems Integrator

.market.seg.integrator:

  - Faster integration times
  - Components which co-operate
  - Lower-spec solution for turnkey systems
  - Absolute reliability of application components


4.5. Requirements Analysis

.req.flex: The OEM requirements lead directly to a need for flexibility to meet 
a range of requirements.

.req.adapt: The OEM will require adaptability from the system to meet changing 
requirements.

.req.rapid: The OEM will require rapid deployment needs to be followed by an 
excellently maintained relationship which emphasises the advantages gained by 
deploying Harlequin's solutions.

.req.eval: Developers have a notoriously short attention-span for new tools, 
and will require rapid deployment and evidence of benefit very quickly.  Our 
analysis suggests that the product should provide evident benefits within half 
a day.  Another way of looking at this is that the product must evaluate well, 
so we must incorporate features targeted at the evaluation cycle.

.req.roi: Further in, developers and development managers will require a good 
return on investment at every deepening stage of involvement with the product.  
The product must also provide evidence of these benefits.

.req.image: The product must look good.

.req.usp: The product must have some compelling unique selling points in 
comparison with the competition.

.req.build: The product should build markets for further memory management 
products and consultancy.

.req.c: The product must support both C and C++.

.req.platform: The division of the C/C++ development market strongly suggests 
that the product must be available on, in order of priority:

  .req.platform.win: Windows,
  .req.platform.mac: Macintosh,
  .req.platform.unix: a range of UNIX platforms, principally Sun, HP, SGI, and 
DEC Alpha, at a higher price.

.req.reliable: The product must have rock-solid reliability.  A memory 
management is a core piece of an application, and developers are unlikely to 
take any nonsense from it.  The product could be completely sunk if it is buggy.


5. KEY SOLUTIONS

This section lists some of the key solutions developed by the Memory Management 
Group.  Only the solutions which have significant impact on the product options 
in this document are listed here.  For a more complete list, see the document 
"overview.ideas" in the Memory Management Information database in Spring.

These solutions (and others) were developed in the context of the broad goals 
of the Memory Management Group (see goal.general) which includes servicing 
internal customers within Harlequin and building technology which will last 
beyond any one particular product.  The wider analysis which supports these 
solutions is not provided in this document (see analysis.general).  In summary, 
the wider requirements are:

  - flexibility to meet a wide range of requirements
    (from this we derive performance, portability, interoperability, etc.);

  - adaptability -- the ability to change and meet changing requirements;

  - reliability.

Section 6, "Products", describes how these solutions can be focussed to meet 
the market requirements.


5.1. Levels of Use

.sol.levels: The MPS Model of Use includes the idea of "levels of use" which 
provide a way of stratifying the sophistication of deployment of the system.  
The idea is to guarantee return on invested effort at each level of 
sophistication, so that a user can gain benefit from the system in one 
afternoon, one week, one month, or one year.  Levels of use contribute to the 
flexibility of the system, since users may have different constraints on the 
effort available.  (For further details, see Memory Management Information, 
overview.mps.usage.)

5.2. Size Class Analysis

.sol.sca: Size class analysis is a technique based on research by Grunwald and 
Zorn (paper.grun92).  It is a simple technique which can be rapidly applied to 
an application to increase performance and memory efficiency.  Good results are 
very likely, and therefore this would be a good technique to apply at low 
levels of user sophistication.  This technique thereby contributes to the 
flexibility of the system.

5.3. Adaptation by Feedback

.sol.feedback: The MPS Model of Use includes a mechanism by which the client's 
requirements are determined by a "measurement feedback loop" consisting of the 
MPS, associated tools, the client programmer, and the client application.  This 
model is designed to extract the client's requirements whether he knows them 
explicitly or not.  This mechanism is a significant contribution to the 
flexibility and adaptibility of the system, and to its overall quality, since 
it increases the probability that the system will meet the clients 
requirements.  (See Memory Management Information, overview.mps.usage.)

5.4. Component Architecture

.sol.component: The MPS is designed as a software component.  It is designed to 
fit in to a system where other such components may be operating.  It does not 
assume control over the address space, threads, the CPU, or the environment in 
general.  It is designed to be small, to fit in embedded systems.  It makes 
conservative use of the features of its implementation languages, and of the 
operating environment.  It avoids unjustifiable clever tricks.  An important 
test of this is that the system can run when there is another copy of itself in 
the application, or another foreign memory manager.  This approach contributes 
to the flexibility of the system by allowing it to be deployed in many 
environments.  It also contributes to the reliability and integrity by 
restricting the complexity and dependencies.

5.5. Incremental Processes

.sol.incr: The MPS implements background management processing, such as 
incremental garbage collection, as a set of state machines whose timing is 
carefully controlled in order to meet the client's timing requirements.  This 
technique contributes to the flexibility and adaptability of the system.

5.6. Ranks and Conservative Garbage Collection

.sol.ranks: The MPS includes the concept of "reference rank" allowing it to 
cope naturally with ambiguous references when needed.  It is therefore suitable 
for deployment in systems where there is only partial knowledge about the 
connectivity of the application's objects.  (An example of this is conservative 
garbage collection.)  This contributes to the flexibility of the system in that 
it allows it to be used in circumstances where full knowledge is impossible or 
costly to obtain.  For example, the MPS can be retro-fitted on to an 
application that was not designed to make use of it, and provide a useful 
degree of automatic management.

5.7. Multiple Co-operating Management Policies

.sol.policies: The MPS allows several different memory management policies to 
co-exist and co-operate, especially in the process of garbage collection.  
Several different types of garbage collector can work together on a pass over 
the application's data.  The protocols used to achieve this are highly 
efficient and do not compromise the efficiency of a single policy working 
alone.  Objects may also be migrated between policies if the MPS determines 
that this would better meet requirements.  This design contributes to 
flexibility by providing the ability to combine policies to form new composite 
policies.  It also contributes to adaptability by simplifying the 
implementation and integration of new policies.

5.8. Pools and Pool Classes

.sol.pools: The MPS is based on a system of "memory pools" and "memory pool 
classes" which implement memory management policies.  Memory pools improve 
locality, allow multiple instantiations of policies, co-operate to give 
composite policies, and provide a uniform interface to memory management which 
greatly improves flexibility by making it easy to modify and experiment with 
policy choices in the client application.

5.9. Adaptive Cost/Benefit Analysis

.sol.adapt: The MPS is designed to make memory management decisions based on 
"adaptive cost/benefit analysis" rather than hard-wired strategy.  This 
technique allows the client to specify the operational parameters 
(requirements) dynamically, and the MPS will take decisions to meet them, 
adapting to the changing circumstances.  This technique contributes the 
flexibility and adaptability of the system.

5.10. Evolutionary Delivery

.sol.evolve: The MPS development is managed using the principle of 
"evolutionary delivery", which emphasises requirement-oriented development, and 
determination of client requirements by early delivery and feedback.  This 
approach significantly reduces the risk of failure by ensuring that actual (as 
opposed to initially stated) client requirements are determined and met, and 
clients have access to early working solutions.  (See book.gilb88: "Principles 
of Software Engineering Management"; Tom Gilb; Addison-Wesley, 1988.)

5.11. Inspection

.sol.inspect: A derivative of a formal document and code review technique 
called "Inspection" is applied to the development of the MPS.  Inspection is 
the single best contribution to the integrity and reliability of the design and 
implementation.  (See book.gilb93: "Software Inspection"; Tom Gilb, Dorothy 
Graham; Addison Wesley 1993; ISBN 0-201-63181-4.)


6. PRODUCTS


6.1. OEM Product

6.1.1. Analysis

.prod.oem.req: The OEM requirements must be determined on a case-by-case basis, 
as must the development costs.  .prod.oem.cost: Since the MPS is flexible we 
can be sure of being able to meet a wide range of requirements at significantly 
less cost than it would take to build a new system from scratch.

.prod.oem.suit: This is an indications that our Memory Management technology is 
extremely well suited to an OEM style of consultative sell.  At Harlequin, we 
have significant experience of the OEM channel, primarily from our EP products, 
and the specialised nature of our MM product should enable us to easily 
identify a small number of key potential customers.  Most of the risk 
associated with the OEM route derives from the (perceived) limited number of 
major customer candidates -- a supply which, once exhausted, is not easily 
replenished.

6.1.2. Description

This will be a traditional, big-ticket, consultative sell in which Harlequin 
revenues will be determined by the exercise of commercial judgement and the 
value we can directly bring to each specific customer.  These contracts need to 
be negotiated by experienced sales professionals who know how to pull 
technology, people and services together.

In each case the product most likely be an adaptation of the core MPS 
technology (the "MPM") plus a number of custom plug-in memory management 
policies, and probably a "glue layer" to provide a custom interface suitable 
for the OEM's needs.

The client's initial requirements are gathered at the beginning of the 
relationship.  (These are unlikely to be the same as the final requirements.)  
As quickly as possible, a "generic" solution is deployed based on the core MPS 
technology.  This solution will _not_ meet all the stated requirements, but 
gets the client up and running, and more importantly, stimulates them to feed 
back the changes in their requirements.  In many cases, it will be possible to 
deploy the "shrink-wrapped" product directly, or with only a little 
adaptation.  The aim is to meet a subset of the requirements as early as 
possible.

There follows a process of "evolutionary delivery" in which the OEM's feedback 
is fed into the development of adaptations.  Incremental deliveries are made 
until until the OEM's final requirements are met.  This late-binding 
requirements analysis dramatically increases the customer satisfaction by 
"homing in" on their final requirements and maintaining a constant feedback 
loop.  (See book.gilb83 for a discussion of this development and delivery 
strategy.)

The two products -- OEM and shrink-wrapped -- are extremely synergistic and 
represent a situation where the 'whole' is greater than the sum of the two 
parts.

6.1.3. Business Model

Premium pricing based on a mix of consultancy and perceived value delivered.

Assemble a list of 'perfect profile' OEM target customers. Aggressively pitch 
our MM OEM product via our senior sales staff.

Such a list is likely to contain, among others:
  - Sun,
  - Microsoft,
  - Borland,
  - Powersoft/Sybase,
  - IBM.

6.1.4. Risk Analysis

.prod.oem.risk.feast: Large OEM deals in this relatively new marketplace are 
likely to represent a case of 'feast or famine'.  Even one deal could consume 
nearly all of our resources, or alternatively, the complexity of the 
partnership involved may be too great for a close relationship.

.prod.oem.risk.com: The deal could founder on purely commercial grounds, even 
though our technical solution places us on the shortlist.

.prod.oem.risk.divert: The development track for a custom solution may divert 
us (in both feature and resource terms) from our planned future product 
directions.  

.prod.oem.risk.window: Our familiarity with the OEM market, and understandable 
caution, may result in us ignoring an extremely exciting shrink-wrapped product 
opportunity which has a natural window-of-opportunity likely to close within 12 
to 18 months.  We may find it significantly harder to achieve market 
penetration later.

.prod.oem.risk.tools: The OEM product has less technical risk than the 
shrink-wrapped product because it is not quite as dependent upon a suite of 
graphical tools to demonstrate benefit.  This said, sales success in the 
shrink-wrapped marketplace cannot fail to assist in our OEM goals.  Graphical 
tools will also be needed in order to adapt the system to meet client needs, so 
their development is crucial.


6.2. "Shrink-Wrapped" Product

6.2.1. Analysis

.prod.sw.eval: The product must bring evident benefits within half a day 
(.req.eval).  This can be achieved by focussing the software, documentation, 
and marketing at this crucial initial period:

  .prod.sw.eval.drop: The software can be developed to simply "drop in" and 
replace the
    compiler vendor's memory manager, providing some immediate benefits, which 
it must
    make evident through measurement tools.

  .prod.sw.eval.sca: Size class analysis (.sol.sca) can be developed so that the
    developer can perform a simple one-shot build-run-analyse-rebuild cycle and 
gain
    immedate benefits to both performance and efficiency.  Again, the 
acompanying tools
    must inform him of the benefits.

.prod.sw.roi: Further return on investment must be supplied at each deepening 
level (.req.roi).  This is achived, again, by focussing software and 
documentation on "levels of use" (.sol.levels).  The documentation and software 
will be structured to give the developer each additional level at minimum 
effort, and provide definite benefits (and evidence for those benefits) at the 
end of each stage.  Documentation will be divided into chapters by level, and 
the software will be tailored to match.

.prod.sw.lead: The customer will be lead through the user levels, encouraging 
him at every stage to invest more time to gain more benefit from the system.  
When he's reached the last user level he'll be ready to buy more specialized 
memory management policies, or even to commission us to produce them.

.prod.sw.coord: To make this model work, the software, documentation, 
packaging, and marketing material have to be highly co-ordinated.  It would be 
very easy to make this product too hard to use, requiring hand-holding and 
costly support.  We must avoid this pitfall.

.prod.sw.build: The product should build markets (.req.build).  This is achived 
by extending the "levels of use" (.sol.levels) model to include two further 
levels: tuning services, and custom solutions, both provided at a price by 
Harlequin.  The documentation and software will be designed to lead the 
customer to these levels once the full potential of stand-alone work has been 
achieved.

.prod.sw.image: The product must look good and have unique selling points 
(.req.image and .req.usp).  These can be provided by unique graphical tools for 
memory analysis and development.  Only one competitor, Insure++ (.comp.insure) 
has anything like a graphical tool, and that is poor.

.prod.sw.c: The software already supports C and can be adapted to support C++ 
by the addition of a "glue layer" (.req.c).  Glue layers are already catered 
for in the architecture of the MPS.

.prod.sw.platform: The MPS is highly portable, and can be made to work on all 
the necessary platforms (.req.platform).  The graphical tools will need to be 
developed for Windows, MacOS, and X, which will be a challenge, as usual.

.prod.sw.reliable: The reliabilty of the MPS will be provided and maintained by 
using solid software engineering techniques, such as software inspection 
(.sol.inspect).  These techniques add a significant overhead to development, 
but pay back massively in reduced support and rework costs.  Management must 
support the software engineering techniques and tolerate the apparent delays in 
order to ensure success of the product when it reaches the market.

6.2.2. Description

This is quoted from Richard's draft introductory blurb:

  - The product is a software component which will help you to deliver better 
software with less effort.

  - The product is a memory manager which works behind the scenes to help your 
application make more effective use of its memory resources, giving higher 
performance and eliminating whole classes of memory-related errors.

  - The product is designed to give you an advantage whether you spend a single 
day with it or devote more time to using its sophisticated features to tune 
your application.  

  - The product should provide a return on your investment at every stage.

  - Use the product in your application and you will deliver higher quality 
software sooner.

The MM Product consists of:

  - a set of libraries containing the memory management components, 
  
  - a set of memory management tools for measuring, analysing, tuning, and 
debugging the application with the memory manager.

  - a user manual,

  - a reference manual,

  - the "pool class catalog",

  - demonstration applications and sample source code. 

Libraries

.prod.sw.lib: The libraries make up the memory manager itself. The distribution 
will consist of a fairly large number of small libraries from which the client 
(in the role of system integrator) can pick and choose. Each supported platform 
will have a set of libraries. Each set of libraries contains several 
components: the MPM (core system), plus a set of pool classes, plus some glue 
layers for compatibility with various language systems. Each of _those_ will be 
built with several different "varieties": optimized, asserted, metered, 
debugging, etc.

If you imagine six target platforms, six pools, and four varieties that makes 
144 libraries to build, test, and catalog. 

Tools

.prod.sw.tools: This will be a graphical interface to an engine which collects 
information from metered varieties of the memory management libraries as they 
run with the application. The tools will provide decoding, display, storage, 
export, and analysis of the data gathered from the MM. This information is 
intended to help the application writer to make choices of policy and 
parameters to make the application do what he wants.  (See Memory Management 
Information, overview.mps.usage for how tools fit in with "User Levels".)

.prod.sw.benefit: The tools must emphasise the benefit that the customer is 
gaining from using them and using the memory manager.  They should provide 
ammunition to the developer to use on other developers and on their managers to 
persuade them that the MM Product is an excellent thing.  We should send them a 
free T-shirt as well.

User Manual

.prod.sw.manual.first-chapter: The first chapter of the user manual is what the 
customer will read first. He may never read the rest. The first chapter of the 
user manual is therefore absolutely critical to the acceptance and use of the 
product. 

.prod.sw.manual.benefit: The user manual must hit the customer with the 
benefits of using the product, and provide a very easy route to getting started 
within that vital first afternoon.

.prod.sw.manual.coax: It must coax him on to greater things, making better and 
better use of memory management, and educating him in the esoteric subjects of 
measurement, garbage collection, and requirements as he reads.

.prod.sw.manual.outline: An outline of a user manual based on this model has 
already been prepared.

Reference Manual

.prod.sw.ref: The reference manual must document the programming interface to 
the memory management libraries, and the tools.

.prod.sw.ref.jump: It's quite possible that the customer will read the 
beginning of the reference manual first, or even skip straight to what look 
like the juicy bits.  The reference manual may need to be designed to point the 
customer back to the beginning of the user manual so we don't lose him in that 
first afternoon.

.prod.sw.ref.useful: Beyond that, the reference manual just needs to be useful 
and accurate. 

Pool Class Catalog

.prod.sw.pcc: The Pool Catalog provides technical details about pool classes.

.prod.sw.pcc.purpose: The purpose of the pool catalog is to allow the user to 
make informed decisions about which pool classes to use with his application in 
order to meet his requirements. 

.prod.sw.pcc.bundle: The MM Product will come bundled with a number of plug-in 
memory management policies which will suit many applications.  Specialized 
applications may require specialized policies.  There is a possibility that we 
could build a market for memory "Pool Classes" as updates to the original 
product.

.prod.sw.pcc.structure: The catalog will be a loose-leaf ring binder containing 
"data sheets" for the memory pool classes.  Each data sheet contains the 
technical specifications which the customer needs to make choices.  The data 
sheets are organized so that the first piece of information is suitable for a 
low "User Level" (see "Model of Use") and provide details further down. When 
the customer receives updated information, or buys new memory pools, he inserts 
the sheets into the catalog.

.prod.sw.pcc.ref: The pool class catalog is the engineer's reference book. 

Demonstration Applications and Sample Code 

.prod.sw.demo: These are essential.  Many of the finer points of memory 
management are extremely hard to explain.  The benefits of garbage collection 
are notoriously hard to convey.  Sample source code is a direct way of 
demonstrating the use of the memory manager.  Demonstration applications are a 
direct way of demonstrating the benefits to be gained. 

.prod.sw.demo.impact: The customer is likely to run the demonstrations during 
the first sortie.  They need to convince him to continue.

.prod.sw.demo.present: Some animated presentations might also be appropriate to 
explain the use of the tools and some of the internal workings.

6.2.3. Business Model

Our product will bring a better solution to an existing market.  It is a 
continuous, rather than a discontinuous innovation.  These are classic 
circumstances for market pricing, requiring analysis of existing commercial 
offerings and pitching the price accordingly.  Note that there is no compulsion 
to either deliberately undercut the opposition or otherwise - just acknowledge 
that the going rate for similar products is a key influencer in our own pricing 
strategy.

Sales Model

It is recommended that a blend of telesales, at the low end, and direct sales 
at the high be employed to support our entry into the marketplace.  Given the 
relatively low likely price of the product, cost-of-sales will play a pivotal 
role in the ultimate profitability and success of the product.  We are likely 
to have a clear, crisp sales message which should certainly be communicable by 
good telesales staff -- and this of course will offer us a very cost-effective 
way of reaching the largest possible audience. It is likely that for sales in 
excess of $10,000 the involvement of a direct salesperson will be required.

Pricing

Pricing is to-be-determined but we clearly must acknowledge the existence of 
other players in this market.  Prices range between $200 to $1000 on Intel, and 
$1000 to $3000 on UNIX, in order to realise profit from this smaller market 
segment (.market.platforms).

Revenue Potential

In 1997, the global memory management tools market will reach approximately 
$44M.  A common heuristic in the (shrink-wrapped) software tools industry 
suggests that a well-planned, aggressive market entry for a new product into an 
existing market can yield in the region of 1%-2% of the global market in its 
first year.  After launch, we can anticipate rapid initial growth of our memory 
management business - 50% p.a would not be unreasonable for the first three or 
four years.

These estimates would yield the following revenue projections, assuming a 
product launch in 2Q97, and a 1% initial penetration:

  1997: $330K
  1998: $660K
  1999: $880K
  2000: $1100K

These figures are exclusive of consulting revenues, which might realistically 
contribute 20 to 25% more than this.

6.2.4. Risk Analysis

.prod.sw.risk.std: If we do not launch a product as soon as possible, the 
current market players may become de-facto standards.

.prod.sw.risk.usp: More work must be done refining our unique selling points.  
Better performance is a softer selling point than zero defects.

.prod.sw.risk.tools: The shrink-wrapped product depends heavily on the 
existence of a slick set of graphical tools, none of which have yet been fully 
specified, let alone started in development.

.prod.sw.risk.overload: The Memory Management Group Project Manager (Richard 
Brooksby) is heavily overloaded.  There is important technical work that only 
he is in a position to do, plus he is responsible for planning, organization, 
and administration.  Most importantly, he is product champion and pulls 
together the product vision, ensuring conceptual integrity and quality.  He is 
also taking on much of the product management work, dealing with internal and 
external clients and defining the product specifications.  While he enjoys all 
this work and believes he is competent, there is a significant risk that there 
is simply too much for him to do in the time available.  The result could be 
that the product is brought to market with significantly reduced functionality 
and quality.  He is attempting to deal with this issue with George Cleland, and 
hopes to come up with a solution that retains coherence of vision.

.prod.sw.risk.scale: A related risk is that the Memory Management Group suffers 
from "scalability problems".  It is infeasible to add new developers to the 
core technology group quickly.  Adding a developer takes six months and places 
a significant strain on Richard, and therefore slows down development.  Adding 
people to this project will _not_ make core development faster.  Richard has a 
solution: Gavin Matthews has recently joined the project and has been assigned 
to solving this problem as his primary goal.  His work will include internal 
documentation of designs and methods, and assistance with the organization of 
the group.  The target is to be able to add a core developer at a remote site 
and get them up and running within a couple of months, with minimal drain on 
management and delay to development.  Richard has faith in Gavin's ability to 
do this, but the work is unlikely to improve the situation for some months.


7. CURRENT STATUS OF DEVELOPMENT

On 27th June 1996, the status is as follows:

.stat.core: The core system (the MPS) is close to being functionally complete.  
Very little significant new research and development is required to build the 
product.  There is quite a lot of consolidation and production programming to 
do at this point.  Some of the research programming needs re-implementing 
solidly, and adaptation will be needed to ensure the system meets the marketing 
requirements.  New memory pools may need to be developed in order to deliver a 
reasonable suite of solutions.

.stat.tools: No analysis tools exist.  The MM Group is carrying out usability 
analysis and early design to determine the key features that must be present in 
the tools.  Some early design and prototyping has been done.  Very little 
research programming needs to be done.  However, no member of the MM Group is a 
experienced user-interface programmer.  This issue is discussed in the 
"Decisions" section (section 8, below).

.stat.doc: No product documentation exists.  Estimates based on the product 
description above reveal a need for six documentor-months of effort, tightly 
coupled with the development toward the product, and ideally as a pseudo-member 
of the Memory Management Group.

.stat.process: A significant and growing body of effective and efficient 
software engineering techniques, adapted for Harlequin, has been developed by 
the group in order to meet the reliability requirement.  This is a significant 
development in itself, and we hope that it will be of great benefit to other 
groups in the company, in accordance with our goals (goal.general.quality, 
goal.general.internal).

.stat.team: The Memory Management team consists of:

  Richard Brooksby (Project Manager)
  Clive Harris (Product Marketing Manager)
  Alex Parnes (Acting Product Manager)
  Mark Preece (QA Manager)
  Ken Jackson (Documentation Manager)
  Tucker Withington (Developer)
  David Jones (Developer)
  Nick Barnes (Developer)
  David Moore (Developer, about to leave)
  Gavin Matthews (Developer, just joined)
  Rod Moyse (Usability)


8. DECISIONS

This section lists the important actions that need to be taken at this stage.


8.1. Approval

.act.approve: We seek Quartet- and Board-level approval of the following points:

  .act.approve.analysis: the market and product analysis,

  .act.approve.vision: the product vision, based on that analysis,

  .act.approve.structure: the structure of the product, as described,

  .act.approve.channels: the product marketing channels.


8.2. Resources

.act.resource: The following additional resources will be required to realize 
this design:

  .act.resource.doc: Six documentor-months solid effort are needed, starting as 
soon as possible.  (For a full analysis and discussion, see 
mail.rom.1996-06-04.17-16.)

  .act.resource.tools: A developer is required to work on memory management 
tool design, implementation, and later maintenance.  (For full details, see 
mail.richard.1996-06-14.15-38.)

  .act.resource.qa: A QA person to develop test suites and manage the QA of the 
product for both internal and external customers.

  .act.resource.support: Product support.


8.3. Support

.act.support: In order to realize the potential of this technology, the Memory 
Management Group will require management support on the following issue:

  .act.support.quality: The product must come to market with a very high 
quality, particularly reliability.  The MM Group are confident that they can 
produce such a product by applying good software engineering techniques, but 
these may slow development.  We believe that the product will sink if it is not 
reliable, and we will not get a second chance.  Delay may be necessary to 
ensure quality, and management must make and support decisions based on that 
principle.


9. CONCLUSION

Lots of potential.  Lots of work.

ATTACHMENT
   "Feature Chart 2"

