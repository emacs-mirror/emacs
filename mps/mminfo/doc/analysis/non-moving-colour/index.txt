             REPRESENTING COLOUR IN A NON-MOVING COLLECTION
                       analysis.non-moving-colour
                               draft doc
                            pekka 1998-05-13

INTRODUCTION

.intro: This document explores the implementation options for representing
colour for a non-moving collection.


History

.hist.0: Written by Pekka P. Pirinen in May 1998 as a part of designing the AMS 
pool class.

.hist.1: Updated by Pekka P. Pirinen in June 1998 after the first 
implementation turned up a problem with the representation of interior grains.

.hist.2: Revised by Pekka P. Pirinen 1998-06-16 to clarify the arguments, and 
consider 


GENERAL

.techniques: There would appear to be two major techniques: "header" bits in 
the object itself, or separate bit tables [are other representations worth 
exploring?].  The usual considerations of in-band vs. out-of-band apply here.

.grey-is-special: For some tracers, it makes sense to represent grey objects 
differently, either as a part of the tracer state (recursive tracing) or in an 
explicit grey list.  The representation is constrained by the desired order of 
tracing, but whatever it might be, it typically needs header bits or bit tables 
as a backup for the eventuality of running out of space.  This changes the 
requirements on the bit representation, since most operations will use the grey 
list.  We'll consider that in a separate chapter.


HEADER BITS

.header-bits.arbitrary: The representation as header bits is pretty much 
arbitrary, about the only thing we can say is that we need two of them.  Only 
if the bits are "stolen" from some other fields, might there be additional 
design constraints.


BIT TABLES

.clever: When we represent colour by bit tables, we can get a lot of benefit by 
choosing a clever representation.  

.fixed-length: For fixed-length objects, we can just use a bit per object, and 
most problems discussed below don't apply.  For variable-length objects, we 
need two tables with a bit per allocation grain, but we often only use the bit 
of the first grain of each object, because it is wasteful to do more and that 
is the one that is easiest to find given the address of the object.

.alloc-bits: We might also represent the free/allocated state in a bit table.  
As we shall see, in some schemes it is even possible to share the same two bit 
tables for colour and alloc information.  A bit table is, however, a somewhat 
inefficient data structure for this purpose, so only the simplest pools will 
use it.

.operations: There are basically four operations that we need to perform using 
the bits: condemn, fix, scan, and reclaim.  Let us consider what these 
operations might need to do with colours: Condemn needs to turn things white 
according to some external criterion (typically everything allocated); fix 
needs to turn a given object grey; scan needs to find all grey objects and turn 
them black; reclaim needs to free all white objects (and typically count their 
total size as well).  In each case, we want to ignore free blocks (although 
reclaim might tolerate them in some algorithms).

.constraint.condemn: Condemn can be performed by a bit table copy from the 
alloc table (if one exists) to the colour tables (with special handling for 
buffers, see design.mps.buffer).  .complement: If the sense of the tables 
happens to turn out wrong, we might end up complementing the bits as we copy; 
this is not expensive compared to the other optimizations, but worth avoiding 
if we can.  It turns out that the sense of the bit tables is arbitrary, if we 
have search functions for both set and reset bits.

.constraint.fix: Setting and examining bits in a bit table is quite fast, so at 
first approximation, fixing doesn't give us any constraints, even if we have to 
look at more than one table to perform the fix.

.constraint.scan: Finding runs of bits from a bit table is also fast, so scan 
could be faster if we can contrive to find the grey objects by a bit table 
search.  Accordingly, we need a grey bit table, where a bit is on (or off) iff 
it's the first grain of a grey object.  We'll notate this as G for grey and -G 
for not grey (the actual bit value being underspecified, see .complement).  The 
other table will then encode the difference between black and white; for 
historical reasons, we'll call it the white table, and notate it W and -W.  
This doesn't tell us what the state of the white table should be for grey 
grains, but we shall see that there's an optimal answer to that from other 
constraints.

.constraint.scan.free: To avoid finding free blocks in scan, they must be set 
to -G in condemn.  .constraint.scan.interior: To avoid finding interior bits of 
objects in scan, they also must be set to -G in condemn.

.constraint.reclaim.interior: For optimum reclaiming efficiency, the interior 
bits should have the same encoding in the white table as the first bit of the 
block -- it turns out this can be achieved at a cost less than handling 
interior bits separately in reclaim.  .condemn.op: In condemn, we don't know if 
the object is going to survive and we don't want to spend any effort on finding 
where each object starts, so the obvious thing is to make the whole object (-G 
&) W.  .scan.op: We can get the interior bits right by turning the whole object 
(-G &) -W when it is scanned.  This is fairly cheap since scanners typically 
have to know the size of each scanned object anyway, or can discover it cheaply.

.constraint.reclaim.bit: The white table can be used as an alloc bit table, 
dispensing with a separate data structure, if free blocks are set to W.  In 
this sceme, you couldn't allocate from a condemned segment during GC, but 
reclaim would require no bit table operations at all (except possibly counting 
the set bits if we need to keep track of the free size).  When using other 
alloc bit table schemes, the optimum would be to reclaim with a bit table copy 
without having to locate each dead object -- again, this can be achieved by 
setting free blocks to W.  .constraint.reclaim.no-bit: When not using an alloc 
bit table, we need to find ranges of contiguous white objects, to add them to 
the free list, so free blocks should be -W.  I think we can safely assume we 
won't need to locate every reclaimed object separately.

.interior.fix: If interior pointers can occur during fixing, we have to pay the 
cost of determining whether they are interior (independent of whether such a 
fix should preserve the object or not).  If we scan directly from fix 
(recursive tracing), we have to determine it immediately.  .interior.determine: 
Doing this by skipping objects from the beginning of the segment/page is slow, 
so if the format doesn't offer any more efficient way of doing it, we should 
consider keeping a separate map of object boundaries (another bit table, 
probably [the possibilities of this should be explored a bit - pekka 
1998-06-22]).  .fix.blacken: The same applies to turning the object directly 
black (by various optimizations), although here we might have the option of 
turning it grey instead, if there's a possibility of its being interior.

.interior.scan: If scan sweeps the segment using a bit table search for G 
grains, fixing an interior grain would cause the search to find it.  We then 
have to determine whether it's interior, and we have basically the same 
options.  In this case, however, the cost of skipping objects from the 
beginning of the segment/page is more acceptable, because we can do it along 
with the sweep and thus share the cost between all the fixes done, instead of 
paying separately for each one.  However, if scan does this, the bit table 
search doesn't really bring much benefit anymore.

.constraint.scan.interior.blacken: Interior grains that have been fixed would 
also make blackening objects during scan more expensive, if we cannot rely on 
interior grains being being W before the scan.  .fix.op: Therefore, we conclude 
that fix should only change the grey table, to turn grains G & W.

.interior.ambiguous-only: If interior pointers only occur from ambiguous 
references, we can keep track of whether there have been any ambiguous fixes to 
the segment and scan by bit table search if there are none.  We could keep even 
closer track of where the ambiguous fixes are, but that's probably not 
cost-effective.

.no-scan-search: When interior fixes are so common that scanning almost always 
uses the Skip method as described in .interior.scan, .constraint.scan doesn't 
apply anymore.  This doesn't allow any improvements though, because there are 
no good opportunities for improvement left and all the other constraints still 
apply.  In particular, the reclaim constraints make it useful to have a white 
table, with W for white and -W for black (as there are no grey objects during 
reclaim).  Furthermore, .constraint.scan.interior.blacken still implies fix 
shouldn't change the white table, so the other table needs to distinguish 
between black and grey, so we might use the same notation for it: G and -G.  
The rest then falls into place as before, and while we have more freedom of 
choosing grey table encodings for some things, I can't think of anything to do 
with it.



GREY LISTS

[work out the consequences later]

