                 USING ELLIPSIS FUNCTIONS IN STANDARD C
                        analysis.ansic.ellipsis
                               draft doc
                            nickb 1996-10-21

Foreword

.scope: This is a description of the use of ellipsis functions in ISO Standard 
C (standard.ansic).

.readership: This is intended to be readable by any interested Harlequin 
employee.

.ref: References are to the standard.

.disc: Use this description at your own risk. Let the standard be your guide.

Body

.def: An ellipsis function is one which has an ellipsis in its definition.

.proto: If such a function is called using an expression with a type that does 
not include a prototype, behaviour is undefined (6.3.2.2).

.compat: If such a function is called using an expression with an incompatible 
type, behaviour is undefined (6.3.2.2).

.conv: Otherwise: the arguments are converted, as if by assignment, to the 
types of the parameters (6.3.2.2, see 6.2 for conversion, in particular 6.2.1.5 
and 6.2.2.3). Arguments for the ellipsis are converted using the default 
argument promotions (float -> double, char, short, int bit-field -> int if it 
fits, unsigned int otherwise).

.conv.not: i.e. arguments being passed in an ellipsis, with type other than 
float, char, short, and int bit-field are not converted at all. We should 
probably have some rule about arguments like this (e.g. all integers passed as 
unsigned long, all floating points passed as long double, all object pointers 
passed as void *, all function pointers passed as void(*)(void)).

.tyname: va_arg has the following restriction (7.8.1.2): "The parameter _type_ 
is a type name specified such that the type of a pointer to an object that has 
the specified type can be obtained simply by postfixing a * to _type_." So 
_type_ cannot be "void (*)(void)". It can, however, be foo, where typedef void 
(*foo)(void).

