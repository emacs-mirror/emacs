              BARRIERS FOR ASYNCHRONOUS GARBAGE COLLECTION
                           analysis.async-gc
                             incomplete doc
                            pekka 1998-02-05

INTRODUCTION

.intro: This document analyses the mechanisms for doing garbage collection 
incrementally or concurrently with the user program.


History

.hist.0: Written by Pekka P. Pirinen in December 1997 and January 1998.  
book.jones96 was a valuable source of different barriers.  Gavin and Tucker 
provided some comments.  The Mutator Actions section has been adapted from 
design.mps.tracer(0).


THE MUTATOR AND THE COLLECTOR

.divide: In order to analyse asynchronous GC, we notionally divide the program 
into to semi-independent processes: the mutator and the collector.
.mutator: The mutator executes the user code, which allocates objects and 
"mutates" the reference graph.  While mutating, it implicitly frees storage by 
modifying existing objects so that some objects become unreachable.
.collector: The collector executes the GC code, which discovers unreachable 
storage and reclaims it.

.root: When we discuss mutator colour (analysis.tracer.mutator-colour), we take 
mutator state to include all the program state that the mutator can act on 
directly.  More precisely, anything that the mutator can access without 
regulation by the collector.  In practice, this usually means it contains the 
registers of any processors that the mutator is running on, the stacks of 
mutator threads, and global static data.

.not-root: If a barrier can be placed between some object and the mutator, then 
we don't need to consider it part of the mutator state.  This includes 
protectable static data and stacks protected by stack barriers (see .stack).  
Such things might still be roots in the sense that they are always in the 
initial grey set.


Mutator Actions

.breakdown: The following is a breakdown of all the possible mutator actions 
into four simple operations on the reference graph.  Complex operations are 
equivalent to a sequence of these operations as far as the tracer is 
concerned.  This breakdown is mostly relevant for formal proofs of tracer 
correctness.

.next-to-root: We represent the mutator state as the root node of the graph.  
The mutator can only affect the graph adjacent to the root, because it doesn't 
know the addresses of any other objects.

.def.load: The "load" operation adds an edge from the root to an object by 
loading a reference from an object into the root.  This is equivalent to the 
mutator dereferencing a pointer.  If the mutator overwrites a reference in a 
register with the loaded reference then the operation is equivalent to a load 
followed by a drop.

Examples:

  x = y->z;

  ld [i4+4],i5

.fig.load: The mutator "load" operation


.def.store: The "store" operation adds an edge from an object adjacent to the 
root to another object adjacent to the root by storing a reference in that 
object.  If the mutator overwrites a reference in the object with the new 
reference then the operation is equivalent to a store followed by a splat.

Examples:

  y->z = x;

  ld i5,[i4+4]

.fig.store: The mutator "store" operation


.def.splat: The "splat" operation removes an edge from an object adjacent to 
the root to another object.

Examples:

  x->y = NULL;

  ld g0,[i4+4]

.fig.splat: The mutator "splat" operation


.def.drop: The "drop" operation removes an edge from the root to a
node adjacent to the root.

Examples:

  x = NULL;

  or g0,1024,i4  (where i4 previously contained a pointer)

.fig.drop: The mutator "drop" operation



INVARIANTS

.invariant.weak: To guarantee that the tracer will not miss any reachable 
nodes, we must ensure that, at all times during the trace, all white objects 
reachable from a black object are also reachable from a grey object through a 
chain of white objects (this is called "having a white path").  We call this 
"the weak tricolour invariant".

.invariant.strong: To guarantee that the tracer does not miss any references 
between reachable nodes for thorough tracing, we must ensure there are no 
references from a black object to a white object.  We call this "the strong 
tricolour invariant".

.scan.weak: If we're using the weak invariant, then instead of scanning 
something to turn it black, a grey copy of it can be made.  Yuasa used this 
technique for the mutator.


BARRIERS

.barrier: Barriers are used to maintain the tricolour invariant and the 
consistency of the mutator's view of the objects.  "Read-barriers" intercept 
mutator loads and "write-barriers" mutator stores and splats.  The collector 
gets a chance to perform some action, before the access completes.


Page-level barriers

.page: Hardware barriers on standard platforms will have to work at a large 
granularity.  Typically, large blocks containing many object can be read- or 
write-protected, and the resulting exception handled by the collector.  In this 
document, we are not concerned about the details of the protection mechanism, 
so we'll just call the unit of protection "a page".

.scalable: The cost of handling such exceptions is typically so large that we 
want to avoid repeats.  So we're particularly interested in barriers that can 
be efficiently implemented at page granularity.  We'll call them "scalable 
barriers".

.whole-page: Locality suggests that repeated accesses to the same page are 
likely, so on the first access, we'll want process every object on the page to 
remove the condition that caused the barrier to be erected.  This means that 
even if the exact address being accessed and the data being transferred could 
be determined (and on some platforms it's quite hard), we are not interested in 
them because they apply to one tiny part of the page only.  Furthermore, all 
objects on the page should ideally be in the same condition, so that they can 
all be processed now, and the possibility of having to reprotect the page later 
is avoided.  This is hard to achieve in non-copying collection.

.non-scalable: Non-scalable barriers are still interesting, as they're suitable 
for implementation in software.


Barrier Descriptions

.action: In the following sections, we categorize the barrier algorithms for 
preserving tricolour invariants on the basis of the action taken at the barrier.
We consider all the simple actions one could take:
.action.scan: One option is to scan (or copy, see .scan.weak) one of the nodes 
involved, turning it black.
.action.shading: A common action is to turn a node grey, if is was white; we 
call this "shading".
.action.grey: Turn a node grey from black.
That's all the useful actions, because turning a node white would break the 
invariant, as would turning a node black without scanning it [actually, under 
the weak invariant, it could be valid, if there were other reasons for assuming 
it didn't refer to any white objects without a white path, but I can't think of 
a simple action that would ensure that, other than .scan.weak].

.desc.write-barrier: In the write-barrier descriptions, there's a write-barrier 
on node A and the mutator attempts to update it from referring to node B to 
refer to node C.  [Add figure]

.desc.read-barrier: In the read-barrier descriptions, there's a read-barrier on 
node A and the mutator attempts to update the root by reading a reference to C 
from node A.  [Add figure]

.strong: If a barrier preserves the strong tricolour invariant, we call it 
"strong", otherwise "weak".


Invariant Barriers for a Grey Mutator

.barrier.steele: A write-barrier on black: when hit, turn A grey only if C is 
white.  This is strong, but not scalable.

.barrier.steele.scalable: [Change this to .barrier.boehm] A write-barrier on 
black: when hit, turn A grey.  This can be regarded as a scalable variant of 
.barrier.steele.  This is strong and scalable, but regresses the trace a bit.

.barrier.dijkstra: A write-barrier on black: when hit, shade C.  This is 
strong, but not scalable.

.barrier.flip: A write-barrier on black: when hit, flip.  This is not actually 
a barrier, but merits consideration here, because it's an alternative to true 
grey mutator barriers.  This is strong and scalable.

.strong-grey-barriers: The strong invariant cannot be guarded from a grey 
mutator without a write-barrier on black.  This turns out to be sufficient to 
preserve the invariant as well, and the four options above cover all the useful 
actions, so they are the only strong grey mutator barriers (using the actions 
described in .action).

.weak-grey-barriers: A grey mutator might contain a white reference that is the 
only reference to that object.  Writing that to a black object and then 
dropping the reference would break the weak invariant.  Since we can't prevent 
the mutator from dropping references, we must put some kind of write-barrier on 
black -- but this leads to one of the strong barriers.  Therefore there are no 
weak grey mutator barriers.


Invariant Barriers for a Black Mutator

.barrier.unflip: A read barrier on grey: when hit, revert the mutator to grey.  
This is not actually a barrier, but merits consideration here, because it's an 
alternative to true black mutator barriers.  This is strong and scalable, but 
regresses the trace.

.barrier.baker: A read-barrier on grey: when hit, shade C.  This is strong and 
but not scalable.

.barrier.appel-ellis-li: A read-barrier on grey: when hit, scan A to turn it 
black, ensuring C is not white.  This could be considered a scalable variation 
on .barrier.baker.  This is strong and scalable, but less so in a non-copying 
collection because then the page is likely to become grey again.

.strong-black-barriers: The mutator can't stay black according to the strong 
tricolour invariant, unless there's a read barrier on grey.  It turns out to be 
sufficient to preserve the invariant as well, and the three options above cover 
all the useful actions, so they are the only strong barriers for a black 
mutator (using the actions described in .action).

.barrier.ap: A write-barrier on grey and white: when hit, shade B.  This is 
weak and not scalable.  (Actually, Yuasa had a write-barrier on everything, but 
grey and white is enough, because all black-to-white pointers must have been 
ultimately read out of grey or white objects.)

.barrier.ap.scalable: A write-barrier on grey and white: when hit, scan A.  
This is weak and scalable (as much as any barrier can be in a non-copying 
collection), but in page mode, the white barrier will cause all garbage on the 
same page to survive.

.barrier.pirinen: A write-barrier on grey & a read-barrier on white.  When the 
write barrier is hit, we shade the old referent B.  When the read barrier is 
hit, we shade C.  This is weak and not scalable.  This barrier works because 
all black-to-white pointers must have been ultimately read out of grey or white 
objects.  If grey, we rely on the write barrier to ensure that it will be 
scanned eventually (as for .barrier.ap); if white, we turn it grey, thereby 
reducing it to the previous case.  .invariant.feeble: Note that this barrier 
actually maintains an invariant that is slightly stronger than .invariant.weak, 
namely that all white objects referenced from a black objects are also 
referenced from a grey objects.

.barrier.pirinen.scalable: A write-barrier on grey & a read-barrier on white.  
When the write barrier is hit, we scan A to turn it black before the store.  
When the read barrier is hit, we shade A (or scan A).  This is a scalable 
variant of barrier.pirinen, but in page mode, the white barrier will cause all 
garbage on the same page to survive.

.weak-black-barriers: To preserve the weak invariant, we must not lose any 
references from grey to white, so we must have a write-barrier protecting 
those.  Additionally, we must do something about references from black to white 
objects that aren't directly referenced from grey.  Either we prevent them or 
we make sure we don't lose the reachability from grey.  The latter requires a 
write barrier on white (.barrier.ap).  The former requires that we catch such 
references when they're read from white (.barrier.pirinen), or when they're 
written to black -- except that the mutator is black, so that's a read barrier 
on white, too (attempts to handle the mutator separately from the black objects 
in the heap lead to .barrier.dijkstra).  [There must be a way of expressing 
this argument more clearly!  Pekka 1998-02-03]  So the options above are the 
only weak barriers for a black mutator (using the actions described in 
.action).


Switching and Mixing Invariant Barriers

.switch: Since these barriers maintain an invariant, the collector can switch 
from one barrier to another during the trace.  However, if it switches between 
weak and strong barriers, then it can only maintain the weak invariant, since 
the strong invariant implies the weak one, but not vice versa.

.mix: We can also mix invariants, to get a guarantee that the tracer will not 
miss a certain subset of references.  This is useful in a mixed copying and 
non-moving collection, where the tracer needs to find and fix all the 
references of the copied objects (more about that in the next section), but is 
allowed to miss references to the stationary objects.  This could be regarded 
as a form of barrier switching, where the barrier to use is chosen on the basis 
of whether the reference it protects could possibly refer to a moveable object 
(in terms of .desc.write-barrier and .desc.read-barrier, if C could be 
moveable).


Barriers for Mutator Consistency

.collector-changes: The only mutator-visible change that a collector might do 
is to move some objects and update pointers to them.  If the collector does 
this, then we need to ensure that all the pointers get updated, and that the 
mutator sees a consistent view of the objects.

.move: There are two types of moves: copying and compacting.  .move.copying: 
Copying collectors copy white objects (and then immediately make them grey).  
.move.compacting: Compacting collectors move surviving objects around, 
typically in ways that destroy the old copies.

.moved.consistency: Mutator consistency requires that once an object has been 
moved, the mutator should only see one of the copies at a time.  If pointer 
equality is not required, then we can relax this and just require that the 
mutator sees both copies being equal (for the appropriate definition of equal, 
see paper.baker93a).  Of course, if the old copy has been destroyed, either by 
the compactor sliding some other object on top of it, or by the tracer 
replacing it with a broken heart, then things are very simple: the mutator must 
see the new copy.

.moved.old-copy: If the mutator can see the old copy, we must have a 
write-barrier on it and duplicate the writes in the new copy.  (The 
Nettles-O'Toole barrier is basically a combination of this and 
.barrier.steele.scalable.)

.moved.new-copy: If the mutator must see only the new copy, then there has to 
be a read barrier on any objects that might still contain pointers to the old 
copy and that the mutator could see, and on hitting it, we must update those 
pointers.

.moved.backpointers: Techniques for maintaining backpointers (for updating 
references as the object is moved) can be divided into two categories: 
out-of-line and in-line.  In-line techniques reuse pointer slots in the objects 
for backpointers, and cannot really be used incrementally.  Out-of-line 
techniques might require a write-barrier to keep them up to date.  [Obviously, 
one could elaborate on this.]

.copied.pointers: Since copying happens during the trace, we can combine 
updating the pointers with the rest of the trace.  Making sure no pointers are 
missed requires a thorough trace.  A thorough trace implies a strong tricolour 
invariant (see .invariant.strong).  .copied.pointers-and-new-copy: We note that 
if we only copy after the flip, then any of the strong barriers will ensure 
mutator consistency, since they fill the conditions of .moved.new-copy.  If we 
copy before the flip, we need a separate barrier for mutator consistency.

.compacted.pointers: Updating pointers after compaction requires a separate 
sweep over the heap.  A read-barrier is required over any parts that haven't 
yet been updated.  [This could be developed further.]


Other Uses for Barriers

.advance: While the mutator is grey, a barrier on white could be used to 
advance the trace by greying the accessed object.

.lazy-copy: When copying large objects we could raise a read barrier on the 
destination and copy the data when required.

.refsets: Write-barriers can be used to keep remembered sets up to date.


Some Implementation Techniques for Barriers

.object-table: Object table methods could be considered combined read- and 
write-barriers.

.stack: Ordinary software barriers on stacks are expensive, and hardware 
protection is impossible on many architectures (some can handle protection 
faults on stacks, by handling the fault on a separate stack), but stacks can 
have special kinds of barriers on them: An entire stack can be effectively 
protected if there is a way for the collector to run before the thread is 
resumed.  Sometimes this can be achieved by manipulating thread state.  Parts 
of stacks can be protected by inserting a continuation at some stack frame that 
will call the collector before invoking the original continuation.  Such 
"functional" barriers will only work, if we know that the mutator will not 
refer to random stack frames lower down in the stack.

.closure: A barrier can be placed on the private data of a closure using a 
technique similar to a continuation barrier on a stack: replace the closure 
code with collector code to process the data (and then restore the original 
code).  While and Field did this for the Spineless Tagless G-machine using 
indirect invocation.

.delayed: Boehm's dirty bits trick could be considered a delayed barrier, a 
variation on .barrier.steele.scalable.  But not all write-barriers can be 
delayed in this manner.

.combine: We can also combine these barriers to create more complicated 
barriers.  See .moved.old-copy for an example.  [Somebody should work out 
whether there are any other interesting combinations.]

