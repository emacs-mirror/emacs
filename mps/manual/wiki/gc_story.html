<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <title>MPS Wiki: Story of a Garbage Collection</title>
  <style type = "text/css">
    <!--
    div.banner {text-align:center}
    dt {font-weight:bold}
    
    -->
  </style>
</head>

<body>

<div class="banner">

<p>
<a href="/">Ravenbrook</a>
/ <a href="/project/">Projects</a>
/ <a href="/project/mps/">Memory Pool System</a>
/ <a href="/project/mps/master/">Master Product Sources</a>
/ <a href="/project/mps/master/manual/">Manuals</a>
/ <a href="/project/mps/master/manual/wiki/">Wiki</a>
</p>

<p><i><a href="/project/mps/">Memory Pool System Project</a></i></p>

<hr />

<h1>MPS Wiki: Story of a Garbage Collection</h1>

<address>
<a href="mailto:rhsk@ravenbrook.com">Richard Kistruck</a>,
<a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>,
2006-11-30
</address>

</div>

<p> This wiki article contains incomplete and informal notes about the MPS, the precursor to more formal documentation.  Not confidential.  Readership: MPS users and developers.  </p>

<h2>Introduction</h2>

<ol>
  <li> What triggers a GC? </li>
  <li> How does it advance? </li>
</ol>

<p>Here's how it happens in the MPS, since about 2001-03.</p>

<p><em>(Note that this is an early (and incomplete) design and implementation of a pool-independent chain mechanism.  It replaced the earlier pool-action model.)</em></p>

<p>This story is for AMC pools in a VM arena.</p>


<h2>Concepts and Datastructures</h2>

<p><em>(The diagram below illustrates several chains, which could all exist simultaneously.  The middle chain, with two generations and one AMC pool, is typical).</em></p>

<p><img src="chain3small.png" alt="diagram of chains, GenDescs, and PoolGens, derived from //info.ravenbrook.com/project/mps/master/code/chain.h#9" /></p>

<dl>
  <dt>zone</dt>
  <dd>A stripe of memory.  The MPS divides the address space into 32 zones (typically).</dd>
</dl>


<h2>Set-up</h2>

<p><em>(Referring to diagram above, see the middle chain: a chain with two generations and one AMC pool)</em></p>

<p>Say the mutator wants a 100 KB nursery, a 200 KB intermediate generation, and the rest for older stuff.  Mutator creates an array of 2 mps_gen_param_s structs:</p>
<ul>
  <li> { 100KB, 90% mortality }, </li>
  <li> { 200KB, 50% mortality } </li>
</ul>

<p>Mutator passes this array to mps_chain_create, and then uses the chain to create a new AMC pool.</p>

<p>The Chain contains an array of two GenDescs: numbers 0 and 1.  The AMC pool creates *three* PoolGens:</p>
<ul>
  <li> PoolGen nr=0 is linked to GenDesc at index 0;</li>
  <li> PoolGen nr=1 is linked to GenDesc at index 1;</li>
  <li> PoolGen nr=2 is linked to the arena-wide "topGen" GenDesc.</li>
</ul>

<p>What specifies the generation number?  Two different (and contradictory) things:</p>
<ul>
  <li> the Chain has an array of GenDescs: the GenDesc's <strong>index</strong> in this array is its "generation";</li>
  <li> the PoolGen struct has <code>Serial nr;  /*generation number*/</code>: this <strong>PoolGen "nr"</strong> is its "generation".</li>
</ul>
<p>(The GenDesc itself, which has size and mortality and is perhaps the place you'd expect, does not store a generation number).</p>

<p>The PoolGen newSizes are zero.  The GenDesc zonesets are empty.</p>


<h2>Accumulating objects</h2>

<p>As the mutator allocates, and as minor collections promote and preserve objects, each "generation" keeps track of its <strong>size</strong> and <strong>location</strong>.  For each new segment that AMCBufferFill gets:</p>
<ul>
  <li>the segment's size is added into the PoolGen's <strong>newSize</strong> accumulator;</li>
  <li>the segment's zoneset is unioned into the GenDesc's <strong>zoneset</strong> accumulator (by calling PoolGenUpdateZones).</li>
</ul>

<p>When AMCBufferFill asks for new memory segments, it passes the PoolGen's "nr" generation number (0 for mutator allocation in the nursery, 1 or 2 etc when preserving objects) as a segment-placement preference (with SegPrefGen).</p>

<p>ArenaVM tries hard to keep all segments for a given SegPrefGen-number together in the same zone or zones, and separate from the zones used for all other things.  (Such as: zones used by other generation numbers, blacklist zones, and as-yet unused zones).</p>

<p>So <em>hopefully</em> the zoneset for a "nr" generation number will be disjoint from other uses of memory.  [Note: if a zoneset gets polluted because of address-space pressure, there's currently no way to 'heal' it again afterwards.  That's not good enough for a long-running client.  See also the "barge" flag in arenavm's pagesFindFreeWithSegPref().  RHSK 2006-12-04]</p>


<h2>Triggering a collection</h2>

<p>All collections start from ArenaStep().  There are two routes into ArenaStep: an explicit call to mps_arena_step(), or an implicit one from the 'time-stealing' ArenaPolls in mps_alloc, mps_reserve, and mps_alloc_pattern_end/reset.</p>

<p>There are three trigger conditions:</p>

<p>Firstly, lots of "spare time".  An MPS client's explicit call to mps_arena_step() can say "I've got some spare time" by passing a non-zero interval and multiplier.  If (interval x multiplier) is big enough, and it's been long enough since the last one, <strong>start a full collection</strong>.</p>

<p>Secondly (when ArenaStep calls TracePoll) the infamous "dynamic criterion" is assessed.  The MPS needs quite a lot of memory to do a full collection.  Memory is being gobbled up by client allocation, and if the MPS waits too long it could get completely 'wedged' or 'chock-a-block', with insufficient free space to do a full collection.  It must start a full collection soon enough that we don't completely run out of memory in the middle of doing it.  Calculating this criterion is tricky, but I think the idea is:</p>

<ol>
  <li> if we started a full collection now, how much extra forwarding-space would the collector use, before reclaiming?;</li>
  <li> and how much additional client-allocation would occur in the meanwhile (while the MPS is doing this incremental full collection)?;</li>
  <li> add these together and compare it against ArenaAvail.</li>
  <li> if we're about to run out of room (according to our hopefully pessimistic estimates), then <strong>start a full collection</strong> now.</li>
</ol>

<p>Both these full-collection triggers call traceStartCollectAll().</p>

<p>Thirdly, if no full collection is triggered, look for a chain whose GenDesc 0 is 'over capacity': the sum of the chain's PoolGen 0 newSizes exceeds the GenDesc's capacity.  If there's a choice, pick the chain whose Gen 0 is most over capacity.  An over-capacity chain will <strong>start a minor collection</strong>, by calling ChainCondemnAuto().  [Note that we only look at "newSize".  I don't understand what this means, or how it differs from "totalSize".  It may be a consequence of nailing, or ramps, perhaps?  RHSK 2006-12-01]</p>


<h2>Full collection: what gets condemned</h2>

<p>traceStartCollectAll() finds all chains, all the PoolGens in Gen 0 of those chains, all the pools those PoolGens are part of, all the segments of those pools, and condemns all those segments:</p>

<pre>traceStartCollectAll():
  traceCondemnAll()
    for chain in all chains:
      ChainCondemnAll(chain)</pre>

<pre>ChainCondemnAll(chain):
  for PoolGen in GenDesc 0 of chain:
    for Seg in (PoolGen->pool)->SegRing:
      TraceWhiten(Seg)</pre>

<p>So all automatic (garbage collected) pools <strong>must</strong> have a chain (even if they aren't generational) or their objects won't get condemned.  AMS pools have a Gen-0-only chain.  LO and AWL pools also have a Gen-0-only chain [but their segment-placement preference is hardwired to SegPrefGen-number 1!  Beware!  RHSK 2006-12-01].</p>


<h2>Minor collection: what gets condemned</h2>

<p>The first step is to choose which generations to condemn.  The minor collection looks at one chain, and will always condemn the nursery, plus any adjacent higher generations that are also over-capacity.  (So if gens 0, 1, and 3 are over-capacity, but 2 is not over-capacity yet, then a minor collection will condemn 0 and 1, but not 2 or 3).  ChainCondemnAuto() finds the <strong>list of adjacent GenDescs</strong> that are over-capacity in this chain only.</p>

<p>The second step is not obvious: these GenDescs have been recording the zoneset of all the segments ever added into that GenDesc (as long as the pool noted it by calling PoolGenUpdateZones).  ChainCondemnAuto() calls TraceCondemnZones() to condemn <strong>the full zoneset ever touched</strong> by a segment in any of the condemned GenDescs.</p>

<p>Why condemn the whole zoneset?  Well, minor collections rely on remembered sets to work well, and the MPS implements remembered sets by recording the zone summary of references in a segment.  We hope that the references that will keep the survivors alive are concentrated in only a few older-generation pages, which we can cheaply find using their zone summaries.  Because of this, if the nursery we are trying to collect lives in zoneset 23 (say), we may as well collect everything in zoneset 23 at the same time, even if it also contains objects from a different chain.</p>

<p>So the major determiner of which objects will get collected together is what <strong>SegPrefGen-number</strong> gets passed in the call to pagesFindFreeWithSegPref() when allocating a new segment.  The generational AWL pool takes this number from the PoolGen's "nr" field.  Some other pools hardwire it (AWLGen = 1, LOGen = 1).  Some do not set it (AMS).</p>

<p>To condemn the zoneset, TraceCondemnZones() uses the SegFirst/SegNext() iterator, and for <strong>every segment that is wholly within the condemned zones</strong>, it calls TraceAddWhite(seg).</p>

<p>WARNING: AWL and LO pools do not take a chain argument; they each have a 'hidden' Gen-0-only chain with hardwired values.  AWL's Gen-0 capacity is hardwired to SizeMAX KB, so AWL objects will never trigger a minor collection.  LO's Gen-0 capacity is hardwired to 1024 KB, so each 1 MB of new LO allocation will trigger a minor collection; the condemned zones may contain AMC-generation-1 objects.</p>




<h2>Progress of a collection</h2>

  
<h2><a id="section-B" name="section-B">B. Document History</a></h2>

<pre>
  2006-11-30  RHSK  Created, incomplete.
  2006-12-01  RHSK  What triggers a GC?
  2006-12-04  RHSK  What triggers a GC: clarify and expand, add diagram
</pre>


<h2><a id="section-C" name="section-C">C. Copyright and License</a></h2>

<p> This document is copyright &copy; 2006 <a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>.  All rights reserved.  This is an open source license.  Contact Ravenbrook for commercial licensing options. </p>

<p> Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: </p>

<ol>

<li> Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. </li>

<li> Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. </li>

<li> Redistributions in any form must be accompanied by information on how to obtain complete source code for the this software and any accompanying software that uses this software.  The source code must either be included in the distribution or be available for no more than the cost of distribution plus a nominal fee, and must be freely redistributable under reasonable conditions.  For an executable file, complete source code means the source code for all modules it contains. It does not include source code for modules or files that typically accompany the major components of the operating system on which the executable file runs. </li>

</ol>

<p> <strong> This software is provided by the copyright holders and contributors "as is" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability, fitness for a particular purpose, or non-infringement, are disclaimed.  In no event shall the copyright holders and contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. </strong> </p>


<hr />

<div class="banner">

<p><code>$Id$</code></p>

<p>
<a href="/">Ravenbrook</a>
/ <a href="/project/">Projects</a>
/ <a href="/project/mps/">Memory Pool System</a>
/ <a href="/project/mps/master/">Master Product Sources</a>
/ <a href="/project/mps/master/manual/">Manuals</a>
/ <a href="/project/mps/master/manual/wiki/">Wiki</a>
</p>

</div>

</body>

</html>
