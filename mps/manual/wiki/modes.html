<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <title>MPS Wiki: Modes of use of MPS</title>
  <style type = "text/css">
    <!--
    div.banner {text-align:center}
    dt {font-weight:bold}
    
    -->
  </style>
</head>

<body>

<div class="banner">

<p>
<a href="/">Ravenbrook</a>
/ <a href="/project/">Projects</a>
/ <a href="/project/mps/">Memory Pool System</a>
/ <a href="/project/mps/master/">Master Product Sources</a>
/ <a href="/project/mps/master/manual/">Manuals</a>
/ <a href="/project/mps/master/manual/wiki/">Wiki</a>
</p>

<p><i><a href="/project/mps/">Memory Pool System Project</a></i></p>

<hr />

<h1>MPS Wiki: Modes of use of MPS</h1>

<address>
<a href="mailto:rhsk@ravenbrook.com">Richard Kistruck</a>,
<a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>,
2006-06-15
</address>

</div>

<p> This wiki article contains incomplete and informal notes about the MPS, the precursor to more formal documentation.  Not confidential.  Readership: MPS users and developers.  </p>

<p>This article has the following sections:</p>
<ul>
  <li>Modes of use of MPS</li>
  <li>Objects, cells, and references</li>
  <li>Using unmanaged workspace</li>
</ul>

<p><strong>Warning: this document is very young, and does not represent consensus, let alone truth!</strong>  RHSK 2006-06-16.</p>

<h2>Modes of use of MPS:</h2>
<dl>
  <dt>.manual:</dt>
  <dd>
    <p>= no collection</p>
    <dl>
      <dt>.manual.malloc:</dt>
      <dd>pure malloc/free replacement</dd>

      <dt>.manual.mps-friendly:</dt>
      <dd>an MPS-friendly interface: ap, SAC, etc</dd>

      <dt>.manual.c++:</dt>
      <dd>C++ friendly (not sure what this involves)</dd>

      <dt>.manual.stl:</dt>
      <dd>packaged as allocator for a C++ STL (Standard Template 
        Library) allocator</dd>
    </dl>
  </dd>
  
  <dt>.freeless:</dt>
  <dd>
    <p>= malloc, with free a no-op</p>
    <p>Probably formatless and fully ambig (Boehm-like).</p>
  </dd>
  
  <dt>.attachable:</dt>
  <dd>
    <p>(for .manual and .freeless) attach without source code changes, 
      or without a re-compile, or without a re-link, 
      or even without stopping mutator?</p>
  </dd>
  
  <dt><a id="unmanaged-workspace">.unmanaged-workspace:</a></dt>
  <dd>
    <p>= workspace (eg. registers and stack) are not scanned</p>
    
    <p>This should be the simplest, but surprisingly it 
      doesn't seem to be well defined -- the MPS seems to lack 
      specified protocols for it!
      See 
      <a href="#using-unmanaged-workspace">Using unmanaged workspace&darr;</a>.</p>
    
    <p>The simplest starting point is probably:
      formatted, exact, non-incremental, and single-threaded.
      (No protection, no stack or register scanner).  
      This is fine for:</p>
    <ul>
      <li> adding GC to part of bigger application;</li>
      <li> implementing a simple language in C.</li>
    </ul>
    
    <p>It's what the SC integration wants.</p>
      
    <p>We're not sure what the limits are.  Multi-threaded might 
      be very hard.</p>
  </dd>
  
  <dt>.ambiguous-workspace:</dt>
  <dd>
    <p>= workspace (eg. registers and stack) are scanned ambiguously</p>
    <p>This is our Dylan-like bread and butter:
      incremental, generational, mostly copying, 
      formatted, ambiguous reg+stack, 
      supports foreign code, multi-threaded.  
      And we do location-dependency, weakness, finalization, ...</p>
  </dd>
  
  <dt>.exact-workspace:</dt>
  <dd>
    <p>= workspace (eg. registers and stack) all scanned exactly</p>
    <p>Might be useful for someone writing their own compiler.  
      You wouldn't want to write this code in C.</p>
  </dd>
</dl>

<h2>Objects, cells, and references</h2>

<p><em class="note">
  [Note: I just made up most of the terminology in this section; 
  it may not be helpful.  RHSK 2006-06-16]
</em></p>

<p>An <dfn>object</dfn> is some memory that contains data and cells.  
  A <dfn>cell</dfn> is memory that stores one reference.  
  A <dfn>reference</dfn> is a stored instance of a value that 
  may designate an object.</p>

  
<h3>Types of object:</h3>
<dl>
  <dt>Root object (in MPS terminology)</dt>
  <dd>&equiv; an object that the mutator has 
    designated as a root.
  </dd>

  <dt>Reachable object (in MPS terminology)</dt>
  <dd>&equiv; a root, or an object reachable from 
    a root via scanned references.
  </dd>
</dl>

<p>Note that the MPS does <strong>NOT</strong> assume that registers, 
  the stack, etc, are roots.  This is a little unusual.  This means 
  that "reachable" means "reachable to the collector"; the mutator 
  may be able to access references that are not "reachable".</p>

<h3>Types of cell:</h3>
<dl>
  <dt><a id="managed-cell">Managed</a></dt>
  <dd>&equiv; a scanned cell in a reachable object.
    If the reference in the cell is TO a 
    reachable object, then the MPS ensures the reference 
    remains fresh.  
    (The MPS must ensure the referent does not get 
    reclaimed.
    If ambiguous, pins referent.  
    If exact, may update the reference.)
  </dd>

  <dt><a id="unmanaged-cell">Unmanaged</a></dt>
  <dd>&equiv; a cell that is not managed.
    A reference stored in an unmanaged cell is not useful 
    unless the reference is guaranteed or quarantined.
    (The MPS cannot see the reference.)
  </dd>
</dl>

<h3>The state of a reference:</h3>
<p>A reference may be:</p>
<dl>
  <dt><a id="fresh-reference">Fresh</a></dt>
  <dd>&equiv; a reference that the MPS has kept up-to-date.  
    (The definition 
    of 'up-to-date' depends on context.  For example, for a weak 
    reference, 'up-to-date' means it either points to the intended 
    object, or it has been nulled out.)
  </dd>

  <dt><a id="stale-reference">Stale</a></dt>
  <dd>&equiv; a reference that has not been kept up-to-date, and 
    may now 
    designate an out-of-date copy of the object, some other object, 
    random memory, or unmapped memory.
  </dd>
</dl>


<h2><a id="using-unmanaged-workspace">Using unmanaged workspace</a></h2>

<p><em class="note">
  [Note: I just made up most of the terminology in this section; 
  it may not be helpful.  RHSK 2006-06-16]
</em></p>

<p>This involves:</p>
<ul>
  <li> copying references from the managed into the unmanaged world;</li>
  <li> copying references from the unmanaged into the managed world;</li>
  <li> moving objects (and the references they contain) 
    from the unmanaged to the managed world.</li>
</ul>

<h3>Guaranteed -vs- guarded protocols</h3>

<p>In a <dfn>guaranteed</dfn> protocol, permitted operations are safe and the results are always valid.</p>

<p>In a <dfn>guarded</dfn> protocol, permitted operations are safe, but the results may be invalid.  After performing the operations, the mutator can find out whether the results are valid or not.</p>

<dl>
  <dt><a id="guaranteed-reference">Guaranteed reference</a></dt>
  <dd>
    <p>&equiv; a value that
      the MPS guarantees will 
      remain a fresh reference, 
      even when stored in an unmanaged cell, until 
      the end of the guaranteed period.
      Permitted operations are safe and correct.
      (The MPS guarantees that the referent does not move or get 
      reclaimed).
      <em class="note">
        [Clearly possible, but these protocols are not currently 
        clearly defined.  RHSK 2006-06-15]
      </em>
    </p>
    <p>A guaranteed reference may be 
      copied into a managed cell.</p>
  </dd>

  <dt><a id="guarded-value">Guarded value</a></dt>
  <dd>
    <p>&equiv; a value that may be a fresh reference, or may be 
      stale.  (The MPS knows which, but the mutator doesn't).  
      A protocol defines how the reference may be used.</p>
  </dd>
  
  <dt><a id="unsafe-value">Unsafe value</a></dt>
  <dd>
    <p>&equiv; a value that is neither guaranteed nor guarded, 
      and even the MPS does not know if it is a fresh reference or 
      not.  An unsafe reference must not be copied into a 
      managed non-ambiguous cell.
    </p>
  </dd>
</dl>


<h3>Operations with guarded references</h3>

<p>A guarded protocol defines the "guarded period", which has 
  an "open" phase, followed by an atomic "commit" event 
  that may succeed or fail, followed by an "abort" phase (only if the 
  commit failed).</p>
  
<p>The "commit" only succeeds if the guarded references remained fresh.
  The result of the operations is valid, and the guarded period is over.  
  A successful commit may atomically change other state too, such 
  as making a previously unmanaged object become managed.</p>

<p>If the "commit" fails, the guarded references are stale, 
  the results are invalid, and the guarded 
  period enters an "abort" phase.  The mutator should detect this, 
  clear up if necessary, and then "close" the abort phase 
  (this also closes the guarded period).</p>

<p>A guarded protocol restricts which operations are permitted
  on guarded references.</p>
  
<p><em class="note">
  [Note: It might be possible to design a protocol where 
  guarded references may be dereferenced.  
  If stale, the mutator would see objects 
  in the stale world that persists until reclaim.
  Not currently supported.  RHSK 2006-06-15]
</em></p>

<h4>Example: the allocation point protocol:</h4>

<blockquote>

<p>Throughout the guarded period, the new object is unmanaged.
  On successful commit, the guarded period ends, and if the new 
  object is reachable it becomes managed.</p>

<p>Throughout the guarded period, 
  the pointer value returned by mps_reserve is a guarded value 
  that may be dereferenced to access the new object,
  and may be copied into a managed cell.  
  On successful commit, copies in the managed world 
  (including copies in the new object, if it is reachable)
  become fresh references to the new object.</p>

<p>Throughout the guarded period, 
  a reference to a reachable object may be
  copied from a managed cell into the unmanaged world
  (including into the new object):
  it becomes a guarded value that may <strong>NOT</strong> be 
  dereferenced.  
  The guarded value may be copied into a managed cell.
  On successful commit, all copies stored in 
  managed cells
  (including cells in the new object, if it is reachable)
  are still fresh.  
  All other copies are unsafe.</p>

<p>On failed commit, for the duration of the abort phase, all
  guarded values remain guarded.  After the abort 
  phase is closed, all remaining copies of the guarded value 
  become unsafe.
  (The mutator must therefore use the abort phase to 
  remove all guarded references from managed non-ambiguous cells.</p>

</blockquote>
 
<h2><a id="section-B" name="section-B">B. Document History</a></h2>

<pre>
  2006-06-15  RHSK  Created.
  2006-06-15  RHSK  Modes of use; Types of object; Types of reference.
  2006-06-16  RHSK  Objects, cells, and references; Using unmanaged workspace
</pre>


<h2><a id="section-C" name="section-C">C. Copyright and License</a></h2>

<p> This document is copyright &copy; 2006 <a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>.  All rights reserved.  This is an open source license.  Contact Ravenbrook for commercial licensing options. </p>

<p> Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: </p>

<ol>

<li> Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. </li>

<li> Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. </li>

<li> Redistributions in any form must be accompanied by information on how to obtain complete source code for the this software and any accompanying software that uses this software.  The source code must either be included in the distribution or be available for no more than the cost of distribution plus a nominal fee, and must be freely redistributable under reasonable conditions.  For an executable file, complete source code means the source code for all modules it contains. It does not include source code for modules or files that typically accompany the major components of the operating system on which the executable file runs. </li>

</ol>

<p> <strong> This software is provided by the copyright holders and contributors "as is" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability, fitness for a particular purpose, or non-infringement, are disclaimed.  In no event shall the copyright holders and contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. </strong> </p>


<hr />

<div class="banner">

<p><code>$Id$</code></p>

<p>
<a href="/">Ravenbrook</a>
/ <a href="/project/">Projects</a>
/ <a href="/project/mps/">Memory Pool System</a>
/ <a href="/project/mps/master/">Master Product Sources</a>
/ <a href="/project/mps/master/manual/">Manuals</a>
/ <a href="/project/mps/master/manual/wiki/">Wiki</a>
</p>

</div>

</body>

</html>
