<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <title>MPS Wiki: Modes of use of MPS</title>
  <style type = "text/css">
    <!--
    div.banner {text-align:center}
    dt {font-weight:bold}
    
    -->
  </style>
</head>

<body>

<div class="banner">

<p>
<a href="/">Ravenbrook</a>
/ <a href="/project/">Projects</a>
/ <a href="/project/mps/">Memory Pool System</a>
/ <a href="/project/mps/master/">Master Product Sources</a>
/ <a href="/project/mps/master/manual/">Manuals</a>
/ <a href="/project/mps/master/manual/wiki/">Wiki</a>
</p>

<p><i><a href="/project/mps/">Memory Pool System Project</a></i></p>

<hr />

<h1>MPS Wiki: Modes of use of MPS</h1>

<address>
<a href="mailto:rhsk@ravenbrook.com">Richard Kistruck</a>,
<a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>,
2006-06-15
</address>

</div>

<p> This wiki article contains incomplete and informal notes about the MPS, the precursor to more formal documentation.  Not confidential.  Readership: MPS users and developers.  </p>

<p>This article has the following sections:</p>
<ul>
  <li>Modes of use of MPS</li>
  <li>Objects, cells, references, and reference-values</li>
  <li>Using unmanaged workspace</li>
</ul>

<p><strong>Warning: this document is young, and does not represent consensus.</strong>  RHSK 2006-06-16.</p>

<h2>Modes of use of MPS:</h2>
<dl>
  <dt>.manual:</dt>
  <dd>
    <p>= no collection</p>
    <dl>
      <dt>.manual.malloc:</dt>
      <dd>pure malloc/free replacement</dd>

      <dt>.manual.mps-friendly:</dt>
      <dd>an MPS-friendly interface: ap, SAC, etc</dd>

      <dt>.manual.c++:</dt>
      <dd>C++ friendly (not sure what this involves)</dd>

      <dt>.manual.stl:</dt>
      <dd>packaged as allocator for a C++ STL (Standard Template 
        Library) allocator</dd>
    </dl>
  </dd>
  
  <dt>.freeless:</dt>
  <dd>
    <p>= malloc, with free a no-op</p>
    <p>Probably formatless and fully ambig (Boehm-like).</p>
  </dd>
  
  <dt>.attachable:</dt>
  <dd>
    <p>(for .manual and .freeless) attach without source code changes, 
      or without a re-compile, or without a re-link, 
      or even without stopping mutator?</p>
  </dd>
  
  <dt><a id="unmanaged-workspace">.unmanaged-workspace:</a></dt>
  <dd>
    <p>= workspace (eg. registers and stack) is not scanned</p>
    
    <p>This should be the simplest, but surprisingly it 
      doesn't seem to be well defined -- the MPS seems to lack 
      the necessary protocols for it!</p>
    
    <p>(The only current protocol for unmanaged objects 
      is when they are under construction in allocation points).</p>
    
    <p>See 
      <a href="#using-unmanaged-workspace">Using unmanaged workspace&darr;</a>.</p>
    
    <p>The simplest starting point would probably be:
      formatted, exact, non-incremental, and single-threaded.
      (No protection, no stack or register scanner).  
      This is fine for:</p>
    <ul>
      <li> adding GC to part of bigger application;</li>
      <li> implementing a simple language in C.</li>
    </ul>
    
    <p>This is what the SC integration wants.</p>
      
    <p>Even when we define the necessary protocols, we're not 
      sure what the limits will be.  Multi-threaded might 
      be very hard.</p>
  </dd>
  
  <dt>.ambiguous-workspace:</dt>
  <dd>
    <p>= all workspace (eg. registers and stack)
      is scanned ambiguously, 
      with the exception of objects under construction 
      in allocation points, which are unmanaged but guarded.</p>
    <p>This is our Dylan-like bread and butter:
      incremental, generational, mostly copying, 
      formatted, ambiguous reg+stack, 
      supports foreign code, multi-threaded.  
      And we do location-dependency, weakness, finalization, ...</p>
  </dd>
  
  <dt>.exact-workspace:</dt>
  <dd>
    <p>= all workspace (eg. registers and stack)
      is scanned exactly
      (except objects under construction in allocation points)</p>
    <p>Might be useful for someone writing their own compiler.  
      You wouldn't want to write this code in C.</p>
  </dd>
</dl>

<h2>Objects, cells, references, and reference-values</h2>

<p><em class="note">
  [Note: apart from "root" and "reachable", the terminology in 
  this section is new (I think).  RHSK 2006-06-16]
</em></p>

<dl>
  <dt> object </dt>
  <dd>some memory allocated by the MPS; it may contain cells.</dd>

  <dt> cell </dt>
  <dd>a place that stores one reference; (A cell is most commonly: 
      a register, 
      a local (C-stack) variable, 
      a statically allocated global variable,
      or a memory word inside an object) </dd>
  
  <dt> reference </dt>
  <dd>one stored instance of a reference-value;
      (For example: the stored bit-pattern 0x1200A3B0 
      in register r4)</dd>
  
  <dt> reference-value </dt>
  <dd>a value that designates an allocated object;
      (A reference-value is usually an address, 
      for example: the bit-pattern 0x1200A3B0)
  </dd>
</dl>


<h3>Types of object:</h3>
<dl>
  <dt>Root object (in MPS terminology)</dt>
  <dd>&equiv; an object that the mutator has 
    designated as a root.
  </dd>

  <dt>Reachable object (in MPS terminology)</dt>
  <dd>&equiv; a root, or an object reachable from 
    a root via scanned references.
  </dd>
</dl>

<p>Note that the MPS does <strong>NOT</strong> assume that registers, 
  the stack, etc, are roots.  This is a little unusual.  This means 
  that "reachable" means "reachable to the collector"; the mutator 
  may be able to access references that are not "reachable".</p>

<h3>Types of cell:</h3>
<dl>
  <dt><a id="managed-cell">Managed</a></dt>
  <dd>&equiv; a scanned cell in a reachable object.
    If the reference in the cell is TO a 
    reachable object, then the MPS ensures the reference 
    remains fresh.  
    (The MPS must ensure the referent does not get 
    reclaimed.
    If ambiguous, pins referent.  
    If exact, may update the reference.)
  </dd>

  <dt><a id="unmanaged-cell">Unmanaged</a></dt>
  <dd>&equiv; a cell that is not managed.
    A reference stored in an unmanaged cell is not useful 
    unless it is a 
    <a href="#guaranteed-reference">guaranteed reference</a> or a 
    <a href="#guarded-value">guarded value</a>.
    (The MPS cannot see the reference).
  </dd>
</dl>

<h3>The state of a reference:</h3>
<p>A reference may be:</p>
<dl>
  <dt><a id="fresh-reference">Fresh</a></dt>
  <dd>&equiv; a reference that the MPS has kept up-to-date.  
    (The definition 
    of 'up-to-date' depends on context.  For example, for a weak 
    reference, 'up-to-date' means it either points to the intended 
    object, or it has been nulled out.)
  </dd>

  <dt><a id="stale-reference">Stale</a></dt>
  <dd>&equiv; a reference that has not been kept up-to-date, and 
    may now 
    designate an out-of-date copy of the object, some other object, 
    random memory, or unmapped memory.
  </dd>
</dl>


<h2><a id="using-unmanaged-workspace">Using unmanaged workspace</a></h2>

<p><em class="note">
  [Note: the terminology in 
  this section is new (I think).  RHSK 2006-06-16]
</em></p>

<p>Unmanaged workspace must be used with care because the MPS cannot 
  see the references stored in it, and so cannot keep these references 
  fresh.</p>
  
<p>Surprisingly, the MPS seems to lack the necessary protocols for 
  using unmanaged workspace in general.  
  The MPS currently supports only one protocol for unmanaged 
  workspace: objects under construction in allocation points.</p>

<p>This section is a preliminary analysis of what protocols are 
  needed (and appropriate) for using unmanaged workspace in general.</p>
  
<h3>Operations</h3>

<p>Using unmanaged workspace involves:</p>
<ul>
  <li> copying references from the managed into the unmanaged world;</li>
  <li> dereferencing references in the unmanaged world;</li>
  <li> copying references from the unmanaged into the managed world;</li>
  <li> moving objects (and the references they contain) 
    from the unmanaged to the managed world.</li>
</ul>

<h3>Guaranteed -vs- guarded protocols</h3>

<p>In a <dfn>guaranteed</dfn> protocol, permitted operations are safe and the results are always valid.</p>

<p>In a <dfn>guarded</dfn> protocol, permitted operations are safe, but the results may be invalid.  After performing the operations, the mutator can find out whether the results are valid or not.</p>

<dl>
  <dt><a id="guaranteed-reference">Guaranteed reference</a></dt>
  <dd>
    <p>&equiv; a value that
      the MPS guarantees will 
      remain a fresh reference, 
      even when stored in an unmanaged cell, until 
      the end of the guaranteed period.
      Permitted operations are safe and correct.
      (The MPS guarantees that the referent does not move or get 
      reclaimed).
      <em class="note">
        [Clearly possible, but these protocols are not currently 
        clearly defined.  RHSK 2006-06-15]
      </em>
    </p>
    <p>A guaranteed reference may be 
      copied into a managed cell.</p>
  </dd>

  <dt><a id="guarded-value">Guarded value</a></dt>
  <dd>
    <p>&equiv; a value that may be a fresh reference, or may be 
      stale.  (The MPS knows which, but the mutator doesn't).  
      A protocol defines how the value may be used.</p>
  </dd>
  
  <dt><a id="unsafe-value">Unsafe value</a></dt>
  <dd>
    <p>&equiv; a value that is neither guaranteed nor guarded, 
      and even the MPS does not know if it is a fresh reference or 
      not.  An unsafe value must not be copied into a 
      managed non-ambiguous cell.
    </p>
  </dd>
</dl>


<h3>Operations with guarded values</h3>

<p>A guarded protocol defines the "guarded period", which has 
  an "operations" phase, followed by an atomic "commit" event 
  that may succeed or fail, followed by an "abort" phase 
  (only if the commit failed).
  </p>
  
<p>"commit" succeeds &rArr; the guarded references remained fresh.
  The result of the operations is valid, and the guarded period is over.  
  A successful commit may atomically change other state too, such 
  as making a previously unmanaged object become managed.</p>

<p>"commit" fails &rArr; the guarded references are stale, 
  the results are invalid, and the guarded 
  period enters an "abort" phase.</p>

<p>The mutator must detect the abort phase, 
  clear up if necessary, and then "close" the abort phase 
  (this also closes the guarded period).</p>

<p>Note: although the "commit" is atomic and succeeds or fails, 
  the mutator will not be able to both commit and test for success 
  or failure atomically.</p>
  
<p>"false abort": the mutator may be unable to 
  test commit's success or failure accurately: it may be 
  required to make a conservative approximation, erring on the 
  side of failure.
  This may result in a 'false abort', where the
  mutator believes it is in the "abort" phase of the guarded 
  period, but actually the commit succeeded and the guarded period 
  is over.  Write your mutator abort code with great care: it 
  must be valid and have the same semantics whether run in a real 
  abort phase or a false abort.</p>
  
<p>A guarded protocol restricts which operations are permitted
  on guarded values.</p>
  
<p><em class="note">
  [Note: It might be possible to design a protocol where 
  guarded references may be dereferenced.  
  If stale, the mutator would see objects 
  in the stale world that persists until reclaim.
  Not currently supported.  RHSK 2006-06-15]
</em></p>

<h4>Example: the allocation point protocol:</h4>

<blockquote>

<p><em class="note">
  [Note: This example attempts to define the allocation
  point protocol using the general concepts for 
  unmanaged workspace and guarded protocols 
  developed above, and extend the definition of 
  the protocol to discuss storing guarded references in 
  exactly-scanned managed cells.  Commit is when the 
  mutator sets I=A.  MPS does not currently define 
  abort-close: in practice the MPS code currently does it 
  on the next mps_ap_fill, but we should probably define it 
  as occurring earlier, when the mutator calls mps_ap_trip.
  RHSK 2006-06-20]
</em></p>

<p>Throughout the guarded period, the new object is unmanaged.
  On successful commit, the guarded period ends, and if the new 
  object is reachable it becomes managed.</p>

<p>Throughout the guarded period, 
  the pointer value returned by mps_reserve is a guarded value 
  that may be dereferenced to access the new object,
  and may be copied into a managed cell.  
  On successful commit, copies in the managed world 
  (including copies in the new object, if it is reachable)
  become fresh references to the new object.</p>

<p>Throughout the guarded period, 
  a reference to a reachable object may be
  copied from a managed cell into the unmanaged world
  (including into the new object):
  it becomes a guarded value that may <strong>NOT</strong> be 
  dereferenced.  
  The guarded value may be copied into a managed cell.
  On successful commit, all copies stored in 
  managed cells
  (including cells in the new object, if it is reachable)
  are still fresh.  
  All other copies are unsafe.</p>

<p>On failed commit, for the duration of the abort phase, all
  guarded values remain guarded.  
  After the abort 
  phase is closed, all remaining copies of the guarded value 
  become unsafe.</p>

<p>During its abort, the mutator must therefore
  remove all guarded values from managed non-ambiguous cells,
  and (because this may be a false abort) it must not 
  dereference the pointer value returned by mps_reserve.</p>

</blockquote>
 
<h2><a id="section-B" name="section-B">B. Document History</a></h2>

<pre>
  2006-06-15  RHSK  Created.
  2006-06-15  RHSK  Modes of use; Types of object; Types of reference.
  2006-06-16  RHSK  Objects, cells, and references; Using unmanaged workspace
  2006-06-20  RHSK  Tidy and clarify.  False aborts in guarded protocols.
</pre>


<h2><a id="section-C" name="section-C">C. Copyright and License</a></h2>

<p> This document is copyright &copy; 2006 <a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>.  All rights reserved.  This is an open source license.  Contact Ravenbrook for commercial licensing options. </p>

<p> Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: </p>

<ol>

<li> Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. </li>

<li> Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. </li>

<li> Redistributions in any form must be accompanied by information on how to obtain complete source code for the this software and any accompanying software that uses this software.  The source code must either be included in the distribution or be available for no more than the cost of distribution plus a nominal fee, and must be freely redistributable under reasonable conditions.  For an executable file, complete source code means the source code for all modules it contains. It does not include source code for modules or files that typically accompany the major components of the operating system on which the executable file runs. </li>

</ol>

<p> <strong> This software is provided by the copyright holders and contributors "as is" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability, fitness for a particular purpose, or non-infringement, are disclaimed.  In no event shall the copyright holders and contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. </strong> </p>


<hr />

<div class="banner">

<p><code>$Id$</code></p>

<p>
<a href="/">Ravenbrook</a>
/ <a href="/project/">Projects</a>
/ <a href="/project/mps/">Memory Pool System</a>
/ <a href="/project/mps/master/">Master Product Sources</a>
/ <a href="/project/mps/master/manual/">Manuals</a>
/ <a href="/project/mps/master/manual/wiki/">Wiki</a>
</p>

</div>

</body>

</html>
