<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <title>MPS Wiki: Garbage Collection</title>
  <style type = "text/css">
    <!--
    div.banner {text-align:center}
    dt {font-weight:bold}
    
    -->
  </style>
</head>

<body>

<div class="banner">

<p>
<a href="/">Ravenbrook</a>
/ <a href="/project/">Projects</a>
/ <a href="/project/mps/">Memory Pool System</a>
/ <a href="/project/mps/master/">Master Product Sources</a>
/ <a href="/project/mps/master/manual/">Manuals</a>
/ <a href="/project/mps/master/manual/wiki/">Wiki</a>
</p>

<p><i><a href="/project/mps/">Memory Pool System Project</a></i></p>

<hr />

<h1>MPS Wiki: Garbage Collection</h1>

<address>
<a href="mailto:rhsk@ravenbrook.com">Richard Kistruck</a>,
<a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>,
2006-06-02
</address>

</div>

<p> This wiki article contains incomplete and informal notes about the MPS, the precursor to more formal documentation.  Not confidential.  Readership: MPS users and developers.  </p>

<p>Notes on getting started with GC -- Garbage Collection.</p>

<h2>Introduction</h2>

<p>The essential MPS concepts for GC are:</p>
<dl>
  <dt> <a href="#Format">Format&darr;</a></dt>
  <dd> lets the MPS ask the client a question about an object;</dd>

  <dt> Root</dt>
  <dd> tell the MPS which things (eg. stack, globals) are always alive.</dd>
</dl>

<p>The advanced MPS concepts for GC are:</p>
<dl>
  <dt> Allocation Point
       <a href="#Allocation-Point-User">(user's guide&darr;)</a></dt>
  <dd> reserve memory, build a new object, and commit 
       it to MPS management.  (For the internals see 
       <a href="#Allocation-Point-Internals">AP internals&darr;</a>).
  </dd>
</dl>


<h2><a id="Format">Format</a></h2>

<p>The client can choose how to format its objects, but the MPS will
sometimes need to ask the client some questions about an object, such
as:</p>
<ul>
  <li> how big is it? (so that if it is dead the MPS collects only that
       object)</li>
  <li> what pointers does it contain? (so the MPS can mark referred-to
       objects as still alive)</li>
</ul>

<p>For each type of question, the client must provide a function that gives
the answer.  These functions are called "format methods", and are
collected together into a "format"
(mps_fmt_t).  Usually the client developer writes these functions,
calls "<code>mps_fmt_create_...</code>" to
collect them into a format, and passes this format to the MPS as an
argument to <code>mps_pool_create()</code>.</p>

<p>A client's format code is 'special'.  It is called at special times (eg.
when handling an interrupt), and is quite restricted in what it is
allowed to do.  Format code is often on the critial path for memory
management operations.  The full requirement for a format is
complicated; see pool class documentation in the Reference Manual.  But
here's a simplified overview:</p>

<p>No format is required for an object in a non-scanned, non-collectable
pool -- the MPS never needs to know the internal details of objects in
these pools.</p>

<p>For collectable and/or scannable pools, the client's format code
generally needs to support three types of object:</p>
<ol>
  <li> the client's own initialized objects;</li>
  <li> on behalf of the MPS, a "forwarding object";</li>
  <li> on behalf of the MPS, a "padding object".</li>
</ol>

<p>A forwarding object is a placeholder that the MPS uses when it has moved
the object that used to be there.  ('Normal' client code never sees
these forwarding objects; only client format code does).</p>

<p>A padding object is a 'dummy' object that the MPS uses when there is not
enough room (eg. at the end of a memory page) to put a real client
object.</p>

<p>The client must be able to distinguish between these three types 
of object.  To guarantee this, client code MUST initialize
memory returned by the MPS (by mps_alloc() or mps_reserve()) BEFORE it
makes any other call into the MPS from that thread (including the call to
mps_commit).  Here, "initialize" means at least enough initialization
that the client's format code handles the object correctly, including
whether it is a client object, a forwarding object, or a padding object.
[See also protocol.mps.format.rel.ap.  RHSK 2006-06-02]</p>

<h3><a id="format-methods">The most important format methods are:</a></h3>

<p>Indicate the size of a collectable client object:</p>
<ul>
  <li> Skip (see <a href="../reference/index.html#mps_fmt_skip_t">mps_fmt_skip_t</a>):
         client must tell the MPS how big this object is.</li>
</ul>

<p>List all references from this object to (other) collectable objects:</p>
<ul>
  <li> Scan (see <a href="../reference/index.html#mps_fmt_scan_t">mps_fmt_scan_t</a>): 
         client must 'scan' the object for pointers, and tell 
         the MPS to 'fix' each pointer it finds;</li>
</ul>

<p>Move this client object (obsolete, see below):</p>
<ul>
  <li> Copy (obsolete) (see <a href="../reference/index.html#mps_fmt_copy_t">mps_fmt_copy_t</a>):
         client must copy the object to a new location.</li>
</ul>

<p>Create/use a forwarding object (used by an incremental moving collector after moving a client object):</p>
<ul>
  <li> Fwd (see <a href="../reference/index.html#mps_fmt_fwd_t">mps_fmt_fwd_t</a>):
         client must create a forwarding object here, and store
         the supplied forwarding pointer in it;</li>
  <li> IsFwd (see <a href="../reference/index.html#mps_fmt_isfwd_t">mps_fmt_isfwd_t</a>):
         client must test whether this is a forwarding object
         (created by the Fwd method), and if so return the 
         forwarding pointer stored in it.  (This is how the 
         MPS remembers where a moved object was moved to).</li>
</ul>

<p>Create a padding object:</p>
<ul>
  <li> Pad (see <a href="../reference/index.html#mps_fmt_pad_t">mps_fmt_pad_t</a>):
         create a padding object here, please.</li>
</ul>

<h3><a id="format-methods-copy-is-obsolete">Format Methods: the Copy method is obsolete</a></h3>

<p>The Copy method is obsolete, and is never called.  The MPS just uses 
<code>mps_lib_memcpy()</code> to copy the bytes to the new location.  
It knows how many bytes to copy by using the Skip method.</p>

<p>Historical notes: The original justification for Copy was:</p>
<ul>
  <li> client (knowing the object's data fields) might intelligently 
         copy less than all the bytes;</li>
  <li> client might alter the data, eg. fixing-up internal pointers.</li>
</ul>
<p>... but this didn't happen with actual clients, and the interface 
to the copy method didn't pass the skip-size (which the MPS has 
already determined by calling Skip) and so didn't allow an efficient 
copy method to be written. So it was dropped, in 1998 or earlier.  
The only place this memcpy currently occurs is in poolamc.c,  in 
AMCFix() (and now AMCHeaderFix() too).</p>

<p>There are notes on this change at 
<a href="../../design/trace/#fix.nocopy">design/trace/#fix.nocopy</a>.</p>

<h3><a id="format-variants">Format Variants</a></h3>

<p>There are several different ways to package-up the format methods -- these different ways are called 'variants'.  MPS currently supports four format variants.  The creation functions for these are:</p>
<ul>
  <li> <a href="../reference/index.html#mps_fmt_create_A">mps_fmt_create_A</a>;</li>
  <li> <a href="../reference/index.html#mps_fmt_create_B">mps_fmt_create_B</a>;</li>
  <li> <a href="../reference/index.html#mps_fmt_create_auto_header">mps_fmt_create_auto_header</a>;</li>
  <li> <a href="../reference/index.html#mps_fmt_create_fixed">mps_fmt_create_fixed</a>.</li>
</ul>

<p>It's a bit messy -- sorry.</p>

<h2><a id="Root-User">Roots -- User's Guide</a></h2>

<pre>
<a href="/project/mps/import/2001-09-27/mminfo/doc/impl/h/mps/index.txt#1">//info.ravenbrook.com/project/mps/import/2001-09-27/mminfo/doc/impl/h/mps/index.txt#1</a>
   307 /* Root Creation and Destruction
   308  *
   309  * mps_root_create creates the most general type of root: a scanning
   310  * function with two closure elements, p and s.
   311  *
   312  * mps_root_create_table creates a root from a block of memory which
   313  * contains a contiguous array of references.  Pages containing table
   314  * roots may be protected by the MPS if MPS_RM_PROT is set in the
   315  * root mode.
   316  *
   317  * mps_root_create_fmt creates a root from a block of memory which
   318  * contains formatted objects.  Pages containing fmt roots may be
   319  * protected by the MPS if MPS_RM_PROT is set in the root mode.
   320  *
   321  * mps_root_create_reg creates a root which will be used to scan
   322  * the registers of a thread.  (Often it will scan the stack, too.)
   323  */
</pre>



<h2><a id="Allocation-Point-User">Allocation Points -- User's Guide</a></h2>

<p>These notes on Allocation Points were written by RHSK between 
  2006-06-07 and 2006-06-12, following research and discussion with 
  RB and NB.</p>
  
<p><strong>Note:</strong> the text in this "Allocation Point" 
  section may <em>supersede</em> the MPS Reference Manual version???.
  At least, the mutator's obligation to ensure there are no exact 
  references to a failed new-object, before it calls mps_ap_trip, 
  is suspected to be new light.</p>
  
<p><strong>Warning:</strong> the text in this "Allocation Point" 
  section is preliminary, but believed to be 'conservatively correct'.
  In other words, I think if you follow these guidelines, your code 
  will be correct, and will not violate the current or future 
  definitions of the MPS ap protocol.  But this is not (yet) an 
  accurate statement of the MPS ap protocol.  RHSK 2006-06-13.</p>

<p><strong>Warning:</strong> the text in this "Allocation Point" 
  section is in transition from 
  1: not assuming ambiguous scanning of reg+stack, 
  to 2: assuming ambiguous scanning of reg+stack.  
  This transition was necessary because we found that we don't have 
  (or haven't rediscovered) a specification of the MPS guarantees 
  that a mutator would require for an unscanned reg+stack to be 
  practical.  
  RHSK 2006-06-13.</p>

<h3>Overview of two-phase allocation</h3>

<p>When the client is building (creating and formatting) a new 
  object, it is in a race with the MPS.  
  The object is 'under 
  construction', and the MPS cannot manage it in the normal way.  
  So the client should build the object quickly, and then 
  commit it to MPS management.  Rarely, the MPS has to move other
  objects around right in the middle of this build phase: that's 
  a (small) price you pay for having an asynchronous collector.  
  If this happens, the MPS tells the client that it has 'lost the 
  race'.  Objects have moved around, and the new object is invalid.
  The client must start building it again from scratch.</p>

<p>The client starts the race with <code>mps_reserve</code>, and 
  says "Finished!" by calling <code>mps_commit</code>.  
  Almost always, <code>mps_commit</code> succeeds.  But if the 
  client lost the race, then <code>mps_commit</code> fails 
  (it returns 0).</p>

<p>This is how the client should build a new object:</p>
<ol>
  <li> <code>mps_reserve</code> some memory,</li>
  <li> build a new object in it,</li>
  <li> store a reference to the new object in an 
    ambiguously-scanned place
    (but <strong>NOT</strong> in any exactly-scanned place),</li>
  <li> <code>mps_commit</code> the new object to MPS management;</li>
  <li> if commit succeeds, the client may write a reference to the 
    new object into some older object (thereby connecting the 
    new object into the client's graph of objects);</li>
  <li> if commit fails, the new object no longer exists: 
    the data has gone and any references that used to refer to it 
    are now dangling pointers.</li>
</ol>

<p>If commit fails, the client should simply try to build the 
  object again (it is very rare for commit to fail even once, let 
  alone twice).</p>
  
<p>Usually, the client's registers and stack are scanned 
  ambiguously, which takes care of point 3 above.  
  So the standard allocation point idiom is:</p>

<blockquote><pre><code>int make_object(object *parent)
{
  void *p;
  object *neo = NULL;

  do {
    if (mps_reserve(&amp;p, ap, SIZE_OBJECT) != MPS_RES_OK) {
      goto fail_make_object;
    }
    /* Initialize the new object */
    neo = p;
    neo-&gt;type = TYPE_OBJECT;
    neo-&gt;size = SIZE_OBJECT;
    neo-&gt;child = NULL;
  } while (! mps_commit(ap, p, SIZE_OBJECT);

  /* Success: link the new object into my object graph */
  parent-&gt;child = neo;
  return TRUE;

fail_make_object:
  return FALSE;  /* out of memory, etc */
}
</code></pre></blockquote>

<p>The rest of this section goes through these steps in more 
  detail.</p>

<p>.talk.RB.2006-06-13:</p>
<blockquote><pre>
 need two snippets:
  1= with stack being ambig scanned
  
  2. without stack being ambig scanned: means, snippet should 
     show parent being pinned.
      /* Store an ambiguous reference to the new object */
      global-&gt;ambigroot = neo;
  [RHSK 2006-06-14: I'm not sure that unscanned reg+stack is possible!]
Also:
  = can't use "new";
  = ? (void**) is not portable.
  - avoid use of "race" -- it conventionally means a bad race.
</pre></blockquote>

<p>.talk.RB.2006-06-14:</p>
<blockquote><pre>
Modes of MPS use:
1. manual only, no collection
  1a. pure malloc/free replacement
  1b. faster manual: ap, SAC, etc
2. formatless fully ambig Boehm-like
3. mostly copying formatted, ambiguous reg+stack
  3a. single-threaded (may be the same as 3b);
  3b. multi-threaded
4. unscanned reg+stack, single-threaded, non-moving.
5. unscanned reg+stack, single-threaded, moving.
6: unscanned reg+stack, multi-threaded, non-moving.
7: unscanned reg+stack, multi-threaded, moving -- may be 
   impossible?impractical?

For 4 and 5 (and 6 and 7), MPS could make a promise about when it 
might invalidate unmanaged references.  (We currently only invalidate 
when we flip the mutator for a trace, so each trace flip starts 
a new epoch, and unmanaged references are only valid during 
the epoch in which the unmanaged reference was created by copying
some managed reference).
</pre></blockquote>

<p>.think.RHSK.2006-06-14:</p>
<blockquote><pre>
For 7: unscanned reg+stack, multi-threaded, moving.

How do we support operations like:
  a-&gt;b-&gt;c-&gt;d = e-&gt;f-&gt;g-&gt;h;
?

If forwarding pointers (broken hearts) didn't over-write the old 
objects, then the long chain would be 'safe' as long as you throw 
away the answer at the end, and as long as you do that before 
the reclaim phase of the trace.  

Hmm, it's easy to write a format where the broken heart doesn't 
obliterate the object's slots -- store the forwarding pointer 
solely in the object's format header, invisible to 'normal' client 
code.  

(By the way, are there any limits on the size of pad object that 
the MPS can request of a format pad method?)

With such a format, and the current behaviour of MPS's only 
moving pool (amc):
  -  after flip, unmanaged references are stale (point  
     to stale copies of objects), but are otherwise still 
     connected as the client expects;
  -  after reclaim, they may be to unmapped memory.  
But the MPS does not currently give a guarantee that it will 
behave be like this.  Perhaps it could.

Allocation Point is two things:
  a. a fast inlined allocation protocol;
  b. a quarantine that allows unmanaged references to be safely 
     written, and either:
       - safely converted into valid managed references 
         (if commit succeeds); or
       - flagged as invalid (if commit fails).

b. is nearly what we want for 7.

We want a defined region of time and space within 
which we can use unmanaged references.  

This can either be guaranteed success, or an attempt 
followed by a 'did we get away with that?' check.  

We could work with this primitive:
  - load word from (ref1 + offset) and store it in (ref2 + offset).
Exact stacks, manually maintained.  But it's painful.  (Okay for a 
language compiler, but not for a human.)

From a pinned object, how do i pin its child?
do {
  Read epoch
  Read o-&gt;child into unmanaged ref "child"
} while(! mps_pin(child, epoch);

We can do this already with an allocation point "ap_PinStack".  Each 
mps_pin_t object in the PinStack is simply a managed ambiguous ref:

/* object o MUST be pinned */
int pin_child(object *child_o, object *o)
{
  void *p;
  mps_pin_t *pin;

  do {
    void *child;  /* unmanaged ref: we must not deref it */
    
    if (mps_reserve(&amp;p, ap_PinStack, sizeof(mps_pin_t)) != MPS_RES_OK) {
      goto fail_pin_child;
    }
    pin = p;
    
    child = o-&gt;child;

    /* We must not dereference child;
       We must not store child anywhere managed.  
       We must not store child in any quarantine except pin.
       
       We may store child in the pin quarantine.
       We may store child somewhere where it will 
         always remain umnanaged.  
       
       We may do whatever else we like with child!
       (Not much!)
    */
    
    pin-&gt;thing = child;
  } while (! mps_commit(ap_PinStack, p, sizeof(mps_pin_t));

  /* Success: we managed to pin the child */
  child_o = pin-&gt;thing;
  return TRUE;

fail_pin_child:
  child_o = NULL;
  return FALSE;  /* out of memory, etc */
}

Given pinned object o, can we pin its child simply by telling our 
own format code that the o-&gt;child slot is to be RankAMBIG now?

NO!  We may have finished scanning at RankAMBIG, be scanning at 
RankEXACT now, come across another ref to child, and move it.
</pre></blockquote>

<h3>The graph of managed references to mobile objects</h3>

<p>The MPS is a moving garbage collector: it supports 
  preserve-by-copying pools, whose objects are 'mobile'.  
  Whenever the MPS moves an object, it will ensure that 
  all managed references are updated to point to the 
  new location -- and this happens instantaneously as far 
  as the client sees it.</p>
  
<p>The client should assume that, between <em>any pair of 
  instructions</em>, the MPS may 'shake' this graph, moving 
  all the mobile objects, and updating all the managed 
  references.</p>
  
<p>The client usually takes care to ensure that the 
  references it 
  holds are managed.  To be managed, the reference must be 
  in a formatted object that is reachable from a root, or 
  actually in a root (such as a scanned stack). </p>
  
<p>It is okay for a careful client to hold unmanaged references, 
  but:</p>
<ul>
  <li> they'd better not be to a mobile object!  Remember, mobile 
    objects could move at any time, and unmanaged references 
    will be left 'dangling'.</li>
  <li> they'd better not be the only reference to an object, 
    or that object might get collected, again leaving a dangling 
    reference.</li>
</ul>

<h3>mps_reserve</h3>

<p><code>mps_reserve</code> returns a reference to a piece 
  of new memory for the client to build a new object in.  
  During this build, the MPS pins the piece of memory, and 
  treats it as raw data.</p>

<p>"Pinned" means: it will not move, be collected, be unmapped, 
  or anything like that.  You may keep an unmanaged reference to 
  it at this time.</p>

<p>"Raw data" means two things:</p> 
  
<p>Firstly, "raw data" means that any references stored IN the 
  new object are <em>unmanaged</em>.  This means:</p>
<ul>
  <li> references in the new object will not get updated if 
    the graph of managed references to mobile objects is 'shaken';</li>
  <li> references in the new object do not 
    preserve any old objects they point to.</li>
</ul>

<p>Secondly, "raw data" means that any references TO the new 
  object are treated like other references to unmanaged memory.
      [.belief.refs-to-uninit-safe:
       We're 'sure', but I need to check this.  What does Fix 
       actually do with a pointer into the init-alloc zone?  We
       hope it ignores it.  RHSK 2006-06-09]
  Because of this, you are permitted to connect the new object 
  into your graph of managed objects immediately.  The MPS gives 
  you these guarantees:</p>
<ul>
  <li> the new object is pinned (won't move), so references to it 
    that you write in old objects won't become stale at this time 
    (but see <code>mps_commit</code> below!)</li>
  <li> although the new object is reachable, the MPS knows it 
    is not yet managed, and will leave it in peace;</li>
  <li> the MPS will not call the client's format code to answer 
    questions about the new object.</li>
</ul>

<h3>Building the object</h3>

<p>The client will typically do all these things:</p>
<ul>
  <li> write data to make the new object 'valid' for the client's format;</li>
  <li> write other data into the new object;</li>
  <li> write references (to existing objects) into the new object;</li>
  <li> write a reference TO the new object into an existing object
     -- this connects the new object into the client's graph of 
     managed objects;</li>
</ul>

<p>However, during the build, the client <strong>MUST NOT</strong> read 
  (from the new object) a reference to an existing mobile object -- 
  because the reference is unmanaged and may be stale.</p>

<p>(Actually, the restriction is: the moment a reference to an 
  existing mobile object is written into the new object, that 
  reference (in the new object) may become stale.  And you'd better 
  not use (dereference) a stale reference.  And you'd better not 
  write it into any existing object.  Writing it back into another 
  part of the new object is okay.  Just don't trust it to be a valid 
  reference.)</p>

<h3>mps_commit</h3>

<p>When you call <code>mps_commit</code>, it will either fail or succeed.</p>

<p>Almost always, <code>mps_commit</code> succeeds.  
  If it succeeds, that means: </p>
<ul>
  <li> the new object is now just a normal object like any other, 
    which means it may get collected if there are no references 
    to it;</li>
  <li> all the references written IN the new object are valid (in 
    other words, a successful commit is the MPS's way of telling 
    you that these references did not become stale while they were 
    sitting unmanaged in the new object);</li>
  <li> all the references TO the new object are valid.</li>
</ul>

<p>Occasionally but rarely, <code>mps_commit</code> fails.  
  This means that the new object no longer exists.  
  The memory may even be unmapped by the time 
  <code>mps_commit</code> returns.</p>

<p>When this happens the client should take care to clear up any 
  managed references to the (now vanished) new object.</p>
  
<p>[But there's a hole here, before the client does this.  
    Are managed (aka scanned) references TO 
    it still safe?  They were safe during building 
    (by .belief.refs-to-uninit-safe).  But now the AP pointers have 
    gone away.  Are they still safe?  
    Clearly, if they are only RankAMBIG, they are safe.  
    What if they are RankEXACT?
    RHSK 2006-06-09]</p>
    
<p>[Discussion with RB 2006-06-09: yes, that's a problem for exact 
    references.  Must not make any exact refs to a new object.  And 
    unmanaged refs are not sufficient, because they won't preserve the 
    new object during commit.  So must make at least one ambiguous 
    ref to new object before calling commit.  That's the truth 
    currently.  There are various ways to solve this to allow 
    purely-exact mutators.  For instance, 
    keep the old init..alloc address-space flagged as a zombie zone, 
    until some communication with mutator (perhaps another reserve 
    from same AP?) indicates that mutator has removed all those 
    pesky exact refs to the now-dead ex-new object.  RHSK 2006-06-09]</p>

<p>The client will also have to re-create the object.  For this 
  reason the standard allocation point idiom is:</p>

<pre><code>
  do {
    if (mps_reserve != MPS_RES_OK) {
      goto fail_nomemory;
    }
    /* initialize my new object */
    /* make an ambiguous reference to new object */
  } while (! mps_commit);
  /* link new object into my object graph */
</code></pre>

<h2><a id="Allocation-Point-Internals">Allocation Point Internals</a></h2>

<p>The synchronization issues are a little tricky.  This following 
  notes on these issues were written by RHSK between 
  2006-06-12 and 2006-06-12.</p>

<h3>scenario</h3>

<p>The MPS allocation point protocol is a binary protocol.  You don't 
  have to use the mps_reserve and mps_commit macros, but they are 
  conventional and useful pre-packaged implementations.  
  I'm using them as an example of correct protocol, referring to
  <a href="http://www.ravenbrook.com/project/mps/master/code/mps.h">mps.h#17</a>.
  It looks like this:</p>

<pre><code>#define mps_reserve(_p_o, _mps_ap, _size) \
  ((char *)(_mps_ap)-&gt;alloc + (_size) &gt; (char *)(_mps_ap)-&gt;alloc &amp;&amp; \
   (char *)(_mps_ap)-&gt;alloc + (_size) &lt;= (char *)(_mps_ap)-&gt;limit ? \
     ((_mps_ap)-&gt;alloc = \
       (mps_addr_t)((char *)(_mps_ap)-&gt;alloc + (_size)), \
      *(_p_o) = (_mps_ap)-&gt;init, \
      MPS_RES_OK) : \
     mps_ap_fill(_p_o, _mps_ap, _size))

#define mps_commit(_mps_ap, _p, _size) \
  ((_mps_ap)-&gt;init = (_mps_ap)-&gt;alloc, \
   (_mps_ap)-&gt;limit != 0 || mps_ap_trip(_mps_ap, _p, _size))
</code></pre>

<p>Abstractly, the mutator code has a cycle of four operations on the 
  allocation point:</p>
<dl>
  <dt> Lr </dt>
  <dd> read Limit at reserve </dd>
  
  <dt> A </dt>
  <dd> write Alloc at reserve </dd>
  
  <dt> I </dt>
  <dd> write Init at commit </dd>
  
  <dt> Lc </dt>
  <dd> read Limit at commit </dd>
</dl>

<p>The normal cycle is Lr A I Lc.</p>

<p>After Lr, the mutator checks that A + size &lt;= Lr.  If this fails, 
  then the mutator does mps_ap_fill instead of A.  So Lr mps_ap_fill I Lc 
  is also a valid cycle.</p>

<p>After Lc, the mutator checks that Lc != 0.  If this fails, the 
  mutator will call mps_ap_trip before beginning a new cycle.  So 
  Lr A I Lc mps_ap_trip is also a valid cycle.</p>

<p>The mutator cannot interrupt the 
  collector.</p>

<p>The collector can interrupt the mutator (between any 
  two mutator instructions).  The collector can only see the A, I, 
  and mps_ap_trip (if present) operations; Lr and Lc are invisible 
  to it.</p>

<p>If the ap is not going to trip, the collector sees two 
  equivalence classes:</p>
<ul>
  <li> (A)</li>
  <li> (I Lc Lr)</li>
</ul>

<p>If the ap is going to trip, the collector sees four
  equivalence classes:</p>
<ul>
  <li> (A)</li>
  <li> (I Lc)</li>
  <li> (the call to mps_ap_trip)</li>
  <li> (mps_ap_trip Lr)</li>
</ul>

<p>The collector has two responsibilities:</p>
<dl>
  <dt> FIX </dt> 
  <dd> to fix (or not fix) references TO the object;</dd>
  <dt> SCAN </dt>
  <dd> to scan (or not scan) references IN the object.</dd>
</dl>

<h3>A mutator with ambiguous references only (to the new object)</h3>

<p>Let's see what's required for a mutator that promises to make no 
  exact references to the new object until Lc succeeds, 
  and promises to have at least one ambiguous reference to the 
  new object when it sets I.</p>
  
<p>Consider a flip -- f1 -- in state A.</p>

<p>The collector at f1 sees (A), and recognises that the I..A region 
  is unmanaged memory.  
  The object is never going to be valid, 
  because it may contain stale references from before the flip, and the 
  collector can't fix them.</p>

<p>The f1 collector writes L = 0, tripping the allocation 
  point, and the rest of this collection is easy.  
  The FIX responsibility is easy: 
  all references to the new object are ambiguous, so the 
  collector can fix them or not -- it 
  doesn't matter.  
  For SCAN, the collector must not scan the new object 
  (because it is not yet formatted), so 
  it must not scan the buffered pool beyond I.</p>

<p>Further collections at this point are idempotent.</p>

<p>Now, suppose the mutator then restarts, but only gets as far 
  as (I Lc) before we have a second collection and a 
  second flip -- f2.</p>

<p>For FIX, f2 can fix or not -- it still doesn't matter.</p>

<p>But for SCAN, f2 <strong>MUST NOT</strong> scan the new object.
  Why not?</p>

<p>The mutator's format code will be okay: the fact 
  that I is set tells f2 that the object 
  is fully formatted.</p>

<p>But there is a problem: the object may contain stale exact 
  references -- unfixed references from before f1.  
  These stale exact references will be bogus.  
  Opinions differ on the implications of bogus exact references.  
  See the next section for a discussion.</p>

<p>Additionally, the collector is not <em>obliged</em> to scan the 
  object: this object is dead!  
  The mutator will later notice that Lr == 0 and realise the object 
  is invalid.  The mutator is not relying 
  on this object to keep anything else alive.</p>

<p>It is easy to avoid scanning the invalid object: 
  the first flip in state (A), f1, must record the value of I.  
  Call the recorded pointer If1.  
  Collections must not scan beyond If1.  
  If1 remains set until the mutator calls mps_ap_trip, 
  which resets If1 to 0.
  [Note: I have not checked whether the MPS 
  records and uses If1 -- RHSK 2006-06-12]</p>

<h3>How bad is a bogus exact reference?</h3>

<p>Tucker said:</p>
<blockquote><p>I believe the collector must be prepared to deal 
  with exact dangling pointers anyways, so this complex 
  mechanism is unnecessary.  
  [<a href="/project/mps/mail/1997/05/12/12-46/1.txt">//info.ravenbrook.com/project/mps/mail/1997/05/12/12-46/1.txt:X-MMInfo-Tag: mail.ptw.1997-05-12.12-46(1)</a>]
</p></blockquote>

<p>I'm not convinced.</p>

<p>Fixing a bogus exact reference is bad news.  
  The worst case is spoofing:
  Imagine the bogus exact reference points at part of a 
  JPEG that <em>just happens</em> to look like a validly formatted 
  object.  
  If this JPEG is in the middle of an object in a moving MPS 
  pool, fixing the bogus exact reference will overwrite a portion 
  of the JPEG with a forwarding object.  
  It gets worse: the spoof object is preserved and will later be 
  scanned, producing more bogus exact references!
  For "JPEG", you can substitute "encrypted string".</p>

<p>The only safe way to cope with such a bogus reference is for 
   Fix to verify that the reference points to the start of a real 
   object, which it could do by iteratating the format skip method 
   from some known point in the pool.</p>

<p>The consequences of fixing a bogus exact 
  reference may be:</p>
<ul>
  <li> Referent is not in MPS memory:
    <ul>
      <li> MPS must detect and ignore these; there should be a 
           debug option to report it;</li>
    </ul>
  </li>
  <li> Referent is not validly formatted:
    <ul>
      <li> mutator format code crashes; or</li>
      <li> mutator format code does something stupid or 
           illegal, and causes corruption or makes MPS crash; or</li>
      <li> (if we're lucky) mutator format code detects this 
           and avoids any harmful action.</li>
    </ul>
  </li>
  <li> Referent appears validly formatted, but is a spoof 
       (that is, it is actually data inside some other 
       object):
    <ul>
      <li> in a moving pool: the object is silently corrupted 
           with a forwarding pointer, and the spoof object is 
           preserved and will later be scanned, producing more 
           bogus exact references!</li>
      <li> in a non-moving pool: object is safe from corruption, 
           but MPS greying/blackening code needs to be robust to 
           this case.</li>
    </ul>
  </li>
  <li> Referent is a validly formatted but dead object:
    <ul>
      <li>it gets needlessly preserved;</li>
      <li>if it had been dead for some time, this dead object may 
          itself contain bogus exact references, and these will get 
          'fixed' too.</li>
    </ul>
  </li>
</ul>  

<p>Also, more arcanely, I wonder whether there's a problem if the 
  referent violates the tri-colour invariant (when scanning at 
  black)?  Does the MPS care about this, or does it 'safely' just 
  cause more conservatism?  Does MPS detect and flag this in 
  debug versions?  Could it?</p>

<p>If MPS or format code detects a bogus exact reference, it could 
  assert, and/or to fix them to a canonical special value.</p>

<p>Some possible contracts between mutator and collector:</p>
<ol>
  <li>Mutator and collector promise never to have bogus exact 
    references.  The collector is permitted to crash if it 
    encounters one.</li>
  <li>Mutator agrees that bogus exact references are wrong.  
    But mutator would like a helpful error message, please.  
    (Collector is not permitted to crash).</li>
  <li>Mutator wants permission to keep bogus exact references 
    in certain circumstances, such as on the stack.  Collector 
    must cope safely.  Need to specify how this is guaranteed, 
    based on intimate knowledge of the mutator's behaviour.  
    Dodgy.</li>
  <li>Mutator wants permission to keep bogus exact references 
    in general.  Collector must cope safely, with all the cases 
    of bogus exact references listed above.  I believe the MPS 
    does not currently do this.  It would require a very fast 
    check at fix time that the reference is to the start of a 
    valid object in an MPS client pool.</li>
</ol>

<h3>with exact refs</h3>

<p>We could define the protocol such that 
  the mutator can clear exact references to the new object 
  after Lc and before calling mps_ap_trip.  During this time, 
  the collector must keep the new object as pinned unmanaged 
  memory.  By calling mps_ap_trip, the mutator promises that 
  it has nulled-out any exact references to the new object, 
  and the collector in mps_ap_trip may unmap the memory or 
  safely re-use it without fear of spoofing.</p>

<h3>flipping at other times</h3>

<p>Perhaps the collector wants to flip even when the ap is not 
  at (A).  Need to analyse synchronization issues here.</p>

<h2><a id="section-B" name="section-B">B. Document History</a></h2>

<pre>
  2006-06-02  RHSK  Created.
  2006-06-02  RHSK  Introduction to MPS Formats
  2006-06-06  RHSK  Formats: clarify explanation of methods, copy method is 
                    obsolete, mention format variants.
  2006-06-09  RHSK  Allocation points: how it's supposed to be, from RB 2006-06-09.
  2006-06-09  RHSK  Allocation points: must make at least one ambiguous ref 
                    and no exact refs to new object before calling commit.
  2006-06-12  RHSK  Allocation points: minor edits for clarity.
  2006-06-12  RHSK  Allocation point internals: Scenario; A mutator with 
                    ambiguous references only (to the new object); How 
                    bad is a bogus exact reference?; quick notes on: with 
                    exact refs; flipping at other times.
  2006-06-13  RHSK  Allocation point user's guide: Tidy; clarify-- not yet complete.
                    Distinguish it from section on AP internals.
  2006-06-14  RHSK  Roots -- User's Guide: bare bones: root variants.
                    Allocation point user's guide: standard reserve-commit 
                      idiom: corrections, and now assume ambiguous reg+stack:
                      transitioning to this assumption.
                    Add .talk.RB.2006-06-13 about standard r-c idiom 
                    Add .talk.RB.2006-06-14 about Modes of use of MPS, 
                      and Promises to not flip (single-threaded).
                    Add .think.RHSK.2006-06-14 about how we could support 
                      unscanned reg+stack, even with multi-threaded, moving
                      collector.
</pre>


<h2><a id="section-C" name="section-C">C. Copyright and License</a></h2>

<p> This document is copyright &copy; 2006 <a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>.  All rights reserved.  This is an open source license.  Contact Ravenbrook for commercial licensing options. </p>

<p> Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: </p>

<ol>

<li> Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. </li>

<li> Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. </li>

<li> Redistributions in any form must be accompanied by information on how to obtain complete source code for the this software and any accompanying software that uses this software.  The source code must either be included in the distribution or be available for no more than the cost of distribution plus a nominal fee, and must be freely redistributable under reasonable conditions.  For an executable file, complete source code means the source code for all modules it contains. It does not include source code for modules or files that typically accompany the major components of the operating system on which the executable file runs. </li>

</ol>

<p> <strong> This software is provided by the copyright holders and contributors "as is" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability, fitness for a particular purpose, or non-infringement, are disclaimed.  In no event shall the copyright holders and contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. </strong> </p>


<hr />

<div class="banner">

<p><code>$Id$</code></p>

<p>
<a href="/">Ravenbrook</a>
/ <a href="/project/">Projects</a>
/ <a href="/project/mps/">Memory Pool System</a>
/ <a href="/project/mps/master/">Master Product Sources</a>
/ <a href="/project/mps/master/manual/">Manuals</a>
/ <a href="/project/mps/master/manual/wiki/">Wiki</a>
</p>

</div>

</body>

</html>
