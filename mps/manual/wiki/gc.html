<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <title>MPS Wiki: Garbage Collection</title>
  <style type = "text/css">
    <!--
    div.banner {text-align:center}
    dt {font-weight:bold}
    
    -->
  </style>
</head>

<body>

<div class="banner">

<p>
<a href="/">Ravenbrook</a>
/ <a href="/project/">Projects</a>
/ <a href="/project/mps/">Memory Pool System</a>
/ <a href="/project/mps/master/">Master Product Sources</a>
/ <a href="/project/mps/master/manual/">Manuals</a>
/ <a href="/project/mps/master/manual/wiki/">Wiki</a>
</p>

<p><i><a href="/project/mps/">Memory Pool System Project</a></i></p>

<hr />

<h1>MPS Wiki: Garbage Collection</h1>

<address>
<a href="mailto:rhsk@ravenbrook.com">Richard Kistruck</a>,
<a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>,
2006-06-02
</address>

</div>

<p> This wiki article contains incomplete and informal notes about the MPS, the precursor to more formal documentation.  Not confidential.  Readership: MPS users and developers.  </p>

<p>Notes on getting started with GC -- Garbage Collection.</p>

<h2>Introduction</h2>

<p>The essential MPS concepts for GC are:</p>
<ul>
  <li> <a href="#Format">Format</a> -- lets the MPS ask the client a question about an object;</li>
  <li> Root -- tell the MPS which things (eg. stack, globals) are always alive.</li>
</ul>

<p>The advanced MPS concepts for GC are:</p>
<ul>
  <li> <a href="#Allocation-Point">Allocation Point</a> 
    -- reserve memory, construct and connect a new object, and commit it to MPS management.
  </li>
</ul>


<h2><a id="Format">Format</a></h2>

<p>The client can choose how to format its objects, but the MPS will
sometimes need to ask the client some questions about an object, such
as:</p>
<ul>
  <li> how big is it? (so that if it is dead the MPS collects only that
       object)</li>
  <li> what pointers does it contain? (so the MPS can mark referred-to
       objects as still alive)</li>
</ul>

<p>For each type of question, the client must provide a function that gives
the answer.  These functions are called "format methods", and are
collected together into a "format"
(mps_fmt_t).  Usually the client developer writes these functions,
calls "<code>mps_fmt_create_...</code>" to
collect them into a format, and passes this format to the MPS as an
argument to <code>mps_pool_create()</code>.</p>

<p>A client's format code is 'special'.  It is called at special times (eg.
when handling an interrupt), and is quite restricted in what it is
allowed to do.  Format code is often on the critial path for memory
management operations.  The full requirement for a format is
complicated; see pool class documentation in the Reference Manual.  But
here's a simplified overview:</p>

<p>No format is required for an object in a non-scanned, non-collectable
pool -- the MPS never needs to know the internal details of objects in
these pools.</p>

<p>For collectable and/or scannable pools, the client's format code
generally needs to support three types of object:</p>
<ol>
  <li> the client's own initialized objects;</li>
  <li> on behalf of the MPS, a "forwarding object";</li>
  <li> on behalf of the MPS, a "padding object".</li>
</ol>

<p>A forwarding object is a placeholder that the MPS uses when it has moved
the object that used to be there.  ('Normal' client code never sees
these forwarding objects; only client format code does).</p>

<p>A padding object is a 'dummy' object that the MPS uses when there is not
enough room (eg. at the end of a memory page) to put a real client
object.</p>

<p>The client must be able to distinguish between these three types 
of object.  To guarantee this, client code MUST initialize
memory returned by the MPS (by mps_alloc() or mps_reserve()) BEFORE it
makes any other call into the MPS from that thread (including the call to
mps_commit).  Here, "initialize" means at least enough initialization
that the client's format code handles the object correctly, including
whether it is a client object, a forwarding object, or a padding object.
[See also protocol.mps.format.rel.ap.  RHSK 2006-06-02]</p>

<h3><a id="format-methods">The most important format methods are:</a></h3>

<p>Indicate the size of a collectable client object:</p>
<ul>
  <li> Skip (see <a href="../reference/index.html#mps_fmt_skip_t">mps_fmt_skip_t</a>):
         client must tell the MPS how big this object is.</li>
</ul>

<p>List all references from this object to (other) collectable objects:</p>
<ul>
  <li> Scan (see <a href="../reference/index.html#mps_fmt_scan_t">mps_fmt_scan_t</a>): 
         client must 'scan' the object for pointers, and tell 
         the MPS to 'fix' each pointer it finds;</li>
</ul>

<p>Move this client object (obsolete, see below):</p>
<ul>
  <li> Copy (obsolete) (see <a href="../reference/index.html#mps_fmt_copy_t">mps_fmt_copy_t</a>):
         client must copy the object to a new location.</li>
</ul>

<p>Create/use a forwarding object (used by an incremental moving collector after moving a client object):</p>
<ul>
  <li> Fwd (see <a href="../reference/index.html#mps_fmt_fwd_t">mps_fmt_fwd_t</a>):
         client must create a forwarding object here, and store
         the supplied forwarding pointer in it;</li>
  <li> IsFwd (see <a href="../reference/index.html#mps_fmt_isfwd_t">mps_fmt_isfwd_t</a>):
         client must test whether this is a forwarding object
         (created by the Fwd method), and if so return the 
         forwarding pointer stored in it.  (This is how the 
         MPS remembers where a moved object was moved to).</li>
</ul>

<p>Create a padding object:</p>
<ul>
  <li> Pad (see <a href="../reference/index.html#mps_fmt_pad_t">mps_fmt_pad_t</a>):
         create a padding object here, please.</li>
</ul>

<h3><a id="format-methods-copy-is-obsolete">Format Methods: the Copy method is obsolete</a></h3>

<p>The Copy method is obsolete, and is never called.  The MPS just uses 
<code>mps_lib_memcpy()</code> to copy the bytes to the new location.  
It knows how many bytes to copy by using the Skip method.</p>

<p>Historical notes: The original justification for Copy was:</p>
<ul>
  <li> client (knowing the object's data fields) might intelligently 
         copy less than all the bytes;</li>
  <li> client might alter the data, eg. fixing-up internal pointers.</li>
</ul>
<p>... but this didn't happen with actual clients, and the interface 
to the copy method didn't pass the skip-size (which the MPS has 
already determined by calling Skip) and so didn't allow an efficient 
copy method to be written. So it was dropped, in 1998 or earlier.  
The only place this memcpy currently occurs is in poolamc.c,  in 
AMCFix() (and now AMCHeaderFix() too).</p>

<p>There are notes on this change at 
<a href="../../design/trace/#fix.nocopy">design/trace/#fix.nocopy</a>.</p>

<h3><a id="format-variants">Format Variants</a></h3>

<p>There are several different ways to package-up the format methods -- these different ways are called 'variants'.  MPS currently supports four format variants.  The creation functions for these are:</p>
<ul>
  <li> <a href="../reference/index.html#mps_fmt_create_A">mps_fmt_create_A</a>;</li>
  <li> <a href="../reference/index.html#mps_fmt_create_B">mps_fmt_create_B</a>;</li>
  <li> <a href="../reference/index.html#mps_fmt_create_auto_header">mps_fmt_create_auto_header</a>;</li>
  <li> <a href="../reference/index.html#mps_fmt_create_fixed">mps_fmt_create_fixed</a>.</li>
</ul>

<p>It's a bit messy -- sorry.</p>


<h2><a id="Allocation-Point">Allocation Point</a></h2>

<p>These notes on Allocation Points were written by RHSK between 
  2006-06-07 and 2006-06-12, following research and discussion with 
  RB and NB.</p>

<h3>Overview of two-phase allocation</h3>

<p>The client should:</p>
<ol>
  <li> <code>mps_reserve</code> some memory,</li>
  <li> construct a new object in it,</li>
  <li> write a reference to the new object into some older object, 
    thereby connecting the new object into the client's graph of 
    objects </li>
  <li> <code>mps_commit</code> the new object to MPS management.</li>
</ol>

<h3>The graph of managed references to mobile objects</h3>

<p>The MPS is a moving garbage collector: it supports 
  preserve-by-copying pools, whose objects are 'mobile'.  
  Whenever the MPS moves an object, it will ensure that 
  all managed references are updated to point to the 
  new location -- and this happens instantaneously as far 
  as the client sees it.</p>
  
<p>The client should assume that, between <em>any pair of 
  instructions</em>, the MPS may 'shake' this graph, moving 
  all the mobile objects, and updating all the managed 
  references.</p>
  
<p>The client usually takes care to ensure that the 
  references it 
  holds are managed.  To be managed, the reference must be 
  in a formatted object that is reachable from a root, or 
  actually in a root (such as a scanned stack). </p>
  
<p>It is okay for a careful client to hold unmanaged references, 
  but:</p>
<ul>
  <li> they'd better not be to a mobile object!  Remember, mobile 
    objects could move at any time, and unmanaged references 
    will be left 'dangling'.</li>
  <li> they'd better not be the only reference to an object, 
    or that object might get collected, again leaving a dangling 
    reference.</li>
</ul>

<h3>mps_reserve</h3>

<p><code>mps_reserve</code> returns a reference to a piece 
  of new memory for the client to build a new object in.  
  During this build, the MPS pins the piece of memory, and 
  treats it as raw data.</p>

<p>"Pinned" means: it will not move, be collected, be unmapped, 
  or anything like that.  You may keep an unmanaged reference to 
  it at this time.</p>

<p>"Raw data" means two things:</p> 
  
<p>Firstly, "raw data" means that any references stored IN the 
  new object are <em>unmanaged</em>.  This means:</p>
<ul>
  <li> references in the new object will not get updated if 
    the graph of managed references to mobile objects is 'shaken';</li>
  <li> references in the new object do not 
    preserve any old objects they point to.</li>
</ul>

<p>Secondly, "raw data" means that any references TO the new 
  object are treated like other references to unmanaged memory.
      [.belief.refs-to-uninit-safe:
       We're 'sure', but I need to check this.  What does Fix 
       actually do with a pointer into the init-alloc zone?  We
       hope it ignores it.  RHSK 2006-06-09]
  Because of this, you are permitted to connect the new object 
  into your graph of managed objects immediately.  The MPS gives 
  you these guarantees:</p>
<ul>
  <li> the new object is pinned (won't move), so references to it 
    that you write in old objects won't become stale at this time 
    (but see <code>mps_commit</code> below!)</li>
  <li> although the new object is reachable, the MPS knows it 
    is not yet managed, and will leave it in peace;</li>
  <li> the MPS will not call the client's format code to answer 
    questions about the new object.</li>
</ul>

<h3>Building the object</h3>

<p>The client will typically do all these things:</p>
<ul>
  <li> write data to make the new object 'valid' for the client's format;</li>
  <li> write other data into the new object;</li>
  <li> write references (to existing objects) into the new object;</li>
  <li> write a reference TO the new object into an existing object
     -- this connects the new object into the client's graph of 
     managed objects;</li>
</ul>

<p>However, during the build, the client <strong>MUST NOT</strong> read 
  (from the new object) a reference to an existing mobile object -- 
  because the reference is unmanaged and may be stale.</p>

<p>(Actually, the restriction is: the moment a reference to an 
  existing mobile object is written into the new object, that 
  reference (in the new object) may become stale.  And you'd better 
  not use (dereference) a stale reference.  And you'd better not 
  write it into any existing object.  Writing it back into another 
  part of the new object is okay.  Just don't trust it to be a valid 
  reference.)</p>

<h3>mps_commit</h3>

<p>When you call <code>mps_commit</code>, it will either fail or succeed.</p>

<p>Almost always, <code>mps_commit</code> succeeds.  
  If it succeeds, that means: </p>
<ul>
  <li> the new object is now just a normal object like any other, 
    which means it may get collected if there are no references 
    to it;</li>
  <li> all the references written IN the new object are valid (in 
    other words, a successful commit is the MPS's way of telling 
    you that these references did not become stale while they were 
    sitting unmanaged in the new object);</li>
  <li> all the references TO the new object are valid.</li>
</ul>

<p>Occasionally but rarely, <code>mps_commit</code> fails.  
  This means that the new object no longer exists.  
  The memory may even be unmapped by the time 
  <code>mps_commit</code> returns.</p>

<p>When this happens the client should take care to clear up any 
  managed references to the (now vanished) new object.</p>
  
<p>[But there's a hole here, before the client does this.  
    Are managed (aka scanned) references TO 
    it still safe?  They were safe during building 
    (by .belief.refs-to-uninit-safe).  But now the AP pointers have 
    gone away.  Are they still safe?  
    Clearly, if they are only RankAMBIG, they are safe.  
    What if they are RankEXACT?
    RHSK 2006-06-09]</p>
    
<p>[Discussion with RB 2006-06-09: yes, that's a problem for exact 
    references.  Must not make any exact refs to a new object.  And 
    unmanaged refs are not sufficient, because they won't preserve the 
    new object during commit.  So must make at least one ambiguous 
    ref to new object before calling commit.  That's the truth 
    currently.  There are various ways to solve this to allow 
    purely-exact mutators.  For instance, 
    keep the old init..alloc address-space flagged as a zombie zone, 
    until some communication with mutator (perhaps another reserve 
    from same AP?) indicates that mutator has removed all those 
    pesky exact refs to the now-dead ex-new object.  RHSK 2006-06-09]</p>

<p>The client will also have to re-create the object.  For this 
  reason the standard allocation point idiom is:</p>

<pre><code>
  do {
    if (mps_reserve != MPS_RES_OK) {
      goto fail_nomemory;
    }
    /* initialize my new object */
    /* make an ambiguous reference to new object */
  } while (! mps_commit);
  /* link new object into my object graph */
</code></pre>


<h2><a id="section-B" name="section-B">B. Document History</a></h2>

<pre>
  2006-06-02  RHSK  Created.
  2006-06-02  RHSK  Introduction to MPS Formats
  2006-06-06  RHSK  Formats: clarify explanation of methods, copy method is 
                    obsolete, mention format variants.
  2006-06-09  RHSK  Allocation points: how it's supposed to be, from RB 2006-06-09.
  2006-06-09  RHSK  Allocation points: must make at least one ambiguous ref 
                    and no exact refs to new object before calling commit.
  2006-06-12  RHSK  Allocation points: minor edits for clarity.
</pre>


<h2><a id="section-C" name="section-C">C. Copyright and License</a></h2>

<p> This document is copyright &copy; 2006 <a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>.  All rights reserved.  This is an open source license.  Contact Ravenbrook for commercial licensing options. </p>

<p> Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: </p>

<ol>

<li> Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. </li>

<li> Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. </li>

<li> Redistributions in any form must be accompanied by information on how to obtain complete source code for the this software and any accompanying software that uses this software.  The source code must either be included in the distribution or be available for no more than the cost of distribution plus a nominal fee, and must be freely redistributable under reasonable conditions.  For an executable file, complete source code means the source code for all modules it contains. It does not include source code for modules or files that typically accompany the major components of the operating system on which the executable file runs. </li>

</ol>

<p> <strong> This software is provided by the copyright holders and contributors "as is" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability, fitness for a particular purpose, or non-infringement, are disclaimed.  In no event shall the copyright holders and contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. </strong> </p>


<hr />

<div class="banner">

<p><code>$Id$</code></p>

<p>
<a href="/">Ravenbrook</a>
/ <a href="/project/">Projects</a>
/ <a href="/project/mps/">Memory Pool System</a>
/ <a href="/project/mps/master/">Master Product Sources</a>
/ <a href="/project/mps/master/manual/">Manuals</a>
/ <a href="/project/mps/master/manual/wiki/">Wiki</a>
</p>

</div>

</body>

</html>
