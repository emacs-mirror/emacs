<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <title>MPS Wiki: Garbage Collection</title>
  <style type = "text/css">
    <!--
    div.banner {text-align:center}
    dt {font-weight:bold}
    
    -->
  </style>
</head>

<body>

<div class="banner">

<p>
<a href="/">Ravenbrook</a>
/ <a href="/project/">Projects</a>
/ <a href="/project/mps/">Memory Pool System</a>
/ <a href="/project/mps/master/">Master Product Sources</a>
/ <a href="/project/mps/master/manual/">Manuals</a>
/ <a href="/project/mps/master/manual/wiki/">Wiki</a>
</p>

<p><i><a href="/project/mps/">Memory Pool System Project</a></i></p>

<hr />

<h1>MPS Wiki: Garbage Collection</h1>

<address>
<a href="mailto:rhsk@ravenbrook.com">Richard Kistruck</a>,
<a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>,
2006-06-02
</address>

</div>

<p> This wiki article contains incomplete and informal notes about the MPS, the precursor to more formal documentation.  Not confidential.  Readership: MPS users and developers.  </p>

<p>Notes on getting started with GC -- Garbage Collection.</p>

<h2>Introduction</h2>

<p>The essential MPS concepts for GC are:</p>
<ul>
  <li> <a href="#Format">Format</a> -- lets the MPS ask the client a question about an object;</li>
  <li> Root -- tell the MPS which things (eg. stack, globals) are always alive.</li>
</ul>

<p>The advanced MPS concepts for GC are:</p>
<ul>
  <li> <a href="#Allocation-Point">Allocation Point</a> 
    -- reserve memory, construct and connect a new object, and commit it to MPS management.
  </li>
</ul>


<h2><a id="Format">Format</a></h2>

<p>The client can choose how to format its objects, but the MPS will
sometimes need to ask the client some questions about an object, such
as:</p>
<ul>
  <li> how big is it? (so that if it is dead the MPS collects only that
       object)</li>
  <li> what pointers does it contain? (so the MPS can mark referred-to
       objects as still alive)</li>
</ul>

<p>For each type of question, the client must provide a function that gives
the answer.  These functions are called "format methods", and are
collected together into a "format"
(mps_fmt_t).  Usually the client developer writes these functions,
calls "<code>mps_fmt_create_...</code>" to
collect them into a format, and passes this format to the MPS as an
argument to <code>mps_pool_create()</code>.</p>

<p>A client's format code is 'special'.  It is called at special times (eg.
when handling an interrupt), and is quite restricted in what it is
allowed to do.  Format code is often on the critial path for memory
management operations.  The full requirement for a format is
complicated; see pool class documentation in the Reference Manual.  But
here's a simplified overview:</p>

<p>No format is required for an object in a non-scanned, non-collectable
pool -- the MPS never needs to know the internal details of objects in
these pools.</p>

<p>For collectable and/or scannable pools, the client's format code
generally needs to support three types of object:</p>
<ol>
  <li> the client's own initialized objects;</li>
  <li> on behalf of the MPS, a "forwarding object";</li>
  <li> on behalf of the MPS, a "padding object".</li>
</ol>

<p>A forwarding object is a placeholder that the MPS uses when it has moved
the object that used to be there.  ('Normal' client code never sees
these forwarding objects; only client format code does).</p>

<p>A padding object is a 'dummy' object that the MPS uses when there is not
enough room (eg. at the end of a memory page) to put a real client
object.</p>

<p>The client must be able to distinguish between these three types 
of object.  To guarantee this, client code MUST initialize
memory returned by the MPS (by mps_alloc() or mps_reserve()) BEFORE it
makes any other call into the MPS from that thread (including the call to
mps_commit).  Here, "initialize" means at least enough initialization
that the client's format code handles the object correctly, including
whether it is a client object, a forwarding object, or a padding object.
[See also protocol.mps.format.rel.ap.  RHSK 2006-06-02]</p>

<h3><a id="format-methods">The most important format methods are:</a></h3>

<p>Indicate the size of a collectable client object:</p>
<ul>
  <li> Skip (see <a href="../reference/index.html#mps_fmt_skip_t">mps_fmt_skip_t</a>):
         client must tell the MPS how big this object is.</li>
</ul>

<p>List all references from this object to (other) collectable objects:</p>
<ul>
  <li> Scan (see <a href="../reference/index.html#mps_fmt_scan_t">mps_fmt_scan_t</a>): 
         client must 'scan' the object for pointers, and tell 
         the MPS to 'fix' each pointer it finds;</li>
</ul>

<p>Move this client object (obsolete, see below):</p>
<ul>
  <li> Copy (obsolete) (see <a href="../reference/index.html#mps_fmt_copy_t">mps_fmt_copy_t</a>):
         client must copy the object to a new location.</li>
</ul>

<p>Create/use a forwarding object (used by an incremental moving collector after moving a client object):</p>
<ul>
  <li> Fwd (see <a href="../reference/index.html#mps_fmt_fwd_t">mps_fmt_fwd_t</a>):
         client must create a forwarding object here, and store
         the supplied forwarding pointer in it;</li>
  <li> IsFwd (see <a href="../reference/index.html#mps_fmt_isfwd_t">mps_fmt_isfwd_t</a>):
         client must test whether this is a forwarding object
         (created by the Fwd method), and if so return the 
         forwarding pointer stored in it.  (This is how the 
         MPS remembers where a moved object was moved to).</li>
</ul>

<p>Create a padding object:</p>
<ul>
  <li> Pad (see <a href="../reference/index.html#mps_fmt_pad_t">mps_fmt_pad_t</a>):
         create a padding object here, please.</li>
</ul>

<h3><a id="format-methods-copy-is-obsolete">Format Methods: the Copy method is obsolete</a></h3>

<p>The Copy method is obsolete, and is never called.  The MPS just uses 
<code>mps_lib_memcpy()</code> to copy the bytes to the new location.  
It knows how many bytes to copy by using the Skip method.</p>

<p>Historical notes: The original justification for Copy was:</p>
<ul>
  <li> client (knowing the object's data fields) might intelligently 
         copy less than all the bytes;</li>
  <li> client might alter the data, eg. fixing-up internal pointers.</li>
</ul>
<p>... but this didn't happen with actual clients, and the interface 
to the copy method didn't pass the skip-size (which the MPS has 
already determined by calling Skip) and so didn't allow an efficient 
copy method to be written. So it was dropped, in 1998 or earlier.  
The only place this memcpy currently occurs is in poolamc.c,  in 
AMCFix() (and now AMCHeaderFix() too).</p>

<p>There are notes on this change at 
<a href="../../design/trace/#fix.nocopy">design/trace/#fix.nocopy</a>.</p>

<h3><a id="format-variants">Format Variants</a></h3>

<p>There are several different ways to package-up the format methods -- these different ways are called 'variants'.  MPS currently supports four format variants.  The creation functions for these are:</p>
<ul>
  <li> <a href="../reference/index.html#mps_fmt_create_A">mps_fmt_create_A</a>;</li>
  <li> <a href="../reference/index.html#mps_fmt_create_B">mps_fmt_create_B</a>;</li>
  <li> <a href="../reference/index.html#mps_fmt_create_auto_header">mps_fmt_create_auto_header</a>;</li>
  <li> <a href="../reference/index.html#mps_fmt_create_fixed">mps_fmt_create_fixed</a>.</li>
</ul>

<p>It's a bit messy -- sorry.</p>


<h2><a id="Allocation-Point">Allocation Point</a></h2>

<p>These notes on Allocation Points were written by RHSK between 
  2006-06-07 and 2006-06-12, following research and discussion with 
  RB and NB.</p>

<h3>Overview of two-phase allocation</h3>

<p>The client should:</p>
<ol>
  <li> <code>mps_reserve</code> some memory,</li>
  <li> construct a new object in it,</li>
  <li> write a reference to the new object into some older object, 
    thereby connecting the new object into the client's graph of 
    objects </li>
  <li> <code>mps_commit</code> the new object to MPS management.</li>
</ol>

<h3>The graph of managed references to mobile objects</h3>

<p>The MPS is a moving garbage collector: it supports 
  preserve-by-copying pools, whose objects are 'mobile'.  
  Whenever the MPS moves an object, it will ensure that 
  all managed references are updated to point to the 
  new location -- and this happens instantaneously as far 
  as the client sees it.</p>
  
<p>The client should assume that, between <em>any pair of 
  instructions</em>, the MPS may 'shake' this graph, moving 
  all the mobile objects, and updating all the managed 
  references.</p>
  
<p>The client usually takes care to ensure that the 
  references it 
  holds are managed.  To be managed, the reference must be 
  in a formatted object that is reachable from a root, or 
  actually in a root (such as a scanned stack). </p>
  
<p>It is okay for a careful client to hold unmanaged references, 
  but:</p>
<ul>
  <li> they'd better not be to a mobile object!  Remember, mobile 
    objects could move at any time, and unmanaged references 
    will be left 'dangling'.</li>
  <li> they'd better not be the only reference to an object, 
    or that object might get collected, again leaving a dangling 
    reference.</li>
</ul>

<h3>mps_reserve</h3>

<p><code>mps_reserve</code> returns a reference to a piece 
  of new memory for the client to build a new object in.  
  During this build, the MPS pins the piece of memory, and 
  treats it as raw data.</p>

<p>"Pinned" means: it will not move, be collected, be unmapped, 
  or anything like that.  You may keep an unmanaged reference to 
  it at this time.</p>

<p>"Raw data" means two things:</p> 
  
<p>Firstly, "raw data" means that any references stored IN the 
  new object are <em>unmanaged</em>.  This means:</p>
<ul>
  <li> references in the new object will not get updated if 
    the graph of managed references to mobile objects is 'shaken';</li>
  <li> references in the new object do not 
    preserve any old objects they point to.</li>
</ul>

<p>Secondly, "raw data" means that any references TO the new 
  object are treated like other references to unmanaged memory.
      [.belief.refs-to-uninit-safe:
       We're 'sure', but I need to check this.  What does Fix 
       actually do with a pointer into the init-alloc zone?  We
       hope it ignores it.  RHSK 2006-06-09]
  Because of this, you are permitted to connect the new object 
  into your graph of managed objects immediately.  The MPS gives 
  you these guarantees:</p>
<ul>
  <li> the new object is pinned (won't move), so references to it 
    that you write in old objects won't become stale at this time 
    (but see <code>mps_commit</code> below!)</li>
  <li> although the new object is reachable, the MPS knows it 
    is not yet managed, and will leave it in peace;</li>
  <li> the MPS will not call the client's format code to answer 
    questions about the new object.</li>
</ul>

<h3>Building the object</h3>

<p>The client will typically do all these things:</p>
<ul>
  <li> write data to make the new object 'valid' for the client's format;</li>
  <li> write other data into the new object;</li>
  <li> write references (to existing objects) into the new object;</li>
  <li> write a reference TO the new object into an existing object
     -- this connects the new object into the client's graph of 
     managed objects;</li>
</ul>

<p>However, during the build, the client <strong>MUST NOT</strong> read 
  (from the new object) a reference to an existing mobile object -- 
  because the reference is unmanaged and may be stale.</p>

<p>(Actually, the restriction is: the moment a reference to an 
  existing mobile object is written into the new object, that 
  reference (in the new object) may become stale.  And you'd better 
  not use (dereference) a stale reference.  And you'd better not 
  write it into any existing object.  Writing it back into another 
  part of the new object is okay.  Just don't trust it to be a valid 
  reference.)</p>

<h3>mps_commit</h3>

<p>When you call <code>mps_commit</code>, it will either fail or succeed.</p>

<p>Almost always, <code>mps_commit</code> succeeds.  
  If it succeeds, that means: </p>
<ul>
  <li> the new object is now just a normal object like any other, 
    which means it may get collected if there are no references 
    to it;</li>
  <li> all the references written IN the new object are valid (in 
    other words, a successful commit is the MPS's way of telling 
    you that these references did not become stale while they were 
    sitting unmanaged in the new object);</li>
  <li> all the references TO the new object are valid.</li>
</ul>

<p>Occasionally but rarely, <code>mps_commit</code> fails.  
  This means that the new object no longer exists.  
  The memory may even be unmapped by the time 
  <code>mps_commit</code> returns.</p>

<p>When this happens the client should take care to clear up any 
  managed references to the (now vanished) new object.</p>
  
<p>[But there's a hole here, before the client does this.  
    Are managed (aka scanned) references TO 
    it still safe?  They were safe during building 
    (by .belief.refs-to-uninit-safe).  But now the AP pointers have 
    gone away.  Are they still safe?  
    Clearly, if they are only RankAMBIG, they are safe.  
    What if they are RankEXACT?
    RHSK 2006-06-09]</p>
    
<p>[Discussion with RB 2006-06-09: yes, that's a problem for exact 
    references.  Must not make any exact refs to a new object.  And 
    unmanaged refs are not sufficient, because they won't preserve the 
    new object during commit.  So must make at least one ambiguous 
    ref to new object before calling commit.  That's the truth 
    currently.  There are various ways to solve this to allow 
    purely-exact mutators.  For instance, 
    keep the old init..alloc address-space flagged as a zombie zone, 
    until some communication with mutator (perhaps another reserve 
    from same AP?) indicates that mutator has removed all those 
    pesky exact refs to the now-dead ex-new object.  RHSK 2006-06-09]</p>

<p>The client will also have to re-create the object.  For this 
  reason the standard allocation point idiom is:</p>

<pre><code>
  do {
    if (mps_reserve != MPS_RES_OK) {
      goto fail_nomemory;
    }
    /* initialize my new object */
    /* make an ambiguous reference to new object */
  } while (! mps_commit);
  /* link new object into my object graph */
</code></pre>

<h2><a id="Allocation-Point-Detail">Allocation Points in Detail</a></h2>

<p>The synchronization issues are a little tricky.  This following 
  notes on these issues were written by RHSK between 
  2006-06-12 and 2006-06-12.</p>

<h3>scenario</h3>

<p>The MPS allocation point protocol is a binary protocol.  You don't 
  have to use the mps_reserve and mps_commit macros, but they are 
  conventional and useful pre-packaged implementations.  
  I'm using them as an example of correct protocol, referring to
  <a href="http://www.ravenbrook.com/project/mps/master/code/mps.h">mps.h#17</a>.
  It looks like this:</p>

<pre><code>#define mps_reserve(_p_o, _mps_ap, _size) \
  ((char *)(_mps_ap)-&gt;alloc + (_size) &gt; (char *)(_mps_ap)-&gt;alloc &amp;&amp; \
   (char *)(_mps_ap)-&gt;alloc + (_size) &lt;= (char *)(_mps_ap)-&gt;limit ? \
     ((_mps_ap)-&gt;alloc = \
       (mps_addr_t)((char *)(_mps_ap)-&gt;alloc + (_size)), \
      *(_p_o) = (_mps_ap)-&gt;init, \
      MPS_RES_OK) : \
     mps_ap_fill(_p_o, _mps_ap, _size))

#define mps_commit(_mps_ap, _p, _size) \
  ((_mps_ap)-&gt;init = (_mps_ap)-&gt;alloc, \
   (_mps_ap)-&gt;limit != 0 || mps_ap_trip(_mps_ap, _p, _size))
</code></pre>

<p>Abstractly, the mutator code has a cycle of four operations on the 
  allocation point:</p>
<dl>
  <dt> Lr </dt>
  <dd> read Limit at reserve </dd>
  
  <dt> A </dt>
  <dd> write Alloc at reserve </dd>
  
  <dt> I </dt>
  <dd> write Init at commit </dd>
  
  <dt> Lc </dt>
  <dd> read Limit at commit </dd>
</dl>

<p>The normal cycle is Lr A I Lc.</p>

<p>After Lr, the mutator checks that A + size &lt;= Lr.  If this fails, 
  then the mutator does mps_ap_fill instead of A.  So Lr mps_ap_fill I Lc 
  is also a valid cycle.</p>

<p>After Lc, the mutator checks that Lc != 0.  If this fails, the 
  mutator will call mps_ap_trip before beginning a new cycle.  So 
  Lr A I Lc mps_ap_trip is also a valid cycle.</p>

<p>The mutator cannot interrupt the 
  collector.</p>

<p>The collector can interrupt the mutator (between any 
  two mutator instructions).  The collector can only see the A, I, 
  and mps_ap_trip (if present) operations; Lr and Lc are invisible 
  to it.</p>

<p>If the ap is not going to trip, the collector sees two 
  equivalence classes:</p>
<ul>
  <li> (A)</li>
  <li> (I Lc Lr)</li>
</ul>

<p>If the ap is going to trip, the collector sees four
  equivalence classes:</p>
<ul>
  <li> (A)</li>
  <li> (I Lc)</li>
  <li> (the call to mps_ap_trip)</li>
  <li> (mps_ap_trip Lr)</li>
</ul>

<p>The collector has two responsibilities:</p>
<dl>
  <dt> FIX </dt> 
  <dd> to fix (or not fix) references TO the object;</dd>
  <dt> SCAN </dt>
  <dd> to scan (or not scan) references IN the object.</dd>
</dl>

<h3>A mutator with ambiguous references only (to the new object)</h3>

<p>Let's see what's required for a mutator that promises to make no 
  exact references to the new object until Lc succeeds, 
  and promises to have at least one ambiguous reference to the 
  new object when it sets I.</p>
  
<p>Consider a flip -- f1 -- in state A.</p>

<p>The collector at f1 sees (A), and recognises that the I..A region 
  is unmanaged memory.  
  The object is never going to be valid, 
  because it may contain stale references from before the flip, and the 
  collector can't fix them.</p>

<p>The f1 collector writes L = 0, tripping the allocation 
  point, and the rest of this collection is easy.  
  The FIX responsibility is easy: 
  all references to the new object are ambiguous, so the 
  collector can fix them or not -- it 
  doesn't matter.  
  For SCAN, the collector must not scan the new object 
  (because it is not yet formatted), so 
  it must not scan the buffered pool beyond I.</p>

<p>Further collections at this point are idempotent.</p>

<p>Now, suppose the mutator then restarts, but only gets as far 
  as (I Lc) before we have a second collection and a 
  second flip -- f2.</p>

<p>For FIX, f2 can fix or not -- it still doesn't matter.</p>

<p>But for SCAN, f2 <strong>MUST NOT</strong> scan the new object.
  Why not?</p>

<p>The mutator's format code will be okay: the fact 
  that I is set tells f2 that the object 
  is fully formatted.</p>

<p>But there is a problem: the object may contain stale exact 
  references -- unfixed references from before f1.  
  These stale exact references will be bogus.  
  Opinions differ on the implications of bogus exact references.  
  See the next section for a discussion.</p>

<p>Additionally, the collector is not <em>obliged</em> to scan the 
  object: this object is dead!  
  The mutator will later notice that Lr == 0 and realise the object 
  is invalid.  The mutator is not relying 
  on this object to keep anything else alive.</p>

<p>It is easy to avoid scanning the invalid object: 
  the first flip in state (A), f1, must record the value of I.  
  Call the recorded pointer If1.  
  Collections must not scan beyond If1.  
  If1 remains set until the mutator calls mps_ap_trip, 
  which resets If1 to 0.
  [Note: I have not checked whether the MPS 
  records and uses If1 -- RHSK 2006-06-12]</p>

<h3>How bad is a bogus exact reference?</h3>

<p>Tucker said:</p>
<blockquote><p>I believe the collector must be prepared to deal 
  with exact dangling pointers anyways, so this complex 
  mechanism is unnecessary.  
  [<a href="/project/mps/mail/1997/05/12/12-46/1.txt">//info.ravenbrook.com/project/mps/mail/1997/05/12/12-46/1.txt:X-MMInfo-Tag: mail.ptw.1997-05-12.12-46(1)</a>]
</p></blockquote>

<p>I'm not convinced.</p>

<p>Fixing a bogus exact reference is bad news.  
  The worst case is spoofing:
  Imagine the bogus exact reference points at part of a 
  JPEG that <em>just happens</em> to look like a validly formatted 
  object.  
  If this JPEG is in the middle of an object in a moving MPS 
  pool, fixing the bogus exact reference will overwrite a portion 
  of the JPEG with a forwarding object.  
  It gets worse: the spoof object is preserved and will later be 
  scanned, producing more bogus exact references!
  For "JPEG", you can substitute "encrypted string".</p>

<p>The only safe way to cope with such a bogus reference is for 
   Fix to verify that the reference points to the start of a real 
   object, which it could do by iteratating the format skip method 
   from some known point in the pool.</p>

<p>The consequences of fixing a bogus exact 
  reference may be:</p>
<ul>
  <li> Referent is not in MPS memory:
    <ul>
      <li> MPS must detect and ignore these; there should be a 
           debug option to report it;</li>
    </ul>
  </li>
  <li> Referent is not validly formatted:
    <ul>
      <li> mutator format code crashes; or</li>
      <li> mutator format code does something stupid or 
           illegal, and causes corruption or makes MPS crash; or</li>
      <li> (if we're lucky) mutator format code detects this 
           and avoids any harmful action.</li>
    </ul>
  </li>
  <li> Referent appears validly formatted, but is a spoof 
       (that is, it is actually data inside some other 
       object):
    <ul>
      <li> in a moving pool: the object is silently corrupted 
           with a forwarding pointer, and the spoof object is 
           preserved and will later be scanned, producing more 
           bogus exact references!</li>
      <li> in a non-moving pool: object is safe from corruption, 
           but MPS greying/blackening code needs to be robust to 
           this case.</li>
    </ul>
  </li>
  <li> Referent is a validly formatted but dead object:
    <ul>
      <li>it gets needlessly preserved;</li>
      <li>if it had been dead for some time, this dead object may 
          itself contain bogus exact references, and these will get 
          'fixed' too.</li>
    </ul>
  </li>
</ul>  

<p>Also, more arcanely, I wonder whether there's a problem if the 
  referent violates the tri-colour invariant (when scanning at 
  black)?  Does the MPS care about this, or does it 'safely' just 
  cause more conservatism?  Does MPS detect and flag this in 
  debug versions?  Could it?</p>

<p>If MPS or format code detects a bogus exact reference, it could 
  assert, and/or to fix them to a canonical special value.</p>

<p>Some possible contracts between mutator and collector:</p>
<ol>
  <li>Mutator and collector promise never to have bogus exact 
    references.  The collector is permitted to crash if it 
    encounters one.</li>
  <li>Mutator agrees that bogus exact references are wrong.  
    But mutator would like a helpful error message, please.  
    (Collector is not permitted to crash).</li>
  <li>Mutator wants permission to keep bogus exact references 
    in certain circumstances, such as on the stack.  Collector 
    must cope safely.  Need to specify how this is guaranteed, 
    based on intimate knowledge of the mutator's behaviour.  
    Dodgy.</li>
  <li>Mutator wants permission to keep bogus exact references 
    in general.  Collector must cope safely, with all the cases 
    of bogus exact references listed above.  I believe the MPS 
    does not currently do this.  It would require a very fast 
    check at fix time that the reference is to the start of a 
    valid object in an MPS client pool.</li>
</ol>

<h3>with exact refs</h3>

<p>We could define the protocol such that 
  the mutator can clear exact references to the new object 
  after Lc and before calling mps_ap_trip.  During this time, 
  the collector must keep the new object as pinned unmanaged 
  memory.  By calling mps_ap_trip, the mutator promises that 
  it has nulled-out any exact references to the new object, 
  and the collector in mps_ap_trip may unmap the memory or 
  safely re-use it without fear of spoofing.</p>

<h3>flipping at other times</h3>

<p>Perhaps the collector wants to flip even when the ap is not 
  at (A).  Need to analyse synchronization issues here.</p>

<h2><a id="section-B" name="section-B">B. Document History</a></h2>

<pre>
  2006-06-02  RHSK  Created.
  2006-06-02  RHSK  Introduction to MPS Formats
  2006-06-06  RHSK  Formats: clarify explanation of methods, copy method is 
                    obsolete, mention format variants.
  2006-06-09  RHSK  Allocation points: how it's supposed to be, from RB 2006-06-09.
  2006-06-09  RHSK  Allocation points: must make at least one ambiguous ref 
                    and no exact refs to new object before calling commit.
  2006-06-12  RHSK  Allocation points: minor edits for clarity.
  2006-06-12  RHSK  Allocation point detail: Scenario; A mutator with 
                    ambiguous references only (to the new object); How 
                    bad is a bogus exact reference?; quick notes on: with 
                    exact refs; flipping at other times.
</pre>


<h2><a id="section-C" name="section-C">C. Copyright and License</a></h2>

<p> This document is copyright &copy; 2006 <a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>.  All rights reserved.  This is an open source license.  Contact Ravenbrook for commercial licensing options. </p>

<p> Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: </p>

<ol>

<li> Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. </li>

<li> Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. </li>

<li> Redistributions in any form must be accompanied by information on how to obtain complete source code for the this software and any accompanying software that uses this software.  The source code must either be included in the distribution or be available for no more than the cost of distribution plus a nominal fee, and must be freely redistributable under reasonable conditions.  For an executable file, complete source code means the source code for all modules it contains. It does not include source code for modules or files that typically accompany the major components of the operating system on which the executable file runs. </li>

</ol>

<p> <strong> This software is provided by the copyright holders and contributors "as is" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability, fitness for a particular purpose, or non-infringement, are disclaimed.  In no event shall the copyright holders and contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. </strong> </p>


<hr />

<div class="banner">

<p><code>$Id$</code></p>

<p>
<a href="/">Ravenbrook</a>
/ <a href="/project/">Projects</a>
/ <a href="/project/mps/">Memory Pool System</a>
/ <a href="/project/mps/master/">Master Product Sources</a>
/ <a href="/project/mps/master/manual/">Manuals</a>
/ <a href="/project/mps/master/manual/wiki/">Wiki</a>
</p>

</div>

</body>

</html>
