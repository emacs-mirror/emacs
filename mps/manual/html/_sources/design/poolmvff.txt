.. _design-poolmvff:


.. index::
   pair: MVFF pool class; design
   single: pool class; MVFF design


MVFF pool class
===============

.. mps:prefix:: design.mps.poolmvff
   pair: MVFF pool class; design
   single: pool class; MVFF design


Introduction
------------

:mps:tag:`intro` This is the design of the MVFF (Manual Variable First-Fit)
pool class. This pool implements a first (or last) fit policy for
variable-sized manually-managed objects, with control over first/last,
segment preference high/low, and slot fit low/high.

The pool was created in a response to a belief that the ScriptWorks
EPDL/EPDR's first fit policy is beneficial for some classes of client
behaviour, but the performance of a linear free list was unacceptable.


Overview
--------

:mps:tag:`over` This pool implements certain variants of the address-ordered
first-fit policy. The implementation allows allocation across segment
boundaries.

:mps:tag:`over.buffer` Buffered allocation is also supported, but in that
case, the buffer-filling policy is worst-fit. Buffered and unbuffered
allocation can be used at the same time, but in that case, the first
ap must be created before any allocations.

:mps:tag:`over.buffer.class` The pool uses the simplest buffer class,
BufferClass. This is appropriate since these buffers don't attach to
segments, and hence don't constrain buffered regions to lie within
segment boundaries.

:mps:tag:`over.segments` The pool uses the simplest segment class
(SegClass). There's no need for anything more complex.


Methods
-------

:mps:tag:`method` The MVFF pool supports the following methods:

.. c:function:: Res MVFFInit(Pool pool, Args arg)

:mps:tag:`method.init` This takes six `keyword arguments`_:

.. _`keyword arguments`: keyword-arguments

================================== ============================================
Keyword argument                   Description
================================== ============================================
:c:macro:`MPS_KEY_EXTEND_BY`       The segment size.
:c:macro:`MPS_KEY_MEAN_SIZE`       The average object size.
:c:macro:`MPS_KEY_ALIGN`           The alignment of allocations and frees.
                                   Must be at least ``sizeof(voidÂ *)``.
:c:macro:`MPS_KEY_MVFF_SLOT_HIGH`  Whether to allocate objects at the end of 
                                   free blocks found, as opposed to at
                                   the start (for unbuffered
                                   allocation).
:c:macro:`MPS_KEY_MVFF_ARENA_HIGH` Whether to express ``SegPrefHIGH``
                                   to the arena, as opposed to
                                   ``SegPrefLOW``.
:c:macro:`MPS_KEY_MVFF_FIRST_FIT`  whether to use the suitable block of lowest
                                   address, as opposed to the highest
                                   (for unbuffered allocation)
================================== ============================================

:mps:tag:`method.init.epdl` To simulate the EPDL pool, specify ``extendBy``,
``avgSize``, and ``maxSize`` as normal, and use ``slotHigh=FALSE``,
``arenaHigh=FALSE``, ``firstFit=TRUE``.

:mps:tag:`method.init.epdr` To simulate the EPDR pool, specify ``extendBy``,
``avgSize``, and ``maxSize`` as normal, and use ``slotHigh=TRUE``,
``arenaHigh=TRUE``, ``firstFit=TRUE``.

:mps:tag:`method.init.other` The performance characteristics of other
combinations are unknown.

:mps:tag:`method.finish` The :c:func:`PoolFinish()` method,

:mps:tag:`method.alloc` :c:func:`PoolAlloc()` and :c:func:`PoolFree()` methods are
supported, implementing the policy set by the pool params (see
:mps:ref:`.method.init`).

:mps:tag:`method.describe` The usual describe method.

:mps:tag:`method.buffer` The buffer methods implement a worst-fit fill
strategy.


External Functions
------------------

:mps:tag:`function` MVFF supports the following external functions:

:mps:tag:`function.free-size` :c:func:`mps_mvff_free_size()` returns the total
size of free space in segments allocated to the MVFF pool instance.

:mps:tag:`function.size` :c:func:`mps_mvff_size()` returns the total memory used
by pool segments, whether free or allocated.

:mps:tag:`function.class` :c:func:`mps_class_mvff()` returns the class object for
the pool class, to be used in pool creation.


Implementation
--------------

:mps:tag:`impl.free-list` The pool stores its free list in a CBS (see
`design.mps.cbs <cbs/>`_). It uses the CBS's mayUseInline facility to
avoid running out of memory to store the free list. This is the reason
for the alignment restriction above.


Details
-------

:mps:tag:`design.seg-size` When adding a segment, we use extendBy as the
segment size unless the object won't fit, in which case we use the
object size (in both cases we align up).

:mps:tag:`design.seg-fail` If allocating a segment fails, we try again with
a segment size just large enough for the object we're allocating. This
is in response to `request.mps.170186`_.

.. _`request.mps.170186`: https://info.ravenbrook.com/project/mps/import/2001-11-05/mmprevol/request/mps/170186/


