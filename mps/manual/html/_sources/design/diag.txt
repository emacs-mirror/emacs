.. _design-diag:


.. index::
   pair: diagnostic feedback; design


Diagnostic feedback
===================

.. mps:prefix:: design.mps.diag


Introduction
------------

:mps:tag:`intro` This document describes how to use the diagnostic feedback
mechanism in the Memory Pool System.

:mps:tag:`sources` Initially abased on [RHSK_2007-04-13]_ and [RHSK_2007-04-18]_.


Overview
--------

Diagnostic feedback is information created by the MPS diagnostic
system for the purpose of helping MPS programmers client-code
programmers.

Such a piece of information is called "a diagnostic". (See also
:mps:ref:`.parts`.)

A diagnostic is not intended to be end-user readable (or visible), or
machine-parseable.

A diagnostic is not intended to be stable from one release to the
next: it may be modified or removed at any time.


Requirements
------------

MPS diagnostic feedback code must do these things:

- calculate, store, and propagate data; 
- collate, synthesise, and format it into a human-useful diagnostic; 
- control (for example, filter) output of diagnostics;
- use a channel to get the diagnostic out. 

Note: the knowledge/code/logic for constructing the human-useful
message is kept inside normal MPS source code. This means it is always
in-sync with changes to the MPS. This also means that any external
utilities used to display the messages do not need to understand, or
keep in sync with, the details of what's going inside the MPS.


Usage
-----

To run the MPS and get diagnostic output from it:

1. Use a variety with diagnostics compiled-in. Currently, that means
   variety.di. See ``config.h``.

2. Check that the diagnostics you require are generated, by looking in
   MPS source for invocations of the appropriate macro (for example,
   :c:func:`DIAG_SINGLEF()`).

3. Check that the diagnostics you require will be output, by looking
   at the diagnostic filter rules in ``diag.c``.

4. Run the MPS and client in an environment that supports the channel
   used (for example, at a command-line if using :c:func:`WriteF()`).


What is a diagnostic?
.....................

A diagnostic has three parts:

1. a trigger condition, that causes this diagnostic to be emitted; 
2. a text tag (for example, "TraceStart") which is the name of this
   diagnostic; and
3. a paragraph of human-useful text.

A diagnostic is emitted by the MPS at a certain point in time when a
certain event happens.

Diagnostics are not nested. Every diagnostic must have a tag. Each
diagnostic should have a unique tag (uniqueness is just to help the
humans; the diagnostic system does not care).

The paragraph of text can be many lines long. It usually explains what
event caused the diagnostic to be emitted, and commonly also includes
the output of some :c:func:`Describe()` methods for various relevant
objects. (For example, the ``TraceStart`` diagnostic might call, and
include the output generated by, the :c:func:`TraceDescribe()` method).

How do I control (filter) which diagnostics I see?
..................................................

All diagnostics are emitted and then filtered according to the
"diagnostic filter rules".

The first level of control is filtering by tag. (For example, only
show ``TraceStart`` diagnostics).

The second level of control is filtering by paragraph content. (For
example, only show ``TraceStart`` diagnostics where the trace is
started because a nursery generation is full).

The third level of control is filtering by line content. (For example,
only show lines containing the word ``whiteSet``).

See ``diag.c`` for details.

Note: the entire filtering mechanism can be turned off, so that
diagnostics go immediately to ``mps_lib_get_stdout(0``, with no
buffering or filtering See impl.c.diag.filter-disable.


How to write a diagnostic
-------------------------

Improve stateless Describe methods where possible
.................................................

Where possible, don't put clever code into an event-triggered
diagnostic: put it into a stateless :c:func:`Describe()` method instead, and
then call that method when emitting your diagnostic.

For example::

    FooDescribe(Foo foo, mps_lib_FILE *stream)
    {
      /* show value of new "quux" field */
      WriteF(stream, "Foo: $P { quux: $U }\n", foo, foo->quux);
    }

    FooWibble(Foo foo)
    {
      ...
      DIAG_FIRSTF(( "FooWibble", "Wibbling foo $P", foo, NULL));
      DIAG( FooDescribe(foo, DIAG_STREAM); );
      DIAG_END("FooWibble");
      ...
    }  

This is much better, because other people can use your human-useful
output in their diagnostics, or 'live' in a debugger.


Use the output macros
.....................

For a simple diagnostic, use :c:func:`DIAG_SINGLEF()`. This begins the tag,
puts text into the paragraph, and ends the tag immediately.

For a more complex diagnostic, the first call must be
:c:func:`DIAG_FIRSTF()`, which begins a diag tag.

While a tag is current, you can add text to the diagnostic's paragraph
using :c:func:`DIAG_MOREF()`, and ``WriteF( DIAG_STREAM, ... )``.

.. note::

    :c:macro:`DIAG_STREAM` is not a real standard C library stream. If you
    want stream-level access, you may use :c:func:`Stream_fputc()` and
    :c:func:`Stream_fputs()`.

End the tag by calling :c:macro:`DIAG_END`.


Compile away in non-diag varieties; no side effects
...................................................

Wrap non-output code with the :c:func:`DIAG()` and :c:func:`DIAG_DECL()` macros,
to make sure that non-diag varieties do not execute
diagnostic-generating code.

For complex diagnostic-generating code, it may be cleaner to move it
into a separate local function. Put ``_diag`` on the end of the function
name (for example, :c:func:`TraceStart_diag()`).

Obviously, diagnostic-generating code must have no side effects.


Choosing tags
.............

Tags should be valid C identifiers. Unless you know of a good reason
why not. (Not currently checked).

There's no formal scheme for tag naming, but make it helpful and
informally hierarchical, for example, ``TraceBegin``, ``TraceStart``,
``TraceEnd``, and so on, not ``BeginTrace``, ``EndTrace``.


Writing good paragraph text
...........................

IMPORTANT: Make your diagnostics easy to understand! Other people will
read your diagnostics! Make them clear and helpful. Do not make them
terse and cryptic. If you use symbols, print a key in the diagnostic.
(If you don't want to see this the screen clutter, then you can always
add a filter rule to your personal rule set to filter it out).


Maintaining helpful filter rules
................................

If you add a noisy diagnostic, add a rule to the default ruleset to
turn it off.


How the MPS diagnostic system works
-----------------------------------

Channels
........

The recommended channel is :c:func:`WriteF()` to standard output.

Other possible of future channels might be:

- :c:func:`printf()`; 
- a new type (yet to be defined) of ``mps_message``;
- squirt them into the telemetry-log-events system; 
- telnet.

Currently, only :c:func:`printf()` and :c:func:`WriteF()` are supported. See the
:c:macro:`DIAG_WITH_` macros in ``mpm.h``.

You can also use a debugger to call :c:func:`Describe()` methods directly,
from within the debugger.

Note: it is unfortunate that choice of channel may (for some channels)
also dictate the form of the code that synthesises the message. (For
example, :c:func:`WriteF()` style parameter-expansion is not possible when
using the :c:func:`printf()` channel, because there is no way to get
:c:func:`WriteF()` to produce its output into a string). This is just a
technical hitch; logically, the code that synthesises a diagnostic
message should not care which channel will be used to transmit it out
of the MPS.


Parts of the MPS diagnostic system
..................................

:mps:tag:`parts` The following facilities are considered part of the MPS
diagnostic system:

- the :c:func:`Describe()` methods. 
- the :c:macro:`DIAG` macros (:c:macro:`DIAG`, :c:macro:`DIAG_DECL`, ``DIAG_*F``, and so on); 
- the :c:macro:`STATISTIC` macros (see ``mpm.h``); 
- the :c:macro:`METER` macros and meter subsystem.


Related systems
...............

The MPS diagnostic system is separate from the following other MPS
systems:

- The telemetry-log-events system. This emits much more data, in a
  less human-readable form, requires MPS-aware external tools, and is
  more stable from release to release). In non-diagnostic telemetry
  varieties, the telemetry-log-events system emits events that log all
  normal MPS actions. In diagnostic telemetry varieties, it may emit
  additional events containing diagnostic information. Additionally,
  the telemetry-log-events stream might in future be available as a
  channel for emitting human-readable text diagnostics. See also
  design.mps.telemetry.
       
- The MPS message system. This is present in all varieties, and
  manages asynchronous communication from the MPS to the client
  program). However, the MPS message system might in future also be
  available as a channel for emitting diagnostics. See also
  design.mps.message.



References
----------

.. [RHSK_2007-04-13] Richard Kistruck. 2007-04-13. "`diagnostic feedback from the MPS <https://info.ravenbrook.com/mail/2007/04/13/13-07-45/0.txt>`_".

.. [RHSK_2007-04-18] Richard Kistruck. 2007-04-18. "`Diverse types of diagnostic feedback <http://info.ravenbrook.com/mail/2007/04/18/10-58-49/0.txt>`_".


