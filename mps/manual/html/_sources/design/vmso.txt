
.. index::
   pair: VM for Solaris; design

.. _design-vmso:


VM for Solaris
==============

.. mps:prefix:: design.mps.vmso

.. warning::

    As of 2013-05-26, the MPS is no longer supported on Solaris, so
    this document is only of historical interest.


Introduction
------------

:mps:tag:`intro` This is the design for the VM implementation on Solaris 2.x
(see os.so for OS details). The implementation is in MMsrc!vmso.c
(impl.c.vm). The design follows the design for and implements the
contract of the generic VM interface (design.mps.vm). To summarize:
The VM module provides a mechanism to reserve large (relative to the
amount of RAM) amounts of address space, and functions to map (back
with RAM) and unmap portions of this address space.

:mps:tag:`source` Much of the implementation (and hence the design) was
inherited from the SunOS4 implementation. Not that there's any design
for that. You'll find the ``mmap(2)`` (for the system call :c:func:`mmap()`)
and the ``zero(7d)`` (for the device ``/dev/zero``) man pages useful
as well. The generic interface and some generic design is in
design.mps.vm.


Definitions
-----------

:mps:tag:`def` See design.mps.vm.def.* for definitions common to all VMs.


Overview
--------

:mps:tag:`over` The system calls :c:func:`mmap()` and :c:func:`munmap()` are used to
access the underlying functionality. They are used in slightly unusual
ways, typically to overcome baroque features or implementation details
of the operating system.

:mps:tag:`over.reserve` In order to reserve address space, a mapping to a
file (``/etc/passwd`` as it happens) is created with no protection
allowed.

:mps:tag:`over.map` In order to map memory, a mapping to ``/dev/zero`` is
created.

:mps:tag:`over.destroy` When the VM is destroyed, :c:func:`munmap()` is used to
remove all the mappings previously created.


Implementation
--------------

:mps:tag:`impl.create` :c:func:`VMCreate()`

:mps:tag:`impl.create.vmstruct` Enough pages to hold the :c:type:`VMStruct` are
allocated by creating a mapping to ``/dev/zero`` (a read/write private
mapping), and using initializing the memory as a :c:type:`VMStruct`.

:mps:tag:`impl.create.reserve` The size parameter is rounded up to page size
and this amount of address space is reserved. The address space is
reserved by creating a shared mapping to ``/etc/passwd`` with no
access allowed (the ``prot`` argument is :c:macro:`PROT_NONE`, and the
``flags`` argument is :c:macro:`MAP_SHARED`).

:mps:tag:`impl.create.reserve.mmap.justify` :c:func:`mmap()` gives us a flexible
way to allocate address space without interfering with any other
component in the process. Because we don't specify :c:macro:`MAP_FIXED` we
are guaranteed to get a range of addresses that are not in use. Other
components must cooperate by not attempting to create mappings
specifying :c:macro:`MAP_FIXED` and an address in the range that the MPS has
reserved.

:mps:tag:`impl.create.reserve.passwd.justify` Mapping ``/etc/passwd`` like
this worked on SunOSÂ 4 (so this implementation inherited it). Mapping
``/dev/zero`` with ``prot=PROT_NONE`` and ``flags=MAP_PRIVATE`` does
not work because Solaris gratuitously allocates swap (even though you
can't use the memory).

:mps:tag:`impl.create.reserve.improve` However, it would appears that or-ing
in :c:macro:`MAP_NORESERVE` mapping ``/dev/zero`` will reserve address space
without allocating swap, so this might be worth trying. That is, with
``prot=PROT_NONE`` and ``flags=MAP_PRIVATE|MAP_NORESERVE``. However
the following caveat comes from the original implementation:
"Experiments have shown that attempting to reserve address space by
mapping ``/dev/zero`` results in swap being reserved. This appears to
be a bug, so we work round it by using ``/etc/passwd``, the only file
we can think of which is pretty much guaranteed to be around." So that
might not work after all.

:mps:tag:`impl.map` :c:func:`VMMap()`

:mps:tag:`impl.map.zero` A mapping to ``/dev/zero`` is created at the
relevant addresses (overriding the map to ``/etc/passwd`` that was
previously in place for those addresses). The ``prot`` argument is
specified as ``PROT_READ|PROT_WRITE|PROT_EXEC`` (so that any access is
allowed), the ``flags`` argument as ``MAP_PRIVATE|MAP_FIXED``. The
flag :c:macro:`MAP_PRIVATE` means that the mapping is not shared with child
processes (child processes will have a mapping, but changes to the
memory will not be shared). The flag :c:macro:`MAP_FIXED` guarantees that we
get the mapping at the specified address). The ``zero(7d)`` man page
documents this as a way to create a "zero-initialized unnamed memory
object".

:mps:tag:`impl.map.error` If there's not enough swap space for the mapping,
:c:func:`mmap()` will return :c:macro:`EAGAIN`, not :c:macro:`ENOMEM`, although you might
not think so from the man page.

:mps:tag:`impl.unmap` :c:func:`VMUnmap()`

:mps:tag:`impl.unmap.reserve` The relevant addresses are returned to the
reserved state by creating a mapping to ``/etc/passwd`` (overriding
the map ``/dev/zero`` that was previously in place for those
addresses). As for :c:func:`VMCreate()` (see :mps:ref:`.impl.create.reserve` above)
the ``prot`` argument is :c:macro:`PROT_NONE`, but the ``flags`` argument has
the addition :c:macro:`MAP_FIXED` flags (so is ``MAP_SHARED|MAP_FIXED``).

:mps:tag:`impl.unmap.reserve.offset` The offset argument is specified to be
the offset of the addresses being unmapped from the base of the
reserved VM area.

:mps:tag:`impl.unmap.reserve.offset.justify` Not specifying the offset like
this makes Solaris create a separate mapping (in the kernel) each time
Unmap is used, eventually the call to :c:func:`mmap()` will fail. Specifying
offset like this does not cause Solaris to create any extra mappings,
the existing mapping to ``/etc/passwd`` gets reused.


