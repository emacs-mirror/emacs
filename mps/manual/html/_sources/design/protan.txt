
.. index::
   pair: ANSI; protection interface design
   pair: ANSI protection interface; design

.. _design-protan:


ANSI implementation of protection module
========================================

.. mps:prefix:: design.mps.protan
   pair: ANSI; protection interface design
   pair: ANSI protection interface; design


Introduction
------------

:mps:tag:`readership` Any MPS developer.

:mps:tag:`intro` This is the design for the ANSI implementation of the
protection module.


Requirements
------------

:mps:tag:`req.test` This module is required for testing. Particularly on
platforms where no real implementation of the protection module
exists.

:mps:tag:`req.rapid-port` This module is required for rapid porting. It
should enable a developer to port a minimally useful configuration of
the MPS to new platforms very quickly.


Overview
--------

:mps:tag:`overview` Most of the functions in the module do nothing. The
exception is :c:func:`ProtSync()` which traverses over all segments in the
arena and simulates an access to each segment that has any protection
on it. This means that this module depends on certain fields in the
segment structure.

:mps:tag:`overview.noos` No operating system specific (or even ANSI hosted
specific) code is in this module. It can therefore be used on any
platform, particularly where no real implementation of the module
exists. It satisfies :mps:ref:`.req.test` and :mps:ref:`.req.rapid-port` in this way.


Functions
---------

:mps:tag:`fun.protsetup` :c:func:`ProtSetup()` does nothing as there is nothing to
do (under UNIX we might expect the protection module to install one or
more signal handlers at this pointer, but that is not appropriate for
the ANSI implementation). Of course, we can't have an empty function
body, so there is a ``NOOP;`` here.

:mps:tag:`fun.sync` :c:func:`ProtSync()` is called to ensure that the actual
protection of each segment (as determined by the OS) is in accordance
with the segments's pm field. In the ANSI implementation we have no
way of changing the protection of a segment, so instead we generate
faults on all protected segments in the assumption that that will
remove the protection on segments.

:mps:tag:`fun.sync.how` Continually loops over all the segments until it
finds that all segments have no protection.

:mps:tag:`fun.sync.seg` If it finds a segment that is protected then
:c:func:`PoolAccess()` is called on that segment's pool and with that
segment. The call to :c:func:`PoolAccess()` is wrapped with a
:c:func:`ShieldEnter()` and :c:func:`ShieldLeave()` thereby giving the pool the
illusion that the fault was generated outside the MM. This depends on
being able to determine the protection of a segment (using the ``pm``
field), on being able to call :c:func:`ShieldEnter()` and :c:func:`ShieldLeave()`,
and on being able to call :c:func:`PoolAccess()`.


