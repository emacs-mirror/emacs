.. _design-finalize:


.. index::
   pair: finalization; design


Finalization
============

.. mps:prefix:: design.mps.finalize


Overview
--------

:mps:tag:`overview` Finalization is implemented internally using the
Guardian Pool Class (design.mps.poolmrg). Objects can be registered
for finalization using an interface function (called
:c:func:`mps_finalize()`). Notification of finalization is given to the client
via the messaging interface. ``PoolClassMRG`` (design.mps.poolmrg)
implements a Message Class which implements the finalization messages.


Requirements
------------

:mps:tag:`req` Historically only Dylan had requirements for finalization,
see req.dylan.fun.final. Now (2003-02-19) Configura have requirements
for finalization. Happily they are very similar.


Architecture
------------

External interface
..................

:mps:tag:`if.register` :c:func:`mps_finalize()` increases the number of times that
an object has been registered for finalization by one. The object must
have been allocated from the arena (space). Any finalization messages
that are created for this object will appear on the arena's message
queue. The MPS will attempt to finalize the object that number of
times.

:mps:tag:`if.deregister` :c:func:`mps_definalize()` reduces the number of times that
the object located at ``obj`` has been registered for finalization by
one. It is an error to definalize an object that has not been
registered for finalization.

:mps:tag:`if.deregister.not` At the moment (1997-08-20) :c:func:`mps_definalize()`
is not implemented.

:mps:tag:`if.get-ref` :c:func:`mps_message_finalization_ref()` returns the reference
to the finalized object stored in the finalization message.


Implementation
--------------

:mps:tag:`int.over` Registering an object for finalization corresponds to
allocating a reference of rank FINAL to that object. This reference is
allocated in a guardian object in a pool of ``PoolClassMRG`` (see
design.mps.poolmrg).

:mps:tag:`int.arena.struct` The MRG pool used for managing final references
is kept in the Arena (Space), referred to as the "final pool".

:mps:tag:`int.arena.lazy` The pool is lazily created. It will not be created
until the first object is registered for finalization.

:mps:tag:`int.arena.flag` There is a flag in the Arena that indicates
whether the final pool has been created yet or not.

.. c:function:: Res ArenaFinalize(Arena arena, Ref addr)

:mps:tag:`int.finalize.create` Creates the final pool if it has not been
created yet.

:mps:tag:`int.finalize.alloc` Allocates a guardian in the final pool.

:mps:tag:`int.finalize.write` Writes a reference to the object into the
guardian object.

:mps:tag:`int.finalize.all` That's all.

:mps:tag:`int.finalize.error` If either the creation of the pool or the
allocation of the object fails then the error will be reported back to
the caller.

:mps:tag:`int.finalize.error.no-unwind` This function does not need to do
any unwinding in the error cases because the creation of the pool is
not something that needs to be undone.

:mps:tag:`int.arena-destroy.empty` :c:func:`ArenaDestroy()` empties the message
queue by calling :c:func:`MessageEmpty()`.

:mps:tag:`int.arena-destroy.final-pool` If the final pool has been created
then :c:func:`ArenaDestroy()` destroys the final pool.

:mps:tag:`access` :c:func:`mps_message_finalization_ref()` needs to access the
finalization message to retrieve the reference and then write it to
where the client asks. This must be done carefully, in order to avoid
breaking the invariants or creating a hidden root.

:mps:tag:`access.invariants` We protect the invariants by using special
routines :c:func:`ArenaRead()` and :c:func:`ArenaPoke()` to read and write the
reference. This works as long as there's no write-barrier collection.

.. note::

    Instead of :c:func:`ArenaPoke()`, we could put in an :c:func:`ArenaWrite()`
    that would be identical to :c:func:`ArenaPoke()`, except that it would
    :c:func:`AVER()` the invariant (or it can just :c:func:`AVER()` that there are
    no busy traces unflipped). When we get write-barrier collection,
    we could change it to do the real thing, but in the absence of a
    write-barrier, it's functionally identical to :c:func:`ArenaPoke()`.
    Pekka P. Pirinen, 1997-12-09.


