
.. index::
   pair: protection interface; design

.. _design-prot:


The protection module
=====================

.. mps:prefix:: design.mps.prot


Introduction
------------

:mps:tag:`intro` This is the generic design of the Protection Module. The
protection module provides protection services to other parts of the
MPS. It is expected that different operating systems will have
different implementations of this module.

:mps:tag:`readership` Any MPS developer.


Interface
---------

.. c:function:: void ProtSetup(void)

:mps:tag:`if.setup` :c:func:`ProtSetup()` will be called exactly once (per
process). It will be called as part of the initialization of the first
space that is created. It should arrange for the setup and
initialization of any datastructures or services that are necessary in
order to implement the protection module. (On UNIX it expected that it
will install a signal handler, on Windows it will do nothing)

.. c:function:: void ProtSet(Addr base, Addr limit, AccessSet mode)

:mps:tag:`if.set` :c:func:`ProtSet()` should set the protection of the memory
between base and limit, including base, but not including limit (ie
the half-open interval [base,limit)) to that specified by mode. The
mode parameter should have the ``AccessWRITE`` bit set if write
accesses to the page are to be forbidden, and should have the
``AccessREAD`` bit set if read accesses to the page are to be
forbidden. A request to forbid read accesses (that is, ``AccessREAD``
is set) may also forbid write accesses, but read accesses will not be
forbidden unless ``AccessREAD`` is set.

.. c:function:: void ProtTramp(void **resultReturn, void *(*f)(void *, size_t), void *p, size_t s)

:mps:tag:`if.tramp` [undocumented]

.. c:function:: void ProtSync(Space space)

:mps:tag:`if.sync` :c:func:`ProtSync()` is called to ensure that the actual
protection of each segment (as determined by the OS) is in accordance
with the segments's ``pm`` field.

.. c:type:: struct MutatorFaultContextStruct *MutatorFaultContext

:mps:tag:`if.context-type` This abstract type is implemented by the
protection module (impl.c.prot*). It represents the continuation of
the mutator which is restored after a mutator fault has been handled.
The functions :c:func:`ProtCanStepInstruction()` (:mps:ref:`.if.canstep` below) and
:c:func:`ProtStepInstruction()` (:mps:ref:`.if.step` below) inspect and manipulate
the context.

.. c:function:: Bool ProtCanStepInstruction(MutatorFaultContext context)

:mps:tag:`if.canstep` Examines the context to determine whether the
protection module can single-step the instruction which is causing the
fault. Should return :c:macro:`TRUE` if and only if the instruction can be
single-stepped (that is, :c:func:`ProtStepInstruction()` can be called).

.. c:function:: Bool Res ProtStepInstruction(MutatorFaultContext context)

:mps:tag:`if.step` Single-steps the instruction which is causing the fault.
This function should only be called if :c:func:`ProtCanStepInstruction()`
applied to the context returned :c:macro:`TRUE`. It should return
``ResUNIMPL`` if the instruction cannot be single-stepped. It should
return ``ResOK`` if the instruction is single-stepped.

The mutator context will be updated by the emulation/execution of the
instruction such that resuming the mutator will not cause the
instruction which was causing the fault to be executed.


