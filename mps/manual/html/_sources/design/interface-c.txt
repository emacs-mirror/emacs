.. _design-interface-c:


.. index::
   pair: C interface; design


C interface design
==================

.. mps:prefix:: design.mps.interface.c


Introduction
------------

:mps:tag:`scope` This document is the design for the Memory Pool System
(MPS) interface to the C Language, impl.h.mps.

:mps:tag:`bg` See mail.richard.1996-07-24.10-57.


Analysis
--------

Goals
.....

:mps:tag:`goal.c` The file impl.h.mps is the C external interface to the
MPS. It is the default interface between client code written in C and
the MPS. :mps:tag:`goal.cpp` impl.h.mps is not specifically designed to be
an interface to C++, but should be usable from C++.


Requirements
............

:mps:tag:`req` The interface must provide an interface from client code
written in C to the functionality of the MPS required by the product
(see req.product), Dylan (req.dylan), and the Core RIP (req.epcore).

``mps.h`` may not include internal MPS header files (such as
``pool.h``).

It is essential that the interface cope well with change, in order to
avoid restricting possible future MPS developments. This means that
the interface must be "open ended" in its definitions. This accounts
for some of the apparently tortuous methods of doing things
(``mps_fmt_A_t``, for example). The requirement is that the MPS should
be able to add new functionality, or alter the implementation of
existing functionality, without affecting existing client code. A
stronger requirement is that the MPS should be able to change without
*recompiling* client code. This is not always possible.

.. note::

    `.naming.global` was presumably done in response to unwritten
    requirements regarding the use of the name spaces in C, perhaps
    these:

    - :mps:tag:`req.name.iso` The interface shall not conflict in terms of
      naming with any interfaces specified by ISO C and all reasonable
      future versions.

    - :mps:tag:`req.name.general` The interface shall use a documented and
      reasonably small portion of the namespace so that clients can
      interoperate easily.

    David Jones, 1998-10-01.


Architecture
------------

:mps:tag:`fig.arch` The architecture of the MPS Interface

[missing figure]

Just behind ``mps.h`` is the file ``mpsi.c``, the "MPS interface
layer" which does the job of converting types and checking parameters
before calling through to the MPS proper, using internal MPS methods.


General conventions
-------------------

:mps:tag:`naming` The external interface names should adhere to the
documented interface conventions; these are found in
doc.mps.ref-man.if-conv(0).naming. They are paraphrased/recreated
here.

:mps:tag:`naming.unixy` The external interface does not follow the same
naming conventions as the internal code. The interface is designed to
resemble a more conventional C, Unix, or Posix naming convention.

:mps:tag:`naming.case` Identifiers are in lower case, except
non-function-like macros, which are in upper case.

:mps:tag:`naming.global` All publicised identifiers are 
prefixed ``mps_`` or :c:macro:`MPS_`.

:mps:tag:`naming.all` All identifiers defined by the MPS 
should begin ``mps_`` or :c:macro:`MPS_` or ``_mps_``.

:mps:tag:`naming.type` Types are suffixed ``_t``.

:mps:tag:`naming.struct` Structure types and tags are suffixed ``_s``.

:mps:tag:`naming.union` Unions types and tags are suffixed ``_u``.

:mps:tag:`naming.scope` The naming conventions apply to all identifiers (see
ISO C §6.1.2); this includes names of functions, variables, types
(through typedef), structure and union tags, enumeration members,
structure and union members, macros, macro parameters, labels.

:mps:tag:`naming.scope.labels` labels (for ``goto`` statements) should be
rare, only in special block macros and probably not even then.

.. note::

    This principle is not adhered to in the source code, which uses
    ``goto`` for handling error cases. Gareth Rees, 2013-05-27.

:mps:tag:`naming.scope.other` The naming convention would also extend to
enumeration types and parameters in functions prototypes but both of
those are prohibited from having names in an interface file.

:mps:tag:`type.gen` The interface defines memory addresses as ``void *`` and
sizes as ``size_t`` for compatibility with standard C (in particular,
with :c:func:`malloc()`). These types must be binary compatible with the
internal types :c:type:`Addr` and :c:type:`Size` respectively. Note that this
restricts the definitions of the internal types :c:type:`Addr` and :c:type:`Size`
when the MPS is interfaced with C, but does not restrict the MPS in
general.

:mps:tag:`type.opaque` Opaque types are defined as pointers to structures
which are never defined. These types are cast to the corresponding
internal types in ``mpsi.c``.

:mps:tag:`type.trans` Some transparent structures are defined. The client is
expected to read these, or poke about in them, under restrictions
which should be documented. The most important is probably the
allocation point (:c:type:`mps_ap_s`) which is part of allocation buffers.
The transparent structures must be binary compatible with
corresponding internal structures. For example, the fields of
:c:type:`mps_ap_s` must correspond with :c:type:`APStruct` internally. This is
checked by ``mpsi.c`` in :c:func:`mps_check()`.

:mps:tag:`type.pseudo` Some pseudo-opaque structures are defined. These only
exist so that code can be inlined using macros. The client code
shouldn't mess with them. The most important case of this is the scan
state (:c:type:`mps_ss_s`) which is accessed by the in-line scanning macros,
``MPS_SCAN_*`` and ``MPS_FIX*``.

:mps:tag:`type.enum` There should be no enumeration types in the interface.
Note that enum specifiers (to declare integer constants) are fine as
long as no type is declared. See guide.impl.c.misc.enum.type.

:mps:tag:`type.fun` Whenever function types or derived function types (such
as pointer to function) are declared a prototype should be used and
the parameters to the function should not be named. This includes the
case where you are declaring the prototype for an interface function.

:mps:tag:`type.fun.example` So use::

    extern mps_res_t mps_alloc(mps_addr_t *, mps_pool_t, size_t, ...);

rather than::

    extern mps_res_t mps_alloc(mps_addr_t *addr_return, mps_pool_t pool , size_t size, ...);

and::

    typedef mps_addr_t (*mps_fmt_class_t)(mps_addr_t);

rather than::

    typedef mps_addr_t (*mps_fmt_class_t)(mps_addr_t object);

See guide.impl.c.misc.prototype.parameters.


Checking
--------

:mps:tag:`check.space` When the arena needs to be recovered from a parameter
it is check using ``AVERT(Foo, foo)`` before any attempt to call
``FooArena(foo)``. The macro :c:func:`AVERT()` in impl.h.assert performs
simple thread-safe checking of ``foo``, so it can be called outside of
:c:func:`ArenaEnter()` and :c:func:`ArenaLeave()`.

:mps:tag:`check.types` We use definitions of types in both our external
interface and our internal code, and we want to make sure that they
are compatible. (The external interface changes less often and hides
more information.) At first, we were just checking their sizes, which
wasn't very good, but I've come up with some macros which check the
assignment compatibility of the types too. This is a sufficiently
useful trick that I thought I'd send it round. It may be useful in
other places where types and structures need to be checked for
compatibility at compile time.

These macros don't generate warnings on the compilers I've tried.

.. c:function:: COMPATLVALUE(lvalue1, lvalue2)

This macro checks the assignment compatibility of two lvalues. It uses
:c:func:`sizeof()` to ensure that the assignments have no effect. ::

    #define COMPATLVALUE(lv1, lv2) \
      ((void)sizeof((lv1) = (lv2)), (void)sizeof((lv2) = (lv1)), TRUE)

.. c:function:: COMPATTYPE(type1, type2)

This macro checks that two types are assignment-compatible and equal
in size. The hack here is that it generates an lvalue for each type by
casting zero to a pointer to the type. The use of :c:func:`sizeof()` avoids
the undefined behaviour that would otherwise result from dereferencing
a null pointer. ::

    #define COMPATTYPE(t1, t2) \
      (sizeof(t1) == sizeof(t2) && \
       COMPATLVALUE(*((t1 *)0), *((t2 *)0)))

.. c:function:: COMPATFIELDAPPROX(structure1, field1, structure2, field2)

This macro checks that the offset and size of two fields in two
structure types are the same. ::

    #define COMPATFIELDAPPROX(s1, f1, s2, f2) \
      (sizeof(((s1 *)0)->f1) == sizeof(((s2 *)0)->f2) && \
       offsetof(s1, f1) == offsetof(s2, f2))

.. c:function:: COMPATFIELD(structure1, field1, structure2, field2)

This macro checks the offset, size, and assignment-compatibility of
two fields in two structure types. ::

    #define COMPATFIELD(s1, f1, s2, f2) \
      (COMPATFIELDAPPROX(s1, f1, s2, f2) && \
       COMPATLVALUE(((s1 *)0)->f1, ((s2 *)0)->f2))


Binary compatibility issues
---------------------------

As in, "Enumeration types are not allowed" (see
mail.richard.1995-09-08.09-28).

There are two main aspects to run-time compatibility: binary interface
and protocol. The binary interface is all the information needed to
correctly use the library, and includes external symbol linkage,
calling conventions, type representation compatibility, structure
layouts, etc. The protocol is how the library is actually used by the
client code -- whether this is called before that -- and determines
the semantic correctness of the client with respect to the library.

The binary interface is determined completely by the header file and
the target. The header file specifies the external names and the
types, and the target platform specifies calling conventions and type
representation. There is therefore a many-to-one mapping between the
header file version and the binary interface.

The protocol is determined by the implementation of the library.

  
Constraints
-----------

:mps:tag:`cons` The MPS C Interface constrains the MPS in order to provide
useful memory management services to a C or C++ program.

:mps:tag:`cons.addr` The interface constrains the MPS address type, Addr
(design.mps.type.addr), to being the same as C's generic pointer type,
``void *``, so that the MPS can manage C objects in the natural way.

:mps:tag:`pun.addr` We pun the type of :c:type:`mps_addr_t` (which is ``void *``)
into :c:type:`Addr` (an incomplete type, see design.mps.type.addr). This
happens in the call to the scan state's fix function, for example.

:mps:tag:`cons.size` The interface constrains the MPS size type, :c:type:`Size`
(design.mps.type.size), to being the same as C's size type,
``size_t``, so that the MPS can manage C objects in the natural way.
 
:mps:tag:`pun.size` We pun the type of ``size_t`` in mps.h into :c:type:`Size` in
the MPM, as an argument to the format methods. We assume this works.

:mps:tag:`cons.word` The MPS assumes that :c:type:`Word` (design.mps.type.word)
and :c:type:`Addr` (design.mps.type.addr) are the same size, and the
interface constrains :c:type:`Word` to being the same size as C's generic
pointer type, ``void *``.


Notes
-----

The file ``mpstd.h`` is the MPS target detection header. It decodes
preprocessor symbols which are predefined by build environments in
order to determine the target platform, and then defines uniform
symbols, such as :c:macro:`MPS_ARCH_I3`, for use internally by the MPS.

There is a design document for the mps interface,
design.mps.interface, but it was written before we had the idea of
having a C interface layer. It is quite relevant, though, and could be
updated. We should use it during the review.

All exported identifiers and file names should begin with ``mps_`` or
:c:macro:`MPS_` so that they don't clash with other systems.

We should probably have a specialized set of rules and a special
checklist for this interface.

:mps:tag:`fmt.extend` This paragraph should be an explanation of why
``mps_fmt_A_t`` is so called. The underlying reason is future
extensibility.

:mps:tag:`thread-safety` Most calls through this interface lock the space
and therefore make the MPM single-threaded. In order to do this they
must recover the space from their parameters. Methods such as
:c:func:`ThreadSpace()` must therefore be callable when the space is *not*
locked. These methods are tagged with the tag of this note.

:mps:tag:`lock-free` Certain functions inside the MPM are thread-safe and do
not need to be serialized by using locks. They are marked with the tag
of this note.

:mps:tag:`form` Almost all functions in this implementation simply cast
their arguments to the equivalent internal types, and cast results
back to the external type, where necessary. Only exceptions are noted
in comments.


