.. _design-telemetry:


.. index::
   pair: telemetry; design


Telemetry
=========

.. mps:prefix:: design.mps.telemetry


Introduction
------------

:mps:tag:`intro` This documents the design of the telemetry mechanism within
the MPS.

:mps:tag:`readership` This document is intended for any MPS developer.

:mps:tag:`source` Various meetings and brainstorms, including
meeting.general.1997-03-04(0), mail.richard.1997-07-03.17-01(0),
mail.gavinm.1997-05-01.12-40(0).


Overview
--------

:mps:tag:`over` Telemetry permits the emission of events from the MPS. These
can be used to drive a graphical tool, or to debug, or whatever. The
system is flexible and robust, but doesn't require heavy support from
the client.


Requirements
------------

:mps:tag:`req.simple` It must be possible to generate code both for the MPS
and any tool without using complicated build tools.

:mps:tag:`req.open` We must not constrain the nature of events before we are
certain of what we want them to be.

:mps:tag:`req.multi` We must be able to send events to multiple streams.

:mps:tag:`req.share` It must be possible to share event descriptions between
the MPS and any tool.

:mps:tag:`req.version` It must be possible to version the set of events so
that any tool can detect whether it can understand the MPS.

:mps:tag:`req.back` Tools should be able to understand older and newer
version of the MPS, so far as is appropriate.

:mps:tag:`req.type` It must be possible to transmit a rich variety of types
to the tool, including doubles, and strings.

:mps:tag:`req.port` It must be possible to transmit and receive events
between different platforms.

:mps:tag:`req.control` It must be possible to control whether and what
events are transmitted at least at a coarse level.

:mps:tag:`req.examine` There should be a cheap means to examine the contents
of logs.

:mps:tag:`req.pm` The event mechanism should provide for post mortem to
detect what significant events led up to death.

:mps:tag:`req.perf` Events should not have a significant effect on
performance when unwanted.

:mps:tag:`req.small` Telemetry streams should be small.

:mps:tag:`req.avail` Events should be available in all varieties, subject to
performance requirements.

:mps:tag:`req.impl` The plinth support for telemetry should be easy to write
and flexible.

:mps:tag:`req.robust` The telemetry protocol should be robust against some
forms of corruption, e.g. packet loss.

:mps:tag:`req.intern` It should be possible to support string-interning.


Architecture
------------

:mps:tag:`arch` Event annotations are scattered throughout the code, but
there is a central registration of event types and properties. Events
are written to a buffer via a specialist structure, and are optionally
written to the plinth. Events can take any number of parameters of a
range of types, indicated as a format both in the annotation and the
the registry.


Analysis
--------

:mps:tag:`anal` The proposed order of development, with summary of
requirements impact is as follows (★ for positive impact, ⇓ for
negative impact):

========================= == == == == == == == == == == == == == == == == == =======
solution                  si op mu sh ve ty po co ex pm pe sm av im ro in ba status
========================= == == == == == == == == == == == == == == == == == =======
:mps:ref:`.sol.format`    ·  ·  ·  ·  ·  ★  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  merged
:mps:ref:`.sol.struct`    ·  ·  ·  ·  ·  ★  ·  ·  ·  ·  ★  ⇓  ·  ·  ·  ·  ·  merged
:mps:ref:`.sol.string`    ·  ·  ·  ·  ·  ★  ·  ·  ·  ·  ·  ·  ·  ·  ·  ★  ·  merged
:mps:ref:`.sol.relation`  ★  ·  ·  ★  ·  ·  ·  ·  ★  ·  ·  ★  ·  ·  ·  ·  ·  merged
:mps:ref:`.sol.dumper`    ·  ·  ·  ·  ·  ·  ·  ·  ★  ·  ·  ·  ·  ·  ·  ·  ·  merged
:mps:ref:`.sol.kind`      ·  ⇓  ·  ·  ·  ·  ·  ★  ·  ★  ·  ·  ·  ·  ·  ·  ·  merged
:mps:ref:`.sol.control`   ·  ·  ·  ·  ·  ·  ·  ★  ·  ·  ★  ·  ·  ·  ·  ·  ·  merged
:mps:ref:`.sol.variety`   ·  ·  ·  ·  ·  ·  ·  ·  ·  ★  ★  ·  ★  ·  ·  ·  · 
========================= == == == == == == == == == == == == == == == == == =======

The following are not yet ordered:

========================= == == == == == == == == == == == == == == == == == =======
solution                  si op mu sh ve ty po co ex pm pe sm av im ro in ba status 
========================= == == == == == == == == == == == == == == == == == =======
:mps:ref:`.sol.buffer`    ·  ·  ·  ·  ·  ·  ·  ★  ·  ★  ★  ·  ·  ·  ·  ·  .
:mps:ref:`.sol.traceback` ·  ·  ·  ·  ·  ·  ·  ·  ·  ★  ·  ·  ·  ·  ·  ·  .
:mps:ref:`.sol.client`    ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ★  .
:mps:ref:`.sol.head`      ·  ·  ·  ·  ·  ·  ★  ·  ·  ·  ·  ·  ·  ·  ·  ·  .
:mps:ref:`.sol.version`   ·  ·  ·  ·  ★  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ★
:mps:ref:`.sol.exit`      ·  ·  ·  ·  ·  ·  ·  ·  ·  ★  ·  ·  ·  ·  ·  ·  .
:mps:ref:`.sol.block`     ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ★  ⇓  ·  ·  ★  ·  ·  
:mps:ref:`.sol.code`      ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ★  ·  ·  ·  ·  ★
:mps:ref:`.sol.msg`       ·  ·  ★  ·  ·  ·  ★  ·  ·  ·  ·  ·  ·  ★  ★  ·  .
========================= == == == == == == == == == == == == == == == == == =======

:mps:tag:`file-format` One of the objectives of this plan is to minimise the
impact of the changes to the log file format. This is to be achieved
firstly by completing all necessary support before changes are
initiated, and secondly by performing all changes at the same time.


Ideas
-----

:mps:tag:`sol.format` Event annotations indicate the types of their
arguments, for example, :c:macro:`EVENT_WD` for a :c:type:`Word` and a ``double``.
(:mps:ref:`.req.type`)

:mps:tag:`sol.struct` Copy event data into a structure of the appropriate
type, for example, :c:type:`EventWDStruct`. (:mps:ref:`.req.type`, :mps:ref:`.req.perf`, but
not :mps:ref:`.req.small` because of padding)

:mps:tag:`sol.string` Permit at most one string per event, at the end, and
use the ``char[1]`` hack, and specialised code; deduce the string
length from the event length and also :c:macro:`NUL`-terminate (:mps:ref:`.req.type`,
:mps:ref:`.req.intern`)

:mps:tag:`sol.buffer` Enter all events initially into internal buffers, and
conditionally send them to the message stream. (:mps:ref:`.req.pm`,
:mps:ref:`.req.control`, :mps:ref:`.req.perf`)

:mps:tag:`sol.variety` In optimized varieties, have internal events (see
:mps:ref:`.sol.buffer`) for a subset of events and no external events; in
normal varieties have all internal events, and the potential for
external events. (:mps:ref:`.req.avail`, :mps:ref:`.req.pm`, :mps:ref:`.req.perf`)

:mps:tag:`sol.kind` Divide events by some coarse type into around 6 groups,
probably related to frequency. (:mps:ref:`.req.control`, :mps:ref:`.req.pm`, but not
:mps:ref:`.req.open`)

:mps:tag:`sol.control` Hold flags to determine which events are emitted
externally. (:mps:ref:`.req.control`, :mps:ref:`.req.perf`)

:mps:tag:`sol.dumper` Write a simple tool to dump event logs as text.
(:mps:ref:`.req.examine`)

:mps:tag:`sol.msg` Redesign the plinth interface to send and receive
messages, based on any underlying IPC mechanism, for example, append
to file, TCP/IP, messages, shared memory. (:mps:ref:`.req.robust`,
:mps:ref:`.req.impl`, :mps:ref:`.req.port`, :mps:ref:`.req.multi`)

:mps:tag:`sol.block` Buffer the events and send them as fixed size blocks,
commencing with a timestamp, and ending with padding. (:mps:ref:`.req.robust`,
:mps:ref:`.req.perf`, but not :mps:ref:`.req.small`)

:mps:tag:`sol.code` Commence each event with two bytes of event code, and
two bytes of length. (:mps:ref:`.req.small`, :mps:ref:`.req.back`)

:mps:tag:`sol.head` Commence each event stream with a platform-independent
header block giving information about the session, version (see
:mps:ref:`.sol.version`), and file format; file format will be sufficient to
decode the (platform-dependent) rest of the file. (:mps:ref:`.req.port`)

:mps:tag:`sol.exit` Provide a mechanism to flush events in the event of
graceful sudden death. (:mps:ref:`.req.pm`)

:mps:tag:`sol.version` Maintain a three part version number for the file
comprising major (incremented when the format of the entire file
changes (other than platform differences)), median (incremented when
an existing event changes its form or semantics), and minor
(incremented when a new event type is added); tools should normally
fail when the median or major is unsupported. (:mps:ref:`.req.version`,
:mps:ref:`.req.back`)

:mps:tag:`sol.relation` Event types will be defined in terms of a relation
specifying their name, code, optimised behaviour (see
:mps:ref:`.sol.variety`), kind (see :mps:ref:`.sol.kind`), and format (see
:mps:ref:`.sol.format`); both the MPS and tool can use this by suitable
``#define`` hacks. (:mps:ref:`.req.simple`, :mps:ref:`.req.share`, :mps:ref:`.req.examine`,
:mps:ref:`.req.small` (no format information in messages))

:mps:tag:`sol.traceback` Provide a mechanism to output recent events (see
:mps:ref:`.sol.buffer`) as a form of backtrace when :c:macro:`AVER` statements fire
or from a debugger, or whatever. (:mps:ref:`.req.pm`)

:mps:tag:`sol.client` Provide a mechanism for user events. (:mps:ref:`.req.intern`)



Implementation
--------------

Annotation
..........

:mps:tag:`annot` An event annotation is of the form::

    EVENT3(FooCreate, pointer, address, word)

:mps:tag:`annot.string` If there is a string in the format, it must be the
last parameter (and hence there can be only one). There is currrently
a maximum string length, defined by ``EventMaxStringLength`` in
impl.h.eventcom.

:mps:tag:`annot.type` The event type should be given as the first parameter
to the event macro, as registered in impl.h.eventdef.

:mps:tag:`annot.param` The parameters of the event should be given as the
remaining parameters of the event macro, in order as indicated in the
event parameters definition in impl.h.eventdef.


Registration
............

:mps:tag:`reg` All event types and parameters should be registered in
impl.h.eventdef, in the form of a higher-order list macros.

:mps:tag:`reg.just` This use of a higher-order macros enables great
flexibility in the use of this file.

:mps:tag:`reg.rel` The event type registration is of the form::

    EVENT(X, FooCreate, 0x1234, TRUE, Arena)

:mps:tag:`reg.type` The first parameter of the relation is the event type.
This needs no prefix, and should correspond to that used in the
annotation.

:mps:tag:`reg.code` The second parameter is the event code, a 16-bit value
used to represent this event type. Codes should not be re-used for new
event types, to allow interpretation of event log files of all ages.

:mps:tag:`reg.always` The third parameter is a boolean value indicating
whether this event type should be implemented in all varieties. See
:mps:ref:`.control.buffer`. Unless your event is on the critical path
(typically per reference or per object), you will want this to be
:c:macro:`TRUE`.

:mps:tag:`reg.kind` The fourth parameter is a kind keyword indicating what
category this event falls into. See :mps:ref:`.control`. The possible values
are:

- :c:type:`Arena` -- per space or arena or global
- :c:type:`Pool` -- pool-related
- :c:type:`Trace` -- per trace or scan
- :c:type:`Seg` -- per segment
- :c:type:`Ref` -- per reference or fix
- ``Object`` -- per object or allocation
- ``User`` -- invoked by the user through the MPS interface

This list can be seen in impl.h.eventcom.

:mps:tag:`reg.doc` Add a docstring column. [RB 2012-09-03]

:mps:tag:`reg.params` The event parameters registration is of the form::

    #define EVENT_FooCreate_PARAMS(PARAM, X) \
      PARAM(X,  0, P, firstParamPointer) \
      PARAM(X,  1, U, secondParamUnsigned)

:mps:tag:`reg.param.index` The first column is the index, and must start at
zero and increase by one for each row.

:mps:tag:`reg.param.sort` The second column is the parameter "sort", which,
when appended to ``EventF``, yields a type for the parameter. It is a
letter from the following list:

- ``P`` -- ``void *``
- ``A`` -- :c:type:`Addr`
- ``W`` -- :c:type:`Word`
- ``U`` -- ``unsigned int``
- ``S`` -- ``char *``
- ``D`` -- ``double``
- ``B`` -- :c:type:`Bool`

The corresponding event parameter must be assignment compatible with
the type.

:mps:tag:`param.types` When an event has parameters whose type is not in the
above list, use the following guidelines: All ``C`` pointer types not
representing strings use ``P``; :c:type:`Size`, :c:type:`Count`, :c:type:`Index` use
``W``; others should be obvious.

:mps:tag:`reg.param.name` The third column is the parameter name. It should
be a valid C identifier and is used for debugging display and human
readable output.

:mps:tag:`reg.param.doc` Add a docstring column. [RB 2012-09-03]

:mps:tag:`reg.dup` It is permissible for the one event type to be used for
more than one annotation. There are generally two reasons for this:

- Variable control flow for successful function completion;
- Platform/Otherwise-dependent implementations of a function.

Note that all annotations for one event type must have the same format
(as implied by :mps:ref:`.sol.format`).


Control
.......

:mps:tag:`control` There are two types of event control, buffer and output.

:mps:tag:`control.buffer` Buffer control affects whether particular events
implemented at all, and is controlled statically by variety using the
always value (see :mps:ref:`.reg.always`) for the event type. The hot variety
does compiles out annotations with ``always=FALSE``. The cool variety
does not, so always buffers a complete set of events.

:mps:tag:`control.output` Output control affects whether events written to
the internal buffer are output via the plinth. This is set on a
per-kind basis (see :mps:ref:`.reg.kind`), using a control bit table stored in
EventKindControl. By default, all event kinds are off. You may switch
some kinds on using a debugger.

For example, to enable :c:type:`Pool` events using gdb (see impl.h.eventcom for
numeric codes)::

    $ gdb ./xci3gc/cool/amcss
    (gdb) break GlobalsInit
    (gdb) run
    ...
    (gdb) print EventKindControl |= 2
    $2 = 2
    (gdb) continue
    ...
    (gdb) quit
    $ mpseventcnv -v | sort | head
    0000178EA03ACF6D PoolInit                9C1E0    9C000 0005E040
    0000178EA03C2825 PoolInitMFS             9C0D8    9C000     1000        C
    0000178EA03C2C27 PoolInitMFS             9C14C    9C000     1000       44
    0000178EA03C332C PoolInitMV              9C080    9C000     1000       20    10000
    0000178EA03F4DB4 BufferInit             2FE2C4   2FE1B0        0
    0000178EA03F4EC8 BufferInitSeg          2FE2C4   2FE1B0        0
    0000178EA03F57DA AMCGenCreate           2FE1B0   2FE288
    0000178EA03F67B5 BufferInit             2FE374   2FE1B0        0
    0000178EA03F6827 BufferInitSeg          2FE374   2FE1B0        0
    0000178EA03F6B72 AMCGenCreate           2FE1B0   2FE338

:mps:tag:`control.env` The initial value of ``EventKindControl`` is read
from the C environment when the ANSI Plinth is used, and so event
output can be controlled like this::

    MPS_TELEMETRY_CONTROL=127 amcss

or like this::

    MPS_TELEMETRY_CONTROL="Pool Arena" amcss

where the variable is set to a space-separated list of names defined by ``EventKindENUM``.

:mps:tag:`control.just` These controls are coarse, but very cheap.

:mps:tag:`control.external` The MPS interface function
``mps_telemetry_control`` can be used to change ``EventKindControl``.

:mps:tag:`control.tool` The tools will be able to control
``EventKindControl``.


Debugging
.........

:mps:tag:`debug.buffer` Each event kind is logged in a separate buffer,
``EventBuffer[kind]``.

:mps:tag:`debug.buffer.reverse` The events are logged in reverse order from
the top of the buffer, with the last logged event at
``EventLast[kind]``. This allows recovery of the list of recent events
using the ``event->any.size`` field.

:mps:tag:`debug.dump` The contents of all buffers can be dumped with the
``EventDump`` function from a debugger, for example::

    gdb> print EventDump(mps_lib_get_stdout())

:mps:tag:`debug.describe` Individual events can be described with the
EventDescribe function, for example::

    gdb> print EventDescribe(EventLast[3], mps_lib_get_stdout())

:mps:tag:`debug.core` The event buffers are preserved in core dumps and can
be used to work out what the MPS was doing before a crash. Since the
kinds correspond to frequencies, ancient events may still be available
in some buffers, even if they have been flushed to the output stream.
Some digging may be required.


Dumper tool
...........

:mps:tag:`dumper` A primitive dumper tool is available in impl.c.eventcnv.
For details, see guide.mps.telemetry.


Allocation replayer tool
........................

:mps:tag:`replayer` A tool for replaying an allocation sequence from a log
is available in impl.c.replay. For details, see
design.mps.telemetry.replayer.


