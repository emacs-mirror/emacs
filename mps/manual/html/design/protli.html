

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>31. Linux implementation of protection module &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Old design" href="old.html" />
    <link rel="next" title="32. SunOS 4 protection module" href="protsu.html" />
    <link rel="prev" title="30. ANSI implementation of protection module" href="protan.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="protsu.html" title="32. SunOS 4 protection module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="protan.html" title="30. ANSI implementation of protection module"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" accesskey="U">Old design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="linux-implementation-of-protection-module">
<span id="design-protli"></span><span id="index-0"></span><h1>31. Linux implementation of protection module<a class="headerlink" href="#linux-implementation-of-protection-module" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="design.mps.protli"></span><h2>31.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.protli.readership"></span><a class="mpstag reference internal" href="#design.mps.protli.readership">.readership:</a> Any MPS developer</p>
<p><span class="target" id="design.mps.protli.intro"></span><a class="mpstag reference internal" href="#design.mps.protli.intro">.intro:</a> This is the design of the Linux implementation of the
protection module. It makes use of various services provided by Linux.
It is intended to work with LinuxThreads.</p>
</div>
<div class="section" id="requirements">
<h2>31.2. Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.protli.req.general"></span><a class="mpstag reference internal" href="#design.mps.protli.req.general">.req.general:</a> Required to implement the general protection
interface defined in design.mps.prot.if.</p>
</div>
<div class="section" id="data-structures">
<h2>31.3. Data structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.protli.data.signext"></span><a class="mpstag reference internal" href="#design.mps.protli.data.signext">.data.signext:</a> This is static. Because that is the only
communications channel available to signal handlers.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">Write a little more here.</p>
</div>
</div>
<div class="section" id="functions">
<h2>31.4. Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.protli.fun.setup"></span><a class="mpstag reference internal" href="#design.mps.protli.fun.setup">.fun.setup:</a> <a class="reference internal" href="prot.html#ProtSetup" title="ProtSetup"><tt class="xref c c-func docutils literal"><span class="pre">ProtSetup()</span></tt></a> installs a signal handler for the signal
<tt class="xref c c-macro docutils literal"><span class="pre">SIGSEGV</span></tt> to catch and handle protection faults (this handler is the
function <tt class="xref c c-func docutils literal"><span class="pre">sigHandle()</span></tt>, see <a class="reference internal" href="#design.mps.protli.fun.sighandle">.fun.sighandle</a>). The previous handler
is recorded (in the variable <tt class="docutils literal"><span class="pre">sigNext</span></tt>, see <a class="reference internal" href="#design.mps.protli.data.signext">.data.signext</a>) so
that it can be reached from <tt class="xref c c-func docutils literal"><span class="pre">sigHandle()</span></tt> if it fails to handle the
fault.</p>
<p><span class="target" id="design.mps.protli.fun.setup.problem"></span><a class="mpstag reference internal" href="#design.mps.protli.fun.setup.problem">.fun.setup.problem:</a> The problem with this approach is that we can&#8217;t
honour the wishes of the <tt class="docutils literal"><span class="pre">sigvec(2)</span></tt> entry for the previous handler
(in terms of masks in particular).</p>
<p><span class="target" id="design.mps.protli.improve.sigvec"></span><a class="mpstag reference internal" href="#design.mps.protli.improve.sigvec">.improve.sigvec:</a> What if when we want to pass on the signal instead
of calling the handler we call <tt class="xref c c-func docutils literal"><span class="pre">sigvec()</span></tt> with the old entry and use
<tt class="xref c c-func docutils literal"><span class="pre">kill()</span></tt> to send the signal to ourselves and then restore our
handler using <tt class="xref c c-func docutils literal"><span class="pre">sigvec()</span></tt> again?</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">Need more detail and analysis here.</p>
</div>
<p><span class="target" id="design.mps.protli.fun.set"></span><a class="mpstag reference internal" href="#design.mps.protli.fun.set">.fun.set:</a> <a class="reference internal" href="prot.html#ProtSet" title="ProtSet"><tt class="xref c c-func docutils literal"><span class="pre">ProtSet()</span></tt></a> uses <tt class="xref c c-func docutils literal"><span class="pre">mprotect()</span></tt> to adjust the
protection for pages.</p>
<p><span class="target" id="design.mps.protli.fun.set.convert"></span><a class="mpstag reference internal" href="#design.mps.protli.fun.set.convert">.fun.set.convert:</a> The requested protection (which is expressed in
the <tt class="docutils literal"><span class="pre">mode</span></tt> parameter, see design.mps.prot.if.set) is translated into
an operating system protection. If read accesses are to be forbidden
then all accesses are forbidden, this is done by setting the
protection of the page to <tt class="xref c c-macro docutils literal"><span class="pre">PROT_NONE</span></tt>. If write accesses are to be
forbidden (and not read accesses) then write accesses are forbidden
and read accesses are allowed, this is done by setting the protection
of the page to <tt class="docutils literal"><span class="pre">PROT_READ|PROT_EXEC</span></tt>. Otherwise (all access are
okay), the protection is set to <tt class="docutils literal"><span class="pre">PROT_READ|PROT_WRITE|PROT_EXEC</span></tt>.</p>
<p><span class="target" id="design.mps.protli.fun.set.assume.mprotect"></span><a class="mpstag reference internal" href="#design.mps.protli.fun.set.assume.mprotect">.fun.set.assume.mprotect:</a> We assume that the call to <tt class="xref c c-func docutils literal"><span class="pre">mprotect()</span></tt>
always succeeds.</p>
<p><span class="target" id="design.mps.protli.fun.set.assume.mprotect"></span><a class="mpstag reference internal" href="#design.mps.protli.fun.set.assume.mprotect">.fun.set.assume.mprotect:</a> This is because we should always call the
function with valid arguments (aligned, references to mapped pages,
and with an access that is compatible with the access of the
underlying object).</p>
<p><span class="target" id="design.mps.protli.fun.sync"></span><a class="mpstag reference internal" href="#design.mps.protli.fun.sync">.fun.sync:</a> <a class="reference internal" href="prot.html#ProtSync" title="ProtSync"><tt class="xref c c-func docutils literal"><span class="pre">ProtSync()</span></tt></a> does nothing in this implementation as
<a class="reference internal" href="prot.html#ProtSet" title="ProtSet"><tt class="xref c c-func docutils literal"><span class="pre">ProtSet()</span></tt></a> sets the protection without any delay.</p>
<p><span class="target" id="design.mps.protli.fun.tramp"></span><a class="mpstag reference internal" href="#design.mps.protli.fun.tramp">.fun.tramp:</a> The protection trampoline, <a class="reference internal" href="prot.html#ProtTramp" title="ProtTramp"><tt class="xref c c-func docutils literal"><span class="pre">ProtTramp()</span></tt></a>, is trivial
under Linux, as there is nothing that needs to be done in the dynamic
context of the mutator in order to catch faults. (Contrast this with
Win32 Structured Exception Handling.)</p>
</div>
<div class="section" id="threads">
<h2>31.5. Threads<a class="headerlink" href="#threads" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.protli.threads"></span><a class="mpstag reference internal" href="#design.mps.protli.threads">.threads:</a> The design must operate in a multi-threaded environment
(with LinuxThreads) and cooperate with the Linux support for locks
(see design.mps.lock) and the thread suspension mechanism (see
design.mps.pthreadext ).</p>
<p><span class="target" id="design.mps.protli.threads.suspend"></span><a class="mpstag reference internal" href="#design.mps.protli.threads.suspend">.threads.suspend:</a> The <tt class="xref c c-macro docutils literal"><span class="pre">SIGSEGV</span></tt> signal handler does not mask out
any signals, so a thread may be suspended while the handler is active,
as required by the design (see
design.mps.pthreadext.req.suspend.protection). The signal handlers
simply nest at top of stack.</p>
<p><span class="target" id="design.mps.protli.threads.async"></span><a class="mpstag reference internal" href="#design.mps.protli.threads.async">.threads.async:</a> POSIX (and hence Linux) imposes some restrictions
on signal handler functions (see
design.mps.pthreadext.anal.signal.safety). Basically the rules say the
behaviour of almost all POSIX functions inside a signal handler is
undefined, except for a handful of functions which are known to be
&#8220;async-signal safe&#8221;. However, if it&#8217;s known that the signal didn&#8217;t
happen inside a POSIX function, then it is safe to call arbitrary
POSIX functions inside a handler.</p>
<p><span class="target" id="design.mps.protli.threads.async.protection"></span><a class="mpstag reference internal" href="#design.mps.protli.threads.async.protection">.threads.async.protection:</a> If the signal handler is invoked because
of an MPS access, then we know the access must have been caused by
client code, because the client is not allowed to permit access to
protectable memory to arbitrary foreign code. In these circumstances,
it&#8217;s OK to call arbitrary POSIX functions inside the handler.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">Need a reference for &#8220;the client is not allowed to permit access
to protectable memory to arbitrary foreign code&#8221;.</p>
</div>
<p><span class="target" id="design.mps.protli.threads.async.other"></span><a class="mpstag reference internal" href="#design.mps.protli.threads.async.other">.threads.async.other:</a> If the signal handler is invoked for some
other reason (that is, one we are not prepared to handle) then there
is less we can say about what might have caused the SEGV. In general
it is not safe to call arbitrary POSIX functions inside the handler in
this case.</p>
<p><span class="target" id="design.mps.protli.threads.async.choice"></span><a class="mpstag reference internal" href="#design.mps.protli.threads.async.choice">.threads.async.choice:</a> The signal handler calls <tt class="xref c c-func docutils literal"><span class="pre">ArenaAccess()</span></tt>
to determine whether the segmentation fault was the result of an MPS
access. ArenaAccess will claim various MPS locks (that is, the arena
ring lock and some arena locks). The code calls no other POSIX
functions in the case where the segmentation fault is not an MPS
access. The locks are implemented as mutexes and are claimed by
calling <tt class="xref c c-func docutils literal"><span class="pre">pthread_mutex_lock()</span></tt>, which is not defined to be
async-signal safe.</p>
<p><span class="target" id="design.mps.protli.threads.async.choice.ok"></span><a class="mpstag reference internal" href="#design.mps.protli.threads.async.choice.ok">.threads.async.choice.ok:</a> However, despite the fact that PThreads
documentation doesn&#8217;t define the behaviour of <tt class="xref c c-func docutils literal"><span class="pre">pthread_mutex_lock()</span></tt>
in these circumstances, we expect the LinuxThreads implementation will
be well-behaved unless the segmentation fault occurs while while in
the process of locking or unlocking one of the MPS locks (see
<a class="reference internal" href="#design.mps.protli.threads.async.linux-mutex">.threads.async.linux-mutex</a>). But we can assume that a segmentation
fault will not happen then (because we use the locks correctly, and
generally must assume that they work). Hence we conclude that it is OK
to call <tt class="xref c c-func docutils literal"><span class="pre">ArenaAccess()</span></tt> directly from the signal handler.</p>
<p><span class="target" id="design.mps.protli.threads.async.linux-mutex"></span><a class="mpstag reference internal" href="#design.mps.protli.threads.async.linux-mutex">.threads.async.linux-mutex:</a> A study of the LinuxThreads source code
reveals that mutex lock and unlock functions are implemented as a
spinlock (using a locked compare-and-exchange instruction) with a
backup suspension mechanism using <tt class="xref c c-func docutils literal"><span class="pre">sigsuspend()</span></tt>. On locking, the
spinlock code performs a loop which examines the state of the lock,
and then atomically tests that the state is unchanged while attempting
to modify it. This part of the code is reentrant (and hence
async-signal safe). Eventually, when locking, the spinlock code may
need to block, in which case it calls <tt class="xref c c-func docutils literal"><span class="pre">sigsuspend()</span></tt>, waiting for
the manager thread to unblock it. The unlocking code is similar,
except that this code may need to release another thread, in which
case it calls <tt class="xref c c-func docutils literal"><span class="pre">kill()</span></tt>. The functions <tt class="xref c c-func docutils literal"><span class="pre">sigsuspend()</span></tt> and
<tt class="xref c c-func docutils literal"><span class="pre">kill()</span></tt> are both defined to be async-signal safe by POSIX. In
summary, the mutex locking functions use primitives which are entirely
async-signal safe. They perform side-effects which modify the fields
of the lock structure only. This code may be safely invoked inside a
signal handler unless the interrupted function is in the process of
manipulating the fields of that lock structure.</p>
<p><span class="target" id="design.mps.protli.threads.async.improve"></span><a class="mpstag reference internal" href="#design.mps.protli.threads.async.improve">.threads.async.improve:</a> In future it would be preferable to not
have to assume reentrant mutex locking and unlocking functions. By
making the assumption we also assume that the implementation of
mutexes in LinuxThreads will not be completely re-designed in future
(which is not wise for the long term). An alternative approach would
be necessary anyway when supporting another platform which doesn&#8217;t
offer reentrant locks (if such a platform does exist).</p>
<p><span class="target" id="design.mps.protli.threads.async.improve.how"></span><a class="mpstag reference internal" href="#design.mps.protli.threads.async.improve.how">.threads.async.improve.how:</a> We could avoid the assumption if we had
a means of testing whether an address lies within an arena chunk
without the need to claim any locks. Such a test might actually be
possible. For example, arenas could update a global datastructure
describing the ranges of all chunks, using atomic updates rather than
locks; the handler code would be allowed to read this without locking.
However, this is somewhat tricky; a particular consideration is that
it&#8217;s not clear when it&#8217;s safe to deallocate stale portions of the
datastructure.</p>
<p><span class="target" id="design.mps.protli.threads.sig-stack"></span><a class="mpstag reference internal" href="#design.mps.protli.threads.sig-stack">.threads.sig-stack:</a> We do not handle signals on a separate signal
stack. Separate signal stacks apparently don&#8217;t work properly with
Pthreads.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">31. Linux implementation of protection module</a><ul>
<li><a class="reference internal" href="#introduction">31.1. Introduction</a></li>
<li><a class="reference internal" href="#requirements">31.2. Requirements</a></li>
<li><a class="reference internal" href="#data-structures">31.3. Data structures</a></li>
<li><a class="reference internal" href="#functions">31.4. Functions</a></li>
<li><a class="reference internal" href="#threads">31.5. Threads</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="protan.html"
                        title="previous chapter">30. ANSI implementation of protection module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="protsu.html"
                        title="next chapter">32. SunOS 4 protection module</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="protsu.html" title="32. SunOS 4 protection module"
             >next</a> |</li>
        <li class="right" >
          <a href="protan.html" title="30. ANSI implementation of protection module"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" >Old design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>