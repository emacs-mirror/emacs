

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>38. Shield &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Old design" href="old.html" />
    <link rel="next" title="39. Splay trees" href="splay.html" />
    <link rel="prev" title="37. Segment data structure" href="seg.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="splay.html" title="39. Splay trees"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="seg.html" title="37. Segment data structure"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" accesskey="U">Old design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="design-shield"></span><div class="section" id="shield">
<span id="index-0"></span><h1>38. Shield<a class="headerlink" href="#shield" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="design.mps.shield"></span><h2>38.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.shield.intro"></span><a class="mpstag reference internal" href="#design.mps.shield.intro">.intro:</a> This document contains a guide to the MPS Shield. There is
no historical initial design, but in its place there are some early
ideas and discussions: see <a class="reference internal" href="#design.mps.shield.ideas">.ideas</a>.</p>
<p><span class="target" id="design.mps.shield.readership"></span><a class="mpstag reference internal" href="#design.mps.shield.readership">.readership:</a> Any MPS developer. Not confidential.</p>
</div>
<div class="section" id="overview">
<h2>38.2. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.shield.over"></span><a class="mpstag reference internal" href="#design.mps.shield.over">.over:</a> For incremental collection, we need <em>separate control</em> of
collector access and mutator (client) access to memory. The collector
must be able to incrementally scan objects, without the mutator being
able to see them yet.</p>
<p>Unfortunately common OSs do not support different access levels
(protection maps) for different parts of the same process.</p>
<p>The MPS Shield is an abstraction that does extra work to overcome this
limitation, and give the rest of the MPS the illusion that we can
control collector and mutator access separately.</p>
</div>
<div class="section" id="control-of-mutator-access">
<h2>38.3. Control of mutator access<a class="headerlink" href="#control-of-mutator-access" title="Permalink to this headline">¶</a></h2>
<p>The MPS uses <a class="reference internal" href="#ShieldRaise" title="ShieldRaise"><tt class="xref c c-func docutils literal"><span class="pre">ShieldRaise()</span></tt></a> and <a class="reference internal" href="#ShieldLower" title="ShieldLower"><tt class="xref c c-func docutils literal"><span class="pre">ShieldLower()</span></tt></a> to forbid or
permit the mutator access to object memory (that is, memory allocated
by MPS).</p>
<dl class="function">
<dt id="ShieldRaise">
void <tt class="descname">ShieldRaise</tt><big>(</big><a class="reference internal" href="arena.html#Arena" title="Arena">Arena</a><em>&nbsp;arena</em>, <a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;seg</em>, <a class="reference internal" href="type.html#AccessSet" title="AccessSet">AccessSet</a><em>&nbsp;mode</em><big>)</big><a class="headerlink" href="#ShieldRaise" title="Permalink to this definition">¶</a></dt>
<dd><p>Prevent the mutator accessing the memory in the specified mode
(<tt class="docutils literal"><span class="pre">AccessREAD</span></tt>, <tt class="docutils literal"><span class="pre">AccessWRITE</span></tt>, or both).</p>
</dd></dl>

<dl class="function">
<dt id="ShieldLower">
void <tt class="descname">ShieldLower</tt><big>(</big><a class="reference internal" href="arena.html#Arena" title="Arena">Arena</a><em>&nbsp;arena</em>, <a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;seg</em>, <a class="reference internal" href="type.html#AccessSet" title="AccessSet">AccessSet</a><em>&nbsp;mode</em><big>)</big><a class="headerlink" href="#ShieldLower" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the mutator to access the memory in the specified mode
(<tt class="docutils literal"><span class="pre">AccessREAD</span></tt>, <tt class="docutils literal"><span class="pre">AccessWRITE</span></tt>, or both).</p>
</dd></dl>

<p>If the mutator attempts an access that hits a shield, the MPS gets a
barrier hit (in the form of a fault, interrupt, exception), quickly
does some necessary work, and then makes the access succeed.</p>
<p>Some objects (for example registers) cannot be hardware protected: the
only way to prevent mutator access to them is to halt all mutator
threads. The MPS uses <a class="reference internal" href="#ShieldSuspend" title="ShieldSuspend"><tt class="xref c c-func docutils literal"><span class="pre">ShieldSuspend()</span></tt></a> and <a class="reference internal" href="#ShieldResume" title="ShieldResume"><tt class="xref c c-func docutils literal"><span class="pre">ShieldResume()</span></tt></a> to do
this.</p>
<dl class="function">
<dt id="ShieldSuspend">
void <tt class="descname">ShieldSuspend</tt><big>(</big><a class="reference internal" href="arena.html#Arena" title="Arena">Arena</a><em>&nbsp;arena</em><big>)</big><a class="headerlink" href="#ShieldSuspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop all registered mutator threads.</p>
</dd></dl>

<dl class="function">
<dt id="ShieldResume">
void <tt class="descname">ShieldResume</tt><big>(</big><a class="reference internal" href="arena.html#Arena" title="Arena">Arena</a><em>&nbsp;arena</em><big>)</big><a class="headerlink" href="#ShieldResume" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume all registered mutator threads.</p>
</dd></dl>

</div>
<div class="section" id="control-of-collector-access">
<h2>38.4. Control of collector access<a class="headerlink" href="#control-of-collector-access" title="Permalink to this headline">¶</a></h2>
<p>When the collector wants to access object memory (that is, memory
allocated by MPS), it must first call <tt class="xref c c-func docutils literal"><span class="pre">ShieldEnter()</span></tt>, then wrap any
accesses with a <tt class="xref c c-func docutils literal"><span class="pre">ShieldExpose()</span></tt> and <tt class="xref c c-func docutils literal"><span class="pre">ShieldCover()</span></tt> pair, and
finally call <tt class="xref c c-func docutils literal"><span class="pre">ShieldLeave()</span></tt>.</p>
<p><tt class="xref c c-func docutils literal"><span class="pre">ShieldEnter()</span></tt> and <tt class="xref c c-func docutils literal"><span class="pre">ShieldLeave()</span></tt> are called by <tt class="xref c c-func docutils literal"><span class="pre">ArenaEnter()</span></tt>
and <tt class="xref c c-func docutils literal"><span class="pre">ArenaLeave()</span></tt> (approximately) &#8211; so the shield is always
entered when we are within MPS code (approximately).</p>
<p><tt class="xref c c-func docutils literal"><span class="pre">ShieldExpose()</span></tt> might for example be called around:</p>
<ul class="simple">
<li>format-scan (when scanning);</li>
<li>format-skip (when marking grains in a non-moving fix);</li>
<li>format-isMoved and <tt class="xref c c-func docutils literal"><span class="pre">AddrCopy()</span></tt> (during a copying fix);</li>
<li>format-pad (during reclaim).</li>
</ul>
<p>Note that there is no need to call <tt class="xref c c-func docutils literal"><span class="pre">ShieldExpose()</span></tt> when accessing
pool management memory such as bit tables. This is not object
memory, is never (legally) accessed by the mutator, and so is never
shielded.</p>
<p>On common operating systems, the only way to allow collector access is
to allow access from the whole process, including the mutator. So if
the Shield is asked to allow collector access but deny mutator access,
it will halt all mutator threads to prevent any mutator access. The
Shield performs suspension and restart; normal collector code does not
need to worry about it.</p>
<p>Collector code can make multiple sequential, overlapping, or nested
calls to <tt class="xref c c-func docutils literal"><span class="pre">ShieldExpose()</span></tt> on the same segment, as long as each is
balanced by a corresponding <tt class="xref c c-func docutils literal"><span class="pre">ShieldCover()</span></tt> before <tt class="xref c c-func docutils literal"><span class="pre">ShieldLeave()</span></tt>
is called). A usage count is maintained on each segment in
<tt class="docutils literal"><span class="pre">seg-&gt;depth</span></tt>: a positive &#8220;depth&#8221; means a positive number of
outstanding <em>reasons</em> why the segment must be exposed to the collector.
When the usage count reaches zero, there is no longer any reason the
segment should be unprotected, and the Shield could re-instate
hardware protection.</p>
<p>However, as a performance-improving hysteresis, the Shield defers
re-protection, maintaining a cache of the last <tt class="docutils literal"><span class="pre">ShieldCacheSIZE</span></tt>
times a segment no longer had a reason to be collector-accessible.
Presence in the cache counts as a reason: segments in the cache have
<tt class="docutils literal"><span class="pre">seg-&gt;depth</span></tt> increased by one. As segments get pushed out of the
cache, or at <tt class="xref c c-func docutils literal"><span class="pre">ShieldLeave()</span></tt>, this artificial reason is
decremented from <tt class="docutils literal"><span class="pre">seg-&gt;depth</span></tt>, and (if <tt class="docutils literal"><span class="pre">seg-&gt;depth</span></tt> is now zero)
the deferred reinstatement of hardware protection happens.</p>
<p>So whenever hardware protection is temporarily removed to allow
collector access, there is a <em>nurse</em> that will ensure this protection
is re-established: the nurse is either the balancing <tt class="xref c c-func docutils literal"><span class="pre">ShieldCover()</span></tt>
call in collector code, or an entry in the shield cache.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Notes</p>
<ol class="arabic simple">
<li>Why is there a fixed-size cache? This is not the simple
approach! All we need is a chain of segs that might need their
hardware protection to be sync&#8217;d with their shield mode. Head
in the shield, and one pointer in each seg struct. I guess we
try hard to avoid bloating <tt class="xref c c-type docutils literal"><span class="pre">SegStruct</span></tt> (to maintain residency
in the processor cache). But is 16 the right size? A cache-miss
wastes two kernel calls.</li>
<li>I don&#8217;t like the cache code. For example, why does
<tt class="xref c c-func docutils literal"><span class="pre">ShieldFlush()</span></tt> break out early if <tt class="docutils literal"><span class="pre">arena-&gt;shDepth</span></tt> is 0?
This should never happen until the cache is completely flushed,
that is, we have reached <tt class="docutils literal"><span class="pre">shCacheLimit</span></tt>. Why does
<tt class="xref c c-func docutils literal"><span class="pre">ShieldFlush()</span></tt> not reset <tt class="docutils literal"><span class="pre">shCacheLimit</span></tt>? Why does
<tt class="xref c c-func docutils literal"><span class="pre">flush()</span></tt> silently accept <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt> cache entries?</li>
<li>Why is <tt class="docutils literal"><span class="pre">seg-&gt;depth</span></tt> never checked for overflow? It is only a
4-bit-wide bit field, currently.</li>
</ol>
<p class="last">Richard Kistruck, 2006-12-19.</p>
</div>
</div>
<div class="section" id="initial-ideas">
<h2>38.5. Initial ideas<a class="headerlink" href="#initial-ideas" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.shield.ideas"></span><a class="mpstag reference internal" href="#design.mps.shield.ideas">.ideas:</a> There never was an initial design document, but
<a class="reference internal" href="#rb-1995-11-29">[RB_1995-11-29]</a> and <a class="reference internal" href="#rb-1995-11-30">[RB_1995-11-30]</a> contain some initial ideas.</p>
</div>
<div class="section" id="references">
<h2>38.6. References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="rb-1995-11-29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[RB_1995-11-29]</a></td><td>Richard Brooksby. Harlequin. 1995-11-29. &#8220;<a class="reference external" href="https://info.ravenbrook.com/project/mps/doc/2002-06-18/obsolete-mminfo/mminfo/idea/shield/index.txt">Shield protocol for barriers</a>&#8221;.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rb-1995-11-30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[RB_1995-11-30]</a></td><td>Richard Brooksby. Harlequin. 1995-11-30. &#8220;<a class="reference external" href="https://info.ravenbrook.com/project/mps/mail/1995/11/30/15-07/0.txt">Exegesis of Incremental Tracing</a>&#8221;.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">38. Shield</a><ul>
<li><a class="reference internal" href="#introduction">38.1. Introduction</a></li>
<li><a class="reference internal" href="#overview">38.2. Overview</a></li>
<li><a class="reference internal" href="#control-of-mutator-access">38.3. Control of mutator access</a></li>
<li><a class="reference internal" href="#control-of-collector-access">38.4. Control of collector access</a></li>
<li><a class="reference internal" href="#initial-ideas">38.5. Initial ideas</a></li>
<li><a class="reference internal" href="#references">38.6. References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="seg.html"
                        title="previous chapter">37. Segment data structure</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="splay.html"
                        title="next chapter">39. Splay trees</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="splay.html" title="39. Splay trees"
             >next</a> |</li>
        <li class="right" >
          <a href="seg.html" title="37. Segment data structure"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" >Old design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>