

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>39. Segment data structure &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Old design" href="old.html" />
    <link rel="next" title="40. Shield" href="shield.html" />
    <link rel="prev" title="38. The generic scanner" href="scan.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="shield.html" title="40. Shield"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="scan.html" title="38. The generic scanner"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" accesskey="U">Old design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="segment-data-structure">
<span id="design-seg"></span><span id="index-0"></span><h1>39. Segment data structure<a class="headerlink" href="#segment-data-structure" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="design.mps.seg"></span><h2>39.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.seg.intro"></span><a class="mpstag reference internal" href="#design.mps.seg.intro">.intro:</a> This document describes the MPS Segment data structure.</p>
</div>
<div class="section" id="overview">
<h2>39.2. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.seg.over.segments"></span><a class="mpstag reference internal" href="#design.mps.seg.over.segments">.over.segments:</a> Segments are the basic units of tracing and
shielding. The MPM also uses them as units of scanning and colour,
although pool classes may subdivide segments and be able to maintain
colour on a finer grain (down to the object level, for example).</p>
<p><span class="target" id="design.mps.seg.over.objects"></span><a class="mpstag reference internal" href="#design.mps.seg.over.objects">.over.objects:</a> The mutator&#8217;s objects are stored in segments.
Segments are contiguous blocks of memory managed by some pool.</p>
<p><span class="target" id="design.mps.seg.segments.pool"></span><a class="mpstag reference internal" href="#design.mps.seg.segments.pool">.segments.pool:</a> The arrangement of objects within a segment is
determined by the class of the pool which owns the segment. The pool
is associated with the segment indirectly via the first tract of the
segment.</p>
<p><span class="target" id="design.mps.seg.over.memory"></span><a class="mpstag reference internal" href="#design.mps.seg.over.memory">.over.memory:</a> The relationship between segments and areas of memory
is maintained by the segment module. Pools acquire tracts from the
arena, and release them back to the arena when they don&#8217;t need them
any longer. The segment module can associate contiguous tracts owned
by the same pool with a segment. The segment module provides the
methods SegBase, SegLimit, and SegSize which map a segment onto the
addresses of the memory block it represents.</p>
<p><span class="target" id="design.mps.seg.over.hierarchy"></span><a class="mpstag reference internal" href="#design.mps.seg.over.hierarchy">.over.hierarchy:</a> The Segment datastructure is designed to be
subclassable (see design.mps.protocol). The basic segment class
(<a class="reference internal" href="#Seg" title="Seg"><tt class="xref c c-type docutils literal"><span class="pre">Seg</span></tt></a>) supports colour and protection for use by the tracer, as
well as support for a pool ring, and all generic segment functions.
Clients may use <a class="reference internal" href="#Seg" title="Seg"><tt class="xref c c-type docutils literal"><span class="pre">Seg</span></tt></a> directly, but will most probably want to use a
subclass with additional properties.</p>
<p><span class="target" id="design.mps.seg.over.hierarchy.gcseg"></span><a class="mpstag reference internal" href="#design.mps.seg.over.hierarchy.gcseg">.over.hierarchy.gcseg:</a> The segment module provides <tt class="docutils literal"><span class="pre">GCSeg</span></tt> - a
subclass of <a class="reference internal" href="#Seg" title="Seg"><tt class="xref c c-type docutils literal"><span class="pre">Seg</span></tt></a> which has full support for GC including buffering
and the ability to be linked onto the grey ring.</p>
</div>
<div class="section" id="data-structure">
<h2>39.3. Data Structure<a class="headerlink" href="#data-structure" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="Seg">
struct SegStruct *<tt class="descname">Seg</tt><a class="headerlink" href="#Seg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="GCSeg">
struct GCSegStruct *<tt class="descname">GCSeg</tt><a class="headerlink" href="#GCSeg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The implementations are as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">SegStruct</span> <span class="p">{</span>      <span class="cm">/* segment structure */</span>
  <span class="n">Sig</span> <span class="n">sig</span><span class="p">;</span>                      <span class="cm">/* impl.h.misc.sig */</span>
  <span class="n">SegClass</span> <span class="n">class</span><span class="p">;</span>               <span class="cm">/* segment class structure */</span>
  <span class="n">Tract</span> <span class="n">firstTract</span><span class="p">;</span>             <span class="cm">/* first tract of segment */</span>
  <span class="n">RingStruct</span> <span class="n">poolRing</span><span class="p">;</span>          <span class="cm">/* link in list of segs in pool */</span>
  <span class="n">Addr</span> <span class="n">limit</span><span class="p">;</span>                   <span class="cm">/* limit of segment */</span>
  <span class="kt">unsigned</span> <span class="n">depth</span> <span class="o">:</span> <span class="n">SHIELD_DEPTH_WIDTH</span><span class="p">;</span> <span class="cm">/* see impl.c.shield.def.depth */</span>
  <span class="n">AccessSet</span> <span class="n">pm</span> <span class="o">:</span> <span class="n">AccessMAX</span><span class="p">;</span>     <span class="cm">/* protection mode, impl.c.shield */</span>
  <span class="n">AccessSet</span> <span class="n">sm</span> <span class="o">:</span> <span class="n">AccessMAX</span><span class="p">;</span>     <span class="cm">/* shield mode, impl.c.shield */</span>
  <span class="n">TraceSet</span> <span class="n">grey</span> <span class="o">:</span> <span class="n">TRACE_MAX</span><span class="p">;</span>    <span class="cm">/* traces for which seg is grey */</span>
  <span class="n">TraceSet</span> <span class="n">white</span> <span class="o">:</span> <span class="n">TRACE_MAX</span><span class="p">;</span>   <span class="cm">/* traces for which seg is white */</span>
  <span class="n">TraceSet</span> <span class="n">nailed</span> <span class="o">:</span> <span class="n">TRACE_MAX</span><span class="p">;</span>  <span class="cm">/* traces for which seg has nailed objects */</span>
  <span class="n">RankSet</span> <span class="n">rankSet</span> <span class="o">:</span> <span class="n">RankMAX</span><span class="p">;</span>    <span class="cm">/* ranks of references in this seg */</span>
<span class="p">}</span> <span class="n">SegStruct</span><span class="p">;</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="n">GCSegStruct</span> <span class="p">{</span>    <span class="cm">/* GC segment structure */</span>
  <span class="n">SegStruct</span> <span class="n">segStruct</span><span class="p">;</span>          <span class="cm">/* superclass fields must come first */</span>
  <span class="n">RingStruct</span> <span class="n">greyRing</span><span class="p">;</span>          <span class="cm">/* link in list of grey segs */</span>
  <span class="n">RefSet</span> <span class="n">summary</span><span class="p">;</span>               <span class="cm">/* summary of references out of seg */</span>
  <span class="n">Buffer</span> <span class="n">buffer</span><span class="p">;</span>                <span class="cm">/* non-NULL if seg is buffered */</span>
  <span class="n">Sig</span> <span class="n">sig</span><span class="p">;</span>                      <span class="cm">/* design.mps.sig */</span>
<span class="p">}</span> <span class="n">GCSegStruct</span><span class="p">;</span>
</pre></div>
</div>
<p><span class="target" id="design.mps.seg.field.rankSet"></span><a class="mpstag reference internal" href="#design.mps.seg.field.rankSet">.field.rankSet:</a> The <tt class="docutils literal"><span class="pre">rankSet</span></tt> field represents the set of ranks
of the references in the segment. It is initialized to empty by
<tt class="xref c c-func docutils literal"><span class="pre">SegInit()</span></tt>.</p>
<p><span class="target" id="design.mps.seg.field.rankSet.single"></span><a class="mpstag reference internal" href="#design.mps.seg.field.rankSet.single">.field.rankSet.single:</a> The Tracer only permits one rank per segment
[ref?] so this field is either empty or a singleton.</p>
<p><span class="target" id="design.mps.seg.field.rankSet.empty"></span><a class="mpstag reference internal" href="#design.mps.seg.field.rankSet.empty">.field.rankSet.empty:</a> An empty <tt class="docutils literal"><span class="pre">rankSet</span></tt> indicates that there are
no references. If there are no references in the segment then it
cannot contain black or grey references.</p>
<p><span class="target" id="design.mps.seg.field.rankSet.start"></span><a class="mpstag reference internal" href="#design.mps.seg.field.rankSet.start">.field.rankSet.start:</a> If references are stored in the segment then
it must be updated, along with the summary (<a class="reference internal" href="#design.mps.seg.field.summary.start">.field.summary.start</a>).</p>
<p><span class="target" id="design.mps.seg.field.depth"></span><a class="mpstag reference internal" href="#design.mps.seg.field.depth">.field.depth:</a> The <tt class="docutils literal"><span class="pre">depth</span></tt> field is used by the Shield
(impl.c.shield) to manage protection of the segment. It is initialized
to zero by <tt class="xref c c-func docutils literal"><span class="pre">SegInit()</span></tt>.</p>
<p><span class="target" id="design.mps.seg.field.sm"></span><a class="mpstag reference internal" href="#design.mps.seg.field.sm">.field.sm:</a> The <tt class="docutils literal"><span class="pre">sm</span></tt> field is used by the Shield (impl.c.shield)
to manage protection of the segment. It is initialized to
<tt class="docutils literal"><span class="pre">AccessSetEMPTY</span></tt> by <tt class="xref c c-func docutils literal"><span class="pre">SegInit()</span></tt>.</p>
<p><span class="target" id="design.mps.seg.field.pm"></span><a class="mpstag reference internal" href="#design.mps.seg.field.pm">.field.pm:</a> The <tt class="docutils literal"><span class="pre">pm</span></tt> field is used by the Shield (impl.c.shield)
to manage protection of the segment. It is initialized to
<tt class="docutils literal"><span class="pre">AccessSetEMPTY</span></tt> by <tt class="xref c c-func docutils literal"><span class="pre">SegInit()</span></tt>. The field is used by both the
shield and the ANSI fake protection (impl.c.protan).</p>
<p><span class="target" id="design.mps.seg.field.black"></span><a class="mpstag reference internal" href="#design.mps.seg.field.black">.field.black:</a> The <tt class="docutils literal"><span class="pre">black</span></tt> field is the set of traces for which
there may be black objects (that is, objects containing references,
but no references to white objects) in the segment. More precisely, if
there is a black object for a trace in the segment then that trace
will appear in the <tt class="docutils literal"><span class="pre">black</span></tt> field. It is initialized to
<tt class="docutils literal"><span class="pre">TraceSetEMPTY</span></tt> by <tt class="xref c c-func docutils literal"><span class="pre">SegInit()</span></tt>.</p>
<p><span class="target" id="design.mps.seg.field.grey"></span><a class="mpstag reference internal" href="#design.mps.seg.field.grey">.field.grey:</a> The <tt class="docutils literal"><span class="pre">grey</span></tt> field is the set of traces for which
there may be grey objects (i.e containing references to white objects)
in the segment. More precisely, if there is a reference to a white
object for a trace in the segment then that trace will appear in the
<tt class="docutils literal"><span class="pre">grey</span></tt> field. It is initialized to <tt class="docutils literal"><span class="pre">TraceSetEMPTY</span></tt> by <tt class="xref c c-func docutils literal"><span class="pre">SegInit()</span></tt>.</p>
<p><span class="target" id="design.mps.seg.field.white"></span><a class="mpstag reference internal" href="#design.mps.seg.field.white">.field.white:</a> The <tt class="docutils literal"><span class="pre">white</span></tt> field is the set of traces for which
there may be white objects in the segment. More precisely, if there is
a white object for a trace in the segment then that trace will appear
in the <tt class="docutils literal"><span class="pre">white</span></tt> field. It is initialized to <tt class="docutils literal"><span class="pre">TraceSetEMPTY</span></tt> by
<tt class="xref c c-func docutils literal"><span class="pre">SegInit()</span></tt>.</p>
<p><span class="target" id="design.mps.seg.field.summary"></span><a class="mpstag reference internal" href="#design.mps.seg.field.summary">.field.summary:</a> The <tt class="docutils literal"><span class="pre">summary</span></tt> field is an approximation to the
set of all references in the segment. If there is a reference <tt class="docutils literal"><span class="pre">R</span></tt> in
the segment, then <tt class="docutils literal"><span class="pre">RefSetIsMember(summary,</span> <span class="pre">R)</span></tt> is <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt>. The
summary is initialized to <tt class="docutils literal"><span class="pre">RefSetEMPTY</span></tt> by <tt class="xref c c-func docutils literal"><span class="pre">SegInit()</span></tt>.</p>
<p><span class="target" id="design.mps.seg.field.summary.start"></span><a class="mpstag reference internal" href="#design.mps.seg.field.summary.start">.field.summary.start:</a> If references are stored in the segment then
it must be updated, along with <tt class="docutils literal"><span class="pre">rankSet</span></tt> (<a class="reference internal" href="#design.mps.seg.field.rankSet.start">.field.rankSet.start</a>).</p>
<p><span class="target" id="design.mps.seg.field.buffer"></span><a class="mpstag reference internal" href="#design.mps.seg.field.buffer">.field.buffer:</a> The <tt class="docutils literal"><span class="pre">buffer</span></tt> field is either <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt>, or points
to the descriptor structure of the buffer which is currently
allocating in the segment. The field is initialized to <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt> by
<tt class="xref c c-func docutils literal"><span class="pre">SegInit()</span></tt>.</p>
<p><span class="target" id="design.mps.seg.field.buffer.owner"></span><a class="mpstag reference internal" href="#design.mps.seg.field.buffer.owner">.field.buffer.owner:</a> This buffer must belong to the same pool as
the segment, because only that pool has the right to attach it.</p>
</div>
<div class="section" id="interface">
<h2>39.4. Interface<a class="headerlink" href="#interface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="splitting-and-merging">
<h3>39.4.1. Splitting and merging<a class="headerlink" href="#splitting-and-merging" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.seg.split-and-merge"></span><a class="mpstag reference internal" href="#design.mps.seg.split-and-merge">.split-and-merge:</a> There is support for splitting and merging
segments, to give pools the flexibility to rearrange their tracts
among segments as they see fit.</p>
<dl class="function">
<dt id="SegSplit">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">SegSplit</tt><big>(</big><a class="reference internal" href="#Seg" title="Seg">Seg</a><em>&nbsp;*segLoReturn</em>, <a class="reference internal" href="#Seg" title="Seg">Seg</a><em>&nbsp;*segHiReturn</em>, <a class="reference internal" href="#Seg" title="Seg">Seg</a><em>&nbsp;seg</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;at</em>, <a class="reference internal" href="type.html#Bool" title="Bool">Bool</a><em>&nbsp;withReservoirPermit</em>, ...<big>)</big><a class="headerlink" href="#SegSplit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.seg.split"></span><a class="mpstag reference internal" href="#design.mps.seg.split">.split:</a> If successful, segment <tt class="docutils literal"><span class="pre">seg</span></tt> is split at address <tt class="docutils literal"><span class="pre">at</span></tt>,
yielding two segments which are returned in segLoReturn and
segHiReturn for the low and high segments respectively. The base of
the low segment is the old base of <tt class="docutils literal"><span class="pre">seg</span></tt>. The limit of the low
segment is <tt class="docutils literal"><span class="pre">at</span></tt>. The base of the high segment is <tt class="docutils literal"><span class="pre">at</span></tt>. This limit
of the high segment is the old limit of <tt class="docutils literal"><span class="pre">seg</span></tt>. <tt class="docutils literal"><span class="pre">seg</span></tt> is
effectively destroyed during this operation (actually, it might be
reused as one of the returned segments). Segment subclasses may make
use of the optional arguments; the built-in classes do not.</p>
<p><span class="target" id="design.mps.seg.split.invariants"></span><a class="mpstag reference internal" href="#design.mps.seg.split.invariants">.split.invariants:</a> The client must ensure some invariants are met
before calling <a class="reference internal" href="#SegSplit" title="SegSplit"><tt class="xref c c-func docutils literal"><span class="pre">SegSplit()</span></tt></a>:</p>
<ul class="simple">
<li><span class="target" id="design.mps.seg.split.inv.align"></span><a class="mpstag reference internal" href="#design.mps.seg.split.inv.align">.split.inv.align:</a> <tt class="docutils literal"><span class="pre">at</span></tt> must be appropriately aligned to the
arena alignment, and lie between the base and limit of <tt class="docutils literal"><span class="pre">seg</span></tt>.
Justification: the split segments cannot be represented if this is
not so.</li>
<li><span class="target" id="design.mps.seg.split.inv.buffer"></span><a class="mpstag reference internal" href="#design.mps.seg.split.inv.buffer">.split.inv.buffer:</a> If <tt class="docutils literal"><span class="pre">seg</span></tt> is attached to a buffer, the
buffered region must not include address <tt class="docutils literal"><span class="pre">at</span></tt>. Justification: the
segment module is not in a position to know how (or whether) a pool
might wish to split a buffer. This permits the buffer to remain
attached to just one of the returned segments.</li>
</ul>
<p><span class="target" id="design.mps.seg.split.state"></span><a class="mpstag reference internal" href="#design.mps.seg.split.state">.split.state:</a> Except as noted above, the segments returned have the
same properties as <tt class="docutils literal"><span class="pre">seg</span></tt>. That is, their colour, summary, rankset,
nailedness etc. are set to the values of <tt class="docutils literal"><span class="pre">seg</span></tt>.</p>
<dl class="function">
<dt id="SegMerge">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">SegMerge</tt><big>(</big><a class="reference internal" href="#Seg" title="Seg">Seg</a><em>&nbsp;*mergedSegReturn</em>, <a class="reference internal" href="#Seg" title="Seg">Seg</a><em>&nbsp;segLo</em>, <a class="reference internal" href="#Seg" title="Seg">Seg</a><em>&nbsp;segHi</em>, <a class="reference internal" href="type.html#Bool" title="Bool">Bool</a><em>&nbsp;withReservoirPermit</em>, ...<big>)</big><a class="headerlink" href="#SegMerge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.seg.merge"></span><a class="mpstag reference internal" href="#design.mps.seg.merge">.merge:</a> If successful, segments <tt class="docutils literal"><span class="pre">segLo</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt> are merged
together, yielding a segment which is returned in mergedSegReturn.
<tt class="docutils literal"><span class="pre">segLo</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt> are effectively destroyed during this
operation (actually, one of them might be reused as the merged
segment). Segment subclasses may make use of the optional arguments;
the built-in classes do not.</p>
<p><span class="target" id="design.mps.seg.merge.invariants"></span><a class="mpstag reference internal" href="#design.mps.seg.merge.invariants">.merge.invariants:</a> The client must ensure some invariants are met
before calling <a class="reference internal" href="#SegMerge" title="SegMerge"><tt class="xref c c-func docutils literal"><span class="pre">SegMerge()</span></tt></a>:</p>
<ul class="simple">
<li><span class="target" id="design.mps.seg.merge.inv.abut"></span><a class="mpstag reference internal" href="#design.mps.seg.merge.inv.abut">.merge.inv.abut:</a> The limit of <tt class="docutils literal"><span class="pre">segLo</span></tt> must be the same as the
base of <tt class="docutils literal"><span class="pre">segHi</span></tt>. Justification: the merged segment cannot be
represented if this is not so.</li>
<li><span class="target" id="design.mps.seg.merge.inv.buffer"></span><a class="mpstag reference internal" href="#design.mps.seg.merge.inv.buffer">.merge.inv.buffer:</a> One or other of <tt class="docutils literal"><span class="pre">segLo</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt> may
attached to a buffer, but not both. Justification: the segment
module does not support attachment of a single seg to 2 buffers.</li>
<li><span class="target" id="design.mps.seg.merge.inv.similar"></span><a class="mpstag reference internal" href="#design.mps.seg.merge.inv.similar">.merge.inv.similar:</a> <tt class="docutils literal"><span class="pre">segLo</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt> must be sufficiently
similar. Two segments are sufficiently similar if they have
identical values for each of the following fields: <tt class="docutils literal"><span class="pre">class</span></tt>,
<tt class="docutils literal"><span class="pre">sm</span></tt>, <tt class="docutils literal"><span class="pre">grey</span></tt>, <tt class="docutils literal"><span class="pre">white</span></tt>, <tt class="docutils literal"><span class="pre">nailed</span></tt>, <tt class="docutils literal"><span class="pre">rankSet</span></tt>. Justification:
there is no single choice of behaviour for cases where these fields
are not identical. The pool class must make it&#8217;s own choices about
this if it wishes to permit more flexible merging. If so, it should
be a simple matter for the pool to arrange for the segments to look
sufficiently similar before calling <a class="reference internal" href="#SegMerge" title="SegMerge"><tt class="xref c c-func docutils literal"><span class="pre">SegMerge()</span></tt></a>.</li>
</ul>
<p><span class="target" id="design.mps.seg.merge.state"></span><a class="mpstag reference internal" href="#design.mps.seg.merge.state">.merge.state:</a> The merged segment will share the same state as
<tt class="docutils literal"><span class="pre">segLo</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt> for those fields which are identical (see
<a class="reference internal" href="#design.mps.seg.merge.inv.similar">.merge.inv.similar</a>). The summary will be the union of the summaries
of <tt class="docutils literal"><span class="pre">segLo</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt>.</p>
</div>
</div>
<div class="section" id="extensibility">
<h2>39.5. Extensibility<a class="headerlink" href="#extensibility" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>39.5.1. Splitting and merging<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="SegSplitMethod">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">(*SegSplitMethod)</tt><big>(</big><a class="reference internal" href="#Seg" title="Seg">Seg</a><em>&nbsp;seg</em>, <a class="reference internal" href="#Seg" title="Seg">Seg</a><em>&nbsp;segHi</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;base</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;mid</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;limit</em>, <a class="reference internal" href="type.html#Bool" title="Bool">Bool</a><em>&nbsp;withReservoirPermit</em><big>)</big><a class="headerlink" href="#SegSplitMethod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.seg.method.split"></span><a class="mpstag reference internal" href="#design.mps.seg.method.split">.method.split:</a> Segment subclasses may extend the support for
segment splitting by defining their own &#8220;split&#8221; method. On entry,
<tt class="docutils literal"><span class="pre">seg</span></tt> is a segment with region <tt class="docutils literal"><span class="pre">[base,limit)</span></tt>, <tt class="docutils literal"><span class="pre">segHi</span></tt> is
uninitialized, <tt class="docutils literal"><span class="pre">mid</span></tt> is the address at which the segment is to be
split. The method is responsible for destructively modifying <tt class="docutils literal"><span class="pre">seg</span></tt>
and initializing <tt class="docutils literal"><span class="pre">segHi</span></tt> so that on exit <tt class="docutils literal"><span class="pre">seg</span></tt> is a segment with
region <tt class="docutils literal"><span class="pre">[base,mid)</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt> is a segment with region
<tt class="docutils literal"><span class="pre">[mid,limit)</span></tt>. Usually a method would only directly modify the
fields defined for the segment subclass. This might involve
allocation, which may use the reservoir if <tt class="docutils literal"><span class="pre">withReservoirPermit</span></tt> is
<tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt>.</p>
<p><span class="target" id="design.mps.seg.method.split.next"></span><a class="mpstag reference internal" href="#design.mps.seg.method.split.next">.method.split.next:</a> A split method should always call the next
method, either before or after any class-specific code (see
design.mps.protocol <a class="reference internal" href="#design.mps.seg.overview.next-method">.overview.next-method</a>).</p>
<dl class="type">
<dt id="SegMergeMethod">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">(*SegMergeMethod)</tt><big>(</big><a class="reference internal" href="#Seg" title="Seg">Seg</a><em>&nbsp;seg</em>, <a class="reference internal" href="#Seg" title="Seg">Seg</a><em>&nbsp;segHi</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;base</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;mid</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;limit</em>, <a class="reference internal" href="type.html#Bool" title="Bool">Bool</a><em>&nbsp;withReservoirPermit</em><big>)</big><a class="headerlink" href="#SegMergeMethod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.seg.method.merge"></span><a class="mpstag reference internal" href="#design.mps.seg.method.merge">.method.merge:</a> Segment subclasses may extend the support for
segment merging by defining their own <tt class="docutils literal"><span class="pre">merge</span></tt> method. On entry,
<tt class="docutils literal"><span class="pre">seg</span></tt> is a segment with region <tt class="docutils literal"><span class="pre">[base,mid)</span></tt>, <tt class="docutils literal"><span class="pre">segHi</span></tt> is a
segment with region <tt class="docutils literal"><span class="pre">[mid,limit)</span></tt>, The method is responsible for
destructively modifying <tt class="docutils literal"><span class="pre">seg</span></tt> and finishing <tt class="docutils literal"><span class="pre">segHi</span></tt> so that on
exit <tt class="docutils literal"><span class="pre">seg</span></tt> is a segment with region <tt class="docutils literal"><span class="pre">[base,limit)</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt>
is garbage. Usually a method would only modify the fields defined for
the segment subclass. This might involve allocation, which may use the
reservoir if <tt class="docutils literal"><span class="pre">withReservoirPermit</span></tt> is <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt>.</p>
<p><span class="target" id="design.mps.seg.method.merge.next"></span><a class="mpstag reference internal" href="#design.mps.seg.method.merge.next">.method.merge.next:</a> A merge method should always call the next
method, either before or after any class-specific code (see
design.mps.protocol.overview.next-method).</p>
<p><span class="target" id="design.mps.seg.split-merge.shield"></span><a class="mpstag reference internal" href="#design.mps.seg.split-merge.shield">.split-merge.shield:</a> Split and merge methods may assume that the
segments they are manipulating are not in the shield cache.</p>
<p><span class="target" id="design.mps.seg.split-merge.shield.flush"></span><a class="mpstag reference internal" href="#design.mps.seg.split-merge.shield.flush">.split-merge.shield.flush:</a> The shield cache is flushed before any
split or merge methods are invoked.</p>
<p><span class="target" id="design.mps.seg.split-merge.shield.re-flush"></span><a class="mpstag reference internal" href="#design.mps.seg.split-merge.shield.re-flush">.split-merge.shield.re-flush:</a> If a split or merge method performs
an operation on a segment which might cause the segment to be cached,
the method must flush the shield cache before returning or calling
another split or merge method.</p>
<p><span class="target" id="design.mps.seg.split-merge.fail"></span><a class="mpstag reference internal" href="#design.mps.seg.split-merge.fail">.split-merge.fail:</a> Split and merge methods might fail, in which
case segments <tt class="docutils literal"><span class="pre">seg</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt> must be equivalently valid and
configured at exit as they were according to the entry conditions.
It&#8217;s simplest if the failure can be detected before calling the next
method (for example, by allocating any objects early in the method).</p>
<p><span class="target" id="design.mps.seg.split-merge.fail.anti"></span><a class="mpstag reference internal" href="#design.mps.seg.split-merge.fail.anti">.split-merge.fail.anti:</a> If it&#8217;s not possible to detect failure
before calling the next method, the appropriate anti-method must be
used (see design.mps.protocol.guide.fail.after-next). Split methods
are anti-methods for merge methods, and vice-versa.</p>
<p><span class="target" id="design.mps.seg.split-merge.fail.anti.constrain"></span><a class="mpstag reference internal" href="#design.mps.seg.split-merge.fail.anti.constrain">.split-merge.fail.anti.constrain:</a> In general, care should be taken
when writing split and merge methods to ensure that they really are
anti-methods for each other. The anti-method must not fail if the
initial method succeeded. The anti-method should reverse any side
effects of the initial method, except where it&#8217;s known to be safe to
avoid this (see <a class="reference internal" href="#design.mps.seg.split-merge.fail.summary">.split-merge.fail.summary</a> for an example of a safe
case).</p>
<p><span class="target" id="design.mps.seg.split-merge.fail.anti.no"></span><a class="mpstag reference internal" href="#design.mps.seg.split-merge.fail.anti.no">.split-merge.fail.anti.no:</a> If this isn&#8217;t possible (it might not be)
then the methods won&#8217;t support after-next failure. This fact should be
documented, if the methods are intended to support further
specialization. Note that using va_arg with the <tt class="docutils literal"><span class="pre">args</span></tt> parameter is
sufficient to make it impossible to reverse all side effects.</p>
<p><span class="target" id="design.mps.seg.split-merge.fail.summary"></span><a class="mpstag reference internal" href="#design.mps.seg.split-merge.fail.summary">.split-merge.fail.summary:</a> The segment summary might not be
restored exactly after a failed merge operation. Each segment would be
left with a summary which is the union of the original summaries (see
<a class="reference internal" href="#design.mps.seg.merge.state">.merge.state</a>). This increases the conservatism in the summaries,
but is otherwise safe.</p>
<p><span class="target" id="design.mps.seg.split-merge.unsupported"></span><a class="mpstag reference internal" href="#design.mps.seg.split-merge.unsupported">.split-merge.unsupported:</a> Segment classes need not support segment
merging at all. The function <tt class="xref c c-func docutils literal"><span class="pre">SegClassMixInNoSplitMerge()</span></tt> is supplied
to set the split and merge methods to unsupporting methods that will
report an error in checking varieties.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">39. Segment data structure</a><ul>
<li><a class="reference internal" href="#introduction">39.1. Introduction</a></li>
<li><a class="reference internal" href="#overview">39.2. Overview</a></li>
<li><a class="reference internal" href="#data-structure">39.3. Data Structure</a></li>
<li><a class="reference internal" href="#interface">39.4. Interface</a><ul>
<li><a class="reference internal" href="#splitting-and-merging">39.4.1. Splitting and merging</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extensibility">39.5. Extensibility</a><ul>
<li><a class="reference internal" href="#id1">39.5.1. Splitting and merging</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="scan.html"
                        title="previous chapter">38. The generic scanner</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="shield.html"
                        title="next chapter">40. Shield</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="shield.html" title="40. Shield"
             >next</a> |</li>
        <li class="right" >
          <a href="scan.html" title="38. The generic scanner"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" >Old design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>