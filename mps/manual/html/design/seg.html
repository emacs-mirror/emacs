

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>15. Segment data structure &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Old design" href="old.html" />
    <link rel="next" title="16. Splay trees" href="splay.html" />
    <link rel="prev" title="14. The generic scanner" href="scan.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="splay.html" title="16. Splay trees"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="scan.html" title="14. The generic scanner"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" accesskey="U">Old design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="design-seg"><span id="index-0"></span></span><div class="section" id="segment-data-structure">
<h1>15. Segment data structure<a class="headerlink" href="#segment-data-structure" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Tag:</th><td class="field-body">design.mps.seg</td>
</tr>
<tr class="field-even field"><th class="field-name">Author:</th><td class="field-body">David Jones</td>
</tr>
<tr class="field-odd field"><th class="field-name">Date:</th><td class="field-body">1997-04-03</td>
</tr>
<tr class="field-even field"><th class="field-name">Status:</th><td class="field-body">incomplete design</td>
</tr>
<tr class="field-odd field"><th class="field-name">Revision:</th><td class="field-body">$Id: //info.ravenbrook.com/project/mps/master/design/seg.txt#1 $</td>
</tr>
<tr class="field-even field"><th class="field-name">Copyright:</th><td class="field-body">See <a class="reference internal" href="#copyright-and-license">Copyright and License</a>.</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h2>15.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="intro">.intro</span>: This document describes the MPS Segment data structure.</p>
</div>
<div class="section" id="overview">
<h2>15.2. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="over-segments">.over.segments</span>: Segments are the basic units of tracing and
shielding. The MPM also uses them as units of scanning and colour,
although pool classes may subdivide segments and be able to maintain
colour on a finer grain (down to the object level, for example).</p>
<p><span class="target" id="over-objects">.over.objects</span>: The mutator&#8217;s objects are stored in segments.
Segments are contiguous blocks of memory managed by some pool.</p>
<p><span class="target" id="segments-pool">.segments.pool</span>: The arrangement of objects within a segment is
determined by the class of the pool which owns the segment. The pool
is associated with the segment indirectly via the first tract of the
segment.</p>
<p><span class="target" id="over-memory">.over.memory</span>: The relationship between segments and areas of memory
is maintained by the segment module. Pools acquire tracts from the
arena, and release them back to the arena when they don&#8217;t need them
any longer. The segment module can associate contiguous tracts owned
by the same pool with a segment. The segment module provides the
methods SegBase, SegLimit, and SegSize which map a segment onto the
addresses of the memory block it represents.</p>
<p><span class="target" id="over-hierarchy">.over.hierarchy</span>: The Segment datastructure is designed to be
subclassable (see design.mps.protocol). The basic segment class
(<tt class="docutils literal"><span class="pre">Seg</span></tt>) supports colour and protection for use by the tracer, as
well as support for a pool ring, and all generic segment functions.
Clients may use <tt class="docutils literal"><span class="pre">Seg</span></tt> directly, but will most probably want to use a
subclass with additional properties.</p>
<p><span class="target" id="over-hierarchy-gcseg">.over.hierarchy.gcseg</span>: The segment module provides <tt class="docutils literal"><span class="pre">GCSeg</span></tt> - a
subclass of <tt class="docutils literal"><span class="pre">Seg</span></tt> which has full support for GC including buffering
and the ability to be linked onto the grey ring.</p>
</div>
<div class="section" id="data-structure">
<h2>15.3. Data Structure<a class="headerlink" href="#data-structure" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">SegStruct</span> <span class="p">{</span>      <span class="cm">/* segment structure */</span>
  <span class="n">Sig</span> <span class="n">sig</span><span class="p">;</span>                      <span class="cm">/* impl.h.misc.sig */</span>
  <span class="n">SegClass</span> <span class="n">class</span><span class="p">;</span>               <span class="cm">/* segment class structure */</span>
  <span class="n">Tract</span> <span class="n">firstTract</span><span class="p">;</span>             <span class="cm">/* first tract of segment */</span>
  <span class="n">RingStruct</span> <span class="n">poolRing</span><span class="p">;</span>          <span class="cm">/* link in list of segs in pool */</span>
  <span class="n">Addr</span> <span class="n">limit</span><span class="p">;</span>                   <span class="cm">/* limit of segment */</span>
  <span class="kt">unsigned</span> <span class="n">depth</span> <span class="o">:</span> <span class="n">SHIELD_DEPTH_WIDTH</span><span class="p">;</span> <span class="cm">/* see impl.c.shield.def.depth */</span>
  <span class="n">AccessSet</span> <span class="n">pm</span> <span class="o">:</span> <span class="n">AccessMAX</span><span class="p">;</span>     <span class="cm">/* protection mode, impl.c.shield */</span>
  <span class="n">AccessSet</span> <span class="n">sm</span> <span class="o">:</span> <span class="n">AccessMAX</span><span class="p">;</span>     <span class="cm">/* shield mode, impl.c.shield */</span>
  <span class="n">TraceSet</span> <span class="n">grey</span> <span class="o">:</span> <span class="n">TRACE_MAX</span><span class="p">;</span>    <span class="cm">/* traces for which seg is grey */</span>
  <span class="n">TraceSet</span> <span class="n">white</span> <span class="o">:</span> <span class="n">TRACE_MAX</span><span class="p">;</span>   <span class="cm">/* traces for which seg is white */</span>
  <span class="n">TraceSet</span> <span class="n">nailed</span> <span class="o">:</span> <span class="n">TRACE_MAX</span><span class="p">;</span>  <span class="cm">/* traces for which seg has nailed objects */</span>
  <span class="n">RankSet</span> <span class="n">rankSet</span> <span class="o">:</span> <span class="n">RankMAX</span><span class="p">;</span>    <span class="cm">/* ranks of references in this seg */</span>
<span class="p">}</span> <span class="n">SegStruct</span><span class="p">;</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="n">GCSegStruct</span> <span class="p">{</span>    <span class="cm">/* GC segment structure */</span>
  <span class="n">SegStruct</span> <span class="n">segStruct</span><span class="p">;</span>          <span class="cm">/* superclass fields must come first */</span>
  <span class="n">RingStruct</span> <span class="n">greyRing</span><span class="p">;</span>          <span class="cm">/* link in list of grey segs */</span>
  <span class="n">RefSet</span> <span class="n">summary</span><span class="p">;</span>               <span class="cm">/* summary of references out of seg */</span>
  <span class="n">Buffer</span> <span class="n">buffer</span><span class="p">;</span>                <span class="cm">/* non-NULL if seg is buffered */</span>
  <span class="n">Sig</span> <span class="n">sig</span><span class="p">;</span>                      <span class="cm">/* design.mps.sig */</span>
<span class="p">}</span> <span class="n">GCSegStruct</span><span class="p">;</span>
</pre></div>
</div>
<p><span class="target" id="field-rankset">.field.rankSet</span>: The <tt class="docutils literal"><span class="pre">rankSet</span></tt> field represents the set of ranks
of the references in the segment. It is initialized to empty by
<tt class="docutils literal"><span class="pre">SegInit</span></tt>.</p>
<p><span class="target" id="field-rankset-single">.field.rankSet.single</span>: The Tracer only permits one rank per segment
[ref?] so this field is either empty or a singleton.</p>
<p><span class="target" id="field-rankset-empty">.field.rankSet.empty</span>: An empty <tt class="docutils literal"><span class="pre">rankSet</span></tt> indicates that there are
no references. If there are no references in the segment then it
cannot contain black or grey references.</p>
<p><span class="target" id="field-rankset-start">.field.rankSet.start</span>: If references are stored in the segment then
it must be updated, along with the summary (<a class="reference internal" href="#field-summary-start">.field.summary.start</a>).</p>
<p><span class="target" id="field-depth">.field.depth</span>: The <tt class="docutils literal"><span class="pre">depth</span></tt> field is used by the Shield
(impl.c.shield) to manage protection of the segment. It is initialized
to zero by <tt class="docutils literal"><span class="pre">SegInit</span></tt>.</p>
<p><span class="target" id="field-sm">.field.sm</span>: The <tt class="docutils literal"><span class="pre">sm</span></tt> field is used by the Shield (impl.c.shield)
to manage protection of the segment. It is initialized to
<tt class="docutils literal"><span class="pre">AccessSetEMPTY</span></tt> by <tt class="docutils literal"><span class="pre">SegInit</span></tt>.</p>
<p><span class="target" id="field-pm">.field.pm</span>: The <tt class="docutils literal"><span class="pre">pm</span></tt> field is used by the Shield (impl.c.shield)
to manage protection of the segment. It is initialized to
<tt class="docutils literal"><span class="pre">AccessSetEMPTY</span></tt> by <tt class="docutils literal"><span class="pre">SegInit</span></tt>. The field is used by both the
shield and the ANSI fake protection (impl.c.protan).</p>
<p><span class="target" id="field-black">.field.black</span>: The <tt class="docutils literal"><span class="pre">black</span></tt> field is the set of traces for which
there may be black objects (that is, objects containing references,
but no references to white objects) in the segment. More precisely, if
there is a black object for a trace in the segment then that trace
will appear in the <tt class="docutils literal"><span class="pre">black</span></tt> field. It is initialized to
<tt class="docutils literal"><span class="pre">TraceSetEMPTY</span></tt> by <tt class="docutils literal"><span class="pre">SegInit</span></tt>.</p>
<p><span class="target" id="field-grey">.field.grey</span>: The <tt class="docutils literal"><span class="pre">grey</span></tt> field is the set of traces for which
there may be grey objects (i.e containing references to white objects)
in the segment. More precisely, if there is a reference to a white
object for a trace in the segment then that trace will appear in the
<tt class="docutils literal"><span class="pre">grey</span></tt> field. It is initialized to <tt class="docutils literal"><span class="pre">TraceSetEMPTY</span></tt> by <tt class="docutils literal"><span class="pre">SegInit</span></tt>.</p>
<p><span class="target" id="field-white">.field.white</span>: The <tt class="docutils literal"><span class="pre">white</span></tt> field is the set of traces for which
there may be white objects in the segment. More precisely, if there is
a white object for a trace in the segment then that trace will appear
in the <tt class="docutils literal"><span class="pre">white</span></tt> field. It is initialized to <tt class="docutils literal"><span class="pre">TraceSetEMPTY</span></tt> by
<tt class="docutils literal"><span class="pre">SegInit</span></tt>.</p>
<p><span class="target" id="field-summary">.field.summary</span>: The <tt class="docutils literal"><span class="pre">summary</span></tt> field is an approximation to the
set of all references in the segment. If there is a reference <tt class="docutils literal"><span class="pre">R</span></tt> in
the segment, then <tt class="docutils literal"><span class="pre">RefSetIsMember(summary,</span> <span class="pre">R)</span></tt> is <tt class="docutils literal"><span class="pre">TRUE</span></tt>. The
summary is initialized to <tt class="docutils literal"><span class="pre">RefSetEMPTY</span></tt> by <tt class="docutils literal"><span class="pre">SegInit</span></tt>.</p>
<p><span class="target" id="field-summary-start">.field.summary.start</span>: If references are stored in the segment then
it must be updated, along with <tt class="docutils literal"><span class="pre">rankSet</span></tt> (<a class="reference internal" href="#field-rankset-start">.field.rankSet.start</a>).</p>
<p><span class="target" id="field-buffer">.field.buffer</span>: The <tt class="docutils literal"><span class="pre">buffer</span></tt> field is either <tt class="docutils literal"><span class="pre">NULL</span></tt>, or points
to the descriptor structure of the buffer which is currently
allocating in the segment. The field is initialized to <tt class="docutils literal"><span class="pre">NULL</span></tt> by
<tt class="docutils literal"><span class="pre">SegInit</span></tt>.</p>
<p><span class="target" id="field-buffer-owner">.field.buffer.owner</span>: This buffer must belong to the same pool as
the segment, because only that pool has the right to attach it.</p>
</div>
<div class="section" id="interface">
<h2>15.4. Interface<a class="headerlink" href="#interface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="splitting-and-merging">
<h3>15.4.1. Splitting and merging<a class="headerlink" href="#splitting-and-merging" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="split-and-merge">.split-and-merge</span>: There is support for splitting and merging
segments, to give pools the flexibility to rearrange their tracts
among segments as they see fit.</p>
<p><span class="target" id="split">.split</span>: Segments may be split with the function <tt class="docutils literal"><span class="pre">SegSplit</span></tt></p>
<p><tt class="docutils literal"><span class="pre">Res</span> <span class="pre">SegSplit(Seg</span> <span class="pre">*segLoReturn,</span> <span class="pre">Seg</span> <span class="pre">*segHiReturn,</span> <span class="pre">Seg</span> <span class="pre">seg,</span> <span class="pre">Addr</span> <span class="pre">at,</span> <span class="pre">Bool</span> <span class="pre">withReservoirPermit,</span> <span class="pre">...);</span></tt></p>
<p>If successful, segment <tt class="docutils literal"><span class="pre">seg</span></tt> is split at address <tt class="docutils literal"><span class="pre">at</span></tt>, yielding
two segments which are returned in segLoReturn and segHiReturn for the
low and high segments respectively. The base of the low segment is the
old base of <tt class="docutils literal"><span class="pre">seg</span></tt>. The limit of the low segment is <tt class="docutils literal"><span class="pre">at</span></tt>. The base
of the high segment is <tt class="docutils literal"><span class="pre">at</span></tt>. This limit of the high segment is the
old limit of <tt class="docutils literal"><span class="pre">seg</span></tt>. <tt class="docutils literal"><span class="pre">seg</span></tt> is effectively destroyed during this
operation (actually, it might be reused as one of the returned
segments). Segment subclasses may make use of the optional arguments;
the built-in classes do not.</p>
<p><span class="target" id="split-invariants">.split.invariants</span>: The client must ensure some invariants are met
before calling <tt class="docutils literal"><span class="pre">SegSplit</span></tt>:</p>
<p><span class="target" id="split-inv-align">.split.inv.align</span>: <tt class="docutils literal"><span class="pre">at</span></tt> must be appropriately aligned to the arena
alignment, and lie between the base and limit of <tt class="docutils literal"><span class="pre">seg</span></tt>.
Justification: the split segments cannot be represented if this is not
so.</p>
<p><span class="target" id="split-inv-buffer">.split.inv.buffer</span>: If <tt class="docutils literal"><span class="pre">seg</span></tt> is attached to a buffer, the buffered
region must not include address <tt class="docutils literal"><span class="pre">at</span></tt>. Justification: the segment
module is not in a position to know how (or whether) a pool might wish
to split a buffer. This permits the buffer to remain attached to just
one of the returned segments.</p>
<p><span class="target" id="split-state">.split.state</span>: Except as noted above, the segments returned have the
same properties as <tt class="docutils literal"><span class="pre">seg</span></tt>. That is, their colour, summary, rankset,
nailedness etc. are set to the values of <tt class="docutils literal"><span class="pre">seg</span></tt>.</p>
<p><span class="target" id="merge">.merge</span>: Segments may be merged with the function SegMerge</p>
<p><tt class="docutils literal"><span class="pre">Res</span> <span class="pre">SegMerge(Seg</span> <span class="pre">*mergedSegReturn,</span> <span class="pre">Seg</span> <span class="pre">segLo,</span> <span class="pre">Seg</span> <span class="pre">segHi,</span> <span class="pre">Bool</span> <span class="pre">withReservoirPermit,</span> <span class="pre">...);</span></tt></p>
<p>If successful, segments <tt class="docutils literal"><span class="pre">segLo</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt> are merged together,
yielding a segment which is returned in mergedSegReturn. <tt class="docutils literal"><span class="pre">segLo</span></tt> and
<tt class="docutils literal"><span class="pre">segHi</span></tt> are effectively destroyed during this operation (actually,
one of them might be reused as the merged segment). Segment subclasses
may make use of the optional arguments; the built-in classes do not.</p>
<p><span class="target" id="merge-invariants">.merge.invariants</span>: The client must ensure some invariants are met
before calling <tt class="docutils literal"><span class="pre">SegMerge</span></tt>:</p>
<p><span class="target" id="merge-inv-abut">.merge.inv.abut</span>: The limit of <tt class="docutils literal"><span class="pre">segLo</span></tt> must be the same as the
base of <tt class="docutils literal"><span class="pre">segHi</span></tt>. Justification: the merged segment cannot be
represented if this is not so.</p>
<p><span class="target" id="merge-inv-buffer">.merge.inv.buffer</span>: One or other of <tt class="docutils literal"><span class="pre">segLo</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt> may
attached to a buffer, but not both. Justification: the segment module
does not support attachment of a single seg to 2 buffers.</p>
<p><span class="target" id="merge-inv-similar">.merge.inv.similar</span>: <tt class="docutils literal"><span class="pre">segLo</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt> must be sufficiently
similar. Two segments are sufficiently similar if they have identical
values for each of the following fields: <tt class="docutils literal"><span class="pre">class</span></tt>, <tt class="docutils literal"><span class="pre">sm</span></tt>, <tt class="docutils literal"><span class="pre">grey</span></tt>,
<tt class="docutils literal"><span class="pre">white</span></tt>, <tt class="docutils literal"><span class="pre">nailed</span></tt>, <tt class="docutils literal"><span class="pre">rankSet</span></tt>. Justification: there is no single
choice of behaviour for cases where these fields are not identical.
The pool class must make it&#8217;s own choices about this if it wishes to
permit more flexible merging. If so, it should be a simple matter for
the pool to arrange for the segments to look sufficiently similar
before calling <tt class="docutils literal"><span class="pre">SegMerge</span></tt>.</p>
<p><span class="target" id="merge-state">.merge.state</span>: The merged segment will share the same state as
<tt class="docutils literal"><span class="pre">segLo</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt> for those fields which are identical (see
<a class="reference internal" href="#merge-inv-similar">.merge.inv.similar</a>). The summary will be the union of the summaries
of <tt class="docutils literal"><span class="pre">segLo</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt>.</p>
</div>
</div>
<div class="section" id="extensibility">
<h2>15.5. Extensibility<a class="headerlink" href="#extensibility" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>15.5.1. Splitting and merging<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="method-split">.method.split</span>: Segment subclasses may extend the support for
segment splitting by defining their own &#8220;split&#8221; method.</p>
<p><tt class="docutils literal"><span class="pre">Res</span> <span class="pre">segSplit(Seg</span> <span class="pre">seg,</span> <span class="pre">Seg</span> <span class="pre">segHi,</span> <span class="pre">Addr</span> <span class="pre">base,</span> <span class="pre">Addr</span> <span class="pre">mid,</span> <span class="pre">Addr</span> <span class="pre">limit,</span> <span class="pre">Bool</span> <span class="pre">withReservoirPermit,</span> <span class="pre">va_list</span> <span class="pre">args)</span></tt></p>
<p>On entry, <tt class="docutils literal"><span class="pre">seg</span></tt> is a segment with region <tt class="docutils literal"><span class="pre">[base,limit)</span></tt>, <tt class="docutils literal"><span class="pre">segHi</span></tt>
is uninitialized, <tt class="docutils literal"><span class="pre">mid</span></tt> is the address at which the segment is to be
split. The method is responsible for destructively modifying <tt class="docutils literal"><span class="pre">seg</span></tt>
and initializing <tt class="docutils literal"><span class="pre">segHi</span></tt> so that on exit <tt class="docutils literal"><span class="pre">seg</span></tt> is a segment with
region <tt class="docutils literal"><span class="pre">[base,mid)</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt> is a segment with region
<tt class="docutils literal"><span class="pre">[mid,limit)</span></tt>. Usually a method would only directly modify the
fields defined for the segment subclass. This might involve
allocation, which may use the reservoir if <tt class="docutils literal"><span class="pre">withReservoirPermit</span></tt> is
<tt class="docutils literal"><span class="pre">TRUE</span></tt>.</p>
<p><span class="target" id="method-split-next">.method.split.next</span>: A split method should always call the next
method, either before or after any class-specific code (see
design.mps.protocol <a href="#id2"><span class="problematic" id="id3">`.overview.next-method`_</span></a>).</p>
<p><span class="target" id="method-merge">.method.merge</span>: Segment subclasses may extend the support for
segment merging by defining their own <tt class="docutils literal"><span class="pre">merge</span></tt> method.</p>
<p><tt class="docutils literal"><span class="pre">Res</span> <span class="pre">segMerge(Seg</span> <span class="pre">seg,</span> <span class="pre">Seg</span> <span class="pre">segHi,</span> <span class="pre">Addr</span> <span class="pre">base,</span> <span class="pre">Addr</span> <span class="pre">mid,</span> <span class="pre">Addr</span> <span class="pre">limit,</span> <span class="pre">Bool</span> <span class="pre">withReservoirPermit,</span> <span class="pre">va_list</span> <span class="pre">args)</span></tt></p>
<p>On entry, <tt class="docutils literal"><span class="pre">seg</span></tt> is a segment with region <tt class="docutils literal"><span class="pre">[base,mid)</span></tt>, <tt class="docutils literal"><span class="pre">segHi</span></tt>
is a segment with region <tt class="docutils literal"><span class="pre">[mid,limit)</span></tt>, The method is responsible
for destructively modifying <tt class="docutils literal"><span class="pre">seg</span></tt> and finishing <tt class="docutils literal"><span class="pre">segHi</span></tt> so that on
exit <tt class="docutils literal"><span class="pre">seg</span></tt> is a segment with region <tt class="docutils literal"><span class="pre">[base,limit)</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt>
is garbage. Usually a method would only modify the fields defined for
the segment subclass. This might involve allocation, which may use the
reservoir if <tt class="docutils literal"><span class="pre">withReservoirPermit</span></tt> is <tt class="docutils literal"><span class="pre">TRUE</span></tt>.</p>
<p><span class="target" id="method-merge-next">.method.merge.next</span>: A merge method should always call the next
method, either before or after any class-specific code (see
design.mps.protocol.overview.next-method).</p>
<p><span class="target" id="split-merge-shield">.split-merge.shield</span>: Split and merge methods may assume that the
segments they are manipulating are not in the shield cache.</p>
<p><span class="target" id="split-merge-shield-flush">.split-merge.shield.flush</span>: The shield cache is flushed before any
split or merge methods are invoked.</p>
<p><span class="target" id="split-merge-shield-re-flush">.split-merge.shield.re-flush</span>: If a split or merge method performs
an operation on a segment which might cause the segment to be cached,
the method must flush the shield cache before returning or calling
another split or merge method.</p>
<p><span class="target" id="split-merge-fail">.split-merge.fail</span>: Split and merge methods might fail, in which
case segments <tt class="docutils literal"><span class="pre">seg</span></tt> and <tt class="docutils literal"><span class="pre">segHi</span></tt> must be equivalently valid and
configured at exit as they were according to the entry conditions.
It&#8217;s simplest if the failure can be detected before calling the next
method (for example, by allocating any objects early in the method).</p>
<p><span class="target" id="split-merge-fail-anti">.split-merge.fail.anti</span>: If it&#8217;s not possible to detect failure
before calling the next method, the appropriate anti-method must be
used (see design.mps.protocol.guide.fail.after-next). Split methods
are anti-methods for merge methods, and vice-versa.</p>
<p><span class="target" id="split-merge-fail-anti-constrain">.split-merge.fail.anti.constrain</span>: In general, care should be taken
when writing split and merge methods to ensure that they really are
anti-methods for each other. The anti-method must not fail if the
initial method succeeded. The anti-method should reverse any side
effects of the initial method, except where it&#8217;s known to be safe to
avoid this (see <a class="reference internal" href="#split-merge-fail-summary">.split-merge.fail.summary</a> for an example of a safe
case).</p>
<p><span class="target" id="split-merge-fail-anti-no">.split-merge.fail.anti.no</span>: If this isn&#8217;t possible (it might not be)
then the methods won&#8217;t support after-next failure. This fact should be
documented, if the methods are intended to support further
specialization. Note that using va_arg with the <tt class="docutils literal"><span class="pre">args</span></tt> parameter is
sufficient to make it impossible to reverse all side effects.</p>
<p><span class="target" id="split-merge-fail-summary">.split-merge.fail.summary</span>: The segment summary might not be
restored exactly after a failed merge operation. Each segment would be
left with a summary which is the union of the original summaries (see
<a class="reference internal" href="#merge-state">.merge.state</a>). This increases the conservatism in the summaries,
but is otherwise safe.</p>
<p><span class="target" id="split-merge-unsupported">.split-merge.unsupported</span>: Segment classes need not support segment
merging at all. The function <tt class="docutils literal"><span class="pre">SegClassMixInNoSplitMerge</span></tt> is supplied
to set the split and merge methods to unsupporting methods that will
report an error in checking varieties.</p>
</div>
</div>
<div class="section" id="document-history">
<h2>15.6. Document History<a class="headerlink" href="#document-history" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>1997-04-03 <a class="reference external" href="http://www.ravenbrook.com/consultants/rb/">RB</a> Initial draft (replacing various notes in revisions 0
and 1) was as part of editing MMsrc!seg.c(MMdevel_action2.1).</li>
<li>1999-04-16 Tony Mann. Rewritten to separate segments and tracts,
following mail.tony.1998-11-02.10-26</li>
<li>2002-06-07 <a class="reference external" href="http://www.ravenbrook.com/consultants/rb/">RB</a> Converted from MMInfo database design document.</li>
</ul>
</div>
<div class="section" id="copyright-and-license">
<h2>15.7. Copyright and License<a class="headerlink" href="#copyright-and-license" title="Permalink to this headline">¶</a></h2>
<p>Copyright © 2001-2013 Ravenbrook Limited. All rights reserved.
&lt;<a class="reference external" href="http://www.ravenbrook.com/">http://www.ravenbrook.com/</a>&gt;. This is an open source license. Contact
Ravenbrook for commercial licensing options.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:</p>
<ol class="arabic simple">
<li>Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.</li>
<li>Redistributions in any form must be accompanied by information on how
to obtain complete source code for this software and any
accompanying software that uses this software.  The source code must
either be included in the distribution or be available for no more than
the cost of distribution plus a nominal fee, and must be freely
redistributable under reasonable conditions.  For an executable file,
complete source code means the source code for all modules it contains.
It does not include source code for modules or files that typically
accompany the major components of the operating system on which the
executable file runs.</li>
</ol>
<p><strong>This software is provided by the copyright holders and contributors
&#8220;as is&#8221; and any express or implied warranties, including, but not
limited to, the implied warranties of merchantability, fitness for a
particular purpose, or non-infringement, are disclaimed.  In no event
shall the copyright holders and contributors be liable for any direct,
indirect, incidental, special, exemplary, or consequential damages
(including, but not limited to, procurement of substitute goods or
services; loss of use, data, or profits; or business interruption)
however caused and on any theory of liability, whether in contract,
strict liability, or tort (including negligence or otherwise) arising in
any way out of the use of this software, even if advised of the
possibility of such damage.</strong></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">15. Segment data structure</a><ul>
<li><a class="reference internal" href="#introduction">15.1. Introduction</a></li>
<li><a class="reference internal" href="#overview">15.2. Overview</a></li>
<li><a class="reference internal" href="#data-structure">15.3. Data Structure</a></li>
<li><a class="reference internal" href="#interface">15.4. Interface</a><ul>
<li><a class="reference internal" href="#splitting-and-merging">15.4.1. Splitting and merging</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extensibility">15.5. Extensibility</a><ul>
<li><a class="reference internal" href="#id1">15.5.1. Splitting and merging</a></li>
</ul>
</li>
<li><a class="reference internal" href="#document-history">15.6. Document History</a></li>
<li><a class="reference internal" href="#copyright-and-license">15.7. Copyright and License</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="scan.html"
                        title="previous chapter">14. The generic scanner</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="splay.html"
                        title="next chapter">16. Splay trees</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="splay.html" title="16. Splay trees"
             >next</a> |</li>
        <li class="right" >
          <a href="scan.html" title="14. The generic scanner"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" >Old design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>