

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>12. C interface design &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Old design" href="old.html" />
    <link rel="next" title="13. I/O subsystem" href="io.html" />
    <link rel="prev" title="11. The generic fix function" href="fix.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="io.html" title="13. I/O subsystem"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="fix.html" title="11. The generic fix function"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" accesskey="U">Old design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="c-interface-design">
<span id="design-interface-c"></span><span id="index-0"></span><h1>12. C interface design<a class="headerlink" href="#c-interface-design" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="design.mps.interface.c"></span><h2>12.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.interface.c.scope"></span><a class="mpstag reference internal" href="#design.mps.interface.c.scope">.scope:</a> This document is the design for the Memory Pool System
(MPS) interface to the C Language, impl.h.mps.</p>
<p><span class="target" id="design.mps.interface.c.bg"></span><a class="mpstag reference internal" href="#design.mps.interface.c.bg">.bg:</a> See mail.richard.1996-07-24.10-57.</p>
</div>
<div class="section" id="analysis">
<h2>12.2. Analysis<a class="headerlink" href="#analysis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="goals">
<h3>12.2.1. Goals<a class="headerlink" href="#goals" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.interface.c.goal.c"></span><a class="mpstag reference internal" href="#design.mps.interface.c.goal.c">.goal.c:</a> The file impl.h.mps is the C external interface to the
MPS. It is the default interface between client code written in C and
the MPS. <span class="target" id="design.mps.interface.c.goal.cpp"></span><a class="mpstag reference internal" href="#design.mps.interface.c.goal.cpp">.goal.cpp:</a> impl.h.mps is not specifically designed to be
an interface to C++, but should be usable from C++.</p>
</div>
<div class="section" id="requirements">
<h3>12.2.2. Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.interface.c.req"></span><a class="mpstag reference internal" href="#design.mps.interface.c.req">.req:</a> The interface must provide an interface from client code
written in C to the functionality of the MPS required by the product
(see req.product), Dylan (req.dylan), and the Core RIP (req.epcore).</p>
<p><tt class="docutils literal"><span class="pre">mps.h</span></tt> may not include internal MPS header files (such as
<tt class="docutils literal"><span class="pre">pool.h</span></tt>).</p>
<p>It is essential that the interface cope well with change, in order to
avoid restricting possible future MPS developments. This means that
the interface must be &#8220;open ended&#8221; in its definitions. This accounts
for some of the apparently tortuous methods of doing things
(<tt class="docutils literal"><span class="pre">mps_fmt_A_t</span></tt>, for example). The requirement is that the MPS should
be able to add new functionality, or alter the implementation of
existing functionality, without affecting existing client code. A
stronger requirement is that the MPS should be able to change without
<em>recompiling</em> client code. This is not always possible.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p><cite>.naming.global</cite> was presumably done in response to unwritten
requirements regarding the use of the name spaces in C, perhaps
these:</p>
<ul class="simple">
<li><span class="target" id="design.mps.interface.c.req.name.iso"></span><a class="mpstag reference internal" href="#design.mps.interface.c.req.name.iso">.req.name.iso:</a> The interface shall not conflict in terms of
naming with any interfaces specified by ISO C and all reasonable
future versions.</li>
<li><span class="target" id="design.mps.interface.c.req.name.general"></span><a class="mpstag reference internal" href="#design.mps.interface.c.req.name.general">.req.name.general:</a> The interface shall use a documented and
reasonably small portion of the namespace so that clients can
interoperate easily.</li>
</ul>
<p class="last">David Jones, 1998-10-01.</p>
</div>
</div>
</div>
<div class="section" id="architecture">
<h2>12.3. Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.interface.c.fig.arch"></span><a class="mpstag reference internal" href="#design.mps.interface.c.fig.arch">.fig.arch:</a> The architecture of the MPS Interface</p>
<p>[missing figure]</p>
<p>Just behind <tt class="docutils literal"><span class="pre">mps.h</span></tt> is the file <tt class="docutils literal"><span class="pre">mpsi.c</span></tt>, the &#8220;MPS interface
layer&#8221; which does the job of converting types and checking parameters
before calling through to the MPS proper, using internal MPS methods.</p>
</div>
<div class="section" id="general-conventions">
<h2>12.4. General conventions<a class="headerlink" href="#general-conventions" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.interface.c.naming"></span><a class="mpstag reference internal" href="#design.mps.interface.c.naming">.naming:</a> The external interface names should adhere to the
documented interface conventions; these are found in
doc.mps.ref-man.if-conv(0).naming. They are paraphrased/recreated
here.</p>
<p><span class="target" id="design.mps.interface.c.naming.unixy"></span><a class="mpstag reference internal" href="#design.mps.interface.c.naming.unixy">.naming.unixy:</a> The external interface does not follow the same
naming conventions as the internal code. The interface is designed to
resemble a more conventional C, Unix, or Posix naming convention.</p>
<p><span class="target" id="design.mps.interface.c.naming.case"></span><a class="mpstag reference internal" href="#design.mps.interface.c.naming.case">.naming.case:</a> Identifiers are in lower case, except
non-function-like macros, which are in upper case.</p>
<p><span class="target" id="design.mps.interface.c.naming.global"></span><a class="mpstag reference internal" href="#design.mps.interface.c.naming.global">.naming.global:</a> All publicised identifiers are
prefixed <tt class="docutils literal"><span class="pre">mps_</span></tt> or <tt class="xref c c-macro docutils literal"><span class="pre">MPS_</span></tt>.</p>
<p><span class="target" id="design.mps.interface.c.naming.all"></span><a class="mpstag reference internal" href="#design.mps.interface.c.naming.all">.naming.all:</a> All identifiers defined by the MPS
should begin <tt class="docutils literal"><span class="pre">mps_</span></tt> or <tt class="xref c c-macro docutils literal"><span class="pre">MPS_</span></tt> or <tt class="docutils literal"><span class="pre">_mps_</span></tt>.</p>
<p><span class="target" id="design.mps.interface.c.naming.type"></span><a class="mpstag reference internal" href="#design.mps.interface.c.naming.type">.naming.type:</a> Types are suffixed <tt class="docutils literal"><span class="pre">_t</span></tt>.</p>
<p><span class="target" id="design.mps.interface.c.naming.struct"></span><a class="mpstag reference internal" href="#design.mps.interface.c.naming.struct">.naming.struct:</a> Structure types and tags are suffixed <tt class="docutils literal"><span class="pre">_s</span></tt>.</p>
<p><span class="target" id="design.mps.interface.c.naming.union"></span><a class="mpstag reference internal" href="#design.mps.interface.c.naming.union">.naming.union:</a> Unions types and tags are suffixed <tt class="docutils literal"><span class="pre">_u</span></tt>.</p>
<p><span class="target" id="design.mps.interface.c.naming.scope"></span><a class="mpstag reference internal" href="#design.mps.interface.c.naming.scope">.naming.scope:</a> The naming conventions apply to all identifiers (see
ISO C §6.1.2); this includes names of functions, variables, types
(through typedef), structure and union tags, enumeration members,
structure and union members, macros, macro parameters, labels.</p>
<p><span class="target" id="design.mps.interface.c.naming.scope.labels"></span><a class="mpstag reference internal" href="#design.mps.interface.c.naming.scope.labels">.naming.scope.labels:</a> labels (for <tt class="docutils literal"><span class="pre">goto</span></tt> statements) should be
rare, only in special block macros and probably not even then.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">This principle is not adhered to in the source code, which uses
<tt class="docutils literal"><span class="pre">goto</span></tt> for handling error cases. Gareth Rees, 2013-05-27.</p>
</div>
<p><span class="target" id="design.mps.interface.c.naming.scope.other"></span><a class="mpstag reference internal" href="#design.mps.interface.c.naming.scope.other">.naming.scope.other:</a> The naming convention would also extend to
enumeration types and parameters in functions prototypes but both of
those are prohibited from having names in an interface file.</p>
<p><span class="target" id="design.mps.interface.c.type.gen"></span><a class="mpstag reference internal" href="#design.mps.interface.c.type.gen">.type.gen:</a> The interface defines memory addresses as <tt class="docutils literal"><span class="pre">void&nbsp;*</span></tt> and
sizes as <tt class="docutils literal"><span class="pre">size_t</span></tt> for compatibility with standard C (in particular,
with <tt class="xref c c-func docutils literal"><span class="pre">malloc()</span></tt>). These types must be binary compatible with the
internal types <a class="reference internal" href="type.html#Addr" title="Addr"><tt class="xref c c-type docutils literal"><span class="pre">Addr</span></tt></a> and <a class="reference internal" href="type.html#Size" title="Size"><tt class="xref c c-type docutils literal"><span class="pre">Size</span></tt></a> respectively. Note that this
restricts the definitions of the internal types <a class="reference internal" href="type.html#Addr" title="Addr"><tt class="xref c c-type docutils literal"><span class="pre">Addr</span></tt></a> and <a class="reference internal" href="type.html#Size" title="Size"><tt class="xref c c-type docutils literal"><span class="pre">Size</span></tt></a>
when the MPS is interfaced with C, but does not restrict the MPS in
general.</p>
<p><span class="target" id="design.mps.interface.c.type.opaque"></span><a class="mpstag reference internal" href="#design.mps.interface.c.type.opaque">.type.opaque:</a> Opaque types are defined as pointers to structures
which are never defined. These types are cast to the corresponding
internal types in <tt class="docutils literal"><span class="pre">mpsi.c</span></tt>.</p>
<p><span class="target" id="design.mps.interface.c.type.trans"></span><a class="mpstag reference internal" href="#design.mps.interface.c.type.trans">.type.trans:</a> Some transparent structures are defined. The client is
expected to read these, or poke about in them, under restrictions
which should be documented. The most important is probably the
allocation point (<a class="reference internal" href="../topic/allocation.html#mps_ap_s" title="mps_ap_s"><tt class="xref c c-type docutils literal"><span class="pre">mps_ap_s</span></tt></a>) which is part of allocation buffers.
The transparent structures must be binary compatible with
corresponding internal structures. For example, the fields of
<a class="reference internal" href="../topic/allocation.html#mps_ap_s" title="mps_ap_s"><tt class="xref c c-type docutils literal"><span class="pre">mps_ap_s</span></tt></a> must correspond with <tt class="xref c c-type docutils literal"><span class="pre">APStruct</span></tt> internally. This is
checked by <tt class="docutils literal"><span class="pre">mpsi.c</span></tt> in <tt class="xref c c-func docutils literal"><span class="pre">mps_check()</span></tt>.</p>
<p><span class="target" id="design.mps.interface.c.type.pseudo"></span><a class="mpstag reference internal" href="#design.mps.interface.c.type.pseudo">.type.pseudo:</a> Some pseudo-opaque structures are defined. These only
exist so that code can be inlined using macros. The client code
shouldn&#8217;t mess with them. The most important case of this is the scan
state (<tt class="xref c c-type docutils literal"><span class="pre">mps_ss_s</span></tt>) which is accessed by the in-line scanning macros,
<tt class="docutils literal"><span class="pre">MPS_SCAN_*</span></tt> and <tt class="docutils literal"><span class="pre">MPS_FIX*</span></tt>.</p>
<p><span class="target" id="design.mps.interface.c.type.enum"></span><a class="mpstag reference internal" href="#design.mps.interface.c.type.enum">.type.enum:</a> There should be no enumeration types in the interface.
Note that enum specifiers (to declare integer constants) are fine as
long as no type is declared. See guide.impl.c.misc.enum.type.</p>
<p><span class="target" id="design.mps.interface.c.type.fun"></span><a class="mpstag reference internal" href="#design.mps.interface.c.type.fun">.type.fun:</a> Whenever function types or derived function types (such
as pointer to function) are declared a prototype should be used and
the parameters to the function should not be named. This includes the
case where you are declaring the prototype for an interface function.</p>
<p><span class="target" id="design.mps.interface.c.type.fun.example"></span><a class="mpstag reference internal" href="#design.mps.interface.c.type.fun.example">.type.fun.example:</a> So use:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">mps_res_t</span> <span class="nf">mps_alloc</span><span class="p">(</span><span class="kt">mps_addr_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">mps_pool_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
<p>rather than:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">mps_res_t</span> <span class="nf">mps_alloc</span><span class="p">(</span><span class="kt">mps_addr_t</span> <span class="o">*</span><span class="n">addr_return</span><span class="p">,</span> <span class="kt">mps_pool_t</span> <span class="n">pool</span> <span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
<p>and:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="nf">mps_addr_t</span> <span class="p">(</span><span class="o">*</span><span class="kt">mps_fmt_class_t</span><span class="p">)(</span><span class="kt">mps_addr_t</span><span class="p">);</span>
</pre></div>
</div>
<p>rather than:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="nf">mps_addr_t</span> <span class="p">(</span><span class="o">*</span><span class="kt">mps_fmt_class_t</span><span class="p">)(</span><span class="kt">mps_addr_t</span> <span class="n">object</span><span class="p">);</span>
</pre></div>
</div>
<p>See guide.impl.c.misc.prototype.parameters.</p>
</div>
<div class="section" id="checking">
<h2>12.5. Checking<a class="headerlink" href="#checking" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.interface.c.check.space"></span><a class="mpstag reference internal" href="#design.mps.interface.c.check.space">.check.space:</a> When the arena needs to be recovered from a parameter
it is check using <tt class="docutils literal"><span class="pre">AVERT(Foo,</span> <span class="pre">foo)</span></tt> before any attempt to call
<tt class="docutils literal"><span class="pre">FooArena(foo)</span></tt>. The macro <tt class="xref c c-func docutils literal"><span class="pre">AVERT()</span></tt> in impl.h.assert performs
simple thread-safe checking of <tt class="docutils literal"><span class="pre">foo</span></tt>, so it can be called outside of
<tt class="xref c c-func docutils literal"><span class="pre">ArenaEnter()</span></tt> and <tt class="xref c c-func docutils literal"><span class="pre">ArenaLeave()</span></tt>.</p>
<p><span class="target" id="design.mps.interface.c.check.types"></span><a class="mpstag reference internal" href="#design.mps.interface.c.check.types">.check.types:</a> We use definitions of types in both our external
interface and our internal code, and we want to make sure that they
are compatible. (The external interface changes less often and hides
more information.) At first, we were just checking their sizes, which
wasn&#8217;t very good, but I&#8217;ve come up with some macros which check the
assignment compatibility of the types too. This is a sufficiently
useful trick that I thought I&#8217;d send it round. It may be useful in
other places where types and structures need to be checked for
compatibility at compile time.</p>
<p>These macros don&#8217;t generate warnings on the compilers I&#8217;ve tried.</p>
<dl class="function">
<dt id="COMPATLVALUE">
<tt class="descname">COMPATLVALUE</tt><big>(</big>lvalue1, lvalue2<big>)</big><a class="headerlink" href="#COMPATLVALUE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>This macro checks the assignment compatibility of two lvalues. It uses
<tt class="xref c c-func docutils literal"><span class="pre">sizeof()</span></tt> to ensure that the assignments have no effect.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define COMPATLVALUE(lv1, lv2) \</span>
<span class="cp">  ((void)sizeof((lv1) = (lv2)), (void)sizeof((lv2) = (lv1)), TRUE)</span>
</pre></div>
</div>
<dl class="function">
<dt id="COMPATTYPE">
<tt class="descname">COMPATTYPE</tt><big>(</big>type1, type2<big>)</big><a class="headerlink" href="#COMPATTYPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>This macro checks that two types are assignment-compatible and equal
in size. The hack here is that it generates an lvalue for each type by
casting zero to a pointer to the type. The use of <tt class="xref c c-func docutils literal"><span class="pre">sizeof()</span></tt> avoids
the undefined behaviour that would otherwise result from dereferencing
a null pointer.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define COMPATTYPE(t1, t2) \</span>
<span class="cp">  (sizeof(t1) == sizeof(t2) &amp;&amp; \</span>
<span class="cp">   COMPATLVALUE(*((t1 *)0), *((t2 *)0)))</span>
</pre></div>
</div>
<dl class="function">
<dt id="COMPATFIELDAPPROX">
<tt class="descname">COMPATFIELDAPPROX</tt><big>(</big>structure1, field1, structure2, field2<big>)</big><a class="headerlink" href="#COMPATFIELDAPPROX" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>This macro checks that the offset and size of two fields in two
structure types are the same.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define COMPATFIELDAPPROX(s1, f1, s2, f2) \</span>
<span class="cp">  (sizeof(((s1 *)0)-&gt;f1) == sizeof(((s2 *)0)-&gt;f2) &amp;&amp; \</span>
<span class="cp">   offsetof(s1, f1) == offsetof(s2, f2))</span>
</pre></div>
</div>
<dl class="function">
<dt id="COMPATFIELD">
<tt class="descname">COMPATFIELD</tt><big>(</big>structure1, field1, structure2, field2<big>)</big><a class="headerlink" href="#COMPATFIELD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>This macro checks the offset, size, and assignment-compatibility of
two fields in two structure types.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define COMPATFIELD(s1, f1, s2, f2) \</span>
<span class="cp">  (COMPATFIELDAPPROX(s1, f1, s2, f2) &amp;&amp; \</span>
<span class="cp">   COMPATLVALUE(((s1 *)0)-&gt;f1, ((s2 *)0)-&gt;f2))</span>
</pre></div>
</div>
</div>
<div class="section" id="binary-compatibility-issues">
<h2>12.6. Binary compatibility issues<a class="headerlink" href="#binary-compatibility-issues" title="Permalink to this headline">¶</a></h2>
<p>As in, &#8220;Enumeration types are not allowed&#8221; (see
mail.richard.1995-09-08.09-28).</p>
<p>There are two main aspects to run-time compatibility: binary interface
and protocol. The binary interface is all the information needed to
correctly use the library, and includes external symbol linkage,
calling conventions, type representation compatibility, structure
layouts, etc. The protocol is how the library is actually used by the
client code &#8211; whether this is called before that &#8211; and determines
the semantic correctness of the client with respect to the library.</p>
<p>The binary interface is determined completely by the header file and
the target. The header file specifies the external names and the
types, and the target platform specifies calling conventions and type
representation. There is therefore a many-to-one mapping between the
header file version and the binary interface.</p>
<p>The protocol is determined by the implementation of the library.</p>
</div>
<div class="section" id="constraints">
<h2>12.7. Constraints<a class="headerlink" href="#constraints" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.interface.c.cons"></span><a class="mpstag reference internal" href="#design.mps.interface.c.cons">.cons:</a> The MPS C Interface constrains the MPS in order to provide
useful memory management services to a C or C++ program.</p>
<p><span class="target" id="design.mps.interface.c.cons.addr"></span><a class="mpstag reference internal" href="#design.mps.interface.c.cons.addr">.cons.addr:</a> The interface constrains the MPS address type, Addr
(design.mps.type.addr), to being the same as C&#8217;s generic pointer type,
<tt class="docutils literal"><span class="pre">void&nbsp;*</span></tt>, so that the MPS can manage C objects in the natural way.</p>
<p><span class="target" id="design.mps.interface.c.pun.addr"></span><a class="mpstag reference internal" href="#design.mps.interface.c.pun.addr">.pun.addr:</a> We pun the type of <a class="reference internal" href="../topic/interface.html#mps_addr_t" title="mps_addr_t"><tt class="xref c c-type docutils literal"><span class="pre">mps_addr_t</span></tt></a> (which is <tt class="docutils literal"><span class="pre">void&nbsp;*</span></tt>)
into <a class="reference internal" href="type.html#Addr" title="Addr"><tt class="xref c c-type docutils literal"><span class="pre">Addr</span></tt></a> (an incomplete type, see design.mps.type.addr). This
happens in the call to the scan state&#8217;s fix function, for example.</p>
<p><span class="target" id="design.mps.interface.c.cons.size"></span><a class="mpstag reference internal" href="#design.mps.interface.c.cons.size">.cons.size:</a> The interface constrains the MPS size type, <a class="reference internal" href="type.html#Size" title="Size"><tt class="xref c c-type docutils literal"><span class="pre">Size</span></tt></a>
(design.mps.type.size), to being the same as C&#8217;s size type,
<tt class="docutils literal"><span class="pre">size_t</span></tt>, so that the MPS can manage C objects in the natural way.</p>
<p><span class="target" id="design.mps.interface.c.pun.size"></span><a class="mpstag reference internal" href="#design.mps.interface.c.pun.size">.pun.size:</a> We pun the type of <tt class="docutils literal"><span class="pre">size_t</span></tt> in mps.h into <a class="reference internal" href="type.html#Size" title="Size"><tt class="xref c c-type docutils literal"><span class="pre">Size</span></tt></a> in
the MPM, as an argument to the format methods. We assume this works.</p>
<p><span class="target" id="design.mps.interface.c.cons.word"></span><a class="mpstag reference internal" href="#design.mps.interface.c.cons.word">.cons.word:</a> The MPS assumes that <a class="reference internal" href="type.html#Word" title="Word"><tt class="xref c c-type docutils literal"><span class="pre">Word</span></tt></a> (design.mps.type.word)
and <a class="reference internal" href="type.html#Addr" title="Addr"><tt class="xref c c-type docutils literal"><span class="pre">Addr</span></tt></a> (design.mps.type.addr) are the same size, and the
interface constrains <a class="reference internal" href="type.html#Word" title="Word"><tt class="xref c c-type docutils literal"><span class="pre">Word</span></tt></a> to being the same size as C&#8217;s generic
pointer type, <tt class="docutils literal"><span class="pre">void&nbsp;*</span></tt>.</p>
</div>
<div class="section" id="notes">
<h2>12.8. Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h2>
<p>The file <tt class="docutils literal"><span class="pre">mpstd.h</span></tt> is the MPS target detection header. It decodes
preprocessor symbols which are predefined by build environments in
order to determine the target platform, and then defines uniform
symbols, such as <a class="reference internal" href="../topic/platform.html#MPS_ARCH_I3" title="MPS_ARCH_I3"><tt class="xref c c-macro docutils literal"><span class="pre">MPS_ARCH_I3</span></tt></a>, for use internally by the MPS.</p>
<p>There is a design document for the mps interface,
design.mps.interface, but it was written before we had the idea of
having a C interface layer. It is quite relevant, though, and could be
updated. We should use it during the review.</p>
<p>All exported identifiers and file names should begin with <tt class="docutils literal"><span class="pre">mps_</span></tt> or
<tt class="xref c c-macro docutils literal"><span class="pre">MPS_</span></tt> so that they don&#8217;t clash with other systems.</p>
<p>We should probably have a specialized set of rules and a special
checklist for this interface.</p>
<p><span class="target" id="design.mps.interface.c.fmt.extend"></span><a class="mpstag reference internal" href="#design.mps.interface.c.fmt.extend">.fmt.extend:</a> This paragraph should be an explanation of why
<tt class="docutils literal"><span class="pre">mps_fmt_A_t</span></tt> is so called. The underlying reason is future
extensibility.</p>
<p><span class="target" id="design.mps.interface.c.thread-safety"></span><a class="mpstag reference internal" href="#design.mps.interface.c.thread-safety">.thread-safety:</a> Most calls through this interface lock the space
and therefore make the MPM single-threaded. In order to do this they
must recover the space from their parameters. Methods such as
<tt class="xref c c-func docutils literal"><span class="pre">ThreadSpace()</span></tt> must therefore be callable when the space is <em>not</em>
locked. These methods are tagged with the tag of this note.</p>
<p><span class="target" id="design.mps.interface.c.lock-free"></span><a class="mpstag reference internal" href="#design.mps.interface.c.lock-free">.lock-free:</a> Certain functions inside the MPM are thread-safe and do
not need to be serialized by using locks. They are marked with the tag
of this note.</p>
<p><span class="target" id="design.mps.interface.c.form"></span><a class="mpstag reference internal" href="#design.mps.interface.c.form">.form:</a> Almost all functions in this implementation simply cast
their arguments to the equivalent internal types, and cast results
back to the external type, where necessary. Only exceptions are noted
in comments.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">12. C interface design</a><ul>
<li><a class="reference internal" href="#introduction">12.1. Introduction</a></li>
<li><a class="reference internal" href="#analysis">12.2. Analysis</a><ul>
<li><a class="reference internal" href="#goals">12.2.1. Goals</a></li>
<li><a class="reference internal" href="#requirements">12.2.2. Requirements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#architecture">12.3. Architecture</a></li>
<li><a class="reference internal" href="#general-conventions">12.4. General conventions</a></li>
<li><a class="reference internal" href="#checking">12.5. Checking</a></li>
<li><a class="reference internal" href="#binary-compatibility-issues">12.6. Binary compatibility issues</a></li>
<li><a class="reference internal" href="#constraints">12.7. Constraints</a></li>
<li><a class="reference internal" href="#notes">12.8. Notes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="fix.html"
                        title="previous chapter">11. The generic fix function</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="io.html"
                        title="next chapter">13. I/O subsystem</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="io.html" title="13. I/O subsystem"
             >next</a> |</li>
        <li class="right" >
          <a href="fix.html" title="11. The generic fix function"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" >Old design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>