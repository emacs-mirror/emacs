

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>40. Splay trees &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Old design" href="old.html" />
    <link rel="next" title="41. Stack scanner for Digital Unix on Alpha" href="sso1al.html" />
    <link rel="prev" title="39. Shield" href="shield.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="sso1al.html" title="41. Stack scanner for Digital Unix on Alpha"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="shield.html" title="39. Shield"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" accesskey="U">Old design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="splay-trees">
<span id="design-splay"></span><span id="index-0"></span><h1>40. Splay trees<a class="headerlink" href="#splay-trees" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="design.mps.splay"></span><h2>40.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.splay.intro"></span><a class="mpstag reference internal" href="#design.mps.splay.intro">.intro:</a> This document explains the design of impl.c.splay, an
implementation of Splay Trees, including its interface and
implementation.</p>
<p><span class="target" id="design.mps.splay.readership"></span><a class="mpstag reference internal" href="#design.mps.splay.readership">.readership:</a> This document is intended for any MM developer.</p>
<p><span class="target" id="design.mps.splay.source"></span><a class="mpstag reference internal" href="#design.mps.splay.source">.source:</a> The primary sources for this design are paper.st85(0) and
paper.sleator96(0). Also as CBS is a client, design.mps.cbs. As
PoolMVFF is an indirect client, design.mps.poolmvff(1). Also, as
PoolMV2 is an (obsolescent?) indirect client, design.mps.poolmv2.</p>
<p><span class="target" id="design.mps.splay.background"></span><a class="mpstag reference internal" href="#design.mps.splay.background">.background:</a> The following background documents influence the design:
guide.impl.c.adt(0).</p>
</div>
<div class="section" id="overview">
<h2>40.2. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.splay.overview"></span><a class="mpstag reference internal" href="#design.mps.splay.overview">.overview:</a> Splay trees are a form of binary tree where each access
brings the accessed element (or the nearest element) to the root of
the tree. The restructuring of the tree caused by the access gives
excellent amortised performance, as the splay tree adapts its shape to
usage patterns. Unused nodes have essentially no time overhead.</p>
</div>
<div class="section" id="definitions">
<h2>40.3. Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.splay.def.splay-tree"></span><a class="mpstag reference internal" href="#design.mps.splay.def.splay-tree">.def.splay-tree:</a> A &#8220;Splay Tree&#8221; is a self-adjusting binary tree as
described in paper.st85(0), paper.sleator96(0).</p>
<p><span class="target" id="design.mps.splay.def.node"></span><a class="mpstag reference internal" href="#design.mps.splay.def.node">.def.node:</a> A &#8220;node&#8221; is used in the typical datastructure sense to
mean an element of a tree (see also <a class="reference internal" href="#design.mps.splay.type.splay.node">.type.splay.node</a>).</p>
<p><span class="target" id="design.mps.splay.def.key"></span><a class="mpstag reference internal" href="#design.mps.splay.def.key">.def.key:</a> A &#8220;key&#8221; is a value associated with each node; the keys
are totally ordered by a client provided comparator.</p>
<p><span class="target" id="design.mps.splay.def.comparator"></span><a class="mpstag reference internal" href="#design.mps.splay.def.comparator">.def.comparator:</a> A &#8220;comparator&#8221; is a function that compares keys to
determine their ordering (see also <a class="reference internal" href="#design.mps.splay.type.splay.compare.method">.type.splay.compare.method</a>).</p>
<p><span class="target" id="design.mps.splay.def.successor"></span><a class="mpstag reference internal" href="#design.mps.splay.def.successor">.def.successor:</a> Node <em>N1</em> is the &#8220;successor&#8221; of node <em>N2</em> if <em>N1</em>
and <em>N2</em> are both in the same tree, and the key of <em>N1</em> immediately
follows the key of <em>N2</em> in the ordering of all keys for the tree.</p>
<p><span class="target" id="design.mps.splay.def.left-child"></span><a class="mpstag reference internal" href="#design.mps.splay.def.left-child">.def.left-child:</a> Each node <em>N</em> contains a &#8220;left child&#8221;, which is a
(possibly empty) sub-tree of nodes. The key of <em>N</em> is ordered after
the keys of all nodes in this sub-tree.</p>
<p><span class="target" id="design.mps.splay.def.right-child"></span><a class="mpstag reference internal" href="#design.mps.splay.def.right-child">.def.right-child:</a> Each node <em>N</em> contains a &#8220;right child&#8221;, which is
a (possibly empty) sub-tree of nodes. The key of <em>N</em> is ordered before
the keys of all nodes in this sub-tree.</p>
<p><span class="target" id="design.mps.splay.def.neighbour"></span><a class="mpstag reference internal" href="#design.mps.splay.def.neighbour">.def.neighbour:</a> A node <em>N</em> which has key <em>Kn</em> is a &#8220;neighbour&#8221; of a
key <em>K</em> if either <em>Kn</em> is the first key in the total order which
compares greater than <em>K</em> or if <em>Kn</em> is the last key in the total
order which compares less than <em>K</em>.</p>
<p><span class="target" id="design.mps.splay.def.first"></span><a class="mpstag reference internal" href="#design.mps.splay.def.first">.def.first:</a> A node is the &#8220;first&#8221; node in a set of nodes if its key
compares less than the keys of all other nodes in the set.</p>
<p><span class="target" id="design.mps.splay.def.last"></span><a class="mpstag reference internal" href="#design.mps.splay.def.last">.def.last:</a> A node is the &#8220;last&#8221; node in a set of nodes if its key
compares greater than the keys of all other nodes in the set.</p>
<p><span class="target" id="design.mps.splay.def.client-property"></span><a class="mpstag reference internal" href="#design.mps.splay.def.client-property">.def.client-property:</a> A &#8220;client property&#8221; is a value that the
client may associate with each node in addition to the key (a block
size, for example). This splay tree implementation provides support
for efficiently finding the first or last nodes with suitably large
client property values. See also <a class="reference internal" href="#design.mps.splay.prop">.prop</a> below.</p>
</div>
<div class="section" id="requirements">
<h2>40.4. Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.splay.req"></span><a class="mpstag reference internal" href="#design.mps.splay.req">.req:</a> These requirements are drawn from those implied by
design.mps.poolmv2, design.mps.poolmvff(1), design.mps.cbs(2) and
general inferred MPS requirements.</p>
<p><span class="target" id="design.mps.splay.req.order"></span><a class="mpstag reference internal" href="#design.mps.splay.req.order">.req.order:</a> Must maintain a set of abstract keys which is totally
ordered for a comparator.</p>
<p><span class="target" id="design.mps.splay.req.tree"></span><a class="mpstag reference internal" href="#design.mps.splay.req.tree">.req.tree:</a> The keys must be associated with nodes arranged in a
Splay Tree.</p>
<p><span class="target" id="design.mps.splay.req.splay"></span><a class="mpstag reference internal" href="#design.mps.splay.req.splay">.req.splay:</a> Common operations must balance the tree by splaying it,
to achieve low amortized cost (see paper.st85(0)).</p>
<p><span class="target" id="design.mps.splay.req.add"></span><a class="mpstag reference internal" href="#design.mps.splay.req.add">.req.add:</a> Must be able to add new members. This is a common
operation.</p>
<p><span class="target" id="design.mps.splay.req.remove"></span><a class="mpstag reference internal" href="#design.mps.splay.req.remove">.req.remove:</a> Must be able to remove members. This is a common
operation.</p>
<p><span class="target" id="design.mps.splay.req.locate"></span><a class="mpstag reference internal" href="#design.mps.splay.req.locate">.req.locate:</a> Must be able to locate a member, given a key. This is
a common operation.</p>
<p><span class="target" id="design.mps.splay.req.neighbours"></span><a class="mpstag reference internal" href="#design.mps.splay.req.neighbours">.req.neighbours:</a> Must be able to locate the neighbouring members
(in order) of a non-member, given a key (see <a class="reference internal" href="#design.mps.splay.def.neighbour">.def.neighbour</a>). This
is a common operation.</p>
<p><span class="target" id="design.mps.splay.req.iterate"></span><a class="mpstag reference internal" href="#design.mps.splay.req.iterate">.req.iterate:</a> Must be able to iterate over all members in order
with reasonable efficiency.</p>
<p><span class="target" id="design.mps.splay.req.protocol"></span><a class="mpstag reference internal" href="#design.mps.splay.req.protocol">.req.protocol:</a> Must support detection of protocol violations.</p>
<p><span class="target" id="design.mps.splay.req.debug"></span><a class="mpstag reference internal" href="#design.mps.splay.req.debug">.req.debug:</a> Must support debugging of clients.</p>
<p><span class="target" id="design.mps.splay.req.stack"></span><a class="mpstag reference internal" href="#design.mps.splay.req.stack">.req.stack:</a> Must do all non-debugging operations with stack usage
bounded by a constant size.</p>
<p><span class="target" id="design.mps.splay.req.adapt"></span><a class="mpstag reference internal" href="#design.mps.splay.req.adapt">.req.adapt:</a> Must adapt to regularities in usage pattern, for better
performance.</p>
<p><span class="target" id="design.mps.splay.req.property"></span><a class="mpstag reference internal" href="#design.mps.splay.req.property">.req.property:</a> Must permit a client to associate a client property
(such as a size) with each node in the tree.</p>
<p><span class="target" id="design.mps.splay.req.property.change"></span><a class="mpstag reference internal" href="#design.mps.splay.req.property.change">.req.property.change:</a> Must permit a client to dynamically reassign
client properties to nodes in the tree. This is a common operation.</p>
<p><span class="target" id="design.mps.splay.req.property.find"></span><a class="mpstag reference internal" href="#design.mps.splay.req.property.find">.req.property.find:</a> Must support rapid finding of the first and
last nodes which have a suitably large value for their client
property. This is a common operation.</p>
<p><span class="target" id="design.mps.splay.req.root"></span><a class="mpstag reference internal" href="#design.mps.splay.req.root">.req.root:</a> Must be able to find the root of a splay tree (if one
exists).</p>
</div>
<div class="section" id="external-types">
<h2>40.5. External types<a class="headerlink" href="#external-types" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="SplayTreeStruct">
struct <a class="reference internal" href="#SplayTreeStruct" title="SplayTreeStruct">SplayTreeStruct</a> <tt class="descname">SplayTreeStruct</tt><a class="headerlink" href="#SplayTreeStruct" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="SplayTree">
struct <a class="reference internal" href="#SplayTreeStruct" title="SplayTreeStruct">SplayTreeStruct</a> *<tt class="descname">SplayTree</tt><a class="headerlink" href="#SplayTree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.type.splay.tree"></span><a class="mpstag reference internal" href="#design.mps.splay.type.splay.tree">.type.splay.tree:</a> <a class="reference internal" href="#SplayTree" title="SplayTree"><tt class="xref c c-type docutils literal"><span class="pre">SplayTree</span></tt></a> is the type of the main object at
the root of the splay tree. It is intended that the
<a class="reference internal" href="#SplayTreeStruct" title="SplayTreeStruct"><tt class="xref c c-type docutils literal"><span class="pre">SplayTreeStruct</span></tt></a> can be embedded in another structure (see
<a class="reference internal" href="#design.mps.splay.usage.client-tree">.usage.client-tree</a> for an example). No convenience functions are
provided for allocation or deallocation.</p>
<dl class="type">
<dt id="SplayNodeStruct">
struct <a class="reference internal" href="#SplayNodeStruct" title="SplayNodeStruct">SplayNodeStruct</a> <tt class="descname">SplayNodeStruct</tt><a class="headerlink" href="#SplayNodeStruct" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="SplayNode">
struct <a class="reference internal" href="#SplayNodeStruct" title="SplayNodeStruct">SplayNodeStruct</a> *<tt class="descname">SplayNode</tt><a class="headerlink" href="#SplayNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.type.splay.node"></span><a class="mpstag reference internal" href="#design.mps.splay.type.splay.node">.type.splay.node:</a> <a class="reference internal" href="#SplayNode" title="SplayNode"><tt class="xref c c-type docutils literal"><span class="pre">SplayNode</span></tt></a> is the type of a node of the splay
tree. <a class="reference internal" href="#SplayNodeStruct" title="SplayNodeStruct"><tt class="xref c c-type docutils literal"><span class="pre">SplayNodeStruct</span></tt></a> contains no fields to store the key
associated with the node, or the client property. Again, it is
intended that the <a class="reference internal" href="#SplayNodeStruct" title="SplayNodeStruct"><tt class="xref c c-type docutils literal"><span class="pre">SplayNodeStruct</span></tt></a> can be embedded in another
structure, and that this is how the association will be made (see
<a class="reference internal" href="#design.mps.splay.usage.client-node">.usage.client-node</a> for an example). No convenience functions are
provided for allocation or deallocation.</p>
<dl class="type">
<dt id="SplayCompareMethod">
<a class="reference internal" href="type.html#Compare" title="Compare">Compare</a> <tt class="descname">(*SplayCompareMethod)</tt><big>(</big>void<em>&nbsp;*key</em>, <a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;node</em><big>)</big><a class="headerlink" href="#SplayCompareMethod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.type.splay.compare.method"></span><a class="mpstag reference internal" href="#design.mps.splay.type.splay.compare.method">.type.splay.compare.method:</a> A function of type
<a class="reference internal" href="#SplayCompareMethod" title="SplayCompareMethod"><tt class="xref c c-type docutils literal"><span class="pre">SplayCompareMethod</span></tt></a> is required to compare <tt class="docutils literal"><span class="pre">key</span></tt> with the key the
client associates with that splay tree node <tt class="docutils literal"><span class="pre">node</span></tt>, and return the
appropriate Compare value (see <a class="reference internal" href="#design.mps.splay.usage.compare">.usage.compare</a> for an example). The
function compares a key with a node, rather than a pair of keys or
nodes as might seem more obvious. This is because the details of the
mapping between nodes and keys is left to the client (see
<a class="reference internal" href="#design.mps.splay.type.splay.node">.type.splay.node</a>), and the splaying operations compare keys with
nodes (see <a class="reference internal" href="#design.mps.splay.impl.splay">.impl.splay</a>).</p>
<dl class="type">
<dt id="SplayNodeDescribeMethod">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">(*SplayNodeDescribeMethod)</tt><big>(</big><a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;node</em>, <a class="reference internal" href="../topic/plinth.html#mps_lib_FILE" title="mps_lib_FILE">mps_lib_FILE</a><em>&nbsp;*stream</em><big>)</big><a class="headerlink" href="#SplayNodeDescribeMethod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.type.splay.node.describe.method"></span><a class="mpstag reference internal" href="#design.mps.splay.type.splay.node.describe.method">.type.splay.node.describe.method:</a> A function of type
<a class="reference internal" href="#SplayNodeDescribeMethod" title="SplayNodeDescribeMethod"><tt class="xref c c-type docutils literal"><span class="pre">SplayNodeDescribeMethod</span></tt></a> is required to write (via <a class="reference internal" href="writef.html#WriteF" title="WriteF"><tt class="xref c c-func docutils literal"><span class="pre">WriteF()</span></tt></a>) a
client-oriented representation of the splay node. The output should be
non-empty, short, and without return characters. This is provided for
debugging purposes only.</p>
<dl class="type">
<dt id="SplayTestNodeMethod">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">(*SplayTestNodeMethod)</tt><big>(</big><a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, <a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;node</em>, void<em>&nbsp;*closureP</em>, unsigned long<em>&nbsp;closureS</em><big>)</big><a class="headerlink" href="#SplayTestNodeMethod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.type.splay.test.node.method"></span><a class="mpstag reference internal" href="#design.mps.splay.type.splay.test.node.method">.type.splay.test.node.method:</a> A function of type
<a class="reference internal" href="#SplayTestNodeMethod" title="SplayTestNodeMethod"><tt class="xref c c-type docutils literal"><span class="pre">SplayTestNodeMethod</span></tt></a> required to determine whether the node itself
meets some client determined property (see <a class="reference internal" href="#design.mps.splay.prop">.prop</a> and
<a class="reference internal" href="#design.mps.splay.usage.test.node">.usage.test.node</a> for an example). Parameters <tt class="docutils literal"><span class="pre">closureP</span></tt> and
<tt class="docutils literal"><span class="pre">closureS</span></tt> describe the environment for the function (see
<a class="reference internal" href="#design.mps.splay.function.splay.find.first">.function.splay.find.first</a> and <a class="reference internal" href="#design.mps.splay.function.splay.find.last">.function.splay.find.last</a>).</p>
<dl class="type">
<dt id="SplayTestTreeMethod">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">(*SplayTestTreeMethod)</tt><big>(</big><a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, <a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;node</em>, void<em>&nbsp;*closureP</em>, unsigned long<em>&nbsp;closureS</em><big>)</big><a class="headerlink" href="#SplayTestTreeMethod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.type.splay.test.tree.method"></span><a class="mpstag reference internal" href="#design.mps.splay.type.splay.test.tree.method">.type.splay.test.tree.method:</a> A function of type
<a class="reference internal" href="#SplayTestTreeMethod" title="SplayTestTreeMethod"><tt class="xref c c-type docutils literal"><span class="pre">SplayTestTreeMethod</span></tt></a> is required to determine whether any of the
nodes in the sub-tree rooted at the given node meet some client
determined property (see <a class="reference internal" href="#design.mps.splay.prop">.prop</a> and <a class="reference internal" href="#design.mps.splay.usage.test.tree">.usage.test.tree</a> for an
example). In particular, it must be a precise (not conservative)
indication of whether there are any nodes in the sub-tree for which
the <tt class="docutils literal"><span class="pre">testNode</span></tt> method (see <a class="reference internal" href="#design.mps.splay.type.splay.test.node.method">.type.splay.test.node.method</a>) would
return <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt>. Parameters <tt class="docutils literal"><span class="pre">closureP</span></tt> and <tt class="docutils literal"><span class="pre">closureS</span></tt> describe the
environment for the function (see <a class="reference internal" href="#design.mps.splay.function.splay.find.first">.function.splay.find.first</a> and
<a class="reference internal" href="#design.mps.splay.function.splay.find.last">.function.splay.find.last</a>).</p>
<dl class="type">
<dt id="SplayUpdateNodeMethod">
void <tt class="descname">(*SplayUpdateNodeMethod)</tt><big>(</big><a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, <a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;node</em>, <a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;leftChild</em>, <a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;rightChild</em><big>)</big><a class="headerlink" href="#SplayUpdateNodeMethod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.type.splay.update.node.method"></span><a class="mpstag reference internal" href="#design.mps.splay.type.splay.update.node.method">.type.splay.update.node.method:</a> A function of type
<a class="reference internal" href="#SplayUpdateNodeMethod" title="SplayUpdateNodeMethod"><tt class="xref c c-type docutils literal"><span class="pre">SplayUpdateNodeMethod</span></tt></a> is required to update any client
datastructures associated with a node to maintain some client
determined property (see <a class="reference internal" href="#design.mps.splay.prop">.prop</a>) given that the children of the node
have changed. If the node does not have one or both children, then
<tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt> will be passed as the relevant parameter. (See
<a class="reference internal" href="#design.mps.splay.usage.callback">.usage.callback</a> for an example)</p>
</div>
<div class="section" id="external-functions">
<h2>40.6. External functions<a class="headerlink" href="#external-functions" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.splay.function.no-thread"></span><a class="mpstag reference internal" href="#design.mps.splay.function.no-thread">.function.no-thread:</a> The interface functions are not designed to be
either thread-safe or re-entrant. Clients of the interface are
responsible for synchronization, and for ensuring that client-provided
methods invoked by the splay module (<a class="reference internal" href="#design.mps.splay.type.splay.compare.method">.type.splay.compare.method</a>,
<a class="reference internal" href="#design.mps.splay.type.splay.test.node.method">.type.splay.test.node.method</a>, <a class="reference internal" href="#design.mps.splay.type.splay.test.tree.method">.type.splay.test.tree.method</a>,
<a class="reference internal" href="#design.mps.splay.type.splay.update.node.method">.type.splay.update.node.method</a>) do not call functions of the splay
module.</p>
<dl class="function">
<dt id="SplayTreeCheck">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">SplayTreeCheck</tt><big>(</big><a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em><big>)</big><a class="headerlink" href="#SplayTreeCheck" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.tree.check"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.tree.check">.function.splay.tree.check:</a> This is a check function for the
SplayTree type (see guide.impl.c.adt.method.check &amp;
design.mps.check(0)).</p>
<dl class="function">
<dt id="SplayNodeCheck">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">SplayNodeCheck</tt><big>(</big><a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;node</em><big>)</big><a class="headerlink" href="#SplayNodeCheck" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.node.check"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.node.check">.function.splay.node.check:</a> This is a check function for the
<a class="reference internal" href="#SplayNode" title="SplayNode"><tt class="xref c c-type docutils literal"><span class="pre">SplayNode</span></tt></a> type (see guide.impl.c.adt.method.check &amp;
design.mps.check(0)).</p>
<dl class="function">
<dt id="SplayTreeInit">
void <tt class="descname">SplayTreeInit</tt><big>(</big><a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, <a class="reference internal" href="#SplayCompareMethod" title="SplayCompareMethod">SplayCompareMethod</a><em>&nbsp;compare</em>, <a class="reference internal" href="#SplayUpdateNodeMethod" title="SplayUpdateNodeMethod">SplayUpdateNodeMethod</a><em>&nbsp;updateNode</em><big>)</big><a class="headerlink" href="#SplayTreeInit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.tree.init"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.tree.init">.function.splay.tree.init:</a> This function initialises a
<a class="reference internal" href="#SplayTree" title="SplayTree"><tt class="xref c c-type docutils literal"><span class="pre">SplayTree</span></tt></a> (see guide.impl.c.adt.method.init). It requires a
<tt class="docutils literal"><span class="pre">compare</span></tt> method that defines a total ordering on nodes (see
<a class="reference internal" href="#design.mps.splay.req.order">.req.order</a>); the effect of supplying a compare method that does not
implement a total ordering is undefined. It also requires an
<tt class="docutils literal"><span class="pre">updateNode</span></tt> method, which will be used to keep client properties up
to date when the tree structure changes; the value
<tt class="docutils literal"><span class="pre">SplayTrivUpdateNode</span></tt> may be used for this method if there is no
need to maintain client properties. (See <a class="reference internal" href="#design.mps.splay.usage.initialization">.usage.initialization</a> for
an example use).</p>
<dl class="function">
<dt id="SplayTreeFinish">
void <tt class="descname">SplayTreeFinish</tt><big>(</big><a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em><big>)</big><a class="headerlink" href="#SplayTreeFinish" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.tree.finish"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.tree.finish">.function.splay.tree.finish:</a> This function clears the fields of a
<a class="reference internal" href="#SplayTree" title="SplayTree"><tt class="xref c c-type docutils literal"><span class="pre">SplayTree</span></tt></a> (see guide.impl.c.adt.method.finish). Note that it does
not attempt to finish or deallocate any associated <a class="reference internal" href="#SplayNode" title="SplayNode"><tt class="xref c c-type docutils literal"><span class="pre">SplayNode</span></tt></a>
objects; clients wishing to destroy a non-empty <a class="reference internal" href="#SplayTree" title="SplayTree"><tt class="xref c c-type docutils literal"><span class="pre">SplayTree</span></tt></a> must
first explicitly descend the tree and call <a class="reference internal" href="#SplayNodeFinish" title="SplayNodeFinish"><tt class="xref c c-func docutils literal"><span class="pre">SplayNodeFinish()</span></tt></a> on
each node from the bottom up.</p>
<dl class="function">
<dt id="SplayNodeInit">
void <tt class="descname">SplayNodeInit</tt><big>(</big><a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;node</em><big>)</big><a class="headerlink" href="#SplayNodeInit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.node.init"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.node.init">.function.splay.node.init:</a> This function initialises a
<a class="reference internal" href="#SplayNode" title="SplayNode"><tt class="xref c c-type docutils literal"><span class="pre">SplayNode</span></tt></a> (see guide.impl.c.adt.method.init).</p>
<dl class="function">
<dt id="SplayNodeFinish">
void <tt class="descname">SplayNodeFinish</tt><big>(</big><a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;node</em><big>)</big><a class="headerlink" href="#SplayNodeFinish" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.node.finish"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.node.finish">.function.splay.node.finish:</a> This function clears the fields of a
<a class="reference internal" href="#SplayNode" title="SplayNode"><tt class="xref c c-type docutils literal"><span class="pre">SplayNode</span></tt></a> (see guide.impl.c.adt.method.finish). Note that it does
not attempt to finish or deallocate any referenced <a class="reference internal" href="#SplayNode" title="SplayNode"><tt class="xref c c-type docutils literal"><span class="pre">SplayNode</span></tt></a>
objects (see.function.splay.tree.finish).</p>
<dl class="function">
<dt id="SplayRoot">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">SplayRoot</tt><big>(</big><a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;*nodeReturn</em>, <a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em><big>)</big><a class="headerlink" href="#SplayRoot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.root"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.root">.function.splay.root:</a> This function returns the root node of the
tree, if any (see <a class="reference internal" href="#design.mps.splay.req.root">.req.root</a>). If the tree is empty, <tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt> is
returned and <tt class="docutils literal"><span class="pre">*nodeReturn</span></tt> is not changed. Otherwise, <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt> is
returned and <tt class="docutils literal"><span class="pre">*nodeReturn</span></tt> is set to the root.</p>
<dl class="function">
<dt id="SplayTreeInsert">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">SplayTreeInsert</tt><big>(</big><a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, <a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;node</em>, void<em>&nbsp;*key</em><big>)</big><a class="headerlink" href="#SplayTreeInsert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.tree.insert"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.tree.insert">.function.splay.tree.insert:</a> This function is used to insert into a
splay tree a new node which is associated with the supplied key (see
<a class="reference internal" href="#design.mps.splay.req.add">.req.add</a>). It first splays the tree at the key. If an attempt is
made to insert a node that compares <tt class="docutils literal"><span class="pre">CompareEQUAL</span></tt> to an existing
node in the tree, then <tt class="docutils literal"><span class="pre">ResFAIL</span></tt> will be returned and the node will
not be inserted. (See <a class="reference internal" href="#design.mps.splay.usage.insert">.usage.insert</a> for an example use).</p>
<dl class="function">
<dt id="SplayTreeDelete">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">SplayTreeDelete</tt><big>(</big><a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, <a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;node</em>, void<em>&nbsp;*key</em><big>)</big><a class="headerlink" href="#SplayTreeDelete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.tree.delete"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.tree.delete">.function.splay.tree.delete:</a> This function is used to delete from a
splay tree a node which is associated with the supplied key (see
<a class="reference internal" href="#design.mps.splay.req.remove">.req.remove</a>). If the tree does not contain the given node, or the
given node does not compare <tt class="docutils literal"><span class="pre">CompareEQUAL</span></tt> with the given key, then
<tt class="docutils literal"><span class="pre">ResFAIL</span></tt> will be returned, and the node will not be deleted. The
function first splays the tree at the given key. (See <a class="reference internal" href="#design.mps.splay.usage.delete">.usage.delete</a>
for an example use).</p>
<dl class="function">
<dt id="SplayTreeSearch">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">SplayTreeSearch</tt><big>(</big><a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;*nodeReturn</em>, <a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, void<em>&nbsp;*key</em><big>)</big><a class="headerlink" href="#SplayTreeSearch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.tree.search"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.tree.search">.function.splay.tree.search:</a> This function searches the splay tree
for a node that compares <tt class="docutils literal"><span class="pre">CompareEQUAL</span></tt> to the given key (see
<a class="reference internal" href="#design.mps.splay.req.locate">.req.locate</a>). It splays the tree at the key. It returns <tt class="docutils literal"><span class="pre">ResFAIL</span></tt>
if there is no such node in the tree, otherwise <tt class="docutils literal"><span class="pre">*nodeReturn</span></tt> will
be set to the node.</p>
<dl class="function">
<dt id="SplayTreeNeighbours">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">SplayTreeNeighbours</tt><big>(</big><a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;*leftReturn</em>, <a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;*rightReturn</em>, <a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, void<em>&nbsp;*key</em><big>)</big><a class="headerlink" href="#SplayTreeNeighbours" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.tree.neighbours"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.tree.neighbours">.function.splay.tree.neighbours:</a> This function searches a splay
tree for the two nodes that are the neighbours of the given key (see
<a class="reference internal" href="#design.mps.splay.req.neighbours">.req.neighbours</a>). It splays the tree at the key. <tt class="docutils literal"><span class="pre">*leftReturn</span></tt>
will be the neighbour which compares less than the key if such a
neighbour exists; otherwise it will be <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt>. <tt class="docutils literal"><span class="pre">*rightReturn</span></tt> will
be the neighbour which compares greater than the key if such a
neighbour exists; otherwise it will be <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt>. The function returns
<tt class="docutils literal"><span class="pre">ResFAIL</span></tt> if any node in the tree compares <tt class="docutils literal"><span class="pre">CompareEQUAL</span></tt> with the
given key. (See <a class="reference internal" href="#design.mps.splay.usage.insert">.usage.insert</a> for an example use).</p>
<dl class="function">
<dt id="SplayTreeFirst">
<a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a> <tt class="descname">SplayTreeFirst</tt><big>(</big><a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, void<em>&nbsp;*zeroKey</em><big>)</big><a class="headerlink" href="#SplayTreeFirst" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.tree.first"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.tree.first">.function.splay.tree.first:</a> This function splays the tree at the
first node, and returns that node (see <a class="reference internal" href="#design.mps.splay.req.iterate">.req.iterate</a>). The supplied
key should compare <tt class="docutils literal"><span class="pre">CompareLESS</span></tt> with all nodes in the tree. It will
return <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt> if the tree has no nodes.</p>
<dl class="function">
<dt id="SplayTreeNext">
<a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a> <tt class="descname">SplayTreeNext</tt><big>(</big><a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, <a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;oldNode</em>, void<em>&nbsp;*oldKey</em><big>)</big><a class="headerlink" href="#SplayTreeNext" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.tree.next"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.tree.next">.function.splay.tree.next:</a> This function receives a node and key
and returns the successor node to that node (see <a class="reference internal" href="#design.mps.splay.req.iterate">.req.iterate</a>).
This function is intended for use in iteration when the received node
will be the current root of the tree, but is robust against being
interspersed with other splay operations (provided the old node still
exists). The supplied key must compare <tt class="docutils literal"><span class="pre">CompareEQUAL</span></tt> to the
supplied node. Note that use of this function rebalances the tree for
each node accessed. If many nodes are accessed as a result of multiple
uses, the resultant tree will be generally well balanced. But if the
tree was previously beneficially balanced for a small working set of
accesses, then this local optimization will be lost. (see
<a class="reference internal" href="#design.mps.splay.future.parent">.future.parent</a>).</p>
<dl class="function">
<dt id="SplayTreeDescribe">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">SplayTreeDescribe</tt><big>(</big><a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, <a class="reference internal" href="../topic/plinth.html#mps_lib_FILE" title="mps_lib_FILE">mps_lib_FILE</a><em>&nbsp;*stream</em>, <a class="reference internal" href="#SplayNodeDescribeMethod" title="SplayNodeDescribeMethod">SplayNodeDescribeMethod</a><em>&nbsp;nodeDescribe</em><big>)</big><a class="headerlink" href="#SplayTreeDescribe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.tree.describe"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.tree.describe">.function.splay.tree.describe:</a> This function prints (using
<tt class="docutils literal"><span class="pre">WriteF</span></tt>) to the stream a textual representation of the given splay
tree, using <tt class="docutils literal"><span class="pre">nodeDescribe</span></tt> to print client-oriented representations
of the nodes (see <a class="reference internal" href="#design.mps.splay.req.debug">.req.debug</a>).</p>
<dl class="function">
<dt id="SplayFindFirst">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">SplayFindFirst</tt><big>(</big><a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;*nodeReturn</em>, <a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, <a class="reference internal" href="#SplayTestNodeMethod" title="SplayTestNodeMethod">SplayTestNodeMethod</a><em>&nbsp;testNode</em>, <a class="reference internal" href="#SplayTestTreeMethod" title="SplayTestTreeMethod">SplayTestTreeMethod</a><em>&nbsp;testTree</em>, void<em>&nbsp;*closureP</em>, unsigned long<em>&nbsp;closureS</em><big>)</big><a class="headerlink" href="#SplayFindFirst" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.find.first"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.find.first">.function.splay.find.first:</a> <a class="reference internal" href="#SplayFindFirst" title="SplayFindFirst"><tt class="xref c c-func docutils literal"><span class="pre">SplayFindFirst()</span></tt></a> finds the first node
in the tree that satisfies some client property (as determined by the
<tt class="docutils literal"><span class="pre">testNode</span></tt> and <tt class="docutils literal"><span class="pre">testTree</span></tt> methods) (see <a class="reference internal" href="#design.mps.splay.req.property.find">.req.property.find</a>).
<tt class="docutils literal"><span class="pre">closureP</span></tt> and <tt class="docutils literal"><span class="pre">closureS</span></tt> are arbitrary values, and are passed to
the <tt class="docutils literal"><span class="pre">testNode</span></tt> and <tt class="docutils literal"><span class="pre">testTree</span></tt> methods which may use the values as
closure environments. If there is no satisfactory node, then <tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt>
is returned, otherwise <tt class="docutils literal"><span class="pre">*nodeReturn</span></tt> is set to the node. (See
<a class="reference internal" href="#design.mps.splay.usage.delete">.usage.delete</a> for an example use).</p>
<dl class="function">
<dt>
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">SplayFindFirst</tt><big>(</big><a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;*nodeReturn</em>, <a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, <a class="reference internal" href="#SplayTestNodeMethod" title="SplayTestNodeMethod">SplayTestNodeMethod</a><em>&nbsp;testNode</em>, <a class="reference internal" href="#SplayTestTreeMethod" title="SplayTestTreeMethod">SplayTestTreeMethod</a><em>&nbsp;testTree</em>, void<em>&nbsp;*closureP</em>, unsigned long<em>&nbsp;closureS</em><big>)</big></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.find.last"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.find.last">.function.splay.find.last:</a> <tt class="xref c c-func docutils literal"><span class="pre">SplayFindLast()</span></tt> finds the last node
in the tree that satisfies some client property (as determined by the
<tt class="docutils literal"><span class="pre">testNode</span></tt> and <tt class="docutils literal"><span class="pre">testTree</span></tt> methods) (see <a class="reference internal" href="#design.mps.splay.req.property.find">.req.property.find</a>).
<tt class="docutils literal"><span class="pre">closureP</span></tt> and <tt class="docutils literal"><span class="pre">closureS</span></tt> are arbitrary values, and are passed to
the <tt class="docutils literal"><span class="pre">testNode</span></tt> and <tt class="docutils literal"><span class="pre">testTree</span></tt> methods which may use the values as
closure environments. If there is no satisfactory node, then <tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt>
is returned, otherwise <tt class="docutils literal"><span class="pre">*nodeReturn</span></tt> is set to the node.</p>
<dl class="function">
<dt id="SplayNodeRefresh">
void <tt class="descname">SplayNodeRefresh</tt><big>(</big><a class="reference internal" href="#SplayTree" title="SplayTree">SplayTree</a><em>&nbsp;tree</em>, <a class="reference internal" href="#SplayNode" title="SplayNode">SplayNode</a><em>&nbsp;node</em>, void<em>&nbsp;*key</em><big>)</big><a class="headerlink" href="#SplayNodeRefresh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.splay.function.splay.node.refresh"></span><a class="mpstag reference internal" href="#design.mps.splay.function.splay.node.refresh">.function.splay.node.refresh:</a> <a class="reference internal" href="#SplayNodeRefresh" title="SplayNodeRefresh"><tt class="xref c c-func docutils literal"><span class="pre">SplayNodeRefresh()</span></tt></a> must be called
whenever the client property (see <a class="reference internal" href="#design.mps.splay.prop">.prop</a>) at a node changes (see
<a class="reference internal" href="#design.mps.splay.req.property.change">.req.property.change</a>). It will call the <tt class="docutils literal"><span class="pre">updateNode</span></tt> method on
the given node, and any other nodes that may require update. The
client key for the node must also be supplied; the function splays the
tree at this key. (See <a class="reference internal" href="#design.mps.splay.usage.insert">.usage.insert</a> for an example use).</p>
</div>
<div class="section" id="client-determined-properties">
<h2>40.7. Client-determined properties<a class="headerlink" href="#client-determined-properties" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.splay.prop"></span><a class="mpstag reference internal" href="#design.mps.splay.prop">.prop:</a> To support <a class="reference internal" href="#design.mps.splay.req.property.find">.req.property.find</a>, this splay tree
implementation provides additional features to permit clients to cache
maximum (or minimum) values of client properties for all the nodes in
a subtree. The splay tree implementation uses the cached values as
part of <tt class="docutils literal"><span class="pre">SplayFindFirst</span></tt> and <tt class="docutils literal"><span class="pre">SplayFindLast</span></tt> via the <tt class="docutils literal"><span class="pre">testNode</span></tt>
and <tt class="docutils literal"><span class="pre">testTree</span></tt> methods. The client is free to choose how to
represent the client property, and how to compute and store the cached
value.</p>
<p><span class="target" id="design.mps.splay.prop.update"></span><a class="mpstag reference internal" href="#design.mps.splay.prop.update">.prop.update:</a> The cached values depend upon the topology of the
tree, which may vary as a result of operations on the tree. The client
is given the opportunity to compute new cache values whenever
necessary, via the <tt class="docutils literal"><span class="pre">updateNode</span></tt> method (see
<a class="reference internal" href="#design.mps.splay.function.splay.tree.init">.function.splay.tree.init</a>). This happens whenever the tree is
restructured. The client may use the <tt class="docutils literal"><span class="pre">SplayNodeRefresh</span></tt> method to
indicate that the client attributes at a node have changed (see
<a class="reference internal" href="#design.mps.splay.req.property.change">.req.property.change</a>). A call to <tt class="docutils literal"><span class="pre">SplayNodeRefresh</span></tt> splays the
tree at the specified node, which may provoke calls to the
<tt class="docutils literal"><span class="pre">updateNode</span></tt> method as a result of the tree restructuring. The
<tt class="docutils literal"><span class="pre">updateNode</span></tt> method will also be called whenever a new splay node is
inserted into the tree.</p>
<p><span class="target" id="design.mps.splay.prop.example"></span><a class="mpstag reference internal" href="#design.mps.splay.prop.example">.prop.example:</a> For example, if implementing an address ordered tree
of free blocks using a splay tree, a client might choose to use the
base address of each block as the key for each node, and the size of
each block as the client property. The client can then maintain as a
cached value in each node the size of the largest block in the subtree
rooted at that node. This will permit a fast search for the first or
last block of at least a given size. See <a class="reference internal" href="#design.mps.splay.usage.callback">.usage.callback</a> for an
example <tt class="docutils literal"><span class="pre">updateNode</span></tt> method for such a client.</p>
<p><span class="target" id="design.mps.splay.prop.ops"></span><a class="mpstag reference internal" href="#design.mps.splay.prop.ops">.prop.ops:</a> The splay operations must cause client properties for
nodes to be updated in the following circumstances:- (see <a class="reference internal" href="#design.mps.splay.impl">.impl</a> for
details):</p>
<p><span class="target" id="design.mps.splay.prop.ops.rotate"></span><a class="mpstag reference internal" href="#design.mps.splay.prop.ops.rotate">.prop.ops.rotate:</a> rotate left, rotate right &#8211; We need to update
the value at the original root, and the new root, in that order.</p>
<p><span class="target" id="design.mps.splay.prop.ops.link"></span><a class="mpstag reference internal" href="#design.mps.splay.prop.ops.link">.prop.ops.link:</a> link left, link right &#8211; We know that the line of
right descent from the root of the left tree and the line of left
descent from the root of the right tree will both need to be updated.
This is performed at the assembly stage. (We could update these chains
every time we do a link left or link right instead, but this would be
less efficient)</p>
<p><span class="target" id="design.mps.splay.prop.ops.assemble"></span><a class="mpstag reference internal" href="#design.mps.splay.prop.ops.assemble">.prop.ops.assemble:</a> assemble &#8211; This operation also invalidates the
lines of right and left descent of the left and right trees
respectively which need to be updated (see below). It also invalidates
the root which must be updated last.</p>
<p><span class="target" id="design.mps.splay.prop.ops.assemble.reverse"></span><a class="mpstag reference internal" href="#design.mps.splay.prop.ops.assemble.reverse">.prop.ops.assemble.reverse:</a> To correct the chains of the left and
right trees without requiring stack or high complexity, we use a
judicious amount of pointer reversal.</p>
<p><span class="target" id="design.mps.splay.prop.ops.assemble.traverse"></span><a class="mpstag reference internal" href="#design.mps.splay.prop.ops.assemble.traverse">.prop.ops.assemble.traverse:</a> During the assembly, after the root&#8217;s
children have been transplanted, we correct the chains of the left and
right trees. For the left tree, we traverse the right child line,
reversing pointers, until we reach the node that was the last node
prior to the transplantation of the root&#8217;s children. Then we update
from that node back to the left tree&#8217;s root, restoring pointers.
Updating the right tree is the same, mutatis mutandis. (See
<a class="reference internal" href="#design.mps.splay.future.reverse">.future.reverse</a> for an alternative approach).</p>
</div>
<div class="section" id="usage">
<h2>40.8. Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.splay.usage"></span><a class="mpstag reference internal" href="#design.mps.splay.usage">.usage:</a> Here&#8217;s a simple example of a client which uses a splay tree
to implement an address ordered tree of free blocks. The significant
client usages of the splay tree interface might look as follows:-</p>
<p><span class="target" id="design.mps.splay.usage.client-tree"></span><a class="mpstag reference internal" href="#design.mps.splay.usage.client-tree">.usage.client-tree:</a> Tree structure to embed a <a class="reference internal" href="#SplayTree" title="SplayTree"><tt class="xref c c-type docutils literal"><span class="pre">SplayTree</span></tt></a> (see
<a class="reference internal" href="#design.mps.splay.type.splay.tree">.type.splay.tree</a>):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">FreeTreeStruct</span> <span class="p">{</span>
  <span class="n">SplayTreeStruct</span> <span class="n">splayTree</span><span class="p">;</span>  <span class="cm">/* Embedded splay tree */</span>
  <span class="cm">/* no obvious client fields for this simple example */</span>
<span class="p">}</span> <span class="n">FreeTreeStruct</span><span class="p">;</span>
</pre></div>
</div>
<p><span class="target" id="design.mps.splay.usage.client-node"></span><a class="mpstag reference internal" href="#design.mps.splay.usage.client-node">.usage.client-node:</a> Node structure to embed a SplayNode (see <a class="reference internal" href="#design.mps.splay.type.splay.node">.type.splay.node</a>):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">FreeBlockStruct</span> <span class="p">{</span>
  <span class="n">SplayNodeStruct</span> <span class="n">splayNode</span><span class="p">;</span> <span class="cm">/* embedded splay node */</span>
  <span class="n">Addr</span> <span class="n">base</span><span class="p">;</span>                 <span class="cm">/* base address of block is also the key */</span>
  <span class="n">Size</span> <span class="n">size</span><span class="p">;</span>                 <span class="cm">/* size of block is also the client property */</span>
  <span class="n">Size</span> <span class="n">maxSize</span><span class="p">;</span>              <span class="cm">/* cached value for maximum size in subtree */</span>
<span class="p">}</span> <span class="n">FreeBlockStruct</span><span class="p">;</span>
</pre></div>
</div>
<p><span class="target" id="design.mps.splay.usage.callback"></span><a class="mpstag reference internal" href="#design.mps.splay.usage.callback">.usage.callback:</a> updateNode callback method (see
<a class="reference internal" href="#design.mps.splay.type.splay.update.node.method">.type.splay.update.node.method</a>):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">FreeBlockUpdateNode</span><span class="p">(</span><span class="n">SplayTree</span> <span class="n">tree</span><span class="p">,</span> <span class="n">SplayNode</span> <span class="n">node</span><span class="p">,</span>
                         <span class="n">SplayNode</span> <span class="n">leftChild</span><span class="p">,</span> <span class="n">SplayNode</span> <span class="n">rightChild</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* Compute the maximum size of any block in this subtree. */</span>
  <span class="cm">/* The value to cache is the maximum of the size of this block, */</span>
  <span class="cm">/* the cached value for the left subtree (if any) and the cached */</span>
  <span class="cm">/* value of the right subtree (if any) */</span>

  <span class="n">FreeBlock</span> <span class="n">freeNode</span> <span class="o">=</span> <span class="n">FreeBlockOfSplayNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

  <span class="n">Size</span> <span class="n">maxSize</span> <span class="o">=</span> <span class="n">freeNode</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">leftChild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">FreeBlock</span> <span class="n">leftNode</span> <span class="o">=</span> <span class="n">FreeBlockOfSplayNode</span><span class="p">(</span><span class="n">leftChild</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">leftNode</span><span class="p">.</span><span class="n">maxSize</span> <span class="o">&gt;</span> <span class="n">maxSize</span><span class="p">)</span>
      <span class="n">maxSize</span> <span class="o">=</span> <span class="n">leftNode</span><span class="o">-&gt;</span><span class="n">maxSize</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">rightChild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">FreeBlock</span> <span class="n">rightNode</span> <span class="o">=</span> <span class="n">FreeBlockOfSplayNode</span><span class="p">(</span><span class="n">rightChild</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rightNode</span><span class="p">.</span><span class="n">maxSize</span> <span class="o">&gt;</span> <span class="n">maxSize</span><span class="p">)</span>
      <span class="n">maxSize</span> <span class="o">=</span> <span class="n">rightNode</span><span class="o">-&gt;</span><span class="n">maxSize</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">freeNode</span><span class="o">-&gt;</span><span class="n">maxSize</span> <span class="o">=</span> <span class="n">maxSize</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="target" id="design.mps.splay.usage.compare"></span><a class="mpstag reference internal" href="#design.mps.splay.usage.compare">.usage.compare:</a> Comparison function (see <a class="reference internal" href="#design.mps.splay.type.splay.compare.method">.type.splay.compare.method</a>):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Compare</span> <span class="nf">FreeBlockCompare</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">SplayNode</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Addr</span> <span class="n">base1</span><span class="p">,</span> <span class="n">base2</span><span class="p">,</span> <span class="n">limit2</span><span class="p">;</span>
  <span class="n">FreeBlock</span> <span class="n">freeNode</span> <span class="o">=</span> <span class="n">FreeBlockOfSplayNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

  <span class="n">base1</span> <span class="o">=</span> <span class="p">(</span><span class="n">Addr</span> <span class="o">*</span><span class="p">)</span><span class="n">key</span><span class="p">;</span>
  <span class="n">base2</span> <span class="o">=</span> <span class="n">freeNode</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
  <span class="n">limit2</span> <span class="o">=</span> <span class="n">AddrAdd</span><span class="p">(</span><span class="n">base2</span><span class="p">,</span> <span class="n">freeNode</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">base1</span> <span class="o">&lt;</span> <span class="n">base2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CompareLESS</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">base1</span> <span class="o">&gt;=</span> <span class="n">limit2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CompareGREATER</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">CompareEQUAL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="target" id="design.mps.splay.usage.test.tree"></span><a class="mpstag reference internal" href="#design.mps.splay.usage.test.tree">.usage.test.tree:</a> Test tree function (see
<a class="reference internal" href="#design.mps.splay.type.splay.test.tree.method">.type.splay.test.tree.method</a>):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Bool</span> <span class="nf">FreeBlockTestTree</span><span class="p">(</span><span class="n">SplayTree</span> <span class="n">tree</span><span class="p">,</span> <span class="n">SplayNode</span> <span class="n">node</span>
                       <span class="kt">void</span> <span class="o">*</span><span class="n">closureP</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">closureS</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Closure environment has wanted size as value of closureS. */</span>
  <span class="cm">/* Look at the cached value for the node to see if any */</span>
  <span class="cm">/* blocks in the subtree are big enough. */</span>

  <span class="n">Size</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">Size</span><span class="p">)</span><span class="n">closureS</span><span class="p">;</span>
  <span class="n">FreeBlock</span> <span class="n">freeNode</span> <span class="o">=</span> <span class="n">FreeBlockOfSplayNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">freeNode</span><span class="o">-&gt;</span><span class="n">maxSize</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="target" id="design.mps.splay.usage.test.node"></span><a class="mpstag reference internal" href="#design.mps.splay.usage.test.node">.usage.test.node:</a> Test node function (see
<a class="reference internal" href="#design.mps.splay.type.splay.test.node.method">.type.splay.test.node.method</a>):</p>
<div class="highlight-c"><pre>Bool FreeBlockTestNode(SplayTree tree, SplayNode node
                       void *closureP, unsigned long closureS) {
  /* Closure environment has wanted size as value of closureS. */
  /* Look at the size of the node to see if is big enough. */

  Size size = (Size)closureS;
  FreeBlock freeNode = FreeBlockOfSplayNode(node);
  return freeNode-&gt;size &gt;= size;
}

:mps:tag:`usage.initialization` Client's initialization function (see
:mps:ref:`.function.splay.tree.init`):
void FreeTreeInit(FreeTree tree) {
  /* Initialize the embedded splay tree. */
  SplayTreeInit(&amp;tree-&gt;splayTree, FreeBlockCompare, FreeBlockUpdateNode);
}</pre>
</div>
<p><span class="target" id="design.mps.splay.usage.insert"></span><a class="mpstag reference internal" href="#design.mps.splay.usage.insert">.usage.insert:</a> Client function to add a new free block into the
tree, merging it with an existing block if possible:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">FreeTreeInsert</span><span class="p">(</span><span class="n">FreeTree</span> <span class="n">tree</span><span class="p">,</span> <span class="n">Addr</span> <span class="n">base</span><span class="p">,</span> <span class="n">Addr</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SplayTree</span> <span class="n">splayTree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">splayTree</span><span class="p">;</span>
  <span class="n">SplayNode</span> <span class="n">leftNeighbour</span><span class="p">,</span> <span class="n">rightNeighbour</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span><span class="p">;</span>  <span class="cm">/* use the base of the block as the key */</span>
  <span class="n">Res</span> <span class="n">res</span><span class="p">;</span>

  <span class="cm">/* Look for any neighbouring blocks. (.function.splay.tree.neighbours) */</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">SplayTreeNeighbours</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leftNeighbour</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rightNeighbour</span><span class="p">,</span>
                            <span class="n">splayTree</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
  <span class="n">AVER</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">ResOK</span><span class="p">);</span>  <span class="cm">/* this client doesn&#39;t duplicate free blocks */</span>

  <span class="cm">/* Look to see if the neighbours are contiguous. */</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">leftNeighbour</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
      <span class="n">FreeBlockLimitOfSplayNode</span><span class="p">(</span><span class="n">leftNeighbour</span><span class="p">)</span> <span class="o">==</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Inserted block is contiguous with left neighbour, so merge it. */</span>
    <span class="cm">/* The client housekeeping is left as an exercise to the reader. */</span>
    <span class="cm">/* This changes the size of a block, which is the client */</span>
    <span class="cm">/* property of the splay node. See :mps:ref:`.function.splay.node.refresh` */</span>
    <span class="n">SplayNodeRefresh</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">leftNeighbour</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rightNeighbour</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
             <span class="n">FreeBlockBaseOfSplayNode</span><span class="p">(</span><span class="n">rightNeighbour</span><span class="p">)</span> <span class="o">==</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Inserted block is contiguous with right neighbour, so merge it. */</span>
    <span class="cm">/* The client housekeeping is left as an exercise to the reader. */</span>
    <span class="cm">/* This changes the size of a block, which is the client */</span>
    <span class="cm">/* property of the splay node. See :mps:ref:`.function.splay.node.refresh` */</span>
    <span class="n">SplayNodeRefresh</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">rightNeighbour</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="cm">/* Not contiguous - so insert a new node */</span>
    <span class="n">FreeBlock</span> <span class="n">newBlock</span> <span class="o">=</span> <span class="p">(</span><span class="n">FreeBlock</span><span class="p">)</span><span class="n">allocate</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FreeBlockStruct</span><span class="p">));</span>
    <span class="n">splayNode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">newBlock</span><span class="o">-&gt;</span><span class="n">splayNode</span><span class="p">;</span>

    <span class="n">newBlock</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
    <span class="n">newBlock</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">AddrOffset</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
    <span class="n">SplayNodeInit</span><span class="p">(</span><span class="n">splayNode</span><span class="p">);</span>  <span class="cm">/* :mps:ref:`.function.splay.node.init` */</span>
    <span class="cm">/* :mps:ref:`.function.splay.tree.insert` */</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">SplayTreeInsert</span><span class="p">(</span><span class="n">splayTree</span><span class="p">,</span> <span class="n">splayNode</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="n">AVER</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">ResOK</span><span class="p">);</span>  <span class="cm">/* this client doesn&#39;t duplicate free blocks */</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="target" id="design.mps.splay.usage.delete"></span><a class="mpstag reference internal" href="#design.mps.splay.usage.delete">.usage.delete:</a> Client function to allocate the first block of a
given size in address order. For simplicity, this allocates the entire
block:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Bool</span> <span class="nf">FreeTreeAllocate</span><span class="p">(</span><span class="n">Addr</span> <span class="o">*</span><span class="n">baseReturn</span><span class="p">,</span> <span class="n">Size</span> <span class="o">*</span><span class="n">sizeReturn</span><span class="p">,</span>
                      <span class="n">FreeTree</span> <span class="n">tree</span><span class="p">,</span> <span class="n">Size</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SplayTree</span> <span class="n">splayTree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">splayTree</span><span class="p">;</span>
  <span class="n">SplayNode</span> <span class="n">splayNode</span><span class="p">;</span>
  <span class="n">Bool</span> <span class="n">found</span><span class="p">;</span>

  <span class="cm">/* look for the first node of at least the given size. */</span>
  <span class="cm">/* closureP parameter is not used. See `.function.splay.find.first.`_  */</span>
  <span class="n">found</span> <span class="o">=</span> <span class="n">SplayFindFirst</span><span class="p">(</span><span class="o">&amp;</span><span class="n">splayNode</span><span class="p">,</span> <span class="n">splayTree</span><span class="p">,</span>
                         <span class="n">FreeBlockTestNode</span><span class="p">,</span> <span class="n">FreeBlockTestTree</span><span class="p">,</span>
                         <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">size</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">FreeBlock</span> <span class="n">freeNode</span> <span class="o">=</span> <span class="n">FreeBlockOfSplayNode</span><span class="p">(</span><span class="n">splayNode</span><span class="p">);</span>
    <span class="n">Void</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">freeNode</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>  <span class="cm">/* use base of block as the key */</span>
    <span class="n">Res</span> <span class="n">res</span><span class="p">;</span>

    <span class="cm">/* allocate the block */</span>
    <span class="o">*</span><span class="n">baseReturn</span> <span class="o">=</span> <span class="n">freeNode</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
    <span class="o">*</span><span class="n">sizeReturn</span> <span class="o">=</span> <span class="n">freeNode</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

    <span class="cm">/* remove the node from the splay tree - :mps:ref:`.function.splay.tree.delete` */</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">SplayTreeDelete</span><span class="p">(</span><span class="n">splayTree</span><span class="p">,</span> <span class="n">splayNode</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="n">AVER</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">ResOK</span><span class="p">);</span>  <span class="cm">/* Must be possible to delete node */</span>

    <span class="cm">/* Delete the block */</span>
    <span class="n">deallocate</span><span class="p">(</span><span class="n">freeNode</span><span class="p">,</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FreeBlockStruct</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>

  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="cm">/* No suitable block */</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="implementation">
<h2>40.9. Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.splay.impl"></span><a class="mpstag reference internal" href="#design.mps.splay.impl">.impl:</a> For more details of how splay trees work, see paper.st85(0).
For more details of how to implement operations on splay trees, see
paper.sleator96(0). Here we describe the operations involved.</p>
<div class="section" id="top-down-splaying">
<h3>40.9.1. Top-down splaying<a class="headerlink" href="#top-down-splaying" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.splay.impl.top-down"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.top-down">.impl.top-down:</a> The method chosen to implement the splaying
operation is called &#8220;top-down splay&#8221;. This is described as &#8220;procedure
top-down splay&#8221; in paper.st85(0) - although the implementation here
additionally permits attempts to access items which are not known to
be in the tree. Top-down splaying is particularly efficient for the
common case where the location of the node in a tree is not known at
the start of an operation. Tree restructuring happens as the tree is
descended, whilst looking for the node.</p>
<p><span class="target" id="design.mps.splay.impl.splay"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.splay">.impl.splay:</a> The key to the operation of the splay tree is the
internal function <tt class="xref c c-func docutils literal"><span class="pre">SplaySplay()</span></tt>. It searches the tree for a node
with a given key and returns whether it suceeded. In the process, it
brings the found node, or an arbitrary neighbour if not found, to the
root of the tree. This &#8220;bring-to-root&#8221; operation is performed top-down
during the search, and it is not the simplest possible bring-to-root
operation, but the resulting tree is well-balanced, and will give good
amortised cost for future calls to <tt class="xref c c-func docutils literal"><span class="pre">SplaySplay()</span></tt>. (See
paper.st85(0))</p>
<p><span class="target" id="design.mps.splay.impl.splay.how"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.splay.how">.impl.splay.how:</a> To perform this top-down splay, the tree is broken
into three parts, a left tree, a middle tree and a right tree. We
store the left tree and right tree in the right and left children
respectively of a &#8220;sides&#8221; node to eliminate some boundary conditions.
The initial condition is that the middle tree is the entire splay
tree, and the left and right trees are empty. We also keep pointers to
the last node in the left tree, and the first node in the right tree.
Note that, at all times, the three trees are each validly ordered, and
they form a partition with the ordering left, middle, right. The splay
is then performed by comparing the middle tree with the following six
cases, and performing the indicated operations, until none apply.</p>
<p><span class="target" id="design.mps.splay.impl.splay.cases"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.splay.cases">.impl.splay.cases:</a> Note that paper.st85(0)(Fig. 3) describes only 3
cases: zig, zig-zig and zig-zag. The additional cases described here
are the symmetric variants which are respectively called zag, zag-zag
and zag-zig. In the descriptions of these cases, <tt class="docutils literal"><span class="pre">root</span></tt> is the root
of the middle tree; <tt class="docutils literal"><span class="pre">node-&gt;left</span></tt> is the left child of <tt class="docutils literal"><span class="pre">node</span></tt>;
<tt class="docutils literal"><span class="pre">node-&gt;right</span></tt> is the right child of <tt class="docutils literal"><span class="pre">node</span></tt>. The comparison
operators (<tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">==</span></tt>) are defined to compare a key and a
node in the obvious way by comparing the supplied key with the node&#8217;s
associated key.</p>
<p><span class="target" id="design.mps.splay.impl.splay.zig"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.splay.zig">.impl.splay.zig:</a> The &#8220;zig&#8221; case is where <tt class="docutils literal"><span class="pre">key</span> <span class="pre">&lt;</span> <span class="pre">root</span></tt>, and either:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">key</span> <span class="pre">==</span> <span class="pre">root-&gt;left</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">key</span> <span class="pre">&lt;</span> <span class="pre">root-&gt;left</span> <span class="pre">&amp;&amp;</span> <span class="pre">root-&gt;left-&gt;left</span> <span class="pre">==</span> <span class="pre">NULL</span></tt>; or</li>
<li><tt class="docutils literal"><span class="pre">key</span> <span class="pre">&gt;</span> <span class="pre">root-&gt;left</span> <span class="pre">&amp;&amp;</span> <span class="pre">root-&gt;left-&gt;right</span> <span class="pre">==</span> <span class="pre">NULL</span></tt>.</li>
</ul>
<p>The operation for the zig case is: link right (see <a class="reference internal" href="#design.mps.splay.impl.link.right">.impl.link.right</a>).</p>
<p><span class="target" id="design.mps.splay.impl.splay.zag"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.splay.zag">.impl.splay.zag:</a> The &#8220;zag&#8221; case is where <tt class="docutils literal"><span class="pre">key</span> <span class="pre">&gt;</span> <span class="pre">root</span></tt>, and either:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">key</span> <span class="pre">==</span> <span class="pre">root-&gt;right</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">key</span> <span class="pre">&lt;</span> <span class="pre">root-&gt;right</span> <span class="pre">&amp;&amp;</span> <span class="pre">root-&gt;right-&gt;left</span> <span class="pre">==</span> <span class="pre">NULL</span></tt>; or</li>
<li><tt class="docutils literal"><span class="pre">key</span> <span class="pre">&gt;</span> <span class="pre">root-&gt;right</span> <span class="pre">&amp;&amp;</span> <span class="pre">root-&gt;right-&gt;right</span> <span class="pre">==</span> <span class="pre">NULL</span></tt>.</li>
</ul>
<p>The operation for the zag case is: link left (see <a class="reference internal" href="#design.mps.splay.impl.link.left">.impl.link.left</a>).</p>
<p><span class="target" id="design.mps.splay.impl.splay.zig.zig"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.splay.zig.zig">.impl.splay.zig.zig:</a> The &#8220;zig-zig&#8221; case is where</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">key</span> <span class="pre">&lt;</span> <span class="pre">root</span> <span class="pre">&amp;&amp;</span> <span class="pre">key</span> <span class="pre">&lt;</span> <span class="pre">root-&gt;left</span> <span class="pre">&amp;&amp;</span> <span class="pre">root-&gt;left-&gt;left</span> <span class="pre">!=</span> <span class="pre">NULL</span></tt>.</li>
</ul>
<p>The operation for the zig-zig case is: rotate right (see
<a class="reference internal" href="#design.mps.splay.impl.rotate.right">.impl.rotate.right</a>) followed by link right (see
<a class="reference internal" href="#design.mps.splay.impl.link.right">.impl.link.right</a>).</p>
<p><span class="target" id="design.mps.splay.impl.splay.zig.zag"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.splay.zig.zag">.impl.splay.zig.zag:</a> The &#8220;zig-zag&#8221; case is where</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">key</span> <span class="pre">&lt;</span> <span class="pre">root</span> <span class="pre">&amp;&amp;</span> <span class="pre">key</span> <span class="pre">&gt;</span> <span class="pre">root-&gt;left</span> <span class="pre">&amp;&amp;</span> <span class="pre">root-&gt;left-&gt;right</span> <span class="pre">!=</span> <span class="pre">NULL</span></tt>.</li>
</ul>
<p>The operation for the zig-zag case is: link right (see
<a class="reference internal" href="#design.mps.splay.impl.link.right">.impl.link.right</a>) followed by link left (see <a class="reference internal" href="#design.mps.splay.impl.link.left">.impl.link.left</a>).</p>
<p><span class="target" id="design.mps.splay.impl.splay.zag.zig"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.splay.zag.zig">.impl.splay.zag.zig:</a> The &#8220;zag-zig&#8221; case is where</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">key</span> <span class="pre">&gt;</span> <span class="pre">root</span> <span class="pre">&amp;&amp;</span> <span class="pre">key</span> <span class="pre">&lt;</span> <span class="pre">root-&gt;right</span> <span class="pre">&amp;&amp;</span> <span class="pre">root-&gt;right-&gt;left</span> <span class="pre">!=</span> <span class="pre">NULL</span></tt>.</li>
</ul>
<p>The operation for the zag-zig case is: link left (see
<a class="reference internal" href="#design.mps.splay.impl.link.left">.impl.link.left</a>) followed by link right (see <a class="reference internal" href="#design.mps.splay.impl.link.right">.impl.link.right</a>).</p>
<p><span class="target" id="design.mps.splay.impl.splay.zag.zag"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.splay.zag.zag">.impl.splay.zag.zag:</a> The &#8220;zag-zag&#8221; case is where</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">key</span> <span class="pre">&gt;</span> <span class="pre">root</span> <span class="pre">&amp;&amp;</span> <span class="pre">key</span> <span class="pre">&gt;</span> <span class="pre">root-&gt;right</span> <span class="pre">&amp;&amp;</span> <span class="pre">root-&gt;right-&gt;right</span> <span class="pre">!=</span> <span class="pre">NULL</span></tt>.</li>
</ul>
<p>The operation for the zag-zag case is: rotate left (see
<a class="reference internal" href="#design.mps.splay.impl.rotate.left">.impl.rotate.left</a>) followed by link left (see <a class="reference internal" href="#design.mps.splay.impl.link.left">.impl.link.left</a>).</p>
<p><span class="target" id="design.mps.splay.impl.splay.terminal.null"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.splay.terminal.null">.impl.splay.terminal.null:</a> A special terminal case is when</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">root</span> <span class="pre">==</span> <span class="pre">NULL</span></tt>.</li>
</ul>
<p>This can only happen at the beginning, and cannot arise from the
operations above. In this case, the splay operation must return
<tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt>, and &#8220;not found&#8221;.</p>
<p><span class="target" id="design.mps.splay.impl.splay.terminal.found"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.splay.terminal.found">.impl.splay.terminal.found:</a> One typical terminal case is when</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">key</span> <span class="pre">==</span> <span class="pre">root</span></tt>.</li>
</ul>
<p>This case is tested for at the beginning, in which case &#8220;found&#8221; is
returned immediately. If this case happens as a result of other
operations, the splay operation is complete, the three trees are
assembled (see <a class="reference internal" href="#design.mps.splay.impl.assemble">.impl.assemble</a>), and &#8220;found&#8221; is returned.</p>
<p><span class="target" id="design.mps.splay.impl.splay.terminal.not-found"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.splay.terminal.not-found">.impl.splay.terminal.not-found:</a> The other typical terminal cases are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">key</span> <span class="pre">&lt;</span> <span class="pre">root</span> <span class="pre">&amp;&amp;</span> <span class="pre">root-&gt;left</span> <span class="pre">==</span> <span class="pre">NULL</span></tt>; and</li>
<li><tt class="docutils literal"><span class="pre">key</span> <span class="pre">&gt;</span> <span class="pre">root</span> <span class="pre">&amp;&amp;</span> <span class="pre">root-&gt;right</span> <span class="pre">==</span> <span class="pre">NULL</span></tt>.</li>
</ul>
<p>In these cases, the splay operation is complete, the three trees are assembled
(see <a class="reference internal" href="#design.mps.splay.impl.assemble">.impl.assemble</a>), and &#8220;not found&#8221; is returned.</p>
<p><span class="target" id="design.mps.splay.impl.rotate.left"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.rotate.left">.impl.rotate.left:</a> The &#8220;rotate left&#8221; operation (see paper.st85(0)
Fig. 1) rearranges the middle tree as follows (where any of sub-trees
A, B and C may be empty):</p>
<p>[missing diagram]</p>
<p><span class="target" id="design.mps.splay.impl.rotate.right"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.rotate.right">.impl.rotate.right:</a> The &#8220;rotate right&#8221; operation (see paper.st85(0)
Fig. 1) rearranges the middle tree as follows (where any of sub-trees
A, B and C may be empty):</p>
<p>[missing diagram]</p>
<p><span class="target" id="design.mps.splay.impl.link.left"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.link.left">.impl.link.left:</a> The &#8220;link left&#8221; operation (see paper.st85(0) Fig.
11a for symmetric variant) rearranges the left and middle trees as
follows (where any of sub-trees A, B, L and R may be empty):</p>
<p>[missing diagram]</p>
<p>The last node of the left tree is now x.</p>
<p><span class="target" id="design.mps.splay.impl.link.right"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.link.right">.impl.link.right:</a> The &#8220;link right&#8221; operation (see paper.st85(0)
Fig. 11a) rearranges the middle and right trees as follows (where any
of sub-trees A, B, L and R may be empty):</p>
<p>[missing diagram]</p>
<p>The first node of the right tree is now x.</p>
<p><span class="target" id="design.mps.splay.impl.assemble"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.assemble">.impl.assemble:</a> The &#8220;assemble&#8221; operation (see paper.st85(0)
Fig. 12) merges the left and right trees with the middle tree as
follows (where any of sub-trees A, B, L and R may be empty):</p>
<p>[missing diagram]</p>
</div>
<div class="section" id="top-level-operations">
<h3>40.9.2. Top-level operations<a class="headerlink" href="#top-level-operations" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.splay.impl.insert"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.insert">.impl.insert:</a> <a class="reference internal" href="#SplayTreeInsert" title="SplayTreeInsert"><tt class="xref c c-func docutils literal"><span class="pre">SplayTreeInsert()</span></tt></a>: (See paper.sleator96(0), chapter
4, function insert). If the tree has no nodes, [how does it smell?]
add the inserted node and we&#8217;re done; otherwise splay the tree around
the supplied key. If the splay successfully found a matching node,
return failure. Otherwise, add the inserted node as a new root, with
the old (newly splayed, but non-matching) root as its left or right
child as appropriate, and the opposite child of the old root as the
other child of the new root.</p>
<p><span class="target" id="design.mps.splay.impl.delete"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.delete">.impl.delete:</a> <a class="reference internal" href="#SplayTreeDelete" title="SplayTreeDelete"><tt class="xref c c-func docutils literal"><span class="pre">SplayTreeDelete()</span></tt></a>: (See paper.sleator96(0), chapter
4, function delete). Splay the tree around the supplied key. Check
that the newly splayed root is the same node as given by the caller,
and that it matches the key; return failure if not. If the given node
(now at the root) has fewer than two children, replace it (as root),
with the non-null child or null. Otherwise, set the root of the tree
to be the left child (arbitrarily) of the node to be deleted, and
splay around the same key. The new root will be the last node in the
sub-tree and will have a null right child; this is set to be the right
child of the node to be deleted.</p>
<p><span class="target" id="design.mps.splay.impl.search"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.search">.impl.search:</a> <a class="reference internal" href="#SplayTreeSearch" title="SplayTreeSearch"><tt class="xref c c-func docutils literal"><span class="pre">SplayTreeSearch()</span></tt></a>: Splay the node around the
supplied key. If the splay found a matching node, return it; otherwise
return failure.</p>
<p><span class="target" id="design.mps.splay.impl.neighbours"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.neighbours">.impl.neighbours:</a> <a class="reference internal" href="#SplayTreeNeighbours" title="SplayTreeNeighbours"><tt class="xref c c-func docutils literal"><span class="pre">SplayTreeNeighbours()</span></tt></a>: Splay the tree around
the supplied key. If the splay found a matching node, return failure.
Otherwise, determine whether the (non-matching) found node is the left
or right neighbour of the key (by comparison with the key). Set the
tree root to be the right or left child of that first neighbour
respectively, and again splay the tree around the supplied key. The
new root will be the second neighbour, and will have a null left or
right child respectively. Set this null child to be the first
neighbour. Return the two neighbours.</p>
<p><span class="target" id="design.mps.splay.impl.neighbours.note"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.neighbours.note">.impl.neighbours.note:</a> Note that it would be possible to implement
<a class="reference internal" href="#SplayTreeNeighbours" title="SplayTreeNeighbours"><tt class="xref c c-func docutils literal"><span class="pre">SplayTreeNeighbours()</span></tt></a> with only one splay, and then a normal
binary tree search for the left or right neighbour of the root. This
would be a cheaper operation, but would give poorer amortised cost if
the call to <a class="reference internal" href="#SplayTreeNeighbours" title="SplayTreeNeighbours"><tt class="xref c c-func docutils literal"><span class="pre">SplayTreeNeighbours()</span></tt></a> typically precedes a call to
<a class="reference internal" href="#SplayTreeInsert" title="SplayTreeInsert"><tt class="xref c c-func docutils literal"><span class="pre">SplayTreeInsert()</span></tt></a> (which is expected to be a common usage
pattern - see <a class="reference internal" href="#design.mps.splay.usage.insert">.usage.insert</a>). It&#8217;s also possible to implement
<a class="reference internal" href="#SplayTreeNeighbours" title="SplayTreeNeighbours"><tt class="xref c c-func docutils literal"><span class="pre">SplayTreeNeighbours()</span></tt></a> by simply keeping track of both neighbours
during a single splay. This has about the same cost as a single splay,
and hence about the same amortised cost if the call to
<a class="reference internal" href="#SplayTreeNeighbours" title="SplayTreeNeighbours"><tt class="xref c c-func docutils literal"><span class="pre">SplayTreeNeighbours()</span></tt></a> typically precedes a call to
<a class="reference internal" href="#SplayTreeInsert" title="SplayTreeInsert"><tt class="xref c c-func docutils literal"><span class="pre">SplayTreeInsert()</span></tt></a>.</p>
<p><span class="target" id="design.mps.splay.impl.next"></span><a class="mpstag reference internal" href="#design.mps.splay.impl.next">.impl.next:</a> <a class="reference internal" href="#SplayTreeNext" title="SplayTreeNext"><tt class="xref c c-func docutils literal"><span class="pre">SplayTreeNext()</span></tt></a>: Splay the tree around the supplied
<tt class="docutils literal"><span class="pre">oldKey</span></tt>. During iteration the &#8220;old node&#8221; found is probably already
at the root, in which case this will be a null operation with little
cost. If this old node has no right child, return <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt>. Otherwise,
split the tree into a right tree (which contains just the right child
of the old node) and a left tree (which contains the old node, its
left child and no right child). The next node is the first node in the
right tree. Find this by splaying the right tree around <tt class="docutils literal"><span class="pre">oldKey</span></tt>
(which is known to compare <tt class="docutils literal"><span class="pre">CompareLESS</span></tt> than any keys in the right
tree). Rejoin the full tree, using the right tree as the root and
setting the left child of root to be the left tree. Return the root of
this tree.</p>
</div>
</div>
<div class="section" id="testing">
<h2>40.10. Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.splay.test"></span><a class="mpstag reference internal" href="#design.mps.splay.test">.test:</a> There is no plan to test splay trees directly. It is
believed that the testing described in design.mps.cbs.test will be
sufficient to test this implementation.</p>
</div>
<div class="section" id="error-handling">
<h2>40.11. Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.splay.error"></span><a class="mpstag reference internal" href="#design.mps.splay.error">.error:</a> This module detects and reports most common classes of
protocol error. The cases it doesn&#8217;t handle will result in undefined
behaviour and probably cause an <tt class="xref c c-macro docutils literal"><span class="pre">AVER</span></tt> to fire. These are:</p>
<p><span class="target" id="design.mps.splay.error.bad-pointer"></span><a class="mpstag reference internal" href="#design.mps.splay.error.bad-pointer">.error.bad-pointer:</a> Passing an invalid pointer in place of a
<a class="reference internal" href="#SplayTree" title="SplayTree"><tt class="xref c c-type docutils literal"><span class="pre">SplayTree</span></tt></a> or <a class="reference internal" href="#SplayNode" title="SplayNode"><tt class="xref c c-type docutils literal"><span class="pre">SplayNode</span></tt></a>.</p>
<p><span class="target" id="design.mps.splay.error.bad-compare"></span><a class="mpstag reference internal" href="#design.mps.splay.error.bad-compare">.error.bad-compare:</a> Initialising a <a class="reference internal" href="#SplayTree" title="SplayTree"><tt class="xref c c-type docutils literal"><span class="pre">SplayTree</span></tt></a> with a compare
function that is not a valid compare function, or which doesn&#8217;t
implement a total ordering on splay nodes.</p>
<p><span class="target" id="design.mps.splay.error.bad-describe"></span><a class="mpstag reference internal" href="#design.mps.splay.error.bad-describe">.error.bad-describe:</a> Passing an invalid describe method to
<a class="reference internal" href="#SplayTreeDescribe" title="SplayTreeDescribe"><tt class="xref c c-func docutils literal"><span class="pre">SplayTreeDescribe()</span></tt></a>.</p>
<p><span class="target" id="design.mps.splay.error.out-of-stack"></span><a class="mpstag reference internal" href="#design.mps.splay.error.out-of-stack">.error.out-of-stack:</a> Stack exhaustion under <a class="reference internal" href="#SplayTreeDescribe" title="SplayTreeDescribe"><tt class="xref c c-func docutils literal"><span class="pre">SplayTreeDescribe()</span></tt></a>.</p>
</div>
<div class="section" id="future">
<h2>40.12. Future<a class="headerlink" href="#future" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.splay.future.tree"></span><a class="mpstag reference internal" href="#design.mps.splay.future.tree">.future.tree:</a> It would be possible to split the splay tree module
into two: one that implements binary trees; and one that implements
splay trees on top of a binary tree.</p>
<p><span class="target" id="design.mps.splay.future.parent"></span><a class="mpstag reference internal" href="#design.mps.splay.future.parent">.future.parent:</a> The iterator could be made more efficient (in an
amortized sense) if it didn&#8217;t splay at each node. To implement this
(whilst meeting <a class="reference internal" href="#design.mps.splay.req.stack">.req.stack</a>) we really need parent pointers from the
nodes. We could use the (first-child, right-sibling/parent) trick
described in paper.st85 to implement this, at a slight cost to all
other tree operations, and an increase in code complexity. paper.st85
doesn&#8217;t describe how to distinguish the first-child between left-child
and right-child, and the right-sibling/parent between right-sibling
and parent. One could either use the comparator to make these
distinctions, or steal some bits from the pointers.</p>
<p><span class="target" id="design.mps.splay.future.reverse"></span><a class="mpstag reference internal" href="#design.mps.splay.future.reverse">.future.reverse:</a> The assembly phase could be made more efficient if
the link left and link right operations were modified to add to the
left and right trees with pointers reversed. This would remove the
need for the assembly phase to reverse them.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">40. Splay trees</a><ul>
<li><a class="reference internal" href="#introduction">40.1. Introduction</a></li>
<li><a class="reference internal" href="#overview">40.2. Overview</a></li>
<li><a class="reference internal" href="#definitions">40.3. Definitions</a></li>
<li><a class="reference internal" href="#requirements">40.4. Requirements</a></li>
<li><a class="reference internal" href="#external-types">40.5. External types</a></li>
<li><a class="reference internal" href="#external-functions">40.6. External functions</a></li>
<li><a class="reference internal" href="#client-determined-properties">40.7. Client-determined properties</a></li>
<li><a class="reference internal" href="#usage">40.8. Usage</a></li>
<li><a class="reference internal" href="#implementation">40.9. Implementation</a><ul>
<li><a class="reference internal" href="#top-down-splaying">40.9.1. Top-down splaying</a></li>
<li><a class="reference internal" href="#top-level-operations">40.9.2. Top-level operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing">40.10. Testing</a></li>
<li><a class="reference internal" href="#error-handling">40.11. Error Handling</a></li>
<li><a class="reference internal" href="#future">40.12. Future</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="shield.html"
                        title="previous chapter">39. Shield</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="sso1al.html"
                        title="next chapter">41. Stack scanner for Digital Unix on Alpha</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="sso1al.html" title="41. Stack scanner for Digital Unix on Alpha"
             >next</a> |</li>
        <li class="right" >
          <a href="shield.html" title="39. Shield"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" >Old design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>