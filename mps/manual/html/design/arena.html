

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>1. Arena &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Old design" href="old.html" />
    <link rel="next" title="2. Bit tables" href="bt.html" />
    <link rel="prev" title="Old design" href="old.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="bt.html" title="2. Bit tables"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="old.html" title="Old design"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" accesskey="U">Old design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="arena">
<span id="design-design-arena"></span><span id="design-arena"></span><span id="index-0"></span><h1>1. Arena<a class="headerlink" href="#arena" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="design.mps.arena"></span><h2>1.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.arena.intro"></span><a class="mpstag reference internal" href="#design.mps.arena.intro">.intro:</a> This is the design of the arena structure.</p>
<p><span class="target" id="design.mps.arena.readership"></span><a class="mpstag reference internal" href="#design.mps.arena.readership">.readership:</a> MPS developers.</p>
</div>
<div class="section" id="overview">
<h2>1.2. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.arena.overview"></span><a class="mpstag reference internal" href="#design.mps.arena.overview">.overview:</a> The arena serves two purposes. It is a structure that is
the top-level state of the MPS, and as such contains a lot of fields
which are considered &#8220;global&#8221;. And it provides raw memory to pools.</p>
<p>An arena belongs to a particular arena class. The class is selected
when the arena is created. Classes encapsulate both policy (such as
how pool placement preferences map into actual placement) and
mechanism (such as where the memory originates: operating system
virtual memory, client provided, or via malloc). Some behaviour
(mostly serving the &#8220;top-level datastructure&#8221; purpose) is implemented
by generic arena code, and some by arena class code.</p>
</div>
<div class="section" id="definitions">
<h2>1.3. Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.arena.def.tract"></span><a class="mpstag reference internal" href="#design.mps.arena.def.tract">.def.tract:</a> Pools request memory from the arena by calling
<tt class="xref c c-func docutils literal"><span class="pre">ArenaAlloc()</span></tt>. This returns a block comprising a contiguous sequence
of &#8220;tracts&#8221;. A tract has a specific size (also known as the &#8220;arena
alignment&#8221;, which typically corresponds to the operating system page
size) and all tracts are aligned to that size. &#8220;Tract&#8221; is also used
for the data structure used to manage tracts.</p>
</div>
<div class="section" id="requirements">
<h2>1.4. Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p>[copied from design.mps.arena.vm(1) and edited slightly &#8211; drj
1999-06-23]</p>
<p>[Where do these come from? Need to identify and document the sources
of requirements so that they are traceable to client requirements.
Most of these come from the architectural design
(design.mps.architecture) or the fix function design (design.mps.fix).
&#8211; richard 1995-08-28]</p>
<div class="section" id="block-management">
<h3>1.4.1. Block management<a class="headerlink" href="#block-management" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.req.fun.block.alloc"></span><a class="mpstag reference internal" href="#design.mps.arena.req.fun.block.alloc">.req.fun.block.alloc:</a> The arena must provide allocation of
contiguous blocks of memory.</p>
<p><span class="target" id="design.mps.arena.req.fun.block.free"></span><a class="mpstag reference internal" href="#design.mps.arena.req.fun.block.free">.req.fun.block.free:</a> It must also provide freeing of contiguously
allocated blocks owned by a pool - whether or not the block was
allocated via a single request.</p>
<p><span class="target" id="design.mps.arena.req.attr.block.size.min"></span><a class="mpstag reference internal" href="#design.mps.arena.req.attr.block.size.min">.req.attr.block.size.min:</a> The arena must support management of
blocks down to the size of the grain (page) provided by the virtual
mapping interface if a virtual memory interface is being used, or a
comparable size otherwise.</p>
<p><span class="target" id="design.mps.arena.req.attr.block.size.max"></span><a class="mpstag reference internal" href="#design.mps.arena.req.attr.block.size.max">.req.attr.block.size.max:</a> It must also support management of blocks
up to the maximum size allowed by the combination of operating system
and architecture. This is derived from req.dylan.attr.obj.max (at
least).</p>
<p><span class="target" id="design.mps.arena.req.attr.block.align.min"></span><a class="mpstag reference internal" href="#design.mps.arena.req.attr.block.align.min">.req.attr.block.align.min:</a> The alignment of blocks shall not be less
than <a class="reference internal" href="../topic/platform.html#MPS_PF_ALIGN" title="MPS_PF_ALIGN"><tt class="xref c c-macro docutils literal"><span class="pre">MPS_PF_ALIGN</span></tt></a> for the architecture. This is so that pool
classes can conveniently guarantee pool allocated blocks are aligned
to <a class="reference internal" href="../topic/platform.html#MPS_PF_ALIGN" title="MPS_PF_ALIGN"><tt class="xref c c-macro docutils literal"><span class="pre">MPS_PF_ALIGN</span></tt></a>. (A trivial requirement)</p>
<p><span class="target" id="design.mps.arena.req.attr.block.grain.max"></span><a class="mpstag reference internal" href="#design.mps.arena.req.attr.block.grain.max">.req.attr.block.grain.max:</a> The granularity of allocation shall not
be more than the grain size provided by the virtual mapping interface.</p>
</div>
<div class="section" id="address-translation">
<h3>1.4.2. Address translation<a class="headerlink" href="#address-translation" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.req.fun.trans"></span><a class="mpstag reference internal" href="#design.mps.arena.req.fun.trans">.req.fun.trans:</a> The arena must provide a translation from any
address to either an indication that the address is not in any tract
(if that is so) or the following data associated with the tract
containing that address:</p>
<p><span class="target" id="design.mps.arena.req.fun.trans.pool"></span><a class="mpstag reference internal" href="#design.mps.arena.req.fun.trans.pool">.req.fun.trans.pool:</a> The pool that allocated the tract.</p>
<p><span class="target" id="design.mps.arena.req.fun.trans.arbitrary"></span><a class="mpstag reference internal" href="#design.mps.arena.req.fun.trans.arbitrary">.req.fun.trans.arbitrary:</a> An arbitrary pointer value that the pool
can associate with the tract at any time.</p>
<p><span class="target" id="design.mps.arena.req.fun.trans.white"></span><a class="mpstag reference internal" href="#design.mps.arena.req.fun.trans.white">.req.fun.trans.white:</a> The tracer whiteness information. That is, a
bit for each active trace that indicates whether this tract is white
(contains white objects). This is required so that the &#8220;fix&#8221; protocol
can run very quickly.</p>
<p><span class="target" id="design.mps.arena.req.attr.trans.time"></span><a class="mpstag reference internal" href="#design.mps.arena.req.attr.trans.time">.req.attr.trans.time:</a> The translation shall take no more than &#64;&#64;&#64;&#64;
[something not very large &#8211; drj 1999-06-23]</p>
</div>
<div class="section" id="iteration-protocol">
<h3>1.4.3. Iteration protocol<a class="headerlink" href="#iteration-protocol" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.req.iter"></span><a class="mpstag reference internal" href="#design.mps.arena.req.iter">.req.iter:</a> er, there&#8217;s a tract iteration protocol which is
presumably required for some reason?</p>
</div>
<div class="section" id="arena-partition">
<h3>1.4.4. Arena partition<a class="headerlink" href="#arena-partition" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.req.fun.set"></span><a class="mpstag reference internal" href="#design.mps.arena.req.fun.set">.req.fun.set:</a> The arena must provide a method for approximating sets
of addresses.</p>
<p><span class="target" id="design.mps.arena.req.fun.set.time"></span><a class="mpstag reference internal" href="#design.mps.arena.req.fun.set.time">.req.fun.set.time:</a> The determination of membership shall take no
more than &#64;&#64;&#64;&#64; [something very small indeed]. (the non-obvious
solution is refsets)</p>
</div>
<div class="section" id="constraints">
<h3>1.4.5. Constraints<a class="headerlink" href="#constraints" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.req.attr.space.overhead"></span><a class="mpstag reference internal" href="#design.mps.arena.req.attr.space.overhead">.req.attr.space.overhead:</a> req.dylan.attr.space.struct implies that
the arena must limit the space overhead. The arena is not the only
part that introduces an overhead (pool classes being the next most
obvious), so multiple parts must cooperate in order to meet the
ultimate requirements.</p>
<p><span class="target" id="design.mps.arena.req.attr.time.overhead"></span><a class="mpstag reference internal" href="#design.mps.arena.req.attr.time.overhead">.req.attr.time.overhead:</a> Time overhead constraint? [how can there be
a time &#8220;overhead&#8221; on a necessary component? drj 1999-06-23]</p>
</div>
</div>
<div class="section" id="architecture">
<h2>1.5. Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h2>
<div class="section" id="statics">
<h3>1.5.1. Statics<a class="headerlink" href="#statics" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.static"></span><a class="mpstag reference internal" href="#design.mps.arena.static">.static:</a> There is no higher-level data structure than a arena, so in
order to support several arenas, we have to have some static data in
impl.c.arena. See impl.c.arena.static.</p>
<p><span class="target" id="design.mps.arena.static.init"></span><a class="mpstag reference internal" href="#design.mps.arena.static.init">.static.init:</a> All the static data items are initialized when the
first arena is created.</p>
<p><span class="target" id="design.mps.arena.static.serial"></span><a class="mpstag reference internal" href="#design.mps.arena.static.serial">.static.serial:</a> <tt class="docutils literal"><span class="pre">arenaSerial</span></tt> is a static <a class="reference internal" href="type.html#Serial" title="Serial"><tt class="xref c c-type docutils literal"><span class="pre">Serial</span></tt></a>, containing
the serial number of the next arena to be created. The serial of any
existing arena is less than this.</p>
<p><span class="target" id="design.mps.arena.static.ring"></span><a class="mpstag reference internal" href="#design.mps.arena.static.ring">.static.ring:</a> <tt class="docutils literal"><span class="pre">arenaRing</span></tt> is the sentinel of the ring of arenas.</p>
<p><span class="target" id="design.mps.arena.static.ring.init"></span><a class="mpstag reference internal" href="#design.mps.arena.static.ring.init">.static.ring.init:</a> <tt class="docutils literal"><span class="pre">arenaRingInit</span></tt> is a <a class="reference internal" href="type.html#Bool" title="Bool"><tt class="xref c c-type docutils literal"><span class="pre">Bool</span></tt></a> showing whether
the ring of arenas has been initialized.</p>
<p><span class="target" id="design.mps.arena.static.ring.lock"></span><a class="mpstag reference internal" href="#design.mps.arena.static.ring.lock">.static.ring.lock:</a> The ring of arenas has to be locked when
traversing the ring, to prevent arenas being added or removed. This is
achieved by using the (non-recursive) global lock facility, provided
by the lock module.</p>
<p><span class="target" id="design.mps.arena.static.check"></span><a class="mpstag reference internal" href="#design.mps.arena.static.check">.static.check:</a> The statics are checked each time any arena is
checked.</p>
</div>
<div class="section" id="arena-classes">
<h3>1.5.2. Arena classes<a class="headerlink" href="#arena-classes" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="Arena">
mps_arena_s *<tt class="descname">Arena</tt><a class="headerlink" href="#Arena" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.arena.class"></span><a class="mpstag reference internal" href="#design.mps.arena.class">.class:</a> The <a class="reference internal" href="#Arena" title="Arena"><tt class="xref c c-type docutils literal"><span class="pre">Arena</span></tt></a> data structure is designed to be subclassable
(see design.mps.protocol(0)). Clients can select what arena class
they&#8217;d like when instantiating one with <a class="reference internal" href="../topic/arena.html#mps_arena_create" title="mps_arena_create"><tt class="xref c c-func docutils literal"><span class="pre">mps_arena_create()</span></tt></a>. The
arguments to <a class="reference internal" href="../topic/arena.html#mps_arena_create" title="mps_arena_create"><tt class="xref c c-func docutils literal"><span class="pre">mps_arena_create()</span></tt></a> are class-dependent.</p>
<p><span class="target" id="design.mps.arena.class.init"></span><a class="mpstag reference internal" href="#design.mps.arena.class.init">.class.init:</a> However, the generic <tt class="xref c c-func docutils literal"><span class="pre">ArenaInit()</span></tt> is called from the
class-specific method, rather than vice versa, because the method is
responsible for allocating the memory for the arena descriptor and the
arena lock in the first place. Likewise, <tt class="xref c c-func docutils literal"><span class="pre">ArenaFinish()</span></tt> is called
from the finish method.</p>
<p><span class="target" id="design.mps.arena.class.fields"></span><a class="mpstag reference internal" href="#design.mps.arena.class.fields">.class.fields:</a> The <tt class="docutils literal"><span class="pre">alignment</span></tt> (for tract allocations) and
<tt class="docutils literal"><span class="pre">zoneShift</span></tt> (for computing zone sizes and what zone an address is
in) fields in the arena are the responsibility of the each class, and
are initialized by the <tt class="docutils literal"><span class="pre">init</span></tt> method. The responsibility for
maintaining the <tt class="docutils literal"><span class="pre">commitLimit</span></tt>, <tt class="docutils literal"><span class="pre">spareCommitted</span></tt>, and
<tt class="docutils literal"><span class="pre">spareCommitLimit</span></tt> fields is shared between the (generic) arena and
the arena class. <tt class="docutils literal"><span class="pre">commitLimit</span></tt> (see <a class="reference internal" href="#design.mps.arena.commit-limit">.commit-limit</a>) is changed by
the generic arena code, but arena classes are responsible for ensuring
the semantics. For <tt class="docutils literal"><span class="pre">spareCommitted</span></tt> and <tt class="docutils literal"><span class="pre">spareCommitLimit</span></tt> see
<a class="reference internal" href="#design.mps.arena.spare-committed">.spare-committed</a> below.</p>
<p><span class="target" id="design.mps.arena.class.abstract"></span><a class="mpstag reference internal" href="#design.mps.arena.class.abstract">.class.abstract:</a> The basic arena class (<tt class="xref c c-type docutils literal"><span class="pre">AbstractArenaClass</span></tt>) is
abstract and must not be instantiated. It provides little useful
behaviour, and exists primarily as the root of the tree of arena
classes. Each concrete class must specialize each of the class method
fields, with the exception of the describe method (which has a trivial
implementation) and the <tt class="docutils literal"><span class="pre">extend</span></tt>, <tt class="docutils literal"><span class="pre">retract</span></tt> and
<tt class="docutils literal"><span class="pre">spareCommitExceeded</span></tt> methods which have non-callable methods for
the benefit of arena classes which don&#8217;t implement these features.</p>
<p><span class="target" id="design.mps.arena.class.abstract.null"></span><a class="mpstag reference internal" href="#design.mps.arena.class.abstract.null">.class.abstract.null:</a> The abstract class does not provide dummy
implementations of those methods which must be overridden. Instead
each abstract method is initialized to <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt>.</p>
</div>
<div class="section" id="tracts">
<h3>1.5.3. Tracts<a class="headerlink" href="#tracts" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.tract"></span><a class="mpstag reference internal" href="#design.mps.arena.tract">.tract:</a> The arena allocation function <tt class="xref c c-func docutils literal"><span class="pre">ArenaAlloc()</span></tt> allocates a
block of memory to pools, of a size which is aligned to the arena
alignment. Each alignment unit (grain) of allocation is represented by
a tract. Tracts are the hook on which the segment module is
implemented. Pools which don&#8217;t use segments may use tracts for
associating their own data with each allocation grain.</p>
<p><span class="target" id="design.mps.arena.tract.structure"></span><a class="mpstag reference internal" href="#design.mps.arena.tract.structure">.tract.structure:</a> The tract structure definition looks like this:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">TractStruct</span> <span class="p">{</span> <span class="cm">/* Tract structure */</span>
  <span class="n">Pool</span> <span class="n">pool</span><span class="p">;</span>   <span class="cm">/* MUST BE FIRST (design.mps.arena.tract.field.pool) */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>                    <span class="cm">/* pointer for use of owning pool */</span>
  <span class="n">Addr</span> <span class="n">base</span><span class="p">;</span>                  <span class="cm">/* Base address of the tract */</span>
  <span class="n">TraceSet</span> <span class="n">white</span> <span class="o">:</span> <span class="n">TRACE_MAX</span><span class="p">;</span> <span class="cm">/* traces for which tract is white */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hasSeg</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* does tract have a seg in p?  */</span>
<span class="p">}</span> <span class="n">TractStruct</span><span class="p">;</span>
</pre></div>
</div>
<p><span class="target" id="design.mps.arena.tract.field.pool"></span><a class="mpstag reference internal" href="#design.mps.arena.tract.field.pool">.tract.field.pool:</a> The pool field indicates to which pool the tract
has been allocated (<a class="reference internal" href="#design.mps.arena.req.fun.trans.pool">.req.fun.trans.pool</a>). Tracts are only valid
when they are allocated to pools. When tracts are not allocated to
pools, arena classes are free to reuse tract objects in undefined
ways. A standard technique is for arena class implementations to
internally describe the objects as a union type of <tt class="xref c c-type docutils literal"><span class="pre">TractStruct</span></tt> and
some private representation, and to set the pool field to <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt>
when the tract is not allocated. The pool field must come first so
that the private representation can share a common prefix with
<tt class="xref c c-type docutils literal"><span class="pre">TractStruct</span></tt>. This permits arena classes to determine from their
private representation whether such an object is allocated or not,
without requiring an extra field.</p>
<p><span class="target" id="design.mps.arena.tract.field.p"></span><a class="mpstag reference internal" href="#design.mps.arena.tract.field.p">.tract.field.p:</a> The <tt class="docutils literal"><span class="pre">p</span></tt> field is used by pools to associate tracts
with other data (<a class="reference internal" href="#design.mps.arena.req.fun.trans.arbitrary">.req.fun.trans.arbitrary</a>). It&#8217;s used by the
segment module to indicate which segment a tract belongs to. If a pool
doesn&#8217;t use segments it may use the <tt class="docutils literal"><span class="pre">p</span></tt> field for its own purposes.
This field has the non-specific type <tt class="docutils literal"><span class="pre">(void</span> <span class="pre">*)</span></tt> so that pools can
use it for any purpose.</p>
<p><span class="target" id="design.mps.arena.tract.field.hasSeg"></span><a class="mpstag reference internal" href="#design.mps.arena.tract.field.hasSeg">.tract.field.hasSeg:</a> The <tt class="docutils literal"><span class="pre">hasSeg</span></tt> bit-field is a Boolean which
indicates whether the <tt class="docutils literal"><span class="pre">p</span></tt> field is being used by the segment module.
If this field is <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt>, then the value of <tt class="docutils literal"><span class="pre">p</span></tt> is a <a class="reference internal" href="seg.html#Seg" title="Seg"><tt class="xref c c-type docutils literal"><span class="pre">Seg</span></tt></a>.
<tt class="docutils literal"><span class="pre">hasSeg</span></tt> is typed as an <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt>, rather than a <a class="reference internal" href="type.html#Bool" title="Bool"><tt class="xref c c-type docutils literal"><span class="pre">Bool</span></tt></a>.
This ensures that there won&#8217;t be sign conversion problems when
converting the bit-field value.</p>
<p><span class="target" id="design.mps.arena.tract.field.base"></span><a class="mpstag reference internal" href="#design.mps.arena.tract.field.base">.tract.field.base:</a> The base field contains the base address of the
memory represented by the tract.</p>
<p><span class="target" id="design.mps.arena.tract.field.white"></span><a class="mpstag reference internal" href="#design.mps.arena.tract.field.white">.tract.field.white:</a> The white bit-field indicates for which traces
the tract is white (<a class="reference internal" href="#design.mps.arena.req.fun.trans.white">.req.fun.trans.white</a>). This information is also
stored in the segment, but is duplicated here for efficiency during a
call to <tt class="docutils literal"><span class="pre">TraceFix</span></tt> (see design.mps.trace.fix).</p>
<p><span class="target" id="design.mps.arena.tract.limit"></span><a class="mpstag reference internal" href="#design.mps.arena.tract.limit">.tract.limit:</a> The limit of the tract&#8217;s memory may be determined by
adding the arena alignment to the base address.</p>
<p><span class="target" id="design.mps.arena.tract.iteration"></span><a class="mpstag reference internal" href="#design.mps.arena.tract.iteration">.tract.iteration:</a> Iteration over tracts is described in
design.mps.arena.tract-iter(0).</p>
<dl class="function">
<dt id="TractOfAddr">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">TractOfAddr</tt><big>(</big>Tract<em>&nbsp;*tractReturn</em>, <a class="reference internal" href="#Arena" title="Arena">Arena</a><em>&nbsp;arena</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;addr</em><big>)</big><a class="headerlink" href="#TractOfAddr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.arena.tract.if.tractofaddr"></span><a class="mpstag reference internal" href="#design.mps.arena.tract.if.tractofaddr">.tract.if.tractofaddr:</a> The function <a class="reference internal" href="#TractOfAddr" title="TractOfAddr"><tt class="xref c c-func docutils literal"><span class="pre">TractOfAddr()</span></tt></a> finds the tract
corresponding to an address in memory. (See <a class="reference internal" href="#design.mps.arena.req.fun.trans">.req.fun.trans</a>.)</p>
<p>If <tt class="docutils literal"><span class="pre">addr</span></tt> is an address which has been allocated to some pool, then
<a class="reference internal" href="#TractOfAddr" title="TractOfAddr"><tt class="xref c c-func docutils literal"><span class="pre">TractOfAddr()</span></tt></a> returns <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt>, and sets <tt class="docutils literal"><span class="pre">*tractReturn</span></tt> to the
tract corresponding to that address. Otherwise, it returns <tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt>.
This function is similar to <tt class="xref c c-func docutils literal"><span class="pre">TractOfBaseAddr()</span></tt> (see
design.mps.arena.tract-iter.if.contig-base) but serves a more general
purpose and is less efficient.</p>
<p><span class="target" id="design.mps.arena.tract.if.TRACT_OF_ADDR"></span><a class="mpstag reference internal" href="#design.mps.arena.tract.if.TRACT_OF_ADDR">.tract.if.TRACT_OF_ADDR:</a> <tt class="xref c c-func docutils literal"><span class="pre">TRACT_OF_ADDR()</span></tt> is a macro version of
<a class="reference internal" href="#TractOfAddr" title="TractOfAddr"><tt class="xref c c-func docutils literal"><span class="pre">TractOfAddr()</span></tt></a>. It&#8217;s provided for efficiency during a call to
<tt class="xref c c-func docutils literal"><span class="pre">TraceFix()</span></tt> (see design.mps.trace.fix.tractofaddr).</p>
</div>
<div class="section" id="control-pool">
<h3>1.5.4. Control pool<a class="headerlink" href="#control-pool" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.pool"></span><a class="mpstag reference internal" href="#design.mps.arena.pool">.pool:</a> Each arena has a &#8220;control pool&#8221;,
<tt class="docutils literal"><span class="pre">arena-&gt;controlPoolStruct</span></tt>, which is used for allocating MPS control
data structures by calling <tt class="xref c c-func docutils literal"><span class="pre">ControlAlloc()</span></tt>.</p>
</div>
<div class="section" id="polling">
<h3>1.5.5. Polling<a class="headerlink" href="#polling" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.poll"></span><a class="mpstag reference internal" href="#design.mps.arena.poll">.poll:</a> <tt class="xref c c-func docutils literal"><span class="pre">ArenaPoll()</span></tt> is called &#8220;often&#8221; by other code (for instance,
on buffer fill or allocation). It is the entry point for doing tracing
work. If the polling clock exceeds a set threshold, and we&#8217;re not
already doing some tracing work (that is, <tt class="docutils literal"><span class="pre">insidePoll</span></tt> is not set),
it calls <tt class="xref c c-func docutils literal"><span class="pre">TracePoll()</span></tt> on all busy traces.</p>
<p><span class="target" id="design.mps.arena.poll.size"></span><a class="mpstag reference internal" href="#design.mps.arena.poll.size">.poll.size:</a> The actual clock is <tt class="docutils literal"><span class="pre">arena-&gt;fillMutatorSize</span></tt>. This is
because internal allocation is only significant when copy segments are
being allocated, and we don&#8217;t want to have the pause times to shrink
because of that. There is no current requirement for the trace rate to
guard against running out of memory. [Clearly it really ought to: we
have a requirement to not run out of memory (see
req.dylan.prot.fail-alloc, req.dylan.prot.consult), and emergency
tracing should not be our only story. drj 1999-06-22] <tt class="docutils literal"><span class="pre">BufferEmpty</span></tt>
is not taken into account, because the splinter will rarely be useable
for allocation and we are wary of the clock running backward.</p>
<p><span class="target" id="design.mps.arena.poll.clamp"></span><a class="mpstag reference internal" href="#design.mps.arena.poll.clamp">.poll.clamp:</a> Polling is disabled when the arena is &#8220;clamped&#8221;, in
which case <tt class="docutils literal"><span class="pre">arena-&gt;clamped</span></tt> is <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt>. Clamping the arena prevents
background tracing work, and further new garbage collections from
starting. Clamping and releasing are implemented by the <tt class="xref c c-func docutils literal"><span class="pre">ArenaClamp()</span></tt>
and <tt class="xref c c-func docutils literal"><span class="pre">ArenaRelease()</span></tt> methods.</p>
<p><span class="target" id="design.mps.arena.poll.park"></span><a class="mpstag reference internal" href="#design.mps.arena.poll.park">.poll.park:</a> The arena is &#8220;parked&#8221; by clamping it, then polling until
there are no active traces. This finishes all the active collections
and prevents further collection. Parking is implemented by the
<tt class="xref c c-func docutils literal"><span class="pre">ArenaPark()</span></tt> method.</p>
</div>
<div class="section" id="commit-limit">
<h3>1.5.6. Commit limit<a class="headerlink" href="#commit-limit" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.commit-limit"></span><a class="mpstag reference internal" href="#design.mps.arena.commit-limit">.commit-limit:</a> The arena supports a client configurable &#8220;commit
limit&#8221; which is a limit on the total amount of committed memory. The
generic arena structure contains a field to hold the value of the
commit limit and the implementation provides two functions for
manipulating it: <tt class="xref c c-func docutils literal"><span class="pre">ArenaCommitLimit()</span></tt> to read it, and
<tt class="xref c c-func docutils literal"><span class="pre">ArenaSetCommitLimit()</span></tt> to set it. Actually abiding by the contract of
not committing more memory than the commit limit is left up to the
individual arena classes.</p>
<p><span class="target" id="design.mps.arena.commit-limit.err"></span><a class="mpstag reference internal" href="#design.mps.arena.commit-limit.err">.commit-limit.err:</a> When allocation from the arena would otherwise
succeed but cause the MPS to use more committed memory than specified
by the commit limit <tt class="xref c c-func docutils literal"><span class="pre">ArenaAlloc()</span></tt> should refuse the request and
return <tt class="docutils literal"><span class="pre">ResCOMMIT_LIMIT</span></tt>.</p>
<p><span class="target" id="design.mps.arena.commit-limit.err.multi"></span><a class="mpstag reference internal" href="#design.mps.arena.commit-limit.err.multi">.commit-limit.err.multi:</a> In the case where an <tt class="xref c c-func docutils literal"><span class="pre">ArenaAlloc()</span></tt> request
cannot be fulfilled for more than one reason including exceeding the
commit limit then class implementations should strive to return a
result code other than <tt class="docutils literal"><span class="pre">ResCOMMIT_LIMIT</span></tt>. That is,
<tt class="docutils literal"><span class="pre">ResCOMMIT_LIMIT</span></tt> should only be returned if the <em>only</em> reason for
failing the <tt class="xref c c-func docutils literal"><span class="pre">ArenaAlloc()</span></tt> request is that the commit limit would be
exceeded. The client documentation allows implementations to be
ambiguous with respect to which result code in returned in such a
situation however.</p>
</div>
<div class="section" id="spare-committed-aka-hysteresis">
<h3>1.5.7. Spare committed (aka &#8220;hysteresis&#8221;)<a class="headerlink" href="#spare-committed-aka-hysteresis" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.spare-committed"></span><a class="mpstag reference internal" href="#design.mps.arena.spare-committed">.spare-committed:</a> See <a class="reference internal" href="../topic/arena.html#mps_arena_spare_committed" title="mps_arena_spare_committed"><tt class="xref c c-func docutils literal"><span class="pre">mps_arena_spare_committed()</span></tt></a>. The generic
arena structure contains two fields for the spare committed memory
fund: <tt class="docutils literal"><span class="pre">spareCommitted</span></tt> records the total number of spare committed
bytes; <tt class="docutils literal"><span class="pre">spareCommitLimit</span></tt> records the limit (set by the user) on the
amount of spare committed memory. <tt class="docutils literal"><span class="pre">spareCommitted</span></tt> is modified by
the arena class but its value is used by the generic arena code. There
are two uses: a getter function for this value is provided through the
MPS interface (<a class="reference internal" href="../topic/arena.html#mps_arena_spare_commit_limit_set" title="mps_arena_spare_commit_limit_set"><tt class="xref c c-func docutils literal"><span class="pre">mps_arena_spare_commit_limit_set()</span></tt></a>), and by the
<tt class="xref c c-func docutils literal"><span class="pre">SetSpareCommitLimit()</span></tt> function to determine whether the amount of
spare committed memory needs to be reduced. <tt class="docutils literal"><span class="pre">spareCommitLimit</span></tt> is
manipulated by generic arena code, however the associated semantics
are the responsibility of the class. It is the class&#8217;s responsibility
to ensure that it doesn&#8217;t use more spare committed bytes than the
value in <tt class="docutils literal"><span class="pre">spareCommitLimit</span></tt>.</p>
<p><span class="target" id="design.mps.arena.spare-commit-limit"></span><a class="mpstag reference internal" href="#design.mps.arena.spare-commit-limit">.spare-commit-limit:</a> The function <tt class="xref c c-func docutils literal"><span class="pre">ArenaSetSpareCommitLimit()</span></tt> sets
the <tt class="docutils literal"><span class="pre">spareCommitLimit</span></tt> field. If the limit is set to a value lower
than the amount of spare committed memory (stored in
<tt class="docutils literal"><span class="pre">spareCommitted</span></tt>) then the class specific function
<tt class="docutils literal"><span class="pre">spareCommitExceeded</span></tt> is called.</p>
</div>
<div class="section" id="locks">
<h3>1.5.8. Locks<a class="headerlink" href="#locks" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.lock.ring"></span><a class="mpstag reference internal" href="#design.mps.arena.lock.ring">.lock.ring:</a> <tt class="xref c c-func docutils literal"><span class="pre">ArenaAccess()</span></tt> is called when we fault on a barrier.
The first thing it does is claim the non-recursive global lock to
protect the arena ring (see design.mps.lock(0)).</p>
<p><span class="target" id="design.mps.arena.lock.arena"></span><a class="mpstag reference internal" href="#design.mps.arena.lock.arena">.lock.arena:</a> After the arena ring lock is claimed, <tt class="xref c c-func docutils literal"><span class="pre">ArenaEnter()</span></tt> is
called on one or more arenas. This claims the lock for that arena.
When the correct arena is identified or we run out of arenas, the lock
on the ring is released.</p>
<p><span class="target" id="design.mps.arena.lock.avoid"></span><a class="mpstag reference internal" href="#design.mps.arena.lock.avoid">.lock.avoid:</a> Deadlocking is avoided as described below:</p>
<p><span class="target" id="design.mps.arena.lock.avoid.mps"></span><a class="mpstag reference internal" href="#design.mps.arena.lock.avoid.mps">.lock.avoid.mps:</a> Firstly we require the MPS not to fault (that is,
when any of these locks are held by a thread, that thread does not
fault).</p>
<p><span class="target" id="design.mps.arena.lock.avoid.thread"></span><a class="mpstag reference internal" href="#design.mps.arena.lock.avoid.thread">.lock.avoid.thread:</a> Secondly, we require that in a multi-threaded
system, memory fault handlers do not suspend threads (although the
faulting thread will, of course, wait for the fault handler to
finish).</p>
<p><span class="target" id="design.mps.arena.lock.avoid.conflict"></span><a class="mpstag reference internal" href="#design.mps.arena.lock.avoid.conflict">.lock.avoid.conflict:</a> Thirdly, we avoid conflicting deadlock between
the arena and global locks by ensuring we never claim the arena lock
when the recursive global lock is already held, and we never claim the
binary global lock when the arena lock is held.</p>
</div>
<div class="section" id="location-dependencies">
<h3>1.5.9. Location dependencies<a class="headerlink" href="#location-dependencies" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.ld"></span><a class="mpstag reference internal" href="#design.mps.arena.ld">.ld:</a> Location dependencies use fields in the arena to maintain a
history of summaries of moved objects, and to keep a notion of time,
so that the staleness of location dependency can be determined.</p>
</div>
<div class="section" id="finalization">
<h3>1.5.10. Finalization<a class="headerlink" href="#finalization" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.final"></span><a class="mpstag reference internal" href="#design.mps.arena.final">.final:</a> There is a pool which is optionally (and dynamically)
instantiated to implement finalization. The fields <tt class="docutils literal"><span class="pre">finalPool</span></tt> and
<tt class="docutils literal"><span class="pre">isFinalPool</span></tt> are used.</p>
</div>
</div>
<div class="section" id="implementation">
<h2>1.6. Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="tract-cache">
<h3>1.6.1. Tract cache<a class="headerlink" href="#tract-cache" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.tract.cache"></span><a class="mpstag reference internal" href="#design.mps.arena.tract.cache">.tract.cache:</a> When tracts are allocated to pools by <tt class="xref c c-func docutils literal"><span class="pre">ArenaAlloc()</span></tt>,
the first tract of the block and it&#8217;s base address are cached in arena
fields <tt class="docutils literal"><span class="pre">lastTract</span></tt> and <tt class="docutils literal"><span class="pre">lastTractBase</span></tt>. The function
<tt class="xref c c-func docutils literal"><span class="pre">TractOfBaseAddr()</span></tt> (see design.mps.arena.tract-iter.if.block-base(0))
checks against these cached values and only calls the class method on
a cache miss. This optimizes for the common case where a pool
allocates a block and then iterates over all its tracts (for example,
to attach them to a segment).</p>
<p><span class="target" id="design.mps.arena.tract.uncache"></span><a class="mpstag reference internal" href="#design.mps.arena.tract.uncache">.tract.uncache:</a> When blocks of memory are freed by pools,
<tt class="xref c c-func docutils literal"><span class="pre">ArenaFree()</span></tt> checks to see if the cached value for the most recently
allocated tract (see <a class="reference internal" href="#design.mps.arena.tract.cache">.tract.cache</a>) is being freed. If so, the cache
is invalid, and must be reset. The <tt class="docutils literal"><span class="pre">lastTract</span></tt> and <tt class="docutils literal"><span class="pre">lastTractBase</span></tt>
fields are set to <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt>.</p>
</div>
<div class="section" id="id1">
<h3>1.6.2. Control pool<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.pool.init"></span><a class="mpstag reference internal" href="#design.mps.arena.pool.init">.pool.init:</a> The control pool is initialized by a call to
<tt class="xref c c-func docutils literal"><span class="pre">PoolInit()</span></tt> during <tt class="xref c c-func docutils literal"><span class="pre">ArenaCreate()</span></tt>.</p>
<p><span class="target" id="design.mps.arena.pool.ready"></span><a class="mpstag reference internal" href="#design.mps.arena.pool.ready">.pool.ready:</a> All the other fields in the arena are made checkable
before calling <tt class="xref c c-func docutils literal"><span class="pre">PoolInit()</span></tt>, so <tt class="xref c c-func docutils literal"><span class="pre">PoolInit()</span></tt> can call
<tt class="docutils literal"><span class="pre">ArenaCheck(arena)</span></tt>. The pool itself is, of course, not checkable,
so we have a field <tt class="docutils literal"><span class="pre">arena-&gt;poolReady</span></tt>, which is false until after
the return from <tt class="xref c c-func docutils literal"><span class="pre">PoolInit()</span></tt>. <tt class="xref c c-func docutils literal"><span class="pre">ArenaCheck()</span></tt> only checks the pool if
<tt class="docutils literal"><span class="pre">poolReady</span></tt>.</p>
</div>
<div class="section" id="traces">
<h3>1.6.3. Traces<a class="headerlink" href="#traces" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.trace"></span><a class="mpstag reference internal" href="#design.mps.arena.trace">.trace:</a> <tt class="docutils literal"><span class="pre">arena-&gt;trace[ti]</span></tt> is valid if and only if
<tt class="docutils literal"><span class="pre">TraceSetIsMember(arena-&gt;busyTraces,</span> <span class="pre">ti)</span></tt>.</p>
<p><span class="target" id="design.mps.arena.trace.create"></span><a class="mpstag reference internal" href="#design.mps.arena.trace.create">.trace.create:</a> Since the arena created by <tt class="xref c c-func docutils literal"><span class="pre">ArenaCreate()</span></tt> has
<tt class="docutils literal"><span class="pre">arena-&gt;busyTraces</span> <span class="pre">=</span> <span class="pre">TraceSetEMPTY</span></tt>, none of the traces are
meaningful.</p>
<p><span class="target" id="design.mps.arena.trace.invalid"></span><a class="mpstag reference internal" href="#design.mps.arena.trace.invalid">.trace.invalid:</a> Invalid traces have signature <tt class="docutils literal"><span class="pre">SigInvalid</span></tt>, which
can be checked.</p>
</div>
<div class="section" id="id2">
<h3>1.6.4. Polling<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.poll.fields"></span><a class="mpstag reference internal" href="#design.mps.arena.poll.fields">.poll.fields:</a> There are three fields of a arena used for polling:
<tt class="docutils literal"><span class="pre">pollThreshold</span></tt>, <tt class="docutils literal"><span class="pre">insidePoll</span></tt>, and <tt class="docutils literal"><span class="pre">clamped</span></tt> (see above).
<tt class="docutils literal"><span class="pre">pollThreshold</span></tt> is the threshold for the next poll: it is set at the
end of <tt class="xref c c-func docutils literal"><span class="pre">ArenaPoll()</span></tt> to the current polling time plus
<tt class="xref c c-macro docutils literal"><span class="pre">ARENA_POLL_MAX</span></tt>.</p>
</div>
<div class="section" id="id3">
<h3>1.6.5. Location dependencies<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.ld.epoch"></span><a class="mpstag reference internal" href="#design.mps.arena.ld.epoch">.ld.epoch:</a> <tt class="docutils literal"><span class="pre">arena-&gt;epoch</span></tt> is the &#8220;current epoch&#8221;. This is the
number of &#8216;flips&#8217; of traces in the arena since the arena was created.
From the mutator&#8217;s point of view locations change atomically at flip.</p>
<p><span class="target" id="design.mps.arena.ld.history"></span><a class="mpstag reference internal" href="#design.mps.arena.ld.history">.ld.history:</a> <tt class="docutils literal"><span class="pre">arena-&gt;history</span></tt> is an array of <tt class="xref c c-macro docutils literal"><span class="pre">ARENA_LD_LENGTH</span></tt>
elements of type <tt class="docutils literal"><span class="pre">RefSet</span></tt>. These are the summaries of moved objects
since the last <tt class="xref c c-macro docutils literal"><span class="pre">ARENA_LD_LENGTH</span></tt> epochs. If <tt class="docutils literal"><span class="pre">e</span></tt> is one of these
recent epochs, then</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">arena</span><span class="o">-&gt;</span><span class="n">history</span><span class="p">[</span><span class="n">e</span> <span class="o">%</span> <span class="n">ARENA_LD_LENGTH</span><span class="p">]</span>
</pre></div>
</div>
<p>is a summary of (the original locations of) objects moved since epoch
<tt class="docutils literal"><span class="pre">e</span></tt>.</p>
<p><span class="target" id="design.mps.arena.ld.prehistory"></span><a class="mpstag reference internal" href="#design.mps.arena.ld.prehistory">.ld.prehistory:</a> <tt class="docutils literal"><span class="pre">arena-&gt;prehistory</span></tt> is a <tt class="docutils literal"><span class="pre">RefSet</span></tt> summarizing
the original locations of all objects ever moved. When considering
whether a really old location dependency is stale, it is compared with
this summary.</p>
</div>
<div class="section" id="roots">
<h3>1.6.6. Roots<a class="headerlink" href="#roots" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.root-ring"></span><a class="mpstag reference internal" href="#design.mps.arena.root-ring">.root-ring:</a> The arena holds a member of a ring of roots in the
arena. It holds an incremental serial which is the serial of the next
root.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">1. Arena</a><ul>
<li><a class="reference internal" href="#introduction">1.1. Introduction</a></li>
<li><a class="reference internal" href="#overview">1.2. Overview</a></li>
<li><a class="reference internal" href="#definitions">1.3. Definitions</a></li>
<li><a class="reference internal" href="#requirements">1.4. Requirements</a><ul>
<li><a class="reference internal" href="#block-management">1.4.1. Block management</a></li>
<li><a class="reference internal" href="#address-translation">1.4.2. Address translation</a></li>
<li><a class="reference internal" href="#iteration-protocol">1.4.3. Iteration protocol</a></li>
<li><a class="reference internal" href="#arena-partition">1.4.4. Arena partition</a></li>
<li><a class="reference internal" href="#constraints">1.4.5. Constraints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#architecture">1.5. Architecture</a><ul>
<li><a class="reference internal" href="#statics">1.5.1. Statics</a></li>
<li><a class="reference internal" href="#arena-classes">1.5.2. Arena classes</a></li>
<li><a class="reference internal" href="#tracts">1.5.3. Tracts</a></li>
<li><a class="reference internal" href="#control-pool">1.5.4. Control pool</a></li>
<li><a class="reference internal" href="#polling">1.5.5. Polling</a></li>
<li><a class="reference internal" href="#commit-limit">1.5.6. Commit limit</a></li>
<li><a class="reference internal" href="#spare-committed-aka-hysteresis">1.5.7. Spare committed (aka &#8220;hysteresis&#8221;)</a></li>
<li><a class="reference internal" href="#locks">1.5.8. Locks</a></li>
<li><a class="reference internal" href="#location-dependencies">1.5.9. Location dependencies</a></li>
<li><a class="reference internal" href="#finalization">1.5.10. Finalization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">1.6. Implementation</a><ul>
<li><a class="reference internal" href="#tract-cache">1.6.1. Tract cache</a></li>
<li><a class="reference internal" href="#id1">1.6.2. Control pool</a></li>
<li><a class="reference internal" href="#traces">1.6.3. Traces</a></li>
<li><a class="reference internal" href="#id2">1.6.4. Polling</a></li>
<li><a class="reference internal" href="#id3">1.6.5. Location dependencies</a></li>
<li><a class="reference internal" href="#roots">1.6.6. Roots</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="old.html"
                        title="previous chapter">Old design</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="bt.html"
                        title="next chapter">2. Bit tables</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="bt.html" title="2. Bit tables"
             >next</a> |</li>
        <li class="right" >
          <a href="old.html" title="Old design"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" >Old design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>