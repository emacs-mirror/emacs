

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>26. MRG pool class &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Old design" href="old.html" />
    <link rel="next" title="27. MV pool class" href="poolmv.html" />
    <link rel="prev" title="25. MFS pool class" href="poolmfs.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="poolmv.html" title="27. MV pool class"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="poolmfs.html" title="25. MFS pool class"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" accesskey="U">Old design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="mrg-pool-class">
<span id="design-poolmrg"></span><span id="index-0"></span><h1>26. MRG pool class<a class="headerlink" href="#mrg-pool-class" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="design.mps.poolmrg"></span><h2>26.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolmrg.readership"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.readership">.readership:</a> Any MPS developer.</p>
<p><span class="target" id="design.mps.poolmrg.intro"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.intro">.intro:</a> This is the design of the MRG (Manual Rank Guardian) pool
class. The MRG pool class is part of the MPS. The MRG pool class is
internal to the MPS (has no client interface) and is used to implement
finalization.</p>
<p><span class="target" id="design.mps.poolmrg.source"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.source">.source:</a> Some of the techniques in paper.dbe93 (&#8220;Guardians in a
Generation-Based Garbage Collector&#8221;) were used in this design. Some
analysis of this design (including various improvements and some more
in-depth justification) is in analysis.mps.poolmrg. That document
should be understood before changing this document. It is also helpful
to look at design.mps.finalize and design.mps.message.</p>
</div>
<div class="section" id="goals">
<h2>26.2. Goals<a class="headerlink" href="#goals" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolmrg.goal.final"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.goal.final">.goal.final:</a> The MRG pool class should support all
requirements pertaining to finalization.</p>
</div>
<div class="section" id="requirements">
<h2>26.3. Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolmrg.req"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.req">.req:</a> We have only one requirement pertaining to finalization:</p>
<p><span class="target" id="design.mps.poolmrg.req.dylan.fun.finalization"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.req.dylan.fun.finalization">.req.dylan.fun.finalization:</a> Support the Dylan language-level
implementation of finalized objects: objects are registered, and are
finalized in random order when they would otherwise have died. Cycles
are broken at random places. There is no guarantee of promptness.</p>
<p><span class="target" id="design.mps.poolmrg.req.general"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.req.general">.req.general:</a> However, finalization is a very common piece of
functionality that is provided by (sophisticated) memory managers, so
we can expect other clients to request this sort of functionality.</p>
<p><span class="target" id="design.mps.poolmrg.anti-req"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.anti-req">.anti-req:</a> Is it required that the MRG pool class return
unused segments to the arena? MFS, for example, does not do this. MRG
will not do this in its initial implementation.</p>
</div>
<div class="section" id="terminology">
<h2>26.4. Terminology<a class="headerlink" href="#terminology" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolmrg.def.mrg"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.def.mrg">.def.mrg:</a> <strong>MRG</strong>: The MRG pool class&#8217;s identifier will be MRG.
This stands for &#8220;Manual Rank Guardian&#8221;. The pool is manually managed
and implements guardians for references of a particular rank
(currently just final).</p>
<p><span class="target" id="design.mps.poolmrg.def.final.ref"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.def.final.ref">.def.final.ref:</a> <strong>final reference</strong>: A reference of rank final (see
design.mps.type.rank).</p>
<p><span class="target" id="design.mps.poolmrg.def.final.object"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.def.final.object">.def.final.object:</a> <strong>finalizable object</strong>: An object is finalizable
with respect to a final reference if, since the creation of that
reference, there was a point in time when no references to the object
of lower (that is, stronger) rank were reachable from a root.</p>
<p><span class="target" id="design.mps.poolmrg.def.final.object.note"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.def.final.object.note">.def.final.object.note:</a> Note that this means an object can be
finalizable even if it is now reachable from the root via exact
references.</p>
<p><span class="target" id="design.mps.poolmrg.def.finalize"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.def.finalize">.def.finalize:</a> <strong>finalize</strong>: To finalize an object is to notify the
client that the object is finalizable. The client is presumed to be
interested in this information (typically it will apply some method to
the object).</p>
<p><span class="target" id="design.mps.poolmrg.def.guardian"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.def.guardian">.def.guardian:</a> <strong>guardian</strong>: An object allocated in the MRG
Pool. A guardian contains exactly one final reference, and some fields
for the pool&#8217;s internal use. Guardians are used to implement a
finalization mechanism.</p>
</div>
<div class="section" id="overview">
<h2>26.5. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolmrg.over"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over">.over:</a> The MRG pool class is a pool class in the MPS. It is
intended to provide the functionality of &#8220;finalization&#8221;.</p>
<p><span class="target" id="design.mps.poolmrg.over.internal"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.internal">.over.internal:</a> The MRG pool class is internal to the MPM: it
is not intended to have a client interface. Clients are expected to
access the functionality provided by this pool (finalization) using a
separate MPS finalization interface (design.mps.finalize).</p>
<p><span class="target" id="design.mps.poolmrg.over.one-size"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.one-size">.over.one-size:</a> The MRG pool class manages objects of a single
size, each object containing a single reference of rank final.</p>
<p><span class="target" id="design.mps.poolmrg.over.one-size.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.one-size.justify">.over.one-size.justify:</a> This is all that is necessary to meet our
requirements for finalization. Whenever an object is registered for
finalization, it is sufficient to create a single reference of rank
final to it.</p>
<p><span class="target" id="design.mps.poolmrg.over.queue"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.queue">.over.queue:</a> A pool maintains a list of live guardian objects,
called (for historical reasons) the &#8220;entry&#8221; list.</p>
<p><span class="target" id="design.mps.poolmrg.over.queue.free"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.queue.free">.over.queue.free:</a> The pool also maintains a list of free guardian
objects called the &#8220;free&#8221; list.</p>
<p><span class="target" id="design.mps.poolmrg.over.queue.exit.not"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.queue.exit.not">.over.queue.exit.not:</a> There used to be an &#8220;exit&#8221; list, but this is
now historical and there shouldn&#8217;t be any current references to it.</p>
<p><span class="target" id="design.mps.poolmrg.over.alloc"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.alloc">.over.alloc:</a> When guardians are allocated, they are placed on the
entry list. Guardians on the entry list refer to objects that have not
yet been shown to be finalizable (either the object has references of
lower rank than final to it, or the MPS has not yet got round to
determining that the object is finalizable).</p>
<p><span class="target" id="design.mps.poolmrg.over.message.create"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.message.create">.over.message.create:</a> When a guardian is discovered to refer to a
finalizable object it is removed from the entry list and becomes a
message on the arena&#8217;s messages queue.</p>
<p><span class="target" id="design.mps.poolmrg.over.message.deliver"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.message.deliver">.over.message.deliver:</a> When the MPS client receives the message the
message system arranges for the message to be destroyed and the pool
reclaims the storage associated with the guardian/message.</p>
<p><span class="target" id="design.mps.poolmrg.over.scan"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.scan">.over.scan:</a> When the pool is scanned at rank final each reference
will be fixed. If the reference is to an unmarked object (before the
fix), then the object must now be finalizable. In this case the
containing guardian will be removed from the entry list and posted as
a message.</p>
<p><span class="target" id="design.mps.poolmrg.over.scan.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.scan.justify">.over.scan.justify:</a> The scanning process is a crucial step
necessary for implementing finalization. It is the means by which the
MPS detects that objects are finalizable.</p>
<p><span class="target" id="design.mps.poolmrg.over.message"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.message">.over.message:</a> <tt class="docutils literal"><span class="pre">PoolClassMRG</span></tt> implements a <a class="reference internal" href="message.html#MessageClass" title="MessageClass"><tt class="xref c c-type docutils literal"><span class="pre">MessageClass</span></tt></a> (see
design.mps.message). All the messages are of one <tt class="docutils literal"><span class="pre">MessageType</span></tt>. This
type is <tt class="docutils literal"><span class="pre">MessageTypeFinalization</span></tt>. Messages are created when objects
are discovered to be finalizable and destroyed when the MPS client has
received the message.</p>
<p><span class="target" id="design.mps.poolmrg.over.message.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.message.justify">.over.message.justify:</a> Messages provide a means for the MPS to
communicate with its client. Notification of finalization is just such
a communication. Messages allow the MPS to inform the client of
finalization events when it is convenient for the MPS to do so (i.e.
not in PageFault context).</p>
<p><span class="target" id="design.mps.poolmrg.over.manual"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.manual">.over.manual:</a> Objects in the MRG pool are manually managed.</p>
<p><span class="target" id="design.mps.poolmrg.over.manual.alloc"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.manual.alloc">.over.manual.alloc:</a> They are allocated by <a class="reference internal" href="finalize.html#ArenaFinalize" title="ArenaFinalize"><tt class="xref c c-func docutils literal"><span class="pre">ArenaFinalize()</span></tt></a> when
objects are registered for finalization.</p>
<p><span class="target" id="design.mps.poolmrg.over.manual.free"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.manual.free">.over.manual.free:</a> They are freed when the associated message is
destroyed.</p>
<p><span class="target" id="design.mps.poolmrg.over.manual.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.over.manual.justify">.over.manual.justify:</a> The lifetime of a guardian object is very
easy to determine so manual memory management is appropriate.</p>
</div>
<div class="section" id="protocols">
<h2>26.6. Protocols<a class="headerlink" href="#protocols" title="Permalink to this headline">¶</a></h2>
<div class="section" id="object-registration">
<h3>26.6.1. Object Registration<a class="headerlink" href="#object-registration" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolmrg.protocol.register"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.protocol.register">.protocol.register:</a> There is a protocol by which objects can be
registered for finalization. This protocol is handled by the arena
module on behalf of finalization. see
design.mps.finalize.int.finalize.</p>
</div>
<div class="section" id="finalizer-execution">
<h3>26.6.2. Finalizer execution<a class="headerlink" href="#finalizer-execution" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolmrg.protocol.finalizer"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.protocol.finalizer">.protocol.finalizer:</a> If an object is proven to be finalizable then
a message to this effect will eventually be posted. A client can
receive the message, determine what to do about it, and do it.
Typically this would involve calling the finalization method for the
object, and deleting the message. Once the message is deleted, the
object may become recyclable.</p>
</div>
<div class="section" id="setup-destroy">
<h3>26.6.3. Setup / destroy<a class="headerlink" href="#setup-destroy" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolmrg.protocol.life"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.protocol.life">.protocol.life:</a> An instance of PoolClassMRG is needed in order to
support finalization, it is called the &#8220;final&#8221; pool and is attached to
the arena (see design.mps.finalize.int.arena.struct).</p>
<p><span class="target" id="design.mps.poolmrg.protocol.life.birth"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.protocol.life.birth">.protocol.life.birth:</a> The final pool is created lazily by
<a class="reference internal" href="finalize.html#ArenaFinalize" title="ArenaFinalize"><tt class="xref c c-func docutils literal"><span class="pre">ArenaFinalize()</span></tt></a>.</p>
<p><span class="target" id="design.mps.poolmrg.protocol.life.death"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.protocol.life.death">.protocol.life.death:</a> The final pool is destroyed during
<tt class="xref c c-func docutils literal"><span class="pre">ArenaDestroy()</span></tt>.</p>
</div>
</div>
<div class="section" id="data-structures">
<h2>26.7. Data structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolmrg.guardian"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian">.guardian:</a> The guardian</p>
<p><span class="target" id="design.mps.poolmrg.guardian.over"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.over">.guardian.over:</a> A guardian is an object used to manage the
references and other data structures that are used by the pool in
order to keep track of which objects are registered for finalization,
which ones have been finalized, and so on.</p>
<p><span class="target" id="design.mps.poolmrg.guardian.state"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.state">.guardian.state:</a> A guardian can be in one of four states:</p>
<p><span class="target" id="design.mps.poolmrg.guardian.state.enum"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.state.enum">.guardian.state.enum:</a> The states are Free, Prefinal, Final,
PostFinal (referred to as MRGGuardianFree, etc. in the
implementation).</p>
<ol class="arabic simple">
<li><span class="target" id="design.mps.poolmrg.guardian.state.free"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.state.free">.guardian.state.free:</a> The guardian is free, meaning that it is
on the free list for the pool and available for allocation.</li>
<li><span class="target" id="design.mps.poolmrg.guardian.state.prefinal"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.state.prefinal">.guardian.state.prefinal:</a> The guardian is allocated, and refers
to an object that has not yet been discovered to be finalizable. It
is on the entry list for the pool.</li>
<li><span class="target" id="design.mps.poolmrg.guardian.state.final"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.state.final">.guardian.state.final:</a> The guardian is allocated, and refers to
an object that has been shown to be finalizable; this state
corresponds to the existence of a message.</li>
<li><span class="target" id="design.mps.poolmrg.guardian.state.postfinal"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.state.postfinal">.guardian.state.postfinal:</a> This state is only used briefly and
is entirely internal to the pool; the guardian enters this state
just after the associated message has been destroyed (which happens
when the client receives the message) and will be freed immediately
(whereupon it will enter the Free state). This state is used for
checking only (so that MRGFree can check that only guardians in
this state are being freed).</li>
</ol>
<p><span class="target" id="design.mps.poolmrg.guardian.life-cycle"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.life-cycle">.guardian.life-cycle:</a> Guardians go through the following state life-cycle: Free ⟶ Prefinal ⟶ Final ⟶ Postfinal ⟶ Free.</p>
<p><span class="target" id="design.mps.poolmrg.guardian.two-part"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.two-part">.guardian.two-part:</a> A guardian is a structure consisting abstractly
of a link part and a reference part. Concretely, the link part is a
<tt class="xref c c-type docutils literal"><span class="pre">LinkPartStruct</span></tt>, and the reference part is a <tt class="xref c c-type docutils literal"><span class="pre">RefPartStruct</span></tt>
(which is just a <a class="reference internal" href="type.html#Word" title="Word"><tt class="xref c c-type docutils literal"><span class="pre">Word</span></tt></a>). The link part is used by the pool, the
reference part forms the object visible to clients of the pool. The
reference part is the reference of <tt class="docutils literal"><span class="pre">RankFINAL</span></tt> that refers to
objects registered for finalization and is how the MPS detects
finalizable objects.</p>
<p><span class="target" id="design.mps.poolmrg.guardian.two-part.union"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.two-part.union">.guardian.two-part.union:</a> The <tt class="xref c c-type docutils literal"><span class="pre">LinkPartStruct</span></tt> is a discriminated
union of a <tt class="xref c c-type docutils literal"><span class="pre">RingStruct</span></tt> and a <a class="reference internal" href="message.html#MessageStruct" title="MessageStruct"><tt class="xref c c-type docutils literal"><span class="pre">MessageStruct</span></tt></a>. The <tt class="xref c c-type docutils literal"><span class="pre">RingStruct</span></tt>
is used when the guardian is either Free or Prefinal. The
MessageStruct is used when the guardian is Final. Neither part of the
union is used when the guardian is in the Postfinal state.</p>
<p><span class="target" id="design.mps.poolmrg.guardian.two-part.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.two-part.justify">.guardian.two-part.justify:</a> This may seem a little profligate with
space, but this is okay as we are not required to make finalization
extremely space efficient.</p>
<p><span class="target" id="design.mps.poolmrg.guardian.parts.separate"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.parts.separate">.guardian.parts.separate:</a> The two parts will be stored in separate
segments.</p>
<p><span class="target" id="design.mps.poolmrg.guardian.parts.separate.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.parts.separate.justify">.guardian.parts.separate.justify:</a> This is so that the data
structures the pool uses to manage the objects can be separated from
the objects themselves. This avoids the pool having to manipulate data
structures that are on shielded segments
(analysis.mps.poolmrg.hazard.shield).</p>
<p><span class="target" id="design.mps.poolmrg.guardian.assoc"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.assoc">.guardian.assoc:</a> Ref part number <em>n</em> (from the beginning of the
segment) in one segment will correspond with link part number <em>n</em> in
another segment. The association between the two segments will be
managed by the additional fields in pool-specific segment subclasses
(see <a class="reference internal" href="#design.mps.poolmrg.mrgseg">.mrgseg</a>).</p>
<p><span class="target" id="design.mps.poolmrg.guardian.ref"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.ref">.guardian.ref:</a> Guardians that are either Prefinal or Final are live
and have valid references (possibly <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt>) in their ref parts.
Guardians that are free are dead and always have <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt> in their ref
parts (see <a class="reference internal" href="#design.mps.poolmrg.free.overwrite">.free.overwrite</a> and <a class="reference internal" href="#design.mps.poolmrg.scan.free">.scan.free</a>).</p>
<p><span class="target" id="design.mps.poolmrg.guardian.ref.free"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.ref.free">.guardian.ref.free:</a> When freeing an object, it is a pointer to the
reference part that will be passed (internally in the pool).</p>
<p><span class="target" id="design.mps.poolmrg.guardian.init"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.guardian.init">.guardian.init:</a> Guardians are initialized when the pool is grown
(<a class="reference internal" href="#design.mps.poolmrg.alloc.grow">.alloc.grow</a>). The initial state has the ref part <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt> and the
link part is attached to the free ring. Freeing an object returns a
guardian to its initial state.</p>
<p><span class="target" id="design.mps.poolmrg.poolstruct"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.poolstruct">.poolstruct:</a> The Pool structure, <tt class="xref c c-type docutils literal"><span class="pre">MRGStruct</span></tt> will have:</p>
<ul>
<li><p class="first"><span class="target" id="design.mps.poolmrg.poolstruct.entry"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.poolstruct.entry">.poolstruct.entry:</a> the head of the entry list.</p>
</li>
<li><p class="first"><span class="target" id="design.mps.poolmrg.poolstruct.free"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.poolstruct.free">.poolstruct.free:</a> the head of the free list.</p>
</li>
<li><p class="first"><span class="target" id="design.mps.poolmrg.poolstruct.rings"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.poolstruct.rings">.poolstruct.rings:</a> The entry list, the exit list, and the free
list will each be implemented as a <a class="reference internal" href="ring.html#Ring" title="Ring"><tt class="xref c c-type docutils literal"><span class="pre">Ring</span></tt></a>. Each ring will be
maintained using the link part of the guardian.</p>
<p><span class="target" id="design.mps.poolmrg.poolstruct.rings.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.poolstruct.rings.justify">.poolstruct.rings.justify:</a> This is because rings are convenient to
use and are well tested. It is possible to implement all three lists
using a singly linked list, but the saving is certainly not worth
making at this stage.</p>
</li>
<li><p class="first"><span class="target" id="design.mps.poolmrg.poolstruct.refring"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.poolstruct.refring">.poolstruct.refring:</a> a ring of &#8220;ref&#8221; segments in use for links or
messages (see .mrgseg.ref.mrgring below).</p>
</li>
<li><p class="first"><span class="target" id="design.mps.poolmrg.poolstruct.extend"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.poolstruct.extend">.poolstruct.extend:</a> a precalculated <tt class="docutils literal"><span class="pre">extendBy</span></tt> field (see
<a class="reference internal" href="#design.mps.poolmrg.init.extend">.init.extend</a>). This value is used to determine how large a
segment should be requested from the arena for the reference part
segment when the pool needs to grow (see <a class="reference internal" href="#design.mps.poolmrg.alloc.grow.size">.alloc.grow.size</a>).</p>
<p><span class="target" id="design.mps.poolmrg.poolstruct.extend.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.poolstruct.extend.justify">.poolstruct.extend.justify:</a> Calculating a reasonable value for this
once and remembering it simplifies the allocation (<a class="reference internal" href="#design.mps.poolmrg.alloc.grow">.alloc.grow</a>).</p>
</li>
</ul>
<p><span class="target" id="design.mps.poolmrg.poolstruct.init"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.poolstruct.init">.poolstruct.init:</a> poolstructs are initialized once for each pool
instance by <a class="reference internal" href="#MRGInit" title="MRGInit"><tt class="xref c c-func docutils literal"><span class="pre">MRGInit()</span></tt></a> (<a class="reference internal" href="#design.mps.poolmrg.init">.init</a>). The initial state has all the
rings initialized to singleton rings, and the <tt class="docutils literal"><span class="pre">extendBy</span></tt> field
initialized to some value (see <a class="reference internal" href="#design.mps.poolmrg.init.extend">.init.extend</a>).</p>
<p><span class="target" id="design.mps.poolmrg.mrgseg"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.mrgseg">.mrgseg:</a> The pool defines two segment subclasses:
<tt class="xref c c-type docutils literal"><span class="pre">MRGRefSegClass</span></tt> and <tt class="xref c c-type docutils literal"><span class="pre">MRGLinkSegClass</span></tt>. Segments of the former
class will be used to store the ref parts of guardians, segments of
the latter will be used to store the link parts of guardians (see
<a class="reference internal" href="#design.mps.poolmrg.guardian.two-part">.guardian.two-part</a>). Segments are always allocated in pairs, with
one of each class, by the function <tt class="xref c c-func docutils literal"><span class="pre">MRGSegPairCreate()</span></tt>. Each
segment contains a link to its pair.</p>
<p><span class="target" id="design.mps.poolmrg.mrgseg.ref"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.mrgseg.ref">.mrgseg.ref:</a> <tt class="xref c c-type docutils literal"><span class="pre">MRGRefSegClass</span></tt> is a subclass of <tt class="xref c c-type docutils literal"><span class="pre">GCSegClass</span></tt>.
Instances are of type <tt class="docutils literal"><span class="pre">MRGRefSeg</span></tt>, and contain:</p>
<ul class="simple">
<li><span class="target" id="design.mps.poolmrg.mrgseg.ref.mrgring"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.mrgseg.ref.mrgring">.mrgseg.ref.mrgring:</a> a field for the ring of ref part segments in
the pool.</li>
<li><span class="target" id="design.mps.poolmrg.mrgseg.ref.linkseg"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.mrgseg.ref.linkseg">.mrgseg.ref.linkseg:</a> a pointer to the paired link segment.</li>
<li><span class="target" id="design.mps.poolmrg.mrgseg.ref.grey"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.mrgseg.ref.grey">.mrgseg.ref.grey:</a> a set describing the greyness of the segment for each trace.</li>
</ul>
<p><span class="target" id="design.mps.poolmrg.mrgseg.ref.init"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.mrgseg.ref.init">.mrgseg.ref.init:</a> A segment is created and initialized once every
time the pool is grown (<a class="reference internal" href="#design.mps.poolmrg.alloc.grow">.alloc.grow</a>). The initial state has the
segment ring node initialized and attached to the pool&#8217;s segment ring,
the linkseg field points to the relevant link segment, the grey field
is initialized such that the segment is not grey for all traces.</p>
<p><span class="target" id="design.mps.poolmrg.mrgseg.link"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.mrgseg.link">.mrgseg.link:</a> <tt class="xref c c-type docutils literal"><span class="pre">MRGLinkSegClass</span></tt> is a subclass of <tt class="xref c c-type docutils literal"><span class="pre">SegClass</span></tt>.
Instances are of type <tt class="docutils literal"><span class="pre">MRGLinkSeg</span></tt>, and contain:</p>
<ul class="simple">
<li><span class="target" id="design.mps.poolmrg.mrgseg.link.refseg"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.mrgseg.link.refseg">.mrgseg.link.refseg:</a> a pointer to the paired ref segment. This
may be <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt> during initialization, while the pairing is being
established.</li>
<li><span class="target" id="design.mps.poolmrg.mrgseg.link.init"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.mrgseg.link.init">.mrgseg.link.init:</a> The initial state has the <tt class="docutils literal"><span class="pre">linkseg</span></tt> field
pointing to the relevant ref segment.</li>
</ul>
</div>
<div class="section" id="functions">
<h2>26.8. Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="MRGCheck">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">MRGCheck</tt><big>(</big>MRG<em>&nbsp;mrg</em><big>)</big><a class="headerlink" href="#MRGCheck" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolmrg.check"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.check">.check:</a> Check the signatures, the class, and each field of the
<tt class="xref c c-type docutils literal"><span class="pre">MRGStruct</span></tt>. Each field is checked as being appropriate for its
type.</p>
<p><span class="target" id="design.mps.poolmrg.check.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.check.justify">.check.justify:</a> There are no non-trivial invariants that can
be easily checked.</p>
<dl class="function">
<dt id="MRGRegister">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">MRGRegister</tt><big>(</big>Pool<em>&nbsp;pool</em>, <a class="reference internal" href="type.html#Ref" title="Ref">Ref</a><em>&nbsp;ref</em><big>)</big><a class="headerlink" href="#MRGRegister" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolmrg.alloc"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.alloc">.alloc:</a> Add a guardian for <tt class="docutils literal"><span class="pre">ref</span></tt>.</p>
<p><span class="target" id="design.mps.poolmrg.alloc.grow"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.alloc.grow">.alloc.grow:</a> If the free list is empty then two new segments are
allocated and the free list filled up from them (note that the
reference fields of the new guardians will need to be overwritten with
<tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt>, see <a class="reference internal" href="#design.mps.poolmrg.free.overwrite">.free.overwrite</a>)</p>
<p><span class="target" id="design.mps.poolmrg.alloc.grow.size"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.alloc.grow.size">.alloc.grow.size:</a> The size of the reference part segment will be
the pool&#8217;s <tt class="docutils literal"><span class="pre">extendBy</span></tt> (<a class="reference internal" href="#design.mps.poolmrg.poolstruct.extend">.poolstruct.extend</a>) value. The link part
segment will be whatever size is necessary to accommodate <em>N</em> link
parts, where <em>N</em> is the number of reference parts that fit in the
reference part segment.</p>
<p><span class="target" id="design.mps.poolmrg.alloc.error"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.alloc.error">.alloc.error:</a> If any of the requests for more resource (there are
two; one for each of two segments) fail then the successful requests
will be retracted and the result code from the failing request will be
returned.</p>
<p><span class="target" id="design.mps.poolmrg.alloc.pop"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.alloc.pop">.alloc.pop:</a> <a class="reference internal" href="#MRGRegister" title="MRGRegister"><tt class="xref c c-func docutils literal"><span class="pre">MRGRegister()</span></tt></a> pops a ring node off the free list,
and add it to the entry list.</p>
<dl class="function">
<dt id="MRGDeregister">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">MRGDeregister</tt><big>(</big>Pool<em>&nbsp;pool</em>, <a class="reference internal" href="type.html#Ref" title="Ref">Ref</a><em>&nbsp;obj</em><big>)</big><a class="headerlink" href="#MRGDeregister" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolmrg.free"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.free">.free:</a> Remove the guardian from the message queue and add it to the
free list.</p>
<p><span class="target" id="design.mps.poolmrg.free.push"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.free.push">.free.push:</a> The guardian will simply be added to the front of the
free list (that is, no keeping the free list in address order or
anything like that).</p>
<p><span class="target" id="design.mps.poolmrg.free.inadequate"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.free.inadequate">.free.inadequate:</a> No attempt will be made to return unused free
segments to the arena (although see
analysis.mps.poolmrg.improve.free.* for suggestions).</p>
<p><span class="target" id="design.mps.poolmrg.free.overwrite"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.free.overwrite">.free.overwrite:</a> <a class="reference internal" href="#MRGDeregister" title="MRGDeregister"><tt class="xref c c-func docutils literal"><span class="pre">MRGDeregister()</span></tt></a> also writes over the reference
with <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt>. <span class="target" id="design.mps.poolmrg.free.overwrite.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.free.overwrite.justify">.free.overwrite.justify:</a> This is so that when the
segment is subsequently scanned (<a class="reference internal" href="#design.mps.poolmrg.scan.free">.scan.free</a>), the reference that
used to be in the object is not accidentally fixed.</p>
<dl class="function">
<dt id="MRGInit">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">MRGInit</tt><big>(</big>Pool<em>&nbsp;pool</em>, ArgList<em>&nbsp;args</em><big>)</big><a class="headerlink" href="#MRGInit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolmrg.init"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.init">.init:</a> Initializes the entry list, the free ring, the ref ring, and
the <tt class="docutils literal"><span class="pre">extendBy</span></tt> field.</p>
<p><span class="target" id="design.mps.poolmrg.init.extend"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.init.extend">.init.extend:</a> The <tt class="docutils literal"><span class="pre">extendBy</span></tt> field is initialized to one
<tt class="xref c c-func docutils literal"><span class="pre">ArenaAlign()</span></tt> (usually a page).</p>
<p><span class="target" id="design.mps.poolmrg.init.extend.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.init.extend.justify">.init.extend.justify:</a> This is adequate as the pool is not expected
to grow very quickly.</p>
<dl class="function">
<dt id="MRGFinish">
void <tt class="descname">MRGFinish</tt><big>(</big>Pool<em>&nbsp;pool</em><big>)</big><a class="headerlink" href="#MRGFinish" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolmrg.finish"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.finish">.finish:</a> Iterate over all the segments, returning all the segments
to the arena.</p>
<dl class="function">
<dt id="MRGScan">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">MRGScan</tt><big>(</big><a class="reference internal" href="type.html#Bool" title="Bool">Bool</a><em>&nbsp;*totalReturn</em>, ScanState<em>&nbsp;ss</em>, Pool<em>&nbsp;pool</em>, <a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;seg</em><big>)</big><a class="headerlink" href="#MRGScan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolmrg.scan"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.scan">.scan:</a> <a class="reference internal" href="#MRGScan" title="MRGScan"><tt class="xref c c-func docutils literal"><span class="pre">MRGScan()</span></tt></a> scans a segment.</p>
<p><span class="target" id="design.mps.poolmrg.scan.trivial"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.scan.trivial">.scan.trivial:</a> Scan will do nothing (that is, return immediately)
if the tracing rank is anything other than final.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">This optimization is missing. impl.c.trace.scan.conservative is
not a problem because there are no faults on these segs, because
there are no references into them. But that&#8217;s why <tt class="xref c c-func docutils literal"><span class="pre">TraceScan()</span></tt>
can&#8217;t do it. Pekka P. Pirinen, 1997-09-19.</p>
</div>
<p><span class="target" id="design.mps.poolmrg.scan.trivial.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.scan.trivial.justify">.scan.trivial.justify:</a> If the rank is lower than final then
scanning is detrimental, it will only delay finalization. If the rank
is higher than final there is nothing to do, the pool only contains
final references.</p>
<p><span class="target" id="design.mps.poolmrg.scan.guardians"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.scan.guardians">.scan.guardians:</a> <a class="reference internal" href="#MRGScan" title="MRGScan"><tt class="xref c c-func docutils literal"><span class="pre">MRGScan()</span></tt></a> will iterate over all guardians in
the segment. Every guardian&#8217;s reference will be fixed (<span class="target" id="design.mps.poolmrg.scan.free"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.scan.free">.scan.free:</a>
note that guardians that are on the free list have <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt> in their
reference part).</p>
<p><span class="target" id="design.mps.poolmrg.scan.wasold"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.scan.wasold">.scan.wasold:</a> If the object referred to had not been fixed
previously (that is, was unmarked) then the object is not referenced
by a reference of a lower rank (than <tt class="docutils literal"><span class="pre">RankFINAL</span></tt>) and hence is
finalizable.</p>
<p><span class="target" id="design.mps.poolmrg.scan.finalize"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.scan.finalize">.scan.finalize:</a> The guardian will be finalized. This entails moving
the guardian from state Prefinal to Final; it is removed from the
entry list and initialized as a message and posted on the arena&#8217;s
message queue.</p>
<p><span class="target" id="design.mps.poolmrg.scan.finalize.idempotent"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.scan.finalize.idempotent">.scan.finalize.idempotent:</a> In fact this will only happen if the
guardian has not already been finalized (which is determined by
examining the state of the guardian).</p>
<p><span class="target" id="design.mps.poolmrg.scan.unordered"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.scan.unordered">.scan.unordered:</a> Because scanning occurs a segment at a time, the
order in which objects are finalized is &#8220;random&#8221; (it cannot be
predicted by considering only the references between objects
registered for finalization). See
analysis.mps.poolmrg.improve.semantics for how this can be improved.</p>
<p><span class="target" id="design.mps.poolmrg.scan.unordered.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.scan.unordered.justify">.scan.unordered.justify:</a> Unordered finalization is all that is
required.</p>
<p>See analysis.mps.poolmrg.improve.scan.nomove for a suggested
improvement that avoids redundant unlinking and relinking.</p>
<dl class="function">
<dt id="MRGDescribe">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">MRGDescribe</tt><big>(</big>Pool<em>&nbsp;pool</em>, <a class="reference internal" href="../topic/plinth.html#mps_lib_FILE" title="mps_lib_FILE">mps_lib_FILE</a><em>&nbsp;*stream</em><big>)</big><a class="headerlink" href="#MRGDescribe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolmrg.describe"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.describe">.describe:</a> Describes an MRG pool. Iterates along each of the entry
and exit lists and prints the guardians in each. The location of the
guardian and the value of the reference in it will be printed out.</p>
<p><span class="target" id="design.mps.poolmrg.functions.unused"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.functions.unused">.functions.unused:</a> All of these will be unused: <tt class="xref c c-func docutils literal"><span class="pre">BufferInit()</span></tt>,
<a class="reference internal" href="buffer.html#BufferFill" title="BufferFill"><tt class="xref c c-func docutils literal"><span class="pre">BufferFill()</span></tt></a>, <tt class="xref c c-func docutils literal"><span class="pre">BufferEmpty()</span></tt>, <tt class="xref c c-func docutils literal"><span class="pre">BufferFinish()</span></tt>,
<tt class="xref c c-func docutils literal"><span class="pre">TraceBegin()</span></tt>, <tt class="xref c c-func docutils literal"><span class="pre">TraceCondemn()</span></tt>, <tt class="xref c c-func docutils literal"><span class="pre">PoolFix()</span></tt>, <tt class="xref c c-func docutils literal"><span class="pre">PoolReclaim()</span></tt>, <tt class="xref c c-func docutils literal"><span class="pre">TraceEnd()</span></tt>.</p>
<p><span class="target" id="design.mps.poolmrg.functions.trivial"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.functions.trivial">.functions.trivial:</a> The Grey method of the pool class will be
<tt class="xref c c-func docutils literal"><span class="pre">PoolTrivGrey()</span></tt>, this pool has no further bookkeeping to perform
for grey segments.</p>
</div>
<div class="section" id="transgressions">
<h2>26.9. Transgressions<a class="headerlink" href="#transgressions" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolmrg.trans.no-finish"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.trans.no-finish">.trans.no-finish:</a> The MRG pool does not trouble itself to tidy up
its internal rings properly when being destroyed.</p>
<p><span class="target" id="design.mps.poolmrg.trans.free-seg"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.trans.free-seg">.trans.free-seg:</a> No attempt is made to release free segments to the
arena. A suggested strategy for this is as follows:</p>
<ul class="simple">
<li>Add a count of free guardians to each segment, and maintain it in
appropriate places.</li>
<li>Add a free segment ring to the pool.</li>
<li>In <tt class="xref c c-func docutils literal"><span class="pre">MRGRefSegScan()</span></tt>, if the segment is entirely free, don&#8217;t scan
it, but instead detach its links from the free ring, and move the
segment to the free segment ring.</li>
<li>At some appropriate point, such as the end of <tt class="xref c c-func docutils literal"><span class="pre">MRGAlloc()</span></tt>,
destroy free segments.</li>
<li>In <tt class="xref c c-func docutils literal"><span class="pre">MRGAlloc()</span></tt>, if there are no free guardians, check the free
segment ring before creating a new pair of segments. Note that this
algorithm would give some slight measure of segment hysteresis. It
is not the place of the pool to support general segment hysteresis.</li>
</ul>
</div>
<div class="section" id="future">
<h2>26.10. Future<a class="headerlink" href="#future" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolmrg.future.array"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.future.array">.future.array:</a> In future, for speed or simplicity, this pool could
be rewritten to use an array. See mail.gavinm.1997-09-04.13-08(0).</p>
</div>
<div class="section" id="tests">
<h2>26.11. Tests<a class="headerlink" href="#tests" title="Permalink to this headline">¶</a></h2>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">This section is utterly out of date. Pekka P. Pirinen, 1997-09-19.</p>
</div>
<p><span class="target" id="design.mps.poolmrg.test"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test">.test:</a> The test impl.c.finalcv is similar to the weakness test (see
design.mps.weakness, impl.c.weakcv).</p>
<div class="section" id="functionality">
<h3>26.11.1. Functionality<a class="headerlink" href="#functionality" title="Permalink to this headline">¶</a></h3>
<p>This is the functionality to be tested:</p>
<ul class="simple">
<li><span class="target" id="design.mps.poolmrg.fun.alloc"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.fun.alloc">.fun.alloc:</a> Can allocate objects.</li>
<li><span class="target" id="design.mps.poolmrg.fun.free"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.fun.free">.fun.free:</a> Can free objects that were allocated.</li>
<li><span class="target" id="design.mps.poolmrg.prot.write"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.prot.write">.prot.write:</a> Can write a reference into an allocated object.</li>
<li><span class="target" id="design.mps.poolmrg.prot.read"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.prot.read">.prot.read:</a> Can read the reference from an allocated object.</li>
<li><span class="target" id="design.mps.poolmrg.promise.faithful"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.promise.faithful">.promise.faithful:</a> A reference stored in an allocated object will
continue to refer to the same object.</li>
<li><span class="target" id="design.mps.poolmrg.promise.live"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.promise.live">.promise.live:</a> A reference stored in an allocated object will
preserve the object referred to.</li>
<li><span class="target" id="design.mps.poolmrg.promise.unreachable"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.promise.unreachable">.promise.unreachable:</a> Any objects referred to in finalization
messages are not (at the time of reading the message) reachable via
a chain of ambiguous or exact references. (we will not be able to
test this at first as there is no messaging interface)</li>
<li><span class="target" id="design.mps.poolmrg.promise.try"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.promise.try">.promise.try:</a> The pool will make a &#8220;good faith&#8221; effort to
finalize objects that are not reachable via a chain of ambiguous or
exact references.</li>
</ul>
</div>
<div class="section" id="attributes">
<h3>26.11.2. Attributes<a class="headerlink" href="#attributes" title="Permalink to this headline">¶</a></h3>
<p>The following attributes will be tested:</p>
<ul class="simple">
<li><span class="target" id="design.mps.poolmrg.attr.none"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.attr.none">.attr.none:</a> There are no attribute requirements.</li>
</ul>
</div>
<div class="section" id="implementation">
<h3>26.11.3. Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>The test will simply allocate a number of objects in the AMC pool and
finalize each one, throwing away the reference to the objects. Churn.</p>
<p><span class="target" id="design.mps.poolmrg.test.mpm"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.mpm">.test.mpm:</a> The test will use the MPM interface (impl.h.mpm).</p>
<p><span class="target" id="design.mps.poolmrg.test.mpm.justify"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.mpm.justify">.test.mpm.justify:</a> This is because it is not intended to provide an
MPS interface to this pool directly, and the MPS interface to
finalization has not been written yet (impl.h.mps).</p>
<p><span class="target" id="design.mps.poolmrg.test.mpm.change"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.mpm.change">.test.mpm.change:</a> Later on it may use the MPS interface, in which
case, where the following text refers to allocating objects in the MRG
pool it will need adjusting.</p>
<p><span class="target" id="design.mps.poolmrg.test.two-pools"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.two-pools">.test.two-pools:</a> The test will use two pools, an AMC pool, and an
MRG pool.</p>
<p><span class="target" id="design.mps.poolmrg.test.alloc"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.alloc">.test.alloc:</a> A number of objects will be allocated in the MRG pool.</p>
<p><span class="target" id="design.mps.poolmrg.test.free"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.free">.test.free:</a> They will then be freed. This will test <a class="reference internal" href="#design.mps.poolmrg.fun.alloc">.fun.alloc</a>
and <a class="reference internal" href="#design.mps.poolmrg.fun.free">.fun.free</a>, although not very much.</p>
<p><span class="target" id="design.mps.poolmrg.test.rw.a"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.rw.a">.test.rw.a:</a> An object, &#8220;A&#8221;, will be allocated in the AMC pool, a
reference to it will be kept in a root.</p>
<p><span class="target" id="design.mps.poolmrg.test.rw.alloc"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.rw.alloc">.test.rw.alloc:</a> A number of objects will be allocated in the MRG
pool.</p>
<p><span class="target" id="design.mps.poolmrg.test.rw.write"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.rw.write">.test.rw.write:</a> A reference to &#8220;A&#8221; will be written into each
object.</p>
<p><span class="target" id="design.mps.poolmrg.test.rw.read"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.rw.read">.test.rw.read:</a> The reference in each object will be read and
checked to see if it refers to &#8220;A&#8221;.</p>
<p><span class="target" id="design.mps.poolmrg.test.rw.free"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.rw.free">.test.rw.free:</a> All the objects will be freed.</p>
<p><span class="target" id="design.mps.poolmrg.test.rw.drop"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.rw.drop">.test.rw.drop:</a> The reference to &#8220;A&#8221; will be dropped. This will test
<a class="reference internal" href="#design.mps.poolmrg.prot.write">.prot.write</a> and <a class="reference internal" href="#design.mps.poolmrg.prot.read">.prot.read</a>.</p>
<p><span class="target" id="design.mps.poolmrg.test.promise.fl.alloc"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.promise.fl.alloc">.test.promise.fl.alloc:</a> A number of objects will be allocated in
the AMC pool.</p>
<p><span class="target" id="design.mps.poolmrg.test.promise.fl.tag"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.promise.fl.tag">.test.promise.fl.tag:</a> Each object will be tagged uniquely.</p>
<p><span class="target" id="design.mps.poolmrg.test.promise.fl.refer"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.promise.fl.refer">.test.promise.fl.refer:</a> a reference to it will be stored in an
object allocated in the MRG pool.</p>
<p><span class="target" id="design.mps.poolmrg.test.promise.fl.churn"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.promise.fl.churn">.test.promise.fl.churn:</a> A large amount of garbage will be allocated
in the AMC pool. Regularly, whilst this garbage is being allocated, a
check will be performed that all the objects allocated in the MRG pool
refer to valid objects and that they still refer to the same objects.
All objects from the MRG pool will then be freed (thus dropping all
references to the AMC objects). This will test <a class="reference internal" href="#design.mps.poolmrg.promise.faithful">.promise.faithful</a>
and <a class="reference internal" href="#design.mps.poolmrg.promise.live">.promise.live</a>.</p>
<p><span class="target" id="design.mps.poolmrg.test.promise.ut.not"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.promise.ut.not">.test.promise.ut.not:</a> The following part of the test has not
implemented. This is because the messaging system has not yet been
implemented.</p>
<p><span class="target" id="design.mps.poolmrg.test.promise.ut.alloc"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.promise.ut.alloc">.test.promise.ut.alloc:</a> A number of objects will be allocated in
the AMC pool.</p>
<p><span class="target" id="design.mps.poolmrg.test.promise.ut.refer"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.promise.ut.refer">.test.promise.ut.refer:</a> Each object will be referred to by a root
and also referred to by an object allocated in the MRG pool.</p>
<p><span class="target" id="design.mps.poolmrg.test.promise.ut.drop"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.promise.ut.drop">.test.promise.ut.drop:</a> References to a random selection of the
objects from the AMC pool will be deleted from the root.</p>
<p><span class="target" id="design.mps.poolmrg.test.promise.ut.churn"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.promise.ut.churn">.test.promise.ut.churn:</a> A large amount of garbage will be allocated
in the AMC pool.</p>
<p><span class="target" id="design.mps.poolmrg.test.promise.ut.message"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.promise.ut.message">.test.promise.ut.message:</a> The message interface will be used to
receive finalization messages.</p>
<p><span class="target" id="design.mps.poolmrg.test.promise.ut.final.check"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.promise.ut.final.check">.test.promise.ut.final.check:</a> For each finalization message
received it will check that the object referenced in the message is
not referred to in the root.</p>
<p><span class="target" id="design.mps.poolmrg.test.promise.ut.nofinal.check"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.test.promise.ut.nofinal.check">.test.promise.ut.nofinal.check:</a> After some amount of garbage has
been allocated it will check to see if any objects are not in the root
and haven&#8217;t been finalized. This will test <a class="reference internal" href="#design.mps.poolmrg.promise.unreachable">.promise.unreachable</a> and
<a class="reference internal" href="#design.mps.poolmrg.promise.try">.promise.try</a>.</p>
</div>
</div>
<div class="section" id="notes">
<h2>26.12. Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolmrg.access.inadequate"></span><a class="mpstag reference internal" href="#design.mps.poolmrg.access.inadequate">.access.inadequate:</a> <tt class="xref c c-func docutils literal"><span class="pre">PoolAccess()</span></tt> will scan segments at
<cite>RankEXACT`</cite>. Really it should be scanned at whatever the minimum rank
of all grey segments is (the trace rank phase), however there is no
way to find this out. As a consequence we will sometimes scan pages at
<tt class="docutils literal"><span class="pre">RankEXACT</span></tt> when the pages could have been scanned at <tt class="docutils literal"><span class="pre">RankFINAL</span></tt>.
This means that finalization of some objects may sometimes get
delayed.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">26. MRG pool class</a><ul>
<li><a class="reference internal" href="#introduction">26.1. Introduction</a></li>
<li><a class="reference internal" href="#goals">26.2. Goals</a></li>
<li><a class="reference internal" href="#requirements">26.3. Requirements</a></li>
<li><a class="reference internal" href="#terminology">26.4. Terminology</a></li>
<li><a class="reference internal" href="#overview">26.5. Overview</a></li>
<li><a class="reference internal" href="#protocols">26.6. Protocols</a><ul>
<li><a class="reference internal" href="#object-registration">26.6.1. Object Registration</a></li>
<li><a class="reference internal" href="#finalizer-execution">26.6.2. Finalizer execution</a></li>
<li><a class="reference internal" href="#setup-destroy">26.6.3. Setup / destroy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-structures">26.7. Data structures</a></li>
<li><a class="reference internal" href="#functions">26.8. Functions</a></li>
<li><a class="reference internal" href="#transgressions">26.9. Transgressions</a></li>
<li><a class="reference internal" href="#future">26.10. Future</a></li>
<li><a class="reference internal" href="#tests">26.11. Tests</a><ul>
<li><a class="reference internal" href="#functionality">26.11.1. Functionality</a></li>
<li><a class="reference internal" href="#attributes">26.11.2. Attributes</a></li>
<li><a class="reference internal" href="#implementation">26.11.3. Implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#notes">26.12. Notes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="poolmfs.html"
                        title="previous chapter">25. MFS pool class</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="poolmv.html"
                        title="next chapter">27. MV pool class</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="poolmv.html" title="27. MV pool class"
             >next</a> |</li>
        <li class="right" >
          <a href="poolmfs.html" title="25. MFS pool class"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" >Old design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>