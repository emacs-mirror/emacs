

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>23. AWL pool class &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Old design" href="old.html" />
    <link rel="next" title="24. LO pool class" href="poollo.html" />
    <link rel="prev" title="22. AMS pool class" href="poolams.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="poollo.html" title="24. LO pool class"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="poolams.html" title="22. AMS pool class"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" accesskey="U">Old design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="design-poolawl"></span><div class="section" id="awl-pool-class">
<span id="index-0"></span><h1>23. AWL pool class<a class="headerlink" href="#awl-pool-class" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="design.mps.poolawl"></span><h2>23.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolawl.readership"></span><a class="mpstag reference internal" href="#design.mps.poolawl.readership">.readership:</a> Any MPS developer.</p>
<p><span class="target" id="design.mps.poolawl.intro"></span><a class="mpstag reference internal" href="#design.mps.poolawl.intro">.intro:</a> The AWL (Automatic Weak Linked) pool is used to manage
Dylan Weak Tables (see req.dylan.fun.weak). Currently the design is
specialised for Dylan Weak Tables, but it could be generalised in the
future.</p>
</div>
<div class="section" id="requirements">
<h2>23.2. Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p>See req.dylan.fun.weak.</p>
<p>See meeting.dylan.1997-02-27(0) where many of the requirements for
this pool were first sorted out.</p>
<p>Must satisfy <a class="reference external" href="https://info.ravenbrook.com/project/mps/import/2001-11-05/mmprevol/request/dylan/170123">request.dylan.170123</a>.</p>
<p><span class="target" id="design.mps.poolawl.req.obj-format"></span><a class="mpstag reference internal" href="#design.mps.poolawl.req.obj-format">.req.obj-format:</a> Only objects of a certain format need be
supported. This format is a subset of the Dylan Object Format. The
pool uses the first slot in the fixed part of an object to store an
association. See mail.drj.1997-03-11.12-05</p>
</div>
<div class="section" id="definitions">
<h2>23.3. Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolawl.def.grain"></span><a class="mpstag reference internal" href="#design.mps.poolawl.def.grain">.def.grain:</a> alignment grain, grain. A grain is a range of addresses
where both the base and the limit of the range are aligned and the
size of range is equal to the (same) alignment. In this context the
alignment is the pool&#8217;s alignment (<tt class="docutils literal"><span class="pre">pool-&gt;alignment</span></tt>). The grain is
the unit of allocation, marking, scanning, etc.</p>
</div>
<div class="section" id="overview">
<h2>23.4. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolawl.overview"></span><a class="mpstag reference internal" href="#design.mps.poolawl.overview">.overview:</a></p>
<p><span class="target" id="design.mps.poolawl.overview.ms"></span><a class="mpstag reference internal" href="#design.mps.poolawl.overview.ms">.overview.ms:</a> The pool is mark and sweep. <span class="target" id="design.mps.poolawl.overview.ms.justify"></span><a class="mpstag reference internal" href="#design.mps.poolawl.overview.ms.justify">.overview.ms.justify:</a>
Mark-sweep pools are slightly easier to write (than moving pools), and
there are no requirements (yet) that this pool be high performance or
moving or anything like that.</p>
<p><span class="target" id="design.mps.poolawl.overview.alloc"></span><a class="mpstag reference internal" href="#design.mps.poolawl.overview.alloc">.overview.alloc:</a> It is possible to allocate weak or exact objects
using the normal reserve/commit AP protocol.
<span class="target" id="design.mps.poolawl.overview.alloc.justify"></span><a class="mpstag reference internal" href="#design.mps.poolawl.overview.alloc.justify">.overview.alloc.justify:</a> Allocation of both weak and exact objects
is required to implement Dylan Weak Tables. Objects are formatted; the
pool uses format A.</p>
<p><span class="target" id="design.mps.poolawl.overview.scan"></span><a class="mpstag reference internal" href="#design.mps.poolawl.overview.scan">.overview.scan:</a> The pool handles the scanning of weak objects
specially so that when a weak reference is deleted the corresponding
reference in an associated object is deleted. The associated object is
determined by using information stored in the object itself (see
<a class="reference internal" href="#design.mps.poolawl.req.obj-format">.req.obj-format</a>).</p>
</div>
<div class="section" id="interface">
<h2>23.5. Interface<a class="headerlink" href="#interface" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolawl.if.init"></span><a class="mpstag reference internal" href="#design.mps.poolawl.if.init">.if.init:</a> The init method takes one extra parameter in the vararg
list. This parameter should have type <tt class="xref c c-type docutils literal"><span class="pre">Format</span></tt> and be a format
object that describes the format of the objects to be allocated in
this pool. The format should support scan and skip methods. There is
an additional restriction on the layout of objects, see
<a class="reference internal" href="#design.mps.poolawl.req.obj-format">.req.obj-format</a>.</p>
<p><span class="target" id="design.mps.poolawl.if.buffer"></span><a class="mpstag reference internal" href="#design.mps.poolawl.if.buffer">.if.buffer:</a> The <tt class="xref c c-func docutils literal"><span class="pre">BufferInit()</span></tt> method takes one extra parameter
in the vararg list. This parameter should be either <tt class="docutils literal"><span class="pre">RankEXACT</span></tt> or
<tt class="docutils literal"><span class="pre">RankWEAK</span></tt>. It determines the rank of the objects allocated using
that buffer.</p>
</div>
<div class="section" id="data-structures">
<h2>23.6. Data structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolawl.sig"></span><a class="mpstag reference internal" href="#design.mps.poolawl.sig">.sig:</a> This signature for this pool will be 0x519bla3l (SIGPooLAWL).</p>
<p><span class="target" id="design.mps.poolawl.poolstruct"></span><a class="mpstag reference internal" href="#design.mps.poolawl.poolstruct">.poolstruct:</a> The class specific pool structure is:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">AWLStruct</span> <span class="p">{</span>
  <span class="n">PoolStruct</span> <span class="n">poolStruct</span><span class="p">;</span>
  <span class="n">Format</span> <span class="n">format</span><span class="p">;</span>
  <span class="n">Shift</span> <span class="n">alignShift</span><span class="p">;</span>
  <span class="n">ActionStruct</span> <span class="n">actionStruct</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">lastCollected</span><span class="p">;</span>
  <span class="n">Serial</span> <span class="n">gen</span><span class="p">;</span>
  <span class="n">Sig</span> <span class="n">sig</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="target" id="design.mps.poolawl.poolstruct.format"></span><a class="mpstag reference internal" href="#design.mps.poolawl.poolstruct.format">.poolstruct.format:</a> The format field is used to refer to the object
format. The object format is passed to the pool during pool creation.</p>
<p><span class="target" id="design.mps.poolawl.poolstruct.alignshift"></span><a class="mpstag reference internal" href="#design.mps.poolawl.poolstruct.alignshift">.poolstruct.alignshift:</a> The <tt class="docutils literal"><span class="pre">alignShift</span></tt> field is the
<tt class="docutils literal"><span class="pre">SizeLog2</span></tt> of the pool&#8217;s alignment. It is computed and initialised
when a pool is created. It is used to compute the number of alignment
grains in a segment which is the number of bits need in the segment&#8217;s
mark and alloc bit table (see <a class="reference internal" href="#design.mps.poolawl.awlseg.bt">.awlseg.bt</a>, <a class="reference internal" href="#design.mps.poolawl.awlseg.mark">.awlseg.mark</a>, and
<a class="reference internal" href="#design.mps.poolawl.awlseg.alloc">.awlseg.alloc</a> below).</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">Clarify this.</p>
</div>
<p><span class="target" id="design.mps.poolawl.poolstruct.actionStruct"></span><a class="mpstag reference internal" href="#design.mps.poolawl.poolstruct.actionStruct">.poolstruct.actionStruct:</a> Contains an Action which is used to
participate in the collection benefit protocol. See <tt class="xref c c-func docutils literal"><span class="pre">AWLBenefit()</span></tt>
below for a description of the algorithm used for determining when to
collect.</p>
<p><span class="target" id="design.mps.poolawl.poolstruct.lastCollected"></span><a class="mpstag reference internal" href="#design.mps.poolawl.poolstruct.lastCollected">.poolstruct.lastCollected:</a> Records the time (using the mutator
total allocation clock, ie that returned by
<tt class="xref c c-func docutils literal"><span class="pre">ArenaMutatorAllocSize()</span></tt>) of the most recent call to either
<a class="reference internal" href="#AWLInit" title="AWLInit"><tt class="xref c c-func docutils literal"><span class="pre">AWLInit()</span></tt></a> or <tt class="xref c c-func docutils literal"><span class="pre">AWLTraceBegin()</span></tt> for this pool. So this is the
time of the beginning of the last collection of this pool. Actually
this isn&#8217;t true because the pool can be collected without
<tt class="xref c c-func docutils literal"><span class="pre">AWLTraceBegin()</span></tt> being called (I think) as it will get collected by
being in the same zone as another pool/generation that is being
collected (which it does arrange to be, see the use of the gen field
in <a class="reference internal" href="#design.mps.poolawl.poolstruct.gen">.poolstruct.gen</a> below and <a class="reference internal" href="#design.mps.poolawl.fun.awlsegcreate.where">.fun.awlsegcreate.where</a> below).</p>
<p><span class="target" id="design.mps.poolawl.poolstruct.gen"></span><a class="mpstag reference internal" href="#design.mps.poolawl.poolstruct.gen">.poolstruct.gen:</a> This part of the mechanism by which the pool
arranges to be in a particular zone and arranges to be collected
simultaneously with other cohorts in the system. <tt class="docutils literal"><span class="pre">gen</span></tt> is the
generation that is used in expressing a generation preference when
allocating a segment. The intention is that this pool will get
collected simultaneously with any other segments that are also
allocated using this generation preference (when using the VM arena,
generation preferences get mapped more or less to zones, each
generation to a unique set of zones in the ideal case). Whilst AWL is
not generational it is expected that this mechanism will arrange for
it to be collected simultaneously with some particular generation of
AMC.</p>
<p><span class="target" id="design.mps.poolawl.poolstruct.gen.1"></span><a class="mpstag reference internal" href="#design.mps.poolawl.poolstruct.gen.1">.poolstruct.gen.1:</a> At the moment the <tt class="docutils literal"><span class="pre">gen</span></tt> field is set for all
AWL pools to be 1.</p>
<p><span class="target" id="design.mps.poolawl.awlseg"></span><a class="mpstag reference internal" href="#design.mps.poolawl.awlseg">.awlseg:</a> The pool defines a segment class <tt class="xref c c-type docutils literal"><span class="pre">AWLSegClass</span></tt>, which is
a subclass of <tt class="xref c c-type docutils literal"><span class="pre">GCSegClass</span></tt> (see
design.mps.seg.over.hierarchy.gcseg). All segments allocated by the
pool are instances of this class, and are of type <tt class="docutils literal"><span class="pre">AWLSeg</span></tt>, for
which the structure is:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">AWLSegStruct</span> <span class="p">{</span>
  <span class="n">GCSegStruct</span> <span class="n">gcSegStruct</span><span class="p">;</span>
  <span class="n">BT</span> <span class="n">mark</span><span class="p">;</span>
  <span class="n">BT</span> <span class="n">scanned</span><span class="p">;</span>
  <span class="n">BT</span> <span class="n">alloc</span><span class="p">;</span>
  <span class="n">Count</span> <span class="n">grains</span><span class="p">;</span>
  <span class="n">Count</span> <span class="n">free</span><span class="p">;</span>
  <span class="n">Count</span> <span class="n">singleAccesses</span><span class="p">;</span>
  <span class="n">AWLStatSegStruct</span> <span class="n">stats</span><span class="p">;</span>
  <span class="n">Sig</span> <span class="n">sig</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="target" id="design.mps.poolawl.awlseg.bt"></span><a class="mpstag reference internal" href="#design.mps.poolawl.awlseg.bt">.awlseg.bt:</a> The mark, alloc, and scanned fields are bit-tables (see
design.mps.bt). Each bit in the table corresponds to a a single
alignment grain in the pool.</p>
<p><span class="target" id="design.mps.poolawl.awlseg.mark"></span><a class="mpstag reference internal" href="#design.mps.poolawl.awlseg.mark">.awlseg.mark:</a> The mark bit table is used to record mark bits during
a trace. <a class="reference internal" href="#AWLCondemn" title="AWLCondemn"><tt class="xref c c-func docutils literal"><span class="pre">AWLCondemn()</span></tt></a> (see <a class="reference internal" href="#design.mps.poolawl.fun.condemn">.fun.condemn</a> below) sets all the
bits of this table to zero. Fix will read and set bits in this table.
Currently there is only one mark bit table. This means that the pool
can only be condemned for one trace.</p>
<p><span class="target" id="design.mps.poolawl.awlseg.mark.justify"></span><a class="mpstag reference internal" href="#design.mps.poolawl.awlseg.mark.justify">.awlseg.mark.justify:</a> This is simple, and can be improved later
when we want to run more than one trace.</p>
<p><span class="target" id="design.mps.poolawl.awlseg.scanned"></span><a class="mpstag reference internal" href="#design.mps.poolawl.awlseg.scanned">.awlseg.scanned:</a> The scanned bit-table is used to note which
objects have been scanned. Scanning (see <a class="reference internal" href="#design.mps.poolawl.fun.scan">.fun.scan</a> below) a segment
will find objects that are marked but not scanned, scan each object
found and set the corresponding bits in the scanned table.</p>
<p><span class="target" id="design.mps.poolawl.awlseg.alloc"></span><a class="mpstag reference internal" href="#design.mps.poolawl.awlseg.alloc">.awlseg.alloc:</a> The alloc bit table is used to record which portions
of a segment have been allocated. Ranges of bits in this table are set
when a buffer is attached to the segment. When a buffer is flushed (ie
<a class="reference internal" href="#AWLBufferEmpty" title="AWLBufferEmpty"><tt class="xref c c-func docutils literal"><span class="pre">AWLBufferEmpty()</span></tt></a> is called) from the segment, the bits
corresponding to the unused portion at the end of the buffer are
reset.</p>
<p><span class="target" id="design.mps.poolawl.awlseg.alloc.invariant"></span><a class="mpstag reference internal" href="#design.mps.poolawl.awlseg.alloc.invariant">.awlseg.alloc.invariant:</a> A bit is set in the alloc table if and
only if the corresponding address is currently being buffered, or the
corresponding address lies within the range of an allocated object.</p>
<p><span class="target" id="design.mps.poolawl.awlseg.grains"></span><a class="mpstag reference internal" href="#design.mps.poolawl.awlseg.grains">.awlseg.grains:</a> The grains field is the number of grains that fit
in the segment. Strictly speaking this is not necessary as it can be
computed from <tt class="docutils literal"><span class="pre">SegSize</span></tt> and AWL&#8217;s alignment, however, precalculating
it and storing it in the segment makes the code simpler by avoiding
lots of repeated calculations.</p>
<p><span class="target" id="design.mps.poolawl.awlseg.free"></span><a class="mpstag reference internal" href="#design.mps.poolawl.awlseg.free">.awlseg.free:</a> A conservative estimate of the number of free grains
in the segment. It is always guaranteed to be greater than or equal to
the number of free grains in the segment, hence can be used during
allocation to quickly pass over a segment.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">Maintained by blah and blah. Unfinished obviously.</p>
</div>
</div>
<div class="section" id="functions">
<h2>23.7. Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">How will pool collect? It needs an action structure.</p>
</div>
<div class="section" id="external">
<h3>23.7.1. External<a class="headerlink" href="#external" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="AWLInit">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">AWLInit</tt><big>(</big>Pool<em>&nbsp;pool</em>, va_list<em>&nbsp;arg</em><big>)</big><a class="headerlink" href="#AWLInit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.init"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.init">.fun.init:</a> <tt class="xref c c-type docutils literal"><span class="pre">AWLStruct</span></tt> has four fields, each one needs initializing.</p>
<p><span class="target" id="design.mps.poolawl.fun.init.poolstruct"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.init.poolstruct">.fun.init.poolstruct:</a> The <tt class="docutils literal"><span class="pre">poolStruct</span></tt> field has already been
initialized by generic code (impl.c.pool).</p>
<p><span class="target" id="design.mps.poolawl.fun.init.format"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.init.format">.fun.init.format:</a> The format will be copied from the argument list,
checked, and written into this field.</p>
<p><span class="target" id="design.mps.poolawl.fun.init.alignshift"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.init.alignshift">.fun.init.alignshift:</a> The <tt class="docutils literal"><span class="pre">alignShift</span></tt> will be computed from the
pool alignment and written into this field.</p>
<p><span class="target" id="design.mps.poolawl.fun.init.sig"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.init.sig">.fun.init.sig:</a> The <tt class="docutils literal"><span class="pre">sig</span></tt> field will be initialized with the
signature for this pool.</p>
<dl class="function">
<dt id="AWLFinish">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">AWLFinish</tt><big>(</big>Pool<em>&nbsp;pool</em><big>)</big><a class="headerlink" href="#AWLFinish" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.finish"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.finish">.fun.finish:</a> Iterates over all segments in the pool and destroys
each segment (by calling <tt class="xref c c-func docutils literal"><span class="pre">SegFree()</span></tt>). Overwrites the sig field in
the <tt class="xref c c-type docutils literal"><span class="pre">AWLStruct</span></tt>. Finishing the generic pool structure is done by the
generic pool code (impl.c.pool).</p>
<p><span class="target" id="design.mps.poolawl.fun.alloc"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.alloc">.fun.alloc:</a> <tt class="xref c c-func docutils literal"><span class="pre">PoolNoAlloc()</span></tt> will be used, as this class does not
implement alloc.</p>
<p><span class="target" id="design.mps.poolawl.fun.free"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.free">.fun.free:</a> <tt class="xref c c-func docutils literal"><span class="pre">PoolNoFree()</span></tt> will be used, as this class does not
implement free.</p>
<dl class="function">
<dt id="AWLBufferFill">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">AWLBufferFill</tt><big>(</big><a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;*segReturn</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;*baseReturn</em>, Pool<em>&nbsp;pool</em>, Buffer<em>&nbsp;buffer</em>, <a class="reference internal" href="type.html#Size" title="Size">Size</a><em>&nbsp;size</em><big>)</big><a class="headerlink" href="#AWLBufferFill" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.fill"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.fill">.fun.fill:</a> This zips round all the the segments applying
<a class="reference internal" href="#AWLSegAlloc" title="AWLSegAlloc"><tt class="xref c c-func docutils literal"><span class="pre">AWLSegAlloc()</span></tt></a> to each segment that has the same rank as the
buffer. <a class="reference internal" href="#AWLSegAlloc" title="AWLSegAlloc"><tt class="xref c c-func docutils literal"><span class="pre">AWLSegAlloc()</span></tt></a> attempts to find a free range, if it finds a
range then it may be bigger than the actual request, in which case the
remainder can be used to &#8220;fill&#8221; the rest of the buffer. If no free
range can be found in an existing segment then a new segment will be
created (which is at least large enough). The range of buffered
addresses is marked as allocated in the segment&#8217;s alloc table.</p>
<dl class="function">
<dt id="AWLBufferEmpty">
void <tt class="descname">AWLBufferEmpty</tt><big>(</big>Pool<em>&nbsp;pool</em>, Buffer<em>&nbsp;buffer</em><big>)</big><a class="headerlink" href="#AWLBufferEmpty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.empty"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.empty">.fun.empty:</a> Locates the free portion of the buffer, that is the
memory between the init and the limit of the buffer and records these
locations as being free in the relevant alloc table. The segment that
the buffer is pointing at (which contains the alloc table that needs
to be dinked with) is available via <tt class="xref c c-func docutils literal"><span class="pre">BufferSeg()</span></tt>.</p>
<p><span class="target" id="design.mps.poolawl.fun.benefit"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.benefit">.fun.benefit:</a> The benefit returned is the total amount of mutator
allocation minus the <tt class="docutils literal"><span class="pre">lastRembemberedSize</span></tt> minus 10&nbsp;MiB, so the pool
becomes an increasingly good candidate for collection at a constant
(mutator allocation) rate, crossing the 0 line when there has been
10&nbsp;MiB of allocation since the (beginning of the) last collection. So
it gets collected approximately every 10&nbsp;MiB of allocation. Note that
it will also get collected by virtue of being in the same zone as some
AMC generation (assuming there are instantiated AMC pools), see
<a class="reference internal" href="#design.mps.poolawl.poolstruct.gen">.poolstruct.gen</a> above.</p>
<dl class="function">
<dt id="AWLCondemn">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">AWLCondemn</tt><big>(</big>Pool<em>&nbsp;pool</em>, Trace<em>&nbsp;trace</em>, <a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;seg</em><big>)</big><a class="headerlink" href="#AWLCondemn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.condemn"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.condemn">.fun.condemn:</a> The current design only permits each segment to be
condemned for one trace (see <a class="reference internal" href="#design.mps.poolawl.awlseg.mark">.awlseg.mark</a>). This function checks
that the segment is not condemned for any trace (<tt class="docutils literal"><span class="pre">seg-&gt;white</span> <span class="pre">==</span>
<span class="pre">TraceSetEMPTY</span></tt>). The segment&#8217;s mark bit-table is reset, and the
whiteness of the seg (<tt class="docutils literal"><span class="pre">seg-&gt;white</span></tt>) has the current trace added to
it.</p>
<dl class="function">
<dt id="AWLGrey">
void <tt class="descname">AWLGrey</tt><big>(</big>Pool<em>&nbsp;pool</em>, Trace<em>&nbsp;trace</em>, <a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;seg</em><big>)</big><a class="headerlink" href="#AWLGrey" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.grey"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.grey">.fun.grey:</a> If the segment is not condemned for this trace the
segment&#8217;s mark table is set to all 1s and the segment is recorded as
being grey.</p>
<dl class="function">
<dt id="AWLScan">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">AWLScan</tt><big>(</big>ScanState<em>&nbsp;ss</em>, Pool<em>&nbsp;pool</em>, <a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;seg</em><big>)</big><a class="headerlink" href="#AWLScan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.scan"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan">.fun.scan:</a></p>
<p><span class="target" id="design.mps.poolawl.fun.scan.overview"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.overview">.fun.scan.overview:</a> The scanner performs a number of passes over
the segment, scanning each marked and unscanned (grey) object that is
finds.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.overview.finish"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.overview.finish">.fun.scan.overview.finish:</a> It keeps perform a pass over the segment
until it is finished.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.overview.finish.condition"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.overview.finish.condition">.fun.scan.overview.finish.condition:</a> A condition for finishing is
that no new marks got placed on objects in this segment during the
pass.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.overview.finish.approximation"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.overview.finish.approximation">.fun.scan.overview.finish.approximation:</a> We use an even stronger
condition for finishing that assumes that scanning any object may
introduce marks onto this segment. It is finished when a pass results
in scanning no objects (that is, all objects were either unmarked or
both marked and scanned).</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.overview.finished-flag"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.overview.finished-flag">.fun.scan.overview.finished-flag:</a> There is a flag called
<tt class="docutils literal"><span class="pre">finished</span></tt> which keeps track of whether we should finish or not. We
only ever finish at the end of a pass. At the beginning of a pass the
flag is set. During a pass if any objects are scanned then the
<tt class="docutils literal"><span class="pre">finished</span></tt> flag is reset. At the end of a pass if the <tt class="docutils literal"><span class="pre">finished</span></tt>
flag is still set then we are finished. No more passes take place and
the function returns.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass">.fun.scan.pass:</a> A pass consists of a setup phase and a repeated
phase.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.buffer"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.buffer">.fun.scan.pass.buffer:</a> The following assumes that in the general
case the segment is buffered; if the segment is not buffered then the
actions that mention buffers are not taken (they are unimportant if
the segment is not buffered).</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.p"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.p">.fun.scan.pass.p:</a> The pass uses a cursor called <tt class="docutils literal"><span class="pre">p</span></tt> to progress
over the segment. During a pass <tt class="docutils literal"><span class="pre">p</span></tt> will increase from the base
address of the segment to the limit address of the segment. When <tt class="docutils literal"><span class="pre">p</span></tt>
reaches the limit address of the segment, the pass in complete.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.setup"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.setup">.fun.scan.pass.setup:</a> <tt class="docutils literal"><span class="pre">p</span></tt> initially points to the base address of
the segment.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.repeat"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.repeat">.fun.scan.pass.repeat:</a> The following comprises the repeated phase.
The repeated phase is repeated until the pass completion condition is
true (that is, <tt class="docutils literal"><span class="pre">p</span></tt> has reached the limit of the segment, see
<a class="reference internal" href="#design.mps.poolawl.fun.scan.pass.p">.fun.scan.pass.p</a> above and <a class="reference internal" href="#design.mps.poolawl.fun.scan.pass.repeat.complete">.fun.scan.pass.repeat.complete</a>
below).</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.repeat.complete"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.repeat.complete">.fun.scan.pass.repeat.complete:</a> If <tt class="docutils literal"><span class="pre">p</span></tt> is equal to the segment&#8217;s
limit then we are done. We proceed to check whether any further passes
need to be performed (see <a class="reference internal" href="#design.mps.poolawl.fun.scan.pass.more">.fun.scan.pass.more</a> below).</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.repeat.free"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.repeat.free">.fun.scan.pass.repeat.free:</a> If <tt class="docutils literal"><span class="pre">!alloc(p)</span></tt> (the grain is free)
then increment <tt class="docutils literal"><span class="pre">p</span></tt> and return to the beginning of the loop.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.repeat.buffer"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.repeat.buffer">.fun.scan.pass.repeat.buffer:</a> If <tt class="docutils literal"><span class="pre">p</span></tt> is equal to the buffer&#8217;s
ScanLimit, as returned by <tt class="xref c c-func docutils literal"><span class="pre">BufferScanLimit()</span></tt>, then set <tt class="docutils literal"><span class="pre">p</span></tt> equal
to the buffer&#8217;s Limit, as returned by <tt class="xref c c-func docutils literal"><span class="pre">BufferLimit()</span></tt> and return to
the beginning of the loop.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.repeat.object-end"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.repeat.object-end">.fun.scan.pass.repeat.object-end:</a> The end of the object is located
using the <tt class="docutils literal"><span class="pre">format-&gt;skip</span></tt> method.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.repeat.object"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.repeat.object">.fun.scan.pass.repeat.object:</a> if <tt class="docutils literal"><span class="pre">mark(p)</span> <span class="pre">&amp;&amp;</span> <span class="pre">!scanned(p)</span></tt> then
the object pointed at is marked but not scanned, which means we must
scan it, otherwise we must skip it.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.repeat.object.dependent"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.repeat.object.dependent">.fun.scan.pass.repeat.object.dependent:</a> To scan the object the
object we first have to determine if the object has a dependent object (see
<a class="reference internal" href="#design.mps.poolawl.req.obj-format">.req.obj-format</a>).</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.repeat.object.dependent.expose"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.repeat.object.dependent.expose">.fun.scan.pass.repeat.object.dependent.expose:</a> If it has a
dependent object then we must expose the segment that the dependent
object is on (only if the dependent object actually points to MPS
managed memory) prior to scanning and cover the segment subsequent to
scanning.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.repeat.object.dependent.summary"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.repeat.object.dependent.summary">.fun.scan.pass.repeat.object.dependent.summary:</a> The summary of the
dependent segment must be set to <tt class="docutils literal"><span class="pre">RefSetUNIV</span></tt> to reflect the fact
that we are allowing it to be written to (and we don&#8217;t know what gets
written to the segment).</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.repeat.object.scan"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.repeat.object.scan">.fun.scan.pass.repeat.object.scan:</a> The object is then scanned by
calling the format&#8217;s scan method with base and limit set to the
beginning and end of the object (<span class="target" id="design.mps.poolawl.fun.scan.scan.improve.single"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.scan.improve.single">.fun.scan.scan.improve.single:</a> A
scan1 format method would make it slightly simpler here). Then the
finished flag is cleared and the bit in the segment&#8217;s scanned table is
set.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.repeat.advance"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.repeat.advance">.fun.scan.pass.repeat.advance:</a> <tt class="docutils literal"><span class="pre">p</span></tt> is advanced past the object
and we return to the beginning of the loop.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.more"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.more">.fun.scan.pass.more:</a> At the end of a pass the finished flag is
examined.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.more.not"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.more.not">.fun.scan.pass.more.not:</a> If the finished flag is set then we are
done (see <a class="reference internal" href="#design.mps.poolawl.fun.scan.overview.finished-flag">.fun.scan.overview.finished-flag</a> above), <a class="reference internal" href="#AWLScan" title="AWLScan"><tt class="xref c c-func docutils literal"><span class="pre">AWLScan()</span></tt></a>
returns.</p>
<p><span class="target" id="design.mps.poolawl.fun.scan.pass.more.so"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.scan.pass.more.so">.fun.scan.pass.more.so:</a> Otherwise (the finished flag is reset) we
perform another pass (see <a class="reference internal" href="#design.mps.poolawl.fun.scan.pass">.fun.scan.pass</a> above).</p>
<dl class="function">
<dt id="AWLFix">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">AWLFix</tt><big>(</big>Pool<em>&nbsp;pool</em>, ScanState<em>&nbsp;ss</em>, <a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;seg</em>, <a class="reference internal" href="type.html#Ref" title="Ref">Ref</a><em>&nbsp;*refIO</em><big>)</big><a class="headerlink" href="#AWLFix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.fix"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.fix">.fun.fix:</a> <tt class="docutils literal"><span class="pre">ss-&gt;wasMarked</span></tt> is set to <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt> (clear compliance
with design.mps.fix.protocol.was-marked.conservative).</p>
<p>If the rank (<tt class="docutils literal"><span class="pre">ss-&gt;rank</span></tt>) is <tt class="docutils literal"><span class="pre">RankAMBIG</span></tt> then fix returns
immediately unless the reference is aligned to the pool alignment.</p>
<p>If the rank (<tt class="docutils literal"><span class="pre">ss-&gt;rank</span></tt>) is <tt class="docutils literal"><span class="pre">RankAMBIG</span></tt> then fix returns
immediately unless the referenced grain is allocated.</p>
<p>The bit in the marked table corresponding to the referenced grain will
be read. If it is already marked then fix returns. Otherwise (the
grain is unmarked), <tt class="docutils literal"><span class="pre">ss-&gt;wasMarked</span></tt> is set to <tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt>, the
remaining actions depend on whether the rank (<tt class="docutils literal"><span class="pre">ss-&gt;rank</span></tt>) is
<tt class="docutils literal"><span class="pre">RankWEAK</span></tt> or not. If the rank is weak then the reference is
adjusted to 0 (see design.mps.weakness) and fix returns. If the rank
is something else then the mark bit corresponding to the referenced
grain is set, and the segment is greyed using <tt class="xref c c-func docutils literal"><span class="pre">TraceSegGreyen()</span></tt>.</p>
<p>Fix returns.</p>
<dl class="function">
<dt id="AWLReclaim">
void <tt class="descname">AWLReclaim</tt><big>(</big>Pool<em>&nbsp;pool</em>, Trace<em>&nbsp;trace</em>, <a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;seg</em><big>)</big><a class="headerlink" href="#AWLReclaim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.reclaim"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.reclaim">.fun.reclaim:</a> This iterates over all allocated objects in the
segment and frees objects that are not marked. When this iteration is
complete the marked array is completely reset.</p>
<p><tt class="docutils literal"><span class="pre">p</span></tt> points to base of segment. Then:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">while</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">SegLimit</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">alloc</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span> <span class="o">++</span><span class="n">p</span><span class="p">;</span><span class="k">continue</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">q</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="cm">/* q points to just past the object pointed at by p */</span>
  <span class="k">if</span> <span class="o">!</span><span class="n">marked</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span> <span class="cm">/* reset the bits in the alloc table from p to q-1 inclusive. */</span>
  <span class="n">p</span> <span class="o">=</span> <span class="n">q</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, reset the entire marked array using <a class="reference internal" href="bt.html#BTResRange" title="BTResRange"><tt class="xref c c-func docutils literal"><span class="pre">BTResRange()</span></tt></a>.</p>
<p><span class="target" id="design.mps.poolawl.fun.reclaim.improve.pad"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.reclaim.improve.pad">.fun.reclaim.improve.pad:</a> Consider filling free ranges with padding
objects. Now reclaim doesn&#8217;t need to check that the objects are
allocated before skipping them. There may be a corresponding change
for scan as well.</p>
<dl class="function">
<dt id="AWLDescribe">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">AWLDescribe</tt><big>(</big>Pool<em>&nbsp;pool</em>, <a class="reference internal" href="../topic/plinth.html#mps_lib_FILE" title="mps_lib_FILE">mps_lib_FILE</a><em>&nbsp;*stream</em><big>)</big><a class="headerlink" href="#AWLDescribe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.describe"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.describe">.fun.describe:</a></p>
</div>
<div class="section" id="internal">
<h3>23.7.2. Internal<a class="headerlink" href="#internal" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="AWLSegCreate">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">AWLSegCreate</tt><big>(</big>AWLSeg<em>&nbsp;*awlsegReturn</em>, <a class="reference internal" href="type.html#Size" title="Size">Size</a><em>&nbsp;size</em><big>)</big><a class="headerlink" href="#AWLSegCreate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.awlsegcreate"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.awlsegcreate">.fun.awlsegcreate:</a> Creates a segment of class <tt class="xref c c-type docutils literal"><span class="pre">AWLSegClass</span></tt> of size at least <tt class="docutils literal"><span class="pre">size</span></tt>.</p>
<p><span class="target" id="design.mps.poolawl.fun.awlsegcreate.size.round"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.awlsegcreate.size.round">.fun.awlsegcreate.size.round:</a> <tt class="docutils literal"><span class="pre">size</span></tt> is rounded up to an
<tt class="docutils literal"><span class="pre">ArenaAlign</span></tt> before requesting the segment.
<span class="target" id="design.mps.poolawl.fun.awlsegcreate.size.round.justify"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.awlsegcreate.size.round.justify">.fun.awlsegcreate.size.round.justify:</a> The arena requires that all
segment sizes are aligned to the <tt class="docutils literal"><span class="pre">ArenaAlign</span></tt>.</p>
<p><span class="target" id="design.mps.poolawl.fun.awlsegcreate.where"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.awlsegcreate.where">.fun.awlsegcreate.where:</a> The segment is allocated using a
generation preference, using the generation number stored in the
<tt class="xref c c-type docutils literal"><span class="pre">AWLStruct</span></tt> (the <tt class="docutils literal"><span class="pre">gen</span></tt> field), see <a class="reference internal" href="#design.mps.poolawl.poolstruct.gen">.poolstruct.gen</a> above.</p>
<dl class="function">
<dt id="awlSegInit">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">awlSegInit</tt><big>(</big><a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;seg</em>, Pool<em>&nbsp;pool</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;base</em>, <a class="reference internal" href="type.html#Size" title="Size">Size</a><em>&nbsp;size</em>, <a class="reference internal" href="type.html#Bool" title="Bool">Bool</a><em>&nbsp;reservoirPermit</em>, va_list<em>&nbsp;args</em><big>)</big><a class="headerlink" href="#awlSegInit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.awlseginit"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.awlseginit">.fun.awlseginit:</a> Init method for <tt class="xref c c-type docutils literal"><span class="pre">AWLSegClass</span></tt>, called for
<tt class="xref c c-func docutils literal"><span class="pre">SegAlloc()</span></tt> whenever an <tt class="docutils literal"><span class="pre">AWLSeg</span></tt> is created (see
<a class="reference internal" href="#design.mps.poolawl.fun.awlsegcreate">.fun.awlsegcreate</a> above).</p>
<p><span class="target" id="design.mps.poolawl.fun.awlseginit.tables"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.awlseginit.tables">.fun.awlseginit.tables:</a> The segment&#8217;s mark scanned and alloc tables
(see <a class="reference internal" href="#design.mps.poolawl.awlseg.bt">.awlseg.bt</a> above) are allocated and initialised. The segment&#8217;s
grains field is computed and stored.</p>
<dl class="function">
<dt id="awlSegFinish">
void <tt class="descname">awlSegFinish</tt><big>(</big><a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;seg</em><big>)</big><a class="headerlink" href="#awlSegFinish" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.awlsegfinish"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.awlsegfinish">.fun.awlsegfinish:</a> Finish method for <tt class="xref c c-type docutils literal"><span class="pre">AWLSegClass</span></tt>, called from
<tt class="xref c c-func docutils literal"><span class="pre">SegFree()</span></tt>. Will free the segment&#8217;s tables (see <a class="reference internal" href="#design.mps.poolawl.awlseg.bt">.awlseg.bt</a>).</p>
<dl class="function">
<dt id="AWLSegAlloc">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">AWLSegAlloc</tt><big>(</big><a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;*baseReturn</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;*limitReturn</em>, AWLSeg<em>&nbsp;awlseg</em>, AWL<em>&nbsp;awl</em>, <a class="reference internal" href="type.html#Size" title="Size">Size</a><em>&nbsp;size</em><big>)</big><a class="headerlink" href="#AWLSegAlloc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.awlsegalloc"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.awlsegalloc">.fun.awlsegalloc:</a> Will search for a free block in the segment that
is at least size bytes long. The base address of the block is returned
in <tt class="docutils literal"><span class="pre">*baseReturn</span></tt>, the limit of the entire free block (which must be
at least as large size and may be bigger) is returned in
<tt class="docutils literal"><span class="pre">*limitReturn</span></tt>. The requested size is converted to a number of
grains, <a class="reference internal" href="bt.html#BTFindResRange" title="BTFindResRange"><tt class="xref c c-func docutils literal"><span class="pre">BTFindResRange()</span></tt></a> is called to find a run of this length in
the alloc bit-table (<a class="reference internal" href="#design.mps.poolawl.awlseg.alloc">.awlseg.alloc</a>). The return results (if it is
successful) from <a class="reference internal" href="bt.html#BTFindResRange" title="BTFindResRange"><tt class="xref c c-func docutils literal"><span class="pre">BTFindResRange()</span></tt></a> are in terms of grains, they are
converted back to addresses before returning the relevant values from
this function.</p>
<dl class="function">
<dt id="AWLDependentObject">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">AWLDependentObject</tt><big>(</big><a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;*objReturn</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;parent</em><big>)</big><a class="headerlink" href="#AWLDependentObject" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolawl.fun.dependent-object"></span><a class="mpstag reference internal" href="#design.mps.poolawl.fun.dependent-object">.fun.dependent-object:</a> This function abstracts the association
between an object and its linked dependent (see <a class="reference internal" href="#design.mps.poolawl.req.obj-format">.req.obj-format</a>).
It currently assumes that objects are Dylan Object formatted according
to design.dylan.container (see analysis.mps.poolawl.dependent.abstract
for suggested improvements). An object has a dependent object iff the
second word of the object, that is, <tt class="docutils literal"><span class="pre">((Word</span> <span class="pre">*)parent)[1]</span></tt>, is
non-<tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt>. The dependent object is the object referenced by the
second word and must be a valid object.</p>
<p>This function assumes objects are in Dylan Object Format (see
design.dylan.container). It will check that the first word looks like
a Dylan wrapper pointer. It will check that the wrapper indicates that
the wrapper has a reasonable format (namely at least one fixed field).
If the second word is <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt> it will return <tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt>. If the second
word is non-<tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt> then the contents of it will be assigned to
<tt class="docutils literal"><span class="pre">*objReturn</span></tt>, and it will return <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt>.</p>
</div>
</div>
<div class="section" id="test">
<h2>23.8. Test<a class="headerlink" href="#test" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>must create Dylan objects.</li>
<li>must create Dylan vectors with at least one fixed field.</li>
<li>must allocate weak thingies.</li>
<li>must allocate exact tables.</li>
<li>must link tables together.</li>
<li>must populate tables with junk.</li>
<li>some junk must die.</li>
</ul>
<p>Use an LO pool and an AWL pool. Three buffers. One buffer for the LO
pool, one exact buffer for the AWL pool, one weak buffer for the AWL
pool.</p>
<p>Initial test will allocate one object from each buffer and then
destroy all buffers and pools and exit</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">23. AWL pool class</a><ul>
<li><a class="reference internal" href="#introduction">23.1. Introduction</a></li>
<li><a class="reference internal" href="#requirements">23.2. Requirements</a></li>
<li><a class="reference internal" href="#definitions">23.3. Definitions</a></li>
<li><a class="reference internal" href="#overview">23.4. Overview</a></li>
<li><a class="reference internal" href="#interface">23.5. Interface</a></li>
<li><a class="reference internal" href="#data-structures">23.6. Data structures</a></li>
<li><a class="reference internal" href="#functions">23.7. Functions</a><ul>
<li><a class="reference internal" href="#external">23.7.1. External</a></li>
<li><a class="reference internal" href="#internal">23.7.2. Internal</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test">23.8. Test</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="poolams.html"
                        title="previous chapter">22. AMS pool class</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="poollo.html"
                        title="next chapter">24. LO pool class</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="poollo.html" title="24. LO pool class"
             >next</a> |</li>
        <li class="right" >
          <a href="poolams.html" title="22. AMS pool class"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" >Old design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>