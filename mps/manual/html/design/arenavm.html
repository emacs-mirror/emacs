

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3. Virtual Memory Arena &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Old design" href="old.html" />
    <link rel="next" title="4. Bit tables" href="bt.html" />
    <link rel="prev" title="2. Arena" href="arena.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="bt.html" title="4. Bit tables"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="arena.html" title="2. Arena"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" accesskey="U">Old design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="design-arenavm"></span><div class="section" id="virtual-memory-arena">
<span id="index-0"></span><h1>3. Virtual Memory Arena<a class="headerlink" href="#virtual-memory-arena" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="design.mps.arena.vm"></span><h2>3.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.arena.vm.intro"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.intro">.intro:</a> This document describes the detailed design of the Virtual
Memory Arena Class of the Memory Pool System. The VM Arena Class is
just one class available in the MPS. The generic arena part is
described in design.mps.arena.</p>
</div>
<div class="section" id="overview">
<h2>3.2. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.arena.vm.overview"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.overview">.overview:</a> VM arenas provide blocks of memory to all other parts of
the MPS in the form of &#8220;tracts&#8221; using the virtual mapping interface
(design.mps.vm) to the operating system. The VM Arena Class is not
expected to be provided on platforms that do not have virtual memory
(like MacOS, os.s7(1)).</p>
<p><span class="target" id="design.mps.arena.vm.overview.gc"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.overview.gc">.overview.gc:</a> The VM Arena Class provides some special services on
these blocks in order to facilitate garbage collection:</p>
<p><span class="target" id="design.mps.arena.vm.overview.gc.zone"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.overview.gc.zone">.overview.gc.zone:</a> Allocation of blocks with specific zones. This
means that the generic fix function (design.mps.fix) can use a fast
refset test to eliminate references to addresses that are not in the
condemned set. This assumes that a pool class that uses this placement
appropriately is being used (such as the generation placement policy
used by AMC: see design.mps.poolamc(1)) and that the pool selects the
condemned sets to coincide with zone stripes.</p>
<p><span class="target" id="design.mps.arena.vm.overview.gc.tract"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.overview.gc.tract">.overview.gc.tract:</a> A fast translation from addresses to tract.
(See design.mps.arena.req.fun.trans)</p>
</div>
<div class="section" id="notes">
<h2>3.3. Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.arena.vm.note.refset"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.note.refset">.note.refset:</a> Some of this document simply assumes that RefSets
(see the horribly incomplete design.mps.refset) have been chosen as
the solution for design.mps.arena.req.fun.set. It&#8217;s a lot simpler that
way. Both to write and understand.</p>
</div>
<div class="section" id="requirements">
<h2>3.4. Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p>Most of the requirements are in fact on the generic arena (see
design.mps.arena.req). However, many of those requirements can only be
met by a suitable arena class design.</p>
<p>Requirements particular to this arena class:</p>
<div class="section" id="placement">
<h3>3.4.1. Placement<a class="headerlink" href="#placement" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.vm.req.fun.place"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.req.fun.place">.req.fun.place:</a> It must be possible for pools to obtain tracts at
particular addresses. Such addresses shall be declared by the pool
specifying what refset zones the tracts should lie in and what refset
zones the tracts should not lie in. It is acceptable for the arena to
not always honour the request in terms of placement if it has run out
of suitable addresses.</p>
</div>
<div class="section" id="arena-partition">
<h3>3.4.2. Arena partition<a class="headerlink" href="#arena-partition" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.arena.vm.req.fun.set"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.req.fun.set">.req.fun.set:</a> See design.mps.arena.req.fun.set. The approximation
to sets of address must cooperate with the placement mechanism in the
way required by <a class="reference internal" href="#design.mps.arena.vm.req.fun.place">.req.fun.place</a> (above).</p>
</div>
</div>
<div class="section" id="architecture">
<h2>3.5. Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.arena.vm.arch.memory"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.arch.memory">.arch.memory:</a> The underlying memory is obtained from whatever
Virtual Memory interface (see design.mps.vm). &#64;&#64;&#64;&#64; Explain why this is
used.</p>
</div>
<div class="section" id="solution-ideas">
<h2>3.6. Solution ideas<a class="headerlink" href="#solution-ideas" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.arena.vm.idea.grain"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.idea.grain">.idea.grain:</a> Set the arena granularity to the grain provided by the
virtual mapping module.</p>
<p><span class="target" id="design.mps.arena.vm.idea.mem"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.idea.mem">.idea.mem:</a> Get a single large contiguous address area from the
virtual mapping interface and divide that up.</p>
<p><span class="target" id="design.mps.arena.vm.idea.table"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.idea.table">.idea.table:</a> Maintain a table with one entry per grain in order to
provide fast mapping (shift and add) between addresses and table
entries.</p>
<p><span class="target" id="design.mps.arena.vm.idea.table.figure"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.idea.table.figure">.idea.table.figure:</a> [missing figure]</p>
<p><span class="target" id="design.mps.arena.vm.idea.map"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.idea.map">.idea.map:</a> Store the pointers (<a class="reference internal" href="#design.mps.arena.vm.req.fun.trans">.req.fun.trans</a>) in the table
directly for every grain.</p>
<p><span class="target" id="design.mps.arena.vm.idea.zones"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.idea.zones">.idea.zones:</a> Partition the managed address space into zones (see
idea.zones) and provide the set approximation as a reference
signature.</p>
<p><span class="target" id="design.mps.arena.vm.idea.first-fit"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.idea.first-fit">.idea.first-fit:</a> Use a simple first-fit allocation policy for
tracts within each zone (<a class="reference internal" href="#design.mps.arena.vm.idea.zones">.idea.zones</a>). Store the freelist in the
table (<a class="reference internal" href="#design.mps.arena.vm.idea.table">.idea.table</a>).</p>
<p><span class="target" id="design.mps.arena.vm.idea.base"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.idea.base">.idea.base:</a> Store information about each contiguous area (allocated
of free) in the table entry (<a class="reference internal" href="#design.mps.arena.vm.idea.table">.idea.table</a>) corresponding to the base
address of the area.</p>
<p><span class="target" id="design.mps.arena.vm.idea.shadow"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.idea.shadow">.idea.shadow:</a> Use the table (<a class="reference internal" href="#design.mps.arena.vm.idea.table">.idea.table</a>) as a &#8220;shadow&#8221; of the
operating system&#8217;s page table. Keep information such as last access,
protection, etc. in this table, since we can&#8217;t get at this information
otherwise.</p>
<p><span class="target" id="design.mps.arena.vm.idea.barrier"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.idea.barrier">.idea.barrier:</a> Use the table (<a class="reference internal" href="#design.mps.arena.vm.idea.table">.idea.table</a>) to implement the
software barrier. Each segment can have a read and/or write barrier
placed on it by each process. (<span class="target" id="design.mps.arena.vm.idea.barrier.bits"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.idea.barrier.bits">.idea.barrier.bits:</a> Store a
bit-pattern which remembers which process protected what.) This will
give a fast translation from a barrier-protected address to the
barrier handler via the process table.</p>
<p><span class="target" id="design.mps.arena.vm.idea.demand-table"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.idea.demand-table">.idea.demand-table:</a> For a 1&nbsp;GiB managed address space with a 4&nbsp;KiB
page size, the table will have 256K-entries. At, say, four words per
entry, this is 4&nbsp;MiB of table. Although this is only an 0.4%, the
table shouldn&#8217;t be preallocated or initially it is an infinite
overhead, and with 1&nbsp;MiB active, it is a 300% overhead! The address
space for the table should be reserved, but the pages for it mapped
and unmapped on demand. By storing the table in a tract, the status of
the table&#8217;s pages can be determined by looking at it&#8217;s own entries in
itself, and thus the translation lookup (<a class="reference internal" href="#design.mps.arena.vm.req.fun.trans">.req.fun.trans</a>) is slowed
to two lookups rather than one.</p>
<p><span class="target" id="design.mps.arena.vm.idea.pool"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.idea.pool">.idea.pool:</a> Make the Arena Manager a pool class. Arena
initialization becomes pool creation. Tract allocation becomes
<tt class="xref c c-func docutils literal"><span class="pre">PoolAlloc()</span></tt>. Other operations become class-specific operations on
the &#8220;arena pool&#8221;.</p>
</div>
<div class="section" id="data-structures">
<h2>3.7. Data structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.arena.vm.tables"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.tables">.tables:</a> There are two table data structures: a page table, and an
alloc table.</p>
<p><span class="target" id="design.mps.arena.vm.table.page.map"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.table.page.map">.table.page.map:</a> Each page in the VM has a corresponding page table
entry.</p>
<p><span class="target" id="design.mps.arena.vm.table.page.linear"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.table.page.linear">.table.page.linear:</a> The table is a linear array of PageStruct
entries; there is a simple mapping between the index in the table and
the base address in the VM. Namely:</p>
<ul class="simple">
<li>index to base address: <tt class="docutils literal"><span class="pre">base-address</span> <span class="pre">=</span> <span class="pre">arena-base</span> <span class="pre">+</span> <span class="pre">(index</span> <span class="pre">*</span> <span class="pre">page-size)</span></tt></li>
<li>base address to index: <tt class="docutils literal"><span class="pre">index</span> <span class="pre">=</span> <span class="pre">(base-address</span> <span class="pre">-</span> <span class="pre">arena-base)</span> <span class="pre">/</span> <span class="pre">page-size</span></tt></li>
</ul>
<p><span class="target" id="design.mps.arena.vm.table.page.partial"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.table.page.partial">.table.page.partial:</a> The table is partially mapped on an
&#8220;as-needed&#8221; basis. The function <tt class="xref c c-func docutils literal"><span class="pre">unusedTablePages()</span></tt> identifies
entirely unused pages occupied by the page table itself (that is,
those pages of the page table which are occupied by <tt class="xref c c-type docutils literal"><span class="pre">PageStruct</span></tt>
objects which all describe free pages). Tract allocation and freeing
use this function to map and unmap the page table with no hysteresis.
(There is restriction on the parameters you may pass to
<tt class="xref c c-func docutils literal"><span class="pre">unusedTablePages()</span></tt>.)</p>
<p><span class="target" id="design.mps.arena.vm.table.page.tract"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.table.page.tract">.table.page.tract:</a> Each page table entry contains a tract, which is
only valid if it is allocated to a pool. If it is not allocated to a
pool, the fields of the tract are used for other purposes. (See
design.mps.arena.tract.field.pool)</p>
<p><span class="target" id="design.mps.arena.vm.table.alloc"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.table.alloc">.table.alloc:</a> The alloc table is a simple bit table (implemented
using the BT module, design.mps.bt).</p>
<p><span class="target" id="design.mps.arena.vm.table.alloc.map"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.table.alloc.map">.table.alloc.map:</a> Each page in the VM has a corresponding alloc
table entry.</p>
<p><span class="target" id="design.mps.arena.vm.table.alloc.semantics"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.table.alloc.semantics">.table.alloc.semantics:</a> The bit in the alloc table is set iff the
corresponding page is allocated (to a pool).</p>
</div>
<div class="section" id="id1">
<h2>3.8. Notes<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.arena.vm.fig.page"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.fig.page">.fig.page:</a> How the pages in the arena area are represented in the
tables.</p>
<p>[missing figure]</p>
<p><span class="target" id="design.mps.arena.vm.fig.count"></span><a class="mpstag reference internal" href="#design.mps.arena.vm.fig.count">.fig.count:</a> How a count table can be used to partially map the page
table, as proposed in <a class="reference external" href="https://info.ravenbrook.com/project/mps/import/2001-11-05/mmprevol/request/dylan/170049">request.dylan.170049.sol.map</a>.</p>
<p>[missing figure]</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Virtual Memory Arena</a><ul>
<li><a class="reference internal" href="#introduction">3.1. Introduction</a></li>
<li><a class="reference internal" href="#overview">3.2. Overview</a></li>
<li><a class="reference internal" href="#notes">3.3. Notes</a></li>
<li><a class="reference internal" href="#requirements">3.4. Requirements</a><ul>
<li><a class="reference internal" href="#placement">3.4.1. Placement</a></li>
<li><a class="reference internal" href="#arena-partition">3.4.2. Arena partition</a></li>
</ul>
</li>
<li><a class="reference internal" href="#architecture">3.5. Architecture</a></li>
<li><a class="reference internal" href="#solution-ideas">3.6. Solution ideas</a></li>
<li><a class="reference internal" href="#data-structures">3.7. Data structures</a></li>
<li><a class="reference internal" href="#id1">3.8. Notes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="arena.html"
                        title="previous chapter">2. Arena</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="bt.html"
                        title="next chapter">4. Bit tables</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="bt.html" title="4. Bit tables"
             >next</a> |</li>
        <li class="right" >
          <a href="arena.html" title="2. Arena"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" >Old design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>