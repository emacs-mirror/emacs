

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>22. AMS pool class &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Old design" href="old.html" />
    <link rel="next" title="23. AWL pool class" href="poolawl.html" />
    <link rel="prev" title="21. AMC pool class" href="poolamc.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="poolawl.html" title="23. AWL pool class"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="poolamc.html" title="21. AMC pool class"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" accesskey="U">Old design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="design-poolams"></span><div class="section" id="ams-pool-class">
<span id="index-0"></span><h1>22. AMS pool class<a class="headerlink" href="#ams-pool-class" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="design.mps.poolams"></span><h2>22.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolams.intro"></span><a class="mpstag reference internal" href="#design.mps.poolams.intro">.intro:</a> This is the design of the AMS pool class.</p>
<p><span class="target" id="design.mps.poolams.readership"></span><a class="mpstag reference internal" href="#design.mps.poolams.readership">.readership:</a> MM developers.</p>
<p><span class="target" id="design.mps.poolams.source"></span><a class="mpstag reference internal" href="#design.mps.poolams.source">.source:</a> design.mps.buffer, design.mps.trace, design.mps.scan,
design.mps.action and design.mps.class-interface [none of these were
actually used &#8211; pekka 1998-04-21].  No requirements doc [we need a
req.mps that captures the commonalities between the products &#8211; pekka
1998-01-27].</p>
</div>
<div class="section" id="overview">
<h2>22.2. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolams.overview"></span><a class="mpstag reference internal" href="#design.mps.poolams.overview">.overview:</a> This document describes the design of the AMS (Automatic
Mark-and-Sweep) pool class. The AMS pool is a proof-of-concept design
for a mark-sweep pool in the MPS. It&#8217;s not meant to be efficient, but
it could serve as a model for an implementation of a more advanced
pool (such as EPVM).</p>
</div>
<div class="section" id="requirements">
<h2>22.3. Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolams.req.mark-sweep"></span><a class="mpstag reference internal" href="#design.mps.poolams.req.mark-sweep">.req.mark-sweep:</a> The pool must use a mark-and-sweep GC algorithm.</p>
<p><span class="target" id="design.mps.poolams.req.colour"></span><a class="mpstag reference internal" href="#design.mps.poolams.req.colour">.req.colour:</a> The colour representation should be as efficient as
possible.</p>
<p><span class="target" id="design.mps.poolams.req.incremental"></span><a class="mpstag reference internal" href="#design.mps.poolams.req.incremental">.req.incremental:</a> The pool must support incremental GC.</p>
<p><span class="target" id="design.mps.poolams.req.ambiguous"></span><a class="mpstag reference internal" href="#design.mps.poolams.req.ambiguous">.req.ambiguous:</a> The pool must support ambiguous references to
objects in it (but ambiguous references into the middle of an object
do not preserve the object).</p>
<p><span class="target" id="design.mps.poolams.req.format"></span><a class="mpstag reference internal" href="#design.mps.poolams.req.format">.req.format:</a> The pool must be formatted, for generality.</p>
<p><span class="target" id="design.mps.poolams.req.correct"></span><a class="mpstag reference internal" href="#design.mps.poolams.req.correct">.req.correct:</a> The design and the implementation should be simple
enough to be seen to be correct.</p>
<p><span class="target" id="design.mps.poolams.req.simple"></span><a class="mpstag reference internal" href="#design.mps.poolams.req.simple">.req.simple:</a> Features not related to mark-and-sweep GC should
initially be implemented as simply as possible, in order to save
development effort.</p>
<p><span class="target" id="design.mps.poolams.not-req.grey"></span><a class="mpstag reference internal" href="#design.mps.poolams.not-req.grey">.not-req.grey:</a> We haven&#8217;t figured out how buffers ought to work
with a grey mutator, so we use <a class="reference internal" href="#design.mps.poolams.req.correct">.req.correct</a> to allow us to design a
pool that doesn&#8217;t work in that phase. This is acceptable as long as we
haven&#8217;t actually implemented grey mutator collection.</p>
</div>
<div class="section" id="architecture">
<h2>22.4. Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h2>
<div class="section" id="subclassing">
<h3>22.4.1. Subclassing<a class="headerlink" href="#subclassing" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolams.subclass"></span><a class="mpstag reference internal" href="#design.mps.poolams.subclass">.subclass:</a> Since we expect to have many mark-and-sweep pools, we
build in some protocol for subclasses to modify various aspects of the
behaviour. Notably there&#8217;s a subclassable segment class, and a
protocol for performing iteration.</p>
</div>
<div class="section" id="allocation">
<h3>22.4.2. Allocation<a class="headerlink" href="#allocation" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolams.align"></span><a class="mpstag reference internal" href="#design.mps.poolams.align">.align:</a> We divide the segments in grains, each the size of the
format alignment. <span class="target" id="design.mps.poolams.alloc-bit-table"></span><a class="mpstag reference internal" href="#design.mps.poolams.alloc-bit-table">.alloc-bit-table:</a> We keep track of allocated
grains using a bit table. This allows a simple implementation of
allocation and freeing using the bit table operators, satisfying
<a class="reference internal" href="#design.mps.poolams.req.simple">.req.simple</a>, and can simplify the GC routines. Eventually, this
should use some sophisticated allocation technique suitable for
non-moving automatic pools.</p>
<p><span class="target" id="design.mps.poolams.buffer"></span><a class="mpstag reference internal" href="#design.mps.poolams.buffer">.buffer:</a> We use buffered allocation, satisfying
<a class="reference internal" href="#design.mps.poolams.req.incremental">.req.incremental</a>. The AMC buffer technique is reused, although it
is not suitable for non-moving pools, but req.simple allows us to do
that for now.</p>
<p><span class="target" id="design.mps.poolams.extend"></span><a class="mpstag reference internal" href="#design.mps.poolams.extend">.extend:</a> If there&#8217;s no space in any existing segment, a new segment
is allocated. The actual class is allowed to decide the size of the
new segment.</p>
<p><span class="target" id="design.mps.poolams.no-alloc"></span><a class="mpstag reference internal" href="#design.mps.poolams.no-alloc">.no-alloc:</a> Do not support <tt class="xref c c-func docutils literal"><span class="pre">PoolAlloc()</span></tt>, because we can&#8217;t support
one-phase allocation for a scannable pool (unless we disallow
incremental collection). For exact details, see design.mps.buffer.</p>
<p><span class="target" id="design.mps.poolams.no-free"></span><a class="mpstag reference internal" href="#design.mps.poolams.no-free">.no-free:</a> Do not support <tt class="xref c c-func docutils literal"><span class="pre">PoolFree()</span></tt>, because automatic pools
don&#8217;t need explicit free and having it encourages clients to use it
(and therefore to have dangling pointers, double frees, and other
memory management errors.)</p>
</div>
<div class="section" id="colours">
<h3>22.4.3. Colours<a class="headerlink" href="#colours" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolams.colour"></span><a class="mpstag reference internal" href="#design.mps.poolams.colour">.colour:</a> Objects in a segment which is <em>not</em> condemned (for some
trace) take their colour (for this trace) from the segment.</p>
<p><span class="target" id="design.mps.poolams.colour.object"></span><a class="mpstag reference internal" href="#design.mps.poolams.colour.object">.colour.object:</a> Since we need to implement a non-copying GC, we
keep track of the colour of each object in a condemned segment
separately. For this, we use bit tables with a bit for each grain.
This format is fast to access, has better locality than mark bits in
the objects themselves, and allows cheap interoperation with the
allocation bit table.</p>
<p><span class="target" id="design.mps.poolams.colour.encoding"></span><a class="mpstag reference internal" href="#design.mps.poolams.colour.encoding">.colour.encoding:</a> As to the details, we follow
analysis.non-moving-colour(3), implementing both the alloc-white
sharing option described in
analysis.non-moving-colour.constraint.reclaim.white-free-bit and the
vanilla three-table option, because the former cannot work with
interior pointers. However, the colour encoding in both is the same.</p>
<p><span class="target" id="design.mps.poolams.ambiguous.middle"></span><a class="mpstag reference internal" href="#design.mps.poolams.ambiguous.middle">.ambiguous.middle:</a> We will allow ambiguous references into the
middle of an object (as required by <a class="reference internal" href="#design.mps.poolams.req.ambiguous">.req.ambiguous</a>), using the
trick in analysis.non-moving-colour.interior.ambiguous-only to speed
up scanning.</p>
<p><span class="target" id="design.mps.poolams.interior-pointer"></span><a class="mpstag reference internal" href="#design.mps.poolams.interior-pointer">.interior-pointer:</a> Note that non-ambiguous interior pointers are
outlawed.</p>
<p><span class="target" id="design.mps.poolams.colour.alloc"></span><a class="mpstag reference internal" href="#design.mps.poolams.colour.alloc">.colour.alloc:</a> Objects are allocated black. This is the most
efficient alternative for traces in the black mutator phase, and
.not-req.grey means that&#8217;s sufficient.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">Some day, we need to think about allocating grey or white during
the grey mutator phase.</p>
</div>
</div>
<div class="section" id="scanning">
<h3>22.4.4. Scanning<a class="headerlink" href="#scanning" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolams.scan.segment"></span><a class="mpstag reference internal" href="#design.mps.poolams.scan.segment">.scan.segment:</a> The tracer protocol requires (for segment barrier
hits) that there is a method for scanning a segment and turning all
grey objects on it black. This cannot be achieved with a single
sequential sweep over the segment, since objects that the sweep has
already passed may become grey as later objects are scanned.</p>
<p><span class="target" id="design.mps.poolams.scan.graph"></span><a class="mpstag reference internal" href="#design.mps.poolams.scan.graph">.scan.graph:</a> For a non-moving GC, it is more efficient to trace
along the reference graph than segment by segment. It also allows
passing type information from fix to scan. Currently, the tracer
doesn&#8217;t offer this option when it&#8217;s polling for work.</p>
<p><span class="target" id="design.mps.poolams.scan.stack"></span><a class="mpstag reference internal" href="#design.mps.poolams.scan.stack">.scan.stack:</a> Tracing along the reference graph cannot be done by
recursive descent, because we can&#8217;t guarantee that the stack won&#8217;t
overflow. We can, however, maintain an explicit stack of things to
trace, and fall back on iterative methods (<a class="reference internal" href="#design.mps.poolams.scan.iter">.scan.iter</a>) when it
overflows and can&#8217;t be extended.</p>
<p><span class="target" id="design.mps.poolams.scan.iter"></span><a class="mpstag reference internal" href="#design.mps.poolams.scan.iter">.scan.iter:</a> As discussed in <a class="reference internal" href="#design.mps.poolams.scan.segment">.scan.segment</a>, when scanning a
segment, we need to ensure that there are no grey objects in the
segment when the scan method returns. We can do this by iterating a
sequential scan over the segment until nothing is grey (see
<a class="reference internal" href="#design.mps.poolams.marked.scan">.marked.scan</a> for details).</p>
<p><span class="target" id="design.mps.poolams.scan.iter.only"></span><a class="mpstag reference internal" href="#design.mps.poolams.scan.iter.only">.scan.iter.only:</a> Some iterative method is needed as a fallback for
the more advanced methods, and as this is the simplest way of
implementing the current tracer protocol, we will start by
implementing it as the only scanning method.</p>
<p><span class="target" id="design.mps.poolams.scan.buffer"></span><a class="mpstag reference internal" href="#design.mps.poolams.scan.buffer">.scan.buffer:</a> We do not scan between ScanLimit and Limit of a
buffer (see <a class="reference internal" href="#design.mps.poolams.iteration.buffer">.iteration.buffer</a>), as usual.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">design.mps.buffer should explain why this works, but doesn&#8217;t.
Pekka P. Pirinen, 1998-02-11.</p>
</div>
<p><span class="target" id="design.mps.poolams.fix.to-black"></span><a class="mpstag reference internal" href="#design.mps.poolams.fix.to-black">.fix.to-black:</a> When fixing a reference to a white object, if the
segment does not refer to the white set, the object cannot refer to
the white set, and can therefore be marked as black immediately
(rather than grey).</p>
</div>
</div>
<div class="section" id="implementation">
<h2>22.5. Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="colour">
<h3>22.5.1. Colour<a class="headerlink" href="#colour" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolams.colour.determine"></span><a class="mpstag reference internal" href="#design.mps.poolams.colour.determine">.colour.determine:</a> Following the plan in <a class="reference internal" href="#design.mps.poolams.colour">.colour</a>, if
<tt class="docutils literal"><span class="pre">SegWhite(seg)</span></tt> includes the trace, the colour of an object is given
by the bit tables. Otherwise if <tt class="docutils literal"><span class="pre">SegGrey(seg)</span></tt> includes the trace,
all the objects are grey. Otherwise all the objects are black.</p>
<p><span class="target" id="design.mps.poolams.colour.bits"></span><a class="mpstag reference internal" href="#design.mps.poolams.colour.bits">.colour.bits:</a> As we only have searches for runs of zero bits, we use
two bit tables, the non-grey and non-white tables, but this is hidden
beneath a layer of macros talking about grey and white in positive
terms.</p>
<p><span class="target" id="design.mps.poolams.colour.single"></span><a class="mpstag reference internal" href="#design.mps.poolams.colour.single">.colour.single:</a> We have only implemented a single set of mark and
scan tables, so we can only condemn a segment for one trace at a time.
This is checked for in condemnation. If we want to do overlapping
white sets, each trace needs its own set of tables.</p>
<p><span class="target" id="design.mps.poolams.colour.check"></span><a class="mpstag reference internal" href="#design.mps.poolams.colour.check">.colour.check:</a> The grey-and-non-white state is illegal, and free
objects must be white as explained in
analysis.non-moving-colour.contraint.reclaim.</p>
</div>
<div class="section" id="iteration">
<h3>22.5.2. Iteration<a class="headerlink" href="#iteration" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolams.iteration"></span><a class="mpstag reference internal" href="#design.mps.poolams.iteration">.iteration:</a> Scan, reclaim and other operations need to iterate over
all objects in a segment. We abstract this into a single iteration
function, even though we no longer use it for reclaiming and rarely
for scanning.</p>
<p><span class="target" id="design.mps.poolams.iteration.buffer"></span><a class="mpstag reference internal" href="#design.mps.poolams.iteration.buffer">.iteration.buffer:</a> Iteration skips directly from ScanLimit to Limit
of a buffer. This is because this area may contain
partially-initialized and uninitialized data, which cannot be
processed. Since the iteration skips the buffer, callers need to take
the appropriate action, if any, on it.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">ScanLimit is used for reasons which are not documented in
design.mps.buffer.</p>
</div>
</div>
<div class="section" id="scanning-algorithm">
<h3>22.5.3. Scanning Algorithm<a class="headerlink" href="#scanning-algorithm" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolams.marked"></span><a class="mpstag reference internal" href="#design.mps.poolams.marked">.marked:</a> Each segment has a <tt class="docutils literal"><span class="pre">marksChanged</span></tt> flag, indicating
whether anything in it has been made grey since the last scan
iteration (<a class="reference internal" href="#design.mps.poolams.scan.iter">.scan.iter</a>) started. This flag only concerns the colour
of objects with respect to the trace for which the segment is
condemned, as this is the only trace for which objects in the segment
are being made grey by fixing. Note that this flag doesn&#8217;t imply that
there are grey objects in the segment, because the grey objects might
have been subsequently scanned and blackened.</p>
<p><span class="target" id="design.mps.poolams.marked.fix"></span><a class="mpstag reference internal" href="#design.mps.poolams.marked.fix">.marked.fix:</a> The <tt class="docutils literal"><span class="pre">marksChanged</span></tt> flag is set <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt> by
<tt class="xref c c-func docutils literal"><span class="pre">AMSFix()</span></tt> when an object is made grey.</p>
<p><span class="target" id="design.mps.poolams.marked.scan"></span><a class="mpstag reference internal" href="#design.mps.poolams.marked.scan">.marked.scan:</a> <tt class="xref c c-func docutils literal"><span class="pre">AMSScan()</span></tt> must blacken all grey objects on the
segment, so it must iterate over the segment until all grey objects
have been seen. Scanning an object in the segment might grey another
one (<a class="reference internal" href="#design.mps.poolams.marked.fix">.marked.fix</a>), so the scanner iterates until this flag is
<tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt>, setting it to <tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt> before each scan. It is safe to
scan the segment even if it contains nothing grey.</p>
<p><span class="target" id="design.mps.poolams.marked.scan.fail"></span><a class="mpstag reference internal" href="#design.mps.poolams.marked.scan.fail">.marked.scan.fail:</a> If the format scanner returns failure (see
protocol.mps.scanning), we abort the scan in the middle of a segment.
So in this case the marksChanged flag is set back to TRUE, because we
may not have blackened all grey objects.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">Is that the best reference for the format scanner?</p>
</div>
<p><span class="target" id="design.mps.poolams.marked.unused"></span><a class="mpstag reference internal" href="#design.mps.poolams.marked.unused">.marked.unused:</a> The <tt class="docutils literal"><span class="pre">marksChanged</span></tt> flag is meaningless unless the
segment is condemned. We make it <tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt> in these circumstances.</p>
<p><span class="target" id="design.mps.poolams.marked.condemn"></span><a class="mpstag reference internal" href="#design.mps.poolams.marked.condemn">.marked.condemn:</a> Condemnation makes all objects in a segment either
black or white, leaving nothing grey, so it doesn&#8217;t need to set the
<tt class="docutils literal"><span class="pre">marksChanged</span></tt> flag which must already be <tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt>.</p>
<p><span class="target" id="design.mps.poolams.marked.reclaim"></span><a class="mpstag reference internal" href="#design.mps.poolams.marked.reclaim">.marked.reclaim:</a> When a segment is reclaimed, it can contain
nothing marked as grey, so the <tt class="docutils literal"><span class="pre">marksChanged</span></tt> flag must already be
<tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt>.</p>
<p><span class="target" id="design.mps.poolams.marked.blacken"></span><a class="mpstag reference internal" href="#design.mps.poolams.marked.blacken">.marked.blacken:</a> When the tracer decides not to scan, but to call
<tt class="xref c c-func docutils literal"><span class="pre">PoolBlacken()</span></tt>, we know that any greyness can be removed.
<tt class="xref c c-func docutils literal"><span class="pre">AMSBlacken()</span></tt> does this and resets the <tt class="docutils literal"><span class="pre">marksChanged</span></tt> flag, if it
finds that the segment has been condemned.</p>
<p><span class="target" id="design.mps.poolams.marked.clever"></span><a class="mpstag reference internal" href="#design.mps.poolams.marked.clever">.marked.clever:</a> AMS could be clever about not setting the
<tt class="docutils literal"><span class="pre">marksChanged</span></tt> flag, if the fixed object is ahead of the current
scan pointer. It could also keep low- and high-water marks of grey
objects, but we don&#8217;t need to implement these improvements at first.</p>
</div>
<div class="section" id="id1">
<h3>22.5.4. Allocation<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolams.buffer-init"></span><a class="mpstag reference internal" href="#design.mps.poolams.buffer-init">.buffer-init:</a> We take one init arg to set the Rank on the buffer,
just to see how it&#8217;s done.</p>
<p><span class="target" id="design.mps.poolams.no-bit"></span><a class="mpstag reference internal" href="#design.mps.poolams.no-bit">.no-bit:</a> As an optimization, we won&#8217;t use the alloc bit table until
the first reclaim on the segment. Before that, we just keep a
high-water mark.</p>
<p><span class="target" id="design.mps.poolams.fill"></span><a class="mpstag reference internal" href="#design.mps.poolams.fill">.fill:</a> <tt class="xref c c-func docutils literal"><span class="pre">AMSBufferFill()</span></tt> takes the simplest approach: it iterates
over the segments in the pool, looking for one which can be used to
refill the buffer.</p>
<p><span class="target" id="design.mps.poolams.fill.colour"></span><a class="mpstag reference internal" href="#design.mps.poolams.fill.colour">.fill.colour:</a> The objects allocated from the new buffer must be
black for all traces (<a class="reference internal" href="#design.mps.poolams.colour.alloc">.colour.alloc</a>), so putting it on a black
segment (meaning one where neither <tt class="docutils literal"><span class="pre">SegWhite(seg)</span></tt> nor
<tt class="docutils literal"><span class="pre">SegGrey(seg)</span></tt> include the trace, see <a class="reference internal" href="#design.mps.poolams.colour.determine">.colour.determine</a>) is
obviously OK. White segments (where <tt class="docutils literal"><span class="pre">SegWhite(seg)</span></tt> includes the
trace) are also fine, as we can use the colour tables to make it
black. At first glance, it seems we can&#8217;t put it on a segment that is
grey but not white for some trace (one where <tt class="docutils literal"><span class="pre">SegWhite(seg)</span></tt> doesn&#8217;t
include the trace, but <tt class="docutils literal"><span class="pre">SegGrey(seg)</span></tt> does), because the new objects
would become grey as the buffer&#8217;s ScanLimit advanced. However, in many
configurations, the mutator would hit a barrier as soon as it started
initializing the object, which would flip the buffer. In fact, the
current (2002-01) implementation of buffers assumes buffers are black,
so they&#8217;d better.</p>
<p><span class="target" id="design.mps.poolams.fill.colour.reclaim"></span><a class="mpstag reference internal" href="#design.mps.poolams.fill.colour.reclaim">.fill.colour.reclaim:</a> In fact, putting a buffer on a condemned
segment will screw up the accounting in <a class="reference internal" href="poolamc.html#AMCReclaim" title="AMCReclaim"><tt class="xref c c-func docutils literal"><span class="pre">AMCReclaim()</span></tt></a>, so it&#8217;s
disallowed.</p>
<p><span class="target" id="design.mps.poolams.fill.slow"></span><a class="mpstag reference internal" href="#design.mps.poolams.fill.slow">.fill.slow:</a> <tt class="xref c c-func docutils literal"><span class="pre">AMSBufferFill()</span></tt> gets progressively slower as more
segments fill up, as it laboriously checks whether the buffer can be
refilled from each segment, by inspecting the allocation bit map. This
is helped a bit by keeping count of free grains in each segment, but
it still spends a lot of time iterating over all the full segments
checking the free size. Obviously, this can be much improved (we could
keep track of the largest free block in the segment and in the pool,
or we could keep the segments in some more efficient structure, or we
could have a real free list structure).</p>
<p><span class="target" id="design.mps.poolams.fill.extend"></span><a class="mpstag reference internal" href="#design.mps.poolams.fill.extend">.fill.extend:</a> If there&#8217;s no space in any existing segment, the
<tt class="docutils literal"><span class="pre">segSize</span></tt> method is called to decide the size of the new segment to
allocate. If that fails, the code tries to allocate a segment that&#8217;s
just large enough to satisfy the request.</p>
<p><span class="target" id="design.mps.poolams.empty"></span><a class="mpstag reference internal" href="#design.mps.poolams.empty">.empty:</a> <tt class="xref c c-func docutils literal"><span class="pre">AMSBufferEmpty()</span></tt> makes the unused space free, since
there&#8217;s no reason not to. We have to adjust the colour tables as well,
since these grains were black and now they need to be white (or at
least encoded -G and W).</p>
<p><span class="target" id="design.mps.poolams.reclaim.empty.buffer"></span><a class="mpstag reference internal" href="#design.mps.poolams.reclaim.empty.buffer">.reclaim.empty.buffer:</a> Segments which after reclaim only contain a
buffer could be destroyed by trapping the buffer, but there&#8217;s no point
to this.</p>
</div>
<div class="section" id="initialization">
<h3>22.5.5. Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolams.init"></span><a class="mpstag reference internal" href="#design.mps.poolams.init">.init:</a> The initialization method <tt class="xref c c-func docutils literal"><span class="pre">AMSInit()</span></tt> takes three
additional arguments: the format of objects allocated in the pool, the
chain that controls GC timing, and a flag for supporting ambiguous
references.</p>
<p><span class="target" id="design.mps.poolams.init.share"></span><a class="mpstag reference internal" href="#design.mps.poolams.init.share">.init.share:</a> If support for ambiguity is required, the
<tt class="docutils literal"><span class="pre">shareAllocTable</span></tt> flag is reset to indicate the pool uses three
separate bit tables, otherwise it is set and the pool shares a table
for non-white and alloc (see <a class="reference internal" href="#design.mps.poolams.colour.encoding">.colour.encoding</a>).</p>
<p><span class="target" id="design.mps.poolams.init.align"></span><a class="mpstag reference internal" href="#design.mps.poolams.init.align">.init.align:</a> The pool alignment is set equal to the format
alignment (see design.mps.align).</p>
<p><span class="target" id="design.mps.poolams.init.internal"></span><a class="mpstag reference internal" href="#design.mps.poolams.init.internal">.init.internal:</a> Subclasses call <tt class="xref c c-func docutils literal"><span class="pre">AMSInitInternal()</span></tt> to avoid the
problems of sharing <tt class="docutils literal"><span class="pre">va_list</span></tt> and emitting a superfluous
<tt class="docutils literal"><span class="pre">PoolInitAMS</span></tt> event.</p>
</div>
<div class="section" id="condemnation">
<h3>22.5.6. Condemnation<a class="headerlink" href="#condemnation" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolams.condemn.buffer"></span><a class="mpstag reference internal" href="#design.mps.poolams.condemn.buffer">.condemn.buffer:</a> Buffers are not condemned, instead they are
coloured black, to make sure that the objects allocated will be black,
following <a class="reference internal" href="#design.mps.poolams.colour.alloc">.colour.alloc</a> (or, if you wish, because buffers are
ignored like free space, so need the same encoding).</p>
</div>
<div class="section" id="reclaim">
<h3>22.5.7. Reclaim<a class="headerlink" href="#reclaim" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolams.reclaim"></span><a class="mpstag reference internal" href="#design.mps.poolams.reclaim">.reclaim:</a> Reclaim uses either of analysis.non-moving-colour
.constraint.reclaim.white-free-bit (just reuse the non-white table as
the alloc table) or
analysis.non-moving-colour.constraint.reclaim.free-bit (copy it),
depending on the shareAllocTable flag (as set by <a class="reference internal" href="#design.mps.poolams.init.share">.init.share</a>).
However, bit table still has to be iterated over to count the free
grains. Also, in a debug pool, each white block has to be splatted.</p>
</div>
<div class="section" id="segment-merging-and-splitting">
<h3>22.5.8. Segment merging and splitting<a class="headerlink" href="#segment-merging-and-splitting" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolams.split-merge"></span><a class="mpstag reference internal" href="#design.mps.poolams.split-merge">.split-merge:</a> We provide methods for splitting and merging AMS
segments. The pool implementation doesn&#8217;t cause segments to be split
or merged &#8211; but a subclass might want to do this (see
<a class="reference internal" href="#design.mps.poolams.stress.split-merge">.stress.split-merge</a>). The methods serve as an example of how to
implement this facility.</p>
<p><span class="target" id="design.mps.poolams.split-merge.constrain"></span><a class="mpstag reference internal" href="#design.mps.poolams.split-merge.constrain">.split-merge.constrain:</a> There are some additional constraints on
what segments may be split or merged:</p>
<ul>
<li><p class="first"><span class="target" id="design.mps.poolams.split-merge.constrain.align"></span><a class="mpstag reference internal" href="#design.mps.poolams.split-merge.constrain.align">.split-merge.constrain.align:</a> Segments may only be split or
merged at an address which is aligned to the pool alignment as well
as to the arena alignment.</p>
<p><span class="target" id="design.mps.poolams.split-merge.constrain.align.justify"></span><a class="mpstag reference internal" href="#design.mps.poolams.split-merge.constrain.align.justify">.split-merge.constrain.align.justify:</a> This constraint is implied
by the design of allocation and colour tables, which cannot
represent segments starting at unaligned addresses. The constraint
only arises if the pool alignment is larger than the arena
alignment. There&#8217;s no requirement to split segments at unaligned
addresses.</p>
</li>
<li><p class="first"><span class="target" id="design.mps.poolams.split-merge.constrain.empty"></span><a class="mpstag reference internal" href="#design.mps.poolams.split-merge.constrain.empty">.split-merge.constrain.empty:</a> The higher segment must be empty.
That is, the higher segment passed to <a class="reference internal" href="seg.html#SegMerge" title="SegMerge"><tt class="xref c c-func docutils literal"><span class="pre">SegMerge()</span></tt></a> must be empty,
and the higher segment returned by <a class="reference internal" href="seg.html#SegSplit" title="SegSplit"><tt class="xref c c-func docutils literal"><span class="pre">SegSplit()</span></tt></a> must be empty.</p>
<p><span class="target" id="design.mps.poolams.split-merge.constrain.empty.justify"></span><a class="mpstag reference internal" href="#design.mps.poolams.split-merge.constrain.empty.justify">.split-merge.constrain.empty.justify:</a> This constraint makes the
code significantly simpler. There&#8217;s no requirement for a more
complex solution at the moment (as the purpose is primarily
pedagogic).</p>
</li>
</ul>
<p><span class="target" id="design.mps.poolams.split-merge.fail"></span><a class="mpstag reference internal" href="#design.mps.poolams.split-merge.fail">.split-merge.fail:</a> The split and merge methods are not proper
anti-methods for each other (see
design.mps.seg.split-merge.fail.anti.no). Methods will not reverse the
side-effects of their counterparts if the allocation of the colour and
allocation bit tables should fail. Client methods which over-ride
split and merge should not be written in such a way that they might
detect failure after calling the next method, unless they have reason
to know that the bit table allocations will not fail.</p>
</div>
</div>
<div class="section" id="testing">
<h2>22.6. Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolams.stress"></span><a class="mpstag reference internal" href="#design.mps.poolams.stress">.stress:</a> There&#8217;s a stress test, MMsrc!amsss.c, that does 800 kB of
allocation, enough for about three GCs. It uses a modified Dylan
format, and checks for corruption by the GC. Both ambiguous and exact
roots are tested.</p>
<p><span class="target" id="design.mps.poolams.stress.split-merge"></span><a class="mpstag reference internal" href="#design.mps.poolams.stress.split-merge">.stress.split-merge:</a> There&#8217;s also a stress test for segment
splitting and merging, MMsrc!segsmss.c. This is similar to amsss.c &#8211;
but it defines a subclass of AMS, and causes segments to be split and
merged. Both buffered and non-buffered segments are split / merged.</p>
</div>
<div class="section" id="notes">
<h2>22.7. Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolams.addr-index.slow"></span><a class="mpstag reference internal" href="#design.mps.poolams.addr-index.slow">.addr-index.slow:</a> Translating from an address to and from a grain
index in a segment uses macros such as <tt class="xref c c-macro docutils literal"><span class="pre">AMS_INDEX</span></tt> and
<tt class="xref c c-macro docutils literal"><span class="pre">AMS_INDEX_ADDR</span></tt>. These are slow because they call <tt class="xref c c-func docutils literal"><span class="pre">SegBase()</span></tt> on
every translation &#8211; we could cache that.</p>
<p><span class="target" id="design.mps.poolams.grey-mutator"></span><a class="mpstag reference internal" href="#design.mps.poolams.grey-mutator">.grey-mutator:</a> To enforce the restriction set in <a class="reference internal" href="#design.mps.poolams.not-req.grey">.not-req.grey</a>
we check that all the traces are flipped in <tt class="xref c c-func docutils literal"><span class="pre">AMSScan()</span></tt>. It would be
good to check in <tt class="xref c c-func docutils literal"><span class="pre">AMSFix()</span></tt> as well, but we can&#8217;t do that, because
it&#8217;s called during the flip, and we can&#8217;t tell the difference between
the flip and the grey mutator phases with the current tracer
interface.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">22. AMS pool class</a><ul>
<li><a class="reference internal" href="#introduction">22.1. Introduction</a></li>
<li><a class="reference internal" href="#overview">22.2. Overview</a></li>
<li><a class="reference internal" href="#requirements">22.3. Requirements</a></li>
<li><a class="reference internal" href="#architecture">22.4. Architecture</a><ul>
<li><a class="reference internal" href="#subclassing">22.4.1. Subclassing</a></li>
<li><a class="reference internal" href="#allocation">22.4.2. Allocation</a></li>
<li><a class="reference internal" href="#colours">22.4.3. Colours</a></li>
<li><a class="reference internal" href="#scanning">22.4.4. Scanning</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">22.5. Implementation</a><ul>
<li><a class="reference internal" href="#colour">22.5.1. Colour</a></li>
<li><a class="reference internal" href="#iteration">22.5.2. Iteration</a></li>
<li><a class="reference internal" href="#scanning-algorithm">22.5.3. Scanning Algorithm</a></li>
<li><a class="reference internal" href="#id1">22.5.4. Allocation</a></li>
<li><a class="reference internal" href="#initialization">22.5.5. Initialization</a></li>
<li><a class="reference internal" href="#condemnation">22.5.6. Condemnation</a></li>
<li><a class="reference internal" href="#reclaim">22.5.7. Reclaim</a></li>
<li><a class="reference internal" href="#segment-merging-and-splitting">22.5.8. Segment merging and splitting</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing">22.6. Testing</a></li>
<li><a class="reference internal" href="#notes">22.7. Notes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="poolamc.html"
                        title="previous chapter">21. AMC pool class</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="poolawl.html"
                        title="next chapter">23. AWL pool class</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="poolawl.html" title="23. AWL pool class"
             >next</a> |</li>
        <li class="right" >
          <a href="poolamc.html" title="21. AMC pool class"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" >Old design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>