

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>4. The critical path through the MPS &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Design" href="index.html" />
    <link rel="next" title="5. Free list allocator" href="freelist.html" />
    <link rel="prev" title="3. MPS Configuration" href="config.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="freelist.html" title="5. Free list allocator"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="config.html" title="3. MPS Configuration"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-critical-path-through-the-mps">
<span id="design-critical-path"></span><span id="index-0"></span><h1>4. The critical path through the MPS<a class="headerlink" href="#the-critical-path-through-the-mps" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div>single: critical path
single: path; critical
single: Memory Pool System; critical path</div></blockquote>
<div class="section" id="introduction">
<h2>4.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The critical path is a key concept in the design of the <a class="reference external" href="http://www.ravenbrook.com/project/mps/">Memory Pool
System</a>.  Code on the critical
path is usually executed more than any other code in the process.  A
change of just one instruction on the critical path can make as much as
a 1% difference in overall run-time.  A lot of the design of the MPS is
arranged around making the critical path as short and fast as possible.
This document describes the critical path and explains some of that
design, with reference to more detailed documents.</p>
</div>
<div class="section" id="what-makes-the-critical-path-critical">
<h2>4.2. What makes the critical path critical<a class="headerlink" href="#what-makes-the-critical-path-critical" title="Permalink to this headline">¶</a></h2>
<p>In order to determine which object can be recycled, the garbage
collector has to frequently examine a very large number of pointers in
the program&#8217;s objects.  It does this by <a class="reference external" href="http://www.memorymanagement.org/glossary/s.html#scan">scanning</a> memory, both
allocated objects and roots (such as the thread stacks).</p>
<p>This means that the scanning functions must loop over pretty much <em>every
word in memory</em> sooner or later.  The MPS takes great pains to avoid
scanning memory which does not need scanning, but to get good
performance, scanning must be highly optimised.</p>
<p>What&#8217;s more, the scanning functions apply an operation called &#8220;fix&#8221; to
every pointer (or potential pointer) that they find in the objects in
memory.  Fixing also attempts to eliminate uninteresting pointers as
fast as possible, but it has to do some work on every object that is
being considered for recycling, and that can be a large proportion of
the objects in existence.  The path through fixing must also be highly
optimised, especially in the early stages.</p>
</div>
<div class="section" id="how-the-mps-avoids-scanning-and-fixing">
<h2>4.3. How the MPS avoids scanning and fixing<a class="headerlink" href="#how-the-mps-avoids-scanning-and-fixing" title="Permalink to this headline">¶</a></h2>
<p>This is just a brief overview of how the MPS is designed to reduce
unnecessary scanning and fixing.</p>
<p>Firstly, the MPS must occasionally decide which objects to try to
recycle.  It does this using various facts it knows about the objects,
primarily their age and whether they&#8217;ve survived previous attempts at
recycling them.  It then <a class="reference external" href="http://www.memorymanagement.org/glossary/c.html#condemned.set">&#8220;condemns&#8221;</a> a large number of objects
at once, and each of these objects must be &#8220;preserved&#8221; by fixing
references to them.</p>
<p>When the MPS condemns objects it chooses sets of objects in a small set
of &#8220;zones&#8221; in memory (preferably a single zone).  The zone of an object
can be determined extremely quickly from its address, without looking at
the object or any other data structure.</p>
<p>The MPS arranges that objects which will probably die at the same time
are in the same zones.</p>
<p>The MPS allocates in &#8220;segments&#8221;.  Each segment is of the order of one
&#8220;tract&#8221; of memory (generally the same as the operating system page
size, usually 4KiB or 8KiB) but may be larger if there are large
objects inside.  The MPS maintains a &#8220;summary&#8221; of the zones pointed to
by all the pointers in a segment from previous scans.</p>
<p>So, once the MPS has decided what to condemn, it can quickly eliminate
all segments which definitely do not point to anything in those zones.
This avoids a large amount of scanning.  It is an implementation of a
<a class="reference external" href="http://www.memorymanagement.org/glossary/r.html#remembered.set">remembered set</a>, though it is unlike that in most other GCs.</p>
<p>In addition, the fix operation can quickly ignore pointers to the wrong
zones.  This is called the &#8220;zone check&#8221; and is a <a class="reference external" href="http://www.memorymanagement.org/glossary/b.html#bibop">BIBOP</a> technique.</p>
<p>Even if a pointer passes the zone check, it may still not point to a
segment containing condemned objects.  The next stage of the fix
operation is to look up the segment pointed to by the pointer and see if
it was condemned.  This is a fast lookup.</p>
<p>After that, each pool class must decide whether the pointer is to a
condemned object and do something to preserve it.  This code is still
critical.  The MPS will have tried to condemn objects that are dead, but
those objects are still likely to be in segments with other objects that
must be preserved.  The pool class fix method must quickly distinguish
between them.</p>
<p>Furthermore, many objects will be preserved at least once in their
lifetime, so even the code that preserves an object needs to be highly
efficient.  (Programs in languages like ML might not preserve 95% of
their objects even once, but many other programs will preserve nearly
all of theirs many times.)</p>
</div>
<div class="section" id="where-to-find-the-critical-path">
<h2>4.4. Where to find the critical path<a class="headerlink" href="#where-to-find-the-critical-path" title="Permalink to this headline">¶</a></h2>
<p>Very briefly, the critical path consists of five stages:</p>
<ol class="arabic">
<li><p class="first">The scanner, which iterates over pointers in objects.  The MPS has
several internal scanners, but the most important ones will be format
scanners in client code registered through <tt class="xref c c-func docutils literal"><span class="pre">mps_format_create()</span></tt>
functions.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">There needs to be a chapter in the manual explaining how to
write a good scanner. Then that could be linked from here.</p>
</div>
</li>
<li><p class="first">The first-stage fix, which filters out pointers inline in the
scanner.  This is implemented in <tt class="xref c c-func docutils literal"><span class="pre">MPS_FIX()</span></tt> macros in
<a class="reference external" href="../code/mps.h">mps.h</a>.</p>
</li>
</ol>
<ol class="arabic" start="3">
<li><p class="first">The second-stage fix, which filters out pointers using general
information about segments.  This is <tt class="docutils literal"><span class="pre">_mps_fix2</span></tt> in
<a class="reference external" href="../code/trace.c">trace.c</a>.</p>
</li>
<li><p class="first">The third-stage fix, which filters out pointers using pool-specific
information.  Implemented in pool class functions called <a class="reference internal" href="poolamc.html#AMCFix" title="AMCFix"><tt class="xref c c-func docutils literal"><span class="pre">AMCFix()</span></tt></a>,
<a class="reference internal" href="poollo.html#LOFix" title="LOFix"><tt class="xref c c-func docutils literal"><span class="pre">LOFix()</span></tt></a>, etc. in pool*.c.</p>
</li>
<li><p class="first">Preserving the object, which might entail</p>
<ul class="simple">
<li><a class="reference external" href="http://www.memorymanagement.org/glossary/m.html#marking">marking</a> it to prevent it being recycled; and/or</li>
<li><a class="reference external" href="http://www.memorymanagement.org/glossary/c.html#copying.garbage.collection">copying</a> it and updating the original pointer (or just
updating the pointer, if the object has previously been
copied); and/or</li>
<li>adding it to a queue of objects to be scanned later, if it
contains pointers.</li>
</ul>
<p>Found in or near the pool class fix functions.</p>
</li>
</ol>
</div>
<div class="section" id="the-format-scanner">
<h2>4.5. The format scanner<a class="headerlink" href="#the-format-scanner" title="Permalink to this headline">¶</a></h2>
<p>The critical path starts when a format scan method is called.  That is a
call from the MPS to a client function of type <a class="reference internal" href="../topic/format.html#mps_fmt_scan_t" title="mps_fmt_scan_t"><tt class="xref c c-type docutils literal"><span class="pre">mps_fmt_scan_t</span></tt></a>
registered with one of the <tt class="xref c c-func docutils literal"><span class="pre">mps_format_create()</span></tt> functions in <a class="reference external" href="../code/mps.h">mps.h</a>.</p>
<p>Here is an example of part of a format scanner for scanning contiguous
runs of pointers, from <a class="reference external" href="../code/fmtdy.c">fmtdy.c</a>, the scanner for the <a class="reference external" href="http://opendylan.org/">Open Dylan</a>
runtime:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">mps_res_t</span> <span class="nf">dylan_scan_contig</span><span class="p">(</span><span class="kt">mps_ss_t</span> <span class="n">mps_ss</span><span class="p">,</span>
                                   <span class="kt">mps_addr_t</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">mps_addr_t</span> <span class="o">*</span><span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">mps_res_t</span> <span class="n">res</span><span class="p">;</span>
  <span class="kt">mps_addr_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>        <span class="cm">/* reference cursor */</span>
  <span class="kt">mps_addr_t</span> <span class="n">r</span><span class="p">;</span>         <span class="cm">/* reference to be fixed */</span>

  <span class="n">MPS_SCAN_BEGIN</span><span class="p">(</span><span class="n">mps_ss</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">p</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
    <span class="nl">loop:</span> <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span> <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
          <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
          <span class="k">if</span><span class="p">(((</span><span class="kt">mps_word_t</span><span class="p">)</span><span class="n">r</span><span class="o">&amp;</span><span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* pointers tagged with 0 */</span>
            <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>             <span class="cm">/* not a pointer */</span>
          <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">MPS_FIX1</span><span class="p">(</span><span class="n">mps_ss</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span> <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
          <span class="n">res</span> <span class="o">=</span> <span class="n">MPS_FIX2</span><span class="p">(</span><span class="n">mps_ss</span><span class="p">,</span> <span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
          <span class="k">if</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">MPS_RES_OK</span><span class="p">)</span> <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
          <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="nl">out:</span>  <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">limit</span><span class="p">);</span>
  <span class="p">}</span> <span class="n">MPS_SCAN_END</span><span class="p">(</span><span class="n">mps_ss</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">MPS_RES_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(To help with understanding optimisation of this code, it&#8217;s written in
a pseudo-assembler style, with one line roughly corresponding to each
instruction of an idealized intermediate code.)</p>
<p>The MPS C interface provides macros to try to help optimise this code.
The <tt class="docutils literal"><span class="pre">mps_ss</span></tt> object is a &#8220;scan state&#8221; and contains data that is used
to eliminate uninteresting pointers now, and record information which
will be used to reduce scanning in future by maintaining the
remembered set.</p>
<p>The macros <a class="reference internal" href="../topic/scanning.html#MPS_SCAN_BEGIN" title="MPS_SCAN_BEGIN"><tt class="xref c c-func docutils literal"><span class="pre">MPS_SCAN_BEGIN()</span></tt></a> and <a class="reference internal" href="../topic/scanning.html#MPS_SCAN_END" title="MPS_SCAN_END"><tt class="xref c c-func docutils literal"><span class="pre">MPS_SCAN_END()</span></tt></a> load key data
from the scan state into local variables, and hopefully into processor
registers. This avoids aliasing values that we know won&#8217;t change when
calls are made to <tt class="docutils literal"><span class="pre">_mps_fix2</span></tt> later, and so allows the compiler to
keep the scan loop small and avoid unnecessary memory references.</p>
<p>This scanner knows that words not ending in 0b00 aren&#8217;t pointers to
objects, so it eliminates them straight away. This is a kind of
<a class="reference external" href="http://www.memorymanagement.org/glossary/t.html#tag">reference tag</a> chosen by the client for its object representation.</p>
<p>Next, the pointer is tested using <a class="reference internal" href="../topic/scanning.html#MPS_FIX1" title="MPS_FIX1"><tt class="xref c c-func docutils literal"><span class="pre">MPS_FIX1()</span></tt></a>. This performs fast
tests on the pointer without using any other memory. In particular, it
does the &#8220;zone check&#8221; described in section 3. If a pointer fails these
tests, it isn&#8217;t interesting and can be skipped. It is very important
to proceed to the next pointer as fast as possible in this case.</p>
<p>Having passed these tests, we need to fix the pointer using other data
in memory, and possibly call the MPS to preserve the object. This is
what <a class="reference internal" href="../topic/scanning.html#MPS_FIX2" title="MPS_FIX2"><tt class="xref c c-func docutils literal"><span class="pre">MPS_FIX2()</span></tt></a> does. The important distinction here is that
<a class="reference internal" href="../topic/scanning.html#MPS_FIX2" title="MPS_FIX2"><tt class="xref c c-func docutils literal"><span class="pre">MPS_FIX2()</span></tt></a> can fail and return an error code, which must be
propagated without ado by returning from the scanner. Separating
<a class="reference internal" href="../topic/scanning.html#MPS_FIX1" title="MPS_FIX1"><tt class="xref c c-func docutils literal"><span class="pre">MPS_FIX1()</span></tt></a> from <a class="reference internal" href="../topic/scanning.html#MPS_FIX2" title="MPS_FIX2"><tt class="xref c c-func docutils literal"><span class="pre">MPS_FIX2()</span></tt></a> helps keep the error handling code
away from the tight loop with the zone check.</p>
<p><tt class="docutils literal"><span class="pre">MPS_FIX*</span></tt>, the macro/inline part of the fix operation, are referred
to as &#8220;fix stage 1&#8221; or &#8220;the first stage fix&#8221; in other documents and
comments.</p>
<p>If these inline checks pass, <tt class="docutils literal"><span class="pre">_mps_fix2</span></tt> is called. If the MPS has
been built as a separate object file or library, this is where the
function call out of the scan loop happens. Since version 1.110 of the
MPS, we encourage clients to compile the MPS in the same translation
unit as their format code, so that the compiler can be intelligent
about inlining parts of <tt class="docutils literal"><span class="pre">_mps_fix2</span></tt> in the format scanner. The
instructions for doing this are in <a class="reference external" href="../manual/build.txt">Building the Memory Pool System</a>, part of the manual.</p>
</div>
<div class="section" id="the-second-stage-fix-in-the-mpm">
<h2>4.6. The second stage fix in the MPM<a class="headerlink" href="#the-second-stage-fix-in-the-mpm" title="Permalink to this headline">¶</a></h2>
<p>If a pointer gets past the first-stage fix filters, it is passed to
<tt class="docutils literal"><span class="pre">_mps_fix2</span></tt>, the &#8220;second stage fix&#8221;.  The second stage can filter out
yet more pointers using information about segments before it has to
consult the pool class.</p>
<p>The first test applied is the &#8220;tract test&#8221;. The MPS looks up the tract
containing the address in the tract table, which is a simple linear
table indexed by the address shifted &#8211; a kind of flat page table.</p>
<p>Note that if the arena has been extended, the tract table becomes less
simple, and this test may involved looking in more than one table.
This will cause a considerable slow-down in garbage collection
scanning. This is the reason that it&#8217;s important to give a good
estimate of the amount of address space you will ever occupy with
objects when you initialize the arena.</p>
<p>The pointer might not even be in the arena (and so not in any tract).
The first stage fix doesn&#8217;t guarantee it. So we eliminate any pointers
not in the arena at this stage.</p>
<p>If the pointer is in an allocated tract, then the table also contains
a cache of the &#8220;white set&#8221; &#8211; the set of garbage collection traces for
which the tract is &#8220;interesting&#8221;. If a tract isn&#8217;t interesting, then
we know that it contains no condemned objects, and we can filter out
the pointer.</p>
<p>If the tract is interesting them it&#8217;s part of a segment containing
objects that have been condemned. The MPM can&#8217;t know anything about
the internal layout of the segment, so at this point we dispatch to
the third stage fix.</p>
<p>This dispatch is slightly subtle. We have a cache of the function to
dispatch to in the scan state, which has recently been looked at and
is with luck still in the processor cache. The reason there is a
dispatch at all is to allow for a fast changeover to emergency garbage
collection, or overriding of garbage collection with extra operations.
Those are beyond the scope of this document. Normally, <tt class="docutils literal"><span class="pre">ss-&gt;fix</span></tt>
points at <tt class="xref c c-func docutils literal"><span class="pre">PoolFix()</span></tt>, and we rely somewhat on modern processor
<a class="reference external" href="https://en.wikipedia.org/wiki/Branch_target_predictor">branch target prediction</a>).
<tt class="xref c c-func docutils literal"><span class="pre">PoolFix()</span></tt> is passed the pool, which is fetched from the tract
table entry, and that should be in the cache.</p>
<p><tt class="xref c c-func docutils literal"><span class="pre">PoolFix()</span></tt> itself dispatches to the pool class. Normally, a
dispatch to a pool class would indirect through the pool class object.
That would be a double indirection from the tract, so instead we have
a cache of the pool&#8217;s fix method in the pool object. This also allows
a pool class to vary its fix method per pool instance, a fact that is
exploited to optimize fixing in the AMC Pool depending on what kind of
object format it is managing.</p>
</div>
<div class="section" id="the-third-stage-fix-in-the-pool-class">
<h2>4.7. The third stage fix in the pool class<a class="headerlink" href="#the-third-stage-fix-in-the-pool-class" title="Permalink to this headline">¶</a></h2>
<p>The final stage of fixing is entirely dependent on the pool class.  The
MPM can&#8217;t, in general, know how the objects within a pool are arranged,
so this is pool class specific code.</p>
<p>Furthermore, the pool class must make decisions based on the &#8220;reference
rank&#8221; of the pointer.  If a pointer is ambiguous (<tt class="docutils literal"><span class="pre">RankAMBIG</span></tt>) then it
can&#8217;t be changed, so even a copying pool class can&#8217;t move an object.
On the other hand, if the pointer is weak (<tt class="docutils literal"><span class="pre">RankWEAK</span></tt>) then the pool fix
method shouldn&#8217;t preserve the object at all, even if it&#8217;s condemned.</p>
<p>The exact details of the logic that the pool fix must implement in
order to co-operate with the MPM and other pools are beyond the scope
of this document, which is about the critical path.  Since it is on
the critical path, it&#8217;s important that whatever the pool fix does is
simple and fast and returns to scanning as soon as possible.</p>
<p>The first step, though, is to further filter out pointers which aren&#8217;t
to objects, if that&#8217;s its policy.  Then, it may preserve the object,
according to its policy, and possibly ensure that the object gets
scanned at some point in the future, if it contains more pointers.</p>
<p>If the object is moved to preserve it (for instance, if the pool class
implements a copying GC), or was already moved when fixing a previous
reference to it, the reference being fixed must be updated (this is
the origin of the term &#8220;fix&#8221;).</p>
<p>As a simple example, <a class="reference internal" href="poollo.html#LOFix" title="LOFix"><tt class="xref c c-func docutils literal"><span class="pre">LOFix()</span></tt></a> is the pool fix method for the Leaf
Only pool class. It implements a marking garbage collector, and does
not have to worry about scanning preserved objects because it is used
to store objects that don&#8217;t contain pointers. (It is used in compiler
run-time systems to store binary data such as character strings, thus
avoiding any scanning, decoding, or remembered set overhead for them.)</p>
<p><a class="reference internal" href="poollo.html#LOFix" title="LOFix"><tt class="xref c c-func docutils literal"><span class="pre">LOFix()</span></tt></a> filters any ambiguous pointers that aren&#8217;t aligned, since
they can&#8217;t point to objects it allocated. Otherwise it subtracts the
segment base address and shifts the result to get an index into a mark
bit table. If the object wasn&#8217;t marked and the pointer is weak, then
it sets the pointer to zero, since the object is about to be recycled.
Otherwise, the mark bit is set, which preserves the object from
recycling when <cite>LOReclaim</cite> is called later on. <cite>LOFix</cite> illustrates
about the minimum and most efficient thing a pool fix method can do.</p>
</div>
<div class="section" id="other-considerations">
<h2>4.8. Other considerations<a class="headerlink" href="#other-considerations" title="Permalink to this headline">¶</a></h2>
<p>So far this document has described the ways in which the garbage
collector is designed around optimising the critical path.  There are a
few other things that the MPS does that are important.</p>
<p>Firstly, inlining is very important.  The first stage fix is inlined
into the format scanner by being implemented in macros in
<a class="reference external" href="../code/mps.h">mps.h</a>.  And to get even better inlining, <a class="reference external" href="../manual/build.txt">we
recommend</a> that the whole MPS is compiled in a
single translation unit with the client format and that strong global
optimisation is applied.</p>
<p>Secondly, we are very careful with code annotations on the critical
path.  Assertions, statistics, and telemetry are all disabled on the
critical path in &#8220;hot&#8221; (production) builds.  (In fact, it&#8217;s because the
critical path is critical that we can afford to leave annotations
switched on elsewhere.)</p>
<p>Last, but by no means least, we pay a lot of brainpower and measurement
to the critical path, and are very very careful about changing it.  Code
review around the critical path is especially vigilant.</p>
<p>And we write long documents about it.</p>
</div>
<div class="section" id="references">
<h2>4.9. References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="mmref" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[MMRef]</td><td>&#8220;The Memory Management Reference&#8221;; &lt;<a class="reference external" href="http://www.memorymanagement.org/">http://www.memorymanagement.org/</a>&gt;.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">4. The critical path through the MPS</a><ul>
<li><a class="reference internal" href="#introduction">4.1. Introduction</a></li>
<li><a class="reference internal" href="#what-makes-the-critical-path-critical">4.2. What makes the critical path critical</a></li>
<li><a class="reference internal" href="#how-the-mps-avoids-scanning-and-fixing">4.3. How the MPS avoids scanning and fixing</a></li>
<li><a class="reference internal" href="#where-to-find-the-critical-path">4.4. Where to find the critical path</a></li>
<li><a class="reference internal" href="#the-format-scanner">4.5. The format scanner</a></li>
<li><a class="reference internal" href="#the-second-stage-fix-in-the-mpm">4.6. The second stage fix in the MPM</a></li>
<li><a class="reference internal" href="#the-third-stage-fix-in-the-pool-class">4.7. The third stage fix in the pool class</a></li>
<li><a class="reference internal" href="#other-considerations">4.8. Other considerations</a></li>
<li><a class="reference internal" href="#references">4.9. References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="config.html"
                        title="previous chapter">3. MPS Configuration</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="freelist.html"
                        title="next chapter">5. Free list allocator</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="freelist.html" title="5. Free list allocator"
             >next</a> |</li>
        <li class="right" >
          <a href="config.html" title="3. MPS Configuration"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>