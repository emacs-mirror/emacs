

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MPS Strategy &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="mps-strategy">
<span id="design-strategy"></span><h1>MPS Strategy<a class="headerlink" href="#mps-strategy" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="design.mps.strategy"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="intro">.intro</span> This is the design of collection strategy for the MPS.</p>
<p><span class="target" id="readership">.readership</span> MPS developers.</p>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="id1">.overview</span> The MPS uses &#8220;strategy&#8221; code to make three decisions:</p>
<ul class="simple">
<li>when to start a collection trace;</li>
<li>what to condemn;</li>
<li>how to schedule tracing work.</li>
</ul>
<p>This document describes the current strategy, identifies some
weaknesses in it, and outlines some possible future development
directions.</p>
</div>
<div class="section" id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p>[TODO: source some from req.dylan, or do an up-to-date requirements
analysis &#8211; NB 2013-03-25]</p>
<p>Garbage collection is a trade-off between time and space: it consumes
some [CPU] time in order to save some [memory] space.  Strategy shifts
the balance point.  A better strategy will take less time to produce
more space.  Examples of good strategy might include:</p>
<ul class="simple">
<li>choosing segments to condemn which contain high proportions of dead
objects;</li>
<li>starting a trace when a large number of objects have just died;</li>
<li>doing enough collection soon enough that the client program never
suffers low-memory problems;</li>
<li>using otherwise-idle CPU resources for tracing.</li>
</ul>
<p>Conversely, it would be bad strategy to do the reverse of each of
these (condemning live objects; tracing when there&#8217;s very little
garbage; not collecting enough; tracing when the client program is
busy).</p>
<p>Abstracting from these notions, requirements on strategy would
relate to:</p>
<ul class="simple">
<li>Maximum pause time and other utilization metrics (for example,
bounded mutator utilization, minimum mutator utilization, total MPS
CPU usage);</li>
<li>Collecting enough garbage (for example: overall heap size;
low-memory requirements).</li>
<li>Allowing client control (for example, client recommendations for
collection timing or condemnation).</li>
</ul>
<p>There are other possible strategy considerations which are so far
outside the scope of current strategy and MPS design that this
document disregards them. For example, either inferring or allowing
the client to specify preferred relative object locations (&#8220;this
object should be kept in the same cache line as that one&#8221;), to improve
cache locality.</p>
</div>
<div class="section" id="generations">
<h2>Generations<a class="headerlink" href="#generations" title="Permalink to this headline">¶</a></h2>
<p>The largest part of the current MPS strategy implementation is the
support for generational GC.  Generations are only fully supported for
AMC (and AMCZ) pools.  See under &#8220;Non-AMC Pools&#8221;, below, for more
information.</p>
<div class="section" id="data-structures">
<h3>Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h3>
<p>The fundamental structure of generational GC is the <tt class="docutils literal"><span class="pre">Chain</span></tt>,
which describes a set of generations.  A chain is created by client
code calling <a class="reference internal" href="../topic/collection.html#mps_chain_create" title="mps_chain_create"><tt class="xref c c-func docutils literal"><span class="pre">mps_chain_create()</span></tt></a>, specifying the &#8220;size&#8221; and
&#8220;mortality&#8221; for each generation.  When creating an AMC pool, the
client code must specify the chain which will control collections for
that pool.  The same chain may be used for multiple pools.</p>
<p>Each generation in a chain has a <tt class="docutils literal"><span class="pre">GenDesc</span></tt> structure,
allocated in an array pointed to from the chain.  Each AMC pool has a
set of <tt class="docutils literal"><span class="pre">PoolGen</span></tt> structures, one per generation.  The PoolGens
for each generation point to the GenDesc and are linked together in a
ring on the GenDesc.  These structures are (solely?) used to gather
information for strategy decisions.</p>
<p>The arena has a unique <tt class="docutils literal"><span class="pre">GenDesc</span></tt> structure, named
<tt class="docutils literal"><span class="pre">topGen</span></tt> and described in comments as &#8220;the dynamic generation&#8221;
(although in fact it is the <em>least</em> dynamic generation).  Each AMC
pool has one more PoolGen than there are GenDescs in the chain.  The
extra PoolGen refers to this topGen.</p>
<p>AMC segments have a segment descriptor <tt class="docutils literal"><span class="pre">amcSegStruct</span></tt> which is
a <tt class="xref c c-type docutils literal"><span class="pre">GCSegStruct</span></tt> with two additional fields.  One field
<tt class="docutils literal"><span class="pre">segTypeP</span></tt> is a pointer either to the per-generation per-pool
<tt class="docutils literal"><span class="pre">amcGen</span></tt> structure (a subclass of <tt class="docutils literal"><span class="pre">PoolGen</span></tt>), or to a
nailboard (which then points to an amcGen).  The other field
<tt class="docutils literal"><span class="pre">new</span></tt> is a boolean used for keeping track of memory usage for
strategy reasons (see below under &#8216;Accounting&#8217;).  The <tt class="docutils literal"><span class="pre">amcGen</span></tt>
is used for statistics (<tt class="docutils literal"><span class="pre">-&gt;segs</span></tt>) and forwarding buffers
(<tt class="docutils literal"><span class="pre">-&gt;forward</span></tt>).</p>
<p>The AMC pool class only ever allocates a segment in order to fill a
buffer: either the buffer for a client Allocation Point, or a
forwarding buffer.  In order to support generational collection, there
is a subclass <tt class="docutils literal"><span class="pre">amcBuf</span></tt> of <tt class="docutils literal"><span class="pre">SegBuf</span></tt>, with a
<tt class="docutils literal"><span class="pre">gen</span></tt> field (pointing to a <tt class="docutils literal"><span class="pre">amcGen</span></tt>).  So in
<a class="reference internal" href="poolamc.html#AMCBufferFill" title="AMCBufferFill"><tt class="xref c c-func docutils literal"><span class="pre">AMCBufferFill()</span></tt></a> the generation of the new segment can be
determined.</p>
<p>When an AMC pool is created, these <tt class="docutils literal"><span class="pre">amcGen</span></tt> and
<tt class="docutils literal"><span class="pre">amcBuf</span></tt> structures are all created, and the
<tt class="docutils literal"><span class="pre">amcBuf-&gt;gen</span></tt> fields initialized so that the forwarding buffer
of each amcGen knows that it belongs to the next &#8220;older&#8221; amcGen (apart
from the &#8220;oldest&#8221; amcGen - that which refers to the topGen - whose
forwarding buffer belongs to itself).</p>
<p>When copying an object in <a class="reference internal" href="poolamc.html#AMCFix" title="AMCFix"><tt class="xref c c-func docutils literal"><span class="pre">AMCFix()</span></tt></a>, the object&#8217;s current
generation is determined (<tt class="xref c c-func docutils literal"><span class="pre">amcSegGen()</span></tt>), and the object is
copied to that amcGen&#8217;s forwarding buffer, using the buffer protocol.
Thus, objects are &#8220;promoted&#8221; up the chain of generations until they
end up in the topGen, which is shared between all chains and all
pools.</p>
<p>For statistics and reporting purposes, when <tt class="xref c c-macro docutils literal"><span class="pre">STATISTICS</span></tt> is
on, each AMC pool has an array of <tt class="xref c c-type docutils literal"><span class="pre">PageRetStruct`s,</span> <span class="pre">one</span> <span class="pre">per</span>
<span class="pre">trace.</span>&nbsp; <span class="pre">This</span> <span class="pre">structure</span> <span class="pre">has</span> <span class="pre">many</span> <span class="pre">:c:type:`Count</span></tt> fields, and is
intended to help to assess AMC page retention code.  See job001811.</p>
</div>
<div class="section" id="zones">
<h3>Zones<a class="headerlink" href="#zones" title="Permalink to this headline">¶</a></h3>
<p>All collections in the MPS start with condemnation of a complete
<tt class="docutils literal"><span class="pre">ZoneSet</span></tt>.  Each generation in each chain has a zoneset
associated with it (<tt class="docutils literal"><span class="pre">chain-&gt;gen[N].zones</span></tt>); the condemned
zoneset is the union of some number of generation&#8217;s zonesets.  It is
condemned by code in the chain system calling
<tt class="xref c c-func docutils literal"><span class="pre">TraceCondemnZones()</span></tt>.  This is either for all chains
(<tt class="xref c c-func docutils literal"><span class="pre">ChainCondemnAll()</span></tt> called for every chain from
<tt class="xref c c-func docutils literal"><span class="pre">traceCondemnAll()</span></tt>) or for some number of generations in a
single chain (<tt class="xref c c-func docutils literal"><span class="pre">ChainCondemnAuto()</span></tt> called from
<tt class="xref c c-func docutils literal"><span class="pre">TracePoll()</span></tt>).  Note that the condemnation is of every
automatic-pool segment in any zone in the zoneset.  It is not limited
to the segments actually associated with the condemned generation(s).</p>
<p>An attempt is made to use distinct zonesets for different generations.
Whenever a segment is allocated (<a class="reference internal" href="poolamc.html#AMCBufferFill" title="AMCBufferFill"><tt class="xref c c-func docutils literal"><span class="pre">AMCBufferFill()</span></tt></a>), a
<tt class="docutils literal"><span class="pre">SegPref</span></tt> is created containing the generation number
(obtained from <tt class="docutils literal"><span class="pre">amcBuf-&gt;gen-&gt;pgen-&gt;nr</span></tt>) and passed to
<tt class="xref c c-func docutils literal"><span class="pre">SegAlloc()</span></tt>.  The arena keeps a zoneset for each generation
number (up to <tt class="docutils literal"><span class="pre">VMArenaGenCount</span></tt>, defined in
<tt class="docutils literal"><span class="pre">arenavm.c</span></tt> to be <tt class="docutils literal"><span class="pre">MPS_WORD_WIDTH/2</span></tt>), and a
<tt class="docutils literal"><span class="pre">freeSet</span></tt>.  The zoneset for each generation number starts out
empty, and the <tt class="docutils literal"><span class="pre">freeSet</span></tt> starts out <tt class="docutils literal"><span class="pre">ZoneSetUNIV</span></tt>.
When a segment is allocated with a <tt class="docutils literal"><span class="pre">SegPref</span></tt> with a generation
number, an attempt is made to allocate it in the corresponding zoneset
(<tt class="xref c c-func docutils literal"><span class="pre">pagesFindFreeInZones()</span></tt>).  If the zoneset is empty, an
attempt is made to allocate it in the <tt class="docutils literal"><span class="pre">freeSet</span></tt> zoneset.
After it is allocated, the zones it occupies are removed from the
<tt class="docutils literal"><span class="pre">freeSet</span></tt> and (if there&#8217;s a generation <tt class="docutils literal"><span class="pre">SegPref</span></tt>)
added to the zoneset for that generation number.</p>
<p>Note that this zone placement code knows nothing of chains,
generations, pool classes, etc.  It is based solely on the generation
<em>number</em>, so generations with the same number from different chains
share a zoneset preference for the purpose of placing newly allocated
segments.  Combined with the fact that condemnation is per-zone, this
effectively means that generations in distinct chains are collected
together.  One consequence of this is that we don&#8217;t have a very fine
granularity of control over collection: a garbage collection of all
chains together is triggered by the most eager chain.  There&#8217;s no way
for a library or other small part of a client program to arrange
independent collection of a separate pool or chain.</p>
<p>When <a class="reference internal" href="poolamc.html#AMCBufferFill" title="AMCBufferFill"><tt class="xref c c-func docutils literal"><span class="pre">AMCBufferFill()</span></tt></a> gets the allocated segment back, it
adds it to the zoneset associated with that generation in the pool&#8217;s
controlling chain.  Note that a chain&#8217;s per-generation zonesets, which
represent the zones in which segments for that generation in that
chain have been placed, are quite distinct from the arena-wide
per-generation-number zonesets, which represent the zones in which
segments for that generation number in any chain have been placed.
The arena-wide per-generation-number zoneset
<tt class="docutils literal"><span class="pre">vmArena-&gt;genZoneSet[N]</span></tt> is augmented in
<tt class="xref c c-func docutils literal"><span class="pre">vmAllocComm()</span></tt>.  The per-chain per-generation zoneset
<tt class="docutils literal"><span class="pre">chain-&gt;gen[N].zones</span></tt> is augmented in
<tt class="xref c c-func docutils literal"><span class="pre">PoolGenUpdateZones()</span></tt>.  Neither kind of zoneset can ever
shrink.</p>
</div>
<div class="section" id="accounting">
<h3>Accounting<a class="headerlink" href="#accounting" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen[N].mortality</span></tt><ul>
<li>Specified by the client.</li>
<li>TODO: fill in how this is used.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">gen[N].capacity</span></tt><ul>
<li>Specified by the client.</li>
<li>TODO: fill in how this is used.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">amcSeg-&gt;new</span></tt><ul>
<li>TODO: fill this in</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">pgen-&gt;totalSize</span></tt>:<ul>
<li>incremented by <a class="reference internal" href="poolamc.html#AMCBufferFill" title="AMCBufferFill"><tt class="xref c c-func docutils literal"><span class="pre">AMCBufferFill()</span></tt></a>;</li>
<li>decremented by <tt class="xref c c-func docutils literal"><span class="pre">amcReclaimNailed()</span></tt> and <a class="reference internal" href="poolamc.html#AMCReclaim" title="AMCReclaim"><tt class="xref c c-func docutils literal"><span class="pre">AMCReclaim()</span></tt></a>;</li>
<li>added up by <tt class="docutils literal"><span class="pre">GenDescTotalSize(gen)</span></tt>.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">pgen-&gt;newSize</span></tt>:<ul>
<li>incremented by <a class="reference internal" href="poolamc.html#AMCBufferFill" title="AMCBufferFill"><tt class="xref c c-func docutils literal"><span class="pre">AMCBufferFill()</span></tt></a> (<em>when not ramping</em>) and <tt class="xref c c-func docutils literal"><span class="pre">AMCRampEnd()</span></tt>;</li>
<li>decremented by <tt class="xref c c-func docutils literal"><span class="pre">AMCWhiten()</span></tt>,</li>
<li>added up by <tt class="docutils literal"><span class="pre">GenDescNewSize(gen)</span></tt>.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">gen[N].proflow</span></tt>:<ul>
<li>set to 1.0 by <tt class="xref c c-func docutils literal"><span class="pre">ChainCreate()</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">arena-&gt;topGen.proflow</span></tt> set to 0.0 by <tt class="docutils literal"><span class="pre">LocusInit(arena)</span></tt>;</li>
<li><em>The value of this field is never used</em>.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">pgen-&gt;newSizeAtCreate</span></tt>:<ul>
<li>set by <tt class="xref c c-func docutils literal"><span class="pre">traceCopySizes()</span></tt> (that is its purpose);</li>
<li>output in the <tt class="docutils literal"><span class="pre">TraceStartPoolGen</span></tt> telemetry event.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="ramps">
<h3>Ramps<a class="headerlink" href="#ramps" title="Permalink to this headline">¶</a></h3>
<p>The intended semantics of ramping are pretty simple.  It allows the
client to advise us of periods of large short-lived allocation on a
particular AP.  Stuff allocated using that AP during its &#8220;ramp&#8221; will
probably be dead when the ramp finishes.  How the MPS makes use of this
advice is up to us, but for instance we might segregate those objects,
collect them less enthusiastically during the ramp and then more
enthusiastically soon after the ramp finishes.  Ramps can nest.</p>
<p>A ramp is entered by calling:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">mps_ap_alloc_pattern_begin</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">mps_alloc_pattern_ramp</span><span class="p">())</span>
</pre></div>
</div>
<p>or similar, and left in a similar way.</p>
<p>This is implemented on a per-pool basis, for AMC only (it&#8217;s ignored by
the other automatic pools).  PoolAMC throws away the identity of the AP
specified by the client.  The implementation is intended to work by
changing the generational forwarding behaviour, so that there is a &#8220;ramp
generation&#8221; - one of the regular AMC generations - which forwards to
itself if collected during a ramp (instead of promoting to an older
generation).  It also tweaks the strategy calculation code, in a way
with consequences I am documenting elsewhere.</p>
<p>Right now, the code sets this ramp generation to the last generation
specified in the pool&#8217;s &#8220;chain&#8221;: it ordinarily forwards to the
&#8220;after-ramp&#8221; generation, which is the &#8220;dynamic generation&#8221; (i.e. the
least dynamic generation, i.e. the arena-wide &#8220;top generation&#8221;).  My
recollection, and some mentions in design/poolamc, suggests that the
ramp generation used to be chosen differently from this.</p>
<p>So far, it doesn&#8217;t sound too ghastly, I guess, although the subversion
of the generational system seems a little daft.  Read on....</p>
<p>An AMC pool has a <tt class="docutils literal"><span class="pre">rampMode</span></tt> (which is really a state of a state
machine), taking one of five values: OUTSIDE, BEGIN, RAMPING, FINISH,
and COLLECTING (actually the enum values are called RampX for these
X). We initialize in OUTSIDE.  The pool also has a <tt class="docutils literal"><span class="pre">rampCount</span></tt>,
which is the ramp nesting depth and is used to allow us to ignore ramp
transitions other than the outermost.  According to design/poolamc,
there&#8217;s an invariant (in BEGIN or RAMPING, <tt class="docutils literal"><span class="pre">rampCount</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt>; in
COLLECTING or OUTSIDE, <tt class="docutils literal"><span class="pre">rampCount</span> <span class="pre">==</span> <span class="pre">0</span></tt>), but this isn&#8217;t checked in
<tt class="xref c c-func docutils literal"><span class="pre">AMCCheck()</span></tt> and in fact is false for COLLECTING (see below).</p>
<p>There is a small set of events causing state machine transitions:</p>
<ul class="simple">
<li>entering an outermost ramp;</li>
<li>leaving an outermost ramp;</li>
<li>condemning any segment of a ramp generation (detected in AMCWhiten);</li>
<li>reclaiming any AMC segment.</li>
</ul>
<p>Here&#8217;s pseudo-code for all the transition events:</p>
<dl class="docutils">
<dt>Entering an outermost ramp:</dt>
<dd>if not FINISH, go to BEGIN.</dd>
<dt>Leaving an outermost ramp:</dt>
<dd>if RAMPING, go to FINISH.   Otherwise, go to OUTSIDE.</dd>
<dt>Condemning a ramp generation segment:</dt>
<dd>If BEGIN, go to RAMPING and make the ramp generation forward
to itself (detach the forwarding buffer and reset its generation).
If FINISH, go to COLLECTING and make the ramp generation
forward to the after-ramp generation.</dd>
<dt>Reclaiming any AMC segment:</dt>
<dd><dl class="first last docutils">
<dt>If COLLECTING:</dt>
<dd>if <tt class="docutils literal"><span class="pre">rampCount</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt>, go to BEGIN.  Otherwise go to OUTSIDE.</dd>
</dl>
</dd>
</dl>
<p>Now, some deductions:</p>
<p>1. When OUTSIDE, the count is always zero, because (a) it starts that
way, and the only ways to go OUTSIDE are (b) by leaving an outermost
ramp (count goes to zero) or (c) by reclaiming when the count is zero.</p>
<p>2. When BEGIN, the count is never zero (consider the transitions to
BEGIN and the transition to zero).</p>
<p>3. When RAMPING, the count is never zero (again consider transitions to
RAMPING and the transition to zero).</p>
<p>4. When FINISH, the count can be anything (the transition to FINISH has
zero count, but the Enter transition when FINISH can change that and
then it can increment to any value).</p>
<p>5. When COLLECTING, the count can be anything (from the previous fact,
and the transition to COLLECTING).</p>
<p>6. <em>This is a bug!!</em> The ramp generation is not always reset (to forward
to the after-ramp generation).  If we get into FINISH and then see
another ramp before the next condemnation of the ramp generation, we
will Enter followed by Leave.  The Enter will keep us in FINISH, and
the Leave will take us back to OUTSIDE, skipping the transition to the
COLLECTING state which is what resets the ramp generation forwarding
buffer.  [TODO: check whether I made an issue and/or fixed it; NB 2013-06-04]</p>
<p>The simplest change to fix this is to change the behaviour of the Leave
transition, which should only take us OUTSIDE if we are in BEGIN or
COLLECTING.  We should also update design/poolamc to tell the truth, and
check the invariants, which will be these:</p>
<blockquote>
<div>OUTSIDE =&gt; zero
BEGIN =&gt; non-zero
RAMPING =&gt; non-zero</div></blockquote>
<p>A cleverer change might radically rearrange the state machine
(e.g. reduce the number of states to three) but that would require
closer design thought and should probably be postponed until we have a
clearer overall strategy plan.</p>
<p>While I&#8217;m writing pseudo-code versions of ramp-related code, I should
mention this other snippet, which is the only other code relating to
ramping (these notes are useful when thinking about the broader strategy
code):</p>
<blockquote>
<div>In <a class="reference internal" href="poolamc.html#AMCBufferFill" title="AMCBufferFill"><tt class="xref c c-func docutils literal"><span class="pre">AMCBufferFill()</span></tt></a>, if we&#8217;re RAMPING, and filling the forwarding
buffer of the ramp generation, and the ramp generation is the
forwarding buffer&#8217;s generation, set <tt class="docutils literal"><span class="pre">amcSeg-&gt;new</span></tt> to FALSE.  Otherwise,
add the segment size to <tt class="docutils literal"><span class="pre">poolGen.newSize</span></tt>.</div></blockquote>
<p>And since I&#8217;ve now mentioned the <tt class="docutils literal"><span class="pre">amcSeg-&gt;new</span></tt> flag, here are the only
other uses of that:</p>
<ul class="simple">
<li>it initializes as TRUE.</li>
<li>When leaving an outermost ramp, go through all the segments in the
pool.  Any non-white segment in the rampGen with new set to FALSE has
its size added to <tt class="docutils literal"><span class="pre">poolGen-&gt;newSize</span></tt> and gets new set to TRUE.</li>
<li>in <tt class="xref c c-func docutils literal"><span class="pre">AMCWhiten()</span></tt>, if new is TRUE, the segment size is deducted
from <tt class="docutils literal"><span class="pre">poolGen.newSize</span></tt> and new is set to FALSE.</li>
</ul>
</div>
<div class="section" id="non-amc-pools">
<h3>Non-AMC Pools<a class="headerlink" href="#non-amc-pools" title="Permalink to this headline">¶</a></h3>
<p>The implementations of AMS, AWL, and LO pool classes are all aware of
generations (this is necessary because all tracing is driven by the
generational data structures described above), but do not make use of
them.  For LO and AWL, when a pool is created, a chain with a single
generation is also created, with size and mortality parameters
hard-wired into the pool-creation function (LOInit, AWLInit).  For
AMS, a chain is passed as a pool creation parameter into
<a class="reference internal" href="../topic/pool.html#mps_pool_create" title="mps_pool_create"><tt class="xref c c-func docutils literal"><span class="pre">mps_pool_create()</span></tt></a>, but this chain must also have only a
single generation (otherwise <tt class="docutils literal"><span class="pre">ResPARAM</span></tt> is returned).</p>
<p>Note that these chains are separate from any chain used by an AMC pool
(except in the trivial case when a single-generation chain is used for
both AMC and AMS).  Note also that these pools do not use or point to
the <tt class="docutils literal"><span class="pre">arena-&gt;topGen</span></tt>, which applies only to AMC.</p>
<p>Non-AMC pools have no support for ramps.</p>
</div>
<div class="section" id="starting-a-trace">
<h3>Starting a Trace<a class="headerlink" href="#starting-a-trace" title="Permalink to this headline">¶</a></h3>
<p>TODO: Why do we start a trace?  How do we choose what to condemn?</p>
</div>
<div class="section" id="trace-progress">
<h3>Trace Progress<a class="headerlink" href="#trace-progress" title="Permalink to this headline">¶</a></h3>
<p>TODO: When do we do some tracing work?  How much tracing work do we do?</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">MPS Strategy</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
<li><a class="reference internal" href="#generations">Generations</a><ul>
<li><a class="reference internal" href="#data-structures">Data Structures</a></li>
<li><a class="reference internal" href="#zones">Zones</a></li>
<li><a class="reference internal" href="#accounting">Accounting</a></li>
<li><a class="reference internal" href="#ramps">Ramps</a></li>
<li><a class="reference internal" href="#non-amc-pools">Non-AMC Pools</a></li>
<li><a class="reference internal" href="#starting-a-trace">Starting a Trace</a></li>
<li><a class="reference internal" href="#trace-progress">Trace Progress</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>