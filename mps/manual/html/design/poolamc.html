

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>21. AMC pool class &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Old design" href="old.html" />
    <link rel="next" title="22. AMS pool class" href="poolams.html" />
    <link rel="prev" title="20. Pool and pool class mechanisms" href="pool.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="poolams.html" title="22. AMS pool class"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pool.html" title="20. Pool and pool class mechanisms"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" accesskey="U">Old design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="amc-pool-class">
<span id="design-poolamc"></span><span id="index-0"></span><h1>21. AMC pool class<a class="headerlink" href="#amc-pool-class" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="design.mps.poolamc"></span><h2>21.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolamc.intro"></span><a class="mpstag reference internal" href="#design.mps.poolamc.intro">.intro:</a> This document contains a guide (<a class="reference internal" href="#design.mps.poolamc.guide">.guide</a>) to the MPS AMC
pool class, followed by the historical initial design
(<a class="reference internal" href="#design.mps.poolamc.initial-design">.initial-design</a>).</p>
<p><span class="target" id="design.mps.poolamc.readership"></span><a class="mpstag reference internal" href="#design.mps.poolamc.readership">.readership:</a> Any MPS developer.</p>
</div>
<div class="section" id="guide">
<h2>21.2. Guide<a class="headerlink" href="#guide" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.poolamc.guide"></span><a class="mpstag reference internal" href="#design.mps.poolamc.guide">.guide:</a> The AMC pool class is a general-purpose automatic
(collecting) pool class. It is intended for most client objects. AMC
is &#8220;Automatic, Mostly Copying&#8221;: it preserves objects by copying,
except when an ambiguous reference &#8216;nails&#8217; the object in place. It is
generational. Chain: specify capacity and mortality of generations 0
to <em>N</em> − 1. Survivors from generation <em>N</em> − 1 get promoted into an
arena-wide &#8220;top&#8221; generation (often anachronistically called the
&#8220;dynamic&#8221; generation, which was the term on the Lisp Machine).</p>
<div class="section" id="segment-states">
<h3>21.2.1. Segment states<a class="headerlink" href="#segment-states" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolamc.seg.state"></span><a class="mpstag reference internal" href="#design.mps.poolamc.seg.state">.seg.state:</a> AMC segments are in one of three states: &#8220;mobile&#8221;,
&#8220;boarded&#8221;, or &#8220;stuck&#8221;.</p>
<p><span class="target" id="design.mps.poolamc.seg.state.mobile"></span><a class="mpstag reference internal" href="#design.mps.poolamc.seg.state.mobile">.seg.state.mobile:</a> Segments are normally <strong>mobile</strong>: all objects on
the seg are un-nailed, and thus may be preserved by copying.</p>
<p><span class="target" id="design.mps.poolamc.seg.state.boarded"></span><a class="mpstag reference internal" href="#design.mps.poolamc.seg.state.boarded">.seg.state.boarded:</a> An ambiguous reference to any address within an
segment makes that segment <strong>boarded</strong>: a nailboard is allocated to
record ambiguous references (&#8220;nails&#8221;), but un-nailed objects on the
segment are still preserved by copying.</p>
<p><span class="target" id="design.mps.poolamc.seg.state.stuck"></span><a class="mpstag reference internal" href="#design.mps.poolamc.seg.state.stuck">.seg.state.stuck:</a> Stuck segments only occur in emergency tracing: a
discovery fix to an object in a mobile segment is recorded in the only
non-allocating way available: by making the entire segment <strong>stuck</strong>.</p>
</div>
<div class="section" id="pads">
<h3>21.2.2. Pads<a class="headerlink" href="#pads" title="Permalink to this headline">¶</a></h3>
<p>(See <a class="reference external" href="http://www.ravenbrook.com/project/mps/issue/job001809/">job001809</a> and <a class="reference external" href="http://www.ravenbrook.com/project/mps/issue/job001811/">job001811</a>, and mps/branch/2009-03-31/padding.)</p>
<p><span class="target" id="design.mps.poolamc.pad"></span><a class="mpstag reference internal" href="#design.mps.poolamc.pad">.pad:</a> A pad is logically a trivial client object. Pads are created
by the MPS asking the client&#8217;s format code to create them, to fill up
a space in a segment. Thereafter, the pad appears to the MPS as a
normal client object (that is: the MPS cannot distinguish a pad from a
client object).</p>
<p><span class="target" id="design.mps.poolamc.pad.reason"></span><a class="mpstag reference internal" href="#design.mps.poolamc.pad.reason">.pad.reason:</a> AMC creates pads for three reasons: buffer empty
fragment (BEF), large segment padding (LSP), and non-mobile reclaim
(NMR). (Large segment pads were new with <a class="reference external" href="http://www.ravenbrook.com/project/mps/issue/job001811/">job001811</a>.)</p>
<p><span class="target" id="design.mps.poolamc.pad.reason.bef"></span><a class="mpstag reference internal" href="#design.mps.poolamc.pad.reason.bef">.pad.reason.bef:</a> Buffer empty fragment (BEF) pads are made by
<a class="reference internal" href="#AMCBufferEmpty" title="AMCBufferEmpty"><tt class="xref c c-func docutils literal"><span class="pre">AMCBufferEmpty()</span></tt></a> whenever it detaches a non-empty buffer from an
AMC segment. Buffer detachment is most often caused because the buffer
is too small for the current buffer reserve request (which may be
either a client requested or a forwarding allocation). Detachment may
happen for other reasons, such as trace flip.</p>
<p><span class="target" id="design.mps.poolamc.pad.reason.lsp"></span><a class="mpstag reference internal" href="#design.mps.poolamc.pad.reason.lsp">.pad.reason.lsp:</a> Large segment padding (LSP) pads are made by
<a class="reference internal" href="#AMCBufferFill" title="AMCBufferFill"><tt class="xref c c-func docutils literal"><span class="pre">AMCBufferFill()</span></tt></a> when the requested fill size is &#8220;large&#8221; (see <a class="reference internal" href="#the-lsp-payoff-calculation">The
LSP payoff calculation</a> below). <a class="reference internal" href="#AMCBufferFill" title="AMCBufferFill"><tt class="xref c c-func docutils literal"><span class="pre">AMCBufferFill()</span></tt></a> fills the buffer
to exactly the size requested by the current buffer reserve operation;
that is: it does not round up to the whole segment size. This prevents
subsequent small objects being placed in the same segment as a single
very large object. If the buffer fill size is less than the segment
size, <a class="reference internal" href="#AMCBufferFill" title="AMCBufferFill"><tt class="xref c c-func docutils literal"><span class="pre">AMCBufferFill()</span></tt></a> fills any remainder with an large segment
pad.</p>
<p><span class="target" id="design.mps.poolamc.pad.reason.nmr"></span><a class="mpstag reference internal" href="#design.mps.poolamc.pad.reason.nmr">.pad.reason.nmr:</a> Non-mobile reclaim (NMR) pads are made by
<tt class="xref c c-func docutils literal"><span class="pre">amcReclaimNailed()</span></tt>, when performing reclaim on a non-mobile (that
is, either boarded or stuck) segment:</p>
<p>The more common NMR scenario is reclaim of a boarded segment after a
non-emergency trace. Ambiguous references into the segment are
recorded as nails. Subsequent exact references to a nailed object do
nothing further, but exact refs that do not match a nail cause
preserve-by-copy and leave a forwarding object. Unreachable objects
are not touched during the scan+fix part of the trace. On reclaim,
only nailed objects need to be preserved; others (namely forwarding
pointers and unreachable objects) are replaced by an NMR pad. (Note
that a BEF or LSP pad appears to be an unreachable object, and is
therefore overwritten by an NMR pad).</p>
<p>The less common NMR scenario is after emergency tracing. Boarded
segments still occur; they may have nailed objects from ambiguous
references, forwarding objects from pre-emergency exact fixes, nailed
objects from mid-emergency exact fixes, and unpreserved objects;
reclaim is as in the non-emergency case. Stuck segments may have
forwarding objects from pre-emergency exact fixes, objects from
mid-emergency fixes, and unreachable objects &#8211; but the latter two are
not distinguishable because there is no nailboard. On reclaim, all
objects except forwarding pointers are preserved; each forwarding
object is replaced by an NMR pad.</p>
<p>If <tt class="xref c c-func docutils literal"><span class="pre">amcReclaimNailed()</span></tt> finds no objects to be preserved then it
calls <tt class="xref c c-func docutils literal"><span class="pre">SegFree()</span></tt> (new with <a class="reference external" href="http://www.ravenbrook.com/project/mps/issue/job001809/">job001809</a>).</p>
</div>
<div class="section" id="placement-pads-are-okay">
<h3>21.2.3. Placement pads are okay<a class="headerlink" href="#placement-pads-are-okay" title="Permalink to this headline">¶</a></h3>
<p>Placement pads are the BEF and LSP pads created in &#8220;to-space&#8221; when
placing objects into segments. This wasted space is an expected
space-cost of AMC&#8217;s naive (but time-efficient) approach to placement
of objects into segments. This is normally not a severe problem. (The
worst case is a client that always requests <tt class="docutils literal"><span class="pre">ArenaAlign()</span> <span class="pre">+</span> <span class="pre">1</span></tt> byte
objects: this has a nearly 100% overhead).</p>
</div>
<div class="section" id="retained-pads-could-be-a-problem">
<h3>21.2.4. Retained pads could be a problem<a class="headerlink" href="#retained-pads-could-be-a-problem" title="Permalink to this headline">¶</a></h3>
<p>Retained pads are the NMR pads stuck in &#8220;from-space&#8221;: non-mobile
segments that were condemned but have preserved-in-place objects
cannot be freed by <tt class="xref c c-func docutils literal"><span class="pre">amcReclaimNailed()</span></tt>. The space around the
preserved objects is filled with NMR pads.</p>
<p>In the worst case, retained pads could waste an enormous amount of
space! A small (one-byte) object could retain a multi-page segment for
as long as the ambiguous reference persists; that is: indefinitely.
Imagine a 256-page (1 MiB) segment containing a very large object
followed by a handful of small objects. An ambiguous reference to one
of the small objects will unfortunately cause the entire 256-page
segment to be retained, mostly as an NMR pad; this is a massive
overhead of wasted space.</p>
<p>AMC mitigates this worst-case behaviour, by treating large segments
specially.</p>
</div>
<div class="section" id="small-medium-and-large-segments">
<h3>21.2.5. Small, medium, and large segments<a class="headerlink" href="#small-medium-and-large-segments" title="Permalink to this headline">¶</a></h3>
<p>AMC categorises segments as <strong>small</strong> (one page), <strong>medium</strong>
(several pages), or <strong>large</strong> (<tt class="docutils literal"><span class="pre">AMCLargeSegPAGES</span></tt> or more):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">pages</span> <span class="o">=</span> <span class="n">SegSize</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="o">/</span> <span class="n">ArenaAlign</span><span class="p">(</span><span class="n">arena</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">pages</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* small */</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pages</span> <span class="o">&lt;</span> <span class="n">AMCLargeSegPAGES</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* medium */</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="cm">/* large */</span>
<span class="p">}</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;&lt;/</span><span class="n">blockquote</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">AMCLargeSegPAGES</span></tt> is currently 8 &#8211; see <a class="reference internal" href="#the-lsp-payoff-calculation">The LSP payoff
calculation</a> below.</p>
<p>AMC might treat &#8220;Large&#8221; segments specially, in two ways:</p>
<ul class="simple">
<li><span class="target" id="design.mps.poolamc.large.single-reserve"></span><a class="mpstag reference internal" href="#design.mps.poolamc.large.single-reserve">.large.single-reserve:</a> A large segment is only used for a single
(large) buffer reserve request; the remainder of the segment (if
any) is immediately padded with an LSP pad.</li>
<li><span class="target" id="design.mps.poolamc.large.lsp-no-retain"></span><a class="mpstag reference internal" href="#design.mps.poolamc.large.lsp-no-retain">.large.lsp-no-retain:</a> Nails to such an LSP pad do not cause
AMCReclaimNailed() to retain the segment.</li>
</ul>
<p><a class="reference internal" href="#design.mps.poolamc.large.single-reserve">.large.single-reserve</a> is implemented. See <a class="reference external" href="http://www.ravenbrook.com/project/mps/issue/job001811/">job001811</a>.</p>
<p><a class="reference internal" href="#design.mps.poolamc.large.lsp-no-retain">.large.lsp-no-retain</a> is <strong>not</strong> currently implemented.</p>
<p>The point of <a class="reference internal" href="#design.mps.poolamc.large.lsp-no-retain">.large.lsp-no-retain</a> would be to avoid retention of
the (large) segment when there is a spurious ambiguous reference to
the LSP pad at the end of the segment. Such an ambiguous reference
might happen naturally and repeatably if the preceding large object is
an array, the array is accessed by an ambiguous element pointer (for
example, on the stack), and the element pointer ends up pointing just
off the end of the large object (as is normal for sequential element
access in C) and remains with that value for a while. (Such an
ambiguous reference could also occur by chance, for example, by
coincidence with an <tt class="docutils literal"><span class="pre">int</span></tt> or <tt class="docutils literal"><span class="pre">float</span></tt>, or when the stack grows to
include old unerased values).</p>
<p>Implementing <a class="reference internal" href="#design.mps.poolamc.large.lsp-no-retain">.large.lsp-no-retain</a> is a little tricky. A pad is
indistinguishable from a client object, so AMC has no direct way to
detect, and safely ignore, the final LSP object in the seg. If AMC
could <em>guarantee</em> that the single buffer reserve
(<a class="reference internal" href="#design.mps.poolamc.large.single-reserve">.large.single-reserve</a>) is only used for a single <em>object</em>, then
<tt class="xref c c-func docutils literal"><span class="pre">AMCReclaimNailed()</span></tt> could honour a nail at the start of a large seg
and ignore all others; this would be extremely simple to implement.
But AMC cannot guarantee this, because in the MPS Allocation Point
Protocol the client is permitted to make a large buffer reserve and
then fill it with many small objects. In such a case, AMC must honour
all nails (if the buffer reserve request was an exact multiple of
<tt class="xref c c-func docutils literal"><span class="pre">ArenaAlign()</span></tt>), or all nails except to the last object (if there
was a remainder filled with an LSP pad). Because an LSP pad cannot be
distinguished from a client object, and the requested allocation size
is not recorded, AMC cannot distinguish these two conditions at
reclaim time. Therefore AMC must record whether or not the last object
in the seg is a pad, in order to ignore nails to it. This could be
done by adding a flag to <tt class="xref c c-type docutils literal"><span class="pre">AMCSegStruct</span></tt>. (This can be done without
increasing the structure size, by making the <tt class="docutils literal"><span class="pre">Bool</span> <span class="pre">new</span></tt> field
smaller than its current 32 bits.)</p>
</div>
<div class="section" id="the-lsp-payoff-calculation">
<h3>21.2.6. The LSP payoff calculation<a class="headerlink" href="#the-lsp-payoff-calculation" title="Permalink to this headline">¶</a></h3>
<p>The LSP fix for <a class="reference external" href="http://www.ravenbrook.com/project/mps/issue/job001811/">job001811</a> treats large segments differently. Without
it, after allocating a very large object (in a new very large
multi-page segment), MPS would happily place subsequent small objects
in any remaining space at the end of the segment. This would risk
pathological fragmentation: if these small objects were systematically
preserved by ambiguous refs, enormous NMR pads would be retained along
with them.</p>
<p>The payoff calculation is a bit like deciding whether or not to
purchase insurance. For single-page and medium-sized segments, we go
ahead and use the remaining space for subsequent small objects. This
is equivalent to choosing <strong>not</strong> to purchase insurance. If the small
objects were to be preserved by ambiguous refs, the retained NMR pads
would be big, but not massive. We expect such ambiguous refs to be
uncommon, so we choose to live with this slight risk of bad
fragmentation. The benefit is that the remaining space is used.</p>
<p>For large segments, we decide that the risk of using the remainder is
just too great, and the benefit too small, so we throw it away as an
LSP pad. This is equivalent to purchasing insurance: we choose to pay
a known small cost every time, to avoid risking an occasional
disaster.</p>
<p>To decide what size of segment counts as &#8220;large&#8221;, we must decide how
much uninsured risk we can tolerate, versus how much insurance cost we
can tolerate. The likelihood of ambiguous references retaining objects
is entirely dependent on client behaviour. However, as a sufficient
&#8220;one size fits all&#8221; policy, I (RHSK 2009-09-14) have judged that
segments smaller than eight pages long do not need to be treated as
large: the insurance cost to &#8220;play safe&#8221; would be considerable
(wasting up to one page of remainder per seven pages of allocation),
and the fragmentation overhead risk is not that great (at most eight
times worse than the unavoidable minimum). So <tt class="docutils literal"><span class="pre">AMCLargeSegPAGES</span></tt> is
defined as 8 in config.h. As long as the assumption that most segments
are not ambiguously referenced remains correct, I expect this policy
will be satisfactory.</p>
<p>To verify that this threshold is acceptable for a given client,
poolamc.c calculates metrics; see <a class="reference internal" href="#feedback-about-retained-pages">Feedback about retained pages</a>
below. If this one-size-fits-all approach is not satisfactory,
<tt class="docutils literal"><span class="pre">AMCLargeSegPAGES</span></tt> could be made a client-tunable parameter.</p>
</div>
<div class="section" id="retained-pages">
<h3>21.2.7. Retained pages<a class="headerlink" href="#retained-pages" title="Permalink to this headline">¶</a></h3>
<p>The reasons why a segment and its pages might be retained are:</p>
<ol class="arabic simple">
<li>ambiguous reference to first-obj: unavoidable page retention (only
the mutator can reduce this, if they so wish, by nulling out ambig
referencess);</li>
<li>ambiguous reference to rest-obj: tuning MPS LSP policy could
mitigate this, reducing the likelihood of rest-objs being
co-located with large first-objs;</li>
<li>ambiguous reference to final pad: implementing
<a class="reference internal" href="#design.mps.poolamc.large.lsp-no-retain">.large.lsp-no-retain</a> could mitigate this;</li>
<li>ambiguous reference to other (NMR) pad: hard to mitigate, as pads
are indistinguishable from client objects;</li>
<li>emergency trace;</li>
<li>non-object-aligned ambiguous ref: fixed by <a class="reference external" href="http://www.ravenbrook.com/project/mps/issue/job001809/">job001809</a>;</li>
<li>other reason (for example, buffered at flip): not expected to be a
problem.</li>
</ol>
<p>This list puts the reasons that are more &#8220;obvious&#8221; to the client
programmer first, and the more obscure reasons last.</p>
</div>
<div class="section" id="feedback-about-retained-pages">
<h3>21.2.8. Feedback about retained pages<a class="headerlink" href="#feedback-about-retained-pages" title="Permalink to this headline">¶</a></h3>
<p>(New with <a class="reference external" href="http://www.ravenbrook.com/project/mps/issue/job001811/">job001811</a>). AMC now accumulates counts of pages condemned
and retained during a trace, in categories according to size and
reason for retention, and emits this via the <tt class="docutils literal"><span class="pre">AMCTraceEnd</span></tt> telemetry
event. See comments on the <tt class="xref c c-type docutils literal"><span class="pre">PageRetStruct</span></tt> in <tt class="docutils literal"><span class="pre">poolamc.c</span></tt>. These
page-based metrics are not as precise as actually counting the size of
objects, but they require much less intrusive code to implement, and
should be sufficient to assess whether AMC&#8217;s page retention policies
and behaviour are acceptable.</p>
</div>
</div>
<div class="section" id="initial-design">
<h2>21.3. Initial design<a class="headerlink" href="#initial-design" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>21.3.1. Introduction<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolamc.intro"></span><a class="mpstag reference internal" href="#design.mps.poolamc.intro">.intro:</a> This is the design of the AMC Pool Class. AMC stands for
Automatic Mostly-Copying. This design is highly fragmentory and some
may even be sufficiently old to be misleading.</p>
<p><span class="target" id="design.mps.poolamc.readership"></span><a class="mpstag reference internal" href="#design.mps.poolamc.readership">.readership:</a> The intended readership is any MPS developer.</p>
</div>
<div class="section" id="overview">
<h3>21.3.2. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolamc.overview"></span><a class="mpstag reference internal" href="#design.mps.poolamc.overview">.overview:</a> This class is intended to be the main pool class used by
Harlequin Dylan. It provides garbage collection of objects (hence
&#8220;automatic&#8221;). It uses generational copying algorithms, but with some
facility for handling small numbers of ambiguous references. Ambiguous
references prevent the pool from copying objects (hence &#8220;mostly
copying&#8221;). It provides incremental collection.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">A lot of this design is awesomely old. David Jones, 1998-02-04.</p>
</div>
</div>
<div class="section" id="definitions">
<h3>21.3.3. Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolamc.def.grain"></span><a class="mpstag reference internal" href="#design.mps.poolamc.def.grain">.def.grain:</a> Grain. An quantity of memory which is both aligned to
the pool&#8217;s alignment and equal to the pool&#8217;s alignment in size. That
is, the smallest amount of memory worth talking about.</p>
</div>
<div class="section" id="segments">
<h3>21.3.4. Segments<a class="headerlink" href="#segments" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolamc.seg.class"></span><a class="mpstag reference internal" href="#design.mps.poolamc.seg.class">.seg.class:</a> AMC allocates segments of class <tt class="xref c c-type docutils literal"><span class="pre">AMCSegClass</span></tt>, which
is a subclass of <tt class="xref c c-type docutils literal"><span class="pre">GCSegClass</span></tt>. Instances contain a <tt class="docutils literal"><span class="pre">segTypeP</span></tt>
field, which is of type <tt class="docutils literal"><span class="pre">int*</span></tt>.</p>
<p><span class="target" id="design.mps.poolamc.seg.gen"></span><a class="mpstag reference internal" href="#design.mps.poolamc.seg.gen">.seg.gen:</a> AMC organizes the segments it manages into generations.</p>
<p><span class="target" id="design.mps.poolamc.seg.gen.map"></span><a class="mpstag reference internal" href="#design.mps.poolamc.seg.gen.map">.seg.gen.map:</a> Every segment is in exactly one generation.</p>
<p><span class="target" id="design.mps.poolamc.seg.gen.ind"></span><a class="mpstag reference internal" href="#design.mps.poolamc.seg.gen.ind">.seg.gen.ind:</a> The segment&#8217;s <tt class="docutils literal"><span class="pre">segTypeP</span></tt> field indicates which
generation (that the segment is in) (an <tt class="xref c c-type docutils literal"><span class="pre">AMCGenStruct</span></tt> see blah
below).</p>
<p><span class="target" id="design.mps.poolamc.seg.typep"></span><a class="mpstag reference internal" href="#design.mps.poolamc.seg.typep">.seg.typep:</a> The <tt class="docutils literal"><span class="pre">segTypeP</span></tt> field actually points to either the
type field of a generation or to the type field of a nail board.</p>
<p><span class="target" id="design.mps.poolamc.seg.typep.distinguish"></span><a class="mpstag reference internal" href="#design.mps.poolamc.seg.typep.distinguish">.seg.typep.distinguish:</a> The <tt class="docutils literal"><span class="pre">type</span></tt> field (which can be accessed
in either case) determines whether the <tt class="docutils literal"><span class="pre">segTypeP</span></tt> field is pointing
to a generation or to a nail board.</p>
<p><span class="target" id="design.mps.poolamc.seg.gen.get"></span><a class="mpstag reference internal" href="#design.mps.poolamc.seg.gen.get">.seg.gen.get:</a> The map from segment to generation is implemented by
<tt class="xref c c-func docutils literal"><span class="pre">AMCSegGen()</span></tt> which deals with all this.</p>
</div>
<div class="section" id="fixing-and-nailing">
<h3>21.3.5. Fixing and nailing<a class="headerlink" href="#fixing-and-nailing" title="Permalink to this headline">¶</a></h3>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">This section contains placeholders for design rather than design
really. David Jones, 1998-02-04.</p>
</div>
<p><span class="target" id="design.mps.poolamc.nailboard"></span><a class="mpstag reference internal" href="#design.mps.poolamc.nailboard">.nailboard:</a> AMC uses a nail board structure for recording ambiguous
references to segments. A nail board is a bit table with one bit per
grain in the segment.</p>
<p><span class="target" id="design.mps.poolamc.nailboard.create"></span><a class="mpstag reference internal" href="#design.mps.poolamc.nailboard.create">.nailboard.create:</a> Nail boards are allocated dynamically whenever a
segment becomes newly ambiguously referenced.</p>
<p><span class="target" id="design.mps.poolamc.nailboard.destroy"></span><a class="mpstag reference internal" href="#design.mps.poolamc.nailboard.destroy">.nailboard.destroy:</a> They are deallocated during reclaim. Ambiguous
fixes simply set the appropriate bit in this table. This table is used
by subsequent scans and reclaims in order to work out what objects
were marked.</p>
<p><span class="target" id="design.mps.poolamc.nailboard.emergency"></span><a class="mpstag reference internal" href="#design.mps.poolamc.nailboard.emergency">.nailboard.emergency:</a> During emergency tracing two things relating
to nail boards happen that don&#8217;t normally:</p>
<ol class="arabic">
<li><p class="first"><span class="target" id="design.mps.poolamc.nailboard.emergency.nonew"></span><a class="mpstag reference internal" href="#design.mps.poolamc.nailboard.emergency.nonew">.nailboard.emergency.nonew:</a> Nail boards aren&#8217;t allocated when we
have new ambiguous references to segments.</p>
<p><span class="target" id="design.mps.poolamc.nailboard.emergency.nonew.justify"></span><a class="mpstag reference internal" href="#design.mps.poolamc.nailboard.emergency.nonew.justify">.nailboard.emergency.nonew.justify:</a> We could try and allocate a
nail board, but we&#8217;re in emergency mode so short of memory so it&#8217;s
unlikely to succeed, and there would be additional code for yet
another error path which complicates things.</p>
</li>
<li><p class="first"><span class="target" id="design.mps.poolamc.nailboard.emergency.exact"></span><a class="mpstag reference internal" href="#design.mps.poolamc.nailboard.emergency.exact">.nailboard.emergency.exact:</a> nail boards are used to record exact
references in order to avoid copying the objects.</p>
<p><span class="target" id="design.mps.poolamc.nailboard.hyper-conservative"></span><a class="mpstag reference internal" href="#design.mps.poolamc.nailboard.hyper-conservative">.nailboard.hyper-conservative:</a> Not creating new nail boards
(<a class="reference internal" href="#design.mps.poolamc.nailboard.emergency.nonew">.nailboard.emergency.nonew</a> above) means that when we have a new
reference to a segment during emergency tracing then we nail the
entire segment and preserve everything in place.</p>
</li>
</ol>
<p><span class="target" id="design.mps.poolamc.fix.nail.states"></span><a class="mpstag reference internal" href="#design.mps.poolamc.fix.nail.states">.fix.nail.states:</a> Partition the segment states into four sets:</p>
<ol class="arabic simple">
<li>white segment and not nailed (and has no nail board);</li>
<li>white segment and nailed and has no nail board;</li>
<li>white segment and nailed and has nail board;</li>
<li>the rest.</li>
</ol>
<p><span class="target" id="design.mps.poolamc.fix.nail.why"></span><a class="mpstag reference internal" href="#design.mps.poolamc.fix.nail.why">.fix.nail.why:</a> A segment is recorded as being nailed when either
there is an ambiguous reference to it, or there is an exact reference
to it and the object couldn&#8217;t be copied off the segment (because there
wasn&#8217;t enough memory to allocate the copy). In either of these cases
reclaim cannot simply destroy the segment (usually the segment will
not be destroyed because it will have live objects on it, though see
<a class="reference internal" href="#design.mps.poolamc.nailboard.limitations.middle">.nailboard.limitations.middle</a> below). If the segment is nailed then
we might be using a nail board to mark objects on the segment.
However, we cannot guarantee that being nailed implies a nail board,
because we might not be able to allocate the nail board. Hence all
these states actually occur in practice.</p>
<p><span class="target" id="design.mps.poolamc.fix.nail.distinguish"></span><a class="mpstag reference internal" href="#design.mps.poolamc.fix.nail.distinguish">.fix.nail.distinguish:</a> The nailed bits in the segment descriptor
(<tt class="xref c c-type docutils literal"><span class="pre">SegStruct</span></tt>) are used to record whether a segment is nailed or not.
The <tt class="docutils literal"><span class="pre">segTypeP</span></tt> field of the segment either points to (the &#8220;type&#8221;
field of) an <tt class="docutils literal"><span class="pre">AMCGen</span></tt> or to an <tt class="docutils literal"><span class="pre">AMCNailBoard</span></tt>, the type field can
be used to determine which of these is the case. (see <a class="reference internal" href="#design.mps.poolamc.seg.typep">.seg.typep</a>
above).</p>
<p><span class="target" id="design.mps.poolamc.nailboard.limitations.single"></span><a class="mpstag reference internal" href="#design.mps.poolamc.nailboard.limitations.single">.nailboard.limitations.single:</a> Just having a single nail board per
segment prevents traces from improving on the findings of each other:
a later trace could find that a nailed object is no longer nailed or
even dead. Until the nail board is discarded, that is.</p>
<p><span class="target" id="design.mps.poolamc.nailboard.limitations.middle"></span><a class="mpstag reference internal" href="#design.mps.poolamc.nailboard.limitations.middle">.nailboard.limitations.middle:</a> An ambiguous reference into the
middle of an object will cause the segment to survive, even if there
are no surviving objects on it.</p>
<p><span class="target" id="design.mps.poolamc.nailboard.limitations.reclaim"></span><a class="mpstag reference internal" href="#design.mps.poolamc.nailboard.limitations.reclaim">.nailboard.limitations.reclaim:</a> <tt class="xref c c-func docutils literal"><span class="pre">AMCReclaimNailed()</span></tt> could cover
each block of reclaimed objects between two nailed objects with a
single padding object, speeding up further scans.</p>
</div>
<div class="section" id="emergency-tracing">
<h3>21.3.6. Emergency tracing<a class="headerlink" href="#emergency-tracing" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolamc.emergency.fix"></span><a class="mpstag reference internal" href="#design.mps.poolamc.emergency.fix">.emergency.fix:</a> <tt class="xref c c-func docutils literal"><span class="pre">AMCFixEmergency()</span></tt> is at the core of AMC&#8217;s
emergency tracing policy (unsurprisingly). <tt class="xref c c-func docutils literal"><span class="pre">AMCFixEmergency()</span></tt>
chooses exactly one of three options:</p>
<ol class="arabic simple">
<li>use the existing nail board structure to record the fix;</li>
<li>preserve and nail the segment in its entirety;</li>
<li>snapout an exact (or high rank) pointer to a broken heart to the
broken heart&#8217;s forwarding pointer.</li>
</ol>
<p>If the rank of the reference is <tt class="docutils literal"><span class="pre">RankAMBIG</span></tt> then it either does (1)
or (2) depending on wether there is an existing nail board or not.
Otherwise (the rank is exact or higher) if there is a broken heart it
is used to snapout the pointer. Otherwise it is as for an
<tt class="docutils literal"><span class="pre">RankAMBIG</span></tt> reference: we either do (1) or (2).</p>
<p><span class="target" id="design.mps.poolamc.emergency.scan"></span><a class="mpstag reference internal" href="#design.mps.poolamc.emergency.scan">.emergency.scan:</a> This is basically as before, the only complication
is that when scanning a nailed segment we may need to do multiple
passes, as <tt class="xref c c-func docutils literal"><span class="pre">FixEmergency()</span></tt> may introduce new marks into the nail
board.</p>
</div>
<div class="section" id="buffers">
<h3>21.3.7. Buffers<a class="headerlink" href="#buffers" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolamc.buffer.class"></span><a class="mpstag reference internal" href="#design.mps.poolamc.buffer.class">.buffer.class:</a> AMC uses buffer of class <tt class="xref c c-type docutils literal"><span class="pre">AMCBufClass</span></tt> (a subclass
of SegBufClass).</p>
<p><span class="target" id="design.mps.poolamc.buffer.gen"></span><a class="mpstag reference internal" href="#design.mps.poolamc.buffer.gen">.buffer.gen:</a> Each buffer allocates into exactly one generation.</p>
<p><span class="target" id="design.mps.poolamc.buffer.field.gen"></span><a class="mpstag reference internal" href="#design.mps.poolamc.buffer.field.gen">.buffer.field.gen:</a> <tt class="docutils literal"><span class="pre">AMCBuf</span></tt> buffer contain a gen field which
points to the generation that the buffer allocates into.</p>
<p><span class="target" id="design.mps.poolamc.buffer.fill.gen"></span><a class="mpstag reference internal" href="#design.mps.poolamc.buffer.fill.gen">.buffer.fill.gen:</a> <a class="reference internal" href="#AMCBufferFill" title="AMCBufferFill"><tt class="xref c c-func docutils literal"><span class="pre">AMCBufferFill()</span></tt></a> uses the generation (obtained
from the <tt class="docutils literal"><span class="pre">gen</span></tt> field) to initialise the segment&#8217;s <tt class="docutils literal"><span class="pre">segTypeP</span></tt> field
which is how segments get allocated in that generation.</p>
<p><span class="target" id="design.mps.poolamc.buffer.condemn"></span><a class="mpstag reference internal" href="#design.mps.poolamc.buffer.condemn">.buffer.condemn:</a> We condemn buffered segments, but not the contents
of the buffers themselves, because we can&#8217;t reclaim uncommitted
buffers (see design.mps.buffer for details). If the segment has a
forwarding buffer on it, we detach it.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p>Why? Forwarding buffers are detached because they used to cause
objects on the same segment to not get condemned, hence caused
retention of garbage. Now that we condemn the non-buffered portion
of buffered segments this is probably unnecessary. David Jones,
1998-06-01.</p>
<p class="last">But it&#8217;s probably more efficient than keeping the buffer on the
segment, because then the other stuff gets nailed &#8211; Pekka P.
Pirinen, 1998-07-10.</p>
</div>
<p>If the segment has a mutator buffer on it, we nail the buffer. If the
buffer cannot be nailed, we give up condemning, since nailing the
whole segment would make it survive anyway. The scan methods skip over
buffers and fix methods don&#8217;t do anything to things that have already
been nailed, so the buffer is effectively black.</p>
</div>
<div class="section" id="types">
<h3>21.3.8. Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolamc.struct"></span><a class="mpstag reference internal" href="#design.mps.poolamc.struct">.struct:</a> <tt class="xref c c-type docutils literal"><span class="pre">AMCStruct</span></tt> is the pool class AMC instance structure.</p>
<p><span class="target" id="design.mps.poolamc.struct.pool"></span><a class="mpstag reference internal" href="#design.mps.poolamc.struct.pool">.struct.pool:</a> Like other pool class instances, it contains a
<tt class="xref c c-type docutils literal"><span class="pre">PoolStruct</span></tt> containing the generic pool fields.</p>
<p><span class="target" id="design.mps.poolamc.struct.format"></span><a class="mpstag reference internal" href="#design.mps.poolamc.struct.format">.struct.format:</a> The <tt class="docutils literal"><span class="pre">format</span></tt> field points to a <tt class="xref c c-type docutils literal"><span class="pre">Format</span></tt>
structure describing the object format of objects allocated in the
pool. The field is intialized by <tt class="xref c c-func docutils literal"><span class="pre">AMCInit()</span></tt> from a parameter, and
thereafter it is not changed until the pool is destroyed.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">Actually the format field is in the generic <tt class="xref c c-type docutils literal"><span class="pre">PoolStruct</span></tt> these
days. David Jones, 1998-09-21.</p>
</div>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">There are lots more fields here.</p>
</div>
</div>
<div class="section" id="generations">
<h3>21.3.9. Generations<a class="headerlink" href="#generations" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolamc.gen"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen">.gen:</a> Generations partition the segments that a pool manages (see
<a class="reference internal" href="#design.mps.poolamc.seg.gen.map">.seg.gen.map</a> above).</p>
<p><span class="target" id="design.mps.poolamc.gen.collect"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.collect">.gen.collect:</a> Generations are more or less the units of
condemnation in AMC. And also the granularity for forwarding (when
copying objects during a collection): all the objects which are copied
out of a generation use the same forwarding buffer for allocating the
new copies, and a forwarding buffer results in allocation in exactly
one generation.</p>
<p><span class="target" id="design.mps.poolamc.gen.rep"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.rep">.gen.rep:</a> Generations are represented using an <tt class="xref c c-type docutils literal"><span class="pre">AMCGenStruct</span></tt>
structure.</p>
<p><span class="target" id="design.mps.poolamc.gen.create"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.create">.gen.create:</a> All the generation are create when the pool is created
(during <tt class="xref c c-func docutils literal"><span class="pre">AMCInitComm()</span></tt>).</p>
<p><span class="target" id="design.mps.poolamc.gen.manage.ring"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.manage.ring">.gen.manage.ring:</a> An AMC&#8217;s generations are kept on a ring attached
to the <tt class="xref c c-type docutils literal"><span class="pre">AMCStruct</span></tt> (the <tt class="docutils literal"><span class="pre">genRing</span></tt> field).</p>
<p><span class="target" id="design.mps.poolamc.gen.manage.array"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.manage.array">.gen.manage.array:</a> They are also kept in an array which is
allocated when the pool is created and attached to the <tt class="xref c c-type docutils literal"><span class="pre">AMCStruct</span></tt>
(the gens field holds the number of generations, the <tt class="docutils literal"><span class="pre">gen</span></tt> field
points to an array of <tt class="docutils literal"><span class="pre">AMCGen</span></tt>).</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">it seems to me that we could probably get rid of the ring. David
Jones, 1998-09-22.</p>
</div>
<p><span class="target" id="design.mps.poolamc.gen.number"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.number">.gen.number:</a> There are <tt class="docutils literal"><span class="pre">AMCTopGen</span> <span class="pre">+</span> <span class="pre">2</span></tt> generations in total.
&#8220;normal&#8221; generations numbered from 0 to <tt class="docutils literal"><span class="pre">AMCTopGen</span></tt> inclusive and an
extra &#8220;ramp&#8221; generation (see <a class="reference internal" href="#design.mps.poolamc.gen.ramp">.gen.ramp</a> below).</p>
<p><span class="target" id="design.mps.poolamc.gen.forward"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.forward">.gen.forward:</a> Each generation has an associated forwarding buffer
(stored in the <tt class="docutils literal"><span class="pre">forward</span></tt> field of <tt class="docutils literal"><span class="pre">AMCGen</span></tt>). This is the buffer
that is used to forward objects out of this generation. When a
generation is created in <tt class="xref c c-func docutils literal"><span class="pre">AMCGenCreate()</span></tt>, its forwarding buffer has
a null <tt class="docutils literal"><span class="pre">p</span></tt> field, indicating that the forwarding buffer has no
generation to allocate in. The collector will assert out (in
<a class="reference internal" href="#AMCBufferFill" title="AMCBufferFill"><tt class="xref c c-func docutils literal"><span class="pre">AMCBufferFill()</span></tt></a> where it checks that <tt class="docutils literal"><span class="pre">buffer-&gt;p</span></tt> is an
<tt class="docutils literal"><span class="pre">AMCGen</span></tt>) if you try to forward an object out of such a generation.</p>
<p><span class="target" id="design.mps.poolamc.gen.forward.setup"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.forward.setup">.gen.forward.setup:</a> All the generation&#8217;s forwarding buffer&#8217;s are
associated with generations when the pool is created (just after the
generations are created in <tt class="xref c c-func docutils literal"><span class="pre">AMCInitComm()</span></tt>).</p>
</div>
<div class="section" id="ramps">
<h3>21.3.10. Ramps<a class="headerlink" href="#ramps" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolamc.ramp"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp">.ramp:</a> Ramps usefully implement the begin/end
<a class="reference internal" href="../topic/pattern.html#mps_alloc_pattern_ramp" title="mps_alloc_pattern_ramp"><tt class="xref c c-func docutils literal"><span class="pre">mps_alloc_pattern_ramp()</span></tt></a> interface.</p>
<p><span class="target" id="design.mps.poolamc.gen.ramp"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.ramp">.gen.ramp:</a> To implement ramping (<a class="reference external" href="https://info.ravenbrook.com/project/mps/import/2001-11-05/mmprevol/request/dylan/170423">request.dylan.170423</a>), AMC uses a
special &#8220;ramping mode&#8221;, where promotions are redirected. One
generation is designated the &#8220;ramp generation&#8221; (<tt class="docutils literal"><span class="pre">amc-&gt;rampGen</span></tt> in
the code).</p>
<p><span class="target" id="design.mps.poolamc.gen.ramp.ordinary"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.ramp.ordinary">.gen.ramp.ordinary:</a> Ordinarily, that is whilst not ramping, objects
are promoted into the ramp generation from younger generations and are
promoted out to older generations. The generation that the ramp
generation ordinarily promotes into is designated the &#8220;after-ramp
generation&#8221; (<tt class="docutils literal"><span class="pre">amc-&gt;afterRampGen</span></tt>).</p>
<p><span class="target" id="design.mps.poolamc.gen.ramp.particular"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.ramp.particular">.gen.ramp.particular:</a> the ramp generation is the second oldest
generation and the after-ramp generation is the oldest generation.</p>
<p><span class="target" id="design.mps.poolamc.gen.ramp.possible"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.ramp.possible">.gen.ramp.possible:</a> In alternative designs it might be possible to
make the ramp generation a special generation that is only promoted
into during ramping, however, this is not done.</p>
<p><span class="target" id="design.mps.poolamc.gen.ramp.ramping"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.ramp.ramping">.gen.ramp.ramping:</a> The ramp generation is promoted into itself
during ramping mode;</p>
<p><span class="target" id="design.mps.poolamc.gen.ramp.after"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.ramp.after">.gen.ramp.after:</a> after this mode ends, the ramp generation is
promoted into the after-ramp generation as usual.</p>
<p><span class="target" id="design.mps.poolamc.gen.ramp.after.once"></span><a class="mpstag reference internal" href="#design.mps.poolamc.gen.ramp.after.once">.gen.ramp.after.once:</a> Care is taken to
ensure that there is at least one collection where stuff is promoted
from the ramp generation to the after-ramp generation even if ramping
mode is immediately re-entered.</p>
<p><span class="target" id="design.mps.poolamc.ramp.mode"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.mode">.ramp.mode:</a> This behaviour is controlled in a slightly convoluted
manner by a state machine. The rampMode field of the pool forms an
important part of the state of the machine.</p>
<p>There are five states: OUTSIDE, BEGIN, RAMPING, FINISH, and
COLLECTING. These appear in the code as <tt class="docutils literal"><span class="pre">RampOUTSIDE</span></tt> and so on.</p>
<p><span class="target" id="design.mps.poolamc.ramp.state.cycle.usual"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.state.cycle.usual">.ramp.state.cycle.usual:</a> The usual progression of states is a
cycle: OUTSIDE → BEGIN → RAMPING → FINISH → COLLECTING → OUTSIDE.</p>
<p><span class="target" id="design.mps.poolamc.ramp.count"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.count">.ramp.count:</a> The pool just counts the number of APs that have begun
ramp mode (and not ended). No state changes occur unless this count
goes from 0 to 1 (starting the first ramp) or from 1 to 0 (leaving the
last ramp). In other words, all nested ramps are ignored (see code in
<tt class="xref c c-func docutils literal"><span class="pre">AMCRampBegin()</span></tt> and <tt class="xref c c-func docutils literal"><span class="pre">AMCRampEnd()</span></tt>).</p>
<p><span class="target" id="design.mps.poolamc.ramp.state.invariant.count"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.state.invariant.count">.ramp.state.invariant.count:</a> In the OUTSIDE state the count must be
zero. In the BEGIN and RAMPING states the count must be greater than
zero. In the FINISH and COLLECTING states the count is not
constrained.</p>
<p><span class="target" id="design.mps.poolamc.ramp.state.invariant.forward"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.state.invariant.forward">.ramp.state.invariant.forward:</a> When in OUTSIDE, BEGIN, or
COLLECTING, the ramp generation forwards to the after-ramp generation.
When in RAMPING or FINISH, the ramp generation forwards to itself.</p>
<p><span class="target" id="design.mps.poolamc.ramp.outside"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.outside">.ramp.outside:</a> The pool is initially in the OUTSIDE state. The only
transition away from the OUTSIDE state is to the BEGIN state, when a
ramp is entered.</p>
<p><span class="target" id="design.mps.poolamc.ramp.begin"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.begin">.ramp.begin:</a> When the count goes up from zero, the state moves from
COLLECTING or OUTSIDE to BEGIN.</p>
<p><span class="target" id="design.mps.poolamc.ramp.begin.leave"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.begin.leave">.ramp.begin.leave:</a> We can leave the BEGIN state to either the
OUTSIDE or the RAMPING state.</p>
<p><span class="target" id="design.mps.poolamc.ramp.begin.leave.outside"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.begin.leave.outside">.ramp.begin.leave.outside:</a> We go to OUTSIDE if the count drops to 0
before a collection starts. This shortcuts the usual cycle of states
for small enough ramps.</p>
<p><span class="target" id="design.mps.poolamc.ramp.begin.leave.ramping"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.begin.leave.ramping">.ramp.begin.leave.ramping:</a> We enter the RAMPING state if a
collection starts that condemns the ramp generation (pedantically when
a new GC begins, and a segment in the ramp generation is condemned, we
leave the BEGIN state, see AMCWhiten). At this point we switch the
ramp generation to forward to itself (<a class="reference internal" href="#design.mps.poolamc.gen.ramp.ramping">.gen.ramp.ramping</a>).</p>
<p><span class="target" id="design.mps.poolamc.ramp.ramping.leave"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.ramping.leave">.ramp.ramping.leave:</a> We leave the RAMPING state and go to the
FINISH state when the ramp count goes back to zero. Thus, the FINISH
state indicates that we have started collecting the ramp generation
while inside a ramp which we have subsequently finished.</p>
<p><span class="target" id="design.mps.poolamc.ramp.finish.remain"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.finish.remain">.ramp.finish.remain:</a> We remain in the FINISH state until we next
start to collect the ramp generation (condemn it), regardless of
entering or leaving any ramps. This ensures that the ramp generation
will be collected to the after-ramp generation at least once.</p>
<p><span class="target" id="design.mps.poolamc.ramp.finish.leave"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.finish.leave">.ramp.finish.leave:</a> When we next condemn the ramp genearation, we
move to the COLLECTING state. At this point the forwarding generations
are switched back so that the ramp generation promotes into the
after-ramp generation on this collection.</p>
<p><span class="target" id="design.mps.poolamc.ramp.collecting.leave"></span><a class="mpstag reference internal" href="#design.mps.poolamc.ramp.collecting.leave">.ramp.collecting.leave:</a> We leave the COLLECTING state when the GC
enters reclaim (specifically, when a segment in the ramp generation is
reclaimed), or when we begin another ramp. Ordinarily we enter the
OUTSIDE state, but if the client has started a ramp then we go
directly to the BEGIN state.</p>
<p><span class="target" id="ramp-collect-all">.ramp.collect-all</span> There used to be two flavours of ramps: the
normal one and the collect-all flavour that triggered a full GC after
the ramp end. This was a hack for producing certain Dylan statistics,
and no longer has any effect (the flag is passed to
<tt class="xref c c-func docutils literal"><span class="pre">AMCRampBegin()</span></tt>, but ignored there).</p>
</div>
<div class="section" id="headers">
<h3>21.3.11. Headers<a class="headerlink" href="#headers" title="Permalink to this headline">¶</a></h3>
<p><span class="target" id="design.mps.poolamc.header"></span><a class="mpstag reference internal" href="#design.mps.poolamc.header">.header:</a> AMC supports a fixed-size header on objects, with the
client pointers pointing after the header, rather than the base of the
memory block. See format documentation for details of the interface.</p>
<p><span class="target" id="design.mps.poolamc.header.client"></span><a class="mpstag reference internal" href="#design.mps.poolamc.header.client">.header.client:</a> The code mostly deals in client pointers, only
computing the base and limit of a block when these are needed (such as
when an object is copied). In several places, the code gets a block of
some sort, a segment or a buffer, and creates a client pointer by
adding the header length (<tt class="docutils literal"><span class="pre">pool-&gt;format-&gt;headerLength</span></tt>).</p>
<p><span class="target" id="design.mps.poolamc.header.fix"></span><a class="mpstag reference internal" href="#design.mps.poolamc.header.fix">.header.fix:</a> There are two versions of the fix method, due to its
criticality, with (<tt class="xref c c-func docutils literal"><span class="pre">AMCHeaderFix()</span></tt>) and without (<a class="reference internal" href="#AMCFix" title="AMCFix"><tt class="xref c c-func docutils literal"><span class="pre">AMCFix()</span></tt></a>)
headers. The correct one is selected in <tt class="xref c c-func docutils literal"><span class="pre">AMCInitComm()</span></tt>, and placed
in the pool&#8217;s fix field. This is the main reason why fix methods
dispatch through the instance, rather than the class like all other
methods.</p>
</div>
<div class="section" id="old-and-aging-notes-below-here">
<h3>21.3.12. Old and aging notes below here<a class="headerlink" href="#old-and-aging-notes-below-here" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="AMCFinish">
void <tt class="descname">AMCFinish</tt><big>(</big>Pool<em>&nbsp;pool</em><big>)</big><a class="headerlink" href="#AMCFinish" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolamc.finish.forward"></span><a class="mpstag reference internal" href="#design.mps.poolamc.finish.forward">.finish.forward:</a> If the pool is being destroyed it is OK to destroy
the forwarding buffers, as the condemned set is about to disappear.</p>
<dl class="function">
<dt id="AMCBufferEmpty">
void <tt class="descname">AMCBufferEmpty</tt><big>(</big>Pool<em>&nbsp;pool</em>, Buffer<em>&nbsp;buffer</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;init</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;limit</em><big>)</big><a class="headerlink" href="#AMCBufferEmpty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolamc.flush"></span><a class="mpstag reference internal" href="#design.mps.poolamc.flush">.flush:</a> Removes the connexion between a buffer and a group, so that
the group is no longer buffered, and the buffer is reset and will
cause a refill when next used.</p>
<p><span class="target" id="design.mps.poolamc.flush.pad"></span><a class="mpstag reference internal" href="#design.mps.poolamc.flush.pad">.flush.pad:</a> The group is padded out with a dummy object so that it
appears full.</p>
<p><span class="target" id="design.mps.poolamc.flush.expose"></span><a class="mpstag reference internal" href="#design.mps.poolamc.flush.expose">.flush.expose:</a> The buffer needs exposing before writing the padding
object onto it. If the buffer is being used for forwarding it might
already be exposed, in this case the segment attached to it must be
covered when it leaves the buffer. See <a class="reference internal" href="#design.mps.poolamc.fill.expose">.fill.expose</a>.</p>
<p><span class="target" id="design.mps.poolamc.flush.cover"></span><a class="mpstag reference internal" href="#design.mps.poolamc.flush.cover">.flush.cover:</a> The buffer needs covering whether it was being used
for forwarding or not. See <a class="reference internal" href="#design.mps.poolamc.flush.expose">.flush.expose</a>.</p>
<dl class="function">
<dt id="AMCBufferFill">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">AMCBufferFill</tt><big>(</big><a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;*baseReturn</em>, <a class="reference internal" href="type.html#Addr" title="Addr">Addr</a><em>&nbsp;*limitReturn</em>, Pool<em>&nbsp;pool</em>, Buffer<em>&nbsp;buffer</em>, <a class="reference internal" href="type.html#Size" title="Size">Size</a><em>&nbsp;size</em>, <a class="reference internal" href="type.html#Bool" title="Bool">Bool</a><em>&nbsp;withReservoirPermit</em><big>)</big><a class="headerlink" href="#AMCBufferFill" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolamc.fill"></span><a class="mpstag reference internal" href="#design.mps.poolamc.fill">.fill:</a> Reserve was called on an allocation buffer which was reset,
or there wasn&#8217;t enough room left in the buffer. Allocate a group for
the new object and attach it to the buffer.</p>
<p><span class="target" id="design.mps.poolamc.fill.expose"></span><a class="mpstag reference internal" href="#design.mps.poolamc.fill.expose">.fill.expose:</a> If the buffer is being used for forwarding it may be
exposed, in which case the group attached to it should be exposed. See
<a class="reference internal" href="#design.mps.poolamc.flush.cover">.flush.cover</a>.</p>
<dl class="function">
<dt id="AMCFix">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">AMCFix</tt><big>(</big>Pool<em>&nbsp;pool</em>, ScanState<em>&nbsp;ss</em>, <a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;seg</em>, <a class="reference internal" href="type.html#Ref" title="Ref">Ref</a><em>&nbsp;*refIO</em><big>)</big><a class="headerlink" href="#AMCFix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolamc.fix"></span><a class="mpstag reference internal" href="#design.mps.poolamc.fix">.fix:</a> Fix a reference to the pool.</p>
<p>Ambiguous references lock down an entire segment by removing it
from old-space and also marking it grey for future scanning.</p>
<p>Exact, final, and weak references are merged because the action for an
already forwarded object is the same in each case. After that
situation is checked for, the code diverges.</p>
<p>Weak references are either snapped out or replaced with
<tt class="docutils literal"><span class="pre">ss-&gt;weakSplat</span></tt> as appropriate.</p>
<p>Exact and final references cause the referenced object to be copied to
new-space and the old copy to be forwarded (broken-heart installed) so
that future references are fixed up to point at the new copy.</p>
<p><span class="target" id="design.mps.poolamc.fix.exact.expose"></span><a class="mpstag reference internal" href="#design.mps.poolamc.fix.exact.expose">.fix.exact.expose:</a> In order to allocate the new copy the forwarding
buffer must be exposed. This might be done more efficiently outside
the entire scan, since it&#8217;s likely to happen a lot.</p>
<p><span class="target" id="design.mps.poolamc.fix.exact.grey"></span><a class="mpstag reference internal" href="#design.mps.poolamc.fix.exact.grey">.fix.exact.grey:</a> The new copy must be at least as grey as the old
as it may have been grey for some other collection.</p>
<dl class="function">
<dt id="AMCScan">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">AMCScan</tt><big>(</big><a class="reference internal" href="type.html#Bool" title="Bool">Bool</a><em>&nbsp;*totalReturn</em>, ScanState<em>&nbsp;ss</em>, Pool<em>&nbsp;pool</em>, <a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;seg</em><big>)</big><a class="headerlink" href="#AMCScan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolamc.scan"></span><a class="mpstag reference internal" href="#design.mps.poolamc.scan">.scan:</a> Searches for a group which is grey for the trace and scans
it. If there aren&#8217;t any, it sets the finished flag to true.</p>
<dl class="function">
<dt id="AMCReclaim">
void <tt class="descname">AMCReclaim</tt><big>(</big>Pool<em>&nbsp;pool</em>, Trace<em>&nbsp;trace</em>, <a class="reference internal" href="seg.html#Seg" title="Seg">Seg</a><em>&nbsp;seg</em><big>)</big><a class="headerlink" href="#AMCReclaim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.poolamc.reclaim"></span><a class="mpstag reference internal" href="#design.mps.poolamc.reclaim">.reclaim:</a> After a trace, destroy any groups which are still
condemned for the trace, because they must be dead.</p>
<p><span class="target" id="design.mps.poolamc.reclaim.grey"></span><a class="mpstag reference internal" href="#design.mps.poolamc.reclaim.grey">.reclaim.grey:</a> Note that this might delete things which are grey
for other collections. This is OK, because we have conclusively proved
that they are dead &#8211; the other collection must have assumed they were
alive. There might be a problem with the accounting of grey groups,
however.</p>
<p><span class="target" id="design.mps.poolamc.reclaim.buf"></span><a class="mpstag reference internal" href="#design.mps.poolamc.reclaim.buf">.reclaim.buf:</a> If a condemned group still has a buffer attached, we
can&#8217;t destroy it, even though we know that there are no live objects
there. Even the object the mutator is allocating is dead, because the
buffer is tripped.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">21. AMC pool class</a><ul>
<li><a class="reference internal" href="#introduction">21.1. Introduction</a></li>
<li><a class="reference internal" href="#guide">21.2. Guide</a><ul>
<li><a class="reference internal" href="#segment-states">21.2.1. Segment states</a></li>
<li><a class="reference internal" href="#pads">21.2.2. Pads</a></li>
<li><a class="reference internal" href="#placement-pads-are-okay">21.2.3. Placement pads are okay</a></li>
<li><a class="reference internal" href="#retained-pads-could-be-a-problem">21.2.4. Retained pads could be a problem</a></li>
<li><a class="reference internal" href="#small-medium-and-large-segments">21.2.5. Small, medium, and large segments</a></li>
<li><a class="reference internal" href="#the-lsp-payoff-calculation">21.2.6. The LSP payoff calculation</a></li>
<li><a class="reference internal" href="#retained-pages">21.2.7. Retained pages</a></li>
<li><a class="reference internal" href="#feedback-about-retained-pages">21.2.8. Feedback about retained pages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#initial-design">21.3. Initial design</a><ul>
<li><a class="reference internal" href="#id1">21.3.1. Introduction</a></li>
<li><a class="reference internal" href="#overview">21.3.2. Overview</a></li>
<li><a class="reference internal" href="#definitions">21.3.3. Definitions</a></li>
<li><a class="reference internal" href="#segments">21.3.4. Segments</a></li>
<li><a class="reference internal" href="#fixing-and-nailing">21.3.5. Fixing and nailing</a></li>
<li><a class="reference internal" href="#emergency-tracing">21.3.6. Emergency tracing</a></li>
<li><a class="reference internal" href="#buffers">21.3.7. Buffers</a></li>
<li><a class="reference internal" href="#types">21.3.8. Types</a></li>
<li><a class="reference internal" href="#generations">21.3.9. Generations</a></li>
<li><a class="reference internal" href="#ramps">21.3.10. Ramps</a></li>
<li><a class="reference internal" href="#headers">21.3.11. Headers</a></li>
<li><a class="reference internal" href="#old-and-aging-notes-below-here">21.3.12. Old and aging notes below here</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="pool.html"
                        title="previous chapter">20. Pool and pool class mechanisms</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="poolams.html"
                        title="next chapter">22. AMS pool class</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="poolams.html" title="22. AMS pool class"
             >next</a> |</li>
        <li class="right" >
          <a href="pool.html" title="20. Pool and pool class mechanisms"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="old.html" >Old design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>