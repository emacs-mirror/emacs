

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5. Free list allocator &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Design" href="index.html" />
    <link rel="next" title="6. Transliterating the alphabet into hexadecimal" href="guide.hex.trans.html" />
    <link rel="prev" title="4. The critical path through the MPS" href="critical-path.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="guide.hex.trans.html" title="6. Transliterating the alphabet into hexadecimal"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="critical-path.html" title="4. The critical path through the MPS"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="free-list-allocator">
<h1>5. Free list allocator<a class="headerlink" href="#free-list-allocator" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="design.mps.freelist"></span><h2>5.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.freelist.intro"></span><a class="mpstag reference internal" href="#design.mps.freelist.intro">.intro:</a> This document describes the free list allocator for the
Memory Pool System.</p>
<p><span class="target" id="design.mps.freelist.readership"></span><a class="mpstag reference internal" href="#design.mps.freelist.readership">.readership:</a> Any MPS developer.</p>
</div>
<div class="section" id="overview">
<h2>5.2. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.freelist.overview"></span><a class="mpstag reference internal" href="#design.mps.freelist.overview">.overview:</a> The free list allocator is an &#8220;emergency&#8221; allocator. It
is intended for use as a fallback allocation strategy in low memory
situations, when memory is not available for the control structures
needed by other allocators. In these situations the free list allocator
ensures that memory is not lost, but with several disadvantages:</p>
<ol class="arabic simple">
<li>operations on the free list are O(n) in the number of free blocks;</li>
<li>the data structures are stored in client memory and so are
vulnerable to corruption;</li>
<li>the data structures have poor locality (and thus potentially poor
cache performance).</li>
</ol>
<p>When memory becomes available again to allocate control structures,
the free lists can be &#8220;flushed&#8221; back into the more efficient data
structures.</p>
<p><span class="target" id="design.mps.freelist.bg"></span><a class="mpstag reference internal" href="#design.mps.freelist.bg">.bg:</a> The free list allocator was formerly part of the Coalescing
Block Structure module (see design.mps.cbs) but it was split into its
own module because this makes it:</p>
<ol class="arabic simple">
<li>simpler (no need to interact with CBS) and thus more maintainable;</li>
<li>possible to test directly (no need to create a CBS and then force
its control pool to run out of memory); and</li>
<li>usable as a fallback allocator in other pools (not just in pools
that use CBS).</li>
</ol>
</div>
<div class="section" id="definitions">
<h2>5.3. Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.freelist.def.range"></span><a class="mpstag reference internal" href="#design.mps.freelist.def.range">.def.range:</a> A (contiguous) <em>range</em> of addresses is a semi-open
interval on address space.</p>
<p><span class="target" id="design.mps.freelist.def.isolated"></span><a class="mpstag reference internal" href="#design.mps.freelist.def.isolated">.def.isolated:</a> A contiguous range is <em>isolated</em> with respect to
some property it has, if adjacent elements do not have that property.</p>
</div>
<div class="section" id="requirements">
<h2>5.4. Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.freelist.req.set"></span><a class="mpstag reference internal" href="#design.mps.freelist.req.set">.req.set:</a> Must maintain a set of free address ranges.</p>
<p><span class="target" id="design.mps.freelist.req.add"></span><a class="mpstag reference internal" href="#design.mps.freelist.req.add">.req.add:</a> Must be able to add free address ranges to the set.</p>
<p><span class="target" id="design.mps.freelist.req.remove"></span><a class="mpstag reference internal" href="#design.mps.freelist.req.remove">.req.remove:</a> Must be able to remove address ranges from the set (in
particular, when memory is allocated).</p>
<p><span class="target" id="design.mps.freelist.req.iterate"></span><a class="mpstag reference internal" href="#design.mps.freelist.req.iterate">.req.iterate:</a> Must support the iteration of all isolated contiguous
ranges.</p>
<p><span class="target" id="design.mps.freelist.req.protocol"></span><a class="mpstag reference internal" href="#design.mps.freelist.req.protocol">.req.protocol:</a> Must detect protocol violations.</p>
<p><span class="target" id="design.mps.freelist.req.align"></span><a class="mpstag reference internal" href="#design.mps.freelist.req.align">.req.align:</a> Must support an alignment (the alignment of all
addresses specifying ranges) of down to <tt class="docutils literal"><span class="pre">sizeof(void&nbsp;*)</span></tt> without
losing memory.</p>
<p><span class="target" id="design.mps.freelist.req.zero-overhead"></span><a class="mpstag reference internal" href="#design.mps.freelist.req.zero-overhead">.req.zero-overhead:</a> Must have zero space overhead for the storage
of any set of free blocks, so that it can be used to manage memory
when no memory can be allocated for control structures.</p>
<p><span class="target" id="design.mps.freelist.req.source"></span><a class="mpstag reference internal" href="#design.mps.freelist.req.source">.req.source:</a> This set of requirements is derived from those of the
CBS module (see design.mps.cbs.req), except that there is no
equivalent of design.mps.cbs.req.fast, and design.mps.cbs.req.small
has been replaced with <a class="reference internal" href="#design.mps.freelist.req.zero-overhead">.req.zero-overhead</a>.</p>
</div>
<div class="section" id="interface">
<h2>5.5. Interface<a class="headerlink" href="#interface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="types">
<h3>5.5.1. Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="Freelist">
struct FreelistStruct *<tt class="descname">Freelist</tt><a class="headerlink" href="#Freelist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.freelist.type.freelist"></span><a class="mpstag reference internal" href="#design.mps.freelist.type.freelist">.type.freelist:</a> The type of free lists. The structure
<tt class="xref c c-type docutils literal"><span class="pre">FreelistStruct</span></tt> is declared in the header so that it can be inlined
in other structures, but you should not depend on its details.</p>
<dl class="type">
<dt id="FreelistIterateMethod">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">(*FreelistIterateMethod)</tt><big>(</big><a class="reference internal" href="type.html#Bool" title="Bool">Bool</a><em>&nbsp;*deleteReturn</em>, <a class="reference internal" href="#Freelist" title="Freelist">Freelist</a><em>&nbsp;fl</em>, <a class="reference internal" href="range.html#Range" title="Range">Range</a><em>&nbsp;range</em>, void<em>&nbsp;*closureP</em>, <a class="reference internal" href="type.html#Size" title="Size">Size</a><em>&nbsp;closureS</em><big>)</big><a class="headerlink" href="#FreelistIterateMethod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.freelist.type.iterate.method"></span><a class="mpstag reference internal" href="#design.mps.freelist.type.iterate.method">.type.iterate.method:</a> A callback function that may be passed to
<a class="reference internal" href="#FreelistIterate" title="FreelistIterate"><tt class="xref c c-func docutils literal"><span class="pre">FreelistIterate()</span></tt></a>. It is called for every isolated contiguous
range in address order, and with the closure arguments that were
originally passed to <a class="reference internal" href="#FreelistIterate" title="FreelistIterate"><tt class="xref c c-func docutils literal"><span class="pre">FreelistIterate()</span></tt></a>. It must update
<tt class="docutils literal"><span class="pre">*deleteReturn</span></tt> to <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt> if the range must be deleted from the
free lists, or <tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt> if the range must be kept. The function must
return <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt> if the iteration must continue, and <tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt> if the
iteration must stop (after possibly deleting the current range).</p>
</div>
<div class="section" id="functions">
<h3>5.5.2. Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="FreelistInit">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">FreelistInit</tt><big>(</big><a class="reference internal" href="#Freelist" title="Freelist">Freelist</a><em>&nbsp;fl</em>, <a class="reference internal" href="type.html#Align" title="Align">Align</a><em>&nbsp;alignment</em><big>)</big><a class="headerlink" href="#FreelistInit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.freelist.function.init"></span><a class="mpstag reference internal" href="#design.mps.freelist.function.init">.function.init:</a> Initialize the <tt class="docutils literal"><span class="pre">Freelist</span></tt> structure pointed to by
<tt class="docutils literal"><span class="pre">fl</span></tt>. The argument <tt class="docutils literal"><span class="pre">alignment</span></tt> is the alignment of address ranges
to be maintained. An initialised free list contains no address ranges.</p>
<dl class="function">
<dt id="FreelistFinish">
void <tt class="descname">FreelistFinish</tt><big>(</big><a class="reference internal" href="#Freelist" title="Freelist">Freelist</a><em>&nbsp;fl</em><big>)</big><a class="headerlink" href="#FreelistFinish" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.freelist.function.finish"></span><a class="mpstag reference internal" href="#design.mps.freelist.function.finish">.function.finish:</a> Finish the free list pointed to by <tt class="docutils literal"><span class="pre">fl</span></tt>.</p>
<dl class="function">
<dt id="FreelistInsert">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">FreelistInsert</tt><big>(</big><a class="reference internal" href="range.html#Range" title="Range">Range</a><em>&nbsp;rangeReturn</em>, <a class="reference internal" href="#Freelist" title="Freelist">Freelist</a><em>&nbsp;fl</em>, <a class="reference internal" href="range.html#Range" title="Range">Range</a><em>&nbsp;range</em><big>)</big><a class="headerlink" href="#FreelistInsert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.freelist.function.insert"></span><a class="mpstag reference internal" href="#design.mps.freelist.function.insert">.function.insert:</a> If any part of <tt class="docutils literal"><span class="pre">range</span></tt> is already in the free
list <tt class="docutils literal"><span class="pre">fl</span></tt>, then leave the free list unchanged and return
<tt class="docutils literal"><span class="pre">ResFAIL</span></tt>. Otherwise, insert <tt class="docutils literal"><span class="pre">range</span></tt> into the free list <tt class="docutils literal"><span class="pre">fl</span></tt>;
update <tt class="docutils literal"><span class="pre">rangeReturn</span></tt> to describe the contiguous isolated range
containing the inserted range (this may differ from <tt class="docutils literal"><span class="pre">range</span></tt> if there
was coalescence on either side) and return <tt class="docutils literal"><span class="pre">ResOK</span></tt>.</p>
<dl class="function">
<dt id="FreelistDelete">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">FreelistDelete</tt><big>(</big><a class="reference internal" href="range.html#Range" title="Range">Range</a><em>&nbsp;rangeReturn</em>, <a class="reference internal" href="#Freelist" title="Freelist">Freelist</a><em>&nbsp;fl</em>, <a class="reference internal" href="range.html#Range" title="Range">Range</a><em>&nbsp;range</em><big>)</big><a class="headerlink" href="#FreelistDelete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.freelist.function.delete"></span><a class="mpstag reference internal" href="#design.mps.freelist.function.delete">.function.delete:</a> If any part of the range is not in the free list,
then leave the free list unchanged and return <tt class="docutils literal"><span class="pre">ResFAIL</span></tt>. Otherwise,
remove <tt class="docutils literal"><span class="pre">range</span></tt> from the free list and update <tt class="docutils literal"><span class="pre">rangeReturn</span></tt> to
describe the contiguous isolated range that formerly contained the
deleted range (this may differ from <tt class="docutils literal"><span class="pre">range</span></tt> if there were fragments
left on either side), and return <tt class="docutils literal"><span class="pre">ResOK</span></tt>.</p>
<dl class="function">
<dt id="FreelistIterate">
void <tt class="descname">FreelistIterate</tt><big>(</big><a class="reference internal" href="#Freelist" title="Freelist">Freelist</a><em>&nbsp;fl</em>, <a class="reference internal" href="#FreelistIterateMethod" title="FreelistIterateMethod">FreelistIterateMethod</a><em>&nbsp;iterate</em>, void<em>&nbsp;*closureP</em>, <a class="reference internal" href="type.html#Size" title="Size">Size</a><em>&nbsp;closureS</em><big>)</big><a class="headerlink" href="#FreelistIterate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.freelist.function.iterate"></span><a class="mpstag reference internal" href="#design.mps.freelist.function.iterate">.function.iterate:</a> Iterate all isolated contiguous ranges in the
free list <tt class="docutils literal"><span class="pre">fl</span></tt> in address order, calling <tt class="docutils literal"><span class="pre">iterate</span></tt> for each one.
See <a class="reference internal" href="#FreelistIterateMethod" title="FreelistIterateMethod"><tt class="xref c c-type docutils literal"><span class="pre">FreelistIterateMethod</span></tt></a> for details.</p>
<dl class="function">
<dt id="FreelistFindFirst">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">FreelistFindFirst</tt><big>(</big><a class="reference internal" href="range.html#Range" title="Range">Range</a><em>&nbsp;rangeReturn</em>, <a class="reference internal" href="range.html#Range" title="Range">Range</a><em>&nbsp;oldRangeReturn</em>, <a class="reference internal" href="#Freelist" title="Freelist">Freelist</a><em>&nbsp;fl</em>, <a class="reference internal" href="type.html#Size" title="Size">Size</a><em>&nbsp;size</em>, FindDelete<em>&nbsp;findDelete</em><big>)</big><a class="headerlink" href="#FreelistFindFirst" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.freelist.function.find.first"></span><a class="mpstag reference internal" href="#design.mps.freelist.function.find.first">.function.find.first:</a> Locate the first isolated contiguous range in
address order, within the free list <tt class="docutils literal"><span class="pre">fl</span></tt>, of at least <tt class="docutils literal"><span class="pre">size</span></tt>
bytes, update <tt class="docutils literal"><span class="pre">rangeReturn</span></tt> to that range, and return <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt>. If
there is no such continuous range, return <tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt>.</p>
<p>In addition, optionally delete the found range from the free list,
depending on the <tt class="docutils literal"><span class="pre">findDelete</span></tt> argument. This saves a separate call
to <a class="reference internal" href="#FreelistDelete" title="FreelistDelete"><tt class="xref c c-func docutils literal"><span class="pre">FreelistDelete()</span></tt></a>, and uses the knowledge of exactly where we
found the range. The value of <tt class="docutils literal"><span class="pre">findDelete</span></tt> must come from this
enumeration:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">enum</span> <span class="p">{</span>
    <span class="n">FindDeleteNONE</span><span class="p">,</span>    <span class="cm">/* don&#39;t delete after finding */</span>
    <span class="n">FindDeleteLOW</span><span class="p">,</span>     <span class="cm">/* delete size bytes from low end of block */</span>
    <span class="n">FindDeleteHIGH</span><span class="p">,</span>    <span class="cm">/* delete size bytes from high end of block */</span>
    <span class="n">FindDeleteENTIRE</span>   <span class="cm">/* delete entire range */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The original contiguous isolated range in which the range was found is
returned via the <tt class="docutils literal"><span class="pre">oldRangeReturn</span></tt> argument. (If <tt class="docutils literal"><span class="pre">findDelete</span></tt> is
<tt class="docutils literal"><span class="pre">FindDeleteNONE</span></tt> or <tt class="docutils literal"><span class="pre">FindDeleteENTIRE</span></tt>, then this will be
identical to the range returned via the <tt class="docutils literal"><span class="pre">rangeReturn</span></tt> argument.)</p>
<dl class="function">
<dt id="FreelistFindLast">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">FreelistFindLast</tt><big>(</big><a class="reference internal" href="range.html#Range" title="Range">Range</a><em>&nbsp;rangeReturn</em>, <a class="reference internal" href="range.html#Range" title="Range">Range</a><em>&nbsp;oldRangeReturn</em>, <a class="reference internal" href="#Freelist" title="Freelist">Freelist</a><em>&nbsp;fl</em>, <a class="reference internal" href="type.html#Size" title="Size">Size</a><em>&nbsp;size</em>, FindDelete<em>&nbsp;findDelete</em><big>)</big><a class="headerlink" href="#FreelistFindLast" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.freelist.function.find.last"></span><a class="mpstag reference internal" href="#design.mps.freelist.function.find.last">.function.find.last:</a> Like <a class="reference internal" href="#FreelistFindFirst" title="FreelistFindFirst"><tt class="xref c c-func docutils literal"><span class="pre">FreelistFindFirst()</span></tt></a>, except that it
finds the last block in address order.</p>
<dl class="function">
<dt id="FreelistFindLargest">
<a class="reference internal" href="type.html#Bool" title="Bool">Bool</a> <tt class="descname">FreelistFindLargest</tt><big>(</big><a class="reference internal" href="range.html#Range" title="Range">Range</a><em>&nbsp;rangeReturn</em>, <a class="reference internal" href="range.html#Range" title="Range">Range</a><em>&nbsp;oldRangeReturn</em>, <a class="reference internal" href="#Freelist" title="Freelist">Freelist</a><em>&nbsp;fl</em>, <a class="reference internal" href="type.html#Size" title="Size">Size</a>, size, FindDelete<em>&nbsp;findDelete</em><big>)</big><a class="headerlink" href="#FreelistFindLargest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.freelist.function.find.largest"></span><a class="mpstag reference internal" href="#design.mps.freelist.function.find.largest">.function.find.largest:</a> Locate the largest block within the free
list <tt class="docutils literal"><span class="pre">fl</span></tt>, and if that block is at least as big as <tt class="docutils literal"><span class="pre">size</span></tt>, return
its range via the <tt class="docutils literal"><span class="pre">rangeReturn</span></tt> argument, and return <tt class="xref c c-macro docutils literal"><span class="pre">TRUE</span></tt>. If
there are no blocks in the free list at least as large as <tt class="docutils literal"><span class="pre">size</span></tt>,
return <tt class="xref c c-macro docutils literal"><span class="pre">FALSE</span></tt>. Pass 0 for <tt class="docutils literal"><span class="pre">size</span></tt> if you want the largest block
unconditionally.</p>
<p>Like <a class="reference internal" href="#FreelistFindFirst" title="FreelistFindFirst"><tt class="xref c c-func docutils literal"><span class="pre">FreelistFindFirst()</span></tt></a>, optionally delete the range from the
free list. (Always the whole range: specifying <tt class="docutils literal"><span class="pre">FindDeleteLOW</span></tt> or
<tt class="docutils literal"><span class="pre">FindDeleteHIGH</span></tt> has the same effect as <tt class="docutils literal"><span class="pre">FindDeleteENTIRE</span></tt>).</p>
<dl class="function">
<dt id="FreelistFlushToCBS">
void <tt class="descname">FreelistFlushToCBS</tt><big>(</big><a class="reference internal" href="#Freelist" title="Freelist">Freelist</a><em>&nbsp;fl</em>, <a class="reference internal" href="cbs.html#CBS" title="CBS">CBS</a><em>&nbsp;cbs</em><big>)</big><a class="headerlink" href="#FreelistFlushToCBS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Remove free address ranges from the free list <tt class="docutils literal"><span class="pre">fl</span></tt> and add them to
the Coalescing Block Structure <tt class="docutils literal"><span class="pre">cbs</span></tt>. Continue until a call to
<a class="reference internal" href="cbs.html#CBSInsert" title="CBSInsert"><tt class="xref c c-func docutils literal"><span class="pre">CBSInsert()</span></tt></a> fails, or until the free list is empty, whichever
happens first.</p>
<dl class="function">
<dt id="FreelistDescribe">
<a class="reference internal" href="type.html#Res" title="Res">Res</a> <tt class="descname">FreelistDescribe</tt><big>(</big><a class="reference internal" href="#Freelist" title="Freelist">Freelist</a><em>&nbsp;fl</em>, <a class="reference internal" href="../topic/plinth.html#mps_lib_FILE" title="mps_lib_FILE">mps_lib_FILE</a><em>&nbsp;*stream</em><big>)</big><a class="headerlink" href="#FreelistDescribe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><span class="target" id="design.mps.freelist.function.describe"></span><a class="mpstag reference internal" href="#design.mps.freelist.function.describe">.function.describe:</a> Print a textual representation of the free
list <tt class="docutils literal"><span class="pre">fl</span></tt> to the given stream, indicating the contiguous ranges in
order. It is provided for debugging purposes only.</p>
</div>
</div>
<div class="section" id="implementation">
<h2>5.6. Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.freelist.impl.list"></span><a class="mpstag reference internal" href="#design.mps.freelist.impl.list">.impl.list:</a> The isolated contiguous free address ranges are kept on
an address-ordered singly linked free list. (As in traditional
<tt class="xref c c-func docutils literal"><span class="pre">malloc()</span></tt> implementations.)</p>
<p><span class="target" id="design.mps.freelist.impl.block"></span><a class="mpstag reference internal" href="#design.mps.freelist.impl.block">.impl.block:</a> If the free address range is large enough to contain
an inline block descriptor consisting of two pointers, then the two
pointers stored are to the next free range in address order (or
<tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt> if there are no more ranges), and to the limit of current
free address range, in that order.</p>
<p><span class="target" id="design.mps.freelist.impl.grain"></span><a class="mpstag reference internal" href="#design.mps.freelist.impl.grain">.impl.grain:</a> Otherwise, the free address range must be large enough
to contain a single pointer. The pointer stored is to the next free
range in address order, or <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt> if there are no more ranges.</p>
<p><span class="target" id="design.mps.freelist.impl.tag"></span><a class="mpstag reference internal" href="#design.mps.freelist.impl.tag">.impl.tag:</a> Grains and blocks are distinguished by a one-bit tag in
the low bit of the first word (the one containing the pointer to the
next range). Grains have this bit set; blocks have this bit reset.</p>
<p><span class="target" id="design.mps.freelist.impl.invariant"></span><a class="mpstag reference internal" href="#design.mps.freelist.impl.invariant">.impl.invariant:</a> The ranges stored in the free list are <em>isolated</em>:
no two ranges are adjacent or overlapping.</p>
<p><span class="target" id="design.mps.freelist.impl.merge"></span><a class="mpstag reference internal" href="#design.mps.freelist.impl.merge">.impl.merge:</a> When a free address range is added to the free list,
it is merged with adjacent ranges so as to maintain
<a class="reference internal" href="#design.mps.freelist.impl.invariant">.impl.invariant</a>.</p>
<p><span class="target" id="design.mps.freelist.impl.rule.break"></span><a class="mpstag reference internal" href="#design.mps.freelist.impl.rule.break">.impl.rule.break:</a> The use of <tt class="xref c c-macro docutils literal"><span class="pre">NULL</span></tt> to mark the end of the list
violates the rule that exceptional values should not be used to
distinguish exeptional situations. This infraction allows the
implementation to meet <a class="reference internal" href="#design.mps.freelist.req.zero-overhead">.req.zero-overhead</a>. (There are other ways to
do this, such as using another tag to indicate the last block in the
list, but these would be more complicated.)</p>
</div>
<div class="section" id="opportunities-for-improvement">
<h2>5.7. Opportunities for improvement<a class="headerlink" href="#opportunities-for-improvement" title="Permalink to this headline">¶</a></h2>
<p><span class="target" id="design.mps.freelist.improve.length"></span><a class="mpstag reference internal" href="#design.mps.freelist.improve.length">.improve.length:</a> When iterating over the list, we could check that
the number of elements visited in the course of the iteration does not
exceed the recorded size of the list.</p>
<p><span class="target" id="design.mps.freelist.improve.maxsize"></span><a class="mpstag reference internal" href="#design.mps.freelist.improve.maxsize">.improve.maxsize:</a> We could maintain the maximum size of any range
on the list, and use that to make an early exit from
<a class="reference internal" href="#FreelistFindLargest" title="FreelistFindLargest"><tt class="xref c c-func docutils literal"><span class="pre">FreelistFindLargest()</span></tt></a>. It&#8217;s not clear that this would actually be
an improvement.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. Free list allocator</a><ul>
<li><a class="reference internal" href="#introduction">5.1. Introduction</a></li>
<li><a class="reference internal" href="#overview">5.2. Overview</a></li>
<li><a class="reference internal" href="#definitions">5.3. Definitions</a></li>
<li><a class="reference internal" href="#requirements">5.4. Requirements</a></li>
<li><a class="reference internal" href="#interface">5.5. Interface</a><ul>
<li><a class="reference internal" href="#types">5.5.1. Types</a></li>
<li><a class="reference internal" href="#functions">5.5.2. Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">5.6. Implementation</a></li>
<li><a class="reference internal" href="#opportunities-for-improvement">5.7. Opportunities for improvement</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="critical-path.html"
                        title="previous chapter">4. The critical path through the MPS</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="guide.hex.trans.html"
                        title="next chapter">6. Transliterating the alphabet into hexadecimal</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="guide.hex.trans.html" title="6. Transliterating the alphabet into hexadecimal"
             >next</a> |</li>
        <li class="right" >
          <a href="critical-path.html" title="4. The critical path through the MPS"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>