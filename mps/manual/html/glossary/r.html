

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Memory Management Glossary: R &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Memory Management Glossary" href="index.html" />
    <link rel="next" title="Memory Management Glossary: S" href="s.html" />
    <link rel="prev" title="Memory Management Glossary: Q" href="q.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="s.html" title="Memory Management Glossary: S"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="q.html" title="Memory Management Glossary: Q"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Memory Management Glossary</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="memory-management-glossary-r">
<span id="glossary-r"></span><h1>Memory Management Glossary: R<a class="headerlink" href="#memory-management-glossary-r" title="Permalink to this headline">Â¶</a></h1>
<p class="glossary-alphabet"><a class="reference internal" href="a.html#glossary-a"><em>A</em></a>
| <a class="reference internal" href="b.html#glossary-b"><em>B</em></a>
| <a class="reference internal" href="c.html#glossary-c"><em>C</em></a>
| <a class="reference internal" href="d.html#glossary-d"><em>D</em></a>
| <a class="reference internal" href="e.html#glossary-e"><em>E</em></a>
| <a class="reference internal" href="f.html#glossary-f"><em>F</em></a>
| <a class="reference internal" href="g.html#glossary-g"><em>G</em></a>
| <a class="reference internal" href="h.html#glossary-h"><em>H</em></a>
| <a class="reference internal" href="i.html#glossary-i"><em>I</em></a>
| J
| <a class="reference internal" href="k.html#glossary-k"><em>K</em></a>
| <a class="reference internal" href="l.html#glossary-l"><em>L</em></a>
| <a class="reference internal" href="m.html#glossary-m"><em>M</em></a>
| <a class="reference internal" href="n.html#glossary-n"><em>N</em></a>
| <a class="reference internal" href="o.html#glossary-o"><em>O</em></a>
| <a class="reference internal" href="p.html#glossary-p"><em>P</em></a>
| <a class="reference internal" href="q.html#glossary-q"><em>Q</em></a>
| <a class="reference internal" href="#glossary-r"><em>R</em></a>
| <a class="reference internal" href="s.html#glossary-s"><em>S</em></a>
| <a class="reference internal" href="t.html#glossary-t"><em>T</em></a>
| <a class="reference internal" href="u.html#glossary-u"><em>U</em></a>
| <a class="reference internal" href="v.html#glossary-v"><em>V</em></a>
| <a class="reference internal" href="w.html#glossary-w"><em>W</em></a>
| X
| Y
| <a class="reference internal" href="z.html#glossary-z"><em>Z</em></a></p>
<dl class="glossary docutils">
<dt id="term-ram">RAM</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>random access memory</em>.</p>
</div>
<p>RAM (random access memory) is a type of <a class="reference internal" href="p.html#term-physical-memory-2"><em class="xref std std-term">physical memory<sup>(2)</sup></em></a> that can be read from and written to.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="m.html#term-main-memory"><em class="xref std std-term">main memory</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#term-rom"><em class="xref std std-term">ROM</em></a>, <a class="reference internal" href="s.html#term-static-ram"><em class="xref std std-term">static RAM</em></a>, <a class="reference internal" href="d.html#term-dynamic-ram"><em class="xref std std-term">dynamic RAM</em></a>.</p>
</div>
</dd>
<dt id="term-random-access-memory">random access memory</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-ram"><em class="xref std std-term">RAM</em></a>.</p>
</div>
</dd>
<dt id="term-ramp-allocation">ramp allocation</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">An <a class="reference internal" href="a.html#term-allocation-pattern"><em class="xref std std-term">allocation pattern</em></a> indicating to the MPS that
most of the blocks allocated after the call to
<a class="reference internal" href="../topic/pattern.html#mps_ap_alloc_pattern_begin" title="mps_ap_alloc_pattern_begin"><tt class="xref c c-func docutils literal"><span class="pre">mps_ap_alloc_pattern_begin()</span></tt></a> are likely to be
<a class="reference internal" href="d.html#term-dead"><em class="xref std std-term">dead</em></a> by the time of the corresponding call to
<a class="reference internal" href="../topic/pattern.html#mps_ap_alloc_pattern_end" title="mps_ap_alloc_pattern_end"><tt class="xref c c-func docutils literal"><span class="pre">mps_ap_alloc_pattern_end()</span></tt></a>. See
<a class="reference internal" href="../topic/pattern.html#topic-pattern-ramp"><em>Ramp allocation</em></a>.</p>
</div>
</dd>
<dt id="term-rank">rank</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">A value of <a class="reference internal" href="../topic/root.html#mps_rank_t" title="mps_rank_t"><tt class="xref c c-type docutils literal"><span class="pre">mps_rank_t</span></tt></a> indicating whether a
<a class="reference internal" href="#term-root"><em class="xref std std-term">root</em></a> is <a class="reference internal" href="a.html#term-ambiguous-root"><em class="xref std std-term">ambiguous</em></a>
(<a class="reference internal" href="../topic/root.html#mps_rank_ambig" title="mps_rank_ambig"><tt class="xref c c-func docutils literal"><span class="pre">mps_rank_ambig()</span></tt></a>), <a class="reference internal" href="e.html#term-exact-root"><em class="xref std std-term">exact</em></a>
(<a class="reference internal" href="../topic/root.html#mps_rank_exact" title="mps_rank_exact"><tt class="xref c c-func docutils literal"><span class="pre">mps_rank_exact()</span></tt></a>) or <a class="reference internal" href="w.html#term-weak-root"><em class="xref std std-term">weak</em></a>
(<a class="reference internal" href="../topic/root.html#mps_rank_weak" title="mps_rank_weak"><tt class="xref c c-func docutils literal"><span class="pre">mps_rank_weak()</span></tt></a>).</p>
</div>
</dd>
<dt id="term-rash">rash</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">A <a class="reference internal" href="v.html#term-variety"><em class="xref std std-term">variety</em></a> in which no MPS functions <a class="reference internal" href="a.html#term-assertion"><em class="xref std std-term">assert</em></a> that their data structures are valid. Select
it by defining <a class="reference internal" href="../topic/error.html#CONFIG_VAR_RASH" title="CONFIG_VAR_RASH"><tt class="xref c c-macro docutils literal"><span class="pre">CONFIG_VAR_RASH</span></tt></a>. Compare
<a class="reference internal" href="c.html#term-cool"><em class="xref std std-term">cool</em></a> and <a class="reference internal" href="h.html#term-hot"><em class="xref std std-term">hot</em></a>.</p>
</div>
</dd>
<dt id="term-raw">raw</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="u.html#term-unwrapped"><em class="xref std std-term">unwrapped</em></a>.</p>
</div>
</dd>
<dt id="term-reachable">reachable</dt>
<dd><p class="first">An <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> is <em>reachable</em> if it is <a class="reference internal" href="#term-reference"><em class="xref std std-term">referred</em></a> to by a <a class="reference internal" href="#term-root"><em class="xref std std-term">root</em></a>, or is referred to by a
reachable object; that is, if it can be reached from the roots
by following <a class="reference internal" href="#term-reference"><em class="xref std std-term">references</em></a>.</p>
<p>Reachability is used as an approximation to <a class="reference internal" href="l.html#term-live"><em class="xref std std-term">liveness</em></a> in <a class="reference internal" href="t.html#term-tracing-garbage-collection"><em class="xref std std-term">tracing garbage collection</em></a>.</p>
<p>In <a class="reference internal" href="../mmref/lang.html#term-java"><em class="xref std std-term">Java</em></a>, the <a class="reference internal" href="#term-reference-object"><em class="xref std std-term">reference objects</em></a> together with
ordinary references and <a class="reference internal" href="f.html#term-finalization"><em class="xref std std-term">finalization</em></a> generate a
hierarchy of reachability that guides the <a class="reference internal" href="c.html#term-collector-1"><em class="xref std std-term">collector<sup>(1)</sup></em></a> on what to do when an object is about to <a class="reference internal" href="d.html#term-dead"><em class="xref std std-term">die</em></a>. There are six strengths:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="s.html#term-strongly-reachable"><em class="xref std std-term">strongly reachable</em></a>;</li>
<li><a class="reference internal" href="s.html#term-softly-reachable"><em class="xref std std-term">softly reachable</em></a>;</li>
<li><a class="reference internal" href="w.html#term-weakly-reachable"><em class="xref std std-term">weakly reachable</em></a>;</li>
<li><a class="reference internal" href="f.html#term-finalization"><em class="xref std std-term">finalizable</em></a>;</li>
<li><a class="reference internal" href="p.html#term-phantom-reachable"><em class="xref std std-term">phantom reachable</em></a>;</li>
<li><a class="reference internal" href="u.html#term-unreachable"><em class="xref std std-term">unreachable</em></a>.</li>
</ol>
<p>Basically, an object is only as reachable as the weakest link
in the strongest path from the roots. Note that the Java
specification&#8217;s description of the reachabilities is a bit
patchy, but that&#8217;s what it intends. It is unspecified where
Java Native Interface&#8217;s <em>weak global references</em> fit into
this.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="l.html#term-live"><em class="xref std std-term">live</em></a>.</p>
</div>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="u.html#term-unreachable"><em class="xref std std-term">unreachable</em></a>.</p>
</div>
<div class="admonition-related-link last admonition">
<p class="first admonition-title">Related links</p>
<p class="last"><a class="reference external" href="http://download.java.net/jdk8/docs/api/java/lang/ref/package-summary.html">Package java.lang.ref</a>, <a class="reference external" href="http://pawlan.com/monica/articles/refobjs/">Reference Objects and Garbage Collection</a>.</p>
</div>
</dd>
<dt id="term-read-barrier">read barrier</dt>
<dd><p class="first">A read <a class="reference internal" href="b.html#term-barrier-1"><em class="xref std std-term">barrier<sup>(1)</sup></em></a> is a block on reading from certain
<a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a> <a class="reference internal" href="m.html#term-memory-location"><em class="xref std std-term">locations</em></a> by
certain threads or processes.</p>
<div class="admonition-relevance-to-memory-management admonition">
<p class="first admonition-title">Relevance to memory management</p>
<p class="last">Read barriers are used for <a class="reference internal" href="i.html#term-incremental-garbage-collection"><em class="xref std std-term">incremental</em></a> or <a class="reference internal" href="p.html#term-parallel-garbage-collection"><em class="xref std std-term">concurrent</em></a> <a class="reference internal" href="g.html#term-garbage-collection"><em class="xref std std-term">garbage collection</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="w.html#term-write-barrier"><em class="xref std std-term">write barrier</em></a>.</p>
</div>
</dd>
<dt id="term-read-fault">read fault</dt>
<dd><p class="first">An exception which occurs when reading from an address in
<a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual memory</em></a>.</p>
<p>This is probably either a <a class="reference internal" href="p.html#term-page-fault"><em class="xref std std-term">page fault</em></a>, an
<a class="reference internal" href="i.html#term-invalid-page-fault"><em class="xref std std-term">invalid page fault</em></a> or a <a class="reference internal" href="p.html#term-protection-fault"><em class="xref std std-term">protection fault</em></a>.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="s.html#term-segmentation-violation"><em class="xref std std-term">segmentation violation</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="w.html#term-write-fault"><em class="xref std std-term">write fault</em></a>.</p>
</div>
</dd>
<dt id="term-read-only-memory">read-only memory</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-rom"><em class="xref std std-term">ROM</em></a>.</p>
</div>
</dd>
<dt id="term-real-memory-1">real memory<sup>(1)</sup></dt>
<dd><p class="first">A system with no <a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual memory</em></a> capability can be
said to have <em>real memory</em>.</p>
<div class="admonition-historical-note admonition">
<p class="first admonition-title">Historical note</p>
<p class="last">On older architectures, programs could only directly
access data in real memory. Where this was inefficient,
they had to store data on disk, and sometimes had
alternate portions of program image called <em>overlays</em>.</p>
</div>
<div class="admonition-opposite-term last admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual memory</em></a>.</p>
</div>
</dd>
<dt id="term-real-memory-2">real memory<sup>(2)</sup></dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="p.html#term-physical-memory-1"><em class="xref std std-term">physical memory<sup>(1)</sup></em></a>.</p>
</div>
</dd>
<dt id="term-reclaim">reclaim</dt>
<dd><p class="first"><em>Reclaiming</em> an <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> or the <a class="reference internal" href="m.html#term-memory-1"><em class="xref std std-term">memory<sup>(1)</sup></em></a>
occupied by it is making it available for reuse after the
object is no longer needed.</p>
<p>This word is usually used only in connection with
<a class="reference internal" href="a.html#term-automatic-memory-management"><em class="xref std std-term">automatic memory management</em></a>.</p>
<div class="admonition-similar-term last admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="#term-recycle"><em class="xref std std-term">recycle</em></a>.</p>
</div>
</dd>
<dt id="term-recycle">recycle</dt>
<dd><p class="first"><em>Recycling</em> <a class="reference internal" href="m.html#term-memory-1"><em class="xref std std-term">memory<sup>(1)</sup></em></a> means making it available for
reuse after it has been occupied by an <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> that is
no longer needed.</p>
<p>In simple cases, this might simply involve adding a
<a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a> <a class="reference internal" href="b.html#term-block"><em class="xref std std-term">block</em></a> to the <a class="reference internal" href="f.html#term-free-list"><em class="xref std std-term">free list</em></a>.
Another possibility is <a class="reference internal" href="u.html#term-unmapped"><em class="xref std std-term">unmapping</em></a> memory so
that the <a class="reference internal" href="b.html#term-backing-store"><em class="xref std std-term">backing store</em></a> can be allocated to another
process.</p>
<div class="admonition-similar-term last admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="#term-reclaim"><em class="xref std std-term">reclaim</em></a>.</p>
</div>
</dd>
<dt id="term-reference">reference</dt>
<dd><p class="first">In memory management, <em>a reference</em> is the general term for a
link from one <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> to another. Some programming
languages have more specific meanings for the term.</p>
<p>The terms &#8220;<a class="reference internal" href="p.html#term-pointer"><em class="xref std std-term">pointer</em></a>&#8221; and &#8220;reference&#8221; are often
interchangeable, but some programming languages differentiate
the two in subtle ways.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar terms</p>
<p class="last"><a class="reference internal" href="a.html#term-address"><em class="xref std std-term">address</em></a>, <a class="reference internal" href="p.html#term-pointer"><em class="xref std std-term">pointer</em></a>.</p>
</div>
<div class="admonition-in-the-mps last admonition">
<p class="first admonition-title">In the MPS</p>
<p>A reference is represented in the <a class="reference internal" href="../mmref/lang.html#term-c"><em class="xref std std-term">C</em></a> interface by a
value of type <a class="reference internal" href="../topic/interface.html#mps_addr_t" title="mps_addr_t"><tt class="xref c c-type docutils literal"><span class="pre">mps_addr_t</span></tt></a> (an alias for <tt class="docutils literal"><span class="pre">void</span>
<span class="pre">*</span></tt>) which points to a <a class="reference internal" href="m.html#term-memory-location"><em class="xref std std-term">memory location</em></a> within the
object (typically the base of the object, but for objects
with <a class="reference internal" href="i.html#term-in-band-header"><em class="xref std std-term">headers</em></a> this may not be the
case). The pointer returned by <a class="reference internal" href="../topic/allocation.html#mps_alloc" title="mps_alloc"><tt class="xref c c-func docutils literal"><span class="pre">mps_alloc()</span></tt></a> and
<a class="reference internal" href="../topic/allocation.html#mps_reserve" title="mps_reserve"><tt class="xref c c-func docutils literal"><span class="pre">mps_reserve()</span></tt></a> is a reference to the object
allocated.</p>
<p class="last">The <a class="reference internal" href="c.html#term-client-program"><em class="xref std std-term">client program</em></a> is free to represent references
as it chooses (for example, with <a class="reference internal" href="t.html#term-tagged-reference"><em class="xref std std-term">tags</em></a>), provided that during <a class="reference internal" href="s.html#term-scan"><em class="xref std std-term">scanning</em></a>
it is able to decode a reference from its representation
into the MPS interface representation and encode a
reference from the MPS into its representation.</p>
</div>
</dd>
<dt id="term-reference-counting">reference counting</dt>
<dd><p class="first">Reference counting systems perform <a class="reference internal" href="a.html#term-automatic-memory-management"><em class="xref std std-term">automatic memory
management</em></a> by keeping a count in each <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a>, usually
in a <a class="reference internal" href="i.html#term-in-band-header"><em class="xref std std-term">header</em></a>, of how many
<a class="reference internal" href="#term-reference"><em class="xref std std-term">references</em></a> there are to the object.
Objects to which there are no references cannot be accessed by
the <a class="reference internal" href="m.html#term-mutator"><em class="xref std std-term">mutator</em></a>; they are therefore <a class="reference internal" href="d.html#term-dead"><em class="xref std std-term">dead</em></a> and may
be <a class="reference internal" href="#term-reclaim"><em class="xref std std-term">reclaimed</em></a>.</p>
<p>The reference count is incremented for each new reference, and
is decremented if a reference is overwritten, or if the
referring object is recycled. If a reference count falls to
zero, then the object is no longer required and can be
recycled.</p>
<p>There are four main problems with simple reference counting:</p>
<ol class="arabic simple">
<li>The reference count field usually has to have limited size,
and the system therefore breaks down if the number of
possible references to an object is unbounded;</li>
<li>Reference counting involves an operation on every
modification of a pointer, which increases code size,
increases demand for <a class="reference internal" href="m.html#term-memory-bandwidth"><em class="xref std std-term">memory bandwidth</em></a>, decreases
<a class="reference internal" href="l.html#term-locality-of-reference"><em class="xref std std-term">locality of reference</em></a> and can be a serious
performance penalty (especially in multi-threaded
environments where reference count updates require
synchronization);</li>
<li>Every object needs to be slightly larger in order to store
the reference count;</li>
<li>If any objects are part of a <a class="reference internal" href="c.html#term-cyclic-data-structure"><em class="xref std std-term">cyclic data structure</em></a>
then they will always have a non-zero reference count, and
hence won&#8217;t be reclaimed when they are dead.</li>
</ol>
<div class="figure align-center">
<img alt="Diagram: Garbage with non-zero reference counts." src="../_images/refloop.svg" /><p class="caption">Garbage with non-zero reference counts.</p>
</div>
<p>Reference counting has the advantage that it can reclaim
objects promptly, and for this reason it is often used to
reclaim non-cyclic data structures in file systems, databases
and operating system kernels. When there is a possibility of
cyclic data structures, reference counting is sometimes used
together with a <a class="reference internal" href="t.html#term-tracing-garbage-collection"><em class="xref std std-term">tracing garbage collector</em></a> that runs infrequently. Such combinations
are generally less efficient than using a tracing collector by
itself, but the promptness of reference counting may be
important.</p>
<p>Pauses due to reference counting are typically fairly short,
and it may be appropriate as a form of <a class="reference internal" href="i.html#term-incremental-garbage-collection"><em class="xref std std-term">incremental
garbage collection</em></a>. But removing a single reference may cause
the recycling of a large number of objects at once, so it is
not suited to real-time systems where minimum pause times must
be guaranteed. There are more complex variations of the
technique that address this problem.</p>
<p>Reference counting is often used because it can be implemented
without any support from the language or compiler. In
<a class="reference internal" href="../mmref/lang.html#term-6"><em class="xref std std-term">C++</em></a> this can be encapsulated in a class, using a
<a class="reference internal" href="s.html#term-smart-pointer"><em class="xref std std-term">smart pointer</em></a>. However, it would normally be more
efficient to use a tracing garbage collector instead. The
performance of reference counting can be improved
substantially with compiler support, using refinements such as
<a class="reference internal" href="d.html#term-deferred-reference-counting"><em class="xref std std-term">deferred reference counting</em></a>, which has been
successfully used in <a class="reference internal" href="../mmref/lang.html#term-smalltalk"><em class="xref std std-term">Smalltalk</em></a> and other languages.</p>
<p>Despite the problems, reference counting is often used for
<a class="reference internal" href="d.html#term-distributed-garbage-collection"><em class="xref std std-term">distributed garbage collection</em></a>. This is because
refinements such as <a class="reference internal" href="w.html#term-weighted-reference-counting"><em class="xref std std-term">weighted reference counting</em></a>
require less inter-process communication than <a class="reference internal" href="t.html#term-trace"><em class="xref std std-term">tracing</em></a>.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="l.html#term-limited-field-reference-count"><em class="xref std std-term">limited-field reference count</em></a>, <a class="reference internal" href="o.html#term-one-bit-reference-count"><em class="xref std std-term">one-bit reference count</em></a>.</p>
</div>
</dd>
<dt id="term-reference-object">reference object</dt>
<dd><p class="first">In <a class="reference internal" href="../mmref/lang.html#term-java"><em class="xref std std-term">Java</em></a>, a <em>reference object</em>
(<tt class="docutils literal"><span class="pre">java.lang.ref.Reference</span></tt>) encapsulates a <a class="reference internal" href="#term-reference"><em class="xref std std-term">reference</em></a>
to some other object, in order to make the <a class="reference internal" href="g.html#term-garbage-collector"><em class="xref std std-term">garbage
collector</em></a> handle it specially. In particular, a Java program
can use this to detect when the referent becomes
<a class="reference internal" href="u.html#term-unreachable"><em class="xref std std-term">unreachable</em></a>.</p>
<p>Basically, the encapsulated reference is a <a class="reference internal" href="w.html#term-weak-reference-1"><em class="xref std std-term">weak
reference<sup>(1)</sup></em></a>; it will be cleared by the <a class="reference internal" href="c.html#term-collector-1"><em class="xref std std-term">collector<sup>(1)</sup></em></a> when all other references to the referent have
disappeared. However, in order to better control what happens
at the end of an object&#8217;s <a class="reference internal" href="l.html#term-lifetime"><em class="xref std std-term">lifetime</em></a>, Java 1.2 provides
three classes of reference objects, each with its own
peculiarities: <tt class="docutils literal"><span class="pre">SoftReference</span></tt>, <tt class="docutils literal"><span class="pre">WeakReference</span></tt>, and
<tt class="docutils literal"><span class="pre">PhantomReference</span></tt>. Each of these classes has its uses in
managing memory. The reference objects together with ordinary
references and <a class="reference internal" href="f.html#term-finalization"><em class="xref std std-term">finalization</em></a> generate a hierarchy of
<a class="reference internal" href="#term-reachable"><em class="xref std std-term">reachability</em></a> that guides the collector on
what to do when an object is about to <a class="reference internal" href="d.html#term-dead"><em class="xref std std-term">die</em></a>.</p>
<p>A reference object can be <em>registered</em> with a queue, and it
will be enqueued when the collector determines that the
referent is <a class="reference internal" href="s.html#term-softly-reachable"><em class="xref std std-term">softly</em></a>, <a class="reference internal" href="w.html#term-weakly-reachable"><em class="xref std std-term">weakly</em></a> or <a class="reference internal" href="p.html#term-phantom-reachable"><em class="xref std std-term">phantom reachable</em></a>, as the case
may be. A program can use these queues to perform some action
when an object is dying. This allows finer control than the
older <a class="reference internal" href="f.html#term-finalization"><em class="xref std std-term">finalization</em></a> mechanism alone.</p>
<div class="admonition-historical-note admonition">
<p class="first admonition-title">Historical note</p>
<p class="last">This feature was introduced in Java 1.2 (confusingly, part
of the Java 2 Platform).</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="s.html#term-soft-reference"><em class="xref std std-term">soft reference</em></a>, <a class="reference internal" href="w.html#term-weak-reference-2"><em class="xref std std-term">weak reference<sup>(2)</sup></em></a>, <a class="reference internal" href="p.html#term-phantom-reference"><em class="xref std std-term">phantom reference</em></a>.</p>
</div>
<div class="admonition-related-link admonition">
<p class="first admonition-title">Related link</p>
<p class="last"><a class="reference external" href="http://download.java.net/jdk8/docs/api/java/lang/ref/package-summary.html">Package java.lang.ref</a>, <a class="reference external" href="http://pawlan.com/monica/articles/refobjs/">Reference Objects and Garbage Collection</a>.</p>
</div>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#dbe93"><em>Dybvig et al. (1993)</em></a>.</p>
</div>
</dd>
<dt id="term-region-inference">region inference</dt>
<dd><p class="first">Region inference is a technique for determining when
<a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> become <a class="reference internal" href="d.html#term-dead"><em class="xref std std-term">dead</em></a> (even if they are
<a class="reference internal" href="#term-reachable"><em class="xref std std-term">reachable</em></a>) by a static analysis of the program.</p>
<p>Region inference infers a <em>region</em> for each object. When a
region dies, all the objects in it are known to be
<a class="reference internal" href="d.html#term-dead"><em class="xref std std-term">dead</em></a>, whether reachable or not. Regions obey a strict
<a class="reference internal" href="s.html#term-stack"><em class="xref std std-term">stack</em></a> discipline; that is, when a region dies, all
younger regions also die. In this way, region inference
occupies a middle ground between <a class="reference internal" href="s.html#term-stack-allocation"><em class="xref std std-term">stack allocation</em></a> and
<a class="reference internal" href="h.html#term-heap-allocation"><em class="xref std std-term">heap allocation</em></a>.</p>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#tt97"><em>Tofte &amp; Talpin (1997)</em></a>.</p>
</div>
</dd>
<dt id="term-register">register</dt>
<dd><p class="first">A <em>register</em> is a small unit of <a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a> that is
attached to a processor and accessible very quickly. Registers
typically form the highest level of a computer&#8217;s
<a class="reference internal" href="s.html#term-storage-hierarchy"><em class="xref std std-term">storage hierarchy</em></a>.</p>
<div class="admonition-relevance-to-memory-management admonition">
<p class="first admonition-title">Relevance to memory management</p>
<p class="last">In some programs (for example, those compiled by typical
<a class="reference internal" href="../mmref/lang.html#term-c"><em class="xref std std-term">C</em></a> or <a class="reference internal" href="../mmref/lang.html#term-6"><em class="xref std std-term">C++</em></a> compilers), a subset of the
registers is always accessible by the <a class="reference internal" href="m.html#term-mutator"><em class="xref std std-term">mutator</em></a> and
so forms a <a class="reference internal" href="#term-root"><em class="xref std std-term">root</em></a>.</p>
</div>
<div class="admonition-in-the-mps last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">The <a class="reference internal" href="s.html#term-scan-method"><em class="xref std std-term">scan method</em></a> for the root containing the
registers is hard to write (it depends on the operating
system, the processor architecture, and in some cases the
compiler), so the MPS provides (on its supported
platforms) the function <a class="reference internal" href="../topic/root.html#mps_stack_scan_ambig" title="mps_stack_scan_ambig"><tt class="xref c c-func docutils literal"><span class="pre">mps_stack_scan_ambig()</span></tt></a>.</p>
</div>
</dd>
<dt id="term-register-set-partitioning">register set partitioning</dt>
<dd><p class="first">Run-time systems for <a class="reference internal" href="g.html#term-garbage-collection"><em class="xref std std-term">garbage-collected</em></a> languages sometimes partition the set of machine
<a class="reference internal" href="#term-register"><em class="xref std std-term">registers</em></a> <em>a priori</em> into two categories:
those always <a class="reference internal" href="t.html#term-trace"><em class="xref std std-term">traced</em></a> and updated by the
<a class="reference internal" href="g.html#term-garbage-collector"><em class="xref std std-term">garbage collector</em></a> and those ignored by it.</p>
<p>The former are always maintained in a format understood by the
collector; the latter are never used to hold
<a class="reference internal" href="#term-reference"><em class="xref std std-term">references</em></a> to collectable <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a>. More
complicated schemes are also possible.</p>
<p>This partitioning provides a separation of concerns between
the compiler and the <a class="reference internal" href="g.html#term-garbage-collector"><em class="xref std std-term">garbage collector</em></a>. The compiler
can generate code that produces values the garbage collector
would not be able to handle (say, because they have no
<a class="reference internal" href="t.html#term-tag"><em class="xref std std-term">tags</em></a>), as long as those values are kept in the
ignored registers. The garbage collector can trust that the
registers it looks at always contain valid data, and can
perform <a class="reference internal" href="e.html#term-exact-garbage-collection"><em class="xref std std-term">exact garbage collection</em></a>.</p>
<p class="last">Register set partitioning increases the demand for registers
(<em>register pressure</em>), but may reduce the amount of
<a class="reference internal" href="b.html#term-boxed"><em class="xref std std-term">boxing</em></a> needed.</p>
</dd>
<dt id="term-relocation">relocation</dt>
<dd><p class="first"><em>Relocating</em> means moving data from one location to another
and updating all <a class="reference internal" href="#term-reference"><em class="xref std std-term">references</em></a>.</p>
<p>Relocation is often performed to avoid <a class="reference internal" href="e.html#term-external-fragmentation"><em class="xref std std-term">external fragmentation</em></a>.</p>
<p>Program loading sometimes relocates code and <a class="reference internal" href="s.html#term-static-allocation"><em class="xref std std-term">static</em></a> data.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="m.html#term-moving-garbage-collector"><em class="xref std std-term">moving</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="c.html#term-compaction"><em class="xref std std-term">compaction</em></a>, <a class="reference internal" href="m.html#term-moving-memory-manager"><em class="xref std std-term">moving memory manager</em></a>.</p>
</div>
</dd>
<dt id="term-remembered-set">remembered set</dt>
<dd><p class="first">A remembered set is the technique of keeping a separate list
of interesting <a class="reference internal" href="#term-reference"><em class="xref std std-term">references</em></a> between two sets
of <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a>, so you don&#8217;t have to find them by
<a class="reference internal" href="s.html#term-scan"><em class="xref std std-term">scanning</em></a>.</p>
<p>Many <a class="reference internal" href="m.html#term-memory-management"><em class="xref std std-term">memory management</em></a> algorithms depend on
partitioning the objects and require special handling for
references between partitions. Keeping track of such
references in a remembered set eliminates the need to scan the
originating partition to find them.</p>
<p>A typical use in <a class="reference internal" href="g.html#term-generational-garbage-collection"><em class="xref std std-term">generational garbage collection</em></a> is
remembering <a class="reference internal" href="#term-reference"><em class="xref std std-term">references</em></a> from an older
<a class="reference internal" href="g.html#term-generation"><em class="xref std std-term">generation</em></a> to a younger one.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="e.html#term-entry-table-2"><em class="xref std std-term">entry table<sup>(2)</sup></em></a>.</p>
</div>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publications</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#ungar84"><em>Ungar (1984)</em></a>, <a class="reference internal" href="../mmref/bib.html#jones12"><em>Jones et al. (2012)</em></a>.</p>
</div>
</dd>
<dt id="term-remote-reference">remote reference</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p>A <a class="reference internal" href="#term-reference"><em class="xref std std-term">reference</em></a> that logically belongs to a
<a class="reference internal" href="f.html#term-formatted-object"><em class="xref std std-term">formatted object</em></a> and so must be <a class="reference internal" href="f.html#term-fix"><em class="xref std std-term">fixed</em></a> when
the object is <a class="reference internal" href="s.html#term-scan"><em class="xref std std-term">scanned</em></a>, but which is not
stored within the block containing the object. (For
example, in an auxiliary table of some sort.)</p>
<p class="last">The MPS does not generally support remote references
because those references may be <a class="reference internal" href="p.html#term-protection"><em class="xref std std-term">protected</em></a> and so if <a class="reference internal" href="s.html#term-scan-method"><em class="xref std std-term">scan method</em></a> attempts to
<a class="reference internal" href="f.html#term-fix"><em class="xref std std-term">fix</em></a> them this will hit a <a class="reference internal" href="b.html#term-barrier-1"><em class="xref std std-term">barrier<sup>(1)</sup></em></a> and
cause a re-entrant call to the MPS.</p>
</div>
</dd>
<dt id="term-replicating-garbage-collector">replicating garbage collector</dt>
<dd><p class="first">A variant of <a class="reference internal" href="c.html#term-copying-garbage-collection"><em class="xref std std-term">copying garbage collection</em></a>, which does
not destroy the original <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> when making a copy.</p>
<p>This is useful in an <a class="reference internal" href="i.html#term-incremental-garbage-collection"><em class="xref std std-term">incremental</em></a> or <a class="reference internal" href="p.html#term-parallel-garbage-collection"><em class="xref std std-term">concurrent</em></a> <a class="reference internal" href="c.html#term-collector-1"><em class="xref std std-term">collector<sup>(1)</sup></em></a>, as no <a class="reference internal" href="#term-read-barrier"><em class="xref std std-term">read barrier</em></a>
is required; the <a class="reference internal" href="m.html#term-mutator"><em class="xref std std-term">mutator</em></a> can continue to use old
objects. The collector uses a <a class="reference internal" href="w.html#term-write-barrier"><em class="xref std std-term">write barrier</em></a> to
replicate the writes to the new copies.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="c.html#term-copying-garbage-collection"><em class="xref std std-term">copying garbage collection</em></a>, <a class="reference internal" href="b.html#term-broken-heart"><em class="xref std std-term">broken heart</em></a>.</p>
</div>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publications</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#noph92"><em>Nettles et al. (1992)</em></a>, <a class="reference internal" href="../mmref/bib.html#no93"><em>Nettles &amp; O&#8217;Toole (1993)</em></a>, <a class="reference internal" href="../mmref/bib.html#no93a"><em>Nettles &amp; O&#8217;Toole (1993a)</em></a>, <a class="reference internal" href="../mmref/bib.html#on94"><em>O&#8217;Toole &amp; Nettles (1994)</em></a>.</p>
</div>
</dd>
<dt id="term-reserved">reserved</dt>
<dd><p class="first">In a <a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual memory</em></a> system, it is usually possible
to hold range of <a class="reference internal" href="v.html#term-virtual-address"><em class="xref std std-term">virtual addresses</em></a>
<em>reserved</em> without making it <a class="reference internal" href="m.html#term-mapped"><em class="xref std std-term">mapped</em></a>.</p>
<p>Reserving addresses prevents other components of the program
using the same addresses, without consuming <a class="reference internal" href="s.html#term-swap-space"><em class="xref std std-term">swap
space</em></a>. This technique is often used in <a class="reference internal" href="b.html#term-bibop"><em class="xref std std-term">BIBOP</em></a> schemes,
where one might want to reserve a large amount of
<a class="reference internal" href="a.html#term-address-space"><em class="xref std std-term">address space</em></a> but only sparsely map it.</p>
<p>On some systems there are special calls for reserving; on
others one can create <a class="reference internal" href="m.html#term-mapping"><em class="xref std std-term">mappings</em></a> that don&#8217;t
need <a class="reference internal" href="b.html#term-backing-store"><em class="xref std std-term">backing store</em></a>. For example, on some Unix systems,
<tt class="docutils literal"><span class="pre">mmap</span> <span class="pre">/dev/zero</span></tt> with no access.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="m.html#term-mapping"><em class="xref std std-term">mapping</em></a>, <a class="reference internal" href="m.html#term-mmap"><em class="xref std std-term">mmap</em></a>.</p>
</div>
</dd>
<dt id="term-resident">resident</dt>
<dd><p class="first">In a <a class="reference internal" href="c.html#term-cache-2"><em class="xref std std-term">cache<sup>(2)</sup></em></a> system, that part of the cached storage
which currently has a copy in the cache is called <em>resident</em>.
Ideally, the <a class="reference internal" href="w.html#term-working-set"><em class="xref std std-term">working set</em></a> should be resident.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="c.html#term-cache-2"><em class="xref std std-term">cache<sup>(2)</sup></em></a>, <a class="reference internal" href="s.html#term-storage-hierarchy"><em class="xref std std-term">storage hierarchy</em></a>, <a class="reference internal" href="#term-resident-set"><em class="xref std std-term">resident set</em></a>.</p>
</div>
</dd>
<dt id="term-resident-set">resident set</dt>
<dd>In a <a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual memory</em></a> system, a process&#8217; resident
set is that part of a process&#8217; <a class="reference internal" href="a.html#term-address-space"><em class="xref std std-term">address space</em></a> which is
currently in <a class="reference internal" href="m.html#term-main-memory"><em class="xref std std-term">main memory</em></a>. If this does not include all
of the process&#8217; <a class="reference internal" href="w.html#term-working-set"><em class="xref std std-term">working set</em></a>, the system may
<a class="reference internal" href="t.html#term-thrash"><em class="xref std std-term">thrash</em></a>.</dd>
<dt id="term-result-code">result code</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">A value returned from an MPS function, represented by the
type <a class="reference internal" href="../topic/error.html#mps_res_t" title="mps_res_t"><tt class="xref c c-type docutils literal"><span class="pre">mps_res_t</span></tt></a>. The result code
<a class="reference internal" href="../topic/error.html#MPS_RES_OK" title="MPS_RES_OK"><tt class="xref c c-macro docutils literal"><span class="pre">MPS_RES_OK</span></tt></a> indicates success; other values
indicate errors. See <a class="reference internal" href="../topic/error.html#topic-error"><em>Error handing</em></a>.</p>
</div>
</dd>
<dt id="term-resurrection">resurrection</dt>
<dd><p class="first">An object is said to have been <em>resurrected</em> if it was
determined to be <a class="reference internal" href="f.html#term-finalization"><em class="xref std std-term">finalizable</em></a> by the
<a class="reference internal" href="g.html#term-garbage-collector"><em class="xref std std-term">garbage collector</em></a> (that is, the only thing keeping it
alive was the fact that it required finalization), but then a
new <a class="reference internal" href="s.html#term-strong-reference"><em class="xref std std-term">strong reference</em></a> was created to it.</p>
<p>This can happen via a <a class="reference internal" href="w.html#term-weak-reference-1"><em class="xref std std-term">weak reference<sup>(1)</sup></em></a> or by the
finalization procedure storing a permanent copy of its
reference to the object.</p>
<div class="admonition-in-the-mps last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">See <a class="reference internal" href="../topic/finalization.html#topic-finalization"><em>Finalization</em></a>.</p>
</div>
</dd>
<dt id="term-rom">ROM</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>read-only memory</em>.</p>
</div>
<p>ROM (read-only memory) is a type of <a class="reference internal" href="p.html#term-physical-memory-2"><em class="xref std std-term">physical memory<sup>(2)</sup></em></a> that can be read from, but not written to. The contents
of ROM are usually set in the factory.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#term-ram"><em class="xref std std-term">RAM</em></a>.</p>
</div>
</dd>
<dt id="term-root">root</dt>
<dd><p class="first">In <a class="reference internal" href="t.html#term-tracing-garbage-collection"><em class="xref std std-term">tracing garbage collection</em></a>, a root holds a
<a class="reference internal" href="#term-reference"><em class="xref std std-term">reference</em></a> or set of references to <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> that
are <em>a priori</em> <a class="reference internal" href="#term-reachable"><em class="xref std std-term">reachable</em></a>. The <a class="reference internal" href="#term-root-set"><em class="xref std std-term">root set</em></a> is used
as the starting point in determining all reachable data.</p>
<p>Roots basically comprise the references in the state of the
<a class="reference internal" href="m.html#term-mutator"><em class="xref std std-term">mutator</em></a>. Typical roots are global variables, other
<a class="reference internal" href="s.html#term-static-allocation"><em class="xref std std-term">static</em></a> data, and the
<a class="reference internal" href="c.html#term-control-stack"><em class="xref std std-term">control stack</em></a>.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="w.html#term-weak-root"><em class="xref std std-term">weak root</em></a>, <a class="reference internal" href="s.html#term-strong-root"><em class="xref std std-term">strong root</em></a>, <a class="reference internal" href="a.html#term-ambiguous-root"><em class="xref std std-term">ambiguous root</em></a>, <a class="reference internal" href="e.html#term-exact-root"><em class="xref std std-term">exact root</em></a>.</p>
</div>
<div class="admonition-in-the-mps last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">See <a class="reference internal" href="../topic/root.html#topic-root"><em>Roots</em></a>.</p>
</div>
</dd>
<dt id="term-root-description">root description</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">The <a class="reference internal" href="a.html#term-arena"><em class="xref std std-term">arena</em></a> uses root descriptions to find
<a class="reference internal" href="#term-reference"><em class="xref std std-term">references</em></a> within the <a class="reference internal" href="c.html#term-client-program"><em class="xref std std-term">client
program&#8217;s</em></a> <a class="reference internal" href="#term-root"><em class="xref std std-term">roots</em></a>. Root
descriptions belong to the type <a class="reference internal" href="../topic/root.html#mps_root_t" title="mps_root_t"><tt class="xref c c-type docutils literal"><span class="pre">mps_root_t</span></tt></a>.</p>
</div>
</dd>
<dt id="term-root-mode">root mode</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">A value of type <a class="reference internal" href="../topic/root.html#mps_rm_t" title="mps_rm_t"><tt class="xref c c-type docutils literal"><span class="pre">mps_rm_t</span></tt></a> describing whether a
<a class="reference internal" href="#term-root"><em class="xref std std-term">root</em></a> is <a class="reference internal" href="c.html#term-constant-root"><em class="xref std std-term">constant</em></a>,
<a class="reference internal" href="p.html#term-protectable-root"><em class="xref std std-term">protectable</em></a>, or both. The root
mode tells the MPS whether it may place a <a class="reference internal" href="b.html#term-barrier-1"><em class="xref std std-term">barrier<sup>(1)</sup></em></a> on the root.</p>
</div>
</dd>
<dt id="term-root-set">root set</dt>
<dd><p class="first">The <em>root set</em> is the collection of <a class="reference internal" href="#term-root"><em class="xref std std-term">roots</em></a> that
the <a class="reference internal" href="m.html#term-mutator"><em class="xref std std-term">mutator</em></a> declares to the <a class="reference internal" href="c.html#term-collector-2"><em class="xref std std-term">collector<sup>(2)</sup></em></a>.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="g.html#term-garbage-collection"><em class="xref std std-term">garbage collection</em></a>.</p>
</div>
</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="q.html"
                        title="previous chapter">Memory Management Glossary: Q</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="s.html"
                        title="next chapter">Memory Management Glossary: S</a></p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="s.html" title="Memory Management Glossary: S"
             >next</a> |</li>
        <li class="right" >
          <a href="q.html" title="Memory Management Glossary: Q"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Memory Management Glossary</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2012, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>