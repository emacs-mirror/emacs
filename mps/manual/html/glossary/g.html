

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Memory Management Glossary: G &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Memory Management Glossary" href="index.html" />
    <link rel="next" title="Memory Management Glossary: H" href="h.html" />
    <link rel="prev" title="Memory Management Glossary: F" href="f.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="h.html" title="Memory Management Glossary: H"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="f.html" title="Memory Management Glossary: F"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Memory Management Glossary</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="memory-management-glossary-g">
<span id="glossary-g"></span><h1>Memory Management Glossary: G<a class="headerlink" href="#memory-management-glossary-g" title="Permalink to this headline">Â¶</a></h1>
<p class="glossary-alphabet"><a class="reference internal" href="a.html#glossary-a"><em>A</em></a>
| <a class="reference internal" href="b.html#glossary-b"><em>B</em></a>
| <a class="reference internal" href="c.html#glossary-c"><em>C</em></a>
| <a class="reference internal" href="d.html#glossary-d"><em>D</em></a>
| <a class="reference internal" href="e.html#glossary-e"><em>E</em></a>
| <a class="reference internal" href="f.html#glossary-f"><em>F</em></a>
| <a class="reference internal" href="#glossary-g"><em>G</em></a>
| <a class="reference internal" href="h.html#glossary-h"><em>H</em></a>
| <a class="reference internal" href="i.html#glossary-i"><em>I</em></a>
| J
| <a class="reference internal" href="k.html#glossary-k"><em>K</em></a>
| <a class="reference internal" href="l.html#glossary-l"><em>L</em></a>
| <a class="reference internal" href="m.html#glossary-m"><em>M</em></a>
| <a class="reference internal" href="n.html#glossary-n"><em>N</em></a>
| <a class="reference internal" href="o.html#glossary-o"><em>O</em></a>
| <a class="reference internal" href="p.html#glossary-p"><em>P</em></a>
| <a class="reference internal" href="q.html#glossary-q"><em>Q</em></a>
| <a class="reference internal" href="r.html#glossary-r"><em>R</em></a>
| <a class="reference internal" href="s.html#glossary-s"><em>S</em></a>
| <a class="reference internal" href="t.html#glossary-t"><em>T</em></a>
| <a class="reference internal" href="u.html#glossary-u"><em>U</em></a>
| <a class="reference internal" href="v.html#glossary-v"><em>V</em></a>
| <a class="reference internal" href="w.html#glossary-w"><em>W</em></a>
| X
| Y
| <a class="reference internal" href="z.html#glossary-z"><em>Z</em></a></p>
<dl class="glossary docutils">
<dt id="term-garbage">garbage</dt>
<dd><p class="first">Garbage consists of <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> that are
<a class="reference internal" href="d.html#term-dead"><em class="xref std std-term">dead</em></a>.</p>
<p class="last">In <a class="reference internal" href="t.html#term-tracing-garbage-collection"><em class="xref std std-term">tracing garbage collection</em></a>, the term is sometimes
used to mean objects that are known to be dead; that is,
objects that are <a class="reference internal" href="u.html#term-unreachable"><em class="xref std std-term">unreachable</em></a>.</p>
</dd>
<dt id="term-garbage-collection">garbage collection</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>GC</em>.</p>
</div>
<p>Garbage collection (GC), also known as <em>automatic memory
management</em>, is the automatic <a class="reference internal" href="r.html#term-recycle"><em class="xref std std-term">recycling</em></a> of
<a class="reference internal" href="h.html#term-heap-allocation"><em class="xref std std-term">dynamically allocated</em></a> <a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a>. Garbage collection is performed by a <a class="reference internal" href="#term-garbage-collector"><em class="xref std std-term">garbage
collector</em></a> which recycles memory that it can prove will never
be used again. Systems and languages which use garbage
collection can be described as <em>garbage-collected</em>.</p>
<p>Garbage collection is a tried and tested memory management
technique that has been in use since its invention in the
1950s. It avoids the need for the programmer to
<a class="reference internal" href="f.html#term-free-1"><em class="xref std std-term">deallocate</em></a> memory <a class="reference internal" href="b.html#term-block"><em class="xref std std-term">blocks</em></a>
explicitly, thus avoiding a number of problems: <a class="reference internal" href="m.html#term-memory-leak"><em class="xref std std-term">memory
leaks</em></a>, <a class="reference internal" href="d.html#term-double-free"><em class="xref std std-term">double frees</em></a>, and <a class="reference internal" href="p.html#term-premature-free"><em class="xref std std-term">premature frees</em></a>. The
burden on the programmer is reduced by not having to
investigate such problems, thereby increasing productivity.</p>
<p>Garbage collection can also dramatically simplify programs,
chiefly by allowing modules to present cleaner interfaces to
each other: the management of object storage between modules
is unnecessary.</p>
<p>It is not possible, in general, for a <a class="reference internal" href="#term-garbage-collector"><em class="xref std std-term">garbage
collector</em></a> to determine exactly which <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> are
still <a class="reference internal" href="l.html#term-live"><em class="xref std std-term">live</em></a>. Even if it didn&#8217;t depend on future input,
there can be no general algorithm to prove that an object is
live (cf. the Halting Problem). All garbage collectors use
some efficient approximation to liveness. In <a class="reference internal" href="t.html#term-tracing-garbage-collection"><em class="xref std std-term">tracing
garbage collection</em></a>, the approximation is that an object can&#8217;t
be live unless it is <a class="reference internal" href="r.html#term-reachable"><em class="xref std std-term">reachable</em></a>. In <a class="reference internal" href="r.html#term-reference-counting"><em class="xref std std-term">reference
counting</em></a>, the approximation is that an object can&#8217;t be live
unless it is <a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">referenced</em></a>. Hybrid algorithms are also
possible. Often the term <em>garbage collection</em> is used narrowly
to mean only tracing garbage collection.</p>
<p>There is a large body of published work on particular and
general garbage collection algorithms.</p>
<div class="admonition-historical-note admonition">
<p class="first admonition-title">Historical note</p>
<p class="last">Garbage collection was first invented by John McCarthy in
1958 as part of the implementation of <a class="reference internal" href="../mmref/lang.html#term-lisp"><em class="xref std std-term">Lisp</em></a>.</p>
</div>
<p>Other significant languages offering garbage collection
include <a class="reference internal" href="../mmref/lang.html#term-java"><em class="xref std std-term">Java</em></a>, <a class="reference internal" href="../mmref/lang.html#term-ml"><em class="xref std std-term">ML</em></a>, <a class="reference internal" href="../mmref/lang.html#term-modula-3"><em class="xref std std-term">Modula-3</em></a>,
<a class="reference internal" href="../mmref/lang.html#term-perl"><em class="xref std std-term">Perl</em></a>, <a class="reference internal" href="../mmref/lang.html#term-prolog"><em class="xref std std-term">Prolog</em></a>, and <a class="reference internal" href="../mmref/lang.html#term-smalltalk"><em class="xref std std-term">Smalltalk</em></a>. Major
applications using garbage collection include Emacs and
AutoCAD; usually, you can&#8217;t tell whether an application does
or not, but these have extension languages that expose the
fact.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="a.html#term-automatic-memory-management"><em class="xref std std-term">automatic memory management</em></a>.</p>
</div>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="m.html#term-manual-memory-management"><em class="xref std std-term">manual memory management</em></a>.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="c.html#term-conservative-garbage-collection"><em class="xref std std-term">conservative garbage collection</em></a>, <a class="reference internal" href="c.html#term-copying-garbage-collection"><em class="xref std std-term">copying garbage collection</em></a>, <a class="reference internal" href="d.html#term-distributed-garbage-collection"><em class="xref std std-term">distributed garbage collection</em></a>, <a class="reference internal" href="#term-generational-garbage-collection"><em class="xref std std-term">generational garbage collection</em></a>, <a class="reference internal" href="i.html#term-incremental-garbage-collection"><em class="xref std std-term">incremental garbage collection</em></a>, <a class="reference internal" href="p.html#term-parallel-garbage-collection"><em class="xref std std-term">parallel garbage collection</em></a>.</p>
</div>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#mccarthy60"><em>McCarthy (1960)</em></a>.</p>
</div>
</dd>
<dt id="term-garbage-collector">garbage collector</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>collector</em>.</p>
</div>
<p>A (garbage) collector is (an implementation of) a
<a class="reference internal" href="#term-garbage-collection"><em class="xref std std-term">garbage collection</em></a> algorithm.</p>
<p class="last">This term is often used when referring to particular
implementations or algorithms, for example, &#8220;the
Boehm-Demers-Weiser <em>collector</em>&#8221;.</p>
</dd>
<dt id="term-gb">GB</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-gigabyte"><em class="xref std std-term">gigabyte</em></a>.</p>
</div>
</dd>
<dt id="term-gc">GC</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-garbage-collection"><em class="xref std std-term">garbage collection</em></a>.</p>
</div>
</dd>
<dt id="term-general-protection-fault">General Protection Fault</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>GPF</em>.</p>
</div>
<p class="last">A General Protection Fault on the Windows platforms is the
equivalent of a <a class="reference internal" href="s.html#term-segmentation-violation"><em class="xref std std-term">segmentation violation</em></a> on Unix.</p>
</dd>
<dt id="term-generation">generation</dt>
<dd><p class="first">A generation is a set of <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> of similar
<em>age</em>.</p>
<p>A <a class="reference internal" href="#term-generational-garbage-collection"><em class="xref std std-term">generational garbage collector</em></a> will typically divide the set of all objects into
generations, and <a class="reference internal" href="c.html#term-condemned-set"><em class="xref std std-term">condemn</em></a> all the
objects in a generation together. Rather than allowing whole
generations to age, the <a class="reference internal" href="c.html#term-collector-1"><em class="xref std std-term">collector<sup>(1)</sup></em></a> can
<a class="reference internal" href="p.html#term-promotion"><em class="xref std std-term">promote</em></a> objects into older generations as
they survive successive <a class="reference internal" href="c.html#term-collection-cycle"><em class="xref std std-term">collection cycles</em></a>.</p>
<p>New objects are usually allocated in the youngest or
<a class="reference internal" href="n.html#term-nursery-generation"><em class="xref std std-term">nursery generation</em></a>, but if we know that particular
objects will be long-lived, we might want to allocate them
directly in an older generation. Thus, more loosely, a
generation is a set of objects which have similar expected
<a class="reference internal" href="l.html#term-lifetime"><em class="xref std std-term">lifetimes</em></a>.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="b.html#term-bucket"><em class="xref std std-term">bucket</em></a>.</p>
</div>
<div class="admonition-in-the-mps last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">The <a class="reference internal" href="c.html#term-client-program"><em class="xref std std-term">client program</em></a> specifies the generational
structure of a <a class="reference internal" href="p.html#term-pool"><em class="xref std std-term">pool</em></a> using a <a class="reference internal" href="#term-generation-chain"><em class="xref std std-term">generation
chain</em></a>. See <a class="reference internal" href="../topic/collection.html#topic-collection"><em>Garbage collection</em></a>.</p>
</div>
</dd>
<dt id="term-generation-chain">generation chain</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">A data structure that specifies the structure of the
<a class="reference internal" href="#term-generation"><em class="xref std std-term">generations</em></a> in a <a class="reference internal" href="p.html#term-pool"><em class="xref std std-term">pool</em></a>. See
<a class="reference internal" href="../topic/collection.html#topic-collection"><em>Garbage collection</em></a>.</p>
</div>
</dd>
<dt id="term-generation-scavenging">generation scavenging</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-generational-garbage-collection"><em class="xref std std-term">generational garbage collection</em></a>.</p>
</div>
</dd>
<dt id="term-generational-garbage-collection">generational garbage collection</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>generation scavenging</em>.</p>
</div>
<p>Generational garbage collection is <a class="reference internal" href="t.html#term-tracing-garbage-collection"><em class="xref std std-term">tracing garbage
collection</em></a> that makes use of the <a class="reference internal" href="#term-generational-hypothesis"><em class="xref std std-term">generational
hypothesis</em></a>. <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">Objects</em></a> are gathered together in
<a class="reference internal" href="#term-generation"><em class="xref std std-term">generations</em></a>. New objects are allocated in
the <em>youngest</em> or <em>nursery</em> generation, and <a class="reference internal" href="p.html#term-promotion"><em class="xref std std-term">promoted</em></a> to <em>older</em> generations if they survive. Objects
in older generations are <a class="reference internal" href="c.html#term-condemned-set"><em class="xref std std-term">condemned</em></a>
less frequently, saving CPU time.</p>
<p>It is typically rare for an object to refer to a younger
object. Hence, objects in one generation typically have few
<a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">references</em></a> to objects in younger
generations. This means that the <a class="reference internal" href="s.html#term-scan"><em class="xref std std-term">scanning</em></a> of
old generations in the course of collecting younger
generations can be done more efficiently by means of
<a class="reference internal" href="r.html#term-remembered-set"><em class="xref std std-term">remembered sets</em></a>.</p>
<p>In some purely functional languages (that is, without update),
all references are backwards in time, in which case remembered
sets are unnecessary.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="r.html#term-remembered-set"><em class="xref std std-term">remembered set</em></a>.</p>
</div>
</dd>
<dt id="term-generational-hypothesis">generational hypothesis</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>infant mortality</em>.</p>
</div>
<p><em>Infant mortality</em> or <em>the generational hypothesis</em> is the
observation that, in most cases, young <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> are
much more likely to <a class="reference internal" href="d.html#term-dead"><em class="xref std std-term">die</em></a> than old objects.</p>
<p class="last">Strictly, the hypothesis is that the probability of death as a
function of age falls faster than exponential decay (inverse
hyper-exponential), but this strict condition is not always
required for techniques such as <a class="reference internal" href="#term-generational-garbage-collection"><em class="xref std std-term">generational garbage
collection</em></a> to be useful.</p>
</dd>
<dt id="term-gigabyte">gigabyte</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>GB</em>.</p>
</div>
<p>A gigabyte is 1024 <a class="reference internal" href="m.html#term-megabyte"><em class="xref std std-term">megabytes</em></a>, or 1073741824
<a class="reference internal" href="b.html#term-byte-1"><em class="xref std std-term">bytes<sup>(1)</sup></em></a>.</p>
<p class="last">See <a class="reference internal" href="b.html#term-byte-1"><em class="xref std std-term">byte<sup>(1)</sup></em></a> for general information on this and
related quantities.</p>
</dd>
<dt id="term-good-fit">good fit</dt>
<dd><p class="first">The class of <a class="reference internal" href="a.html#term-allocation-policy"><em class="xref std std-term">allocation policies</em></a> which approximate
<a class="reference internal" href="b.html#term-best-fit"><em class="xref std std-term">best fit</em></a>. Strict best fit may be costly to implement
(depending on the details of the <a class="reference internal" href="a.html#term-allocation-mechanism"><em class="xref std std-term">allocation
mechanism</em></a>), so some implementors approximate it, choosing a
block which is close in size to the allocation request.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="b.html#term-best-fit"><em class="xref std std-term">best fit</em></a>, <a class="reference internal" href="a.html#term-allocation-policy"><em class="xref std std-term">allocation policy</em></a>, <a class="reference internal" href="n.html#term-next-fit"><em class="xref std std-term">next fit</em></a>, <a class="reference internal" href="w.html#term-worst-fit"><em class="xref std std-term">worst fit</em></a>.</p>
</div>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#wil95"><em>Wilson et al. (1995)</em></a>.</p>
</div>
</dd>
<dt id="term-gpf">GPF</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-general-protection-fault"><em class="xref std std-term">General Protection Fault</em></a>.</p>
</div>
</dd>
<dt id="term-grain">grain</dt>
<dd><p class="first">The grain of a platform is the smallest <a class="reference internal" href="a.html#term-alignment"><em class="xref std std-term">alignment</em></a> that
is sufficient to accommodate all data accesses on that
platform. Often this is a <a class="reference internal" href="w.html#term-word"><em class="xref std std-term">word</em></a> or a small multiple of
a word. Double precision floating point numbers often have the
strictest alignment requirements.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="a.html#term-alignment"><em class="xref std std-term">alignment</em></a>, <a class="reference internal" href="w.html#term-word"><em class="xref std std-term">word</em></a>.</p>
</div>
</dd>
<dt id="term-graph">graph</dt>
<dd><p class="first">A graph is a set of <a class="reference internal" href="n.html#term-node"><em class="xref std std-term">nodes</em></a> together with a set
of <a class="reference internal" href="e.html#term-edge"><em class="xref std std-term">edges</em></a> connecting nodes.</p>
<p>If the edges have direction like arrows (for example,
<a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">references</em></a> in a graph of <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a>), then the
graph is said to be a <em>directed graph</em>.</p>
<div class="figure align-center">
<img alt="Ten white circles (the nodes of this graph), some of them joined by arrows (the edges of the graph). Most of the edges point in one direction, but one edge points both ways. Seven of the nodes are connected in one component, and three in another." src="../_images/graph.svg" /><p class="caption">Directed graph.</p>
</div>
<div class="admonition-relevance-to-memory-management last admonition">
<p class="first admonition-title">Relevance to memory management</p>
<p class="last">Graphs are used to model <a class="reference internal" href="r.html#term-reachable"><em class="xref std std-term">reachability</em></a>
for <a class="reference internal" href="t.html#term-tracing-garbage-collection"><em class="xref std std-term">tracing garbage collection</em></a>. The
<a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> are considered to form a graph, with the
nodes of the graph being the objects and the edges of the
graph being the references from one object to another.
Usually, there is a single, distinguished <a class="reference internal" href="r.html#term-root"><em class="xref std std-term">root</em></a> to
which the <a class="reference internal" href="m.html#term-mutator"><em class="xref std std-term">mutator</em></a> has <em>direct</em> access, and the
nodes strongly connected to it are the reachable modes.</p>
</div>
</dd>
<dt id="term-gray"><span id="term-grey"></span>gray<br />grey</dt>
<dd><p class="first">In a <a class="reference internal" href="t.html#term-tri-color-marking"><em class="xref std std-term">tri-color marking</em></a> scheme, gray <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a>
are objects that are proved or assumed (see
<a class="reference internal" href="#term-generational-garbage-collection"><em class="xref std std-term">generational</em></a> and
<a class="reference internal" href="c.html#term-condemned-set"><em class="xref std std-term">condemn</em></a>) to be <a class="reference internal" href="r.html#term-reachable"><em class="xref std std-term">reachable</em></a>, but
have not yet been <a class="reference internal" href="s.html#term-scan"><em class="xref std std-term">scanned</em></a>.</p>
<p>More precisely, gray objects have been noted reachable, but
must still be visited by the <a class="reference internal" href="c.html#term-collector-2"><em class="xref std std-term">collector<sup>(2)</sup></em></a> in order to
process their children.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="#term-gray-list"><em class="xref std std-term">gray list</em></a>.</p>
</div>
<div class="admonition-opposite-term last admonition">
<p class="first admonition-title">Opposite terms</p>
<p class="last"><a class="reference internal" href="b.html#term-black"><em class="xref std std-term">black</em></a>, <a class="reference internal" href="w.html#term-white"><em class="xref std std-term">white</em></a>.</p>
</div>
</dd>
<dt id="term-gray-list"><span id="term-grey-list"></span>gray list<br />grey list</dt>
<dd><p class="first">The gray list is the set of <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> that a
<a class="reference internal" href="t.html#term-tracing-garbage-collection"><em class="xref std std-term">tracing garbage collector</em></a>
has noted <a class="reference internal" href="r.html#term-reachable"><em class="xref std std-term">reachable</em></a>, but hasn&#8217;t <a class="reference internal" href="s.html#term-scan"><em class="xref std std-term">scanned</em></a>
yet.</p>
<p>The gray list is so called because it corresponds to the set
of <a class="reference internal" href="#term-gray"><em class="xref std std-term">gray</em></a> objects in the <a class="reference internal" href="t.html#term-tri-color-marking"><em class="xref std std-term">tri-color marking</em></a> model
of graph tracing. The gray list changes as the garbage
collector progresses.</p>
<p>Each gray object is <a class="reference internal" href="s.html#term-scan"><em class="xref std std-term">scanned</em></a>, and all
<a class="reference internal" href="w.html#term-white"><em class="xref std std-term">white</em></a> objects referred to by it become gray and are
added to the list. Scanning a gray object turns it
<a class="reference internal" href="b.html#term-black"><em class="xref std std-term">black</em></a>. When the gray list is empty, the tracing is
finished, and white objects may be <a class="reference internal" href="r.html#term-reclaim"><em class="xref std std-term">reclaimed</em></a>.</p>
<p>The representation of the gray list is a key part of garbage
collector design. The size of the list is potentially
proportional to the size of the <a class="reference internal" href="h.html#term-heap"><em class="xref std std-term">heap</em></a>, and the
operation of finding the next gray object to scan must be
cheap.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="c.html#term-cheney-scan"><em class="xref std std-term">Cheney scan</em></a>.</p>
</div>
</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="f.html"
                        title="previous chapter">Memory Management Glossary: F</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="h.html"
                        title="next chapter">Memory Management Glossary: H</a></p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="h.html" title="Memory Management Glossary: H"
             >next</a> |</li>
        <li class="right" >
          <a href="f.html" title="Memory Management Glossary: F"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Memory Management Glossary</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2012, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>