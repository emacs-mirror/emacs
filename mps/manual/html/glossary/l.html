

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Memory Management Glossary: L &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Memory Management Glossary" href="index.html" />
    <link rel="next" title="Memory Management Glossary: M" href="m.html" />
    <link rel="prev" title="Memory Management Glossary: K" href="k.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="m.html" title="Memory Management Glossary: M"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="k.html" title="Memory Management Glossary: K"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Memory Management Glossary</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="memory-management-glossary-l">
<span id="glossary-l"></span><h1>Memory Management Glossary: L<a class="headerlink" href="#memory-management-glossary-l" title="Permalink to this headline">Â¶</a></h1>
<p class="glossary-alphabet"><a class="reference internal" href="a.html#glossary-a"><em>A</em></a>
| <a class="reference internal" href="b.html#glossary-b"><em>B</em></a>
| <a class="reference internal" href="c.html#glossary-c"><em>C</em></a>
| <a class="reference internal" href="d.html#glossary-d"><em>D</em></a>
| <a class="reference internal" href="e.html#glossary-e"><em>E</em></a>
| <a class="reference internal" href="f.html#glossary-f"><em>F</em></a>
| <a class="reference internal" href="g.html#glossary-g"><em>G</em></a>
| <a class="reference internal" href="h.html#glossary-h"><em>H</em></a>
| <a class="reference internal" href="i.html#glossary-i"><em>I</em></a>
| J
| <a class="reference internal" href="k.html#glossary-k"><em>K</em></a>
| <a class="reference internal" href="#glossary-l"><em>L</em></a>
| <a class="reference internal" href="m.html#glossary-m"><em>M</em></a>
| <a class="reference internal" href="n.html#glossary-n"><em>N</em></a>
| <a class="reference internal" href="o.html#glossary-o"><em>O</em></a>
| <a class="reference internal" href="p.html#glossary-p"><em>P</em></a>
| <a class="reference internal" href="q.html#glossary-q"><em>Q</em></a>
| <a class="reference internal" href="r.html#glossary-r"><em>R</em></a>
| <a class="reference internal" href="s.html#glossary-s"><em>S</em></a>
| <a class="reference internal" href="t.html#glossary-t"><em>T</em></a>
| <a class="reference internal" href="u.html#glossary-u"><em>U</em></a>
| <a class="reference internal" href="v.html#glossary-v"><em>V</em></a>
| <a class="reference internal" href="w.html#glossary-w"><em>W</em></a>
| X
| Y
| <a class="reference internal" href="z.html#glossary-z"><em>Z</em></a></p>
<dl class="glossary docutils">
<dt id="term-large-object-area">large object area</dt>
<dd><p class="first">An <a class="reference internal" href="a.html#term-allocation-mechanism"><em class="xref std std-term">allocation mechanism</em></a> designed to optimize the
management of large <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> by separating
them from small ones.</p>
<p>Large objects, typically objects one or more orders of
magnitude larger than the <a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual memory</em></a>
<a class="reference internal" href="p.html#term-page"><em class="xref std std-term">page</em></a> of a platform, can be costly to <a class="reference internal" href="a.html#term-allocate"><em class="xref std std-term">allocate</em></a>,
initialize, and <a class="reference internal" href="r.html#term-recycle"><em class="xref std std-term">recycle</em></a>. By segregating those objects
into a separate area, they can be managed using specific
mechanisms that would be inefficient for smaller objects but
which can reduce the cost of manipulating large ones.</p>
<p>Some example mechanisms:</p>
<ol class="last arabic simple">
<li>In a <a class="reference internal" href="c.html#term-copying-garbage-collection"><em class="xref std std-term">copying collector</em></a>
large objects can be managed separately using a
<a class="reference internal" href="m.html#term-mark-sweep"><em class="xref std std-term">mark-and-sweep collector</em></a> to avoid
copying costs. See <a class="reference internal" href="../mmref/bib.html#ungar88"><em>Ungar (1988)</em></a>.</li>
<li>By aligning large objects on page boundaries, they can be
<a class="reference internal" href="c.html#term-compaction"><em class="xref std std-term">compacted</em></a> or copied by adjusting their
<a class="reference internal" href="m.html#term-mapping"><em class="xref std std-term">mapping</em></a> in <a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual memory</em></a>. See
<a class="reference internal" href="../mmref/bib.html#withington91"><em>Withington (1991)</em></a>.</li>
<li>Large objects may be split into a header and a body, where
the header is fixed size and the bulk of the object is in
the body. See <a class="reference internal" href="../mmref/bib.html#ungar88"><em>Ungar (1988)</em></a>.</li>
<li>By using a page-based <a class="reference internal" href="r.html#term-read-barrier"><em class="xref std std-term">read barrier</em></a>, large objects
can be initialized incrementally. For example, each page of
the large object is initialized to zero when it is first
read, rather than all at once at creation time.</li>
<li>In a copying collector, large objects can be copied
incrementally using a similar technique (the new copy is
initialized from the old copy). See <a class="reference internal" href="../mmref/bib.html#baker78"><em>Baker (1978)</em></a>.</li>
<li>Large objects are often <a class="reference internal" href="#term-leaf-object"><em class="xref std std-term">leaf objects</em></a>,
so do not need to be <a class="reference internal" href="s.html#term-scan"><em class="xref std std-term">scanned</em></a>, or are known
to have a fixed <a class="reference internal" href="f.html#term-format"><em class="xref std std-term">format</em></a> with only a few
<a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">references</em></a> so they can be scanned more
efficiently by a specialized scanner.</li>
<li>Large objects often have longer than average
<a class="reference internal" href="#term-lifetime"><em class="xref std std-term">lifetimes</em></a>, so are not allocated in a
<a class="reference internal" href="n.html#term-nursery-space"><em class="xref std std-term">nursery space</em></a> of a <a class="reference internal" href="g.html#term-generational-garbage-collection"><em class="xref std std-term">generational garbage
collector</em></a>.</li>
</ol>
</dd>
<dt id="term-large-page">large page</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="h.html#term-huge-page"><em class="xref std std-term">huge page</em></a>.</p>
</div>
</dd>
<dt id="term-leaf-object">leaf object</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>atomic object</em>.</p>
</div>
<p>A leaf object is an <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> that does not
<a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">reference</em></a> any other objects.</p>
<p>In a typed language, the compiler can often determine at
compile time that certain types can be represented as leaf
objects. Usually these types are either a <a class="reference internal" href="s.html#term-scalar-data-type"><em class="xref std std-term">scalar data
type</em></a> or a <a class="reference internal" href="v.html#term-vector-data-type"><em class="xref std std-term">vector data type</em></a> of scalars with bounded
magnitude.</p>
<div class="admonition-relevance-to-memory-management last admonition">
<p class="first admonition-title">Relevance to memory management</p>
<p class="last">If leaf objects can be identified, a <a class="reference internal" href="g.html#term-garbage-collector"><em class="xref std std-term">garbage
collector</em></a> can make certain optimizations: leaf objects do
not have to be <a class="reference internal" href="s.html#term-scan"><em class="xref std std-term">scanned</em></a> for references nor
are <a class="reference internal" href="b.html#term-barrier-1"><em class="xref std std-term">barrier<sup>(1)</sup></em></a> needed to detect
and maintain references in the object.</p>
</div>
</dd>
<dt id="term-leak">leak</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="m.html#term-memory-leak"><em class="xref std std-term">memory leak</em></a>.</p>
</div>
</dd>
<dt id="term-life">life</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-lifetime"><em class="xref std std-term">lifetime</em></a>.</p>
</div>
</dd>
<dt id="term-lifetime">lifetime</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>extent</em>, <em>life</em>.</p>
</div>
<p>The lifetime or extent of an <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> is the time for
which the object is <a class="reference internal" href="#term-live"><em class="xref std std-term">live</em></a>.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="d.html#term-dynamic-extent"><em class="xref std std-term">dynamic extent</em></a>, <a class="reference internal" href="i.html#term-indefinite-extent"><em class="xref std std-term">indefinite extent</em></a>.</p>
</div>
</dd>
<dt id="term-lifo-ordered-first-fit">LIFO-ordered first fit</dt>
<dd><p class="first">The <a class="reference internal" href="a.html#term-allocation-policy"><em class="xref std std-term">allocation policy</em></a> that always uses the
most-recently <a class="reference internal" href="f.html#term-free-1"><em class="xref std std-term">freed<sup>(1)</sup></em></a> suitable <a class="reference internal" href="f.html#term-free-block"><em class="xref std std-term">free block</em></a>.
Commonly implemented by pushing freed blocks on the front of a
<a class="reference internal" href="f.html#term-free-block-chain"><em class="xref std std-term">free block chain</em></a>, and then using <a class="reference internal" href="f.html#term-first-fit"><em class="xref std std-term">first fit</em></a>
allocation on this chain. <a class="reference internal" href="f.html#term-free-1"><em class="xref std std-term">free<sup>(1)</sup></em></a> can be very quick,
depending on the <a class="reference internal" href="c.html#term-coalesce"><em class="xref std std-term">coalescing</em></a> policy.</p>
<p>This policy may suffer from severe <a class="reference internal" href="f.html#term-fragmentation"><em class="xref std std-term">fragmentation</em></a> in
the presence of short-lived large objects of a single size. As
smaller objects are allocated, the free block chain fills up
with fragments a little smaller than the large object size.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="f.html#term-first-fit"><em class="xref std std-term">first fit</em></a>, <a class="reference internal" href="f.html#term-fifo-ordered-first-fit"><em class="xref std std-term">FIFO-ordered first fit</em></a>, <a class="reference internal" href="a.html#term-address-ordered-first-fit"><em class="xref std std-term">address-ordered first fit</em></a>.</p>
</div>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#wil95"><em>Wilson et al. (1995)</em></a>.</p>
</div>
</dd>
<dt id="term-limited-field-reference-count">limited-field reference count</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>sticky reference count</em>.</p>
</div>
<p>A <a class="reference internal" href="r.html#term-reference-counting"><em class="xref std std-term">reference counting</em></a> technique whereby the field used
to store the number of <a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">references</em></a> to an
<a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> has a limited size. In particular, the field is
not large enough to represent the maximum possible number of
references to an object.</p>
<p>Using the observation that most objects are not referenced a
great number of times, some systems that use reference counts
only store the count accurately up to a certain maximum value.
If an object has more references than the maximum then the
count &#8220;sticks&#8221; at the maximum and is never decremented. Such
objects are expected to be rare, but their <a class="reference internal" href="m.html#term-memory-1"><em class="xref std std-term">memory<sup>(1)</sup></em></a>
can never be <a class="reference internal" href="r.html#term-reclaim"><em class="xref std std-term">reclaimed</em></a> using reference counting. A
separate (infrequently run) <a class="reference internal" href="t.html#term-tracing-garbage-collection"><em class="xref std std-term">tracing garbage collector</em></a> is often employed to reclaim
this storage.</p>
<p class="last">A degenerate form of limited-field reference counting is
<a class="reference internal" href="o.html#term-one-bit-reference-count"><em class="xref std std-term">one-bit reference counting</em></a>
where an object is considered to be referenced either exactly
once or many times.</p>
</dd>
<dt id="term-linear-addressing">linear addressing</dt>
<dd><p class="first">In linear addressing, <a class="reference internal" href="a.html#term-address"><em class="xref std std-term">addresses</em></a> form a
single, continuous <a class="reference internal" href="a.html#term-address-space"><em class="xref std std-term">address space</em></a>. This term is used
mostly in opposition to <a class="reference internal" href="s.html#term-segmented-addressing"><em class="xref std std-term">segmented addressing</em></a>.</p>
<div class="admonition-opposite-term last admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="s.html#term-segmented-addressing"><em class="xref std std-term">segmented addressing</em></a>.</p>
</div>
</dd>
<dt id="term-live">live</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>alive</em>, <em>active</em>.</p>
</div>
<p><a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">Memory<sup>(2)</sup></em></a> or an <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> is live if the program
will read from it in future. The term is often used more
broadly to mean <a class="reference internal" href="r.html#term-reachable"><em class="xref std std-term">reachable</em></a>.</p>
<p>It is not possible, in general, for <a class="reference internal" href="g.html#term-garbage-collector"><em class="xref std std-term">garbage collectors</em></a>
to determine exactly which <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> are still live.
Instead, they use some approximation to detect objects that
are provably <a class="reference internal" href="d.html#term-dead"><em class="xref std std-term">dead</em></a>, such as those that are not
<a class="reference internal" href="r.html#term-reachable"><em class="xref std std-term">reachable</em></a>.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="r.html#term-reachable"><em class="xref std std-term">reachable</em></a>.</p>
</div>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="d.html#term-dead"><em class="xref std std-term">dead</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="u.html#term-undead"><em class="xref std std-term">undead</em></a>.</p>
</div>
</dd>
<dt id="term-load">load</dt>
<dd><p class="first">To transfer data from <a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a> to a processor&#8217;s
<a class="reference internal" href="r.html#term-register"><em class="xref std std-term">registers</em></a>.</p>
<p>Load can also be used in the more general sense of moving data
from a part of the <a class="reference internal" href="m.html#term-memory-hierarchy"><em class="xref std std-term">memory hierarchy</em></a> that is slow to
access to one that is fast to access (For example, &#8220;it takes
about 3 ms for the <a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual memory</em></a> system to load a
<a class="reference internal" href="p.html#term-page"><em class="xref std std-term">page</em></a> from disk on this system&#8221;). When used in this
sense, the qualified term <a class="reference internal" href="c.html#term-cache-2"><em class="xref std std-term">cache<sup>(2)</sup></em></a> load is common.</p>
<p><tt class="docutils literal"><span class="pre">LOAD</span></tt> (or an abbreviation) is also commonly used in many
processor architectures as the mnemonic name for the machine
code instructions that are used primarily to make data
accessible to the CPU (by loading the data into registers
usually). In RISC architectures it is common for the load
instructions to be the only means of making data accessible to
the CPU; in CISC architectures it is common for a wide variety
of instructions to implicitly or explicitly load data from
memory.</p>
<div class="admonition-opposite-term last admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="s.html#term-store-1"><em class="xref std std-term">store<sup>(1)</sup></em></a>.</p>
</div>
</dd>
<dt id="term-locality-of-reference">locality of reference</dt>
<dd><p class="first">Locality of reference is the extent to which successive
accesses of nearby <a class="reference internal" href="m.html#term-memory-1"><em class="xref std std-term">memory<sup>(1)</sup></em></a> <a class="reference internal" href="m.html#term-memory-location"><em class="xref std std-term">locations</em></a> are nearby in time; for example, a program that
reads all the elements of a contiguous array in turn or that
repeatedly uses the same memory variable has good locality of
reference.</p>
<p>Good locality of reference interacts well with <a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual
memory</em></a> and <a class="reference internal" href="c.html#term-cache-1"><em class="xref std std-term">memory caches</em></a>, as it reduces
the <a class="reference internal" href="w.html#term-working-set"><em class="xref std std-term">working set</em></a> and improves the <a class="reference internal" href="h.html#term-hit-rate"><em class="xref std std-term">hit rate</em></a>.</p>
<p>There are a number of specialized senses of locality of
reference in certain fields such as distributed systems; these
are not covered in depth here.</p>
<div class="admonition-relevance-to-memory-management admonition">
<p class="first admonition-title">Relevance to memory management</p>
<p class="last">A <a class="reference internal" href="m.html#term-mutator"><em class="xref std std-term">mutator</em></a> may exhibit predictable properties such
as accessing in turn <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> which were
<a class="reference internal" href="a.html#term-allocate"><em class="xref std std-term">allocated</em></a> in turn, or accessing in turn objects
which have <a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">references</em></a> to each other. An
intelligent <a class="reference internal" href="a.html#term-allocator"><em class="xref std std-term">allocator</em></a> or <a class="reference internal" href="c.html#term-copying-garbage-collection"><em class="xref std std-term">copying garbage
collector</em></a> can use this
observation to improve locality of reference.</p>
</div>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publications</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#gzh93"><em>Grunwald et al. (1993)</em></a>, <a class="reference internal" href="../mmref/bib.html#wlm92"><em>Wilson et al. (1992)</em></a>.</p>
</div>
</dd>
<dt id="term-location">location</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="m.html#term-memory-location"><em class="xref std std-term">memory location</em></a>.</p>
</div>
</dd>
<dt id="term-location-dependency">location dependency</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">A <em>location dependency</em> records the fact that the
<a class="reference internal" href="c.html#term-client-program"><em class="xref std std-term">client program</em></a> depends on the bit patterns of some
<a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">references</em></a> (and not merely on the
identity of the <a class="reference internal" href="b.html#term-block"><em class="xref std std-term">block</em></a> to which the reference
refers), and provides a function
(<a class="reference internal" href="../topic/location.html#mps_ld_isstale" title="mps_ld_isstale"><tt class="xref c c-func docutils literal"><span class="pre">mps_ld_isstale()</span></tt></a>) to find out whether any of
these references have been changed because a block has
been <a class="reference internal" href="m.html#term-moving-garbage-collector"><em class="xref std std-term">moved</em></a>. See
<a class="reference internal" href="../topic/location.html#topic-location"><em>Location dependency</em></a>.</p>
</div>
</dd>
<dt id="term-lock-free">lock free</dt>
<dd>A multi-threaded program is <em>lock free</em> if all schedules for
the threads make progress: in particular, no schedule leads to
deadlock. This is most easily implemented by avoiding taking
locks.</dd>
<dt id="term-logical-address">logical address</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="v.html#term-virtual-address"><em class="xref std std-term">virtual address</em></a>.</p>
</div>
</dd>
<dt id="term-longword">longword</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="d.html#term-doubleword"><em class="xref std std-term">doubleword</em></a>.</p>
</div>
</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="k.html"
                        title="previous chapter">Memory Management Glossary: K</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="m.html"
                        title="next chapter">Memory Management Glossary: M</a></p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="m.html" title="Memory Management Glossary: M"
             >next</a> |</li>
        <li class="right" >
          <a href="k.html" title="Memory Management Glossary: K"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Memory Management Glossary</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2012, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>