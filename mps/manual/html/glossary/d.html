

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Memory Management Glossary: D &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Memory Management Glossary" href="index.html" />
    <link rel="next" title="Memory Management Glossary: E" href="e.html" />
    <link rel="prev" title="Memory Management Glossary: C" href="c.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="e.html" title="Memory Management Glossary: E"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="c.html" title="Memory Management Glossary: C"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Memory Management Glossary</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="memory-management-glossary-d">
<span id="glossary-d"></span><h1>Memory Management Glossary: D<a class="headerlink" href="#memory-management-glossary-d" title="Permalink to this headline">Â¶</a></h1>
<p class="glossary-alphabet"><a class="reference internal" href="a.html#glossary-a"><em>A</em></a>
| <a class="reference internal" href="b.html#glossary-b"><em>B</em></a>
| <a class="reference internal" href="c.html#glossary-c"><em>C</em></a>
| <a class="reference internal" href="#glossary-d"><em>D</em></a>
| <a class="reference internal" href="e.html#glossary-e"><em>E</em></a>
| <a class="reference internal" href="f.html#glossary-f"><em>F</em></a>
| <a class="reference internal" href="g.html#glossary-g"><em>G</em></a>
| <a class="reference internal" href="h.html#glossary-h"><em>H</em></a>
| <a class="reference internal" href="i.html#glossary-i"><em>I</em></a>
| J
| <a class="reference internal" href="k.html#glossary-k"><em>K</em></a>
| <a class="reference internal" href="l.html#glossary-l"><em>L</em></a>
| <a class="reference internal" href="m.html#glossary-m"><em>M</em></a>
| <a class="reference internal" href="n.html#glossary-n"><em>N</em></a>
| <a class="reference internal" href="o.html#glossary-o"><em>O</em></a>
| <a class="reference internal" href="p.html#glossary-p"><em>P</em></a>
| <a class="reference internal" href="q.html#glossary-q"><em>Q</em></a>
| <a class="reference internal" href="r.html#glossary-r"><em>R</em></a>
| <a class="reference internal" href="s.html#glossary-s"><em>S</em></a>
| <a class="reference internal" href="t.html#glossary-t"><em>T</em></a>
| <a class="reference internal" href="u.html#glossary-u"><em>U</em></a>
| <a class="reference internal" href="v.html#glossary-v"><em>V</em></a>
| <a class="reference internal" href="w.html#glossary-w"><em>W</em></a>
| X
| Y
| <a class="reference internal" href="z.html#glossary-z"><em>Z</em></a></p>
<dl class="glossary docutils">
<dt id="term-dangling-pointer">dangling pointer</dt>
<dd><p class="first">A dangling <a class="reference internal" href="p.html#term-pointer"><em class="xref std std-term">pointer</em></a> is a surviving <a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">reference</em></a> to
an <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> that no longer exists at that
<a class="reference internal" href="a.html#term-address"><em class="xref std std-term">address</em></a>.</p>
<p>In <a class="reference internal" href="m.html#term-manual-memory-management"><em class="xref std std-term">manual memory management</em></a>, dangling pointers
typically arise from one of:</p>
<ol class="arabic simple">
<li>A <a class="reference internal" href="p.html#term-premature-free"><em class="xref std std-term">premature free</em></a>, where an object is <a class="reference internal" href="f.html#term-free-1"><em class="xref std std-term">freed<sup>(1)</sup></em></a>, but a reference is retained;</li>
<li>Retaining a reference to a <a class="reference internal" href="s.html#term-stack-allocation"><em class="xref std std-term">stack-allocated</em></a> object, after the relevant <a class="reference internal" href="s.html#term-stack-frame"><em class="xref std std-term">stack frame</em></a>
has been popped.</li>
</ol>
<p class="last">Dangling pointers can occur under <a class="reference internal" href="a.html#term-automatic-memory-management"><em class="xref std std-term">automatic memory
management</em></a>, because of a <a class="reference internal" href="g.html#term-garbage-collection"><em class="xref std std-term">garbage collection</em></a> bug (such
as premature collection, or <a class="reference internal" href="m.html#term-moving-garbage-collector"><em class="xref std std-term">moving</em></a> without updating all <a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">references</em></a>), but this
is much rarer because garbage collection code is usually a
single common core of reused code in which these bugs can be
fixed systematically.</p>
</dd>
<dt id="term-data-stack">data stack</dt>
<dd><p class="first">A <a class="reference internal" href="s.html#term-stack"><em class="xref std std-term">stack</em></a> used to manage the storage of
<a class="reference internal" href="s.html#term-stack-allocation"><em class="xref std std-term">stack-allocated</em></a> <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a>,
other than <a class="reference internal" href="a.html#term-activation-record"><em class="xref std std-term">activation records</em></a>, often under program
control.</p>
<p>Because of the limitations that may be imposed on the
<a class="reference internal" href="c.html#term-control-stack"><em class="xref std std-term">control stack</em></a>, or to support stack-like semantics for
certain data structures, some language implementations manage
additional data stacks in software for storing objects that
have <a class="reference internal" href="#term-dynamic-extent"><em class="xref std std-term">dynamic extent</em></a> but that do not fit within the
constraints of the control stack.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="c.html#term-control-stack"><em class="xref std std-term">control stack</em></a>.</p>
</div>
</dd>
<dt id="term-dead">dead</dt>
<dd><p class="first">An <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> is dead if it is not <a class="reference internal" href="l.html#term-live"><em class="xref std std-term">live</em></a>; that is,
when the <a class="reference internal" href="m.html#term-mutator"><em class="xref std std-term">mutator</em></a> cannot reach any state in which it
accesses the object.</p>
<p>It is not possible, in general, for <a class="reference internal" href="g.html#term-garbage-collector"><em class="xref std std-term">garbage collectors</em></a>
to determine exactly which <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> are dead and which
are live. Instead, they use some approximation to detect
objects that are provably dead, such as those that are
<a class="reference internal" href="u.html#term-unreachable"><em class="xref std std-term">unreachable</em></a>.</p>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="l.html#term-live"><em class="xref std std-term">live</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="g.html#term-garbage"><em class="xref std std-term">garbage</em></a>, <a class="reference internal" href="u.html#term-undead"><em class="xref std std-term">undead</em></a>, <a class="reference internal" href="f.html#term-free-3"><em class="xref std std-term">free<sup>(3)</sup></em></a>.</p>
</div>
</dd>
<dt id="term-deallocate">deallocate</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="f.html#term-free-1"><em class="xref std std-term">free<sup>(1)</sup></em></a>.</p>
</div>
</dd>
<dt id="term-debugging-pool">debugging pool</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">A <a class="reference internal" href="p.html#term-pool"><em class="xref std std-term">pool</em></a> that performs extra checking in order to
find errors in the <a class="reference internal" href="c.html#term-client-program"><em class="xref std std-term">client program</em></a>. It uses
<a class="reference internal" href="f.html#term-fencepost"><em class="xref std std-term">fenceposts</em></a> to detect
<a class="reference internal" href="o.html#term-overwriting-error"><em class="xref std std-term">overwriting errors</em></a> and it
writes patterns over reclaimed blocks in order to detect
<a class="reference internal" href="p.html#term-premature-free"><em class="xref std std-term">use after free</em></a> or missing
references during <a class="reference internal" href="s.html#term-scan"><em class="xref std std-term">scanning</em></a>.</p>
</div>
</dd>
<dt id="term-deferred-coalescing">deferred coalescing</dt>
<dd><p class="first">Deferred coalescing is a policy which <a class="reference internal" href="c.html#term-coalesce"><em class="xref std std-term">coalesces</em></a>
<a class="reference internal" href="f.html#term-free-block"><em class="xref std std-term">free blocks</em></a> some time after the blocks are freed, as
opposed to coalescing free blocks immediately as they are
freed.</p>
<p>Adjacent free blocks can be coalesced to form larger free
blocks; deferred coalescing is a catch-all for policies which
perform this coalescing sometime after the blocks were freed.</p>
<p class="last">Given this rather flexible definition there are a number of
choices for when to coalesce: as the <a class="reference internal" href="f.html#term-free-list"><em class="xref std std-term">free list</em></a> is
traversed during allocation, when the allocation cannot be
satisfied from the free list, periodically, and so on. In
addition there are choices to be made regarding how much
coalescing to perform at any one time.</p>
</dd>
<dt id="term-deferred-reference-counting">deferred reference counting</dt>
<dd><p class="first">Deferred <a class="reference internal" href="r.html#term-reference-counting"><em class="xref std std-term">reference counting</em></a> reduces the cost of
maintaining reference counts by avoiding adjustments when the
<a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">reference</em></a> is stored on the <a class="reference internal" href="s.html#term-stack"><em class="xref std std-term">stack</em></a>.</p>
<p>On many systems, the majority of stores are made into local
variables, which are kept on the stack. Deferred reference
counting leaves those out and counts only references stored in
<a class="reference internal" href="h.html#term-heap"><em class="xref std std-term">heap</em></a> objects. This requires compiler support, but can
lead to substantial performance improvements.</p>
<p><a class="reference internal" href="o.html#term-object"><em class="xref std std-term">Objects</em></a> cannot be <a class="reference internal" href="r.html#term-reclaim"><em class="xref std std-term">reclaimed</em></a> as soon
as their reference count becomes zero, because there might
still be references to them from the stack. Such objects are
added to a <a class="reference internal" href="z.html#term-zero-count-table"><em class="xref std std-term">zero count table</em></a> (ZCT) instead. If a
reference to an object with a count of zero is stored into the
heap, then the object is removed from the ZCT. Periodically
the stack is <a class="reference internal" href="s.html#term-scan"><em class="xref std std-term">scanned</em></a>, and any objects in the
ZCT which were not referenced from the stack are reclaimed.</p>
<p>Deferred reference counting has been used successfully with
several languages, notably <a class="reference internal" href="../mmref/lang.html#term-smalltalk"><em class="xref std std-term">Smalltalk</em></a>. However, since
it fails to collect objects with <a class="reference internal" href="c.html#term-cyclic-data-structure"><em class="xref std std-term">cyclic</em></a> references, it is often used alongside a
<a class="reference internal" href="t.html#term-tracing-garbage-collection"><em class="xref std std-term">tracing garbage collector</em></a>.</p>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#db76"><em>Deutsch &amp; Bobrow (1976)</em></a>.</p>
</div>
</dd>
<dt id="term-dependent-object">dependent object</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">In <a class="reference internal" href="../pool/awl.html#pool-awl"><em>AWL (Automatic Weak Linked)</em></a>, each object in the pool can have a
<em>dependent object</em>. While scanning an object, the MPS
ensures that the dependent object is unprotected so that
it can be updated. This feature supports the
implementation of <a class="reference internal" href="w.html#term-weak-key-hash-table"><em class="xref std std-term">weak-key</em></a>
and <a class="reference internal" href="w.html#term-weak-value-hash-table"><em class="xref std std-term">weak-value hash tables</em></a>. See
<a class="reference internal" href="../pool/awl.html#pool-awl-dependent"><em>Dependent objects</em></a>.</p>
</div>
</dd>
<dt id="term-derived-pointer">derived pointer</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="i.html#term-interior-pointer"><em class="xref std std-term">interior pointer</em></a>.</p>
</div>
</dd>
<dt id="term-derived-type">derived type</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">In the MPS interface, a <em>derived type</em> is a type that is
neither an <a class="reference internal" href="o.html#term-opaque-type"><em class="xref std std-term">opaque type</em></a> nor a <a class="reference internal" href="t.html#term-transparent-type"><em class="xref std std-term">transparent
type</em></a>, but is instead a structure or function type based
on transparent and opaque types and on built-in C types.
See <a class="reference internal" href="../topic/interface.html#topic-interface"><em>Interface conventions</em></a>.</p>
</div>
</dd>
<dt id="term-destructor-1">destructor<sup>(1)</sup></dt>
<dd><p class="first">A destructor is a function or a method that performs the
explicit <a class="reference internal" href="f.html#term-free-1"><em class="xref std std-term">deallocation</em></a> of an <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a>.
It may also perform clean-up actions.</p>
<div class="admonition-opposite-term last admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="c.html#term-constructor-1"><em class="xref std std-term">constructor<sup>(1)</sup></em></a>.</p>
</div>
</dd>
<dt id="term-destructor-2">destructor<sup>(2)</sup></dt>
<dd><p class="first">In <a class="reference internal" href="../mmref/lang.html#term-6"><em class="xref std std-term">C++</em></a>, a <em>destructor</em> is a member function that is
used to clean up when an object is being <a class="reference internal" href="f.html#term-free-1"><em class="xref std std-term">deallocated</em></a>.</p>
<p>When an object is being destroyed (by <tt class="docutils literal"><span class="pre">delete</span></tt> or
automatically), the appropriate destructor is called, and then
the actual deallocation of <a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a> is performed by
<tt class="docutils literal"><span class="pre">operator</span> <span class="pre">delete</span></tt> or the run-time system (for <a class="reference internal" href="s.html#term-static-allocation"><em class="xref std std-term">static</em></a> and <a class="reference internal" href="s.html#term-stack-allocation"><em class="xref std std-term">stack allocation</em></a>).</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="c.html#term-constructor-2"><em class="xref std std-term">constructor<sup>(2)</sup></em></a>.</p>
</div>
</dd>
<dt id="term-dgc">DGC</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-distributed-garbage-collection"><em class="xref std std-term">distributed garbage collection</em></a>.</p>
</div>
</dd>
<dt id="term-direct-method">direct method</dt>
<dd><p class="first">Direct methods of <a class="reference internal" href="a.html#term-automatic-memory-management"><em class="xref std std-term">automatic memory management</em></a> maintain
information about the <a class="reference internal" href="l.html#term-live"><em class="xref std std-term">liveness</em></a> of each
<a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a>, detecting <a class="reference internal" href="g.html#term-garbage"><em class="xref std std-term">garbage</em></a> directly.</p>
<p>Such bits of information, for example, <a class="reference internal" href="r.html#term-reference-counting"><em class="xref std std-term">reference counts</em></a>, are typically stored within the objects
themselves.</p>
<p>Direct <a class="reference internal" href="g.html#term-garbage-collection"><em class="xref std std-term">garbage collection</em></a> can allow <a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a>
to be <a class="reference internal" href="r.html#term-reclaim"><em class="xref std std-term">reclaimed</em></a> as soon as it becomes
<a class="reference internal" href="u.html#term-unreachable"><em class="xref std std-term">unreachable</em></a>. However, the stored information must be
updated as the <a class="reference internal" href="g.html#term-graph"><em class="xref std std-term">graph</em></a> of objects changes; this may be
an expensive operation, especially in <a class="reference internal" href="#term-distributed-garbage-collection"><em class="xref std std-term">distributed
garbage collection</em></a> where it can lead to intensive
communication between processors, and make garbage collection
less robust to network failures.</p>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="i.html#term-indirect-method"><em class="xref std std-term">indirect method</em></a>.</p>
</div>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#jones12"><em>Jones et al. (2012)</em></a>.</p>
</div>
</dd>
<dt id="term-dirty-bit">dirty bit</dt>
<dd><p class="first">A dirty bit is a flag indicating that a <a class="reference internal" href="p.html#term-page"><em class="xref std std-term">page</em></a> (or
similar) has been written to since it was last examined.</p>
<p class="last">Dirty bits are used by <a class="reference internal" href="c.html#term-cache-2"><em class="xref std std-term">cache<sup>(2)</sup></em></a> to determine which
pages must be written out, and by garbage collectors in
conjunction with <a class="reference internal" href="w.html#term-write-barrier"><em class="xref std std-term">write barriers</em></a>.</p>
</dd>
<dt id="term-distributed-garbage-collection">distributed garbage collection</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>DGC</em>.</p>
</div>
<p>Distributed garbage collection is <a class="reference internal" href="g.html#term-garbage-collection"><em class="xref std std-term">garbage collection</em></a>
in a system where <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> might not reside in the same
<a class="reference internal" href="a.html#term-address-space"><em class="xref std std-term">address space</em></a> or even on the same machine.</p>
<p class="last">Distributed garbage collection is difficult to achieve in
widely-distributed systems (over wide-area networks) because
of the costs of synchronization and communication between
processes. These costs are particularly high for a
<a class="reference internal" href="t.html#term-tracing-garbage-collection"><em class="xref std std-term">tracing garbage collector</em></a>, so other techniques, including <a class="reference internal" href="w.html#term-weighted-reference-counting"><em class="xref std std-term">weighted
reference counting</em></a>, are commonly used instead.</p>
</dd>
<dt id="term-double-buddies">double buddies</dt>
<dd><p class="first">A <a class="reference internal" href="b.html#term-buddy-system"><em class="xref std std-term">buddy system</em></a> <a class="reference internal" href="a.html#term-allocation-mechanism"><em class="xref std std-term">allocation mechanism</em></a> using a
pair of <a class="reference internal" href="b.html#term-binary-buddies"><em class="xref std std-term">binary buddy</em></a> systems with
staggered size classes.</p>
<p>One system is a pure binary buddy, with powers-of-two classes
(2, 4, 8, â¦). The other uses some fixed multiple of
powers-of-two (for example, 3, 6, 12, â¦). This resembles
<a class="reference internal" href="w.html#term-weighted-buddies"><em class="xref std std-term">weighted buddies</em></a>, but the two buddy systems are
treated independently: blocks cannot be <a class="reference internal" href="s.html#term-split"><em class="xref std std-term">split</em></a> or
<a class="reference internal" href="c.html#term-coalesce"><em class="xref std std-term">coalesced</em></a> from one to the other.</p>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#wise78"><em>Wise (1978)</em></a>.</p>
</div>
</dd>
<dt id="term-double-free">double free</dt>
<dd><p class="first">A double free is when an attempt is made to <a class="reference internal" href="f.html#term-free-1"><em class="xref std std-term">free<sup>(1)</sup></em></a> a
<a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a> <a class="reference internal" href="b.html#term-block"><em class="xref std std-term">block</em></a> that has already been freed.</p>
<p>This usually occurs in <a class="reference internal" href="m.html#term-manual-memory-management"><em class="xref std std-term">manual memory management</em></a> when
two parts of a program believe they are responsible for the
management of the same block.</p>
<p>Many manual <a class="reference internal" href="m.html#term-memory-manager"><em class="xref std std-term">memory managers</em></a> have great trouble with
double frees, because they cannot cheaply determine that
<a class="reference internal" href="f.html#term-free-1"><em class="xref std std-term">deallocated</em></a> blocks were already free.
Instead, they corrupt their <a class="reference internal" href="f.html#term-free-block-chain"><em class="xref std std-term">free block chain</em></a>, which
leads to mysterious problems when the same block is
subsequently <a class="reference internal" href="a.html#term-allocate"><em class="xref std std-term">allocated</em></a>.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="p.html#term-premature-free"><em class="xref std std-term">premature free</em></a>.</p>
</div>
</dd>
<dt id="term-doubleword">doubleword</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>longword</em>.</p>
</div>
<p>A <em>doubleword</em> is a unit of memory consisting of two adjacent
<a class="reference internal" href="w.html#term-word"><em class="xref std std-term">words</em></a>.</p>
<div class="admonition-historical-note admonition">
<p class="first admonition-title">Historical note</p>
<p class="last">On the Intel 80386, 80486, and Pentium processors, the
doubleword of 32 bits is actually the <em>natural word size</em>,
but the term <em>word</em> is still used for the 16-bit unit, as
it was on earlier processors of this series.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="q.html#term-quadword"><em class="xref std std-term">quadword</em></a>.</p>
</div>
</dd>
<dt id="term-doubly-weak-hash-table">doubly weak hash table</dt>
<dd>A hash table that is both <a class="reference internal" href="w.html#term-weak-key-hash-table"><em class="xref std std-term">weak-key</em></a> and <a class="reference internal" href="w.html#term-weak-value-hash-table"><em class="xref std std-term">weak-value</em></a>.</dd>
<dt id="term-dram">DRAM</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-dynamic-memory"><em class="xref std std-term">dynamic memory</em></a>.</p>
</div>
</dd>
<dt id="term-dynamic-allocation">dynamic allocation</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="h.html#term-heap-allocation"><em class="xref std std-term">heap allocation</em></a>.</p>
</div>
</dd>
<dt id="term-dynamic-extent">dynamic extent</dt>
<dd><p class="first">An <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> has <em>dynamic extent</em> if its <a class="reference internal" href="l.html#term-lifetime"><em class="xref std std-term">lifetime</em></a>
is bounded by the execution of a function or some other block
construct.</p>
<p>Objects of dynamic extent are usually <a class="reference internal" href="s.html#term-stack-allocation"><em class="xref std std-term">stack-allocated</em></a>.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="a.html#term-automatic-storage-duration"><em class="xref std std-term">automatic storage duration</em></a>.</p>
</div>
<div class="admonition-opposite-term last admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="i.html#term-indefinite-extent"><em class="xref std std-term">indefinite extent</em></a>.</p>
</div>
</dd>
<dt id="term-dynamic-memory">dynamic memory</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>dynamic RAM</em>, <em>DRAM</em>.</p>
</div>
<p>Dynamic memory, or dynamic RAM (DRAM, pronounced &#8220;dee ram&#8221;),
is a type of <a class="reference internal" href="r.html#term-ram"><em class="xref std std-term">RAM</em></a>.</p>
<p>Dynamic memory requires periodic refreshing to avoid losing
its contents (as opposed to <a class="reference internal" href="s.html#term-static-memory-1"><em class="xref std std-term">static memory<sup>(1)</sup></em></a>, the
contents of which are preserved without any need for
refreshing). The refreshing is performed by additional
&#8220;refresh hardware&#8221; usually external to the dynamic memory
package itself, sometimes by the main CPU. Dynamic memory is
cheap and compact and is the choice for large amounts of
relatively fast memory, such as the <a class="reference internal" href="m.html#term-main-memory"><em class="xref std std-term">main memory</em></a> of
PCs. Dynamic memory often comes packaged in SIMMs or DIMMs.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="s.html#term-static-memory-1"><em class="xref std std-term">static memory<sup>(1)</sup></em></a>, <a class="reference internal" href="s.html#term-sdram"><em class="xref std std-term">SDRAM</em></a>.</p>
</div>
</dd>
<dt id="term-dynamic-ram">dynamic RAM</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-dynamic-memory"><em class="xref std std-term">dynamic memory</em></a>.</p>
</div>
</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="c.html"
                        title="previous chapter">Memory Management Glossary: C</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="e.html"
                        title="next chapter">Memory Management Glossary: E</a></p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="e.html" title="Memory Management Glossary: E"
             >next</a> |</li>
        <li class="right" >
          <a href="c.html" title="Memory Management Glossary: C"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Memory Management Glossary</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2012, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>