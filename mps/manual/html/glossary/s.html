

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Memory Management Glossary: S &mdash; Memory Pool System 1.111.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mps.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.111.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Memory Pool System 1.111.0 documentation" href="../index.html" />
    <link rel="up" title="Memory Management Glossary" href="index.html" />
    <link rel="next" title="Memory Management Glossary: T" href="t.html" />
    <link rel="prev" title="Memory Management Glossary: R" href="r.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="t.html" title="Memory Management Glossary: T"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="r.html" title="Memory Management Glossary: R"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Memory Management Glossary</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="memory-management-glossary-s">
<span id="glossary-s"></span><h1>Memory Management Glossary: S<a class="headerlink" href="#memory-management-glossary-s" title="Permalink to this headline">Â¶</a></h1>
<p class="glossary-alphabet"><a class="reference internal" href="a.html#glossary-a"><em>A</em></a>
| <a class="reference internal" href="b.html#glossary-b"><em>B</em></a>
| <a class="reference internal" href="c.html#glossary-c"><em>C</em></a>
| <a class="reference internal" href="d.html#glossary-d"><em>D</em></a>
| <a class="reference internal" href="e.html#glossary-e"><em>E</em></a>
| <a class="reference internal" href="f.html#glossary-f"><em>F</em></a>
| <a class="reference internal" href="g.html#glossary-g"><em>G</em></a>
| <a class="reference internal" href="h.html#glossary-h"><em>H</em></a>
| <a class="reference internal" href="i.html#glossary-i"><em>I</em></a>
| J
| <a class="reference internal" href="k.html#glossary-k"><em>K</em></a>
| <a class="reference internal" href="l.html#glossary-l"><em>L</em></a>
| <a class="reference internal" href="m.html#glossary-m"><em>M</em></a>
| <a class="reference internal" href="n.html#glossary-n"><em>N</em></a>
| <a class="reference internal" href="o.html#glossary-o"><em>O</em></a>
| <a class="reference internal" href="p.html#glossary-p"><em>P</em></a>
| <a class="reference internal" href="q.html#glossary-q"><em>Q</em></a>
| <a class="reference internal" href="r.html#glossary-r"><em>R</em></a>
| <a class="reference internal" href="#glossary-s"><em>S</em></a>
| <a class="reference internal" href="t.html#glossary-t"><em>T</em></a>
| <a class="reference internal" href="u.html#glossary-u"><em>U</em></a>
| <a class="reference internal" href="v.html#glossary-v"><em>V</em></a>
| <a class="reference internal" href="w.html#glossary-w"><em>W</em></a>
| X
| Y
| <a class="reference internal" href="z.html#glossary-z"><em>Z</em></a></p>
<dl class="glossary docutils">
<dt id="term-sbrk">sbrk</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">sbrk</span></tt> is a Unix library function that adjusts the limit of
the data segment; this limit is known as the <em>break</em>.</p>
<p><tt class="docutils literal"><span class="pre">sbrk</span></tt> returns the previous value of the break, so
<tt class="docutils literal"><span class="pre">sbrk(0)</span></tt> is a common idiom for getting the current value.</p>
<p class="last">Note that, if you use <a class="reference internal" href="b.html#term-brk"><em class="xref std std-term">brk</em></a>, you probably can&#8217;t safely
use <tt class="docutils literal"><span class="pre">sbrk</span></tt> as well, because it may store the last value of
the break in a private variable.</p>
</dd>
<dt id="term-scalar-data-type">scalar data type</dt>
<dd><p class="first">A scalar data type is a type that is representable in a single
dimension and whose objects have only magnitude as value.</p>
<p>Examples of scalar data types include: integers,
floating-point numbers, enumerations, and characters.</p>
<div class="admonition-relevance-to-memory-management admonition">
<p class="first admonition-title">Relevance to memory management</p>
<p class="last">The objects of a scalar data type are <a class="reference internal" href="l.html#term-leaf-object"><em class="xref std std-term">leaf
objects</em></a>. Scalar data types with bounded magnitude can be
represented compactly using <a class="reference internal" href="v.html#term-value-object"><em class="xref std std-term">value objects</em></a>.</p>
</div>
<div class="admonition-historical-note admonition">
<p class="first admonition-title">Historical note</p>
<p class="last">Because compact representation solves many memory
management issues, many older programming languages only
offered bounded scalar data types. For example, the
<tt class="docutils literal"><span class="pre">int</span></tt> type in <a class="reference internal" href="../mmref/lang.html#term-c"><em class="xref std std-term">C</em></a> is defined to have a magnitude
that can be represented by a <a class="reference internal" href="w.html#term-word"><em class="xref std std-term">word</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="v.html#term-vector-data-type"><em class="xref std std-term">vector data type</em></a>, <a class="reference internal" href="a.html#term-algebraic-data-type"><em class="xref std std-term">algebraic data type</em></a>, <a class="reference internal" href="v.html#term-value-object"><em class="xref std std-term">value object</em></a>, <a class="reference internal" href="l.html#term-leaf-object"><em class="xref std std-term">leaf object</em></a>.</p>
</div>
</dd>
<dt id="term-scan">scan</dt>
<dd><p class="first">The examination of an <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> or an area of
<a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a> to find <a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">references</em></a>,
typically as part of <a class="reference internal" href="t.html#term-trace"><em class="xref std std-term">tracing</em></a>.</p>
<p>Scanning examines memory that has been decided to be
non-<a class="reference internal" href="g.html#term-garbage"><em class="xref std std-term">garbage</em></a>, to find references to objects that have
been <a class="reference internal" href="c.html#term-condemned-set"><em class="xref std std-term">condemned</em></a>.</p>
<div class="admonition-in-the-mps last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">See <a class="reference internal" href="../topic/scanning.html#topic-scanning"><em>Scanning</em></a>.</p>
</div>
</dd>
<dt id="term-scan-method">scan method</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">A function that examines a block of memory to find
<a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">references</em></a> and indicate them to the
MPS. A scan method forms part of an <a class="reference internal" href="o.html#term-object-format"><em class="xref std std-term">object format</em></a>.
See <a class="reference internal" href="../topic/format.html#mps_fmt_scan_t" title="mps_fmt_scan_t"><tt class="xref c c-type docutils literal"><span class="pre">mps_fmt_scan_t</span></tt></a>.</p>
</div>
</dd>
<dt id="term-scan-state">scan state</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">A scan state represents the state of the current
<a class="reference internal" href="#term-scan"><em class="xref std std-term">scan</em></a>. The MPS passes a scan state to the
<a class="reference internal" href="#term-scan-method"><em class="xref std std-term">scan method</em></a> of an <a class="reference internal" href="o.html#term-object-format"><em class="xref std std-term">object format</em></a> when it
needs to <a class="reference internal" href="#term-scan"><em class="xref std std-term">scan</em></a> for <a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">references</em></a>
within a region of memory. Scan states belong to the type
<a class="reference internal" href="../topic/scanning.html#mps_ss_t" title="mps_ss_t"><tt class="xref c c-type docutils literal"><span class="pre">mps_ss_t</span></tt></a>.</p>
</div>
</dd>
<dt id="term-scavenging-garbage-collection">scavenging garbage collection</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="c.html#term-copying-garbage-collection"><em class="xref std std-term">copying garbage collection</em></a>.</p>
</div>
</dd>
<dt id="term-sdram">SDRAM</dt>
<dd><p class="first">Synchronous Dynamic Random Access Memory. A high performance
variant of <a class="reference internal" href="d.html#term-dynamic-memory"><em class="xref std std-term">DRAM</em></a>.</p>
<p class="last">SDRAM uses an external clock signal to synchronize its data
input and output. It is capable of achieving very high data
rates for linear access to memory.</p>
</dd>
<dt id="term-segmentation-violation">segmentation violation</dt>
<dd><p class="first">A segmentation violation occurs when an attempt is made to
access <a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a> whose <a class="reference internal" href="a.html#term-address"><em class="xref std std-term">address</em></a> is
well-formed, but to which access cannot be granted. This might
be due to either a <a class="reference internal" href="p.html#term-protection-fault"><em class="xref std std-term">protection fault</em></a> or an
<a class="reference internal" href="i.html#term-invalid-page-fault"><em class="xref std std-term">invalid page fault</em></a>.</p>
<p>The term is sometimes used more loosely as a synonym for any
memory access error, including a <a class="reference internal" href="b.html#term-bus-error"><em class="xref std std-term">bus error</em></a>.</p>
<div class="admonition-similar-term last admonition">
<p class="first admonition-title">Similar terms</p>
<p class="last"><a class="reference internal" href="g.html#term-general-protection-fault"><em class="xref std std-term">general protection fault</em></a>, <a class="reference internal" href="r.html#term-read-fault"><em class="xref std std-term">read fault</em></a>, <a class="reference internal" href="w.html#term-write-fault"><em class="xref std std-term">write fault</em></a>.</p>
</div>
</dd>
<dt id="term-segmented-addressing">segmented addressing</dt>
<dd><p class="first">In segmented addressing, <a class="reference internal" href="a.html#term-address"><em class="xref std std-term">addresses</em></a> are in
two parts: a segment identifier and an offset into that
segment.</p>
<p>Each segment has a base address and a limit. If the offset is
greater than the limit, the address is invalid (see
<a class="reference internal" href="#term-segmentation-violation"><em class="xref std std-term">segmentation violation</em></a>). Otherwise, the offset is
added to the segment&#8217;s base address, giving the unsegmented
address. Segment identifiers may be implicit; for instance,
they may be obtained from a <em>current segment</em> register.</p>
<p>Segmentation may be layered on top of <a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual memory</em></a>,
in which case the unsegmented address is a <a class="reference internal" href="v.html#term-virtual-address"><em class="xref std std-term">virtual
address</em></a>, or not, in which case it is a <a class="reference internal" href="p.html#term-physical-address"><em class="xref std std-term">physical
address</em></a>.</p>
<p>Note that, in segmented architectures, you can have a
two-dimensional <a class="reference internal" href="a.html#term-address-space"><em class="xref std std-term">address space</em></a>.</p>
<p>Segments are a feature of some processor architectures and
operating systems. This description does not cover all
possible variations on segmentation.</p>
<div class="admonition-historical-note admonition">
<p class="first admonition-title">Historical note</p>
<p class="last">Segment terminology may be used on unsegmented systems for
historical reasons. For instance, Unix processes have
<em>text segments</em>, even when running on an unsegmented
system.</p>
</div>
<div class="admonition-opposite-term last admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="l.html#term-linear-addressing"><em class="xref std std-term">linear addressing</em></a>.</p>
</div>
</dd>
<dt id="term-segregated-allocation-cache">segregated allocation cache</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">A mechanism for adding a <a class="reference internal" href="#term-segregated-free-list"><em class="xref std std-term">segregated free list</em></a> to a
<a class="reference internal" href="m.html#term-manual-memory-management"><em class="xref std std-term">manual</em></a> <a class="reference internal" href="p.html#term-pool-class"><em class="xref std std-term">pool
class</em></a>. See <a class="reference internal" href="../topic/cache.html#topic-cache"><em>Segregated allocation caches</em></a>.</p>
</div>
</dd>
<dt id="term-segregated-fit">segregated fit</dt>
<dd><p class="first">One of the <a class="reference internal" href="#term-segregated-free-list"><em class="xref std std-term">segregated free list</em></a> class of
<a class="reference internal" href="a.html#term-allocation-mechanism"><em class="xref std std-term">allocation mechanisms</em></a>. There is
an array of <a class="reference internal" href="f.html#term-free-list"><em class="xref std std-term">free lists</em></a>, each holding
<a class="reference internal" href="f.html#term-free-block"><em class="xref std std-term">free blocks</em></a> of a particular range of
sizes. The <a class="reference internal" href="a.html#term-allocator"><em class="xref std std-term">allocator</em></a> identifies the appropriate free
list and allocates from it (often using a <a class="reference internal" href="#term-sequential-fit"><em class="xref std std-term">sequential
fit</em></a> mechanism such as <a class="reference internal" href="f.html#term-first-fit"><em class="xref std std-term">first fit</em></a>). If this fails, a
larger block is taken from another list and split.</p>
<p>The details of the mechanism depend on the division of sizes
between free lists. See <a class="reference internal" href="e.html#term-exact-segregated-fit"><em class="xref std std-term">exact segregated fit</em></a> and
<a class="reference internal" href="#term-strict-segregated-fit"><em class="xref std std-term">strict segregated fit</em></a>.</p>
<p>This implements a <a class="reference internal" href="g.html#term-good-fit"><em class="xref std std-term">good fit</em></a> <a class="reference internal" href="a.html#term-allocation-policy"><em class="xref std std-term">allocation policy</em></a>.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#term-segregated-free-list"><em class="xref std std-term">segregated free list</em></a>, <a class="reference internal" href="a.html#term-allocation-mechanism"><em class="xref std std-term">allocation mechanism</em></a>, <a class="reference internal" href="f.html#term-free-list"><em class="xref std std-term">free list</em></a>, <a class="reference internal" href="e.html#term-exact-segregated-fit"><em class="xref std std-term">exact segregated fit</em></a>, <a class="reference internal" href="#term-strict-segregated-fit"><em class="xref std std-term">strict segregated fit</em></a>.</p>
</div>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#wil95"><em>Wilson et al. (1995)</em></a>.</p>
</div>
</dd>
<dt id="term-segregated-free-list"><span id="term-12"></span>segregated free list<br />segregated free-list</dt>
<dd><p class="first">A class of <a class="reference internal" href="a.html#term-allocation-mechanism"><em class="xref std std-term">allocation mechanism</em></a> which divides the
<a class="reference internal" href="f.html#term-free-list"><em class="xref std std-term">free list</em></a> into several subsets, according to the size
of the <a class="reference internal" href="f.html#term-free-block"><em class="xref std std-term">free blocks</em></a>. A <a class="reference internal" href="f.html#term-free-1"><em class="xref std std-term">freed</em></a> or <a class="reference internal" href="c.html#term-coalesce"><em class="xref std std-term">coalesced</em></a> block is placed on the
appropriate list. An allocation request is serviced from the
appropriate list.</p>
<p>This class of mechanism implements a <a class="reference internal" href="g.html#term-good-fit"><em class="xref std std-term">good fit</em></a> or
<a class="reference internal" href="b.html#term-best-fit"><em class="xref std std-term">best fit</em></a> policy.</p>
<p>Variations within this class include <a class="reference internal" href="#term-simple-segregated-storage"><em class="xref std std-term">simple segregated
storage</em></a>, <a class="reference internal" href="#term-segregated-fit"><em class="xref std std-term">segregated fit</em></a>, and <a class="reference internal" href="b.html#term-buddy-system"><em class="xref std std-term">buddy systems</em></a>.</p>
<div class="admonition-related-publication admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#wil95"><em>Wilson et al. (1995)</em></a>.</p>
</div>
<div class="admonition-in-the-mps last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last"><a class="reference internal" href="#term-segregated-allocation-cache"><em class="xref std std-term">Segregated allocation caches</em></a> are a general
mechanism for adding a segregated free list to any
manually managed pool. See <a class="reference internal" href="../topic/cache.html#topic-cache"><em>Segregated allocation caches</em></a>.</p>
</div>
</dd>
<dt id="term-semi-conservative-garbage-collection">semi-conservative garbage collection</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>mostly-precise garbage collection</em>, <em>mostly-exact garbage collection</em>.</p>
</div>
<p>A variant of <a class="reference internal" href="c.html#term-conservative-garbage-collection"><em class="xref std std-term">conservative garbage collection</em></a> which
deals with <a class="reference internal" href="e.html#term-exact-reference"><em class="xref std std-term">exact references</em></a> as well
as <a class="reference internal" href="a.html#term-ambiguous-reference"><em class="xref std std-term">ambiguous references</em></a>.</p>
<p>For example, references from the <a class="reference internal" href="r.html#term-root-set"><em class="xref std std-term">root set</em></a> might be
ambiguous, but <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> on the <a class="reference internal" href="h.html#term-heap"><em class="xref std std-term">heap</em></a>
might be fully described and precisely <a class="reference internal" href="#term-scan"><em class="xref std std-term">scanned</em></a>.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="m.html#term-mostly-copying-garbage-collection"><em class="xref std std-term">mostly-copying garbage collection</em></a>.</p>
</div>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#bartlett88"><em>Bartlett (1988)</em></a>.</p>
</div>
</dd>
<dt id="term-semi-space">semi-space</dt>
<dd><p class="first">When an area of <a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a> is divided into two parts
for the purposes of <a class="reference internal" href="c.html#term-copying-garbage-collection"><em class="xref std std-term">copying garbage collection</em></a>, the
parts are known as <em>semi-spaces</em>, or sometimes just <em>spaces</em>.</p>
<p>Each semi-space is a contiguous area of memory. Semi-spaces
are usually used for <a class="reference internal" href="t.html#term-two-space-collector"><em class="xref std std-term">two space collection</em></a>, but can be used for <a class="reference internal" href="g.html#term-generational-garbage-collection"><em class="xref std std-term">generational
collection</em></a>.</p>
<p>The semi-space where <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> reside at the start of
the collection is known as the <a class="reference internal" href="f.html#term-fromspace"><em class="xref std std-term">fromspace</em></a>; the
<a class="reference internal" href="t.html#term-tospace"><em class="xref std std-term">tospace</em></a> is where objects will reside, and where new
objects will be <a class="reference internal" href="a.html#term-allocate"><em class="xref std std-term">allocated</em></a>, when the collection is
complete.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="t.html#term-two-space-collector"><em class="xref std std-term">two-space collector</em></a>.</p>
</div>
</dd>
<dt id="term-semi-space-collector">semi-space collector</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="t.html#term-two-space-collector"><em class="xref std std-term">two-space collector</em></a>.</p>
</div>
</dd>
<dt id="term-sequential-fit">sequential fit</dt>
<dd><p class="first">A class of <a class="reference internal" href="a.html#term-allocation-mechanism"><em class="xref std std-term">allocation mechanisms</em></a> that maintain the
<a class="reference internal" href="f.html#term-free-list"><em class="xref std std-term">free list</em></a> as a single linear list of <a class="reference internal" href="f.html#term-free-block"><em class="xref std std-term">free
blocks</em></a> (a <a class="reference internal" href="f.html#term-free-block-chain"><em class="xref std std-term">free block chain</em></a>). Sequential fit
mechanisms include <a class="reference internal" href="f.html#term-first-fit"><em class="xref std std-term">first fit</em></a> and <a class="reference internal" href="n.html#term-next-fit"><em class="xref std std-term">next fit</em></a>.</p>
<p>To quote <a class="reference internal" href="../mmref/bib.html#wil95"><em>Wilson et al. (1995)</em></a>:</p>
<blockquote>
<div>The list is often doubly-linked and/or circularly linked.
Typically, sequential fit algorithms use Knuth&#8217;s boundary
tag technique, and a doubly-linked list to make
<a class="reference internal" href="c.html#term-coalesce"><em class="xref std std-term">coalescing</em></a> simple and fast. [â¦] In
considering sequential fits, it is probably most important
to keep strategy and policy issues in mind. The classic
linear-list implementations may not scale well to large
<a class="reference internal" href="h.html#term-heap"><em class="xref std std-term">heaps</em></a>, in terms of time costs; as the
number of free blocks grows the time to search the list
may become unacceptable. More efficient and scalable
techniques are available, using totally or partially
ordered trees, or <a class="reference internal" href="#term-segregated-fit"><em class="xref std std-term">segregated fits</em></a>.</div></blockquote>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="b.html#term-bitmapped-fit"><em class="xref std std-term">bitmapped fit</em></a>, <a class="reference internal" href="i.html#term-indexed-fit"><em class="xref std std-term">indexed fit</em></a>.</p>
</div>
</dd>
<dt id="term-sequential-store-buffer">sequential store buffer</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>SSB</em>.</p>
</div>
<p>A sequential store buffer is a technique for dividing the cost
of a <a class="reference internal" href="w.html#term-write-barrier"><em class="xref std std-term">write barrier</em></a> by remembering which
<a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> are modified and updating <a class="reference internal" href="r.html#term-remembered-set"><em class="xref std std-term">remembered
sets</em></a> (and so on) at a later stage.</p>
<p class="last">This turns out to be extremely efficient on pipelined
architectures with branch prediction.</p>
</dd>
<dt id="term-shared-memory">shared memory</dt>
<dd><a class="reference internal" href="m.html#term-memory-location"><em class="xref std std-term">Memory locations</em></a> are <em>shared</em> if
they are in the range of multiple <a class="reference internal" href="a.html#term-address-space"><em class="xref std std-term">address spaces</em></a>.</dd>
<dt id="term-simple-object">simple object</dt>
<dd><p class="first">In the <a class="reference internal" href="../mmref/lang.html#term-postscript"><em class="xref std std-term">PostScript</em></a> language, <em>simple objects</em> are the
<a class="reference internal" href="u.html#term-unboxed"><em class="xref std std-term">unboxed</em></a> objects.</p>
<p>Unlike a <a class="reference internal" href="c.html#term-composite-object"><em class="xref std std-term">composite object</em></a>, a simple object contains
all its data in the object itself.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="u.html#term-unboxed"><em class="xref std std-term">unboxed</em></a>.</p>
</div>
<div class="admonition-opposite-term last admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="c.html#term-composite-object"><em class="xref std std-term">composite object</em></a>.</p>
</div>
</dd>
<dt id="term-simple-segregated-storage">simple segregated storage</dt>
<dd><p class="first">A <a class="reference internal" href="#term-segregated-free-list"><em class="xref std std-term">segregated free list</em></a> <a class="reference internal" href="a.html#term-allocation-mechanism"><em class="xref std std-term">allocation mechanism</em></a>
which divides <a class="reference internal" href="m.html#term-memory-1"><em class="xref std std-term">memory<sup>(1)</sup></em></a> into <a class="reference internal" href="p.html#term-page"><em class="xref std std-term">pages</em></a> or
other areas and only allocates <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> of a
single size, or small range of sizes, within each area. This
makes allocation fast and avoids <a class="reference internal" href="i.html#term-in-band-header"><em class="xref std std-term">headers</em></a>, but may lead to high <a class="reference internal" href="e.html#term-external-fragmentation"><em class="xref std std-term">external fragmentation</em></a>,
as unused parts of areas cannot be reused for other object
sizes.</p>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#wil95"><em>Wilson et al. (1995)</em></a>.</p>
</div>
</dd>
<dt id="term-size">size</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">The term <em>size</em> in the documentation always refers to a
size that is measured in <a class="reference internal" href="b.html#term-byte-1"><em class="xref std std-term">bytes<sup>(1)</sup></em></a>. The term
<em>count</em> is used for the number of elements in an array.</p>
</div>
</dd>
<dt id="term-size-class">size class</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">A <a class="reference internal" href="#term-segregated-allocation-cache"><em class="xref std std-term">segregated allocation cache</em></a> maintains a reserve
of free <a class="reference internal" href="b.html#term-block"><em class="xref std std-term">blocks</em></a> in a set of <a class="reference internal" href="#term-size"><em class="xref std std-term">sizes</em></a>: each
such size is known as a <em>size class</em>. When creating a
segregated allocation cache by calling
<a class="reference internal" href="../topic/cache.html#mps_sac_create" title="mps_sac_create"><tt class="xref c c-func docutils literal"><span class="pre">mps_sac_create()</span></tt></a>, the <a class="reference internal" href="c.html#term-client-program"><em class="xref std std-term">client program</em></a>
describes the desired set of size classes by passing an
array of structures of type <a class="reference internal" href="../topic/cache.html#mps_sac_class_s" title="mps_sac_class_s"><tt class="xref c c-type docutils literal"><span class="pre">mps_sac_class_s</span></tt></a>. See
<a class="reference internal" href="../topic/cache.html#topic-cache"><em>Segregated allocation caches</em></a>.</p>
</div>
</dd>
<dt id="term-skip-method">skip method</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">A <a class="reference internal" href="f.html#term-format-method"><em class="xref std std-term">format method</em></a> that returns the address of the
&#8220;next object&#8221; in a block of <a class="reference internal" href="f.html#term-formatted-object"><em class="xref std std-term">formatted objects</em></a>. See <a class="reference internal" href="../topic/format.html#mps_fmt_skip_t" title="mps_fmt_skip_t"><tt class="xref c c-type docutils literal"><span class="pre">mps_fmt_skip_t</span></tt></a>.</p>
</div>
</dd>
<dt id="term-smart-pointer">smart pointer</dt>
<dd><p class="first">A smart pointer is an instance of a <a class="reference internal" href="../mmref/lang.html#term-6"><em class="xref std std-term">C++</em></a> class that
encapsulates a <a class="reference internal" href="p.html#term-pointer"><em class="xref std std-term">pointer</em></a> and performs <a class="reference internal" href="r.html#term-reference-counting"><em class="xref std std-term">reference
counting</em></a>.</p>
<p>By overloading certain operators it is possible for the class
to present the illusion of being a pointer, so that
<tt class="docutils literal"><span class="pre">operator\*</span></tt>, <tt class="docutils literal"><span class="pre">operator-\&gt;</span></tt>, etc. can be used as normal.
Reference counting allows the objects that are referred to
using the smart pointer class to have their <a class="reference internal" href="m.html#term-memory-1"><em class="xref std std-term">memory<sup>(1)</sup></em></a>
automatically <a class="reference internal" href="r.html#term-reclaim"><em class="xref std std-term">reclaimed</em></a> when they are no longer
<a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">referenced</em></a>. It is a common technique used when trying
to solve <a class="reference internal" href="m.html#term-memory-management"><em class="xref std std-term">memory management</em></a> problems in C++
applications.</p>
<p>However, reference counting is not always an appropriate
memory management technique and smart pointers can be hard to
implement properly in C++. A <a class="reference internal" href="t.html#term-tracing-garbage-collection"><em class="xref std std-term">tracing garbage collector</em></a> might be worth considering.</p>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#edelson92a"><em>Edelson (1992a)</em></a>.</p>
</div>
</dd>
<dt id="term-snap-out">snap-out</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>transport snap-out</em>.</p>
</div>
<p>In a <a class="reference internal" href="c.html#term-copying-garbage-collection"><em class="xref std std-term">copying collector</em></a>,
when there is a <a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">reference</em></a> to an <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> that
was <a class="reference internal" href="c.html#term-condemned-set"><em class="xref std std-term">condemned</em></a>, but has been
<a class="reference internal" href="t.html#term-transport"><em class="xref std std-term">transported</em></a>, snap-out is the adjustment of that
reference to point to the preserved copy.</p>
<p>Typically the first transport leaves a <a class="reference internal" href="f.html#term-forwarding-pointer"><em class="xref std std-term">forwarding
pointer</em></a> that enables the snap-out.</p>
<div class="figure align-center">
<img alt="Diagram: Snap-out." src="../_images/snap-out.svg" /><p class="caption">Snap-out.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="b.html#term-broken-heart"><em class="xref std std-term">broken heart</em></a>.</p>
</div>
</dd>
<dt id="term-snapshot-at-the-beginning">snapshot at the beginning</dt>
<dd><p class="first">Snapshot-at-the-beginning algorithms for <a class="reference internal" href="t.html#term-trace"><em class="xref std std-term">tracing</em></a>, <a class="reference internal" href="i.html#term-incremental-garbage-collection"><em class="xref std std-term">incremental GC</em></a> note changes made by the <a class="reference internal" href="m.html#term-mutator"><em class="xref std std-term">mutator</em></a> to the
<a class="reference internal" href="g.html#term-graph"><em class="xref std std-term">graph</em></a> of <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> and update the
<a class="reference internal" href="c.html#term-collector-2"><em class="xref std std-term">collector<sup>(2)</sup></em></a> state to make it trace relevant
<a class="reference internal" href="e.html#term-edge"><em class="xref std std-term">edges</em></a> that the mutator deletes.</p>
<p>In order for the collector to miss a <a class="reference internal" href="r.html#term-reachable"><em class="xref std std-term">reachable</em></a>
<a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a>, the following two conditions need to hold at
some point during tracing:</p>
<ol class="arabic simple">
<li>The mutator stores a <a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">reference</em></a> to a <a class="reference internal" href="w.html#term-white"><em class="xref std std-term">white</em></a>
object into a <a class="reference internal" href="b.html#term-black"><em class="xref std std-term">black</em></a> object.</li>
<li>All paths from any <a class="reference internal" href="g.html#term-gray"><em class="xref std std-term">gray</em></a> objects to that white
object are destroyed.</li>
</ol>
<p>Snapshot-at-the-beginning algorithms ensure the second
condition cannot occur, by causing the collector to process
any reference that the mutator overwrites and that might be
part of such a path.</p>
<p>They are so called because they keep track of references that
existed at the beginning of the <a class="reference internal" href="c.html#term-collection-cycle"><em class="xref std std-term">collection cycle</em></a>. Note
that this does not mean all modifications need to be seen by
the collector, only those needed to complete tracing without
missing a reachable object (see <a class="reference internal" href="../mmref/bib.html#pirinen98"><em>Pirinen (1998)</em></a> for details), nor does it mean that it won&#8217;t
trace some references created during the collection.</p>
<div class="admonition-historical-note admonition">
<p class="first admonition-title">Historical note</p>
<p class="last">This distinction between incremental update and
snapshot at the beginning was first introduced for
write-barrier algorithms, but it applies to any type of
tracing algorithm.</p>
</div>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="i.html#term-incremental-update"><em class="xref std std-term">incremental update</em></a>.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="t.html#term-tri-color-marking"><em class="xref std std-term">tri-color marking</em></a>, <a class="reference internal" href="w.html#term-weak-tri-color-invariant"><em class="xref std std-term">weak tri-color invariant</em></a>, <a class="reference internal" href="b.html#term-barrier-1"><em class="xref std std-term">barrier<sup>(1)</sup></em></a>.</p>
</div>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publications</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#wil94"><em>Wilson (1994)</em></a>, <a class="reference internal" href="../mmref/bib.html#pirinen98"><em>Pirinen (1998)</em></a>.</p>
</div>
</dd>
<dt id="term-soft-reference">soft reference</dt>
<dd><p class="first">In <a class="reference internal" href="../mmref/lang.html#term-java"><em class="xref std std-term">Java</em></a> terminology, <em>soft reference</em> is used to mean
a <a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">reference</em></a> encapsulated in a <a class="reference internal" href="r.html#term-reference-object"><em class="xref std std-term">reference object</em></a>
of class <tt class="docutils literal"><span class="pre">SoftReference</span></tt>.</p>
<p>Soft references form one of three kinds of <a class="reference internal" href="w.html#term-weak-reference-1"><em class="xref std std-term">weak
reference<sup>(1)</sup></em></a> in Java. They are handy for building
<a class="reference internal" href="c.html#term-caching-3"><em class="xref std std-term">caches<sup>(3)</sup></em></a> that are automatically
flushed when memory is low.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#term-softly-reachable"><em class="xref std std-term">softly reachable</em></a>.</p>
</div>
<div class="admonition-related-link last admonition">
<p class="first admonition-title">Related links</p>
<p class="last"><a class="reference external" href="http://download.java.net/jdk8/docs/api/java/lang/ref/SoftReference.html">Class java.lang.ref.SoftReference</a>, <a class="reference external" href="http://pawlan.com/monica/articles/refobjs/">Reference Objects and Garbage Collection</a>.</p>
</div>
</dd>
<dt id="term-softly-reachable">softly reachable</dt>
<dd><p class="first">In <a class="reference internal" href="../mmref/lang.html#term-java"><em class="xref std std-term">Java</em></a>, an object is <em>softly reachable</em> if it is not
<a class="reference internal" href="#term-strongly-reachable"><em class="xref std std-term">strongly reachable</em></a> and there is a path from the
<a class="reference internal" href="r.html#term-root"><em class="xref std std-term">roots</em></a> to it that contains at least one
<a class="reference internal" href="#term-soft-reference"><em class="xref std std-term">soft reference</em></a> but no <a class="reference internal" href="w.html#term-weak-reference-2"><em class="xref std std-term">weak<sup>(2)</sup></em></a> or <a class="reference internal" href="p.html#term-phantom-reference"><em class="xref std std-term">phantom references</em></a>.</p>
<p>When the Java <a class="reference internal" href="c.html#term-collector-1"><em class="xref std std-term">collector<sup>(1)</sup></em></a> determines that an object
is softly reachable, it has the option of clearing the soft
references involved, which will usually allow the object to be
<a class="reference internal" href="r.html#term-recycle"><em class="xref std std-term">recycled</em></a>. The idea is that they will only be cleared
if the process is running short of <a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a>. If it
is done, all soft references involved are cleared, so that the
object is no longer softly reachable, and any affected
<a class="reference internal" href="r.html#term-reference-object"><em class="xref std std-term">reference objects</em></a> which are registered with a queue
are enqueued.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="r.html#term-reachable"><em class="xref std std-term">reachability</em></a>, <a class="reference internal" href="w.html#term-weakly-reachable"><em class="xref std std-term">weakly reachable</em></a>, <a class="reference internal" href="p.html#term-phantom-reachable"><em class="xref std std-term">phantom reachable</em></a>.</p>
</div>
<div class="admonition-related-link last admonition">
<p class="first admonition-title">Related link</p>
<p class="last"><a class="reference external" href="http://download.java.net/jdk8/docs/api/java/lang/ref/SoftReference.html">Class java.lang.ref.SoftReference</a>, <a class="reference external" href="http://pawlan.com/monica/articles/refobjs/">Reference Objects and Garbage Collection</a>.</p>
</div>
</dd>
<dt id="term-space-leak">space leak</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="m.html#term-memory-leak"><em class="xref std std-term">memory leak</em></a>.</p>
</div>
</dd>
<dt id="term-spare-commit-limit">spare commit limit</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">The spare commit limit is a limit on the <a class="reference internal" href="#term-spare-committed-memory"><em class="xref std std-term">spare
committed memory</em></a> that the MPS will obtain from the
operating system. It can be retrieved by calling
<a class="reference internal" href="../topic/arena.html#mps_arena_spare_commit_limit" title="mps_arena_spare_commit_limit"><tt class="xref c c-func docutils literal"><span class="pre">mps_arena_spare_commit_limit()</span></tt></a> and changed by
calling <a class="reference internal" href="../topic/arena.html#mps_arena_spare_commit_limit_set" title="mps_arena_spare_commit_limit_set"><tt class="xref c c-func docutils literal"><span class="pre">mps_arena_spare_commit_limit_set()</span></tt></a>.</p>
</div>
</dd>
<dt id="term-spare-committed-memory">spare committed memory</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">Memory which is not in use by any <a class="reference internal" href="p.html#term-pool"><em class="xref std std-term">pool</em></a> and not
otherwise in use for internal MPS data structures, but
which remains <a class="reference internal" href="m.html#term-mapped"><em class="xref std std-term">committed</em></a> (mapped to
<a class="reference internal" href="r.html#term-ram"><em class="xref std std-term">RAM</em></a> by the operating system). It is used by the
<a class="reference internal" href="a.html#term-arena"><em class="xref std std-term">arena</em></a> to (attempt to) avoid calling the operating
system to repeatedly map and unmap areas of <a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual
memory</em></a> as the amount of memory in use goes up and down.
It is subject to the <a class="reference internal" href="#term-spare-commit-limit"><em class="xref std std-term">spare commit limit</em></a>. The total
spare committed memory can be retrieved by calling
<a class="reference internal" href="../topic/arena.html#mps_arena_spare_committed" title="mps_arena_spare_committed"><tt class="xref c c-func docutils literal"><span class="pre">mps_arena_spare_committed()</span></tt></a>.</p>
</div>
</dd>
<dt id="term-spaghetti-stack">spaghetti stack</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="c.html#term-cactus-stack"><em class="xref std std-term">cactus stack</em></a>.</p>
</div>
</dd>
<dt id="term-splat">splat</dt>
<dd><div class="admonition-in-the-mps first last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">To overwrite a <a class="reference internal" href="w.html#term-weak-reference-1"><em class="xref std std-term">weak reference<sup>(1)</sup></em></a> with a null
pointer, when the MPS has determined that there are no
remaining <a class="reference internal" href="#term-strong-reference"><em class="xref std std-term">strong references</em></a> to the block referred
to. See <a class="reference internal" href="../topic/weak.html#topic-weak"><em>Weak references</em></a>.</p>
</div>
</dd>
<dt id="term-split">split</dt>
<dd><p class="first">To divide a <a class="reference internal" href="f.html#term-free-block"><em class="xref std std-term">free block</em></a> into two smaller free blocks in
the process of satisfying an allocation request.</p>
<p>Deciding when to split a block is an important aspect of an
<a class="reference internal" href="a.html#term-allocation-policy"><em class="xref std std-term">allocation policy</em></a>.</p>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="c.html#term-coalesce"><em class="xref std std-term">coalesce</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="c.html#term-coalesce"><em class="xref std std-term">coalesce</em></a>, <a class="reference internal" href="a.html#term-allocation-policy"><em class="xref std std-term">allocation policy</em></a>, <a class="reference internal" href="f.html#term-free-block"><em class="xref std std-term">free block</em></a>.</p>
</div>
</dd>
<dt id="term-sram">SRAM</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-static-memory-1"><em class="xref std std-term">static memory<sup>(1)</sup></em></a>.</p>
</div>
</dd>
<dt id="term-ssb">SSB</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-sequential-store-buffer"><em class="xref std std-term">sequential store buffer</em></a>.</p>
</div>
</dd>
<dt id="term-stack">stack</dt>
<dd><p class="first">A stack is a LIFO (last in, first out) collection:
<a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> may be <em>pushed</em> onto the stack, and
<em>popped</em> off it in reverse order of pushing.</p>
<p>When people say &#8220;the stack&#8221;, they usually mean the
<a class="reference internal" href="c.html#term-control-stack"><em class="xref std std-term">control stack</em></a> supported by the OS and/or the
processor.</p>
<div class="admonition-relevance-to-memory-management admonition">
<p class="first admonition-title">Relevance to memory management</p>
<p class="last"><a class="reference internal" href="#term-stack-allocation"><em class="xref std std-term">Stack allocation</em></a> is an important technique.
Control stacks are central to the performance of the
system and often require special handling.</p>
</div>
<div class="admonition-historical-note admonition">
<p class="first admonition-title">Historical note</p>
<p class="last">The terms &#8220;stack&#8221;, &#8220;push&#8221;, and &#8220;pop&#8221; are taken from the
spring-loaded dish stack found in cafeterias and salad
bars where removing the top plate causes the others to
rise up, exposing the next one, and adding a plate causes
the spring to compress, leaving only that plate
accessible.</p>
</div>
<p>So originally, the latest item was the &#8220;top&#8221;, &#8220;down the stack&#8221;
meant towards earlier items, and &#8220;up&#8221; towards later ones, but
today many use &#8220;up&#8221; and &#8220;down&#8221; in the opposite sense.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="c.html#term-control-stack"><em class="xref std std-term">control stack</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="d.html#term-data-stack"><em class="xref std std-term">data stack</em></a>, <a class="reference internal" href="c.html#term-cactus-stack"><em class="xref std std-term">cactus stack</em></a>.</p>
</div>
</dd>
<dt id="term-stack-allocation">stack allocation</dt>
<dd><p class="first"><em>Stack allocation</em> means run-time <a class="reference internal" href="a.html#term-allocate"><em class="xref std std-term">allocation</em></a> and <a class="reference internal" href="f.html#term-free-1"><em class="xref std std-term">deallocation</em></a> of
<a class="reference internal" href="m.html#term-memory-1"><em class="xref std std-term">memory<sup>(1)</sup></em></a> in last-in/first-out order.</p>
<p>Typically, stack allocation is performed on top of the main
<a class="reference internal" href="#term-stack"><em class="xref std std-term">stack</em></a>, but one can have a separate <a class="reference internal" href="d.html#term-data-stack"><em class="xref std std-term">data stack</em></a>
for this purpose as well, as in Forth, or even multiple ones,
as in the <a class="reference internal" href="../mmref/lang.html#term-postscript"><em class="xref std std-term">PostScript</em></a> language.</p>
<p>Allocation and deallocation are typically fast, since they can
be done simply by adding or subtracting the size of the
<a class="reference internal" href="b.html#term-block"><em class="xref std std-term">block</em></a> from the stack pointer.</p>
<p>Using only stack allocation, without heap allocation, is
somewhat restrictive, as only objects whose size is known at
compile-time can be returned from a procedure.</p>
<p>Some programming languages (such as some versions of
<a class="reference internal" href="../mmref/lang.html#term-lisp"><em class="xref std std-term">Lisp</em></a> and <a class="reference internal" href="../mmref/lang.html#term-c"><em class="xref std std-term">C</em></a>) provide program-controlled stack
<a class="reference internal" href="a.html#term-allocate"><em class="xref std std-term">allocation</em></a> and <a class="reference internal" href="f.html#term-free-1"><em class="xref std std-term">deallocation</em></a> of dynamic extent objects for efficiency, despite its
being unsafe.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="a.html#term-automatic-storage-duration"><em class="xref std std-term">automatic storage duration</em></a>.</p>
</div>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite terms</p>
<p class="last"><a class="reference internal" href="h.html#term-heap-allocation"><em class="xref std std-term">heap allocation</em></a>, <a class="reference internal" href="#term-static-allocation"><em class="xref std std-term">static allocation</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="r.html#term-region-inference"><em class="xref std std-term">region inference</em></a>, <a class="reference internal" href="d.html#term-dynamic-extent"><em class="xref std std-term">dynamic extent</em></a>.</p>
</div>
</dd>
<dt id="term-stack-frame">stack frame</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>stack record</em>.</p>
</div>
<p>A stack frame or record is an <a class="reference internal" href="a.html#term-activation-record"><em class="xref std std-term">activation record</em></a> that
is stored on the <a class="reference internal" href="#term-stack"><em class="xref std std-term">stack</em></a>.</p>
<p>In a register-based architecture, where the current activation
record may be partially stored in registers, there may be
hardware instructions that facilitate storing registers on the
stack when another activation record is made current. Such
instructions may prescribe a particular layout for activation
records.</p>
<div class="admonition-relevance-to-memory-management admonition">
<p class="first admonition-title">Relevance to memory management</p>
<p class="last">Hardware support for saving and restoring registers, for
stacks and for stack addressing may limit or otherwise
prescribe the size and type of data that can be stored in
a stack frame. Knowledge of the layout of each stack frame
may assist a <a class="reference internal" href="g.html#term-garbage-collector"><em class="xref std std-term">garbage collector</em></a> in finding
<a class="reference internal" href="r.html#term-root"><em class="xref std std-term">roots</em></a>.</p>
</div>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="a.html#term-activation-record"><em class="xref std std-term">activation record</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#term-stack"><em class="xref std std-term">stack</em></a>.</p>
</div>
</dd>
<dt id="term-stack-record">stack record</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-stack-frame"><em class="xref std std-term">stack frame</em></a>.</p>
</div>
</dd>
<dt id="term-static-allocation">static allocation</dt>
<dd><p class="first"><em>Static allocation</em> means <a class="reference internal" href="a.html#term-allocate"><em class="xref std std-term">allocation</em></a> of
<a class="reference internal" href="m.html#term-memory-1"><em class="xref std std-term">memory<sup>(1)</sup></em></a> before the program starts and retention
until the end.</p>
<p>The locations of <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">objects</em></a> are basically
decided at compile-time, although they might be
<a class="reference internal" href="r.html#term-relocation"><em class="xref std std-term">relocated</em></a> at load-time. This implies the
sizes of the objects must be known then.</p>
<p>Using only static allocation is restrictive, as sizes of data
structures can&#8217;t be dynamically varied, and procedures cannot
be recursive. However, it is also fast and eliminates the
possibility of running out of memory. For this reason, this
scheme is sometimes used in real-time systems.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="#term-static-storage-duration"><em class="xref std std-term">static storage duration</em></a>.</p>
</div>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite terms</p>
<p class="last"><a class="reference internal" href="#term-stack-allocation"><em class="xref std std-term">stack allocation</em></a>, <a class="reference internal" href="h.html#term-heap-allocation"><em class="xref std std-term">heap allocation</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="r.html#term-region-inference"><em class="xref std std-term">region inference</em></a>, <a class="reference internal" href="#term-static-memory-2"><em class="xref std std-term">static memory<sup>(2)</sup></em></a>.</p>
</div>
</dd>
<dt id="term-static-memory-1">static memory<sup>(1)</sup></dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>static RAM</em>, <em>SRAM</em>.</p>
</div>
<p>Static <a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a> or static RAM (SRAM) is a type of
<a class="reference internal" href="p.html#term-physical-memory-2"><em class="xref std std-term">physical memory<sup>(2)</sup></em></a> that does not need to be refreshed
periodically to avoid losing state.</p>
<p>Static memory is typically faster than <a class="reference internal" href="d.html#term-dynamic-memory"><em class="xref std std-term">dynamic memory</em></a>,
or requires essentially no power to preserve its state, but
rarely both. These benefits result in static RAM being used
for <a class="reference internal" href="c.html#term-cache-1"><em class="xref std std-term">cache<sup>(1)</sup></em></a> memory, and also in portable, low-power
applications (such as PDAs). It is, however, more expensive
than dynamic RAM and requires more transistors, making dynamic
RAM the choice for large amounts of memory (the <a class="reference internal" href="m.html#term-main-memory"><em class="xref std std-term">main
memory</em></a> of desktop machines, for example).</p>
<div class="admonition-opposite-term last admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="d.html#term-dynamic-memory"><em class="xref std std-term">dynamic memory</em></a>.</p>
</div>
</dd>
<dt id="term-static-memory-2">static memory<sup>(2)</sup></dt>
<dd><p class="first">The <a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a> where <a class="reference internal" href="#term-static-allocation"><em class="xref std std-term">statically allocated</em></a> objects are stored is sometimes known as
<em>static memory</em>. In the context of <a class="reference internal" href="g.html#term-garbage-collection"><em class="xref std std-term">garbage collection</em></a>,
the term is used mean memory used to store <a class="reference internal" href="#term-static-object"><em class="xref std std-term">static
objects</em></a>.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#term-static-storage-duration"><em class="xref std std-term">static storage duration</em></a>.</p>
</div>
</dd>
<dt id="term-static-object">static object</dt>
<dd>A static <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> is non-<a class="reference internal" href="m.html#term-moving-garbage-collector"><em class="xref std std-term">moving</em></a>. That is, it is not <a class="reference internal" href="r.html#term-relocation"><em class="xref std std-term">relocated</em></a>
by a <a class="reference internal" href="m.html#term-memory-manager"><em class="xref std std-term">memory manager</em></a>; its <a class="reference internal" href="a.html#term-address"><em class="xref std std-term">address</em></a> does not
change.</dd>
<dt id="term-static-ram">static RAM</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="#term-static-memory-1"><em class="xref std std-term">static memory<sup>(1)</sup></em></a>.</p>
</div>
</dd>
<dt id="term-static-storage-duration">static storage duration</dt>
<dd><p class="first">In <a class="reference internal" href="../mmref/lang.html#term-c"><em class="xref std std-term">C</em></a> and <a class="reference internal" href="../mmref/lang.html#term-6"><em class="xref std std-term">C++</em></a>, the <tt class="docutils literal"><span class="pre">static</span></tt> keyword applied
to a file scope variable or function means it is local to the
file; the <tt class="docutils literal"><span class="pre">static</span></tt> keyword applied to a function or a block
scope variable means it is <a class="reference internal" href="a.html#term-allocate"><em class="xref std std-term">allocated</em></a> and initialized
once only.</p>
<p>Objects declared locally in blocks with the <tt class="docutils literal"><span class="pre">static</span></tt> keyword
are <a class="reference internal" href="a.html#term-allocate"><em class="xref std std-term">allocated</em></a> in <a class="reference internal" href="#term-static-memory-2"><em class="xref std std-term">static memory<sup>(2)</sup></em></a>, and
initialized once (usually by the compiler/linker) instead of
each time the block is entered.</p>
<p>Static variables within functions retain their value between
function invocations, and therefore must form part of the
<a class="reference internal" href="r.html#term-root-set"><em class="xref std std-term">root set</em></a> of any <a class="reference internal" href="c.html#term-collector-1"><em class="xref std std-term">collector<sup>(1)</sup></em></a>.</p>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="a.html#term-automatic-storage-duration"><em class="xref std std-term">automatic storage duration</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="l.html#term-lifetime"><em class="xref std std-term">lifetime</em></a>.</p>
</div>
</dd>
<dt id="term-stepper-function">stepper function</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>visitor function</em>.</p>
</div>
<div class="admonition-in-the-mps last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">A function that will be called on each element in a
collection. For example, a stepper function of type
<a class="reference internal" href="../topic/format.html#mps_formatted_objects_stepper_t" title="mps_formatted_objects_stepper_t"><tt class="xref c c-type docutils literal"><span class="pre">mps_formatted_objects_stepper_t</span></tt></a> can be passed to
<a class="reference internal" href="../topic/format.html#mps_arena_formatted_objects_walk" title="mps_arena_formatted_objects_walk"><tt class="xref c c-func docutils literal"><span class="pre">mps_arena_formatted_objects_walk()</span></tt></a> and it will be
called on all <a class="reference internal" href="f.html#term-formatted-object"><em class="xref std std-term">formatted objects</em></a>
in an <a class="reference internal" href="a.html#term-arena"><em class="xref std std-term">arena</em></a>.</p>
</div>
</dd>
<dt id="term-sticky-reference-count">sticky reference count</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="l.html#term-limited-field-reference-count"><em class="xref std std-term">limited-field reference count</em></a>.</p>
</div>
</dd>
<dt id="term-stop-and-copy-collection">stop-and-copy collection</dt>
<dd><p class="first"><a class="reference internal" href="c.html#term-copying-garbage-collection"><em class="xref std std-term">Copying garbage collection</em></a> that stops the
<a class="reference internal" href="m.html#term-mutator"><em class="xref std std-term">mutator</em></a> while the collector runs.</p>
<div class="figure align-center">
<img alt="Diagram: Two-space collector." src="../_images/two-space.svg" /><p class="caption">Stop-and-copy in a <a class="reference internal" href="t.html#term-two-space-collector"><em class="xref std std-term">two-space collector</em></a>.</p>
</div>
<div class="admonition-opposite-term last admonition">
<p class="first admonition-title">Opposite terms</p>
<p class="last"><a class="reference internal" href="i.html#term-incremental-garbage-collection"><em class="xref std std-term">incremental garbage collection</em></a>,  <a class="reference internal" href="p.html#term-parallel-garbage-collection"><em class="xref std std-term">parallel garbage collection</em></a>.</p>
</div>
</dd>
<dt id="term-storage">storage</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="m.html#term-memory-1"><em class="xref std std-term">memory<sup>(1)</sup></em></a>.</p>
</div>
</dd>
<dt id="term-storage-hierarchy">storage hierarchy</dt>
<dd><div class="admonition-also-known-as first admonition">
<p class="first admonition-title">Also known as</p>
<p class="last"><em>memory hierarchy</em>.</p>
</div>
<p>A typical computer has several different <em>levels</em> of
<a class="reference internal" href="m.html#term-memory-1"><em class="xref std std-term">storage</em></a>. Each level of storage has a
different speed, cost, and size. The levels form a <em>storage
hierarchy</em>, in which the topmost levels (those nearest the
processor) are fastest, most expensive and smallest.</p>
<p>Levels typically include processor <a class="reference internal" href="r.html#term-register"><em class="xref std std-term">registers</em></a>, possibly some levels of <a class="reference internal" href="c.html#term-cache-1"><em class="xref std std-term">cache<sup>(1)</sup></em></a>,
<a class="reference internal" href="m.html#term-main-memory"><em class="xref std std-term">main memory</em></a>, and possibly some levels of
<a class="reference internal" href="b.html#term-backing-store"><em class="xref std std-term">backing store</em></a>.</p>
<p>Each level is commonly used as a <a class="reference internal" href="c.html#term-cache-2"><em class="xref std std-term">cache<sup>(2)</sup></em></a> for the
next level. For instance, <a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual memory</em></a> systems
use main memory as a cache for backing store.</p>
<div class="last figure align-center">
<img alt="Diagram: Storage hierarchy with (typical) relative cost, speed, and size." src="../_images/storage.svg" /><p class="caption">Storage hierarchy with (typical) relative cost, speed, and
size.</p>
</div>
</dd>
<dt id="term-storage-level">storage level</dt>
<dd><p class="first">One level in a <a class="reference internal" href="#term-storage-hierarchy"><em class="xref std std-term">storage hierarchy</em></a>, for instance a
<a class="reference internal" href="c.html#term-cache-1"><em class="xref std std-term">cache<sup>(1)</sup></em></a>, <a class="reference internal" href="m.html#term-main-memory"><em class="xref std std-term">main memory</em></a>, <a class="reference internal" href="b.html#term-backing-store"><em class="xref std std-term">backing store</em></a>,
and so on.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#term-storage-hierarchy"><em class="xref std std-term">storage hierarchy</em></a>.</p>
</div>
</dd>
<dt id="term-storage-management">storage management</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="m.html#term-memory-management"><em class="xref std std-term">memory management</em></a>.</p>
</div>
</dd>
<dt id="term-store-1">store<sup>(1)</sup></dt>
<dd><p class="first">To transfer data from a processor&#8217;s <a class="reference internal" href="r.html#term-register"><em class="xref std std-term">registers</em></a> to <a class="reference internal" href="m.html#term-memory-2"><em class="xref std std-term">memory<sup>(2)</sup></em></a>.</p>
<p>Store can also be used in the more general sense of
transferring data from a part of the <a class="reference internal" href="m.html#term-memory-hierarchy"><em class="xref std std-term">memory hierarchy</em></a>
that is fast to access to one that is slow to access.</p>
<p><tt class="docutils literal"><span class="pre">STORE</span></tt> (or an abbreviation) is also commonly used in many
processor architectures as the mnemonic for the machine code
instructions that store data into memory.</p>
<div class="admonition-opposite-term last admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="l.html#term-load"><em class="xref std std-term">load</em></a>.</p>
</div>
</dd>
<dt id="term-store-2">store<sup>(2)</sup></dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="m.html#term-memory-1"><em class="xref std std-term">memory<sup>(1)</sup></em></a>.</p>
</div>
</dd>
<dt id="term-strict-segregated-fit">strict segregated fit</dt>
<dd><p class="first">A <a class="reference internal" href="#term-segregated-fit"><em class="xref std std-term">segregated fit</em></a> <a class="reference internal" href="a.html#term-allocation-mechanism"><em class="xref std std-term">allocation mechanism</em></a> which
has only one block size on each <a class="reference internal" href="f.html#term-free-list"><em class="xref std std-term">free list</em></a>. A requested
block size is rounded up to the next provided size, and the
first block on that list is returned. The sizes must be chosen
so that any block of a larger size can be <a class="reference internal" href="#term-split"><em class="xref std std-term">split</em></a> into a
number of smaller sized blocks. <a class="reference internal" href="b.html#term-buddy-system"><em class="xref std std-term">Buddy systems</em></a> are a special case of strict segregated fit
allocators.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="b.html#term-buddy-system"><em class="xref std std-term">buddy system</em></a>, <a class="reference internal" href="#term-segregated-fit"><em class="xref std std-term">segregated fit</em></a>, <a class="reference internal" href="#term-segregated-free-list"><em class="xref std std-term">segregated free list</em></a>, <a class="reference internal" href="a.html#term-allocation-mechanism"><em class="xref std std-term">allocation mechanism</em></a>.</p>
</div>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publication</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#wil95"><em>Wilson et al. (1995)</em></a>.</p>
</div>
</dd>
<dt id="term-strong-reference">strong reference</dt>
<dd><p class="first">In a <a class="reference internal" href="t.html#term-tracing-garbage-collection"><em class="xref std std-term">tracing garbage collector</em></a>, a strong reference is a <a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">reference</em></a> that
keeps the <a class="reference internal" href="o.html#term-object"><em class="xref std std-term">object</em></a> it refers to <a class="reference internal" href="l.html#term-live"><em class="xref std std-term">alive</em></a>.</p>
<p>A strong reference is the usual sort of reference; The term is
usually used to draw a contrast with <a class="reference internal" href="w.html#term-weak-reference-1"><em class="xref std std-term">weak reference<sup>(1)</sup></em></a>.</p>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="w.html#term-weak-reference-1"><em class="xref std std-term">weak reference<sup>(1)</sup></em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#term-strong-root"><em class="xref std std-term">strong root</em></a>.</p>
</div>
</dd>
<dt id="term-strong-root">strong root</dt>
<dd><p class="first">A strong root is a <a class="reference internal" href="r.html#term-root"><em class="xref std std-term">root</em></a> such that all
<a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">references</em></a> in it are <a class="reference internal" href="#term-strong-reference"><em class="xref std std-term">strong references</em></a>.</p>
<p>A strong root is the usual sort of root. The term is usually
used to draw a contrast with <a class="reference internal" href="w.html#term-weak-root"><em class="xref std std-term">weak root</em></a>.</p>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="w.html#term-weak-root"><em class="xref std std-term">weak root</em></a>.</p>
</div>
<div class="admonition-in-the-mps last admonition">
<p class="first admonition-title">In the MPS</p>
<p class="last">Strong roots have <a class="reference internal" href="r.html#term-rank"><em class="xref std std-term">rank</em></a> <a class="reference internal" href="../topic/root.html#mps_rank_ambig" title="mps_rank_ambig"><tt class="xref c c-func docutils literal"><span class="pre">mps_rank_ambig()</span></tt></a> or
<a class="reference internal" href="../topic/root.html#mps_rank_exact" title="mps_rank_exact"><tt class="xref c c-func docutils literal"><span class="pre">mps_rank_exact()</span></tt></a>.</p>
</div>
</dd>
<dt id="term-strong-tri-color-invariant"><span id="term-strong-tri-colour-invariant"></span><span id="term-strong-tricolor-invariant"></span><span id="term-strong-tricolour-invariant"></span>strong tri-color invariant<br />strong tri-colour invariant<br />strong tricolor invariant<br />strong tricolour invariant</dt>
<dd><p class="first">The strong <a class="reference internal" href="t.html#term-tri-color-invariant"><em class="xref std std-term">tri-color invariant</em></a> is the property of a
<a class="reference internal" href="r.html#term-reference"><em class="xref std std-term">reference</em></a> <a class="reference internal" href="g.html#term-graph"><em class="xref std std-term">graph</em></a> that there is no <a class="reference internal" href="e.html#term-edge"><em class="xref std std-term">edge</em></a>
from a <a class="reference internal" href="b.html#term-black"><em class="xref std std-term">black</em></a> <a class="reference internal" href="n.html#term-node"><em class="xref std std-term">node</em></a> to a <a class="reference internal" href="w.html#term-white"><em class="xref std std-term">white</em></a> node.</p>
<p>By preserving this property throughout <a class="reference internal" href="t.html#term-tri-color-marking"><em class="xref std std-term">tri-color
marking</em></a>, a <a class="reference internal" href="t.html#term-trace"><em class="xref std std-term">tracing</em></a> algorithm can ensure that
the <a class="reference internal" href="c.html#term-collector-2"><em class="xref std std-term">collector<sup>(2)</sup></em></a> will not miss reachable objects,
even if the <a class="reference internal" href="m.html#term-mutator"><em class="xref std std-term">mutator</em></a> manipulates the graph during the
collection. This invariant can also be used to ensure that a
<a class="reference internal" href="c.html#term-copying-garbage-collection"><em class="xref std std-term">copying garbage collector</em></a>
doesn&#8217;t confuse the mutator. Mutator actions might need to
change the <a class="reference internal" href="c.html#term-color"><em class="xref std std-term">color</em></a> of the nodes affected in order to
preserve the invariant.</p>
<p>Algorithms using this invariant are <a class="reference internal" href="i.html#term-incremental-update"><em class="xref std std-term">incremental update</em></a>
algorithms.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="t.html#term-tri-color-invariant"><em class="xref std std-term">tri-color invariant</em></a>.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="b.html#term-barrier-1"><em class="xref std std-term">barrier<sup>(1)</sup></em></a>, <a class="reference internal" href="w.html#term-weak-tri-color-invariant"><em class="xref std std-term">weak tri-color invariant</em></a>.</p>
</div>
<div class="admonition-related-publication last admonition">
<p class="first admonition-title">Related publications</p>
<p class="last"><a class="reference internal" href="../mmref/bib.html#johnstone97"><em>Johnstone (1997)</em></a>, <a class="reference internal" href="../mmref/bib.html#pirinen98"><em>Pirinen (1998)</em></a>.</p>
</div>
</dd>
<dt id="term-strongly-reachable">strongly reachable</dt>
<dd><p class="first">In <a class="reference internal" href="../mmref/lang.html#term-java"><em class="xref std std-term">Java</em></a>, an object is <em>strongly reachable</em>, if there
is a path from the <a class="reference internal" href="r.html#term-root"><em class="xref std std-term">roots</em></a> to it that contains
only <a class="reference internal" href="#term-strong-reference"><em class="xref std std-term">strong references</em></a>, that is,
contains no <a class="reference internal" href="r.html#term-reference-object"><em class="xref std std-term">reference objects</em></a>.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="r.html#term-reachable"><em class="xref std std-term">reachability</em></a>, <a class="reference internal" href="#term-softly-reachable"><em class="xref std std-term">softly reachable</em></a>, <a class="reference internal" href="w.html#term-weakly-reachable"><em class="xref std std-term">weakly reachable</em></a>, <a class="reference internal" href="p.html#term-phantom-reachable"><em class="xref std std-term">phantom reachable</em></a>.</p>
</div>
<div class="admonition-related-link last admonition">
<p class="first admonition-title">Related link</p>
<p class="last"><a class="reference external" href="http://pawlan.com/monica/articles/refobjs/">Reference Objects and Garbage Collection</a>.</p>
</div>
</dd>
<dt id="term-suballocator">suballocator</dt>
<dd><p class="first">A <em>suballocator</em> is an <a class="reference internal" href="a.html#term-allocator"><em class="xref std std-term">allocator</em></a> functioning on top of
another allocator.</p>
<p>Suballocators work by <a class="reference internal" href="a.html#term-allocate"><em class="xref std std-term">allocating</em></a> large
<a class="reference internal" href="b.html#term-block"><em class="xref std std-term">blocks</em></a> and <a class="reference internal" href="#term-split"><em class="xref std std-term">splitting</em></a> them for
use, or by <a class="reference internal" href="r.html#term-recycle"><em class="xref std std-term">recycling</em></a> blocks locally.</p>
<p class="last">Application programmers sometimes write their own
suballocators when faced with an inefficient or inadequate
<a class="reference internal" href="m.html#term-memory-manager"><em class="xref std std-term">memory manager</em></a>. Suballocators can take advantage of
special knowledge of program behavior, but are less efficient
in general than fixing the underlying allocator, mainly
because <a class="reference internal" href="m.html#term-memory-management"><em class="xref std std-term">memory management</em></a> is a <em>global</em> issue for an
application, and a global strategy can make a big difference.
For example, different suballocators can interact
catastrophically with each other and with the <a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual
memory</em></a> system, causing the application&#8217;s memory
requirements to grow unnecessarily due to
<a class="reference internal" href="f.html#term-fragmentation"><em class="xref std std-term">fragmentation</em></a>.</p>
</dd>
<dt id="term-subgraph">subgraph</dt>
<dd>A subgraph S of a <a class="reference internal" href="g.html#term-graph"><em class="xref std std-term">graph</em></a> G is a graph such that all the
<a class="reference internal" href="n.html#term-node"><em class="xref std std-term">nodes</em></a> in S are also in G and all the
<a class="reference internal" href="e.html#term-edge"><em class="xref std std-term">edges</em></a> in S are also in G; that is, it is a part
of a graph.</dd>
<dt id="term-superpage">superpage</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="h.html#term-huge-page"><em class="xref std std-term">huge page</em></a>.</p>
</div>
</dd>
<dt id="term-sure-reference">sure reference</dt>
<dd><div class="admonition-see first last admonition">
<p class="first admonition-title">See</p>
<p class="last"><a class="reference internal" href="e.html#term-exact-reference"><em class="xref std std-term">exact reference</em></a>.</p>
</div>
</dd>
<dt id="term-swap-space">swap space</dt>
<dd><p class="first"><a class="reference internal" href="b.html#term-backing-store"><em class="xref std std-term">Backing store</em></a> used by a <a class="reference internal" href="#term-swapping"><em class="xref std std-term">swapping</em></a> system.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#term-swapping"><em class="xref std std-term">swapping</em></a>, <a class="reference internal" href="b.html#term-backing-store"><em class="xref std std-term">backing store</em></a>.</p>
</div>
</dd>
<dt id="term-swapped-in">swapped in</dt>
<dd><p class="first">A process or <a class="reference internal" href="p.html#term-page"><em class="xref std std-term">page</em></a> is <em>swapped in</em> if it is available
in <a class="reference internal" href="p.html#term-physical-memory-1"><em class="xref std std-term">physical memory<sup>(1)</sup></em></a>. This usually applies to the
entire program image.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="p.html#term-paged-in"><em class="xref std std-term">paged in</em></a>.</p>
</div>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="#term-swapped-out"><em class="xref std std-term">swapped out</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#term-swapping"><em class="xref std std-term">swapping</em></a>.</p>
</div>
</dd>
<dt id="term-swapped-out">swapped out</dt>
<dd><p class="first">A process or <a class="reference internal" href="p.html#term-page"><em class="xref std std-term">page</em></a> is <em>swapped out</em> if it is not
available in <a class="reference internal" href="p.html#term-physical-memory-1"><em class="xref std std-term">physical memory<sup>(1)</sup></em></a>. This usually applies
to the entire program image.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="p.html#term-paged-out"><em class="xref std std-term">paged out</em></a>.</p>
</div>
<div class="admonition-opposite-term admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="#term-swapped-in"><em class="xref std std-term">swapped in</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#term-swapping"><em class="xref std std-term">swapping</em></a>.</p>
</div>
</dd>
<dt id="term-swapping">swapping</dt>
<dd><p class="first">Historically, swapping was the technique of moving entire
program images to disk (or drum) and back into <a class="reference internal" href="p.html#term-physical-memory-1"><em class="xref std std-term">physical
memory<sup>(1)</sup></em></a>, an early form of <a class="reference internal" href="v.html#term-virtual-memory"><em class="xref std std-term">virtual memory</em></a>.
Nowadays, it is used as a synonym for <a class="reference internal" href="p.html#term-paging"><em class="xref std std-term">paging</em></a>.</p>
<div class="admonition-similar-term admonition">
<p class="first admonition-title">Similar term</p>
<p class="last"><a class="reference internal" href="p.html#term-paging"><em class="xref std std-term">paging</em></a>.</p>
</div>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#term-swapped-in"><em class="xref std std-term">swapped in</em></a>, <a class="reference internal" href="#term-swapped-out"><em class="xref std std-term">swapped out</em></a>.</p>
</div>
</dd>
<dt id="term-sweeping">sweeping</dt>
<dd><p class="first">Sweeping is the second phase (&#8220;the sweep phase&#8221;) of the
<a class="reference internal" href="m.html#term-mark-sweep"><em class="xref std std-term">mark-sweep</em></a> algorithm. It performs a sequential
(address-order) pass over memory to <a class="reference internal" href="r.html#term-recycle"><em class="xref std std-term">recycle</em></a> unmarked
blocks.</p>
<p>Sweeping typically gathers all unmarked blocks into one or
more <a class="reference internal" href="f.html#term-free-list"><em class="xref std std-term">free lists</em></a>.</p>
<div class="admonition-see-also last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="m.html#term-marking"><em class="xref std std-term">marking</em></a>.</p>
</div>
</dd>
<dt id="term-synchronous-garbage-collector">synchronous garbage collector</dt>
<dd><p class="first">A <a class="reference internal" href="c.html#term-collector-2"><em class="xref std std-term">collector<sup>(2)</sup></em></a> is asynchronous with respect to the
<a class="reference internal" href="m.html#term-mutator"><em class="xref std std-term">mutator</em></a> if it runs at predictable times, for example
only when a collection function is called.</p>
<p>This means that mutator need not ensure that <a class="reference internal" href="f.html#term-formatted-object"><em class="xref std std-term">formatted
objects</em></a> are always <a class="reference internal" href="#term-scan"><em class="xref std std-term">scannable</em></a>, as long as it
makes them scannable before the collector runs.</p>
<div class="admonition-opposite-term last admonition">
<p class="first admonition-title">Opposite term</p>
<p class="last"><a class="reference internal" href="a.html#term-asynchronous-garbage-collector"><em class="xref std std-term">asynchronous garbage collector</em></a>.</p>
</div>
</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="r.html"
                        title="previous chapter">Memory Management Glossary: R</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="t.html"
                        title="next chapter">Memory Management Glossary: T</a></p><h4>Downloads</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/release/1.111.0/">MPS Kit release 1.111.0</a><br>
<a href="http://www.ravenbrook.com/project/mps/release/">All MPS Kit releases</a>
</p>

<h4>Issues</h4>

<p class="topless">
<a href="http://www.ravenbrook.com/project/mps/issue/?action=list&amp;view=status%3dopen&amp;display=Job:Priority:Title&amp;sort=Priority">Known issues</a><br>
<a href="http://www.ravenbrook.com/project/mps/issue/?action=fixed&release_fixed=1.111.0">Issues fixed in release 1.111.0</a>
</p><h4>Contact us</h4>

<p class="topless"><a href="mailto:mps-questions@ravenbrook.com">mps-questions@ravenbrook.com</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="t.html" title="Memory Management Glossary: T"
             >next</a> |</li>
        <li class="right" >
          <a href="r.html" title="Memory Management Glossary: R"
             >previous</a> |</li>
        <li><a href="../index.html">Memory Pool System 1.111.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Memory Management Glossary</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2013, Ravenbrook Limited.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>