TODO

 2. Create new types of objects for pools and topics.
 
 3. Glossary entries need permalinks. See 
    <https://bitbucket.org/birkenfeld/sphinx/issue/996/expose-glossary-entry-link-on-hover>
 
 5. Fix the general index so that (1) aren't interpreted as
    subentries.
 
 7. Re-do the diagrams in vector form and using the colour palette.
 
 8. Use a better bibliography extension. See for example
    <http://wnielson.bitbucket.org/projects/sphinx-natbib/>
 
 9. Hyphenate long function names across line endings (but what if you
    copy them?)

11. Support MMREF-style anchors to the glossary (#garbage.collection
    instead of #garbage-collection).


QUERIES

 1. Does the object format description (struct mps_fmt_A_s etc) have
    to be static? Is it OK to throw it away after calling
    mps_fmt_create?

    Same question for the generation structure (mps_gen_param_s)?
 
 2. What is the difference, if any, between mps_word_t and MPS_T_WORD?
 
 3. How can I explain why the Scheme example uses sizeof(mps_word_t)
    as its alignment? Why not MPS_PF_ALIGN (or are client programs not
    supposed to look at mpstd.h)? Why not something of its own
    manufacture, like sizeof(union {long, size_t, void*})?
 
 4. Why does the Scheme example have a copy method in its object
    format when the reference manual says it's obsolete?

    I removed it.
 
 5. What is the difference between the "event stream" and the
    "telemetry stream"? Are these names for the same thing? Or is
    there a distinction (for example, "event stream" refers to the
    internal, unfiltered, stream of events and "telemetry stream"
    refers to the filtered stream)?
 
 6. The location dependency functions all take an arena as an
    argument. What is the role of this argument?
 
 7. What is the role of the third (addr) argument to mps_ld_isstale?
    LDIsStale says "UNUSED(addr);" so maybe it is unused.
 
 8. Is the material in the pool class comparison table at all accurate?
 
 9. This code seems a bit confused about what to do:

        assert(0);
        fprintf(stderr, "Unexpected object on the heap\n");
        abort();
        return MPS_RES_FAIL;

    I took out the assertion and the return.

10. How does fixing interact with tagged references? Do I need to
    remove the tag before fixing a reference? Do I need to restore the
    tag afterwards? I thought that both would be necessary but the
    critical path documentation has an example from OpenDylan with
    tagged references that does neither:
    <//info.ravenbrook.com/project/mps/master/design/critical-path.txt>

11. This code from mps_chat in the Scheme example is wrong:

        if (type == mps_message_type_gc_start()) {
          printf("Collection %lu started.\n", (unsigned long)mps_collections(arena));

    mps_collections returns the total number of collections to date,
    not the number of the collection that posted the message. This
    means that if there have been multiple collections since the last
    time the message queue was emptied, the output will look like

        Collection 47 started.
          ...
        Collection 47 started.
          ...
        Collection 47 started.
          ...
        Collection 47 started.

12. It seems "tricky" to re-use fowarding objects as padding objects
    by setting their forwarding pointer to NULL. It would be simpler
    to explain if we had TYPE_PAD for multiple-word padding objects.
    There's enough to explain as it is!

    I made this change.

13. The Scheme example says, "Adapting it to use the MPS took
    approximately two hours". I doubt this would be the common case,
    and it would be better to under-promise and over-deliver.

14. I need to document the values in mps_gen_param_s. I believe they
    are the capacity (size of the generation in kilobytes) and the
    mortality (the proportion of objects in this generation that are
    expected to die in a collection). But what do they mean to the
    MPS? And how should one go about choosing values?


DONE

1. Create a new domain
   <http://sphinx.pocoo.org/ext/appapi.html#sphinx.domains.Domain>

4. Make (1), (2) etc into superscripts

6. Identify :term: references that point to "see" cross-references.

10. Pluralize "Topic" to "Topics" and so on.
