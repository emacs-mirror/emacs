<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>

<title>GC Messages</title>

</head>

<body bgcolor="#FFFFFF" text="#000000" link="#000099" vlink="#660066" alink="#FF0000">

<div align="center">

<p>
<a href="/">Ravenbrook</a> /
<a href="/project/">Projects</a> /
<a href="/project/mps/">Memory Pool System</a> /
<a href="/project/mps/master/">Master Product Sources</a> /
<a href="/project/mps/master/design/">Design Documents</a>
</p>

<p><i><a href="/project/mps/">Memory Pool System Project</a></i></p>

<hr />

<h1>GC Messages</h1>

<address>
<a href="mailto:drj@ravenbrook.com">David Jones</a>,
<a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>,
2003-02-17
</address>

</div>

<p>Design of MPS GC messages:</p>
<ul>
  <li><code>mps_message_type_gc_start()</code>;</li>
  <li><code>mps_message_type_gc()</code>.</li>
</ul>
<p>MPS source code and this document call these "<b>trace start</b>" and "<b>trace end</b>" messages.</p>

<p>Readership: any MPS developer.  Not confidential.</p>


<h2><a id="section-1" name="section-1">1. Introduction</a></h2>

<p>Implementation is mostly in the source file "<code><b>traceanc.c</b></code>".</p>

<p>The "<b>_gc_start</b>" message is implemented internally by the "<b>trace start</b>" message.  The principal names are:</p>

<blockquote><pre>
Internal names:
  <b>trace start</b>
  TraceStartMessage, tsMessage (struct *)
  arena->tsMessage[ti]
  MessageTypeGCSTART (enum)

External names:
  <b>mps_message_type_gc_start</b> (enum macro)
  MPS_MESSAGE_TYPE_GC_START (enum)

</pre></blockquote>


<p>The "<b>_gc</b>" message is implemented internally by the "<b>trace end</b>" message.  The principal names are:</p>
  
<blockquote><pre>
Internal names:
  <b>trace end</b>
  TraceMessage, tMessage (struct *)
  arena->tMessage[ti]
  MessageTypeGC (enum)

External names:
  <b>mps_message_type_gc</b> (enum macro)
  MPS_MESSAGE_TYPE_GC (enum)
</pre></blockquote>

<em class="note"><p>Note: the names of these messages are unconventional (or 'wrong'); they should properly be called "gc (or trace) <b>begin</b>" and "gc (or trace) <b>end</b>".  But it's much too late to change them now.  RHSK 2008-12-15</p></em>

<p>Collectively, the trace-start and trace-end messages are called the "<b>trace id messages</b>", and they are managed by the following functions:</p>
  
<blockquote><pre>
Internal names:
  TraceIdMessagesCheck
  TraceIdMessagesCreate
  TraceIdMessagesDestroy
</pre></blockquote>

<p>The currently supported message-field accessor methods are:</p>
<ul>
	<li>mps_message_gc_start_why</li>
	<li>mps_message_gc_live_size</li>
	<li>mps_message_gc_condemned_size</li>
	<li>mps_message_gc_not_condemned_size</li>
</ul>
<p>These are documented in the <a href="../../manual/reference/">Reference Manual</a>.</p>


<h2><a id="section-2" name="section-2">2. Purpose</a></h2>

<p>The purpose of these messages is to allow the client program to be aware of GC activity, in order to:</p>
<ul>
	<li>adjust its own behaviour;</li>
	<li>show or report GC activity in some appropriate 'custom' way, such as an in-client display (perhaps to help client-developers), in a log file, etc.</li>
</ul>

<p>While there is some overlap with the <a href="../diag/">Diagnostic Feedback</a> system, the main contrasts are that these GC messages are present in all MPS varieties, are stable from release to release, and are designed to be parsed by the client program.</p>


<h2><a id="section-3" name="section-3">3. Lifecycle</a></h2>

<p><b>Overview</b>: for each trace id, pre-allocate a pair of start/end messages (with ControlAlloc).  Then, when a trace runs using that trace id, fill-in and post these messages.  When the trace completes, and has posted both messages, it immediately pre-allocates a new pair of messages, which wait in readiness for the next trace using that trace id.</p>


<h3><a id="section-3.1" name="section-3.1">3.1 Requirements</a></h3>

<p><a id=".no-start-alloc"><b>.no-start-alloc:</b></a> Should avoid attempting to allocate memory at trace start time.</p>

<p><a id=".no-start-alloc.why">.no-start-alloc.why:</a> There may be no free memory at trace start time.  Client would still like to hear about collections in those circumstances.</p>

<p><a id=".queue"><b>.queue:</b></a> Must support a client that enables, but does not promptly get, GC messages.  Ungot messages must remain queued, and the client must be able to get them later without loss.  It is not acceptable to stop issuing GC messages for subsequent collections merely because messages from previous collections have not yet been got.</p>

<p><a id=".queue.why">.queue.why:</a> This is because there is simply no reasonable way for a client to guarantee that it always promptly collects GC messages.</p>

<p><a id=".match"><b>.match:</b></a> Start and end messages should always match up: never post one of the messages but fail to post the matching one.</p>

<p><a id=".match.why">.match.why:</a> This makes client code much simpler -- it does not have to handle mismatching messages.</p>

<p><a id=".errors-not-direct"><b>.errors-not-direct:</b></a> Errors (such as a ControlAlloc failure) cannot be reported directly to the client, because collections often happen automatically, without an explicit client call to the MPS interface.</p>

<p><a id=".simultaneous"><b>.simultaneous:</b></a> Up to TraceLIMIT traces may be running, and emitting start/end messages, simultaneously.</p>

<p><a id=".early"><b>.early:</b></a> Nice to tell client as much as possible about the collection in the start message, if we can.</p>


<h3><a id="section-3.2" name="section-3.2">3.2 Implementation</a></h3>

<p>For each trace-id (<a href=".simultaneous">.simultaneous</a>)
 a pair (<a href=".match">.match</a>)
 of start/end messages is 
dynamically allocated (<a href=".queue">.queue</a>)
in advance (<a href=".no-start-alloc">.no-start-alloc</a>).
Messages are allocated using ControlAlloc.</p>

<p><em class="note">(Previous implementations of the trace start message used static allocation.  This does not meet .queue, and also led to nasty bugs -- see job001570 and job001989.  RHSK 2008-12-15.)</em></p>

<p>	Pointers to these messages are stored in arrays (<code>tsMessage[ti]</code> and <code>tMessage[ti]</code>) in the ArenaStruct.</p>

<p><em class="note">(We <b>cannot</b> keep the pre-allocated messages in the TraceStructs: although TraceStructs are statically allocated, they are re-initialised by TraceCreate <b>each time</b> they are used.  RHSK 2008-12-15.)</em></p>

<p>At ArenaCreate time we TRACE_SET_ITER to initialise the pointers to NULL, and then (when the control pool is ready) TRACE_SET_ITER calling TraceIdMessagesCreate.  This performs the <b>initial pre-allocation</b> of the trace start/end messages for each trace id.  Allocation failure here makes ArenaCreate fail with an error code -- the arena is too small.</p>

<p>When the first trace runs, it fills-in and posts a message, and nulls-out the pointer to it from the ArenaStruct.  The message is only reachable from the arena message queue (but the control pool also knows about it).</p>

<p>If the client has not enabled that message type, the message is discarded immediately, calling ControlFree and reclaiming the memory.</p>

<p>If the client has enabled but never gets the message, it remains on the message queue until ArenaDestroy.  (At ArenaDestroy any ungot messages are destroyed, freeing the memory).  Theoretically these messages could accumulate forever until they exhaust memory.  (This is 'intentional'; the client should not enable a message type and then never get it!)</p>

<p>Otherwise, when the client gets a message, it is dropped from the arena message queue: only the client (and the control pool) hold references to it.  The client must call mps_message_discard once it has finished using the message.  This calls ControlFree and reclaims the memory.  (If the client simply drops its reference, the memory will not be reclaimed until ArenaDestroy; this is intentional -- the control pool is not garbage-collected).  At ArenaDestroy the control pool is destroyed, which frees any still un-discarded messages.</p>

<p>When the trace completes, it calls TraceIdMessagesCreate for its trace id.  This performs the <b>ongoing pre-allocation</b> of the trace start/end messages for this trace id.</p>

<p>Hopefully, after a trace has completed, some memory will have been reclaimed and the ControlAllocs will succeed.  But they may not, and allocation failure here is permitted: if it happens, <b>both</b> the start and the end messages are freed (if present) (<a href=".match">.match</a>).  There is no direct way to report this failure to the client (<a href=".errors-not-direct">.errors-not-direct</a>), so we just increment the "droppedMessages" counter in the ArenaStruct.  Currently this is not reported to the client (except via ArenaDescribe in diagnostic varieties).</p>

<p>At ArenaDestroy, we TRACE_SET_ITER calling TraceIdMessagesDestroy which calls ControlFree on the remaining pre-allocated messages.  In other words this performs the <b>final clearup</b>of pre-allocated messages.</p>


<h2><a id="section-6" name="section-6">6. Testing</a></h2>

<p> amcss already collects and reports mps_message_type_gc.  It should
be simple to extend it to mps_message_type_gc_start and
mps_message_type_gc_generation.  </p>

<p> Using amcss might not give a very good coverage.  In particular not
all the available reasons will appear.  Perhaps a more dedicated test
should be written. </p>


<h2><a id="section-7" name="section-7">7. Unimplemented mps_message_type_gc_generation</a></h2>

<p><em>This section for historical interest only.</em></p>

<p> A proposal to more fully meet the primary requirement by implementing a message
that is generated per generation per collection
(mps_message_type_gc_generation) 
<strong>has not been implemented</strong>, 
but the requirements have been retained here: </p>

<p>We would have the
following requirements on per generation messages: </p>

<ul>

  <li><p> Must be able to tell for any generation whether it is
  condemned for each collection that occurs.  In practise, due to the
  flexible nature of the MPS, a generation might not be either
  all-condemned or all-foundation for any particular collection.  In
  particular the commonest sort of collection (collections driven by
  allocation in the nursery generations) will condemn a particular set
  of zones. There may be generations which have some object in one zone
  and some objects in another; they may have only some of their objects
  condemned by a per zone condemnation strategy. </p></li>

  <li>
  <p> For each generation for each collection we would like
    to know the following:  </p>

  <ul>

    <li><p> Number of bytes condemned in this generation. </p></li>

    <li><p> Number of bytes occupied by objects and not condemned.  </p></li>

    <li><p> Where survivors are going (that is, what generation are
    survivors are being promoted to. </p></li>

    <li><p> (Not essential) Other byte counts for this generation: How
    much free space there is, how much overhead there is. </p></li>

  </ul>
  </li>

</ul>


<h2><a id="section-A" name="section-A">A. References</a></h2>

<!-- Template Entry

<table>

<tr valign="top">

<td>[<a id="ref-#REF#" name="ref-#REF#" href="#REF_URL#">#REF_NAME#</a>]</td>

<td>
  "#REF_TITLE#";
  #REF_AUTHOR#;
  &lt;URL: <a href="#REF_URL#">#REF_URL#</a>&gt;;
  #REF_DATE#.
</td>

</tr>

</table>

-->

<h2><a id="section-B" name="section-B">B. Document History</a></h2>

<table>

<tr valign="top">

<td>2003-02-17</td>

<td><a href="mailto:drj@ravenbrook.com">DRJ</a></td>

<td>Created.</td>

</tr>

<tr valign="top">
<td>2006-12-07</td>
<td><a href="mailto:rhsk@ravenbrook.com">RHSK</a></td>
<td>Remove mps_message_type_gc_generation (not implemented).</td>
</tr>

<tr valign="top">
<td>2007-02-08</td>
<td><a href="mailto:rhsk@ravenbrook.com">RHSK</a></td>
<td>Move historically interesting requirements for mps_message_type_gc_generation (not implemented) to the end of the doc.</td>
</tr>

</table>


<h2><a id="section-C" name="section-C">C. Copyright and License</a></h2>

<p> This document is copyright &copy; 1995-2002, 2006-2007 <a
href="http://www.ravenbrook.com/">Ravenbrook Limited</a>.  All rights
reserved.  This is an open source license.  Contact Ravenbrook for
commercial licensing options. </p>

<p> Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met: </p>

<ol>

<li> Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer. </li>

<li> Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution. </li>

<li> Redistributions in any form must be accompanied by information
on how to obtain complete source code for the this software and any
accompanying software that uses this software.  The source code must
either be included in the distribution or be available for no more
than the cost of distribution plus a nominal fee, and must be freely
redistributable under reasonable conditions.  For an executable file,
complete source code means the source code for all modules it contains. It
does not include source code for modules or files that typically accompany
the major components of the operating system on which the executable
file runs. </li>

</ol>

<p> <strong> This software is provided by the copyright holders and contributors "as is" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability, fitness for a particular purpose, or non-infringement, are disclaimed.  In no event shall the copyright holders and contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. </strong> </p>


<hr />

<div align="center">

<p><code>$Id: //info.ravenbrook.com/project/mps/branch/2003-02-17/gcgenmsg/design/message/index.html#1 $</code></p>

<p>
<a href="/">Ravenbrook</a> /
<a href="/project/">Projects</a> /
<a href="/project/mps/">Memory Pool System</a> /
<a href="/project/mps/master/">Master Product Sources</a> /
<a href="/project/mps/master/design/">Design Documents</a>
</p>

</div>

</body>

</html>
