<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>

<title>GC Messages</title>

</head>

<body bgcolor="#FFFFFF" text="#000000" link="#000099" vlink="#660066" alink="#FF0000">

<div align="center">

<p>
<a href="/">Ravenbrook</a> /
<a href="/project/">Projects</a> /
<a href="/project/mps/">Memory Pool System</a> /
<a href="/project/mps/master/">Master Product Sources</a> /
<a href="/project/mps/master/design/">Design Documents</a>
</p>

<p><i><a href="/project/mps/">Memory Pool System Project</a></i></p>

<hr />

<h1>GC Messages</h1>

<address>
<a href="mailto:rhsk@ravenbrook.com">Richard Kistruck</a>,
<a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>,
2008-12-19
</address>

<address>
(previous version: <a href="mailto:drj@ravenbrook.com">David Jones</a>,
<a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>,
2003-02-17)
</address>

</div>

<p>Design of MPS GC messages:</p>
<ul>
  <li><code>mps_message_type_gc_start()</code>;</li>
  <li><code>mps_message_type_gc()</code>.</li>
</ul>
<p>They are called "<b>trace start</b>" and "<b>trace end</b>" messages in this document and in most MPS source code.</p>

<p>Readership: any MPS developer.  Not confidential.</p>

<p>(For a guide to the MPS message system in general, see <a href="../message/">&lt;design/message&gt;</a>.)</p>


<h2><a id="introduction" name="introduction">Introduction</a></h2>

<p>The MPS posts a <b>trace start</b> message (<code>_gc_start</code>) near the start of every trace (but after calculating the condemned set, so we can report how large it is).</p>

<p>The MPS posts a <b>trace end</b> message (<code>_gc</code>) near the end of every trace.</p>

<p>These messages are extremely flexible: they can hold arbitrary additional data simply by writing new accessor functions.  If there is more data to report at either of these two events, then there is a good argument for adding it into these existing messages.</p>

<p><em class="note">(Note: in previous versions of this design document, there was a partial unimplemented design for a "<code>_gc_generation</code>" message.  I would argue that this would not have been a good design, because managing and collating multiple messages is much more complex for both MPS and client than using a single message.  RHSK 2008-12-19.)</em></p>


<h2><a id="purpose" name="purpose">Purpose</a></h2>

<p>The purpose of these messages is to allow the client program to be aware of GC activity, in order to:</p>
<ul>
	<li>adjust its own behaviour programmatically;</li>
	<li>show or report GC activity in some appropriate 'custom' way, such as an in-client display, in a log file, etc.  The main message content should be intelligible and helpful to client-developers (with help from MPS staff if necessary).  There may be extra content that is only meaningful to MPS staff, to help us diagnose client problems.</li>
</ul>

<p>While there is some overlap with the <a href="../diag/">Diagnostic Feedback</a> system, the main contrasts are that these GC messages are present in release builds, are stable from release to release, and are designed to be parsed by the client program.</p>


<h2><a id="names-parts" name="names-parts">Names and Parts</a></h2>

<p>Here's a helpful list of the names used in the GC message system:</p>

<p>Implementation is mostly in the source file "<code><b>traceanc.c</b></code>" (trace ancillary).</p>

<p>The "<b>_gc_start</b>" message is implemented internally by the "<b>trace start</b>" message.  The principal names are:</p>

<blockquote><pre>
Internal names:
  <b>trace start</b>
  TraceStartMessage, tsMessage (struct *)
  arena->tsMessage[ti]
  MessageTypeGCSTART (enum)

External names:
  <b>mps_message_type_gc_start</b> (enum macro)
  MPS_MESSAGE_TYPE_GC_START (enum)
</pre></blockquote>


<p>The "<b>_gc</b>" message is implemented internally by the "<b>trace end</b>" message.  The principal names are:</p>
  
<blockquote><pre>
Internal names:
  <b>trace end</b>
  TraceMessage, tMessage (struct *)
  arena->tMessage[ti]
  MessageTypeGC (enum)

External names:
  <b>mps_message_type_gc</b> (enum macro)
  MPS_MESSAGE_TYPE_GC (enum)
</pre></blockquote>

<p><em class="note">Note: the names of these messages are unconventional; they should properly be called "gc (or trace) <b>begin</b>" and "gc (or trace) <b>end</b>".  But it's much too late to change them now.  RHSK 2008-12-15</em></p>

<p>Collectively, the trace-start and trace-end messages are called the "<b>trace id messages</b>", and they are managed by the following functions:</p>
  
<blockquote><pre>
Internal names:
  TraceIdMessagesCheck
  TraceIdMessagesCreate
  TraceIdMessagesDestroy
</pre></blockquote>

<p>The currently supported message-field accessor methods are:</p>

<blockquote><pre>
External names:
  mps_message_gc_start_why
  mps_message_gc_live_size
  mps_message_gc_condemned_size
  mps_message_gc_not_condemned_size
</pre></blockquote>

<p>These are documented in the <a href="../../manual/reference/">Reference Manual</a>.</p>


<h2><a id="lifecycle" name="lifecycle">Lifecycle</a></h2>

<p><b>Overview</b>: for each trace id, pre-allocate a pair of start/end messages (with ControlAlloc).  Then, when a trace runs using that trace id, fill-in and post these messages.  As soon as the trace has posted both messages, immediately pre-allocate a new pair of messages, which wait in readiness for the next trace to use that trace id.</p>


<h3><a id="requirements" name="requirements">Requirements</a></h3>

<p><a id="no-start-alloc"><b>.no-start-alloc:</b></a> Should avoid attempting to allocate memory at trace start time.</p>

<p><a id="no-start-alloc.why">.no-start-alloc.why:</a> There may be no free memory at trace start time.  Client would still like to hear about collections in those circumstances.</p>

<p><a id="queue"><b>.queue:</b></a> Must support a client that enables, but does not promptly get, GC messages.  Ungot messages must remain queued, and the client must be able to get them later without loss.  It is not acceptable to stop issuing GC messages for subsequent collections merely because messages from previous collections have not yet been got.</p>

<p><a id="queue.why">.queue.why:</a> This is because there is simply no reasonable way for a client to guarantee that it always promptly collects GC messages.</p>

<p><a id="match"><b>.match:</b></a> Start and end messages should always match up: never post one of the messages but fail to post the matching one.</p>

<p><a id="match.why">.match.why:</a> This makes client code much simpler -- it does not have to handle mismatching messages.</p>

<p><a id="errors-not-direct"><b>.errors-not-direct:</b></a> Errors (such as a ControlAlloc failure) cannot be reported directly to the client, because collections often happen automatically, without an explicit client call to the MPS interface.</p>

<p><a id="multi-trace"><b>.multi-trace:</b></a> Up to TraceLIMIT traces may be running, and emitting start/end messages, simultaneously.</p>

<p><a id="early"><b>.early:</b></a> Nice to tell client as much as possible about the collection in the start message, if we can.</p>

<p><a id="similar"><b>.similar:</b></a> Start and end messages are conceptually similar -- it is quite okay, and may be helpful to the client, for the same datum (for example: the reason why the collection occurred) to be present in both the start and end message.</p>


<h3><a id="storage" name="storage">Storage</a></h3>

<p>For each trace-id (<a href="multi-trace">.multi-trace</a>)
 a pair (<a href="match">.match</a>)
 of start/end messages is 
dynamically allocated (<a href="queue">.queue</a>)
in advance (<a href="no-start-alloc">.no-start-alloc</a>).
Messages are allocated in the control pool using ControlAlloc.</p>

<p><em class="note">(Previous implementations of the trace start message used static allocation.  This does not satisfy .queue.  See also <a href="../../issue/job001570">job001570</a>.  RHSK 2008-12-15.)</em></p>

<p>	Pointers to these messages are stored in <code>tsMessage[ti]</code> and <code>tMessage[ti]</code> arrays in the ArenaStruct.</p>

<p><em class="note">(We <b>must not</b> keep the pre-allocated messages, or pointers to them, in the TraceStructs: the memory for TraceStructs is statically allocated, but the values in them are re-initialised by TraceCreate each time the trace id is used, so the TraceStructs are invalid (that is: to be treated as random uninitialised memory) when not being used by a trace.  See also <a href="../../issue/job001989">job001989</a>.  RHSK 2008-12-15.)</em></p>


<h3><a id="creating-posting" name="creating-posting">Creating and Posting</a></h3>

<p>At ArenaCreate time we TRACE_SET_ITER to initialise the <code>tsMessage[ti]</code> and <code>tMessage[ti]</code> pointers to NULL, and then (when the control pool is ready) TRACE_SET_ITER calling TraceIdMessagesCreate.  This performs the <b>initial pre-allocation</b> of the trace start/end messages for each trace id.  Allocation failure is not tolerated here: it makes ArenaCreate fail with an error code, because the arena is deemed to be unreasonably small.</p>

<p>When a trace is running using trace id <code>ti</code>, it finds a pre-allocated message via <code>tsMessage[ti]</code> or <code>tMessage[ti]</code> in the ArenaStruct, fills-in and <b>posts</b> the message, and nulls-out the pointer.  (If the pointer was null, no message is sent; see below).  The message is now reachable only from the arena message queue (but the control pool also knows about it).</p>

<p>When the trace completes, it calls TraceIdMessagesCreate for its trace id.  This performs the <b>ongoing pre-allocation</b> of the trace start/end messages for the next use of this trace id.  The expectation is that, after a trace has completed, some memory will have been reclaimed, and the ControlAllocs will succeed.</p>

<p>But allocation failure here is permitted: if it happens, both the start and the end messages are freed (if present).  This means that, for the next collection using this trace id, neither a start nor an end message will be sent (<a href="match">.match</a>).  There is no direct way to report this failure to the client (<a href="errors-not-direct">.errors-not-direct</a>), so we just increment the "droppedMessages" counter in the ArenaStruct.  Currently this counter is never reported to the client (except in diagnostic varieties).</p>


<h3><a id="getting-discarding" name="getting-discarding">Getting and Discarding</a></h3>

<p>If the client has not enabled that message type, the message is discarded immediately when posted, calling ControlFree and reclaiming the memory.</p>

<p>If the client has enabled but never gets the message, it remains on the message queue until ArenaDestroy.  Theoretically these messages could accumulate forever until they exhaust memory.  This is intentional: the client should not enable a message type and then never get it!</p>

<p>Otherwise, when the client gets a message, it is dropped from the arena message queue: now only the client (and the control pool) hold references to it.  The client must call mps_message_discard once it has finished using the message.  This calls ControlFree and reclaims the memory.</p>

<p>If the client simply drops its reference, the memory will not be reclaimed until ArenaDestroy.  This is intentional: the control pool is not garbage-collected.</p>


<h3><a id="final-clearup" name="final-clearup">Final Clearup</a></h3>

<p><b>Final clearup</b> is performed at ArenaDestroy, as follows:</p>
<dl>
	<dt>Unused and unsent pre-allocated messages (one per trace id):</dt>
	<dd>Freed with TRACE_SET_ITER calling TraceIdMessagesDestroy which calls ControlFree on anything left in <code>tsMessage[ti]</code> and <code>tMessage[ti]</code>.</dd>

	<dt>Ungot messages:</dt>
	<dd>Freed by emptying the arena message queue with MessageEmpty.</dd>

	<dt>Got but undiscarded messages:</dt>
	<dd>Freed by destroying the control pool.</dd>
</dl>


<h2><a id="testing" name="testing">Testing</a></h2>

<p>The main test is "<code>zmess.c</code>".  See notes there.</p>

<p>Various other tests, including "<code>amcss.c</code>", also collect and report mps_message_type_gc and/or mps_message_type_gc_start.</p>


<h3><a id="coverage" name="coverage">Coverage</a></h3>

<p>Current tests do not check:</p>
<ul>
	<li>The less common why-codes (reasons why a trace starts).  These should be added to <code>zmess.c</code>.</li>
</ul>


<h2><a id="section-A" name="section-A">A. References</a></h2>

<!-- Template Entry

<table>

<tr valign="top">

<td>[<a id="ref-#REF#" name="ref-#REF#" href="#REF_URL#">#REF_NAME#</a>]</td>

<td>
  "#REF_TITLE#";
  #REF_AUTHOR#;
  &lt;URL: <a href="#REF_URL#">#REF_URL#</a>&gt;;
  #REF_DATE#.
</td>

</tr>

</table>

-->

<h2><a id="section-B" name="section-B">B. Document History</a></h2>

<table>

<tr valign="top">

<td>2003-02-17</td>

<td><a href="mailto:drj@ravenbrook.com">DRJ</a></td>

<td>Created.</td>

</tr>

<tr valign="top">
<td>2006-12-07</td>
<td><a href="mailto:rhsk@ravenbrook.com">RHSK</a></td>
<td>Remove mps_message_type_gc_generation (not implemented).</td>
</tr>

<tr valign="top">
<td>2007-02-08</td>
<td><a href="mailto:rhsk@ravenbrook.com">RHSK</a></td>
<td>Move historically interesting requirements for mps_message_type_gc_generation (not implemented) to the end of the doc.</td>
</tr>

<tr valign="top">
<td>2008-12-19</td>
<td><a href="mailto:rhsk@ravenbrook.com">RHSK</a></td>
<td>Complete re-write, for new GC message lifecycle.  See job001989.  (Previous version was //info.ravenbrook.com/project/mps/master/design/message-gc/index.html#2).</td>
</tr>

</table>


<h2><a id="section-C" name="section-C">C. Copyright and License</a></h2>

<p> This document is copyright &copy; 1995-2002, 2006-2007, 2008 <a
href="http://www.ravenbrook.com/">Ravenbrook Limited</a>.  All rights
reserved.  This is an open source license.  Contact Ravenbrook for
commercial licensing options. </p>

<p> Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met: </p>

<ol>

<li> Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer. </li>

<li> Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution. </li>

<li> Redistributions in any form must be accompanied by information
on how to obtain complete source code for the this software and any
accompanying software that uses this software.  The source code must
either be included in the distribution or be available for no more
than the cost of distribution plus a nominal fee, and must be freely
redistributable under reasonable conditions.  For an executable file,
complete source code means the source code for all modules it contains. It
does not include source code for modules or files that typically accompany
the major components of the operating system on which the executable
file runs. </li>

</ol>

<p> <strong> This software is provided by the copyright holders and contributors "as is" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability, fitness for a particular purpose, or non-infringement, are disclaimed.  In no event shall the copyright holders and contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. </strong> </p>


<hr />

<div align="center">

<p><code>$Id$</code></p>

<p>
<a href="/">Ravenbrook</a> /
<a href="/project/">Projects</a> /
<a href="/project/mps/">Memory Pool System</a> /
<a href="/project/mps/master/">Master Product Sources</a> /
<a href="/project/mps/master/design/">Design Documents</a>
</p>

</div>

</body>

</html>
