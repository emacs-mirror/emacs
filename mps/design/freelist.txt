.. mode: -*- rst -*-

Free list allocator
===================

:Tag: design.mps.freelist
:Author: Gareth Rees
:Date: 2013-05-18
:Status: incomplete design
:Revision: $Id$
:Copyright: See section `Copyright and License`_.
:Index terms: pair: free list allocator; design


Introduction
------------

_`.intro`: This document describes the free list allocator for the
Memory Pool System.

_`.readership`: Any MPS developer.


Overview
--------

_`.overview`: The free list allocator is an "emergency" allocator. It
is intended for use as a fallback allocation strategy in low memory
situations, when memory is not available for the control structures
needed by other allocators. In these situations the free list allocator
ensures that memory is not lost, but with several disadvantages:

#. operations on the free list take time proportional to the number of
   free blocks;
#. the data structures are stored in client memory and so are
   vulnerable to corruption;
#. the data structures have poor locality (and thus potentially poor
   cache performance).

When memory becomes available again to allocate control structures,
the free lists can be "flushed" back into the more efficient data
structures.


Requirements
------------

In addition to the generic land requirements (see design.mps.land_),
free lists must satisfy:

.. _design.mps.land: land

_`.req.zero-overhead`: Must have zero space overhead for the storage
of any set of free blocks, so that it can be used to manage memory
when no memory can be allocated for control structures.


Interface
---------

_`.land`: Free lists are an implementation of the *land* abstract data
type, so the interface consists of the generic functions for lands.
See design.mps.land_.


Types
.....

``typedef struct FreelistStruct *Freelist``

_`.type.freelist`: The type of free lists. A ``FreelistStruct`` may be
embedded in another structure, or you can create it using
``LandCreate()``.


External functions
..................

``LandClass FreelistLandClassGet(void)``

_`.function.class`: The function ``FreelistLandClassGet()`` returns
the free list class, a subclass of ``LandClass`` suitable for passing
to ``LandCreate()`` or ``LandInit()``.


Keyword arguments
.................

When initializing a free list, ``LandCreate()`` and ``LandInit()``
take no keyword arguments. Pass ``mps_args_none``.


Implementation
--------------

_`.impl.list`: The isolated contiguous free address ranges are kept on
an address-ordered singly linked free list. (As in traditional
``malloc()`` implementations.)

_`.impl.block`: If the free address range is large enough to contain
an inline block descriptor consisting of two pointers, then the two
pointers stored are to the next free range in address order (or
``freelistEND`` if there are no more ranges), and to the limit of the
current free address range, in that order.

_`.impl.grain`: Otherwise, the free address range must be large enough
to contain a single pointer. The pointer stored is to the next free
range in address order, or ``freelistEND`` if there are no more
ranges.

_`.impl.tag`: Grains and blocks are distinguished by a one-bit tag in
the low bit of the first word (the one containing the pointer to the
next range). Grains have this bit set; blocks have this bit reset.

_`.impl.invariant`: The ranges stored in the free list are *isolated*:
no two ranges are adjacent or overlapping.

_`.impl.merge`: When a free address range is added to the free list,
it is merged with adjacent ranges so as to maintain
`.impl.invariant`_.

_`.impl.rule.break`: The use of ``freelistEND`` to mark the end of the
list violates the rule that exceptional values should not be used to
distinguish exeptional situations. This infraction allows the
implementation to meet `.req.zero-overhead`_. (There are other ways to
do this, such as using another tag to indicate the last block in the
list, but these would be more complicated.)


Testing
-------

_`.test`: The following testing will be performed on this module:

_`.test.land`: A generic test for land implementations. See
design.mps.land.test_.

.. _design.mps.land.test: land#design.mps.land.test

_`.test.pool`: Two pools (MVT_ and MVFF_) use free lists as a fallback
when low on memory. These are subject to testing in development, QA,
and are heavily exercised by customers.

.. _MVT: poolmvt
.. _MVFF: poolmvff



Opportunities for improvement
-----------------------------

_`.improve.length`: When iterating over the list, we could check that
the number of elements visited in the course of the iteration does not
exceed the recorded size of the list.

_`.improve.maxsize`: We could maintain the maximum size of any range
on the list, and use that to make an early exit from
``freelistFindLargest()``. It's not clear that this would actually be
an improvement.



Document History
----------------

- 2013-05-18 GDR_ Initial draft based on CBS "emergency block" design.

- 2014-04-01 GDR_ Moved generic material to design.mps.land_.

.. _GDR: http://www.ravenbrook.com/consultants/gdr/


Copyright and License
---------------------

Copyright Â© 2013-2014 Ravenbrook Limited. All rights reserved.
<http://www.ravenbrook.com/>. This is an open source license. Contact
Ravenbrook for commercial licensing options.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

#. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

#. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

#. Redistributions in any form must be accompanied by information on how
   to obtain complete source code for this software and any
   accompanying software that uses this software.  The source code must
   either be included in the distribution or be available for no more than
   the cost of distribution plus a nominal fee, and must be freely
   redistributable under reasonable conditions.  For an executable file,
   complete source code means the source code for all modules it contains.
   It does not include source code for modules or files that typically
   accompany the major components of the operating system on which the
   executable file runs.

**This software is provided by the copyright holders and contributors
"as is" and any express or implied warranties, including, but not
limited to, the implied warranties of merchantability, fitness for a
particular purpose, or non-infringement, are disclaimed.  In no event
shall the copyright holders and contributors be liable for any direct,
indirect, incidental, special, exemplary, or consequential damages
(including, but not limited to, procurement of substitute goods or
services; loss of use, data, or profits; or business interruption)
however caused and on any theory of liability, whether in contract,
strict liability, or tort (including negligence or otherwise) arising in
any way out of the use of this software, even if advised of the
possibility of such damage.**
