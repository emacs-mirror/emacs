.. mode: -*- rst -*-

Free list allocator
===================

:Tag: design.mps.freelist
:Author: Gareth Rees
:Date: 2013-05-18
:Status: incomplete design
:Revision: $Id$
:Copyright: See section `Copyright and License`_.


Introduction
------------

_`.intro`: This document describes the free list allocator for the
Memory Pool System.

_`.readership`: Any MPS developer.


Overview
--------

_`.overview`: The free list allocator is an "emergency" allocator. It
is intended for use as a fallback allocation strategy in low memory
situations, when memory is not available for the control structures
needed by other allocators. In these situation the free list allocator
ensures that memory is not lost, at the expense of performance. When
memory becomes available again to allocate control structures, the
free lists can be "flushed" back into the more efficient data
structures.

_`.bg`: The free list allocator was formerly part of the Coalescing
Block Structure (see design.mps.cbs) but it was split into its own
module because this makes it:

1. simpler (no need to interact with CBS) and thus more maintainable;
2. possible to test directly (no need to create a CBS and then force
   its control pool to run out of memory); and
3. usable as a fallback allocator in other pools (not just in pools
   that use CBS).


Definitions
-----------

_`.def.range`: A (contiguous) range of addresses is a semi-open
interval on address space.

_`.def.isolated`: A contiguous range is isolated with respect to some
property it has, if adjacent elements do not have that property.


Requirements
------------

_`.req.set`: Must maintain a set of free address ranges.

_`.req.add`: Must be able to add free address ranges to the set.

_`.req.remove`: Must be able to remove address ranges from the set (in
particular, when memory is allocated).

_`.req.iterate`: Must support the iteration of all isolated contiguous
ranges.

_`.req.protocol`: Must detect protocol violations.

_`.req.align`: Must support an alignment (the alignment of all
addresses specifying ranges) of down to ``sizeof(void *)`` without
losing memory.

_`.req.zero-overhead`: Must have zero space overhead for the storage
of any set of free blocks, so that it can be used to manage memory
when no memory can be allocated for control structures.

_`.req.source`: This set of requirements is derived from those of the
CBS module (see design.mps.cbs.req), except that there is no
equivalent of design.mps.cbs.req.fast, and design.mps.cbs.req.small
has been replaced with `.req.zero-overhead`_.


Interface
---------


Types
.....

``typedef struct FreelistStruct *Freelist``

_`.type.freelist`: The type of free lists. The structure
``FreelistStruct`` is declared in the header so that it can be inlined
in other structures, but you should not depend on its details.

``typedef Bool (*FreelistIterateMethod)(Freelist fl, Range range, void *closureP, Size closureS)``

_`.type.iterate.method`: A callback function that may be passed to
``FreelistIterate()``. It is called for every isolated contiguous
range in address order. The function must returns a ``Bool``
indicating whether to continue with the iteration.


Functions
.........

``Res FreelistInit(Freelist fl, Align alignment)``

_`.function.init`: Initialize the ``Freelist`` structure pointed to by
``fl``. The argument ``alignment`` indicates the alignment of address
ranges to be maintained. An initialised free list contains no address
ranges.

``void FreelistFinish(Freelist fl)``

_`.function.finish`: Finish the free list pointed to by ``fl``..

``Res FreelistInsert(Range rangeReturn, Freelist fl, Range range)``

_`.function.insert`: Insert ``range`` into the free list ``fl``. If
any part of the range is already in the free list, then ``ResFAIL`` is
returned, and the free list is unchanged. If it succeeds, then
``rangeReturn`` is updated to describe the range containing the
inserted range (this may differ from ``range`` if there was
coalescence on either side) and ``ResOK`` is returned.

``Res FreelistDelete(Range rangeReturn, Freelist fl, Range range)``

_`.function.delete`: Remove ``range`` from the free list ``fl``. If
any part of the range is not in the free list, then ``ResFAIL`` is
returned, and the free list is unchanged.

``void FreelistIterate(Freelist fl, FreelistIterateMethod iterate, void *closureP, Size closureS)``

_`.function.iterate`: Iterate all isolated contiguous ranges in a free
list. It receives a pointer, ``Size`` closure pair to pass on to the
iterator method, and an iterator method to invoke on every range in
address order. If the iterator method returns ``FALSE``, then the
iteration is terminated.

``Bool FreelistFind(Range rangeReturn, Range oldRangeReturn, Freelist fl, Size size, FindDelete findDelete)``

_`.function.find`: Locate the first block (in address order) within
the free list ``fl`` of at least the specified size, return its range
via the ``rangeReturn`` argument, and return ``TRUE``. If there is no
such block, return ``FALSE``.

Optionally delete the top, bottom, or all of the found range,
depending on the ``findDelete`` argument. This saves a separate call
to ``FreelistDelete()``, and uses the knowledge of exactly where we
found the range. The value of ``findDelete`` must come from this
enumeration::

    enum {
        FindDeleteNONE,    /* don't delete after finding */
        FindDeleteLOW,     /* delete precise size from low end */
        FindDeleteHIGH,    /* delete precise size from high end */
        FindDeleteENTIRE   /* delete entire range */
    };

The old range of the block from which the found range was deleted is
returned via the ``oldRangeReturn`` argument. (If ``findDelete`` is
``FindDeleteNONE`` or ``FindDeleteENTIRE``, then these will be
identical to the range returned via the ``rangeReturn`` argument.)

``Bool FreelistFindLargest(Range rangeReturn, Range oldRangeReturn, Freelist fl, FindDelete findDelete)``

_`.function.find.largest`: Locate the largest block within the free
list ``fl``, return its range via the ``rangeReturn`` argument, and
returns ``TRUE``. If there are no blocks in the free list, it returns
``FALSE``.

Like ``FreelistFind()``, it optionally deletes the range (specifying
``FindDeleteLOW`` or ``FindDeleteHIGH`` has the same effect as
``FindDeleteENTIRE``).

``Res FreelistDescribe(Freelist fl, mps_lib_FILE *stream)``

_`.function.describe`: Print a textual representation of the free
list ``fl`` to the given stream, indicating the contiguous ranges in
order. It is provided for debugging purposes only.



Implementation
--------------

_`.impl.block`: If the free address range is large enough to contain an
inline block descriptor consisting of two pointers, then it is kept on
an address-ordered free block list.

_`.impl.block.structure`: The two pointers stored are to the next such
block (or ``NULL`` if there are no more blocks), and to the limit of
the block, in that order.

_`.impl.grain`: Otherwise, the free address range must be large enough
to contain a single pointer, and it is kept on an address-ordered free
grain list.

_`.impl.grain.structure`: The pointer stored is to the next such
grain, or ``NULL`` if there are no more grains.

_`.impl.grain.align`: This implementation of the grain list requires
the alignment of the free list to be at least ``sizeof(void *)``.

_`.impl.merge`: The free block list and the free grain list are
eagerly merged when a free address range is added to the set.


Opportunities for improvement
-----------------------------

_`.improve.length`: When iterating over lists, check that the
number of elements visited does not exceed the stored size.

_`.improve.maxsize`: Could maintain the maximum size of any block on
the block list, and use that for early exit in
``FreelistFindLargest()``.



Document History
----------------

- 2013-05-18 GDR_ Initial draft based on CBS "emergency block" design.

.. _GDR: http://www.ravenbrook.com/consultants/gdr/


Copyright and License
---------------------

Copyright © 2013 Ravenbrook Limited. All rights reserved. 
<http://www.ravenbrook.com/>. This is an open source license. Contact
Ravenbrook for commercial licensing options.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. Redistributions in any form must be accompanied by information on how
   to obtain complete source code for this software and any
   accompanying software that uses this software.  The source code must
   either be included in the distribution or be available for no more than
   the cost of distribution plus a nominal fee, and must be freely
   redistributable under reasonable conditions.  For an executable file,
   complete source code means the source code for all modules it contains.
   It does not include source code for modules or files that typically
   accompany the major components of the operating system on which the
   executable file runs.

**This software is provided by the copyright holders and contributors
"as is" and any express or implied warranties, including, but not
limited to, the implied warranties of merchantability, fitness for a
particular purpose, or non-infringement, are disclaimed.  In no event
shall the copyright holders and contributors be liable for any direct,
indirect, incidental, special, exemplary, or consequential damages
(including, but not limited to, procurement of substitute goods or
services; loss of use, data, or profits; or business interruption)
however caused and on any theory of liability, whether in contract,
strict liability, or tort (including negligence or otherwise) arising in
any way out of the use of this software, even if advised of the
possibility of such damage.**
