.. mode: -*- rst -*-

Stack and register scanning
===========================

:Tag: design.mps.ss
:Author: Gareth Rees
:Date: 2014-10-22
:Status: complete design
:Revision: $Id$
:Copyright: See `Copyright and License`_.
:Index terms: pair: stack and register scanning; design


Introduction
------------

_`.intro`: This is the design of the stack and register scanning
module.

_`.readership`: Any MPS developer; anyone porting the MPS to a new
platform.

_`.overview`: This module locates and scans references in the control
stack and registers of the *current* thread.

_`.other`: The thread manager module is responsible for scanning the
control stack and registers of *other* threads. See
design.mps.thread-manager.if.scan_.

.. _design.mps.thread-manager.if.scan: thread-manager#if.scan

_`.origin`: This design was originally proposed in
mail.richard.2012-08-03.14-36_.

.. _mail.richard.2012-08-03.14-36: https://info.ravenbrook.com/mail/2012/08/03/14-36-35/0/


Requirements
------------

_`.req.stack.top`: Must locate the top of the mutator's stack. (This
is needed for conservative garbage collection of uncooperative code,
where references might be stored by mutator on its stack.)

_`.req.stack.bottom.not`: There is no requirement to locate the bottom
of the stack. (The mutator supplies this as an argument to
``mps_root_create_reg()``.)

_`.req.stack.platform`: Must implement the platform's stack
conventions.

_`.req.stack.platform.full-empty`: The implementation must take into
account whether the stack is *full* (the stack pointer points to the
last full location) or *empty* (the stack pointer points to the
first empty location).

_`.req.stack.platform.desc-asc`: The implementation must take into
account whether the stack is *descending* (top of stack is at a lower
address than bottom of stack) or *ascending* (top of stack is at a
higher address than bottom of stack).

_`.req.registers`: Must locate and scan all references in the
mutator's *root registers*, the subset of registers which might
contain references that do not also appear on the stack. (This is
needed for conservative garbage collection of uncooperative code,
where references might appear in registers.)

_`.req.entry`: Should save the mutator's context (stack and registers)
at the point where it enters the MPS. (This avoids scanning registers
and stack that belong to the MPS rather than the mutator, leading to
unnecessary pinning and zone pollution; see job003525_.)

.. _job003525: http://www.ravenbrook.com/project/mps/issue/job003525/

_`.req.setjmp`: The implementation must follow the C Standard in its
use of the ``setjmp`` macro. (So that it is reliable and portable.)

_`.req.assembly`: The implementation should not use assembly language.
(So that it can be developed in tools like Microsoft Visual Studio
that don't support this.)


Design
------

_`.sol.entry-points`: To meet `.req.stack.entry`_, the mutator's
registers and stack must be recorded when the mutator enters the MPS,
if there is a possibility that the MPS might need to know the mutator
context.

_`.sol.entry-points.fragile`: The analysis of which entry points might
need to save the context (see `.anal.entry-points`_ below) is fragile.
It might be incorrect now, or become incomplete if we refactor the
internals of tracing and polling. As a defence against errors of this
form, ``StackScan()`` asserts that the context was saved, but if the
client program continues from the assertion, it saves the context
anyway and continues.

_`.sol.registers`: Implementations spill the root registers onto the
stack so that they can be scanned there.

_`.sol.registers.root`: The *root registers* are the subset of the
callee-save registers that may contain pointers.

_`.sol.registers.root.justify`: The caller-save registers will have
been spilled onto the stack by the time the MPS is entered, so will be
scanned by the stack scan. Floating-point registers and debugging
registers do not, as far as we are aware, contain pointers.

_`.sol.setjmp`: The values in callee-save registers can be found by
calling ``setjmp`` and scanning the ``jmp_buf``.

_`.sol.setjmp.scan`: An implementation can decode the jump buffer and
scan just the root registers, or it can conservatively scan the whole
of the jump buffer.

_`.sol.setjmp.justify`: The C standard specifies that ``jmp_buf`` "is
an array type suitable for holding the information needed to restore a
calling environment. The environment of a call to the ``setjmp`` macro
consists of information sufficient for a call to the ``longjmp``
function to return execution to the correct block and invocation of
that block, were it called recursively." We believe that any
reasonable implementation of ``setjmp`` must copy the callee-save
registers into the ``jmp_buf`` in order to work as described.
Otherwise, once the callee-save registers have been overwritten by
other function calls, a ``longjmp`` would result in the callee-save
registers having the wrong values.

_`.sol.stack.top`: Similarly, an implementation can decode the jump
buffer and get the top of the mutator's stack from the stack pointer
register, or it can conservatively use the address of a local variable
in the entry point to the MPS.

_`.sol.stack.platform`: As of version 1.115, all supported platforms
are *full* and *descending* so the implementation in ``StackScan``
assumes this. New platforms must check this assumption.

_`.sol.xc.alternative`: On OS X, we could use ``getcontext()`` from
libunwind (see here_), but that produces deprecation warnings and
introduces a dependency on that library.

.. _here: http://stackoverflow.com/questions/3592914/how-can-i-implement-cooperative-lightweight-threading-with-c-on-mac-os-x


Analysis
--------

_`.anal.setjmp`: The C90 Standard says:

    An invocation of the ``setjmp`` macro shall appear only in one of
    the following contexts:

    - the entire controlling expression of a selection or iteration
      statement;

    - one operand of a relational or equality operator with the other
      operand an integral constant expression, with the resulting
      expression being the entire controlling expression of a
      selection or iteration statement;

    - the operand of a unary ``!`` operator with the resulting
      expression being the entire controlling expression of a
      selection or iteration statement; or

    - the entire expression of an expression statement (possibly cast
      to ``void``).

And C99 adds:

    If the invocation appears in any other context, the behavior is
    undefined.

_`.anal.entry-points`: Here's a reverse call graph (in the master
sources at changelevel 187410) showing which entry points might call
``StackScan()`` and so need to record the stack context::

    StackScan
     └ThreadScan
       └mps_stack_scan_ambig
         └RootScan
           └traceScanRootRes
             └traceScanRoot
               └rootFlip
                 └traceFlip
                   └TraceStart
                     ├TracePoll
                     │ ├ArenaStep
                     │ │ └mps_arena_step
                     │ └ArenaPoll
                     │   ├mps_alloc
                     │   ├mps_ap_fill
                     │   ├mps_ap_fill_with_reservoir_permit
                     │   ├mps_ap_alloc_pattern_end
                     │   ├mps_ap_alloc_pattern_reset
                     │   └ArenaRelease
                     │     ├mps_arena_release
                     │     └ArenaStartCollect
                     │       ├mps_arena_start_collect
                     │       └ArenaCollect
                     │         └mps_arena_collect
                     └TraceStartCollectAll
                       ├ArenaStep [see above]
                       ├ArenaStartCollect [see above]
                       └TracePoll [see above]

So the entry points that need to save the stack context are
``mps_arena_step()``, ``mps_alloc()``, ``mps_ap_fill()``,
``mps_ap_fill_with_reservoir_permit()``,
``mps_ap_alloc_pattern_end()``, ``mps_ap_alloc_pattern_reset()``,
``mps_arena_release()``, ``mps_arena_start_collect()``, and
``mps_arena_collect()``.


Interface
---------

``typedef StackContextStruct *StackContext``

_`.if.sc`: A structure encapsulating the mutator context.

``Addr StackContextStackTop(StackContext sc)``

_`.if.stack.top`: Return (a conservative approximation to) the address
of the "top" of the mutator's stack at the point where ``sc`` was
stored. In the common case, where the stack grows downwards, this is
actually the lowest stack address.

``Res StackScan(ScanState ss, Addr *stackBot)``

_`.if.scan`: Scan the stack of the current thread, between
``stackBot`` and the "top" of the mutator's stack that was recorded by
``STACK_CONTEXT_SAVE()`` when the arena was entered. Also scan any
roots which were in the mutator's callee-save registers at that point.
Return ``ResOK`` if successful, or another result code if not. See the
platform-specific implementation of ``StackContextScan()`` for the
exact registers which are scanned.

_`.if.scan.begin-end`: This function must be called between
``STACK_CONTEXT_BEGIN()`` and ``STACK_CONTEXT_END()``.

``STACK_CONTEXT_SAVE(StackContext sc)``

_`.if.save`: Store the mutator context in the structure ``sc``.

_`.if.save.macro`: This must be implemented as a macro because it
needs to run in the stack frame of the entry point (if it runs in some
other function it does not necessarily get the mutator's registers).
This necessity to have the definition in scope in ``mpsi.c``, while
also having different definitions on different platforms, requires a
violation of design.mps.config.no-spaghetti_ in ss.h.

.. _design.mps.config.no-spaghetti: config#no-spaghetti

``STACK_CONTEXT_BEGIN(Arena arena)``

_`.if.begin`: Start an MPS operation that may need to know the mutator
context (see .sol.entry-points). This macro must be used like this::

    Res res;
    STACK_CONTEXT_BEGIN(arena) {
      res = ArenaStartCollect(arena);
    } STACK_CONTEXT_END(arena);
    return res;

That is, it must be paired with ``STACK_CONTEXT_END()``, and there
must be no ``return`` between the two macro invocations.

This macro takes the arena lock, stores the mutator context in a
``StackContext`` structure allocated on the stack, and sets
``arena->scAtArenaEnter`` to the address of this structure.

``STACK_CONTEXT_END(Arena arena)``

_`.if.end`: Finish the MPS operation that was started by
``STACK_CONTEXT_BEGIN()``.

This macro sets ``arena->scAtArenaEnter`` to ``NULL`` and releases
the arena lock.


Implementations
---------------

_`.impl.an`: Generic implementation in ``ssan.c``. Since the C
standard does not specify where the callee-save registers appear in
the jump buffer, the whole buffer must be scanned (see
`.sol.setjmp.scan`_), and the top of the stack must be taken
conservatively from a local variable.

_`.impl.w3`: Windows implementation in ``ssw3i3mv.c`` and
``ssw3i6mv.c``. We know the layout of the jump buffer used by the
compiler, and so can scan exactly the subset of registers we need, and
decode the stack pointer from ESP (on IA-32) or RSP (on x86-64).

_`.impl.w3.i3`: On Windows on IA-32, the callee-save registers are
EBX, ESI, EDI, and EBP. See [Fog]_.

_`.impl.w3.i6`: On Windows on x86-64, the callee-save registers are
RBX, RBP, RDI, RSI, R12, R13, R14, and R15. See
[x86_64_registers]_. In theory the lowest 128 bits of the vector
registers XMM6 to XMM15 are also callee-save, but we assume that
references do not appear in these registers.

_`.impl.xc`: OS X implementation in ``ssxci3.c`` and ``ssxci6.c``.
Scans the jump buffer conservatively as for `.impl.an`_, but decodes
the stack pointer from ESP (on IA-32) or RSP (on x86-64).

_`.impl.xc.i3`: On OS X on IA-32, the callee-save registers are EBX,
ESI, EDI and EBP. See [Fog]_.

_`.impl.xc.i6`: On OS X on x86-64, the callee-save registers are RBX,
RBP, R12, R13, R14, and R15. See [Fog]_.


References
----------

.. [Fog]
   "Calling conventions for different C++ compilers and operating systems";
   Agner Fog;
   Copenhagen University College of Engineering;
   2014-08-07;
   <http://agner.org/optimize/calling_conventions.pdf>

.. [x86_64_registers]
   "Caller/Callee Saved Registers";
   Microsoft Corporation;
   <https://msdn.microsoft.com/en-us/library/6t169e9c.aspx>


Document History
----------------

- 2014-10-22 GDR_ Initial draft.

.. _GDR: http://www.ravenbrook.com/consultants/gdr/


Copyright and License
---------------------

Copyright © 2014 Ravenbrook Limited. All rights reserved.
<http://www.ravenbrook.com/>. This is an open source license. Contact
Ravenbrook for commercial licensing options.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

#. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

#. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

#. Redistributions in any form must be accompanied by information on how
   to obtain complete source code for this software and any
   accompanying software that uses this software.  The source code must
   either be included in the distribution or be available for no more than
   the cost of distribution plus a nominal fee, and must be freely
   redistributable under reasonable conditions.  For an executable file,
   complete source code means the source code for all modules it contains.
   It does not include source code for modules or files that typically
   accompany the major components of the operating system on which the
   executable file runs.

**This software is provided by the copyright holders and contributors
"as is" and any express or implied warranties, including, but not
limited to, the implied warranties of merchantability, fitness for a
particular purpose, or non-infringement, are disclaimed.  In no event
shall the copyright holders and contributors be liable for any direct,
indirect, incidental, special, exemplary, or consequential damages
(including, but not limited to, procurement of substitute goods or
services; loss of use, data, or profits; or business interruption)
however caused and on any theory of liability, whether in contract,
strict liability, or tort (including negligence or otherwise) arising in
any way out of the use of this software, even if advised of the
possibility of such damage.**
