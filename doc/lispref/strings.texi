@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2023 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Strings and Characters
@chapter Strings and Characters
@cindex strings
@cindex character arrays
@cindex characters
@cindex bytes

  A string in Emacs Lisp is an array that contains an ordered sequence
of characters.  Strings are used as names of symbols, buffers, and
files; to send messages to users; to hold text being copied between
buffers; and for many other purposes.  Because strings are so important,
Emacs Lisp has many functions expressly for manipulating them.  Emacs
Lisp programs use strings more often than individual characters.

  @xref{Strings of Events}, for special considerations for strings of
keyboard character events.

@menu
* Basics: String Basics.      Basic properties of strings and characters.
* Predicates for Strings::    Testing whether an object is a string or char.
* Creating Strings::          Functions to allocate new strings.
* Modifying Strings::         Altering the contents of an existing string.
* Text Comparison::           Comparing characters or strings.
* String Conversion::         Converting to and from characters and strings.
* Formatting Strings::        @code{format}: Emacs's analogue of @code{printf}.
* Custom Format Strings::     Formatting custom @code{format} specifications.
* Case Conversion::           Case conversion functions.
* Case Tables::               Customizing case conversion.
@end menu

@node String Basics
@section String and Character Basics

  A character is a Lisp object which represents a single character of
text.  In Emacs Lisp, characters are simply integers; whether an
integer is a character or not is determined only by how it is used.
@xref{Character Codes}, for details about character representation in
Emacs.

  A string is a fixed sequence of characters.  It is a type of
sequence called a @dfn{array}, meaning that its length is fixed and
cannot be altered once it is created (@pxref{Sequences Arrays
Vectors}).  Unlike in C, Emacs Lisp strings are @emph{not} terminated
by a distinguished character code.

  Since strings are arrays, and therefore sequences as well, you can
operate on them with the general array and sequence functions documented
in @ref{Sequences Arrays Vectors}.  For example, you can access
individual characters in a string using the function @code{aref}
(@pxref{Array Functions}).

  There are two text representations for non-@acronym{ASCII}
characters in Emacs strings (and in buffers): unibyte and multibyte.
For most Lisp programming, you don't need to be concerned with these
two representations.  @xref{Text Representations}, for details.

  Sometimes key sequences are represented as unibyte strings.  When a
unibyte string is a key sequence, string elements in the range 128 to
255 represent meta characters (which are large integers) rather than
character codes in the range 128 to 255.  Strings cannot hold
characters that have the hyper, super or alt modifiers; they can hold
@acronym{ASCII} control characters, but no other control characters.
They do not distinguish case in @acronym{ASCII} control characters.
If you want to store such characters in a sequence, such as a key
sequence, you must use a vector instead of a string.  @xref{Character
Type}, for more information about keyboard input characters.

  Strings are useful for holding regular expressions.  You can also
match regular expressions against strings with @code{string-match}
(@pxref{Regexp Search}).  The functions @code{match-string}
(@pxref{Simple Match Data}) and @code{replace-match} (@pxref{Replacing
Match}) are useful for decomposing and modifying strings after
matching regular expressions against them.

  Like a buffer, a string can contain text properties for the characters
in it, as well as the characters themselves.  @xref{Text Properties}.
All the Lisp primitives that copy text from strings to buffers or other
strings also copy the properties of the characters being copied.

  @xref{Text}, for information about functions that display strings or
copy them into buffers.  @xref{Character Type}, and @ref{String Type},
for information about the syntax of characters and strings.
@xref{Non-ASCII Characters}, for functions to convert between text
representations and to encode and decode character codes.
Also, note that @code{length} should @emph{not} be used for computing
the width of a string on display; use @code{string-width} (@pxref{Size
of Displayed Text}) instead.

@node Predicates for Strings
@section Predicates for Strings
@cindex predicates for strings
@cindex string predicates

For more information about general sequence and array predicates,
see @ref{Sequences Arrays Vectors}, and @ref{Arrays}.

@defun stringp object
This function returns @code{t} if @var{object} is a string, @code{nil}
otherwise.
@end defun

@defun string-or-null-p object
This function returns @code{t} if @var{object} is a string or
@code{nil}.  It returns @code{nil} otherwise.
@end defun

@defun char-or-string-p object
This function returns @code{t} if @var{object} is a string or a
character (i.e., an integer), @code{nil} otherwise.
@end defun

@node Creating Strings
@section Creating Strings
@cindex creating strings
@cindex string creation

  The following functions create strings, either from scratch, or by
putting strings together, or by taking them apart.  (For functions
that create strings based on the modified contents of other strings,
like @code{string-replace} and @code{replace-regexp-in-string}, see
@ref{Search and Replace}.)

@defun make-string count character &optional multibyte
This function returns a string made up of @var{count} repetitions of
@var{character}.  If @var{count} is negative, an error is signaled.

@example
(make-string 5 ?x)
     @result{} "xxxxx"
(make-string 0 ?x)
     @result{} ""
@end example

  Normally, if @var{character} is an @acronym{ASCII} character, the
result is a unibyte string.  But if the optional argument
@var{multibyte} is non-@code{nil}, the function will produce a
multibyte string instead.  This is useful when you later need to
concatenate the result with non-@acronym{ASCII} strings or replace
some of its characters with non-@acronym{ASCII} characters.

  Other functions to compare with this one include @code{make-vector}
(@pxref{Vectors}) and @code{make-list} (@pxref{Building Lists}).
@end defun

@defun string &rest characters
This returns a string containing the characters @var{characters}.

@example
(string ?a ?b ?c)
     @result{} "abc"
@end example
@end defun

@defun substring string &optional start end
This function returns a new string which consists of those characters
from @var{string} in the range from (and including) the character at the
index @var{start} up to (but excluding) the character at the index
@var{end}.  The first character is at index zero.  With one argument,
this function just copies @var{string}.

@example
@group
(substring "abcdefg" 0 3)
     @result{} "abc"
@end group
@end example

@noindent
In the above example, the index for @samp{a} is 0, the index for
@samp{b} is 1, and the index for @samp{c} is 2.  The index 3---which
is the fourth character in the string---marks the character position
up to which the substring is copied.  Thus, @samp{abc} is copied from
the string @code{"abcdefg"}.

A negative number counts from the end of the string, so that @minus{}1
signifies the index of the last character of the string.  For example:

@example
@group
(substring "abcdefg" -3 -1)
     @result{} "ef"
@end group
@end example

@noindent
In this example, the index for @samp{e} is @minus{}3, the index for
@samp{f} is @minus{}2, and the index for @samp{g} is @minus{}1.
Therefore, @samp{e} and @samp{f} are included, and @samp{g} is excluded.

When @code{nil} is used for @var{end}, it stands for the length of the
string.  Thus,

@example
@group
(substring "abcdefg" -3 nil)
     @result{} "efg"
@end group
@end example

Omitting the argument @var{end} is equivalent to specifying @code{nil}.
It follows that @code{(substring @var{string} 0)} returns a copy of all
of @var{string}.

@example
@group
(substring "abcdefg" 0)
     @result{} "abcdefg"
@end group
@end example

@noindent
But we recommend @code{copy-sequence} for this purpose (@pxref{Sequence
Functions}).

If the characters copied from @var{string} have text properties, the
properties are copied into the new string also.  @xref{Text Properties}.

@code{substring} also accepts a vector for the first argument.
For example:

@example
(substring [a b (c) "d"] 1 3)
     @result{} [b (c)]
@end example

A @code{wrong-type-argument} error is signaled if @var{start} is not
an integer or if @var{end} is neither an integer nor @code{nil}.  An
@code{args-out-of-range} error is signaled if @var{start} indicates a
character following @var{end}, or if either integer is out of range
for @var{string}.

Contrast this function with @code{buffer-substring} (@pxref{Buffer
Contents}), which returns a string containing a portion of the text in
the current buffer.  The beginning of a string is at index 0, but the
beginning of a buffer is at index 1.
@end defun

@defun substring-no-properties string &optional start end
This works like @code{substring} but discards all text properties from
the value.  Also, @var{start} may be omitted or @code{nil}, which is
equivalent to 0.  Thus, @w{@code{(substring-no-properties
@var{string})}} returns a copy of @var{string}, with all text
properties removed.
@end defun

@defun concat &rest sequences
@cindex copying strings
@cindex concatenating strings
This function returns a string consisting of the characters in the
arguments passed to it (along with their text properties, if any).  The
arguments may be strings, lists of numbers, or vectors of numbers; they
are not themselves changed.  If @code{concat} receives no arguments, it
returns an empty string.

@example
(concat "abc" "-def")
     @result{} "abc-def"
(concat "abc" (list 120 121) [122])
     @result{} "abcxyz"
;; @r{@code{nil} is an empty sequence.}
(concat "abc" nil "-def")
     @result{} "abc-def"
(concat "The " "quick brown " "fox.")
     @result{} "The quick brown fox."
(concat)
     @result{} ""
@end example

@noindent
This function does not always allocate a new string.  Callers are
advised not rely on the result being a new string nor on it being
@code{eq} to an existing string.

In particular, mutating the returned value may inadvertently change
another string, alter a constant string in the program, or even raise
an error.  To obtain a string that you can safely mutate, use
@code{copy-sequence} on the result.

For information about other concatenation functions, see the
description of @code{mapconcat} in @ref{Mapping Functions},
@code{vconcat} in @ref{Vector Functions}, and @code{append} in @ref{Building
Lists}.  For concatenating individual command-line arguments into a
string to be used as a shell command, see @ref{Shell Arguments,
combine-and-quote-strings}.
@end defun

@defun split-string string &optional separators omit-nulls trim
This function splits @var{string} into substrings based on the regular
expression @var{separators} (@pxref{Regular Expressions}).  Each match
for @var{separators} defines a splitting point; the substrings between
splitting points are made into a list, which is returned.

If @var{separators} is @code{nil} (or omitted), the default is the
value of @code{split-string-default-separators} and the function
behaves as if @var{omit-nulls} were @code{t}.

If @var{omit-nulls} is @code{nil} (or omitted), the result contains
null strings whenever there are two consecutive matches for
@var{separators}, or a match is adjacent to the beginning or end of
@var{string}.  If @var{omit-nulls} is @code{t}, these null strings are
omitted from the result.

If the optional argument @var{trim} is non-@code{nil}, it should be a
regular expression to match text to trim from the beginning and end of
each substring.  If trimming makes the substring empty, it is treated
as null.

If you need to split a string into a list of individual command-line
arguments suitable for @code{call-process} or @code{start-process},
see @ref{Shell Arguments, split-string-and-unquote}.

Examples:

@example
(split-string "  two words ")
     @result{} ("two" "words")
@end example

The result is not @code{("" "two" "words" "")}, which would rarely be
useful.  If you need such a result, use an explicit value for
@var{separators}:

@example
(split-string "  two words "
              split-string-default-separators)
     @result{} ("" "two" "words" "")
@end example

@example
(split-string "Soup is good food" "o")
     @result{} ("S" "up is g" "" "d f" "" "d")
(split-string "Soup is good food" "o" t)
     @result{} ("S" "up is g" "d f" "d")
(split-string "Soup is good food" "o+")
     @result{} ("S" "up is g" "d f" "d")
@end example

Empty matches do count, except that @code{split-string} will not look
for a final empty match when it already reached the end of the string
using a non-empty match or when @var{string} is empty:

@example
(split-string "aooob" "o*")
     @result{} ("" "a" "" "b" "")
(split-string "ooaboo" "o*")
     @result{} ("" "" "a" "b" "")
(split-string "" "")
     @result{} ("")
@end example

However, when @var{separators} can match the empty string,
@var{omit-nulls} is usually @code{t}, so that the subtleties in the
three previous examples are rarely relevant:

@example
(split-string "Soup is good food" "o*" t)
     @result{} ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
(split-string "Nice doggy!" "" t)
     @result{} ("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
(split-string "" "" t)
     @result{} nil
@end example

Somewhat odd, but predictable, behavior can occur for certain
``non-greedy'' values of @var{separators} that can prefer empty
matches over non-empty matches.  Again, such values rarely occur in
practice:

@example
(split-string "ooo" "o*" t)
     @result{} nil
(split-string "ooo" "\\|o+" t)
     @result{} ("o" "o" "o")
@end example
@end defun

@defvar split-string-default-separators
The default value of @var{separators} for @code{split-string}.  Its
usual value is @w{@code{"[ \f\t\n\r\v]+"}}.
@end defvar

@defun string-clean-whitespace string
Clean up the whitespace in @var{string} by collapsing stretches of
whitespace to a single space character, as well as removing all
whitespace from the start and the end of @var{string}.
@end defun

@defun string-trim-left string &optional regexp
Remove the leading text that matches @var{regexp} from @var{string}.
@var{regexp} defaults to @samp{[ \t\n\r]+}.
@end defun

@defun string-trim-right string &optional regexp
Remove the trailing text that matches @var{regexp} from @var{string}.
@var{regexp} defaults to @samp{[ \t\n\r]+}.
@end defun

@defun string-trim string &optional trim-left trim-right
Remove the leading text that matches @var{trim-left} and trailing text
that matches @var{trim-right} from @var{string}.  Both regexps
default to @samp{[ \t\n\r]+}.
@end defun

@defun string-fill string length
Attempt to Word-wrap @var{string} so that no lines are longer than
@var{length}.  Filling is done on whitespace boundaries only.  If
there are individual words that are longer than @var{length}, these
will not be shortened.
@end defun

@defun string-limit string length &optional end coding-system
If @var{string} is shorter than @var{length} characters, @var{string}
is returned as is.  Otherwise, return a substring of @var{string}
consisting of the first @var{length} characters.  If the optional
@var{end} parameter is given, return a string of the @var{length} last
characters instead.

If @var{coding-system} is non-@code{nil}, @var{string} will be encoded
before limiting, and the result will be a unibyte string that's
shorter than @code{length} bytes.  If @var{string} contains characters
that are encoded into several bytes (for instance, when using
@code{utf-8}), the resulting unibyte string is never truncated in the
middle of a character representation.

This function measures the string length in characters or bytes, and
thus is generally inappropriate if you need to shorten strings for
display purposes; use @code{truncate-string-to-width} or
@code{window-text-pixel-size} or @code{string-glyph-split} instead
(@pxref{Size of Displayed Text}).
@end defun

@defun string-lines string &optional omit-nulls keep-newlines
Split @var{string} into a list of strings on newline boundaries.  If
the optional argument @var{omit-nulls} is non-@code{nil}, remove empty
lines from the results.  If the optional argument @var{keep-newlines}
is non-@code{nil}, don't remove the trailing newlines from the result
strings.
@end defun

@defun string-pad string length &optional padding start
Pad @var{string} to be of the given @var{length} using @var{padding}
as the padding character.  @var{padding} defaults to the space
character.  If @var{string} is longer than @var{length}, no padding is
done.  If @var{start} is @code{nil} or omitted, the padding is
appended to the characters of @var{string}, and if it's
non-@code{nil}, the padding is prepended to @var{string}'s characters.
@end defun

@defun string-chop-newline string
Remove the final newline, if any, from @var{string}.
@end defun

@node Modifying Strings
@section Modifying Strings
@cindex modifying strings
@cindex string modification

  You can alter the contents of a mutable string via operations
described in this section.  @xref{Mutability}.

  The most basic way to alter the contents of an existing string is with
@code{aset} (@pxref{Array Functions}).  @w{@code{(aset @var{string}
@var{idx} @var{char})}} stores @var{char} into @var{string} at character
index @var{idx}.  It will automatically convert a pure-@acronym{ASCII}
@var{string} to a multibyte string (@pxref{Text Representations}) if
needed, but we recommend to always make sure @var{string} is multibyte
(e.g., by using @code{string-to-multibyte}, @pxref{Converting
Representations}), if @var{char} is a non-@acronym{ASCII} character, not
a raw byte.

  A more powerful function is @code{store-substring}:

@defun store-substring string idx obj
This function alters part of the contents of the specified @var{string},
by storing @var{obj} starting at character index @var{idx}.  The
argument @var{obj} may be either a character (in which case the function
behaves exactly as @code{aset}) or a (smaller) string.  If @var{obj}
is a multibyte string, we recommend to make sure @var{string} is also
multibyte, even if it's pure-@acronym{ASCII}.

Since it is impossible to change the number of characters in an
existing string, it is an error if @var{obj} consists of more
characters than would fit in @var{string} starting at character index
@var{idx}.
@end defun

  To clear out a string that contained a password, use
@code{clear-string}:

@defun clear-string string
This makes @var{string} a unibyte string and clears its contents to
zeros.  It may also change @var{string}'s length.
@end defun

@need 2000
@node Text Comparison
@section Comparison of Characters and Strings
@cindex string equality
@cindex text comparison

@defun char-equal character1 character2
This function returns @code{t} if the arguments represent the same
character, @code{nil} otherwise.  This function ignores differences
in case if @code{case-fold-search} is non-@code{nil}.

@example
(char-equal ?x ?x)
     @result{} t
(let ((case-fold-search nil))
  (char-equal ?x ?X))
     @result{} nil
@end example
@end defun

@defun string= string1 string2
This function returns @code{t} if the characters of the two strings
match exactly.  Symbols are also allowed as arguments, in which case
the symbol names are used.  Case is always significant, regardless of
@code{case-fold-search}.

This function is equivalent to @code{equal} for comparing two strings
(@pxref{Equality Predicates}).  In particular, the text properties of
the two strings are ignored; use @code{equal-including-properties} if
you need to distinguish between strings that differ only in their text
properties.  However, unlike @code{equal}, if either argument is not a
string or symbol, @code{string=} signals an error.

@example
(string= "abc" "abc")
     @result{} t
(string= "abc" "ABC")
     @result{} nil
(string= "ab" "ABC")
     @result{} nil
@end example

A unibyte and a multibyte string are equal in the sense of
@code{string=} if and only if they contain the same sequence of
character codes all being in the range 0--127 (@acronym{ASCII}).
@xref{Text Representations}.
@end defun

@defun string-equal string1 string2
@code{string-equal} is another name for @code{string=}.
@end defun

@defun string-equal-ignore-case string1 string2
@code{string-equal-ignore-case} compares strings ignoring case
differences, like @code{char-equal} when @code{case-fold-search} is
@code{t}.
@end defun

@cindex locale-dependent string equivalence
@defun string-collate-equalp string1 string2 &optional locale ignore-case
This function returns @code{t} if @var{string1} and @var{string2} are
equal with respect to the collation rules of the specified
@var{locale}, which defaults to your current system locale.  A
collation rule is not only
determined by the lexicographic order of the characters contained in
@var{string1} and @var{string2}, but also by further rules about
relations between these characters.  Usually, it is defined by the
locale environment with which Emacs is running and by the Standard C
library against which Emacs was linked@footnote{
For more information about collation rules and their locale
dependencies, see @uref{https://unicode.org/reports/tr10/, The Unicode
Collation Algorithm}.  Some Standard C libraries, such as the
@acronym{GNU} C Library (a.k.a.@: @dfn{glibc}) implement large
portions of the Unicode Collation Algorithm and use the associated
locale data, Common Locale Data Repository, or @acronym{CLDR}.
}.

For example, characters with different code points but the same
meaning, like different grave accent Unicode characters, might, in
some locales, be considered as equal:

@example
@group
(string-collate-equalp (string ?\uFF40) (string ?\u1FEF))
     @result{} t
@end group
@end example

The optional argument @var{locale}, a string, overrides the setting of
your current locale identifier for collation.  The value is system
dependent; a @var{locale} @code{"en_US.UTF-8"} is applicable on POSIX
systems, while it would be, e.g., @code{"enu_USA.1252"} on MS-Windows
systems.

If @var{ignore-case} is non-@code{nil}, characters are compared
case-insensitively, by converting them to lower-case.  However, if the
underlying system library doesn't provide locale-specific collation
rules, this function falls back to @code{string-equal}, in which case
the @var{ignore-case} argument is ignored, and the comparison will
always be case-sensitive.

@vindex w32-collate-ignore-punctuation
To emulate Unicode-compliant collation on MS-Windows systems,
bind @code{w32-collate-ignore-punctuation} to a non-@code{nil} value, since
the codeset part of the locale cannot be @code{"UTF-8"} on MS-Windows.

If your system does not support a locale environment, this function
behaves like @code{string-equal}.

Do @emph{not} use this function to compare file names for equality, as
filesystems generally don't honor linguistic equivalence of strings
that collation implements.
@end defun

@cindex lexical comparison of strings
@defun string< string1 string2
@c (findex string< causes problems for permuted index!!)
This function compares two strings a character at a time.  It
scans both the strings at the same time to find the first pair of corresponding
characters that do not match.  If the lesser character of these two is
the character from @var{string1}, then @var{string1} is less, and this
function returns @code{t}.  If the lesser character is the one from
@var{string2}, then @var{string1} is greater, and this function returns
@code{nil}.  If the two strings match entirely, the value is @code{nil}.

Pairs of characters are compared according to their character codes.
Keep in mind that lower case letters have higher numeric values in the
@acronym{ASCII} character set than their upper case counterparts; digits and
many punctuation characters have a lower numeric value than upper case
letters.  An @acronym{ASCII} character is less than any non-@acronym{ASCII}
character; a unibyte non-@acronym{ASCII} character is always less than any
multibyte non-@acronym{ASCII} character (@pxref{Text Representations}).

@example
@group
(string< "abc" "abd")
     @result{} t
(string< "abd" "abc")
     @result{} nil
(string< "123" "abc")
     @result{} t
@end group
@end example

When the strings have different lengths, and they match up to the
length of @var{string1}, then the result is @code{t}.  If they match up
to the length of @var{string2}, the result is @code{nil}.  A string of
no characters is less than any other string.

@example
@group
(string< "" "abc")
     @result{} t
(string< "ab" "abc")
     @result{} t
(string< "abc" "")
     @result{} nil
(string< "abc" "ab")
     @result{} nil
(string< "" "")
     @result{} nil
@end group
@end example

Symbols are also allowed as arguments, in which case their print names
are compared.
@end defun

@defun string-lessp string1 string2
@code{string-lessp} is another name for @code{string<}.
@end defun

@defun string-greaterp string1 string2
This function returns the result of comparing @var{string1} and
@var{string2} in the opposite order, i.e., it is equivalent to calling
@code{(string-lessp @var{string2} @var{string1})}.
@end defun

@cindex locale-dependent string comparison
@defun string-collate-lessp string1 string2 &optional locale ignore-case
This function returns @code{t} if @var{string1} is less than
@var{string2} in collation order of the specified @var{locale}, which
defaults to your current system locale.  A collation order is not only
determined by the lexicographic order of the characters contained in
@var{string1} and @var{string2}, but also by further rules about
relations between these characters.  Usually, it is defined by the
locale environment with which Emacs is running, and by the Standard C
library against which Emacs was linked.

For example, punctuation and whitespace characters might be ignored
for sorting (@pxref{Sequence Functions}):

@example
@group
(sort (list "11" "12" "1 1" "1 2" "1.1" "1.2") 'string-collate-lessp)
     @result{} ("11" "1 1" "1.1" "12" "1 2" "1.2")
@end group
@end example

This behavior is system-dependent; e.g., punctuation and whitespace
are never ignored on Cygwin, regardless of locale.

The optional argument @var{locale}, a string, overrides the setting of
your current locale identifier for collation.  The value is system
dependent; a @var{locale} @code{"en_US.UTF-8"} is applicable on POSIX
systems, while it would be, e.g., @code{"enu_USA.1252"} on MS-Windows
systems.  The @var{locale} value of @code{"POSIX"} or @code{"C"} lets
@code{string-collate-lessp} behave like @code{string-lessp}:

@example
@group
(sort (list "11" "12" "1 1" "1 2" "1.1" "1.2")
      (lambda (s1 s2) (string-collate-lessp s1 s2 "POSIX")))
     @result{} ("1 1" "1 2" "1.1" "1.2" "11" "12")
@end group
@end example

If @var{ignore-case} is non-@code{nil}, characters are compared
case-insensitively, by converting them to lower-case.  However, if the
underlying system library doesn't provide locale-specific collation
rules, this function falls back to @code{string-lessp}, in which case
the @var{ignore-case} argument is ignored, and the comparison will
always be case-sensitive.

To emulate Unicode-compliant collation on MS-Windows systems,
bind @code{w32-collate-ignore-punctuation} to a non-@code{nil} value, since
the codeset part of the locale cannot be @code{"UTF-8"} on MS-Windows.

If your system does not support a locale environment, this function
behaves like @code{string-lessp}.
@end defun

@defun string-version-lessp string1 string2
This function compares strings lexicographically, except it treats
sequences of numerical characters as if they comprised a base-ten
number, and then compares the numbers.  So @samp{foo2.png} is
``smaller'' than @samp{foo12.png} according to this predicate, even if
@samp{12} is lexicographically ``smaller'' than @samp{2}.
@end defun

@defun string-prefix-p string1 string2 &optional ignore-case
This function returns non-@code{nil} if @var{string1} is a prefix of
@var{string2}; i.e., if @var{string2} starts with @var{string1}.  If
the optional argument @var{ignore-case} is non-@code{nil}, the
comparison ignores case differences.
@end defun

@defun string-suffix-p suffix string &optional ignore-case
This function returns non-@code{nil} if @var{suffix} is a suffix of
@var{string}; i.e., if @var{string} ends with @var{suffix}.  If the
optional argument @var{ignore-case} is non-@code{nil}, the comparison
ignores case differences.
@end defun

@defun string-search needle haystack &optional start-pos
Return the position of the first instance of @var{needle} in
@var{haystack}, both of which are strings.  If @var{start-pos} is
non-@code{nil}, start searching from that position in @var{needle}.
Return @code{nil} if no match was found.
This function only considers the characters in the strings when doing
the comparison; text properties are ignored.  Matching is always
case-sensitive.
@end defun

@defun compare-strings string1 start1 end1 string2 start2 end2 &optional ignore-case
This function compares a specified part of @var{string1} with a
specified part of @var{string2}.  The specified part of @var{string1}
runs from index @var{start1} (inclusive) up to index @var{end1}
(exclusive); @code{nil} for @var{start1} means the start of the
string, while @code{nil} for @var{end1} means the length of the
string.  Likewise, the specified part of @var{string2} runs from index
@var{start2} up to index @var{end2}.

The strings are compared by the numeric values of their characters.
For instance, @var{str1} is considered less than @var{str2} if
its first differing character has a smaller numeric value.  If
@var{ignore-case} is non-@code{nil}, characters are converted to
upper-case, using the current buffer's case-table (@pxref{Case
Tables}), before comparing them.  Unibyte strings are converted to
multibyte for comparison (@pxref{Text Representations}), so that a
unibyte string and its conversion to multibyte are always regarded as
equal.

If the specified portions of the two strings match, the value is
@code{t}.  Otherwise, the value is an integer which indicates how many
leading characters agree, and which string is less.  Its absolute
value is one plus the number of characters that agree at the beginning
of the two strings.  The sign is negative if @var{string1} (or its
specified portion) is less.
@end defun

@cindex Levenshtein distance
@cindex distance between strings
@cindex edit distance between strings
@defun string-distance string1 string2 &optional bytecompare
This function returns the @dfn{Levenshtein distance} between the
source string @var{string1} and the target string @var{string2}.  The
Levenshtein distance is the number of single-character
changes---deletions, insertions, or replacements---required to
transform the source string into the target string; it is one possible
definition of the @dfn{edit distance} between strings.

Letter-case of the strings is significant for the computed distance,
but their text properties are ignored.  If the optional argument
@var{bytecompare} is non-@code{nil}, the function calculates the
distance in terms of bytes instead of characters.  The byte-wise
comparison uses the internal Emacs representation of characters, so it
will produce inaccurate results for multibyte strings that include raw
bytes (@pxref{Text Representations}); make the strings unibyte by
encoding them (@pxref{Explicit Encoding}) if you need accurate results
with raw bytes.
@end defun

@defun assoc-string key alist &optional case-fold
This function works like @code{assoc}, except that @var{key} must be a
string or symbol, and comparison is done using @code{compare-strings}.
Symbols are converted to strings before testing.
If @var{case-fold} is non-@code{nil}, @var{key} and the elements of
@var{alist} are converted to upper-case before comparison.
Unlike @code{assoc}, this function can also match elements of the alist
that are strings or symbols rather than conses.  In particular, @var{alist} can
be a list of strings or symbols rather than an actual alist.
@xref{Association Lists}.
@end defun

  See also the function @code{compare-buffer-substrings} in
@ref{Comparing Text}, for a way to compare text in buffers.  The
function @code{string-match}, which matches a regular expression
against a string, can be used for a kind of string comparison; see
@ref{Regexp Search}.

@node String Conversion
@section Conversion of Characters and Strings
@cindex conversion of strings

  This section describes functions for converting between characters,
strings and integers.  @code{format} (@pxref{Formatting Strings}) and
@code{prin1-to-string} (@pxref{Output Functions}) can also convert
Lisp objects into strings.  @code{read-from-string} (@pxref{Input
Functions}) can convert a string representation of a Lisp object
into an object.  The functions @code{string-to-multibyte} and
@code{string-to-unibyte} convert the text representation of a string
(@pxref{Converting Representations}).

  @xref{Documentation}, for functions that produce textual descriptions
of text characters and general input events
(@code{single-key-description} and @code{text-char-description}).  These
are used primarily for making help messages.

@defun number-to-string number
@cindex integer to string
@cindex integer to decimal
This function returns a string consisting of the printed base-ten
representation of @var{number}.  The returned value starts with a
minus sign if the argument is negative.

@example
(number-to-string 256)
     @result{} "256"
@group
(number-to-string -23)
     @result{} "-23"
@end group
(number-to-string -23.5)
     @result{} "-23.5"
@end example

@cindex @code{int-to-string}
@code{int-to-string} is a semi-obsolete alias for this function.

See also the function @code{format} in @ref{Formatting Strings}.
@end defun

@defun string-to-number string &optional base
@cindex string to number
This function returns the numeric value of the characters in
@var{string}.  If @var{base} is non-@code{nil}, it must be an integer
between 2 and 16 (inclusive), and integers are converted in that base.
If @var{base} is @code{nil}, then base ten is used.  Floating-point
conversion only works in base ten; we have not implemented other
radices for floating-point numbers, because that would be much more
work and does not seem useful.

The parsing skips spaces and tabs at the beginning of @var{string},
then reads as much of @var{string} as it can interpret as a number in
the given base.  (On some systems it ignores other whitespace at the
beginning, not just spaces and tabs.)  If @var{string} cannot be
interpreted as a number, this function returns 0.

@example
(string-to-number "256")
     @result{} 256
(string-to-number "25 is a perfect square.")
     @result{} 25
(string-to-number "X256")
     @result{} 0
(string-to-number "-4.5")
     @result{} -4.5
(string-to-number "1e5")
     @result{} 100000.0
@end example

@findex string-to-int
@code{string-to-int} is an obsolete alias for this function.
@end defun

@defun char-to-string character
@cindex character to string
This function returns a new string containing one character,
@var{character}.  This function is semi-obsolete because the function
@code{string} is more general.  @xref{Creating Strings}.
@end defun

@defun string-to-char string
  This function returns the first character in @var{string}.  This is
mostly identical to @w{@code{(aref string 0)}}, except that it returns 0
if the string is empty.  (The value is also 0 when the first character
of @var{string} is the null character, @acronym{ASCII} code 0.)  This
function may be eliminated in the future if it does not seem useful
enough to retain.
@end defun

  Here are some other functions that can convert to or from a string:

@table @code
@item concat
This function converts a vector or a list into a string.
@xref{Creating Strings}.

@item vconcat
This function converts a string into a vector.  @xref{Vector
Functions}.

@item append
This function converts a string into a list.  @xref{Building Lists}.

@item byte-to-string
This function converts a byte of character data into a unibyte string.
@xref{Converting Representations}.
@end table

@node Formatting Strings
@section Formatting Strings
@cindex formatting strings
@cindex strings, formatting them

  @dfn{Formatting} means constructing a string by substituting
computed values at various places in a constant string.  This constant
string controls how the other values are printed, as well as where
they appear; it is called a @dfn{format string}.

  Formatting is often useful for computing messages to be displayed.  In
fact, the functions @code{message} and @code{error} provide the same
formatting feature described here; they differ from @code{format-message} only
in how they use the result of formatting.

@defun format string &rest objects
This function returns a string equal to @var{string}, replacing any format
specifications with encodings of the corresponding @var{objects}.  The
arguments @var{objects} are the computed values to be formatted.

The characters in @var{string}, other than the format specifications,
are copied directly into the output, including their text properties,
if any.  Any text properties of the format specifications are copied
to the produced string representations of the argument @var{objects}.

The output string need not be newly-allocated.  For example, if
@code{x} is the string @code{"foo"}, the expressions @code{(eq x
(format x))} and @code{(eq x (format "%s" x))} might both yield
@code{t}.
@end defun

@defun format-message string &rest objects
@cindex curved quotes, in formatted messages
@cindex curly quotes, in formatted messages
This function acts like @code{format}, except it also converts any
grave accents (@t{`}) and apostrophes (@t{'}) in @var{string} as per the
value of @code{text-quoting-style}.

Typically grave accent and apostrophe in the format translate to
matching curved quotes, e.g., @t{"Missing `%s'"} might result in
@t{"Missing ‘foo’"}.  @xref{Text Quoting Style}, for how to influence
or inhibit this translation.
@end defun

@cindex @samp{%} in format
@cindex format specification
  A format specification is a sequence of characters beginning with a
@samp{%}.  Thus, if there is a @samp{%d} in @var{string}, the
@code{format} function replaces it with the printed representation of
one of the values to be formatted (one of the arguments @var{objects}).
For example:

@example
@group
(format "The value of fill-column is %d." fill-column)
     @result{} "The value of fill-column is 72."
@end group
@end example

  Since @code{format} interprets @samp{%} characters as format
specifications, you should @emph{never} pass an arbitrary string as
the first argument.  This is particularly true when the string is
generated by some Lisp code.  Unless the string is @emph{known} to
never include any @samp{%} characters, pass @code{"%s"}, described
below, as the first argument, and the string as the second, like this:

@example
  (format "%s" @var{arbitrary-string})
@end example

  Certain format specifications require values of particular types.  If
you supply a value that doesn't fit the requirements, an error is
signaled.

  Here is a table of valid format specifications:

@table @samp
@item %s
Replace the specification with the printed representation of the object,
made without quoting (that is, using @code{princ}, not
@code{prin1}---@pxref{Output Functions}).  Thus, strings are represented
by their contents alone, with no @samp{"} characters, and symbols appear
without @samp{\} characters.

If the object is a string, its text properties are
copied into the output.  The text properties of the @samp{%s} itself
are also copied, but those of the object take priority.

@item %S
Replace the specification with the printed representation of the object,
made with quoting (that is, using @code{prin1}---@pxref{Output
Functions}).  Thus, strings are enclosed in @samp{"} characters, and
@samp{\} characters appear where necessary before special characters.

@item %o
@cindex integer to octal
Replace the specification with the base-eight representation of an
integer.  Negative integers are formatted in a platform-dependent
way.  The object can also be a floating-point number that is formatted
as an integer, dropping any fraction.

@item %d
Replace the specification with the base-ten representation of a signed
integer.  The object can also be a floating-point number that is
formatted as an integer, dropping any fraction.

@item %x
@itemx %X
@cindex integer to hexadecimal
Replace the specification with the base-sixteen representation of an
integer.  Negative integers are formatted in a platform-dependent
way.  @samp{%x} uses lower case and @samp{%X} uses upper
case.  The object can also be a floating-point number that is
formatted as an integer, dropping any fraction.

@item %c
Replace the specification with the character which is the value given.

@item %e
Replace the specification with the exponential notation for a
floating-point number.

@item %f
Replace the specification with the decimal-point notation for a
floating-point number.

@item %g
Replace the specification with notation for a floating-point number,
using either exponential notation or decimal-point notation.  The
exponential notation is used if the exponent would be less than @minus{}4 or
greater than or equal to the precision (default: 6).  By default,
trailing zeros are removed from the fractional portion of the result
and a decimal-point character appears only if it is followed by a
digit.

@item %%
Replace the specification with a single @samp{%}.  This format
specification is unusual in that its only form is plain
@samp{%%} and that it does not use a value.  For example,
@code{(format "%% %d" 30)} returns @code{"% 30"}.
@end table

  Any other format character results in an @samp{Invalid format
operation} error.

  Here are several examples, which assume the typical
@code{text-quoting-style} settings:

@example
@group
(format "The octal value of %d is %o,
         and the hex value is %x." 18 18 18)
     @result{} "The octal value of 18 is 22,
         and the hex value is 12."

(format-message
 "The name of this buffer is ‘%s’." (buffer-name))
     @result{} "The name of this buffer is ‘strings.texi’."

(format-message
 "The buffer object prints as `%s'." (current-buffer))
     @result{} "The buffer object prints as ‘strings.texi’."
@end group
@end example

  By default, format specifications correspond to successive values from
@var{objects}.  Thus, the first format specification in @var{string}
uses the first such value, the second format specification uses the
second such value, and so on.  Any extra format specifications (those
for which there are no corresponding values) cause an error.  Any
extra values to be formatted are ignored.

@cindex field numbers in format spec
  A format specification can have a @dfn{field number}, which is a
decimal number immediately after the initial @samp{%}, followed by a
literal dollar sign @samp{$}.  It causes the format specification to
convert the argument with the given number instead of the next
argument.  Field numbers start at 1.  A format can contain either
numbered or unnumbered format specifications but not both, except that
@samp{%%} can be mixed with numbered specifications.

@example
(format "%2$s, %3$s, %%, %1$s" "x" "y" "z")
     @result{} "y, z, %, x"
@end example

@cindex flags in format specifications
  After the @samp{%} and any field number, you can put certain
@dfn{flag characters}.

  The flag @samp{+} inserts a plus sign before a nonnegative number, so
that it always has a sign.  A space character as flag inserts a space
before a nonnegative number.  (Otherwise, nonnegative numbers start with the
first digit.)  These flags are useful for ensuring that nonnegative
and negative numbers use the same number of columns.  They are
ignored except for @samp{%d}, @samp{%e}, @samp{%f}, @samp{%g}, and if
both flags are used, @samp{+} takes precedence.

  The flag @samp{#} specifies an alternate form which depends on
the format in use.  For @samp{%o}, it ensures that the result begins
with a @samp{0}.  For @samp{%x} and @samp{%X}, it prefixes nonzero results
with @samp{0x} or @samp{0X}.  For @samp{%e} and @samp{%f}, the
@samp{#} flag means include a decimal point even if the precision is
zero.  For @samp{%g}, it always includes a decimal point, and also
forces any trailing zeros after the decimal point to be left in place
where they would otherwise be removed.

  The flag @samp{0} ensures that the padding consists of @samp{0}
characters instead of spaces.  This flag is ignored for non-numerical
specification characters like @samp{%s}, @samp{%S} and @samp{%c}.
These specification characters accept the @samp{0} flag, but still pad
with @emph{spaces}.

  The flag @samp{-} causes any padding inserted by the width,
if specified, to be inserted on the right rather than the left.
If both @samp{-} and @samp{0} are present, the @samp{0} flag is
ignored.

@example
@group
(format "%06d is padded on the left with zeros" 123)
     @result{} "000123 is padded on the left with zeros"

(format "'%-6d' is padded on the right" 123)
     @result{} "'123   ' is padded on the right"

(format "The word '%-7s' actually has %d letters in it."
        "foo" (length "foo"))
     @result{} "The word 'foo    ' actually has 3 letters in it."
@end group
@end example

@cindex field width
@cindex padding
  A specification can have a @dfn{width}, which is a decimal number
that appears after any field number and flags.  If the printed
representation of the object contains fewer characters than this
width, @code{format} extends it with padding.  Any padding introduced by
the width normally consists of spaces inserted on the left:

@example
(format "%5d is padded on the left with spaces" 123)
     @result{} "  123 is padded on the left with spaces"
@end example

@noindent
If the width is too small, @code{format} does not truncate the
object's printed representation.  Thus, you can use a width to specify
a minimum spacing between columns with no risk of losing information.
In the following two examples, @samp{%7s} specifies a minimum width
of 7.  In the first case, the string inserted in place of @samp{%7s}
has only 3 letters, and needs 4 blank spaces as padding.  In the
second case, the string @code{"specification"} is 13 letters wide but
is not truncated.

@example
@group
(format "The word '%7s' has %d letters in it."
        "foo" (length "foo"))
     @result{} "The word '    foo' has 3 letters in it."
(format "The word '%7s' has %d letters in it."
        "specification" (length "specification"))
     @result{} "The word 'specification' has 13 letters in it."
@end group
@end example

@cindex precision in format specifications
  All the specification characters allow an optional @dfn{precision}
after the field number, flags and width, if present.  The precision is
a decimal-point @samp{.} followed by a digit-string.  For the
floating-point specifications (@samp{%e} and @samp{%f}), the
precision specifies how many digits following the decimal point to
show; if zero, the decimal-point itself is also omitted.  For
@samp{%g}, the precision specifies how many significant digits to show
(significant digits are the first digit before the decimal point and
all the digits after it).  If the precision of %g is zero or
unspecified, it is treated as 1.  For @samp{%s} and @samp{%S}, the
precision truncates the string to the given width, so @samp{%.3s}
shows only the first three characters of the representation for
@var{object}.  For other specification characters, the effect of
precision is what the local library functions of the @code{printf}
family produce.

@cindex formatting numbers for rereading later
  If you plan to use @code{read} later on the formatted string to
retrieve a copy of the formatted value, use a specification that lets
@code{read} reconstruct the value.  To format numbers in this
reversible way you can use @samp{%s} and @samp{%S}, to format just
integers you can also use @samp{%d}, and to format just nonnegative
integers you can also use @samp{#x%x} and @samp{#o%o}.  Other formats
may be problematic; for example, @samp{%d} and @samp{%g} can mishandle
NaNs and can lose precision and type, and @samp{#x%x} and @samp{#o%o}
can mishandle negative integers.  @xref{Input Functions}.

The functions described in this section accept a fixed set of
specification characters.  The next section describes a function
@code{format-spec} which can accept custom specification characters,
such as @samp{%a} or @samp{%z}.

@node Custom Format Strings
@section Custom Format Strings
@cindex custom format string
@cindex custom @samp{%}-sequence in format

Sometimes it is useful to allow users and Lisp programs alike to
control how certain text is generated via custom format control
strings.  For example, a format string could control how to display
someone's forename, surname, and email address.  Using the function
@code{format} described in the previous section, the format string
could be something like @w{@code{"%s %s <%s>"}}.  This approach
quickly becomes impractical, however, as it can be unclear which
specification character corresponds to which piece of information.

A more convenient format string for such cases would be something like
@w{@code{"%f %l <%e>"}}, where each specification character carries
more semantic information and can easily be rearranged relative to
other specification characters, making such format strings more easily
customizable by the user.

The function @code{format-spec} described in this section performs a
similar function to @code{format}, except it operates on format
control strings that use arbitrary specification characters.

@defun format-spec template spec-alist &optional ignore-missing split
This function returns a string produced from the format string
@var{template} according to conversions specified in @var{spec-alist},
which is an alist (@pxref{Association Lists}) of the form
@w{@code{(@var{letter} . @var{replacement})}}.  Each specification
@code{%@var{letter}} in @var{template} will be replaced by
@var{replacement} when formatting the resulting string.

The characters in @var{template}, other than the format
specifications, are copied directly into the output, including their
text properties, if any.  Any text properties of the format
specifications are copied to their replacements.

Using an alist to specify conversions gives rise to some useful
properties:

@itemize @bullet
@item
If @var{spec-alist} contains more unique @var{letter} keys than there
are unique specification characters in @var{template}, the unused keys
are simply ignored.
@item
If @var{spec-alist} contains more than one association with the same
@var{letter}, the closest one to the start of the list is used.
@item
If @var{template} contains the same specification character more than
once, then the same @var{replacement} found in @var{spec-alist} is
used as a basis for all of that character's substitutions.
@item
The order of specifications in @var{template} need not correspond to
the order of associations in @var{spec-alist}.
@end itemize

REPLACEMENT can also be a function taking no arguments, and returning
a string to be used for the replacement.  It will only be called when
the corresponding LETTER is used in the TEMPLATE.  This is useful, for
example, to avoid prompting for input unless it is needed.

The optional argument @var{ignore-missing} indicates how to handle
specification characters in @var{template} that are not found in
@var{spec-alist}.  If it is @code{nil} or omitted, the function
signals an error; if it is @code{ignore}, those format specifications
are left verbatim in the output, including their text properties, if
any; if it is @code{delete}, those format specifications are removed
from the output; any other non-@code{nil} value is handled like
@code{ignore}, but any occurrences of @samp{%%} are also left verbatim
in the output.

If the optional argument @var{split} is non-@code{nil}, instead of
returning a single string, @code{format-spec} will split the result
into a list of strings, based on where the substitutions were
performed.  For instance:

@example
(format-spec "foo %b bar" '((?b . "zot")) nil t)
     @result{} ("foo " "zot" " bar")
@end example
@end defun

The syntax of format specifications accepted by @code{format-spec} is
similar, but not identical, to that accepted by @code{format}.  In
both cases, a format specification is a sequence of characters
beginning with @samp{%} and ending with an alphabetic letter such as
@samp{s}.

Unlike @code{format}, which assigns specific meanings to a fixed set
of specification characters, @code{format-spec} accepts arbitrary
specification characters and treats them all equally.  For example:

@example
@group
(setq my-site-info
      (list (cons ?s system-name)
            (cons ?t (symbol-name system-type))
            (cons ?c system-configuration)
            (cons ?v emacs-version)
            (cons ?e invocation-name)
            (cons ?p (number-to-string (emacs-pid)))
            (cons ?a user-mail-address)
            (cons ?n user-full-name)))

(format-spec "%e %v (%c)" my-site-info)
     @result{} "emacs 27.1 (x86_64-pc-linux-gnu)"

(format-spec "%n <%a>" my-site-info)
     @result{} "Emacs Developers <emacs-devel@@gnu.org>"
@end group
@end example

A format specification can include any number of the following flag
characters immediately after the @samp{%} to modify aspects of the
substitution.

@table @samp
@item 0
This flag causes any padding specified by the width to consist of
@samp{0} characters instead of spaces.

@item -
This flag causes any padding specified by the width to be inserted on
the right rather than the left.

@item <
This flag causes the substitution to be truncated on the left to the
given width and precision, if specified.

@item >
This flag causes the substitution to be truncated on the right to the
given width, if specified.

@item ^
This flag converts the substituted text to upper case (@pxref{Case
Conversion}).

@item _@r{ (underscore)}
This flag converts the substituted text to lower case (@pxref{Case
Conversion}).
@end table

The result of using contradictory flags (for instance, both upper and
lower case) is undefined.

As is the case with @code{format}, a format specification can include
a width, which is a decimal number that appears after any flags, and a
precision, which is a decimal-point @samp{.} followed by a decimal
number that appears after any flags and width.

If a substitution contains fewer characters than its specified width,
it is padded on the left:

@example
@group
(format-spec "%8a is padded on the left with spaces"
             '((?a . "alpha")))
     @result{} "   alpha is padded on the left with spaces"
@end group
@end example

If a substitution contains more characters than its specified
precision, it is truncated on the right:

@example
@group
(format-spec "%.2a is truncated on the right"
             '((?a . "alpha")))
     @result{} "al is truncated on the right"
@end group
@end example

Here is a more complicated example that combines several
aforementioned features:

@example
@group
(setq my-battery-info
      (list (cons ?p "73")      ; Percentage
            (cons ?L "Battery") ; Status
            (cons ?t "2:23")    ; Remaining time
            (cons ?c "24330")   ; Capacity
            (cons ?r "10.6")))  ; Rate of discharge

(format-spec "%>^-3L : %3p%% (%05t left)" my-battery-info)
     @result{} "BAT :  73% (02:23 left)"

(format-spec "%>^-3L : %3p%% (%05t left)"
             (cons (cons ?L "AC")
                   my-battery-info))
     @result{} "AC  :  73% (02:23 left)"
@end group
@end example

As the examples in this section illustrate, @code{format-spec} is
often used for selectively formatting an assortment of different
pieces of information.  This is useful in programs that provide
user-customizable format strings, as the user can choose to format
with a regular syntax and in any desired order only a subset of the
information that the program makes available.

@node Case Conversion
@section Case Conversion in Lisp
@cindex upper case
@cindex lower case
@cindex character case
@cindex case conversion in Lisp

  The character case functions change the case of single characters or
of the contents of strings.  The functions normally convert only
alphabetic characters (the letters @samp{A} through @samp{Z} and
@samp{a} through @samp{z}, as well as non-@acronym{ASCII} letters); other
characters are not altered.  You can specify a different case
conversion mapping by specifying a case table (@pxref{Case Tables}).

  These functions do not modify the strings that are passed to them as
arguments.

  The examples below use the characters @samp{X} and @samp{x} which have
@acronym{ASCII} codes 88 and 120 respectively.

@defun downcase string-or-char
This function converts @var{string-or-char}, which should be either a
character or a string, to lower case.

When @var{string-or-char} is a string, this function returns a new
string in which each letter in the argument that is upper case is
converted to lower case.  When @var{string-or-char} is a character,
this function returns the corresponding lower case character (an
integer); if the original character is lower case, or is not a letter,
the return value is equal to the original character.

@example
(downcase "The cat in the hat")
     @result{} "the cat in the hat"

(downcase ?X)
     @result{} 120
@end example
@end defun

@defun upcase string-or-char
This function converts @var{string-or-char}, which should be either a
character or a string, to upper case.

When @var{string-or-char} is a string, this function returns a new
string in which each letter in the argument that is lower case is
converted to upper case.  When @var{string-or-char} is a character,
this function returns the corresponding upper case character (an
integer); if the original character is upper case, or is not a letter,
the return value is equal to the original character.

@example
(upcase "The cat in the hat")
     @result{} "THE CAT IN THE HAT"

(upcase ?x)
     @result{} 88
@end example
@end defun

@defun capitalize string-or-char
@cindex capitalization
This function capitalizes strings or characters.  If
@var{string-or-char} is a string, the function returns a new string
whose contents are a copy of @var{string-or-char} in which each word
has been capitalized.  This means that the first character of each
word is converted to upper case, and the rest are converted to lower
case.

The definition of a word is any sequence of consecutive characters that
are assigned to the word constituent syntax class in the current syntax
table (@pxref{Syntax Class Table}).

When @var{string-or-char} is a character, this function does the same
thing as @code{upcase}.

@example
@group
(capitalize "The cat in the hat")
     @result{} "The Cat In The Hat"
@end group

@group
(capitalize "THE 77TH-HATTED CAT")
     @result{} "The 77th-Hatted Cat"
@end group

@group
(capitalize ?x)
     @result{} 88
@end group
@end example
@end defun

@defun upcase-initials string-or-char
If @var{string-or-char} is a string, this function capitalizes the
initials of the words in @var{string-or-char}, without altering any
letters other than the initials.  It returns a new string whose
contents are a copy of @var{string-or-char}, in which each word has
had its initial letter converted to upper case.

The definition of a word is any sequence of consecutive characters that
are assigned to the word constituent syntax class in the current syntax
table (@pxref{Syntax Class Table}).

When the argument to @code{upcase-initials} is a character,
@code{upcase-initials} has the same result as @code{upcase}.

@example
@group
(upcase-initials "The CAT in the hAt")
     @result{} "The CAT In The HAt"
@end group
@end example
@end defun

  Note that case conversion is not a one-to-one mapping of codepoints
and length of the result may differ from length of the argument.
Furthermore, because passing a character forces return type to be
a character, functions are unable to perform proper substitution and
result may differ compared to treating a one-character string.  For
example:

@ifnottex
@example
@group
(upcase "ﬁ")  ; note: single character, ligature "fi"
     @result{} "FI"
@end group
@group
(upcase ?ﬁ)
     @result{} 64257  ; i.e. ?ﬁ
@end group
@end example
@end ifnottex
@iftex
@example
@group
(upcase "@r{fi}")  ; note: single character, ligature "fi"
     @result{} "FI"
@end group
@group
(upcase ?@r{fi})
     @result{} 64257  ; i.e. ?@r{fi}
@end group
@end example
@end iftex

  To avoid this, a character must first be converted into a string,
using @code{string} function, before being passed to one of the casing
functions.  Of course, no assumptions on the length of the result may
be made.

  Mapping for such special cases are taken from
@code{special-uppercase}, @code{special-lowercase} and
@code{special-titlecase} @xref{Character Properties}.

  @xref{Text Comparison}, for functions that compare strings; some of
them ignore case differences, or can optionally ignore case differences.

@node Case Tables
@section The Case Table

  You can customize case conversion by installing a special @dfn{case
table}.  A case table specifies the mapping between upper case and lower
case letters.  It affects both the case conversion functions for Lisp
objects (see the previous section) and those that apply to text in the
buffer (@pxref{Case Changes}).  Each buffer has a case table; there is
also a standard case table which is used to initialize the case table
of new buffers.

  A case table is a char-table (@pxref{Char-Tables}) whose subtype is
@code{case-table}.  This char-table maps each character into the
corresponding lower case character.  It has three extra slots, which
hold related tables:

@table @var
@item upcase
The upcase table maps each character into the corresponding upper
case character.
@item canonicalize
The canonicalize table maps all of a set of case-related characters
into a particular member of that set.
@item equivalences
The equivalences table maps each one of a set of case-related characters
into the next character in that set.
@end table

  In simple cases, all you need to specify is the mapping to lower-case;
the three related tables will be calculated automatically from that one.

  For some languages, upper and lower case letters are not in one-to-one
correspondence.  There may be two different lower case letters with the
same upper case equivalent.  In these cases, you need to specify the
maps for both lower case and upper case.

  The extra table @var{canonicalize} maps each character to a canonical
equivalent; any two characters that are related by case-conversion have
the same canonical equivalent character.  For example, since @samp{a}
and @samp{A} are related by case-conversion, they should have the same
canonical equivalent character (which should be either @samp{a} for both
of them, or @samp{A} for both of them).

  The extra table @var{equivalences} is a map that cyclically permutes
each equivalence class (of characters with the same canonical
equivalent).  (For ordinary @acronym{ASCII}, this would map @samp{a} into
@samp{A} and @samp{A} into @samp{a}, and likewise for each set of
equivalent characters.)

  When constructing a case table, you can provide @code{nil} for
@var{canonicalize}; then Emacs fills in this slot from the lower case
and upper case mappings.  You can also provide @code{nil} for
@var{equivalences}; then Emacs fills in this slot from
@var{canonicalize}.  In a case table that is actually in use, those
components are non-@code{nil}.  Do not try to specify
@var{equivalences} without also specifying @var{canonicalize}.

  Here are the functions for working with case tables:

@defun case-table-p object
This predicate returns non-@code{nil} if @var{object} is a valid case
table.
@end defun

@defun set-standard-case-table table
This function makes @var{table} the standard case table, so that it will
be used in any buffers created subsequently.
@end defun

@defun standard-case-table
This returns the standard case table.
@end defun

@defun current-case-table
This function returns the current buffer's case table.
@end defun

@defun set-case-table table
This sets the current buffer's case table to @var{table}.
@end defun

@defmac with-case-table table body@dots{}
The @code{with-case-table} macro saves the current case table, makes
@var{table} the current case table, evaluates the @var{body} forms,
and finally restores the case table.  The return value is the value of
the last form in @var{body}.  The case table is restored even in case
of an abnormal exit via @code{throw} or error (@pxref{Nonlocal
Exits}).
@end defmac

  Some language environments modify the case conversions of
@acronym{ASCII} characters; for example, in the Turkish language
environment, the @acronym{ASCII} capital I is downcased into
a Turkish dotless i (@samp{ı}).  This can interfere with code that requires
ordinary @acronym{ASCII} case conversion, such as implementations of
@acronym{ASCII}-based network protocols.  In that case, use the
@code{with-case-table} macro with the variable @var{ascii-case-table},
which stores the unmodified case table for the @acronym{ASCII}
character set.

@defvar ascii-case-table
The case table for the @acronym{ASCII} character set.  This should not be
modified by any language environment settings.
@end defvar

  The following three functions are convenient subroutines for packages
that define non-@acronym{ASCII} character sets.  They modify the specified
case table @var{case-table}; they also modify the standard syntax table.
@xref{Syntax Tables}.  Normally you would use these functions to change
the standard case table.

@defun set-case-syntax-pair uc lc case-table
This function specifies a pair of corresponding letters, one upper case
and one lower case.
@end defun

@defun set-case-syntax-delims l r case-table
This function makes characters @var{l} and @var{r} a matching pair of
case-invariant delimiters.
@end defun

@defun set-case-syntax char syntax case-table
This function makes @var{char} case-invariant, with syntax
@var{syntax}.
@end defun

@deffn Command describe-buffer-case-table
This command displays a description of the contents of the current
buffer's case table.
@end deffn
