@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2021 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Functions
@chapter Functions

  A Lisp program is composed mainly of Lisp functions.  This chapter
explains what functions are, how they accept arguments, and how to
define them.

@menu
* What Is a Function::          Lisp functions vs. primitives; terminology.
* Lambda Expressions::          How functions are expressed as Lisp objects.
* Function Names::              A symbol can serve as the name of a function.
* Defining Functions::          Lisp expressions for defining functions.
* Calling Functions::           How to use an existing function.
* Mapping Functions::           Applying a function to each element of a list, etc.
* Anonymous Functions::         Lambda expressions are functions with no names.
* Generic Functions::           Polymorphism, Emacs-style.
* Function Cells::              Accessing or setting the function definition
                            of a symbol.
* Closures::                    Functions that enclose a lexical environment.
* Advising Functions::          Adding to the definition of a function.
* Obsolete Functions::          Declaring functions obsolete.
* Inline Functions::            Functions that the compiler will expand inline.
* Declare Form::                Adding additional information about a function.
* Declaring Functions::         Telling the compiler that a function is defined.
* Function Safety::             Determining whether a function is safe to call.
* Related Topics::              Cross-references to specific Lisp primitives
                            that have a special bearing on how functions work.
@end menu

@node What Is a Function
@section What Is a Function?

@cindex return value
@cindex value of function
@cindex argument
@cindex pure function
  In a general sense, a function is a rule for carrying out a
computation given input values called @dfn{arguments}.  The result of
the computation is called the @dfn{value} or @dfn{return value} of the
function.  The computation can also have side effects, such as lasting
changes in the values of variables or the contents of data structures
(@pxref{Definition of side effect}).  A @dfn{pure function} is a
function which, in addition to having no side effects, always returns
the same value for the same combination of arguments, regardless of
external factors such as machine type or system state.

  In most computer languages, every function has a name.  But in Lisp,
a function in the strictest sense has no name: it is an object which
can @emph{optionally} be associated with a symbol (e.g., @code{car})
that serves as the function name.  @xref{Function Names}.  When a
function has been given a name, we usually also refer to that symbol
as a ``function'' (e.g., we refer to ``the function @code{car}'').
In this manual, the distinction between a function name and the
function object itself is usually unimportant, but we will take note
wherever it is relevant.

  Certain function-like objects, called @dfn{special forms} and
@dfn{macros}, also accept arguments to carry out computations.
However, as explained below, these are not considered functions in
Emacs Lisp.

  Here are important terms for functions and function-like objects:

@table @dfn
@item lambda expression
A function (in the strict sense, i.e., a function object) which is
written in Lisp.  These are described in the following section.
@ifnottex
@xref{Lambda Expressions}.
@end ifnottex

@item primitive
@cindex primitive
@cindex subr
@cindex built-in function
A function which is callable from Lisp but is actually written in C@.
Primitives are also called @dfn{built-in functions}, or @dfn{subrs}.
Examples include functions like @code{car} and @code{append}.  In
addition, all special forms (see below) are also considered
primitives.

Usually, a function is implemented as a primitive because it is a
fundamental part of Lisp (e.g., @code{car}), or because it provides a
low-level interface to operating system services, or because it needs
to run fast.  Unlike functions defined in Lisp, primitives can be
modified or added only by changing the C sources and recompiling
Emacs.  See @ref{Writing Emacs Primitives}.

@item special form
A primitive that is like a function but does not evaluate all of its
arguments in the usual way.  It may evaluate only some of the
arguments, or may evaluate them in an unusual order, or several times.
Examples include @code{if}, @code{and}, and @code{while}.
@xref{Special Forms}.

@item macro
@cindex macro
A construct defined in Lisp, which differs from a function in that it
translates a Lisp expression into another expression which is to be
evaluated instead of the original expression.  Macros enable Lisp
programmers to do the sorts of things that special forms can do.
@xref{Macros}.

@item command
@cindex command
An object which can be invoked via the @code{command-execute}
primitive, usually due to the user typing in a key sequence
@dfn{bound} to that command.  @xref{Interactive Call}.  A command is
usually a function; if the function is written in Lisp, it is made
into a command by an @code{interactive} form in the function
definition (@pxref{Defining Commands}).  Commands that are functions
can also be called from Lisp expressions, just like other functions.

Keyboard macros (strings and vectors) are commands also, even though
they are not functions.  @xref{Keyboard Macros}.  We say that a symbol
is a command if its function cell contains a command (@pxref{Symbol
Components}); such a @dfn{named command} can be invoked with
@kbd{M-x}.

@item closure
A function object that is much like a lambda expression, except that
it also encloses an environment of lexical variable bindings.
@xref{Closures}.

@item byte-code function
A function that has been compiled by the byte compiler.
@xref{Byte-Code Type}.

@item autoload object
@cindex autoload object
A place-holder for a real function.  If the autoload object is called,
Emacs loads the file containing the definition of the real function,
and then calls the real function.  @xref{Autoload}.
@end table

  You can use the function @code{functionp} to test if an object is a
function:

@defun functionp object
This function returns @code{t} if @var{object} is any kind of
function, i.e., can be passed to @code{funcall}.  Note that
@code{functionp} returns @code{t} for symbols that are function names,
and returns @code{nil} for special forms.
@end defun

  It is also possible to find out how many arguments an arbitrary
function expects:

@defun func-arity function
This function provides information about the argument list of the
specified @var{function}.  The returned value is a cons cell of the
form @w{@code{(@var{min} . @var{max})}}, where @var{min} is the
minimum number of arguments, and @var{max} is either the maximum
number of arguments, or the symbol @code{many} for functions with
@code{&rest} arguments, or the symbol @code{unevalled} if
@var{function} is a special form.

Note that this function might return inaccurate results in some
situations, such as the following:

@itemize @minus
@item
Functions defined using @code{apply-partially} (@pxref{Calling
Functions, apply-partially}).

@item
Functions that are advised using @code{advice-add} (@pxref{Advising
Named Functions}).

@item
Functions that determine the argument list dynamically, as part of
their code.
@end itemize

@end defun

@noindent
Unlike @code{functionp}, the next three functions do @emph{not} treat
a symbol as its function definition.

@defun subrp object
This function returns @code{t} if @var{object} is a built-in function
(i.e., a Lisp primitive).

@example
@group
(subrp 'message)            ; @r{@code{message} is a symbol,}
     @result{} nil                 ;   @r{not a subr object.}
@end group
@group
(subrp (symbol-function 'message))
     @result{} t
@end group
@end example
@end defun

@defun byte-code-function-p object
This function returns @code{t} if @var{object} is a byte-code
function.  For example:

@example
@group
(byte-code-function-p (symbol-function 'next-line))
     @result{} t
@end group
@end example
@end defun

@defun subr-arity subr
This works like @code{func-arity}, but only for built-in functions and
without symbol indirection.  It signals an error for non-built-in
functions.  We recommend to use @code{func-arity} instead.
@end defun

@node Lambda Expressions
@section Lambda Expressions
@cindex lambda expression

  A lambda expression is a function object written in Lisp.  Here is
an example:

@example
(lambda (x)
  "Return the hyperbolic cosine of X."
  (* 0.5 (+ (exp x) (exp (- x)))))
@end example

@noindent
In Emacs Lisp, such a list is a valid expression which evaluates to
a function object.

  A lambda expression, by itself, has no name; it is an @dfn{anonymous
function}.  Although lambda expressions can be used this way
(@pxref{Anonymous Functions}), they are more commonly associated with
symbols to make @dfn{named functions} (@pxref{Function Names}).
Before going into these details, the following subsections describe
the components of a lambda expression and what they do.

@menu
* Lambda Components::           The parts of a lambda expression.
* Simple Lambda::               A simple example.
* Argument List::               Details and special features of argument lists.
* Function Documentation::      How to put documentation in a function.
@end menu

@node Lambda Components
@subsection Components of a Lambda Expression

  A lambda expression is a list that looks like this:

@example
(lambda (@var{arg-variables}@dots{})
  [@var{documentation-string}]
  [@var{interactive-declaration}]
  @var{body-forms}@dots{})
@end example

@cindex lambda list
  The first element of a lambda expression is always the symbol
@code{lambda}.  This indicates that the list represents a function.  The
reason functions are defined to start with @code{lambda} is so that
other lists, intended for other uses, will not accidentally be valid as
functions.

  The second element is a list of symbols---the argument variable
names (@pxref{Argument List}).
This is called the @dfn{lambda list}.  When a Lisp function is called,
the argument values are matched up against the variables in the lambda
list, which are given local bindings with the values provided.
@xref{Local Variables}.

  The documentation string is a Lisp string object placed within the
function definition to describe the function for the Emacs help
facilities.  @xref{Function Documentation}.

  The interactive declaration is a list of the form @code{(interactive
@var{code-string})}.  This declares how to provide arguments if the
function is used interactively.  Functions with this declaration are called
@dfn{commands}; they can be called using @kbd{M-x} or bound to a key.
Functions not intended to be called in this way should not have interactive
declarations.  @xref{Defining Commands}, for how to write an interactive
declaration.

@cindex body of function
  The rest of the elements are the @dfn{body} of the function: the Lisp
code to do the work of the function (or, as a Lisp programmer would say,
``a list of Lisp forms to evaluate'').  The value returned by the
function is the value returned by the last element of the body.

@node Simple Lambda
@subsection A Simple Lambda Expression Example

  Consider the following example:

@example
(lambda (a b c) (+ a b c))
@end example

@noindent
We can call this function by passing it to @code{funcall}, like this:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 2 3)
@end group
@end example

@noindent
This call evaluates the body of the lambda expression  with the variable
@code{a} bound to 1, @code{b} bound to 2, and @code{c} bound to 3.
Evaluation of the body adds these three numbers, producing the result 6;
therefore, this call to the function returns the value 6.

  Note that the arguments can be the results of other function calls, as in
this example:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 (* 2 3) (- 5 4))
@end group
@end example

@noindent
This evaluates the arguments @code{1}, @code{(* 2 3)}, and @code{(- 5
4)} from left to right.  Then it applies the lambda expression to the
argument values 1, 6 and 1 to produce the value 8.

  As these examples show, you can use a form with a lambda expression
as its @sc{car} to make local variables and give them values.  In the
old days of Lisp, this technique was the only way to bind and
initialize local variables.  But nowadays, it is clearer to use the
special form @code{let} for this purpose (@pxref{Local Variables}).
Lambda expressions are mainly used as anonymous functions for passing
as arguments to other functions (@pxref{Anonymous Functions}), or
stored as symbol function definitions to produce named functions
(@pxref{Function Names}).

@node Argument List
@subsection Features of Argument Lists
@kindex wrong-number-of-arguments
@cindex argument binding
@cindex binding arguments
@cindex argument lists, features

  Our simple sample function, @code{(lambda (a b c) (+ a b c))},
specifies three argument variables, so it must be called with three
arguments: if you try to call it with only two arguments or four
arguments, you get a @code{wrong-number-of-arguments} error
(@pxref{Errors}).

  It is often convenient to write a function that allows certain
arguments to be omitted.  For example, the function @code{substring}
accepts three arguments---a string, the start index and the end
index---but the third argument defaults to the @var{length} of the
string if you omit it.  It is also convenient for certain functions to
accept an indefinite number of arguments, as the functions @code{list}
and @code{+} do.

@cindex optional arguments
@cindex rest arguments
@kindex &optional
@kindex &rest
  To specify optional arguments that may be omitted when a function
is called, simply include the keyword @code{&optional} before the optional
arguments.  To specify a list of zero or more extra arguments, include the
keyword @code{&rest} before one final argument.

  Thus, the complete syntax for an argument list is as follows:

@example
@group
(@var{required-vars}@dots{}
 @r{[}&optional @r{[}@var{optional-vars}@dots{}@r{]}@r{]}
 @r{[}&rest @r{[}@var{rest-var}@r{]}@r{]})
@end group
@end example

@noindent
The square brackets indicate that the @code{&optional} and @code{&rest}
clauses, and the variables that follow them, are optional.

  A call to the function requires one actual argument for each of the
@var{required-vars}.  There may be actual arguments for zero or more of
the @var{optional-vars}, and there cannot be any actual arguments beyond
that unless the lambda list uses @code{&rest}.  In that case, there may
be any number of extra actual arguments.

  If actual arguments for the optional and rest variables are omitted,
then they always default to @code{nil}.  There is no way for the
function to distinguish between an explicit argument of @code{nil} and
an omitted argument.  However, the body of the function is free to
consider @code{nil} an abbreviation for some other meaningful value.
This is what @code{substring} does; @code{nil} as the third argument to
@code{substring} means to use the length of the string supplied.

@cindex CL note---default optional arg
@quotation
@b{Common Lisp note:} Common Lisp allows the function to specify what
default value to use when an optional argument is omitted; Emacs Lisp
always uses @code{nil}.  Emacs Lisp does not support @code{supplied-p}
variables that tell you whether an argument was explicitly passed.
@end quotation

  For example, an argument list that looks like this:

@example
(a b &optional c d &rest e)
@end example

@noindent
binds @code{a} and @code{b} to the first two actual arguments, which are
required.  If one or two more arguments are provided, @code{c} and
@code{d} are bound to them respectively; any arguments after the first
four are collected into a list and @code{e} is bound to that list.
Thus, if there are only two arguments, @code{c}, @code{d} and @code{e}
are @code{nil}; if two or three arguments, @code{d} and @code{e} are
@code{nil}; if four arguments or fewer, @code{e} is @code{nil}.  Note
that exactly five arguments with an explicit @code{nil} argument
provided for @code{e} will cause that @code{nil} argument to be passed
as a list with one element, @code{(nil)}, as with any other single
value for @code{e}.

  There is no way to have required arguments following optional
ones---it would not make sense.  To see why this must be so, suppose
that @code{c} in the example were optional and @code{d} were required.
Suppose three actual arguments are given; which variable would the
third argument be for?  Would it be used for the @var{c}, or for
@var{d}?  One can argue for both possibilities.  Similarly, it makes
no sense to have any more arguments (either required or optional)
after a @code{&rest} argument.

  Here are some examples of argument lists and proper calls:

@example
(funcall (lambda (n) (1+ n))        ; @r{One required:}
         1)                         ; @r{requires exactly one argument.}
     @result{} 2
(funcall (lambda (n &optional n1)   ; @r{One required and one optional:}
           (if n1 (+ n n1) (1+ n))) ; @r{1 or 2 arguments.}
         1 2)
     @result{} 3
(funcall (lambda (n &rest ns)       ; @r{One required and one rest:}
           (+ n (apply '+ ns)))     ; @r{1 or more arguments.}
         1 2 3 4 5)
     @result{} 15
@end example

@node Function Documentation
@subsection Documentation Strings of Functions
@cindex documentation string of function
@cindex function's documentation string

  A lambda expression may optionally have a @dfn{documentation string}
just after the lambda list.  This string does not affect execution of
the function; it is a kind of comment, but a systematized comment
which actually appears inside the Lisp world and can be used by the
Emacs help facilities.  @xref{Documentation}, for how the
documentation string is accessed.

  It is a good idea to provide documentation strings for all the
functions in your program, even those that are called only from within
your program.  Documentation strings are like comments, except that they
are easier to access.

  The first line of the documentation string should stand on its own,
because @code{apropos} displays just this first line.  It should consist
of one or two complete sentences that summarize the function's purpose.

  The start of the documentation string is usually indented in the
source file, but since these spaces come before the starting
double-quote, they are not part of the string.  Some people make a
practice of indenting any additional lines of the string so that the
text lines up in the program source.  @emph{That is a mistake.}  The
indentation of the following lines is inside the string; what looks
nice in the source code will look ugly when displayed by the help
commands.

  You may wonder how the documentation string could be optional, since
there are required components of the function that follow it (the body).
Since evaluation of a string returns that string, without any side effects,
it has no effect if it is not the last form in the body.  Thus, in
practice, there is no confusion between the first form of the body and the
documentation string; if the only body form is a string then it serves both
as the return value and as the documentation.

  The last line of the documentation string can specify calling
conventions different from the actual function arguments.  Write
text like this:

@example
\(fn @var{arglist})
@end example

@noindent
following a blank line, at the beginning of the line, with no newline
following it inside the documentation string.  (The @samp{\} is used
to avoid confusing the Emacs motion commands.)  The calling convention
specified in this way appears in help messages in place of the one
derived from the actual arguments of the function.

  This feature is particularly useful for macro definitions, since the
arguments written in a macro definition often do not correspond to the
way users think of the parts of the macro call.

  Do not use this feature if you want to deprecate the calling
convention and favor the one you advertise by the above specification.
Instead, use the @code{advertised-calling-convention} declaration
(@pxref{Declare Form}) or @code{set-advertised-calling-convention}
(@pxref{Obsolete Functions}), because these two will cause the byte
compiler emit a warning message when it compiles Lisp programs which
use the deprecated calling convention.

@node Function Names
@section Naming a Function
@cindex function definition
@cindex named function
@cindex function name

  A symbol can serve as the name of a function.  This happens when the
symbol's @dfn{function cell} (@pxref{Symbol Components}) contains a
function object (e.g., a lambda expression).  Then the symbol itself
becomes a valid, callable function, equivalent to the function object
in its function cell.

  The contents of the function cell are also called the symbol's
@dfn{function definition}.  The procedure of using a symbol's function
definition in place of the symbol is called @dfn{symbol function
indirection}; see @ref{Function Indirection}.  If you have not given a
symbol a function definition, its function cell is said to be
@dfn{void}, and it cannot be used as a function.

  In practice, nearly all functions have names, and are referred to by
their names.  You can create a named Lisp function by defining a
lambda expression and putting it in a function cell (@pxref{Function
Cells}).  However, it is more common to use the @code{defun} special
form, described in the next section.
@ifnottex
@xref{Defining Functions}.
@end ifnottex

  We give functions names because it is convenient to refer to them by
their names in Lisp expressions.  Also, a named Lisp function can
easily refer to itself---it can be recursive.  Furthermore, primitives
can only be referred to textually by their names, since primitive
function objects (@pxref{Primitive Function Type}) have no read
syntax.

  A function need not have a unique name.  A given function object
@emph{usually} appears in the function cell of only one symbol, but
this is just a convention.  It is easy to store it in several symbols
using @code{fset}; then each of the symbols is a valid name for the
same function.

  Note that a symbol used as a function name may also be used as a
variable; these two uses of a symbol are independent and do not
conflict.  (This is not the case in some dialects of Lisp, like
Scheme.)

  By convention, if a function's symbol consists of two names
separated by @samp{--}, the function is intended for internal use and
the first part names the file defining the function.  For example, a
function named @code{vc-git--rev-parse} is an internal function
defined in @file{vc-git.el}.  Internal-use functions written in C have
names ending in @samp{-internal}, e.g., @code{bury-buffer-internal}.
Emacs code contributed before 2018 may follow other internal-use
naming conventions, which are being phased out.

@node Defining Functions
@section Defining Functions
@cindex defining a function

  We usually give a name to a function when it is first created.  This
is called @dfn{defining a function}, and we usually do it with the
@code{defun} macro.  This section also describes other ways to define
a function.

@defmac defun name args [doc] [declare] [interactive] body@dots{}
@code{defun} is the usual way to define new Lisp functions.  It
defines the symbol @var{name} as a function with argument list
@var{args} (@pxref{Argument List}) and body forms given by @var{body}.
Neither @var{name} nor @var{args} should be quoted.

@var{doc}, if present, should be a string specifying the function's
documentation string (@pxref{Function Documentation}).  @var{declare},
if present, should be a @code{declare} form specifying function
metadata (@pxref{Declare Form}).  @var{interactive}, if present,
should be an @code{interactive} form specifying how the function is to
be called interactively (@pxref{Interactive Call}).

The return value of @code{defun} is undefined.

Here are some examples:

@example
@group
(defun foo () 5)
(foo)
     @result{} 5
@end group

@group
(defun bar (a &optional b &rest c)
    (list a b c))
(bar 1 2 3 4 5)
     @result{} (1 2 (3 4 5))
@end group
@group
(bar 1)
     @result{} (1 nil nil)
@end group
@group
(bar)
@error{} Wrong number of arguments.
@end group

@group
(defun capitalize-backwards ()
  "Upcase the last letter of the word at point."
  (interactive)
  (backward-word 1)
  (forward-word 1)
  (backward-char 1)
  (capitalize-word 1))
@end group
@end example

@cindex override existing functions
@cindex redefine existing functions
Be careful not to redefine existing functions unintentionally.
@code{defun} redefines even primitive functions such as @code{car}
without any hesitation or notification.  Emacs does not prevent you
from doing this, because redefining a function is sometimes done
deliberately, and there is no way to distinguish deliberate
redefinition from unintentional redefinition.
@end defmac

@cindex function aliases
@cindex alias, for functions
@defun defalias name definition &optional doc
@anchor{Definition of defalias}
This function defines the symbol @var{name} as a function, with
definition @var{definition} (which can be any valid Lisp function).
Its return value is @emph{undefined}.

If @var{doc} is non-@code{nil}, it becomes the function documentation
of @var{name}.  Otherwise, any documentation provided by
@var{definition} is used.

@cindex defalias-fset-function property
Internally, @code{defalias} normally uses @code{fset} to set the definition.
If @var{name} has a @code{defalias-fset-function} property, however,
the associated value is used as a function to call in place of @code{fset}.

The proper place to use @code{defalias} is where a specific function
name is being defined---especially where that name appears explicitly in
the source file being loaded.  This is because @code{defalias} records
which file defined the function, just like @code{defun}
(@pxref{Unloading}).

By contrast, in programs that manipulate function definitions for other
purposes, it is better to use @code{fset}, which does not keep such
records.  @xref{Function Cells}.
@end defun

  You cannot create a new primitive function with @code{defun} or
@code{defalias}, but you can use them to change the function definition of
any symbol, even one such as @code{car} or @code{x-popup-menu} whose
normal definition is a primitive.  However, this is risky: for
instance, it is next to impossible to redefine @code{car} without
breaking Lisp completely.  Redefining an obscure function such as
@code{x-popup-menu} is less dangerous, but it still may not work as
you expect.  If there are calls to the primitive from C code, they
call the primitive's C definition directly, so changing the symbol's
definition will have no effect on them.

  See also @code{defsubst}, which defines a function like @code{defun}
and tells the Lisp compiler to perform inline expansion on it.
@xref{Inline Functions}.

  To undefine a function name, use @code{fmakunbound}.
@xref{Function Cells}.

@node Calling Functions
@section Calling Functions
@cindex function invocation
@cindex calling a function

  Defining functions is only half the battle.  Functions don't do
anything until you @dfn{call} them, i.e., tell them to run.  Calling a
function is also known as @dfn{invocation}.

  The most common way of invoking a function is by evaluating a list.
For example, evaluating the list @code{(concat "a" "b")} calls the
function @code{concat} with arguments @code{"a"} and @code{"b"}.
@xref{Evaluation}, for a description of evaluation.

  When you write a list as an expression in your program, you specify
which function to call, and how many arguments to give it, in the text
of the program.  Usually that's just what you want.  Occasionally you
need to compute at run time which function to call.  To do that, use
the function @code{funcall}.  When you also need to determine at run
time how many arguments to pass, use @code{apply}.

@defun funcall function &rest arguments
@code{funcall} calls @var{function} with @var{arguments}, and returns
whatever @var{function} returns.

Since @code{funcall} is a function, all of its arguments, including
@var{function}, are evaluated before @code{funcall} is called.  This
means that you can use any expression to obtain the function to be
called.  It also means that @code{funcall} does not see the
expressions you write for the @var{arguments}, only their values.
These values are @emph{not} evaluated a second time in the act of
calling @var{function}; the operation of @code{funcall} is like the
normal procedure for calling a function, once its arguments have
already been evaluated.

The argument @var{function} must be either a Lisp function or a
primitive function.  Special forms and macros are not allowed, because
they make sense only when given the unevaluated argument
expressions.  @code{funcall} cannot provide these because, as we saw
above, it never knows them in the first place.

If you need to use @code{funcall} to call a command and make it behave
as if invoked interactively, use @code{funcall-interactively}
(@pxref{Interactive Call}).

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(funcall f 'x 'y 'z)
     @result{} (x y z)
@end group
@group
(funcall f 'x 'y '(z))
     @result{} (x y (z))
@end group
@group
(funcall 'and t nil)
@error{} Invalid function: #<subr and>
@end group
@end example

Compare these examples with the examples of @code{apply}.
@end defun

@defun apply function &rest arguments
@code{apply} calls @var{function} with @var{arguments}, just like
@code{funcall} but with one difference: the last of @var{arguments} is a
list of objects, which are passed to @var{function} as separate
arguments, rather than a single list.  We say that @code{apply}
@dfn{spreads} this list so that each individual element becomes an
argument.

@code{apply} with a single argument is special: the first element of
the argument, which must be a non-empty list, is called as a function
with the remaining elements as individual arguments.  Passing two or
more arguments will be faster.

@code{apply} returns the result of calling @var{function}.  As with
@code{funcall}, @var{function} must either be a Lisp function or a
primitive function; special forms and macros do not make sense in
@code{apply}.

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(apply f 'x 'y 'z)
@error{} Wrong type argument: listp, z
@end group
@group
(apply '+ 1 2 '(3 4))
     @result{} 10
@end group
@group
(apply '+ '(1 2 3 4))
     @result{} 10
@end group

@group
(apply 'append '((a b c) nil (x y z) nil))
     @result{} (a b c x y z)
@end group

@group
(apply '(+ 3 4))
     @result{} 7
@end group
@end example

For an interesting example of using @code{apply}, see @ref{Definition
of mapcar}.
@end defun

@cindex partial application of functions
@cindex currying
  Sometimes it is useful to fix some of the function's arguments at
certain values, and leave the rest of arguments for when the function
is actually called.  The act of fixing some of the function's
arguments is called @dfn{partial application} of the function@footnote{
This is related to, but different from @dfn{currying}, which
transforms a function that takes multiple arguments in such a way that
it can be called as a chain of functions, each one with a single
argument.}.
The result is a new function that accepts the rest of
arguments and calls the original function with all the arguments
combined.

  Here's how to do partial application in Emacs Lisp:

@defun apply-partially func &rest args
This function returns a new function which, when called, will call
@var{func} with the list of arguments composed from @var{args} and
additional arguments specified at the time of the call.  If @var{func}
accepts @var{n} arguments, then a call to @code{apply-partially} with
@w{@code{@var{m} < @var{n}}} arguments will produce a new function of
@w{@code{@var{n} - @var{m}}} arguments.

Here's how we could define the built-in function @code{1+}, if it
didn't exist, using @code{apply-partially} and @code{+}, another
built-in function:

@example
@group
(defalias '1+ (apply-partially '+ 1)
  "Increment argument by one.")
@end group
@group
(1+ 10)
     @result{} 11
@end group
@end example
@end defun

@cindex functionals
  It is common for Lisp functions to accept functions as arguments or
find them in data structures (especially in hook variables and property
lists) and call them using @code{funcall} or @code{apply}.  Functions
that accept function arguments are often called @dfn{functionals}.

  Sometimes, when you call a functional, it is useful to supply a no-op
function as the argument.  Here are two different kinds of no-op
function:

@defun identity argument
This function returns @var{argument} and has no side effects.
@end defun

@defun ignore &rest arguments
This function ignores any @var{arguments} and returns @code{nil}.
@end defun

@defun always &rest arguments
This function ignores any @var{arguments} and returns @code{t}.
@end defun

  Some functions are user-visible @dfn{commands}, which can be called
interactively (usually by a key sequence).  It is possible to invoke
such a command exactly as though it was called interactively, by using
the @code{call-interactively} function.  @xref{Interactive Call}.

@node Mapping Functions
@section Mapping Functions
@cindex mapping functions

  A @dfn{mapping function} applies a given function (@emph{not} a
special form or macro) to each element of a list or other collection.
Emacs Lisp has several such functions; this section describes
@code{mapcar}, @code{mapc}, @code{mapconcat}, and @code{mapcan}, which
map over a list.  @xref{Definition of mapatoms}, for the function
@code{mapatoms} which maps over the symbols in an obarray.
@xref{Definition of maphash}, for the function @code{maphash} which
maps over key/value associations in a hash table.

  These mapping functions do not allow char-tables because a char-table
is a sparse array whose nominal range of indices is very large.  To map
over a char-table in a way that deals properly with its sparse nature,
use the function @code{map-char-table} (@pxref{Char-Tables}).

@defun mapcar function sequence
@anchor{Definition of mapcar}
@code{mapcar} applies @var{function} to each element of @var{sequence}
in turn, and returns a list of the results.

The argument @var{sequence} can be any kind of sequence except a
char-table; that is, a list, a vector, a bool-vector, or a string.  The
result is always a list.  The length of the result is the same as the
length of @var{sequence}.  For example:

@example
@group
(mapcar 'car '((a b) (c d) (e f)))
     @result{} (a c e)
(mapcar '1+ [1 2 3])
     @result{} (2 3 4)
(mapcar 'string "abc")
     @result{} ("a" "b" "c")
@end group

@group
;; @r{Call each function in @code{my-hooks}.}
(mapcar 'funcall my-hooks)
@end group

@group
(defun mapcar* (function &rest args)
  "Apply FUNCTION to successive cars of all ARGS.
Return the list of results."
  ;; @r{If no list is exhausted,}
  (if (not (memq nil args))
      ;; @r{apply function to @sc{car}s.}
      (cons (apply function (mapcar 'car args))
            (apply 'mapcar* function
                   ;; @r{Recurse for rest of elements.}
                   (mapcar 'cdr args)))))
@end group

@group
(mapcar* 'cons '(a b c) '(1 2 3 4))
     @result{} ((a . 1) (b . 2) (c . 3))
@end group
@end example
@end defun

@defun mapcan function sequence
This function applies @var{function} to each element of
@var{sequence}, like @code{mapcar}, but instead of collecting the
results into a list, it returns a single list with all the elements of
the results (which must be lists), by altering the results (using
@code{nconc}; @pxref{Rearrangement}).  Like with @code{mapcar},
@var{sequence} can be of any type except a char-table.

@example
@group
;; @r{Contrast this:}
(mapcar 'list '(a b c d))
     @result{} ((a) (b) (c) (d))
;; @r{with this:}
(mapcan 'list '(a b c d))
     @result{} (a b c d)
@end group
@end example
@end defun

@defun mapc function sequence
@code{mapc} is like @code{mapcar} except that @var{function} is used for
side-effects only---the values it returns are ignored, not collected
into a list.  @code{mapc} always returns @var{sequence}.
@end defun

@defun mapconcat function sequence separator
@code{mapconcat} applies @var{function} to each element of
@var{sequence}; the results, which must be sequences of characters
(strings, vectors, or lists), are concatenated into a single string
return value.  Between each pair of result sequences, @code{mapconcat}
inserts the characters from @var{separator}, which also must be a
string, or a vector or list of characters.  @xref{Sequences Arrays
Vectors}.

The argument @var{function} must be a function that can take one
argument and returns a sequence of characters: a string, a vector, or
a list.  The argument @var{sequence} can be any kind of sequence
except a char-table; that is, a list, a vector, a bool-vector, or a
string.

@example
@group
(mapconcat 'symbol-name
           '(The cat in the hat)
           " ")
     @result{} "The cat in the hat"
@end group

@group
(mapconcat (lambda (x) (format "%c" (1+ x)))
           "HAL-8000"
           "")
     @result{} "IBM.9111"
@end group
@end example
@end defun

@node Anonymous Functions
@section Anonymous Functions
@cindex anonymous function

  Although functions are usually defined with @code{defun} and given
names at the same time, it is sometimes convenient to use an explicit
lambda expression---an @dfn{anonymous function}.  Anonymous functions
are valid wherever function names are.  They are often assigned as
variable values, or as arguments to functions; for instance, you might
pass one as the @var{function} argument to @code{mapcar}, which
applies that function to each element of a list (@pxref{Mapping
Functions}).  @xref{describe-symbols example}, for a realistic example
of this.

  When defining a lambda expression that is to be used as an anonymous
function, you can in principle use any method to construct the list.
But typically you should use the @code{lambda} macro, or the
@code{function} special form, or the @code{#'} read syntax:

@defmac lambda args [doc] [interactive] body@dots{}
This macro returns an anonymous function with argument list
@var{args}, documentation string @var{doc} (if any), interactive spec
@var{interactive} (if any), and body forms given by @var{body}.

Under dynamic binding, this macro effectively makes @code{lambda}
forms self-quoting: evaluating a form whose @sc{car} is @code{lambda}
yields the form itself:

@example
(lambda (x) (* x x))
     @result{} (lambda (x) (* x x))
@end example

Note that when evaluating under lexical binding the result is a
closure object (@pxref{Closures}).

The @code{lambda} form has one other effect: it tells the Emacs
evaluator and byte-compiler that its argument is a function, by using
@code{function} as a subroutine (see below).
@end defmac

@defspec function function-object
@cindex function quoting
This special form returns @var{function-object} without evaluating it.
In this, it is similar to @code{quote} (@pxref{Quoting}).  But unlike
@code{quote}, it also serves as a note to the Emacs evaluator and
byte-compiler that @var{function-object} is intended to be used as a
function.  Assuming @var{function-object} is a valid lambda
expression, this has two effects:

@itemize
@item
When the code is byte-compiled, @var{function-object} is compiled into
a byte-code function object (@pxref{Byte Compilation}).

@item
When lexical binding is enabled, @var{function-object} is converted
into a closure.  @xref{Closures}.
@end itemize

When @var{function-object} is a symbol and the code is byte compiled,
the byte-compiler will warn if that function is not defined or might
not be known at run time.
@end defspec

@cindex @samp{#'} syntax
The read syntax @code{#'} is a short-hand for using @code{function}.
The following forms are all equivalent:

@example
(lambda (x) (* x x))
(function (lambda (x) (* x x)))
#'(lambda (x) (* x x))
@end example

  In the following example, we define a @code{change-property}
function that takes a function as its third argument, followed by a
@code{double-property} function that makes use of
@code{change-property} by passing it an anonymous function:

@example
@group
(defun change-property (symbol prop function)
  (let ((value (get symbol prop)))
    (put symbol prop (funcall function value))))
@end group

@group
(defun double-property (symbol prop)
  (change-property symbol prop (lambda (x) (* 2 x))))
@end group
@end example

@noindent
Note that we do not quote the @code{lambda} form.

  If you compile the above code, the anonymous function is also
compiled.  This would not happen if, say, you had constructed the
anonymous function by quoting it as a list:

@c Do not unquote this lambda!
@example
@group
(defun double-property (symbol prop)
  (change-property symbol prop '(lambda (x) (* 2 x))))
@end group
@end example

@noindent
In that case, the anonymous function is kept as a lambda expression in
the compiled code.  The byte-compiler cannot assume this list is a
function, even though it looks like one, since it does not know that
@code{change-property} intends to use it as a function.

@node Generic Functions
@section Generic Functions
@cindex generic functions
@cindex polymorphism

  Functions defined using @code{defun} have a hard-coded set of
assumptions about the types and expected values of their arguments.
For example, a function that was designed to handle values of its
argument that are either numbers or lists of numbers will fail or
signal an error if called with a value of any other type, such as a
vector or a string.  This happens because the implementation of the
function is not prepared to deal with types other than those assumed
during the design.

  By contrast, object-oriented programs use @dfn{polymorphic
functions}: a set of specialized functions having the same name, each
one of which was written for a certain specific set of argument types.
Which of the functions is actually called is decided at run time based
on the types of the actual arguments.

@cindex CLOS
  Emacs provides support for polymorphism.  Like other Lisp
environments, notably Common Lisp and its Common Lisp Object System
(@acronym{CLOS}), this support is based on @dfn{generic functions}.
The Emacs generic functions closely follow @acronym{CLOS}, including
use of similar names, so if you have experience with @acronym{CLOS},
the rest of this section will sound very familiar.

  A generic function specifies an abstract operation, by defining its
name and list of arguments, but (usually) no implementation.  The
actual implementation for several specific classes of arguments is
provided by @dfn{methods}, which should be defined separately.  Each
method that implements a generic function has the same name as the
generic function, but the method's definition indicates what kinds of
arguments it can handle by @dfn{specializing} the arguments defined by
the generic function.  These @dfn{argument specializers} can be more
or less specific; for example, a @code{string} type is more specific
than a more general type, such as @code{sequence}.

  Note that, unlike in message-based OO languages, such as C@t{++} and
Simula, methods that implement generic functions don't belong to a
class, they belong to the generic function they implement.

  When a generic function is invoked, it selects the applicable
methods by comparing the actual arguments passed by the caller with
the argument specializers of each method.  A method is applicable if
the actual arguments of the call are compatible with the method's
specializers.  If more than one method is applicable, they are
combined using certain rules, described below, and the combination
then handles the call.

@defmac cl-defgeneric name arguments [documentation] [options-and-methods@dots{}] &rest body
This macro defines a generic function with the specified @var{name}
and @var{arguments}.  If @var{body} is present, it provides the
default implementation.  If @var{documentation} is present (it should
always be), it specifies the documentation string for the generic
function, in the form @code{(:documentation @var{docstring})}.  The
optional @var{options-and-methods} can be one of the following forms:

@table @code
@item (declare @var{declarations})
A declare form, as described in @ref{Declare Form}.
@item (:argument-precedence-order &rest @var{args})
This form affects the sorting order for combining applicable methods.
Normally, when two methods are compared during combination, method
arguments are examined left to right, and the first method whose
argument specializer is more specific will come before the other one.
The order defined by this form overrides that, and the arguments are
examined according to their order in this form, and not left to right.
@item (:method [@var{qualifiers}@dots{}] args &rest body)
This form defines a method like @code{cl-defmethod} does.
@end table
@end defmac

@defmac cl-defmethod name [qualifier] arguments [&context (expr spec)@dots{}] &rest [docstring] body
This macro defines a particular implementation for the generic
function called @var{name}.  The implementation code is given by
@var{body}.  If present, @var{docstring} is the documentation string
for the method.  The @var{arguments} list, which must be identical in
all the methods that implement a generic function, and must match the
argument list of that function, provides argument specializers of the
form @code{(@var{arg} @var{spec})}, where @var{arg} is the argument
name as specified in the @code{cl-defgeneric} call, and @var{spec} is
one of the following specializer forms:

@table @code
@item @var{type}
This specializer requires the argument to be of the given @var{type},
one of the types from the type hierarchy described below.
@item (eql @var{object})
This specializer requires the argument be @code{eql} to the given
@var{object}.
@item (head @var{object})
The argument must be a cons cell whose @code{car} is @code{eql} to
@var{object}.
@item @var{struct-type}
The argument must be an instance of a class named @var{struct-type}
defined with @code{cl-defstruct} (@pxref{Structures,,, cl, Common Lisp
Extensions for GNU Emacs Lisp}), or of one of its child classes.
@end table

Method definitions can make use of a new argument-list keyword,
@code{&context}, which introduces extra specializers that test the
environment at the time the method is run.  This keyword should appear
after the list of required arguments, but before any @code{&rest} or
@code{&optional} keywords.  The @code{&context} specializers look much
like regular argument specializers---(@var{expr} @var{spec})---except
that @var{expr} is an expression to be evaluated in the current
context, and the @var{spec} is a value to compare against.  For
example, @code{&context (overwrite-mode (eql t))} will make the method
applicable only when @code{overwrite-mode} is turned on.  The
@code{&context} keyword can be followed by any number of context
specializers.  Because the context specializers are not part of the
generic function's argument signature, they may be omitted in methods
that don't require them.

The type specializer, @code{(@var{arg} @var{type})}, can specify one
of the @dfn{system types} in the following list.  When a parent type
is specified, an argument whose type is any of its more specific child
types, as well as grand-children, grand-grand-children, etc. will also
be compatible.

@table @code
@item integer
Parent type: @code{number}.
@item number
@item null
Parent type: @code{symbol}
@item symbol
@item string
Parent type: @code{array}.
@item array
Parent type: @code{sequence}.
@item cons
Parent type: @code{list}.
@item list
Parent type: @code{sequence}.
@item marker
@item overlay
@item float
Parent type: @code{number}.
@item window-configuration
@item process
@item window
@item subr
@item compiled-function
@item buffer
@item char-table
Parent type: @code{array}.
@item bool-vector
Parent type: @code{array}.
@item vector
Parent type: @code{array}.
@item frame
@item hash-table
@item font-spec
@item font-entity
@item font-object
@end table

The optional @var{qualifier} allows combining several applicable
methods.  If it is not present, the defined method is a @dfn{primary}
method, responsible for providing the primary implementation of the
generic function for the specialized arguments.  You can also define
@dfn{auxiliary methods}, by using one of the following values as
@var{qualifier}:

@table @code
@item :before
This auxiliary method will run before the primary method.  More
accurately, all the @code{:before} methods will run before the
primary, in the most-specific-first order.
@item :after
This auxiliary method will run after the primary method.  More
accurately, all such methods will run after the primary, in the
most-specific-last order.
@item :around
This auxiliary method will run @emph{instead} of the primary method.
The most specific of such methods will be run before any other method.
Such methods normally use @code{cl-call-next-method}, described below,
to invoke the other auxiliary or primary methods.
@item :extra @var{string}
This allows you to add more methods, distinguished by @var{string},
for the same specializers and qualifiers.
@end table

Functions defined using @code{cl-defmethod} cannot be made
interactive, i.e.@: commands (@pxref{Defining Commands}), by adding
the @code{interactive} form to them.  If you need a polymorphic
command, we recommend defining a normal command that calls a
polymorphic function defined via @code{cl-defgeneric} and
@code{cl-defmethod}.
@end defmac

@cindex dispatch of methods for generic function
@cindex multiple-dispatch methods
Each time a generic function is called, it builds the @dfn{effective
method} which will handle this invocation by combining the applicable
methods defined for the function.  The process of finding the
applicable methods and producing the effective method is called
@dfn{dispatch}.  The applicable methods are those all of whose
specializers are compatible with the actual arguments of the call.
Since all of the arguments must be compatible with the specializers,
they all determine whether a method is applicable.  Methods that
explicitly specialize more than one argument are called
@dfn{multiple-dispatch methods}.

The applicable methods are sorted into the order in which they will be
combined.  The method whose left-most argument specializer is the most
specific one will come first in the order.  (Specifying
@code{:argument-precedence-order} as part of @code{cl-defmethod}
overrides that, as described above.)  If the method body calls
@code{cl-call-next-method}, the next most-specific method will run.
If there are applicable @code{:around} methods, the most-specific of
them will run first; it should call @code{cl-call-next-method} to run
any of the less specific @code{:around} methods.  Next, the
@code{:before} methods run in the order of their specificity, followed
by the primary method, and lastly the @code{:after} methods in the
reverse order of their specificity.

@defun cl-call-next-method &rest args
When invoked from within the lexical body of a primary or an
@code{:around} auxiliary method, call the next applicable method for
the same generic function.  Normally, it is called with no arguments,
which means to call the next applicable method with the same arguments
that the calling method was invoked.  Otherwise, the specified
arguments are used instead.
@end defun

@defun cl-next-method-p
This function, when called from within the lexical body of a primary
or an @code{:around} auxiliary method, returns non-@code{nil} if there
is a next method to call.
@end defun


@node Function Cells
@section Accessing Function Cell Contents

  The @dfn{function definition} of a symbol is the object stored in the
function cell of the symbol.  The functions described here access, test,
and set the function cell of symbols.

  See also the function @code{indirect-function}.  @xref{Definition of
indirect-function}.

@defun symbol-function symbol
@kindex void-function
This returns the object in the function cell of @var{symbol}.  It does
not check that the returned object is a legitimate function.

If the function cell is void, the return value is @code{nil}.  To
distinguish between a function cell that is void and one set to
@code{nil}, use @code{fboundp} (see below).

@example
@group
(defun bar (n) (+ n 2))
(symbol-function 'bar)
     @result{} (lambda (n) (+ n 2))
@end group
@group
(fset 'baz 'bar)
     @result{} bar
@end group
@group
(symbol-function 'baz)
     @result{} bar
@end group
@end example
@end defun

@cindex void function cell
  If you have never given a symbol any function definition, we say
that that symbol's function cell is @dfn{void}.  In other words, the
function cell does not have any Lisp object in it.  If you try to call
the symbol as a function, Emacs signals a @code{void-function} error.

  Note that void is not the same as @code{nil} or the symbol
@code{void}.  The symbols @code{nil} and @code{void} are Lisp objects,
and can be stored into a function cell just as any other object can be
(and they can be valid functions if you define them in turn with
@code{defun}).  A void function cell contains no object whatsoever.

  You can test the voidness of a symbol's function definition with
@code{fboundp}.  After you have given a symbol a function definition, you
can make it void once more using @code{fmakunbound}.

@defun fboundp symbol
This function returns @code{t} if the symbol has an object in its
function cell, @code{nil} otherwise.  It does not check that the object
is a legitimate function.
@end defun

@defun fmakunbound symbol
This function makes @var{symbol}'s function cell void, so that a
subsequent attempt to access this cell will cause a
@code{void-function} error.  It returns @var{symbol}.  (See also
@code{makunbound}, in @ref{Void Variables}.)

@example
@group
(defun foo (x) x)
(foo 1)
     @result{}1
@end group
@group
(fmakunbound 'foo)
     @result{} foo
@end group
@group
(foo 1)
@error{} Symbol's function definition is void: foo
@end group
@end example
@end defun

@defun fset symbol definition
This function stores @var{definition} in the function cell of
@var{symbol}.  The result is @var{definition}.  Normally
@var{definition} should be a function or the name of a function, but
this is not checked.  The argument @var{symbol} is an ordinary evaluated
argument.

The primary use of this function is as a subroutine by constructs that define
or alter functions, like @code{defun} or @code{advice-add} (@pxref{Advising
Functions}).  You can also use it to give a symbol a function definition that
is not a function, e.g., a keyboard macro (@pxref{Keyboard Macros}):

@example
;; @r{Define a named keyboard macro.}
(fset 'kill-two-lines "\^u2\^k")
     @result{} "\^u2\^k"
@end example

It you wish to use @code{fset} to make an alternate name for a
function, consider using @code{defalias} instead.  @xref{Definition of
defalias}.
@end defun

@node Closures
@section Closures

  As explained in @ref{Variable Scoping}, Emacs can optionally enable
lexical binding of variables.  When lexical binding is enabled, any
named function that you create (e.g., with @code{defun}), as well as
any anonymous function that you create using the @code{lambda} macro
or the @code{function} special form or the @code{#'} syntax
(@pxref{Anonymous Functions}), is automatically converted into a
@dfn{closure}.

@cindex closure
  A closure is a function that also carries a record of the lexical
environment that existed when the function was defined.  When it is
invoked, any lexical variable references within its definition use the
retained lexical environment.  In all other respects, closures behave
much like ordinary functions; in particular, they can be called in the
same way as ordinary functions.

  @xref{Lexical Binding}, for an example of using a closure.

  Currently, an Emacs Lisp closure object is represented by a list
with the symbol @code{closure} as the first element, a list
representing the lexical environment as the second element, and the
argument list and body forms as the remaining elements:

@example
;; @r{lexical binding is enabled.}
(lambda (x) (* x x))
     @result{} (closure (t) (x) (* x x))
@end example

@noindent
However, the fact that the internal structure of a closure is
exposed to the rest of the Lisp world is considered an internal
implementation detail.  For this reason, we recommend against directly
examining or altering the structure of closure objects.

@node Advising Functions
@section Advising Emacs Lisp Functions
@cindex advising functions
@cindex piece of advice

When you need to modify a function defined in another library, or when you need
to modify a hook like @code{@var{foo}-function}, a process filter, or basically
any variable or object field which holds a function value, you can use the
appropriate setter function, such as @code{fset} or @code{defun} for named
functions, @code{setq} for hook variables, or @code{set-process-filter} for
process filters, but those are often too blunt, completely throwing away the
previous value.

  The @dfn{advice} feature lets you add to the existing definition of
a function, by @dfn{advising the function}.  This is a cleaner method
than redefining the whole function.

Emacs's advice system provides two sets of primitives for that: the core set,
for function values held in variables and object fields (with the corresponding
primitives being @code{add-function} and @code{remove-function}) and another
set layered on top of it for named functions (with the main primitives being
@code{advice-add} and @code{advice-remove}).

As a trivial example, here's how to add advice that'll modify the
return value of a function every time it's called:

@example
(defun my-double (x)
  (* x 2))
(defun my-increase (x)
  (+ x 1))
(advice-add 'my-double :filter-return #'my-increase)
@end example

After adding this advice, if you call @code{my-double} with @samp{3},
the return value will be @samp{7}.  To remove this advice, say

@example
(advice-remove 'my-double #'my-increase)
@end example

A more advanced example would be to trace the calls to the process
filter of a process @var{proc}:

@example
(defun my-tracing-function (proc string)
  (message "Proc %S received %S" proc string))

(add-function :before (process-filter @var{proc}) #'my-tracing-function)
@end example

This will cause the process's output to be passed to @code{my-tracing-function}
before being passed to the original process filter.  @code{my-tracing-function}
receives the same arguments as the original function.  When you're done with
it, you can revert to the untraced behavior with:

@example
(remove-function (process-filter @var{proc}) #'my-tracing-function)
@end example

Similarly, if you want to trace the execution of the function named
@code{display-buffer}, you could use:

@example
(defun his-tracing-function (orig-fun &rest args)
  (message "display-buffer called with args %S" args)
  (let ((res (apply orig-fun args)))
    (message "display-buffer returned %S" res)
    res))

(advice-add 'display-buffer :around #'his-tracing-function)
@end example

Here, @code{his-tracing-function} is called instead of the original function
and receives the original function (additionally to that function's arguments)
as argument, so it can call it if and when it needs to.
When you're tired of seeing this output, you can revert to the untraced
behavior with:

@example
(advice-remove 'display-buffer #'his-tracing-function)
@end example

The arguments @code{:before} and @code{:around} used in the above examples
specify how the two functions are composed, since there are many different
ways to do it.  The added function is also called a piece of @emph{advice}.

@menu
* Core Advising Primitives::    Primitives to manipulate advice.
* Advising Named Functions::    Advising named functions.
* Advice Combinators::          Ways to compose advice.
* Porting Old Advice::          Adapting code using the old defadvice.
@end menu

@node Core Advising Primitives
@subsection Primitives to manipulate advices
@cindex advice, add and remove

@defmac add-function where place function &optional props
This macro is the handy way to add the advice @var{function} to the function
stored in @var{place} (@pxref{Generalized Variables}).

@var{where} determines how @var{function} is composed with the
existing function, e.g., whether @var{function} should be called before, or
after the original function.  @xref{Advice Combinators}, for the list of
available ways to compose the two functions.

When modifying a variable (whose name will usually end with @code{-function}),
you can choose whether @var{function} is used globally or only in the current
buffer: if @var{place} is just a symbol, then @var{function} is added to the
global value of @var{place}.  Whereas if @var{place} is of the form
@code{(local @var{symbol})}, where @var{symbol} is an expression which returns
the variable name, then @var{function} will only be added in the
current buffer.  Finally, if you want to modify a lexical variable, you will
have to use @code{(var @var{variable})}.

Every function added with @code{add-function} can be accompanied by an
association list of properties @var{props}.  Currently only two of those
properties have a special meaning:

@table @code
@item name
This gives a name to the advice, which @code{remove-function} can use to
identify which function to remove.  Typically used when @var{function} is an
anonymous function.

@item depth
This specifies how to order the advice, should several pieces of
advice be present.  By default, the depth is 0.  A depth of 100
indicates that this piece of advice should be kept as deep as
possible, whereas a depth of @minus{}100 indicates that it should stay as the
outermost piece.  When two pieces of advice specify the same depth,
the most recently added one will be outermost.

For @code{:before} advice, being outermost means that this advice will
be run first, before any other advice, whereas being innermost means
that it will run right before the original function, with no other
advice run between itself and the original function.  Similarly, for
@code{:after} advice innermost means that it will run right after the
original function, with no other advice run in between, whereas
outermost means that it will be run right at the end after all other
advice.  An innermost @code{:override} piece of advice will only
override the original function and other pieces of advice will apply
to it, whereas an outermost @code{:override} piece of advice will
override not only the original function but all other advice applied
to it as well.
@end table

If @var{function} is not interactive, then the combined function will inherit
the interactive spec, if any, of the original function.  Else, the combined
function will be interactive and will use the interactive spec of
@var{function}.  One exception: if the interactive spec of @var{function}
is a function (i.e., a @code{lambda} expression or an @code{fbound}
symbol rather than an expression or a string), then the interactive
spec of the combined function will be a call to that function with as sole
argument the interactive spec of the original function.  To interpret the spec
received as argument, use @code{advice-eval-interactive-spec}.

Note: The interactive spec of @var{function} will apply to the combined
function and should hence obey the calling convention of the combined function
rather than that of @var{function}.  In many cases, it makes no difference
since they are identical, but it does matter for @code{:around},
@code{:filter-args}, and @code{:filter-return}, where @var{function}
receives different arguments than the original function stored in
@var{place}.
@end defmac

@defmac remove-function place function
This macro removes @var{function} from the function stored in
@var{place}.  This only works if @var{function} was added to @var{place}
using @code{add-function}.

@var{function} is compared with functions added to @var{place} using
@code{equal}, to try and make it work also with lambda expressions.  It is
additionally compared also with the @code{name} property of the functions added
to @var{place}, which can be more reliable than comparing lambda expressions
using @code{equal}.
@end defmac

@defun advice-function-member-p advice function-def
Return non-@code{nil} if @var{advice} is already in @var{function-def}.
Like for @code{remove-function} above, instead of @var{advice} being the actual
function, it can also be the @code{name} of the piece of advice.
@end defun

@defun advice-function-mapc f function-def
Call the function @var{f} for every piece of advice that was added to
@var{function-def}.  @var{f} is called with two arguments: the advice function
and its properties.
@end defun

@defun advice-eval-interactive-spec spec
Evaluate the interactive @var{spec} just like an interactive call to a function
with such a spec would, and then return the corresponding list of arguments
that was built.  E.g., @code{(advice-eval-interactive-spec "r\nP")} will
return a list of three elements, containing the boundaries of the region and
the current prefix argument.

For instance, if you want to make the @kbd{C-x m}
(@code{compose-mail}) command prompt for a @samp{From:} header, you
could say something like this:

@example
(defun my-compose-mail-advice (orig &rest args)
  "Read From: address interactively."
  (interactive
   (lambda (spec)
     (let* ((user-mail-address
             (completing-read "From: "
                              '("one.address@@example.net"
                                "alternative.address@@example.net")))
            (from (message-make-from user-full-name
                                     user-mail-address))
            (spec (advice-eval-interactive-spec spec)))
       ;; Put the From header into the OTHER-HEADERS argument.
       (push (cons 'From from) (nth 2 spec))
       spec)))
  (apply orig args))

(advice-add 'compose-mail :around #'my-compose-mail-advice)
@end example
@end defun

@node Advising Named Functions
@subsection Advising Named Functions
@cindex advising named functions

A common use of advice is for named functions and macros.
You could just use @code{add-function} as in:

@example
(add-function :around (symbol-function '@var{fun}) #'his-tracing-function)
@end example

  But you should use @code{advice-add} and @code{advice-remove} for that
instead.  This separate set of functions to manipulate pieces of advice applied
to named functions, offers the following extra features compared to
@code{add-function}: they know how to deal with macros and autoloaded
functions, they let @code{describe-function} preserve the original docstring as
well as document the added advice, and they let you add and remove advice
before a function is even defined.

  @code{advice-add} can be useful for altering the behavior of existing calls
to an existing function without having to redefine the whole function.
However, it can be a source of bugs, since existing callers to the function may
assume the old behavior, and work incorrectly when the behavior is changed by
advice.  Advice can also cause confusion in debugging, if the person doing the
debugging does not notice or remember that the function has been modified
by advice.

  For these reasons, advice should be reserved for the cases where you
cannot modify a function's behavior in any other way.  If it is
possible to do the same thing via a hook, that is preferable
(@pxref{Hooks}).  If you simply want to change what a particular key
does, it may be better to write a new command, and remap the old
command's key bindings to the new one (@pxref{Remapping Commands}).

  If you are writing code for release, for others to use, try to avoid
including advice in it.  If the function you want to advise has no
hook to do the job, please talk with the Emacs developers about adding
a suitable hook.  Especially, Emacs's own source files should not put
advice on functions in Emacs.  (There are currently a few exceptions
to this convention, but we aim to correct them.)  It is generally
cleaner to create a new hook in @code{foo}, and make @code{bar} use
the hook, than to have @code{bar} put advice in @code{foo}.

  Special forms (@pxref{Special Forms}) cannot be advised, however macros can
be advised, in much the same way as functions.  Of course, this will not affect
code that has already been macro-expanded, so you need to make sure the advice
is installed before the macro is expanded.

  It is possible to advise a primitive (@pxref{What Is a Function}),
but one should typically @emph{not} do so, for two reasons.  Firstly,
some primitives are used by the advice mechanism, and advising them
could cause an infinite recursion.  Secondly, many primitives are
called directly from C, and such calls ignore advice; hence, one ends
up in a confusing situation where some calls (occurring from Lisp
code) obey the advice and other calls (from C code) do not.

@defmac define-advice symbol (where lambda-list &optional name depth) &rest body
This macro defines a piece of advice and adds it to the function named
@var{symbol}.  The advice is an anonymous function if @var{name} is
@code{nil} or a function named @code{symbol@@name}.  See
@code{advice-add} for explanation of other arguments.
@end defmac

@defun advice-add symbol where function &optional props
Add the advice @var{function} to the named function @var{symbol}.
@var{where} and @var{props} have the same meaning as for @code{add-function}
(@pxref{Core Advising Primitives}).
@end defun

@defun advice-remove symbol function
Remove the advice @var{function} from the named function @var{symbol}.
@var{function} can also be the @code{name} of a piece of advice.
@end defun

@defun advice-member-p function symbol
Return non-@code{nil} if the advice @var{function} is already in the named
function @var{symbol}.  @var{function} can also be the @code{name} of
a piece of advice.
@end defun

@defun advice-mapc function symbol
Call @var{function} for every piece of advice that was added to the
named function @var{symbol}.  @var{function} is called with two
arguments: the advice function and its properties.
@end defun

@node Advice Combinators
@subsection Ways to compose advice

Here are the different possible values for the @var{where} argument of
@code{add-function} and @code{advice-add}, specifying how the advice
@var{function} and the original function should be composed.

@table @code
@item :before
Call @var{function} before the old function.  Both functions receive the
same arguments, and the return value of the composition is the return value of
the old function.  More specifically, the composition of the two functions
behaves like:
@example
(lambda (&rest r) (apply @var{function} r) (apply @var{oldfun} r))
@end example
@code{(add-function :before @var{funvar} @var{function})} is comparable for
single-function hooks to @code{(add-hook '@var{hookvar} @var{function})} for
normal hooks.

@item :after
Call @var{function} after the old function.  Both functions receive the
same arguments, and the return value of the composition is the return value of
the old function.  More specifically, the composition of the two functions
behaves like:
@example
(lambda (&rest r) (prog1 (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after @var{funvar} @var{function})} is comparable for
single-function hooks to @code{(add-hook '@var{hookvar} @var{function}
'append)} for normal hooks.

@item :override
This completely replaces the old function with the new one.  The old function
can of course be recovered if you later call @code{remove-function}.

@item :around
Call @var{function} instead of the old function, but provide the old function
as an extra argument to @var{function}.  This is the most flexible composition.
For example, it lets you call the old function with different arguments, or
many times, or within a let-binding, or you can sometimes delegate the work to
the old function and sometimes override it completely.  More specifically, the
composition of the two functions behaves like:
@example
(lambda (&rest r) (apply @var{function} @var{oldfun} r))
@end example

@item :before-while
Call @var{function} before the old function and don't call the old
function if @var{function} returns @code{nil}.  Both functions receive the
same arguments, and the return value of the composition is the return value of
the old function.  More specifically, the composition of the two functions
behaves like:
@example
(lambda (&rest r) (and (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-while @var{funvar} @var{function})} is comparable
for single-function hooks to @code{(add-hook '@var{hookvar} @var{function})}
when @var{hookvar} is run via @code{run-hook-with-args-until-failure}.

@item :before-until
Call @var{function} before the old function and only call the old function if
@var{function} returns @code{nil}.  More specifically, the composition of the
two functions behaves like:
@example
(lambda (&rest r) (or (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-until @var{funvar} @var{function})} is comparable
for single-function hooks to @code{(add-hook '@var{hookvar} @var{function})}
when @var{hookvar} is run via @code{run-hook-with-args-until-success}.

@item :after-while
Call @var{function} after the old function and only if the old function
returned non-@code{nil}.  Both functions receive the same arguments, and the
return value of the composition is the return value of @var{function}.
More specifically, the composition of the two functions behaves like:
@example
(lambda (&rest r) (and (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-while @var{funvar} @var{function})} is comparable
for single-function hooks to @code{(add-hook '@var{hookvar} @var{function}
'append)} when @var{hookvar} is run via
@code{run-hook-with-args-until-failure}.

@item :after-until
Call @var{function} after the old function and only if the old function
returned @code{nil}.  More specifically, the composition of the two functions
behaves like:
@example
(lambda (&rest r) (or  (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-until @var{funvar} @var{function})} is comparable
for single-function hooks to @code{(add-hook '@var{hookvar} @var{function}
'append)} when @var{hookvar} is run via
@code{run-hook-with-args-until-success}.

@item :filter-args
Call @var{function} first and use the result (which should be a list) as the
new arguments to pass to the old function.  More specifically, the composition
of the two functions behaves like:
@example
(lambda (&rest r) (apply @var{oldfun} (funcall @var{function} r)))
@end example

@item :filter-return
Call the old function first and pass the result to @var{function}.
More specifically, the composition of the two functions behaves like:
@example
(lambda (&rest r) (funcall @var{function} (apply @var{oldfun} r)))
@end example
@end table


@node Porting Old Advice
@subsection Adapting code using the old defadvice
@cindex old advices, porting
@c NB: The following index entries deliberately avoid ``old'',
@c an adjective that does not come to mind for those who grew up
@c on ‘defadvice’ et al.  For those folks, that way is ``current''.
@c They discover its oldness reading this node.
@cindex advices, porting from @code{defadvice}
@findex defadvice
@findex ad-activate

A lot of code uses the old @code{defadvice} mechanism, which is largely made
obsolete by the new @code{advice-add}, whose implementation and semantics is
significantly simpler.

An old piece of advice such as:

@example
(defadvice previous-line (before next-line-at-end
                                 (&optional arg try-vscroll))
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

could be translated in the new advice mechanism into a plain function:

@example
(defun previous-line--next-line-at-end (&optional arg try-vscroll)
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

Obviously, this does not actually modify @code{previous-line}.  For that the
old advice needed:
@example
(ad-activate 'previous-line)
@end example
whereas the new advice mechanism needs:
@example
(advice-add 'previous-line :before #'previous-line--next-line-at-end)
@end example

Note that @code{ad-activate} had a global effect: it activated all pieces of
advice enabled for that specified function.  If you wanted to only activate or
deactivate a particular piece, you needed to @emph{enable} or @emph{disable}
it with @code{ad-enable-advice} and @code{ad-disable-advice}.
The new mechanism does away with this distinction.

Around advice such as:

@example
(defadvice foo (around foo-around)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    ad-do-it))
(ad-activate 'foo)
@end example

could translate into:

@example
(defun foo--foo-around (orig-fun &rest args)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    (apply orig-fun args)))
(advice-add 'foo :around #'foo--foo-around)
@end example

Regarding the advice's @emph{class}, note that the new @code{:before} is not
quite equivalent to the old @code{before}, because in the old advice you could
modify the function's arguments (e.g., with @code{ad-set-arg}), and that would
affect the argument values seen by the original function, whereas in the new
@code{:before}, modifying an argument via @code{setq} in the advice has no
effect on the arguments seen by the original function.
When porting @code{before} advice which relied on this behavior, you'll need
to turn it into new @code{:around} or @code{:filter-args} advice instead.

Similarly old @code{after} advice could modify the returned value by
changing @code{ad-return-value}, whereas new @code{:after} advice cannot, so
when porting such old @code{after} advice, you'll need to turn it into new
@code{:around} or @code{:filter-return} advice instead.

@node Obsolete Functions
@section Declaring Functions Obsolete
@cindex obsolete functions

  You can mark a named function as @dfn{obsolete}, meaning that it may
be removed at some point in the future.  This causes Emacs to warn
that the function is obsolete whenever it byte-compiles code
containing that function, and whenever it displays the documentation
for that function.  In all other respects, an obsolete function
behaves like any other function.

  The easiest way to mark a function as obsolete is to put a
@code{(declare (obsolete @dots{}))} form in the function's
@code{defun} definition.  @xref{Declare Form}.  Alternatively, you can
use the @code{make-obsolete} function, described below.

  A macro (@pxref{Macros}) can also be marked obsolete with
@code{make-obsolete}; this has the same effects as for a function.  An
alias for a function or macro can also be marked as obsolete; this
makes the alias itself obsolete, not the function or macro which it
resolves to.

@defun make-obsolete obsolete-name current-name when
This function marks @var{obsolete-name} as obsolete.
@var{obsolete-name} should be a symbol naming a function or macro, or
an alias for a function or macro.

If @var{current-name} is a symbol, the warning message says to use
@var{current-name} instead of @var{obsolete-name}.  @var{current-name}
does not need to be an alias for @var{obsolete-name}; it can be a
different function with similar functionality.  @var{current-name} can
also be a string, which serves as the warning message.  The message
should begin in lower case, and end with a period.  It can also be
@code{nil}, in which case the warning message provides no additional
details.

The argument @var{when} should be a string indicating when the function
was first made obsolete---for example, a date or a release number.
@end defun

@defmac define-obsolete-function-alias obsolete-name current-name when &optional doc
This convenience macro marks the function @var{obsolete-name} obsolete
and also defines it as an alias for the function @var{current-name}.
It is equivalent to the following:

@example
(defalias @var{obsolete-name} @var{current-name} @var{doc})
(make-obsolete @var{obsolete-name} @var{current-name} @var{when})
@end example
@end defmac

In addition, you can mark a particular calling convention for a
function as obsolete:

@defun set-advertised-calling-convention function signature when
This function specifies the argument list @var{signature} as the
correct way to call @var{function}.  This causes the Emacs byte
compiler to issue a warning whenever it comes across an Emacs Lisp
program that calls @var{function} any other way (however, it will
still allow the code to be byte compiled).  @var{when} should be a
string indicating when the variable was first made obsolete (usually a
version number string).

For instance, in old versions of Emacs the @code{sit-for} function
accepted three arguments, like this

@example
  (sit-for seconds milliseconds nodisp)
@end example

However, calling @code{sit-for} this way is considered obsolete
(@pxref{Waiting}).  The old calling convention is deprecated like
this:

@example
(set-advertised-calling-convention
  'sit-for '(seconds &optional nodisp) "22.1")
@end example
@end defun

@node Inline Functions
@section Inline Functions
@cindex inline functions

  An @dfn{inline function} is a function that works just like an
ordinary function, except for one thing: when you byte-compile a call
to the function (@pxref{Byte Compilation}), the function's definition
is expanded into the caller.

  The simple way to define an inline function, is to write
@code{defsubst} instead of @code{defun}.  The rest of the definition
looks just the same, but using @code{defsubst} says to make it inline
for byte compilation.

@defmac defsubst name args [doc] [declare] [interactive] body@dots{}
This macro defines an inline function.  Its syntax is exactly the same
as @code{defun} (@pxref{Defining Functions}).
@end defmac

  Making a function inline often makes its function calls run faster.
But it also has disadvantages.  For one thing, it reduces flexibility;
if you change the definition of the function, calls already inlined
still use the old definition until you recompile them.

  Another disadvantage is that making a large function inline can
increase the size of compiled code both in files and in memory.  Since
the speed advantage of inline functions is greatest for small
functions, you generally should not make large functions inline.

  Also, inline functions do not behave well with respect to debugging,
tracing, and advising (@pxref{Advising Functions}).  Since ease of
debugging and the flexibility of redefining functions are important
features of Emacs, you should not make a function inline, even if it's
small, unless its speed is really crucial, and you've timed the code
to verify that using @code{defun} actually has performance problems.

  After an inline function is defined, its inline expansion can be
performed later on in the same file, just like macros.

  It's possible to use @code{defmacro} to define a macro to expand
into the same code that an inline function would execute
(@pxref{Macros}).  But the macro would be limited to direct use in
expressions---a macro cannot be called with @code{apply},
@code{mapcar} and so on.  Also, it takes some work to convert an
ordinary function into a macro.  To convert it into an inline function
is easy; just replace @code{defun} with @code{defsubst}.  Since each
argument of an inline function is evaluated exactly once, you needn't
worry about how many times the body uses the arguments, as you do for
macros.

  Alternatively, you can define a function by providing the code which
will inline it as a compiler macro.  The following macros make this
possible.

@c FIXME: Can define-inline use the interactive spec?
@defmac define-inline name args [doc] [declare] body@dots{}
Define a function @var{name} by providing code that does its inlining,
as a compiler macro.  The function will accept the argument list
@var{args} and will have the specified @var{body}.

If present, @var{doc} should be the function's documentation string
(@pxref{Function Documentation}); @var{declare}, if present, should be
a @code{declare} form (@pxref{Declare Form}) specifying the function's
metadata.
@end defmac

Functions defined via @code{define-inline} have several advantages
with respect to macros defined by @code{defsubst} or @code{defmacro}:

@itemize @minus
@item
They can be passed to @code{mapcar} (@pxref{Mapping Functions}).

@item
They are more efficient.

@item
They can be used as @dfn{place forms} to store values
(@pxref{Generalized Variables}).

@item
They behave in a more predictable way than @code{cl-defsubst}
(@pxref{Argument Lists,,, cl, Common Lisp Extensions for GNU Emacs
Lisp}).
@end itemize

Like @code{defmacro}, a function inlined with @code{define-inline}
inherits the scoping rules, either dynamic or lexical, from the call
site.  @xref{Variable Scoping}.

The following macros should be used in the body of a function defined
by @code{define-inline}.

@defmac inline-quote expression
Quote @var{expression} for @code{define-inline}.  This is similar to
the backquote (@pxref{Backquote}), but quotes code and accepts only
@code{,}, not @code{,@@}.
@end defmac

@defmac inline-letevals (bindings@dots{}) body@dots{}
This provides a convenient way to ensure that the arguments to an
inlined function are evaluated exactly once, as well as to create
local variables.

It's similar to @code{let} (@pxref{Local Variables}): It sets up local
variables as specified by @var{bindings}, and then evaluates
@var{body} with those bindings in effect.

Each element of @var{bindings} should be either a symbol or a list of
the form @w{@code{(@var{var} @var{expr})}}; the result is to evaluate
@var{expr} and bind @var{var} to the result.  However, when an element
of @var{bindings} is just a symbol @var{var}, the result of evaluating
@var{var} is re-bound to @var{var} (which is quite different from the
way @code{let} works).

The tail of @var{bindings} can be either @code{nil} or a symbol which
should hold a list of arguments, in which case each argument is
evaluated, and the symbol is bound to the resulting list.
@end defmac

@defmac inline-const-p expression
Return non-@code{nil} if the value of @var{expression} is already
known.
@end defmac

@defmac inline-const-val expression
Return the value of @var{expression}.
@end defmac

@defmac inline-error format &rest args
Signal an error, formatting @var{args} according to @var{format}.
@end defmac

Here's an example of using @code{define-inline}:

@lisp
(define-inline myaccessor (obj)
  (inline-letevals (obj)
    (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))
@end lisp

@noindent
This is equivalent to

@lisp
(defsubst myaccessor (obj)
  (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))
@end lisp

@node Declare Form
@section The @code{declare} Form
@findex declare

  @code{declare} is a special macro which can be used to add meta
properties to a function or macro: for example, marking it as
obsolete, or giving its forms a special @key{TAB} indentation
convention in Emacs Lisp mode.

@anchor{Definition of declare}
@defmac declare specs@dots{}
This macro ignores its arguments and evaluates to @code{nil}; it has
no run-time effect.  However, when a @code{declare} form occurs in the
@var{declare} argument of a @code{defun} or @code{defsubst} function
definition (@pxref{Defining Functions}) or a @code{defmacro} macro
definition (@pxref{Defining Macros}), it appends the properties
specified by @var{specs} to the function or macro.  This work is
specially performed by @code{defun}, @code{defsubst}, and
@code{defmacro}.

Each element in @var{specs} should have the form @code{(@var{property}
@var{args}@dots{})}, which should not be quoted.  These have the
following effects:

@table @code
@item (advertised-calling-convention @var{signature} @var{when})
This acts like a call to @code{set-advertised-calling-convention}
(@pxref{Obsolete Functions}); @var{signature} specifies the correct
argument list for calling the function or macro, and @var{when} should
be a string indicating when the old argument list was first made obsolete.

@item (debug @var{edebug-form-spec})
This is valid for macros only.  When stepping through the macro with
Edebug, use @var{edebug-form-spec}.  @xref{Instrumenting Macro Calls}.

@item (doc-string @var{n})
This is used when defining a function or macro which itself will be used to
define entities like functions, macros, or variables.  It indicates that
the @var{n}th argument, if any, should be considered
as a documentation string.

@item (indent @var{indent-spec})
Indent calls to this function or macro according to @var{indent-spec}.
This is typically used for macros, though it works for functions too.
@xref{Indenting Macros}.

@item (interactive-only @var{value})
Set the function's @code{interactive-only} property to @var{value}.
@xref{The interactive-only property}.

@item (obsolete @var{current-name} @var{when})
Mark the function or macro as obsolete, similar to a call to
@code{make-obsolete} (@pxref{Obsolete Functions}).  @var{current-name}
should be a symbol (in which case the warning message says to use that
instead), a string (specifying the warning message), or @code{nil} (in
which case the warning message gives no extra details).  @var{when}
should be a string indicating when the function or macro was first
made obsolete.

@item (compiler-macro @var{expander})
This can only be used for functions, and tells the compiler to use
@var{expander} as an optimization function.  When encountering a call to the
function, of the form @code{(@var{function} @var{args}@dots{})}, the macro
expander will call @var{expander} with that form as well as with
@var{args}@dots{}, and @var{expander} can either return a new expression to use
instead of the function call, or it can return just the form unchanged,
to indicate that the function call should be left alone.  @var{expander} can
be a symbol, or it can be a form @code{(lambda (@var{arg}) @var{body})} in
which case @var{arg} will hold the original function call expression, and the
(unevaluated) arguments to the function can be accessed using the function's
formal arguments.

@item (gv-expander @var{expander})
Declare @var{expander} to be the function to handle calls to the macro (or
function) as a generalized variable, similarly to @code{gv-define-expander}.
@var{expander} can be a symbol or it can be of the form @code{(lambda
(@var{arg}) @var{body})} in which case that function will additionally have
access to the macro (or function)'s arguments.

@item (gv-setter @var{setter})
Declare @var{setter} to be the function to handle calls to the macro (or
function) as a generalized variable.  @var{setter} can be a symbol in which
case it will be passed to @code{gv-define-simple-setter}, or it can be of the
form @code{(lambda (@var{arg}) @var{body})} in which case that function will
additionally have access to the macro (or function)'s arguments and it will
be passed to @code{gv-define-setter}.

@item (completion @var{completion-predicate})
Declare @var{completion-predicate} as a function to determine whether
to include the symbol in the list of functions when asking for
completions in @kbd{M-x}.  @var{completion-predicate} is called with
two parameters: The first parameter is the symbol, and the second is
the current buffer.

@item (modes @var{modes})
Specify that this command is meant to be applicable for @var{modes}
only.
@end table

@end defmac

@node Declaring Functions
@section Telling the Compiler that a Function is Defined
@cindex function declaration
@cindex declaring functions
@findex declare-function

Byte-compiling a file often produces warnings about functions that the
compiler doesn't know about (@pxref{Compiler Errors}).  Sometimes this
indicates a real problem, but usually the functions in question are
defined in other files which would be loaded if that code is run.  For
example, byte-compiling @file{simple.el} used to warn:

@example
simple.el:8727:1:Warning: the function ‘shell-mode’ is not known to be
    defined.
@end example

In fact, @code{shell-mode} is used only in a function that executes
@code{(require 'shell)} before calling @code{shell-mode}, so
@code{shell-mode} will be defined properly at run-time.  When you know
that such a warning does not indicate a real problem, it is good to
suppress the warning.  That makes new warnings which might mean real
problems more visible.  You do that with @code{declare-function}.

All you need to do is add a @code{declare-function} statement before the
first use of the function in question:

@example
(declare-function shell-mode "shell" ())
@end example

This says that @code{shell-mode} is defined in @file{shell.el} (the
@samp{.el} can be omitted).  The compiler takes for granted that that file
really defines the function, and does not check.

  The optional third argument specifies the argument list of
@code{shell-mode}.  In this case, it takes no arguments
(@code{nil} is different from not specifying a value).  In other
cases, this might be something like @code{(file &optional overwrite)}.
You don't have to specify the argument list, but if you do the
byte compiler can check that the calls match the declaration.

@defmac declare-function function file &optional arglist fileonly
Tell the byte compiler to assume that @var{function} is defined in the
file @var{file}.  The optional third argument @var{arglist} is either
@code{t}, meaning the argument list is unspecified, or a list of
formal parameters in the same style as @code{defun}.  An omitted
@var{arglist} defaults to @code{t}, not @code{nil}; this is atypical
behavior for omitted arguments, and it means that to supply a fourth
but not third argument one must specify @code{t} for the third-argument
placeholder instead of the usual @code{nil}.  The optional fourth
argument @var{fileonly} non-@code{nil} means check only that
@var{file} exists, not that it actually defines @var{function}.
@end defmac

@findex check-declare-file
@findex check-declare-directory
  To verify that these functions really are declared where
@code{declare-function} says they are, use @code{check-declare-file}
to check all @code{declare-function} calls in one source file, or use
@code{check-declare-directory} check all the files in and under a
certain directory.

  These commands find the file that ought to contain a function's
definition using @code{locate-library}; if that finds no file, they
expand the definition file name relative to the directory of the file
that contains the @code{declare-function} call.

  You can also say that a function is a primitive by specifying a file
name ending in @samp{.c} or @samp{.m}.  This is useful only when you
call a primitive that is defined only on certain systems.  Most
primitives are always defined, so they will never give you a warning.

  Sometimes a file will optionally use functions from an external package.
If you prefix the filename in the @code{declare-function} statement with
@samp{ext:}, then it will be checked if it is found, otherwise skipped
without error.

  There are some function definitions that @samp{check-declare} does not
understand (e.g., @code{defstruct} and some other macros).  In such cases,
you can pass a non-@code{nil} @var{fileonly} argument to
@code{declare-function}, meaning to only check that the file exists, not
that it actually defines the function.  Note that to do this without
having to specify an argument list, you should set the @var{arglist}
argument to @code{t} (because @code{nil} means an empty argument list, as
opposed to an unspecified one).

@node Function Safety
@section Determining whether a Function is Safe to Call
@cindex function safety
@cindex safety of functions

Some major modes, such as SES, call functions that are stored in user
files.  (@inforef{Top, ,ses}, for more information on SES@.)  User
files sometimes have poor pedigrees---you can get a spreadsheet from
someone you've just met, or you can get one through email from someone
you've never met.  So it is risky to call a function whose source code
is stored in a user file until you have determined that it is safe.

@defun unsafep form &optional unsafep-vars
Returns @code{nil} if @var{form} is a @dfn{safe} Lisp expression, or
returns a list that describes why it might be unsafe.  The argument
@var{unsafep-vars} is a list of symbols known to have temporary
bindings at this point; it is mainly used for internal recursive
calls.  The current buffer is an implicit argument, which provides a
list of buffer-local bindings.
@end defun

Being quick and simple, @code{unsafep} does a very light analysis and
rejects many Lisp expressions that are actually safe.  There are no
known cases where @code{unsafep} returns @code{nil} for an unsafe
expression.  However, a safe Lisp expression can return a string
with a @code{display} property, containing an associated Lisp
expression to be executed after the string is inserted into a buffer.
This associated expression can be a virus.  In order to be safe, you
must delete properties from all strings calculated by user code before
inserting them into buffers.

@ignore
What is a safe Lisp expression?  Basically, it's an expression that
calls only built-in functions with no side effects (or only innocuous
ones).  Innocuous side effects include displaying messages and
altering non-risky buffer-local variables (but not global variables).

@table @dfn
@item Safe expression
@itemize
@item
An atom or quoted thing.
@item
A call to a safe function (see below), if all its arguments are
safe expressions.
@item
One of the special forms @code{and}, @code{catch}, @code{cond},
@code{if}, @code{or}, @code{prog1}, @code{prog2}, @code{progn},
@code{while}, and @code{unwind-protect}], if all its arguments are
safe.
@item
A form that creates temporary bindings (@code{condition-case},
@code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, or
@code{let*}), if all args are safe and the symbols to be bound are not
explicitly risky (@pxref{File Local Variables}).
@item
An assignment using @code{add-to-list}, @code{setq}, @code{push}, or
@code{pop}, if all args are safe and the symbols to be assigned are
not explicitly risky and they already have temporary or buffer-local
bindings.
@item
One of [apply, mapc, mapcar, mapconcat] if the first argument is a
safe explicit lambda and the other args are safe expressions.
@end itemize

@item Safe function
@itemize
@item
A lambda containing safe expressions.
@item
A symbol on the list @code{safe-functions}, so the user says it's safe.
@item
A symbol with a non-@code{nil} @code{side-effect-free} property.
@item
A symbol with a non-@code{nil} @code{safe-function} property.  The
value @code{t} indicates a function that is safe but has innocuous
side effects.  Other values will someday indicate functions with
classes of side effects that are not always safe.
@end itemize

The @code{side-effect-free} and @code{safe-function} properties are
provided for built-in functions and for low-level functions and macros
defined in @file{subr.el}.  You can assign these properties for the
functions you write.
@end table
@end ignore

@node Related Topics
@section Other Topics Related to Functions

  Here is a table of several functions that do things related to
function calling and function definitions.  They are documented
elsewhere, but we provide cross references here.

@table @code
@item apply
See @ref{Calling Functions}.

@item autoload
See @ref{Autoload}.

@item call-interactively
See @ref{Interactive Call}.

@item called-interactively-p
See @ref{Distinguish Interactive}.

@item commandp
See @ref{Interactive Call}.

@item documentation
See @ref{Accessing Documentation}.

@item eval
See @ref{Eval}.

@item funcall
See @ref{Calling Functions}.

@item function
See @ref{Anonymous Functions}.

@item ignore
See @ref{Calling Functions}.

@item indirect-function
See @ref{Function Indirection}.

@item interactive
See @ref{Using Interactive}.

@item interactive-p
See @ref{Distinguish Interactive}.

@item mapatoms
See @ref{Creating Symbols}.

@item mapcar
See @ref{Mapping Functions}.

@item map-char-table
See @ref{Char-Tables}.

@item mapconcat
See @ref{Mapping Functions}.

@item undefined
See @ref{Functions for Key Lookup}.
@end table
