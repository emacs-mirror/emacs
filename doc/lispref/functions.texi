@c -*- mode: texinfo -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2026 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Functions
@chapter Functions

  A Lisp program is composed mainly of Lisp functions.  This chapter
explains what functions are, how they accept arguments, and how to
define them.

@menu
* What Is a Function::          Lisp functions vs.@: primitives; terminology.
* Lambda Expressions::          How functions are expressed as Lisp objects.
* Function Names::              A symbol can serve as the name of a function.
* Defining Functions::          Lisp expressions for defining functions.
* Calling Functions::           How to use an existing function.
* Mapping Functions::           Applying a function to each element of a list, etc.
* Anonymous Functions::         Lambda expressions are functions with no names.
* Generic Functions::           Polymorphism, Emacs-style.
* Function Cells::              Accessing or setting the function definition
                            of a symbol.
* Closures::                    Functions that enclose a lexical environment.
* OClosures::                   Function objects with meta-data.
* Advising Functions::          Adding to the definition of a function.
* Obsolete Functions::          Declaring functions obsolete.
* Inline Functions::            Functions that the compiler will expand inline.
* Declare Form::                Adding additional information about a function.
* Declaring Functions::         Telling the compiler that a function is defined.
* Function Safety::             Determining whether a function is safe to call.
* Related Topics::              Cross-references to specific Lisp primitives
                            that have a special bearing on how functions work.
@end menu

@node What Is a Function
@section What Is a Function?

@cindex return value
@cindex value of function
@cindex argument
@cindex pure function
  In a general sense, a function is a rule for carrying out a
computation given input values called @dfn{arguments}.  The result of
the computation is called the @dfn{value} or @dfn{return value} of the
function.  The computation can also have side effects, such as lasting
changes in the values of variables or the contents of data structures
(@pxref{Definition of side effect}).  A @dfn{pure function} is a
function which, in addition to having no side effects, always returns
the same value for the same combination of arguments, regardless of
external factors such as machine type or system state.

  In most computer languages, every function has a name.  But in Lisp,
a function in the strictest sense has no name: it is an object which
can @emph{optionally} be associated with a symbol (e.g., @code{car})
that serves as the function name.  @xref{Function Names}.  When a
function has been given a name, we usually also refer to that symbol
as a ``function'' (e.g., we refer to ``the function @code{car}'').
In this manual, the distinction between a function name and the
function object itself is usually unimportant, but we will take note
wherever it is relevant.

  Certain function-like objects, called @dfn{special forms} and
@dfn{macros}, also accept arguments to carry out computations.
However, as explained below, these are not considered functions in
Emacs Lisp.

  Here are important terms for functions and function-like objects:

@table @dfn
@item lambda expression
A function (in the strict sense, i.e., a function object) which is
written in Lisp.  These are described in the following section.
@ifnottex
@xref{Lambda Expressions}.
@end ifnottex

@item primitive
@cindex primitive
@cindex subr
@cindex built-in function
A function which is callable from Lisp but is actually written in C@.
Primitives are also called @dfn{built-in functions}, or @dfn{subrs}.
Examples include functions like @code{car} and @code{append}.  In
addition, all special forms (see below) are also considered
primitives.

Usually, a function is implemented as a primitive because it is a
fundamental part of Lisp (e.g., @code{car}), or because it provides a
low-level interface to operating system services, or because it needs
to run fast.  Unlike functions defined in Lisp, primitives can be
modified or added only by changing the C sources and recompiling
Emacs.  @xref{Writing Emacs Primitives}.

@item special form
A primitive that is like a function but does not evaluate all of its
arguments in the usual way.  It may evaluate only some of the
arguments, or may evaluate them in an unusual order, or several times.
Examples include @code{if}, @code{and}, and @code{while}.
@xref{Special Forms}.

@item macro
@cindex macro
A construct defined in Lisp, which differs from a function in that it
translates a Lisp expression into another expression which is to be
evaluated instead of the original expression.  Macros enable Lisp
programmers to do the sorts of things that special forms can do.
@xref{Macros}.

@item command
@cindex command
An object which can be invoked via the @code{command-execute}
primitive, usually due to the user typing in a key sequence
@dfn{bound} to that command.  @xref{Interactive Call}.  A command is
usually a function; if the function is written in Lisp, it is made
into a command by an @code{interactive} form in the function
definition (@pxref{Defining Commands}).  Commands that are functions
can also be called from Lisp expressions, just like other functions.

Keyboard macros (strings and vectors) are commands also, even though
they are not functions.  @xref{Keyboard Macros}.  We say that a symbol
is a command if its function cell contains a command (@pxref{Symbol
Components}); such a @dfn{named command} can be invoked with
@kbd{M-x}.

@item closure
A function object that is much like a lambda expression, except that
it also encloses an environment of lexical variable bindings.
@xref{Closures}.

@item byte-code function
A function that has been compiled by the byte compiler.
@xref{Closure Type}.

@item autoload object
@cindex autoload object
A place-holder for a real function.  If the autoload object is called,
Emacs loads the file containing the definition of the real function,
and then calls the real function.  @xref{Autoload}.
@end table

  You can use the function @code{functionp} to test if an object is a
function:

@defun functionp object
This function returns @code{t} if @var{object} is any kind of
function, i.e., can be passed to @code{funcall}.  Note that
@code{functionp} returns @code{t} for symbols that are function names,
and returns @code{nil} for symbols that are macros or special forms.

If @var{object} is not a function, this function ordinarily returns
@code{nil}.  However, the representation of function objects is
complicated, and for efficiency reasons in rare cases this function
can return @code{t} even when @var{object} is not a function.
@end defun

  It is also possible to find out how many arguments an arbitrary
function expects:

@defun func-arity function
This function provides information about the argument list of the
specified @var{function}.  The returned value is a cons cell of the
form @w{@code{(@var{min} . @var{max})}}, where @var{min} is the
minimum number of arguments, and @var{max} is either the maximum
number of arguments, or the symbol @code{many} for functions with
@code{&rest} arguments, or the symbol @code{unevalled} if
@var{function} is a special form.

Note that this function might return inaccurate results in some
situations, such as the following:

@itemize @minus
@item
Functions defined using @code{apply-partially} (@pxref{Calling
Functions, apply-partially}).

@item
Functions that are advised using @code{advice-add} (@pxref{Advising
Named Functions}).

@item
Functions that determine the argument list dynamically, as part of
their code.
@end itemize

@end defun

@noindent
Unlike @code{functionp}, the next functions do @emph{not} treat a symbol
as its function definition.

@defun subrp object
This function returns @code{t} if @var{object} is a built-in function
(i.e., a Lisp primitive).

@example
@group
(subrp 'message)            ; @r{@code{message} is a symbol,}
     @result{} nil                 ;   @r{not a subr object.}
@end group
@group
(subrp (symbol-function 'message))
     @result{} t
@end group
@end example
@end defun

@defun byte-code-function-p object
This function returns @code{t} if @var{object} is a byte-code
function.  For example:

@example
@group
(byte-code-function-p (symbol-function 'next-line))
     @result{} t
@end group
@end example
@end defun

@defun compiled-function-p object
This function returns @code{t} if @var{object} is a function object
that is not in the form of Lisp source code but something like
machine code or byte code instead.  More specifically it returns
@code{t} if the function is built-in (a.k.a.@: ``primitive'',
@pxref{What Is a Function}), or byte-compiled (@pxref{Byte
Compilation}), or native-compiled (@pxref{Native Compilation}), or
a function loaded from a dynamic module (@pxref{Dynamic Modules}).
@end defun

@defun interpreted-function-p object
This function returns @code{t} if @var{object} is an interpreted function.
@end defun

@defun closurep object
This function returns @code{t} if @var{object} is a closure, which is
a particular kind of function object.  Currently closures are used
for all byte-code functions and all interpreted functions.
@end defun

@defun subr-arity subr
This works like @code{func-arity}, but only for built-in functions and
without symbol indirection.  It signals an error for non-built-in
functions.  We recommend to use @code{func-arity} instead.
@end defun

@defun cl-functionp object
This function is like @code{functionp}, except it returns @code{nil} for
lists and symbols.
@end defun

@findex subr-primitive-p
@defun primitive-function-p object
This function returns @code{t} if @var{object} is a built-in primitive
written in C (@pxref{Primitive Function Type}).  Note that special forms
are explicitly excluded, as they are not functions.  Use
@code{subr-primitive-p} if you need to recognize special forms as well.
@end defun


@node Lambda Expressions
@section Lambda Expressions
@cindex lambda expression

  A lambda expression is a function object written in Lisp.  Here is
an example:

@example
(lambda (x)
  "Return the hyperbolic cosine of X."
  (* 0.5 (+ (exp x) (exp (- x)))))
@end example

@noindent
In Emacs Lisp, such a list is a valid expression which evaluates to
a function object.

  A lambda expression, by itself, has no name; it is an @dfn{anonymous
function}.  Although lambda expressions can be used this way
(@pxref{Anonymous Functions}), they are more commonly associated with
symbols to make @dfn{named functions} (@pxref{Function Names}).
Before going into these details, the following subsections describe
the components of a lambda expression and what they do.

@menu
* Lambda Components::           The parts of a lambda expression.
* Simple Lambda::               A simple example.
* Argument List::               Details and special features of argument lists.
* Function Documentation::      How to put documentation in a function.
@end menu

@node Lambda Components
@subsection Components of a Lambda Expression

  A lambda expression is a list that looks like this:

@example
(lambda (@var{arg-variables}@dots{})
  [@var{documentation-string}]
  [@var{interactive-declaration}]
  @var{body-forms}@dots{})
@end example

@cindex lambda list
  The first element of a lambda expression is always the symbol
@code{lambda}.  This indicates that the list represents a function.  The
reason functions are defined to start with @code{lambda} is so that
other lists, intended for other uses, will not accidentally be valid as
functions.

  The second element is a list of symbols---the argument variable
names (@pxref{Argument List}).
This is called the @dfn{lambda list}.  When a Lisp function is called,
the argument values are matched up against the variables in the lambda
list, which are given local bindings with the values provided.
@xref{Local Variables}.

  The documentation string is a Lisp string object placed within the
function definition to describe the function for the Emacs help
facilities.  @xref{Function Documentation}.

  The interactive declaration is a list of the form @code{(interactive
@var{code-string})}.  This declares how to provide arguments if the
function is used interactively.  Functions with this declaration are called
@dfn{commands}; they can be called using @kbd{M-x} or bound to a key.
Functions not intended to be called in this way should not have interactive
declarations.  @xref{Defining Commands}, for how to write an interactive
declaration.

@cindex body of function
  The rest of the elements are the @dfn{body} of the function: the Lisp
code to do the work of the function (or, as a Lisp programmer would say,
``a list of Lisp forms to evaluate'').  The value returned by the
function is the value returned by the last element of the body.

@node Simple Lambda
@subsection A Simple Lambda Expression Example

  Consider the following example:

@example
(lambda (a b c) (+ a b c))
@end example

@noindent
We can call this function by passing it to @code{funcall}, like this:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 2 3)
@end group
@end example

@noindent
This call evaluates the body of the lambda expression  with the variable
@code{a} bound to 1, @code{b} bound to 2, and @code{c} bound to 3.
Evaluation of the body adds these three numbers, producing the result 6;
therefore, this call to the function returns the value 6.

  Note that the arguments can be the results of other function calls, as in
this example:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 (* 2 3) (- 5 4))
@end group
@end example

@noindent
This evaluates the arguments @code{1}, @code{(* 2 3)}, and @code{(- 5
4)} from left to right.  Then it applies the lambda expression to the
argument values 1, 6 and 1 to produce the value 8.

  As these examples show, you can use a form with a lambda expression
as its @sc{car} to make local variables and give them values.  In the
old days of Lisp, this technique was the only way to bind and
initialize local variables.  But nowadays, it is clearer to use the
special form @code{let} for this purpose (@pxref{Local Variables}).
Lambda expressions are mainly used as anonymous functions for passing
as arguments to other functions (@pxref{Anonymous Functions}), or
stored as symbol function definitions to produce named functions
(@pxref{Function Names}).

@node Argument List
@subsection Features of Argument Lists
@kindex wrong-number-of-arguments
@cindex argument binding
@cindex binding arguments
@cindex argument lists, features

  Our simple sample function, @code{(lambda (a b c) (+ a b c))},
specifies three argument variables, so it must be called with three
arguments: if you try to call it with only two arguments or four
arguments, you get a @code{wrong-number-of-arguments} error
(@pxref{Errors}).

  It is often convenient to write a function that allows certain
arguments to be omitted.  For example, the function @code{substring}
accepts three arguments---a string, the start index and the end
index---but the third argument defaults to the @var{length} of the
string if you omit it.  It is also convenient for certain functions to
accept an indefinite number of arguments, as the functions @code{list}
and @code{+} do.

@cindex optional arguments
@cindex rest arguments
@kindex &optional
@kindex &rest
  To specify optional arguments that may be omitted when a function
is called, simply include the keyword @code{&optional} before the optional
arguments.  To specify a list of zero or more extra arguments, include the
keyword @code{&rest} before one final argument.

  Thus, the complete syntax for an argument list is as follows:

@example
@group
(@var{required-vars}@dots{}
 @r{[}&optional @r{[}@var{optional-vars}@dots{}@r{]}@r{]}
 @r{[}&rest @var{rest-var}@r{]})
@end group
@end example

@noindent
The square brackets indicate that the @code{&optional} and @code{&rest}
clauses, and the variables that follow them, are optional.

  A call to the function requires one actual argument for each of the
@var{required-vars}.  There may be actual arguments for zero or more of
the @var{optional-vars}, and there cannot be any actual arguments beyond
that unless the lambda list uses @code{&rest}.  In that case, there may
be any number of extra actual arguments.

  If actual arguments for the optional and rest variables are omitted,
then they always default to @code{nil}.  There is no way for the
function to distinguish between an explicit argument of @code{nil} and
an omitted argument.  However, the body of the function is free to
consider @code{nil} an abbreviation for some other meaningful value.
This is what @code{substring} does; @code{nil} as the third argument to
@code{substring} means to use the length of the string supplied.

@cindex CL note---default optional arg
@quotation
@b{Common Lisp note:} Common Lisp allows the function to specify what
default value to use when an optional argument is omitted; Emacs Lisp
always uses @code{nil}.  Emacs Lisp does not support @code{supplied-p}
variables that tell you whether an argument was explicitly passed.
@end quotation

  For example, an argument list that looks like this:

@example
(a b &optional c d &rest e)
@end example

@noindent
binds @code{a} and @code{b} to the first two actual arguments, which are
required.  If one or two more arguments are provided, @code{c} and
@code{d} are bound to them respectively; any arguments after the first
four are collected into a list and @code{e} is bound to that list.
Thus, if there are only two arguments, @code{c}, @code{d} and @code{e}
are @code{nil}; if two or three arguments, @code{d} and @code{e} are
@code{nil}; if four arguments or fewer, @code{e} is @code{nil}.  Note
that exactly five arguments with an explicit @code{nil} argument
provided for @code{e} will cause that @code{nil} argument to be passed
as a list with one element, @code{(nil)}, as with any other single
value for @code{e}.

  There is no way to have required arguments following optional
ones---it would not make sense.  To see why this must be so, suppose
that @code{c} in the example were optional and @code{d} were required.
Suppose three actual arguments are given; which variable would the
third argument be for?  Would it be used for the @var{c}, or for
@var{d}?  One can argue for both possibilities.  Similarly, it makes
no sense to have any more arguments (either required or optional)
after a @code{&rest} argument.

  Here are some examples of argument lists and proper calls:

@example
(funcall (lambda (n) (1+ n))        ; @r{One required:}
         1)                         ; @r{requires exactly one argument.}
     @result{} 2
(funcall (lambda (n &optional n1)   ; @r{One required and one optional:}
           (if n1 (+ n n1) (1+ n))) ; @r{1 or 2 arguments.}
         1 2)
     @result{} 3
(funcall (lambda (n &rest ns)       ; @r{One required and one rest:}
           (+ n (apply '+ ns)))     ; @r{1 or more arguments.}
         1 2 3 4 5)
     @result{} 15
@end example

@node Function Documentation
@subsection Documentation Strings of Functions
@cindex documentation string of function
@cindex function's documentation string

  A lambda expression may optionally have a @dfn{documentation string}
just after the lambda list.  This string does not affect execution of
the function; it is a kind of comment, but a systematized comment
which actually appears inside the Lisp world and can be used by the
Emacs help facilities.  @xref{Documentation}, for how the
documentation string is accessed.

  It is a good idea to provide documentation strings for all the
functions in your program, even those that are called only from within
your program.  Documentation strings are like comments, except that they
are easier to access.

  The first line of the documentation string should stand on its own,
because @code{apropos} displays just this first line.  It should consist
of one or two complete sentences that summarize the function's purpose.

  The start of the documentation string is usually indented in the
source file, but since these spaces come before the starting
double-quote, they are not part of the string.  Some people make a
practice of indenting any additional lines of the string so that the
text lines up in the program source.  @emph{That is a mistake.}  The
indentation of the following lines is inside the string; what looks
nice in the source code will look ugly when displayed by the help
commands.

  A documentation string must always be followed by at least one Lisp
expression; otherwise, it is not a documentation string at all but the
single expression of the body and used as the return value.
When there is no meaningful value to return from a function, it is
standard practice to return @code{nil} by adding it after the
documentation string.

  The last line of the documentation string can specify calling
conventions different from the actual function arguments.  Write
text like this:

@example
\(fn @var{arglist})
@end example

@noindent
following a blank line, at the beginning of the line, with no newline
following it inside the documentation string.  (The @samp{\} is used
to avoid confusing the Emacs motion commands.)  The calling convention
specified in this way appears in help messages in place of the one
derived from the actual arguments of the function.

  This feature is particularly useful for macro definitions, since the
arguments written in a macro definition often do not correspond to the
way users think of the parts of the macro call.

  Do not use this feature if you want to deprecate the calling
convention and favor the one you advertise by the above specification.
Instead, use the @code{advertised-calling-convention} declaration
(@pxref{Declare Form}) or @code{set-advertised-calling-convention}
(@pxref{Obsolete Functions}), because these two will cause the byte
compiler emit a warning message when it compiles Lisp programs which
use the deprecated calling convention.

@ifnottex
The @code{(fn)} feature is typically used in the following situations:

@itemize @minus
@item To spell out arguments and their purposes in a macro or a function.  Example:

@example
(defmacro lambda (&rest cdr)
  "@dots{}
\(fn ARGS [DOCSTRING] [INTERACTIVE] BODY)"@dots{})
@end example

@item To provide a more detailed description and names of arguments.  Example:

@example
(defmacro macroexp--accumulate (var+list &rest body)
  "@dots{}
\(fn (VAR LIST) BODY@dots{})"
  (declare (indent 1))
  (let ((var (car var+list))
	  (list (cadr var+list))
@dots{})))
@end example

@item To better explain the purpose of a @code{defalias}.  Example:

@example
(defalias 'abbrev-get 'get
  "@dots{}
\(fn ABBREV PROP)")
@end example
@end itemize
@end ifnottex

@cindex computed documentation string
@kindex :documentation
Documentation strings are usually static, but occasionally it can be
necessary to generate them dynamically.  In some cases you can do so
by writing a macro which generates at compile time the code of the
function, including the desired documentation string.  But you can
also generate the docstring dynamically by writing
@code{(:documentation @var{form})} instead of the documentation
string.  This will evaluate @var{form} at run-time when the function
is defined and use it as the documentation string@footnote{This only
works in code using @code{lexical-binding}.}.  You can also compute
the documentation string on the fly when it is requested, by setting
the @code{function-documentation} property of the function's symbol to
a Lisp form that evaluates to a string.

For example:
@example
@group
(defun adder (x)
  (lambda (y)
    (:documentation (format "Add %S to the argument Y." x))
    (+ x y)))
(defalias 'adder5 (adder 5))
(documentation 'adder5)
    @result{} "Add 5 to the argument Y."
@end group

@group
(put 'adder5 'function-documentation
     '(concat (documentation (symbol-function 'adder5) 'raw)
              "  Consulted at " (format-time-string "%H:%M:%S")))
(documentation 'adder5)
    @result{} "Add 5 to the argument Y.  Consulted at 15:52:13"
(documentation 'adder5)
    @result{} "Add 5 to the argument Y.  Consulted at 15:52:18"
@end group
@end example

@node Function Names
@section Naming a Function
@cindex function definition
@cindex named function
@cindex function name

  A symbol can serve as the name of a function.  This happens when the
symbol's @dfn{function cell} (@pxref{Symbol Components}) contains a
function object (e.g., a lambda expression).  Then the symbol itself
becomes a valid, callable function, equivalent to the function object
in its function cell.

  The contents of the function cell are also called the symbol's
@dfn{function definition}.  The procedure of using a symbol's function
definition in place of the symbol is called @dfn{symbol function
indirection}; see @ref{Function Indirection}.  If you have not given a
symbol a function definition, its function cell is said to be
@dfn{void}, and it cannot be used as a function.

  In practice, nearly all functions have names, and are referred to by
their names.  You can create a named Lisp function by defining a
lambda expression and putting it in a function cell (@pxref{Function
Cells}).  However, it is more common to use the @code{defun} macro,
described in the next section.
@ifnottex
@xref{Defining Functions}.
@end ifnottex

  We give functions names because it is convenient to refer to them by
their names in Lisp expressions.  Also, a named Lisp function can
easily refer to itself---it can be recursive.  Furthermore, primitives
can only be referred to textually by their names, since primitive
function objects (@pxref{Primitive Function Type}) have no read
syntax.

  A function need not have a unique name.  A given function object
@emph{usually} appears in the function cell of only one symbol, but
this is just a convention.  It is easy to store it in several symbols
using @code{fset}; then each of the symbols is a valid name for the
same function.

  Note that a symbol used as a function name may also be used as a
variable; these two uses of a symbol are independent and do not
conflict.  (This is not the case in some dialects of Lisp, like
Scheme.)

@cindex internal functions, naming conventions
  By convention, if a function's symbol consists of two names
separated by @samp{--}, the function is intended for internal use and
the first part names the file defining the function.  For example, a
function named @code{vc-git--rev-parse} is an internal function
defined in @file{vc-git.el}.  Internal-use functions written in C have
names ending in @samp{-internal}, e.g., @code{bury-buffer-internal}.
Emacs code contributed before 2018 may follow other internal-use
naming conventions, which are being phased out.

@node Defining Functions
@section Defining Functions
@cindex defining a function

  We usually give a name to a function when it is first created.  This
is called @dfn{defining a function}, and we usually do it with the
@code{defun} macro.  This section also describes other ways to define
a function.

@defmac defun name args [doc] [declare] [interactive] body@dots{}
@code{defun} is the usual way to define new Lisp functions.  It
defines the symbol @var{name} as a function with argument list
@var{args} (@pxref{Argument List}) and body forms given by @var{body}.
Neither @var{name} nor @var{args} should be quoted.

@var{doc}, if present, should be a string specifying the function's
documentation string (@pxref{Function Documentation}).  @var{declare},
if present, should be a @code{declare} form specifying function
metadata (@pxref{Declare Form}).  @var{interactive}, if present,
should be an @code{interactive} form specifying how the function is to
be called interactively (@pxref{Interactive Call}).

The return value of @code{defun} is undefined.

Here are some examples:

@example
@group
(defun foo () 5)
(foo)
     @result{} 5
@end group

@group
(defun bar (a &optional b &rest c)
    (list a b c))
(bar 1 2 3 4 5)
     @result{} (1 2 (3 4 5))
@end group
@group
(bar 1)
     @result{} (1 nil nil)
@end group
@group
(bar)
@error{} Wrong number of arguments.
@end group

@group
(defun capitalize-backwards ()
  "Upcase the last letter of the word at point."
  (interactive)
  (backward-word 1)
  (forward-word 1)
  (backward-char 1)
  (capitalize-word 1))
@end group
@end example

@cindex defining functions dynamically
Most Emacs functions are part of the source code of Lisp programs, and
are defined when the Emacs Lisp reader reads the program source before
executing it.  However, you can also define functions dynamically at
run time, e.g., by generating @code{defun} calls when your program's
code is executed.  If you do this, be aware that Emacs's Help
commands, such as @kbd{C-h f}, which present in the @file{*Help*}
buffer a button to jump to the function's definition, might be unable
to find the source code because generating a function dynamically
usually looks very different from the usual static calls to
@code{defun}.  You can make the job of finding the code that
generates such functions easier by using the @code{definition-name}
or @code{find-function-type-alist} property, @pxref{Standard Properties}.

@cindex override existing functions
@cindex redefine existing functions
Be careful not to redefine existing functions unintentionally.
@code{defun} redefines even primitive functions such as @code{car}
without any hesitation or notification.  Emacs does not prevent you
from doing this, because redefining a function is sometimes done
deliberately, and there is no way to distinguish deliberate
redefinition from unintentional redefinition.
@end defmac

@cindex function aliases
@cindex alias, for functions
@defun defalias name definition &optional doc
@anchor{Definition of defalias}
This function defines the symbol @var{name} as a function, with
definition @var{definition}.  @var{definition} can be any valid Lisp
function or macro, or a special form (@pxref{Special Forms}), or a
keymap (@pxref{Keymaps}), or a vector or string (a keyboard macro).
The return value of @code{defalias} is @emph{undefined}.

If @var{doc} is non-@code{nil}, it becomes the function documentation
of @var{name}.  Otherwise, any documentation provided by
@var{definition} is used.

@cindex defalias-fset-function property
Internally, @code{defalias} normally uses @code{fset} to set the definition.
If @var{name} has a @code{defalias-fset-function} property, however,
the associated value is used as a function to call in place of @code{fset}.

The proper place to use @code{defalias} is where a specific function
or macro name is being defined---especially where that name appears
explicitly in the source file being loaded.  This is because
@code{defalias} records which file defined the function, just like
@code{defun} (@pxref{Unloading}).

By contrast, in programs that manipulate function definitions for other
purposes, it is better to use @code{fset}, which does not keep such
records.  @xref{Function Cells}.

If the resulting function definition chain would be circular, then
Emacs will signal a @code{cyclic-function-indirection} error.
@end defun

@defun function-alias-p object
Checks whether @var{object} is a function alias.  If it is, it returns
a list of symbols representing the function alias chain, else
@code{nil}.  For instance, if @code{a} is an alias for @code{b}, and
@code{b} is an alias for @code{c}:

@example
(function-alias-p 'a)
    @result{} (b c)
@end example

There is also a second, optional argument that is obsolete and has no
effect.
@end defun

  You cannot create a new primitive function with @code{defun} or
@code{defalias}, but you can use them to change the function definition of
any symbol, even one such as @code{car} or @code{x-popup-menu} whose
normal definition is a primitive.  However, this is risky: for
instance, it is next to impossible to redefine @code{car} without
breaking Lisp completely.  Redefining an obscure function such as
@code{x-popup-menu} is less dangerous, but it still may not work as
you expect.  If there are calls to the primitive from C code, they
call the primitive's C definition directly, so changing the symbol's
definition will have no effect on them.

  See also @code{defsubst}, which defines a function like @code{defun}
and tells the Lisp compiler to perform inline expansion on it.
@xref{Inline Functions}.

  To undefine a function name, use @code{fmakunbound}.
@xref{Function Cells}.

@menu
* Finding Definitions::         Finding function definitions created by macros.
@end menu

@node Finding Definitions
@subsection Finding Definitions

Tools such as Emacs's built-in help command @kbd{C-h f} (@pxref{Help,,,
emacs, The GNU Emacs Manual}) can find the definition site of functions
and other Lisp objects in the source code.  To do this, they use the
variable @code{find-function-regexp-alist}.

@vindex @code{find-function-regexp-alist}
The alist @code{find-function-regexp-alist} associates object types with
a regexp or a function that finds the definition of that object in its
source file.  Each element's @code{car} is a symbol that describes the
type of object, or @code{nil}, which means a function defined with
@code{defun}.  Each element's @code{cdr} can be one of the following:

@itemize
@item
A symbol whose value is a string interpreted as a regexp.
@item
A symbol naming a function that can find the definition.
@item
A cons cell where the @code{car} is a regexp (or function that returns
one) and the @code{cdr} is @dfn{form-matcher}: a function that creates a
matcher for macro-expanded forms.
@end itemize

A regexp string is actually a format string, and @code{%s} will be
substituted with the name of the symbol we are looking for.

A function will be called with one argument, the (symbol for) the object
we are searching for.

The form-matcher function in a cons cell value is called with one
argument (the symbol being sought) and should return a function; that
function should take a form and return non-@code{nil} if the form
defines the sought symbol.  This is useful for finding definitions that
are created by expansion of macros.

@cindex @code{definition-name} (symbol property)
If the function to be found is defined by a macro, it may be hard for
Emacs to find the definition site in the source code.  A macro call may
have an unexpected look to it, and @code{find-function-regexp-alist}
will fail to identify the definition.

For example, a @code{define-derived-mode} (@pxref{Derived Modes}) might
define a mode-specific function or a variable implicitly; or your Lisp
program might generate a run-time call to @code{defun} to define a
function.  In these and similar cases, the @code{definition-name}
property of the symbol should be another symbol whose definition can be
found by textual search and whose code defines the original symbol.  In
the example with @code{define-derived-mode}, the value of this property
of the functions and variables it defines should be the mode symbol.

@cindex @code{find-function-type-alist} (symbol property)
In some cases, the definition cannot be found by looking for the
definition of another symbol.  For example, a test file might use a
macro to generate calls to @code{ert-deftest} (@pxref{How to Write
Tests,,,ert, ERT: Emacs Lisp Regression Testing}) where the code is
boiler plate and only varying data need to be passed in.  In such cases,
the @code{find-function-type-alist} property of the symbol can be an
alist that augments @code{find-function-regexp-alist} telling how to
find the definition of symbols of this type.

The @code{find-function-regexp-alist} property is most easily maintained
with the convenience function @code{find-function-update-type-alist}.

@defun find-function-update-type-alist symbol type variable
Update property @code{find-function-type-alist} of @var{symbol} with
a new element containing key @var{type} and value @var{variable}.
@end defun

In the example of a macro defining calls to @code{ert-deftest},
the macro could put the property @code{find-function-type-alist} on each
test defined, associating @code{ert--test} (the internal type of ERT
tests) with the name of a regexp or function that can find the correct
macro call.  The file defining the macro would also have to provide that
definition-finding function or regexp.
Here is an example using a function to find the definition:

@example
@group
(defmacro define-foo-test (data)
  "Define a test of the foo system using DATA."
  (declare (debug (&rest sexp)))
  (let ((test-name (intern (concat ...))))
    `(progn
       (find-function-update-type-alist
        ',test-name 'ert--test 'foo-find-test-def-function)
       (ert-deftest ,test-name ()
         ,(concat "Test foo with " ...)
         ...))))
@end group

@group
(defun foo-find-test-def-function (test-name)
  "Search for the `define-foo-test' call defining TEST-NAME.
Return non-nil if the definition is found."
  (let ((regexp ...))
    (re-search-forward regexp nil t)))
@end group
@end example

@node Calling Functions
@section Calling Functions
@cindex function invocation
@cindex calling a function

  Defining functions is only half the battle.  Functions don't do
anything until you @dfn{call} them, i.e., tell them to run.  Calling a
function is also known as @dfn{invocation}.

  The most common way of invoking a function is by evaluating a list.
For example, evaluating the list @code{(concat "a" "b")} calls the
function @code{concat} with arguments @code{"a"} and @code{"b"}.
@xref{Evaluation}, for a description of evaluation.

  When you write a list as an expression in your program, you specify
which function to call, and how many arguments to give it, in the text
of the program.  Usually that's just what you want.  Occasionally you
need to compute at run time which function to call.  To do that, use
the function @code{funcall}.  When you also need to determine at run
time how many arguments to pass, use @code{apply}.

@defun funcall function &rest arguments
@code{funcall} calls @var{function} with @var{arguments}, and returns
whatever @var{function} returns.

Since @code{funcall} is a function, all of its arguments, including
@var{function}, are evaluated before @code{funcall} is called.  This
means that you can use any expression to obtain the function to be
called.  It also means that @code{funcall} does not see the
expressions you write for the @var{arguments}, only their values.
These values are @emph{not} evaluated a second time in the act of
calling @var{function}; the operation of @code{funcall} is like the
normal procedure for calling a function, once its arguments have
already been evaluated.

The argument @var{function} must be either a Lisp function or a
primitive function.  Special forms and macros are not allowed, because
they make sense only when given the unevaluated argument
expressions.  @code{funcall} cannot provide these because, as we saw
above, it never knows them in the first place.

If you need to use @code{funcall} to call a command and make it behave
as if invoked interactively, use @code{funcall-interactively}
(@pxref{Interactive Call}).

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(funcall f 'x 'y 'z)
     @result{} (x y z)
@end group
@group
(funcall f 'x 'y '(z))
     @result{} (x y (z))
@end group
@group
(funcall 'and t nil)
@error{} Invalid function: #<subr and>
@end group
@end example

Compare these examples with the examples of @code{apply}.
@end defun

@defun apply function &rest arguments
@code{apply} calls @var{function} with @var{arguments}, just like
@code{funcall} but with one difference: the last of @var{arguments} is a
list of objects, which are passed to @var{function} as separate
arguments, rather than a single list.  We say that @code{apply}
@dfn{spreads} this list so that each individual element becomes an
argument.

@code{apply} with a single argument is special: the first element of
the argument, which must be a non-empty list, is called as a function
with the remaining elements as individual arguments.  Passing two or
more arguments will be faster.

@code{apply} returns the result of calling @var{function}.  As with
@code{funcall}, @var{function} must either be a Lisp function or a
primitive function; special forms and macros do not make sense in
@code{apply}.

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(apply f 'x 'y 'z)
@error{} Wrong type argument: listp, z
@end group
@group
(apply '+ 1 2 '(3 4))
     @result{} 10
@end group
@group
(apply '+ '(1 2 3 4))
     @result{} 10
@end group

@group
(apply 'append '((a b c) nil (x y z) nil))
     @result{} (a b c x y z)
@end group

@group
(apply '(+ 3 4))
     @result{} 7
@end group
@end example

For an interesting example of using @code{apply}, see @ref{Definition
of mapcar}.
@end defun

@cindex partial application of functions
@cindex currying
  Sometimes it is useful to fix some of the function's arguments at
certain values, and leave the rest of arguments for when the function
is actually called.  The act of fixing some of the function's
arguments is called @dfn{partial application} of the function@footnote{
This is related to, but different from @dfn{currying}, which
transforms a function that takes multiple arguments in such a way that
it can be called as a chain of functions, each one with a single
argument.}.
The result is a new function that accepts the rest of
arguments and calls the original function with all the arguments
combined.

  In Emacs Lisp, this is best done with an anonymous function.  For
example, if you have a function @samp{my-function} that takes two
arguments, you could do something like this:

@example
(mapcar (lambda (x) (my-function 123 x)) @dots{})
@end example

  You can also do partial application using the function
@code{apply-partially}.  However, this will be slower than using an
anonymous function with @code{lambda}.

@defun apply-partially func &rest args
This function returns a new function which, when called, will call
@var{func} with the list of arguments composed from @var{args} and
additional arguments specified at the time of the call.  If @var{func}
accepts @var{n} arguments, then a call to @code{apply-partially} with
@w{@code{@var{m} <= @var{n}}} arguments will produce a new function of
@w{@code{@var{n} - @var{m}}} arguments@footnote{
If the number of arguments that @var{func} can accept is unlimited,
then the new function will also accept an unlimited number of
arguments, so in that case @code{apply-partially} doesn't reduce the
number of arguments that the new function could accept.
}.

Here's how we could define the built-in function @code{1+}, if it
didn't exist, using @code{apply-partially} and @code{+}, another
built-in function@footnote{
Note that unlike the built-in function, this version accepts any
number of arguments.
}:

@example
@group
(defalias '1+ (apply-partially '+ 1)
  "Increment argument by one.")
@end group
@group
(1+ 10)
     @result{} 11
@end group
@end example
@end defun

@cindex functionals
  It is common for Lisp functions to accept functions as arguments or
find them in data structures (especially in hook variables and property
lists) and call them using @code{funcall} or @code{apply}.  Functions
that accept function arguments are often called @dfn{functionals}.

  Sometimes, when you call a functional, it is useful to supply a no-op
function as the argument.  Here are three different kinds of no-op
functions:

@defun identity argument
This function returns @var{argument} and has no side effects.
@end defun

@defun ignore &rest arguments
This function ignores any @var{arguments} and returns @code{nil}.
@end defun

@defun always &rest arguments
This function ignores any @var{arguments} and returns @code{t}.
@end defun

  Some functions are user-visible @dfn{commands}, which can be called
interactively (usually by a key sequence).  It is possible to invoke
such a command exactly as though it was called interactively, by using
the @code{call-interactively} function.  @xref{Interactive Call}.

@node Mapping Functions
@section Mapping Functions
@cindex mapping functions

  A @dfn{mapping function} applies a given function (@emph{not} a
special form or macro) to each element of a sequence, such as a list or
a vector or a string (@pxref{Sequences Arrays Vectors}).
Emacs Lisp has several such functions; this section describes
@code{mapcar}, @code{mapc}, @code{mapconcat}, and @code{mapcan}, which
map over sequences.  @xref{Definition of mapatoms}, for the function
@code{mapatoms} which maps over the symbols in an obarray.
@xref{Definition of maphash}, for the function @code{maphash} which
maps over key/value associations in a hash table.

  These mapping functions do not work on char-tables because a char-table
is a sparse array whose nominal range of indices is very large.  To map
over a char-table in a way that deals properly with its sparse nature,
use the function @code{map-char-table} (@pxref{Char-Tables}).

@defun mapcar function sequence
@anchor{Definition of mapcar}
@code{mapcar} applies @var{function} to each element of @var{sequence}
in turn, and returns a list of the results.

The argument @var{sequence} can be any kind of sequence except a
char-table; that is, a list, a vector, a bool-vector, or a string.  The
result is always a list.  The length of the result is the same as the
length of @var{sequence}.  For example:

@example
@group
(mapcar #'car '((a b) (c d) (e f)))
     @result{} (a c e)
(mapcar #'1+ [1 2 3])
     @result{} (2 3 4)
(mapcar #'string "abc")
     @result{} ("a" "b" "c")
@end group

@group
;; @r{Call each function in @code{my-hooks}.}
(mapcar 'funcall my-hooks)
@end group

@group
(defun mapcar* (function &rest args)
  "Apply FUNCTION to successive cars of all ARGS.
Return the list of results."
  ;; @r{If no list is exhausted,}
  (if (not (memq nil args))
      ;; @r{apply function to @sc{car}s.}
      (cons (apply function (mapcar #'car args))
            (apply #'mapcar* function
                   ;; @r{Recurse for rest of elements.}
                   (mapcar #'cdr args)))))
@end group

@group
(mapcar* #'cons '(a b c) '(1 2 3 4))
     @result{} ((a . 1) (b . 2) (c . 3))
@end group
@end example
@end defun

@defun mapcan function sequence
This function applies @var{function} to each element of
@var{sequence}, like @code{mapcar}, but instead of collecting the
results into a list, it returns a single list with all the elements of
the results (which must be lists), by altering the results (using
@code{nconc}; @pxref{Rearrangement}).  Like with @code{mapcar},
@var{sequence} can be of any type except a char-table.

@example
@group
;; @r{Contrast this:}
(mapcar #'list '(a b c d))
     @result{} ((a) (b) (c) (d))
;; @r{with this:}
(mapcan #'list '(a b c d))
     @result{} (a b c d)
@end group
@end example
@end defun

@defun mapc function sequence
@code{mapc} is like @code{mapcar} except that @var{function} is used for
side-effects only---the values it returns are ignored, not collected
into a list.  @code{mapc} always returns @var{sequence}.
@end defun

@defun mapconcat function sequence &optional separator
@code{mapconcat} applies @var{function} to each element of
@var{sequence}; the results, which must be sequences of characters
(strings, vectors, or lists), are concatenated into a single string
return value.  Between each pair of result sequences, @code{mapconcat}
inserts the characters from @var{separator}, which also must be a
string, or a vector or list of characters; a @code{nil} value is
treated as the empty string.  @xref{Sequences Arrays Vectors}.

The argument @var{function} must be a function that can take one
argument and returns a sequence of characters: a string, a vector, or
a list.  The argument @var{sequence} can be any kind of sequence
except a char-table; that is, a list, a vector, a bool-vector, or a
string.

@example
@group
(mapconcat #'symbol-name
           '(The cat in the hat)
           " ")
     @result{} "The cat in the hat"
@end group

@group
(mapconcat (lambda (x) (format "%c" (1+ x)))
           "HAL-8000")
     @result{} "IBM.9111"
@end group
@end example
@end defun

@node Anonymous Functions
@section Anonymous Functions
@cindex anonymous function

  Although functions are usually defined with @code{defun} and given
names at the same time, it is sometimes convenient to use an explicit
lambda expression---an @dfn{anonymous function}.  Anonymous functions
are valid wherever function names are.  They are often assigned as
variable values, or as arguments to functions; for instance, you might
pass one as the @var{function} argument to @code{mapcar}, which
applies that function to each element of a list (@pxref{Mapping
Functions}).  @xref{describe-symbols example}, for a realistic example
of this.

  When defining a lambda expression that is to be used as an anonymous
function, you should use the @code{lambda} macro, or the
@code{function} special form, or the @code{#'} read syntax:

@defmac lambda args [doc] [interactive] body@dots{}
This macro returns an anonymous function with argument list
@var{args}, documentation string @var{doc} (if any), interactive spec
@var{interactive} (if any), and body forms given by @var{body}.

For example, this macro makes @code{lambda} forms almost self-quoting:
evaluating a form whose @sc{car} is @code{lambda} yields a value that is
almost like the form itself:

@example
(lambda (x) (* x x))
     @result{} #f(lambda (x) :dynbind (* x x))
@end example

When evaluating under lexical binding the result is a similar
closure object, where the @code{:dynbind} marker is replaced by the
captured variables (@pxref{Closures}).

The @code{lambda} form has one other effect: it tells the Emacs
evaluator and byte-compiler that its argument is a function, by using
@code{function} as a subroutine (see below).
@end defmac

@defspec function function-object
@cindex function quoting
This special form returns the function value of the @var{function-object}.
In many ways, it is similar to @code{quote} (@pxref{Quoting}).  But unlike
@code{quote}, it also serves as a note to the Emacs evaluator and
byte-compiler that @var{function-object} is intended to be used as a
function.  Assuming @var{function-object} is a valid lambda
expression, this has two effects:

@itemize
@item
When the code is byte-compiled, @var{function-object} is compiled into
a byte-code function object (@pxref{Byte Compilation}).

@item
When lexical binding is enabled, @var{function-object} is converted
into a closure.  @xref{Closures}.
@end itemize

When @var{function-object} is a symbol and the code is byte compiled,
the byte-compiler will warn if that function is not defined or might
not be known at run time.
@end defspec

@cindex @samp{#'} syntax
The read syntax @code{#'} is a short-hand for using @code{function}.
The following forms are all equivalent:

@example
(lambda (x) (* x x))
(function (lambda (x) (* x x)))
#'(lambda (x) (* x x))
@end example

  In the following example, we define a @code{change-property}
function that takes a function as its third argument, followed by a
@code{double-property} function that makes use of
@code{change-property} by passing it an anonymous function:

@example
@group
(defun change-property (symbol prop function)
  (let ((value (get symbol prop)))
    (put symbol prop (funcall function value))))
@end group

@group
(defun double-property (symbol prop)
  (change-property symbol prop (lambda (x) (* 2 x))))
@end group
@end example

@noindent
Note that we do not quote the @code{lambda} form.

  If you compile the above code, the anonymous function is also
compiled.  This would not happen if, say, you had constructed the
anonymous function by quoting it as a list:

@c Do not unquote this lambda!
@example
@group
(defun double-property (symbol prop)
  (change-property symbol prop '(lambda (x) (* 2 x))))
@end group
@end example

@noindent
In that case, the anonymous function is kept as a lambda expression in
the compiled code.  The byte-compiler cannot assume this list is a
function, even though it looks like one, since it does not know that
@code{change-property} intends to use it as a function.

@node Generic Functions
@section Generic Functions
@cindex generic functions
@cindex polymorphism

  Functions defined using @code{defun} have a hard-coded set of
assumptions about the types and expected values of their arguments.
For example, a function that was designed to handle values of its
argument that are either numbers or lists of numbers will fail or
signal an error if called with a value of any other type, such as a
vector or a string.  This happens because the implementation of the
function is not prepared to deal with types other than those assumed
during the design.

  By contrast, object-oriented programs use @dfn{polymorphic
functions}: a set of specialized functions having the same name, each
one of which was written for a certain specific set of argument types.
Which of the functions is actually called is decided at run time based
on the types of the actual arguments.

@cindex CLOS
  Emacs provides support for polymorphism.  Like other Lisp
environments, notably Common Lisp and its Common Lisp Object System
(@acronym{CLOS}), this support is based on @dfn{generic functions}.
The Emacs generic functions closely follow @acronym{CLOS}, including
use of similar names, so if you have experience with @acronym{CLOS},
the rest of this section will sound very familiar.

  A generic function specifies an abstract operation, by defining its
name and list of arguments, but (usually) no implementation.  The
actual implementation for several specific classes of arguments is
provided by @dfn{methods}, which should be defined separately.  Each
method that implements a generic function has the same name as the
generic function, but the method's definition indicates what kinds of
arguments it can handle by @dfn{specializing} the arguments defined by
the generic function.  These @dfn{argument specializers} can be more
or less specific; for example, a @code{string} type is more specific
than a more general type, such as @code{sequence}.

  Note that, unlike in message-based OO languages, such as C@t{++} and
Simula, methods that implement generic functions don't belong to a
class, they belong to the generic function they implement.

  When a generic function is invoked, it selects the applicable
methods by comparing the actual arguments passed by the caller with
the argument specializers of each method.  A method is applicable if
the actual arguments of the call are compatible with the method's
specializers.  If more than one method is applicable, they are
combined using certain rules, described below, and the combination
then handles the call.

@defmac cl-defgeneric name arguments [documentation] [options-and-methods@dots{}] &rest body
This macro defines a generic function with the specified @var{name}
and @var{arguments}.  If @var{body} is present, it provides the
default implementation.  If @var{documentation} is present (it should
always be), it specifies the documentation string for the generic
function, in the form @code{(:documentation @var{docstring})}.  The
optional @var{options-and-methods} can be one of the following forms:

@table @code
@item (declare @var{declarations})
A declare form, as described in @ref{Declare Form}.
@item (:argument-precedence-order &rest @var{args})
This form affects the sorting order for combining applicable methods.
Normally, when two methods are compared during combination, method
arguments are examined left to right, and the first method whose
argument specializer is more specific will come before the other one.
The order defined by this form overrides that, and the arguments are
examined according to their order in this form, and not left to right.
@item (:method [@var{qualifiers}@dots{}] args &rest body)
This form defines a method like @code{cl-defmethod} does.
@end table
@end defmac

@defmac cl-defmethod name [extra] [qualifier] arguments [&context (expr spec)@dots{}] &rest [docstring] body
This macro defines a particular implementation for the generic
function called @var{name}.  The implementation code is given by
@var{body}.  If present, @var{docstring} is the documentation string
for the method.  The @var{arguments} list, which must be identical in
all the methods that implement a generic function, and must match the
argument list of that function, provides argument specializers of the
form @code{(@var{arg} @var{spec})}, where @var{arg} is the argument
name as specified in the @code{cl-defgeneric} call, and @var{spec} is
one of the following specializer forms:

@table @code
@item @var{type}
This specializer requires the argument to be of the given @var{type},
one of the types from the type hierarchy described below.
@item (eql @var{object})
This specializer requires the argument be @code{eql} to the given
@var{object}.
@item (head @var{object})
The argument must be a cons cell whose @code{car} is @code{eql} to
@var{object}.
@item @var{struct-type}
The argument must be an instance of a class named @var{struct-type}
defined with @code{cl-defstruct} (@pxref{Structures,,, cl, Common Lisp
Extensions for GNU Emacs Lisp}), or of one of its child classes.
@end table

Method definitions can make use of a new argument-list keyword,
@code{&context}, which introduces extra specializers that test the
environment at the time the method is run.  This keyword should appear
after the list of required arguments, but before any @code{&rest} or
@code{&optional} keywords.  The @code{&context} specializers look much
like regular argument specializers---(@var{expr} @var{spec})---except
that @var{expr} is an expression to be evaluated in the current
context, and the @var{spec} is a value to compare against.  For
example, @code{&context (overwrite-mode (eql t))} will make the method
applicable only when @code{overwrite-mode} is turned on.  The
@code{&context} keyword can be followed by any number of context
specializers.  Because the context specializers are not part of the
generic function's argument signature, they may be omitted in methods
that don't require them.

The type specializer, @code{(@var{arg} @var{type})}, can specify one
of the @dfn{system types} in the following list.  When a parent type
is specified, an argument whose type is any of its more specific child
types, as well as grand-children, grand-grand-children, etc.@: will also
be compatible.

@table @code
@item integer
Parent type: @code{number}.
@item number
@item null
Parent type: @code{symbol}
@item symbol
@item string
Parent type: @code{array}.
@item array
Parent type: @code{sequence}.
@item cons
Parent type: @code{list}.
@item list
Parent type: @code{sequence}.
@item marker
@item overlay
@item float
Parent type: @code{number}.
@item window-configuration
@item process
@item window
@item subr
@item compiled-function
@item buffer
@item char-table
Parent type: @code{array}.
@item bool-vector
Parent type: @code{array}.
@item vector
Parent type: @code{array}.
@item frame
@item hash-table
@item font-spec
@item font-entity
@item font-object
@end table

The optional @var{extra} element, expressed as @samp{:extra
@var{string}}, allows you to add more methods, distinguished by
@var{string}, for the same specializers and qualifiers.

The optional @var{qualifier} allows combining several applicable
methods.  If it is not present, the defined method is a @dfn{primary}
method, responsible for providing the primary implementation of the
generic function for the specialized arguments.  You can also define
@dfn{auxiliary methods}, by using one of the following values as
@var{qualifier}:

@table @code
@item :before
This auxiliary method will run before the primary method.  More
accurately, all the @code{:before} methods will run before the
primary, in the most-specific-first order.
@item :after
This auxiliary method will run after the primary method.  More
accurately, all such methods will run after the primary, in the
most-specific-last order.
@item :around
This auxiliary method will run @emph{instead} of the primary method.
The most specific of such methods will be run before any other method.
Such methods normally use @code{cl-call-next-method}, described below,
to invoke the other auxiliary or primary methods.
@end table

Functions defined using @code{cl-defmethod} cannot be made
interactive, i.e.@: commands (@pxref{Defining Commands}), by adding
the @code{interactive} form to them.  If you need a polymorphic
command, we recommend defining a normal command that calls a
polymorphic function defined via @code{cl-defgeneric} and
@code{cl-defmethod}.
@end defmac

@cindex dispatch of methods for generic function
@cindex multiple-dispatch methods
Each time a generic function is called, it builds the @dfn{effective
method} which will handle this invocation by combining the applicable
methods defined for the function.  The process of finding the
applicable methods and producing the effective method is called
@dfn{dispatch}.  The applicable methods are those all of whose
specializers are compatible with the actual arguments of the call.
Since all of the arguments must be compatible with the specializers,
they all determine whether a method is applicable.  Methods that
explicitly specialize more than one argument are called
@dfn{multiple-dispatch methods}.

The applicable methods are sorted into the order in which they will be
combined.  The method whose left-most argument specializer is the most
specific one will come first in the order.  (Specifying
@code{:argument-precedence-order} as part of @code{cl-defmethod}
overrides that, as described above.)  If the method body calls
@code{cl-call-next-method}, the next most-specific method will run.
If there are applicable @code{:around} methods, the most-specific of
them will run first; it should call @code{cl-call-next-method} to run
any of the less specific @code{:around} methods.  Next, the
@code{:before} methods run in the order of their specificity, followed
by the primary method, and lastly the @code{:after} methods in the
reverse order of their specificity.

@defun cl-call-next-method &rest args
When invoked from within the lexical body of a primary or an
@code{:around} auxiliary method, call the next applicable method for
the same generic function.  Normally, it is called with no arguments,
which means to call the next applicable method with the same arguments
that the calling method was invoked.  Otherwise, the specified
arguments are used instead.
@end defun

@defun cl-next-method-p
This function, when called from within the lexical body of a primary
or an @code{:around} auxiliary method, returns non-@code{nil} if there
is a next method to call.
@end defun


@node Function Cells
@section Accessing Function Cell Contents

  The @dfn{function definition} of a symbol is the object stored in the
function cell of the symbol.  The functions described here access, test,
and set the function cell of symbols.

  See also the function @code{indirect-function}.  @xref{Definition of
indirect-function}.

@defun symbol-function symbol
@kindex void-function
This returns the object in the function cell of @var{symbol}.  It does
not check that the returned object is a legitimate function.
If the function is void, the return value is @code{nil}.

@example
@group
(defun bar (n) (+ n 2))
(symbol-function 'bar)
     @result{} #f(lambda (n) [t] (+ n 2))
@end group
@group
(fset 'baz 'bar)
     @result{} bar
@end group
@group
(symbol-function 'baz)
     @result{} bar
@end group
@end example
@end defun

@cindex void function cell
  If you have never given a symbol any function definition, its function
cell contains the default value @code{nil} and we say
that that function is @dfn{void}.  If you try to call
the symbol as a function, Emacs signals a @code{void-function} error.

  Unlike with void variables (@pxref{Void Variables}), a symbol's
function cell that contains @code{nil} is indistinguishable from the
function's being void.  Note that void is not the same as the symbol
@code{void}: @code{void} can be a valid function if you define it with
@code{defun}.

  You can test the voidness of a symbol's function definition with
@code{fboundp}.  After you have given a symbol a function definition, you
can make it void once more using @code{fmakunbound}.

@defun fboundp symbol
This function returns @code{t} if the symbol has a non-@code{nil} object
in its function cell, @code{nil} otherwise.  It does not check that the
object is a legitimate function.
@end defun

@defun fmakunbound symbol
This function makes @var{symbol}'s function cell @code{nil}, so that a
subsequent attempt to access this cell will cause a
@code{void-function} error.  It returns @var{symbol}.  (See also
@code{makunbound}, in @ref{Void Variables}.)

@example
@group
(defun foo (x) x)
(foo 1)
     @result{}1
@end group
@group
(fmakunbound 'foo)
     @result{} foo
@end group
@group
(foo 1)
@error{} Symbol's function definition is void: foo
@end group
@end example
@end defun

@defun fset symbol definition
This function stores @var{definition} in the function cell of
@var{symbol}.  The result is @var{definition}.  Normally
@var{definition} should be a function or the name of a function, but
this is not checked.  The argument @var{symbol} is an ordinary evaluated
argument.

The primary use of this function is as a subroutine by constructs that define
or alter functions, like @code{defun} or @code{advice-add} (@pxref{Advising
Functions}).  You can also use it to give a symbol a function definition that
is not a function, e.g., a keyboard macro (@pxref{Keyboard Macros}):

@example
;; @r{Define a named keyboard macro.}
(fset 'kill-two-lines "\^u2\^k")
     @result{} "\^u2\^k"
@end example

If you wish to use @code{fset} to make an alternate name for a
function, consider using @code{defalias} instead.  @xref{Definition of
defalias}.

If the resulting function definition chain would be circular, then
Emacs will signal a @code{cyclic-function-indirection} error.
@end defun

@node Closures
@section Closures

  As explained in @ref{Variable Scoping}, Emacs can optionally enable
lexical binding of variables.  When lexical binding is enabled, any
named function that you create (e.g., with @code{defun}), as well as
any anonymous function that you create using the @code{lambda} macro
or the @code{function} special form or the @code{#'} syntax
(@pxref{Anonymous Functions}), is automatically converted into a
@dfn{closure}.

@cindex closure
  A closure is a function that also carries a record of the lexical
environment that existed when the function was defined.  When it is
invoked, any lexical variable references within its definition use the
retained lexical environment.  In all other respects, closures behave
much like ordinary functions; in particular, they can be called in the
same way as ordinary functions.

  @xref{Lexical Binding}, for an example of using a closure.

@example
;; @r{lexical binding is enabled.}
(lambda (x) (* x x))
     @result{} #f(lambda (x) [t] (* x x))
@end example

  The internal structure of a closure is an implementation matter and we
recommend against examining or altering it directly.  For the curious,
@pxref{Closure Objects}.

@node OClosures
@section Open Closures
@cindex oclosures
@cindex open closures

  Traditionally, functions are opaque objects which offer no other
functionality but to call them.  (Emacs Lisp functions aren't fully
opaque since you can extract some info out of them such as their
docstring, their arglist, or their interactive spec, but they are
still mostly opaque.)  This is usually what we want, but occasionally
we need functions to expose a bit more information about themselves.

  @dfn{Open closures}, or @dfn{OClosures} for short, are function
objects which carry additional type information and expose some
information about themselves in the form of slots which you can access
via accessor functions.

 OClosures are defined in two steps: first you use
@code{oclosure-define} to define a new OClosure type by specifying the
slots carried by the OClosures of this type, and then you use
@code{oclosure-lambda} to create an OClosure object of a given type.

Let's say we want to define keyboard macros, i.e.@: interactive
functions which re-execute a sequence of key events (@pxref{Keyboard
Macros}).  You could do it with a plain function as follows:

@example
(defun kbd-macro (key-sequence)
  (lambda (&optional arg)
    (interactive "P")
    (execute-kbd-macro key-sequence arg)))
@end example

@noindent
But with such a definition there is no easy way to extract the
@var{key-sequence} from that function, for example to print it.

We can solve this problem using OClosures as follows.  First we define
the type of our keyboard macros (to which we decided to add
a @code{counter} slot while at it):

@example
(oclosure-define kbd-macro
  "Keyboard macro."
  keys (counter :mutable t))
@end example

@noindent
After which we can rewrite our @code{kbd-macro} function:

@example
(defun kbd-macro (key-sequence)
  (oclosure-lambda (kbd-macro (keys key-sequence) (counter 0))
      (&optional arg)
    (interactive "P")
    (execute-kbd-macro keys arg)
    (setq counter (1+ counter))))
@end example

@noindent
As you can see, the @code{keys} and @code{counter} slots of the
OClosure can be accessed as local variables from within the body
of the OClosure.  But we can now also access them from outside of the
body of the OClosure, for example to describe a keyboard macro:

@example
(defun describe-kbd-macro (km)
  (if (not (eq 'kbd-macro (oclosure-type km)))
      (message "Not a keyboard macro")
    (let ((keys    (kbd-macro--keys km))
          (counter (kbd-macro--counter km)))
      (message "Keys=%S, called %d times" keys counter))))
@end example

@noindent
Where @code{kbd-macro--keys} and @code{kbd-macro--counter} are
accessor functions generated by the @code{oclosure-define} macro for
oclosures whose type is @code{kbd-macro}.

@defmac oclosure-define oname &optional docstring &rest slots
This macro defines a new OClosure type along with accessor functions
for its @var{slots}.  @var{oname} can be a symbol (the name of the new
type), or a list of the form
@w{@code{(@var{oname} . @var{type-props})}}, in which case
@var{type-props} is a list of additional properties of this oclosure
type.  @var{slots} is a list of slot descriptions where each slot can
be either a symbol (the name of the slot) or it can be of the form
@w{@code{(@var{slot-name} . @var{slot-props})}}, where
@var{slot-props} is a property list of the corresponding slot
@var{slot-name}.
The OClosure type's properties specified by @var{type-props} can
include the following:

@table @code
@item (:predicate @var{pred-name})
This requests creation of a predicate function named @var{pred-name}.
This function will be used to recognize OClosures of the type
@var{oname}.  If this type property is not specified,
@code{oclosure-define} will generate a default name for the
predicate.
@item (:parent @var{otype})
This makes type @var{otype} of OClosures be the parent of the type
@var{oname}.  The OClosures of type @var{oname} inherit the
@var{slots} defined by their parent type.
@c FIXME: Is the above description of :parent correct?
@item (:copier @var{copier-name} @var{copier-args})
This causes the definition of a functional update function, knows as
the @dfn{copier}, which takes an OClosure of type @var{oname} as its
first argument and returns a copy of it with the slots named in
@var{copier-args} modified to contain the value passed in the
corresponding argument in the actual call to @var{copier-name}.
@end table

For each slot in @var{slots}, the @code{oclosure-define} macro creates
an accessor function named @code{@var{oname}--@var{slot-name}}; these
can be used to access the values of the slots.  The slot definitions
in @var{slots} can specify the following properties of the slots:

@table @code
@item :mutable @var{val}
By default, slots are immutable, but if you specify the
@code{:mutable} property with a non-@code{nil} value, the slot can be
mutated, for example with @code{setf} (@pxref{Setting Generalized
Variables}).
@c FIXME: Some rationale and meaning of immutable slot is probably in
@c order here.
@item :type @var{val-type}
This specifies the type of the values expected to appear in the slot.
@c FIXME: What will happen if the value is of a different type? error?
@end table
@end defmac

@defmac oclosure-lambda (type . slots) arglist &rest body
This macro creates an anonymous OClosure of type @var{type}, which
should have been defined with @code{oclosure-define}.  @var{slots}
should be a list of elements of the form
@w{@code{(@var{slot-name} @var{expr})}}.  At run time, each @var{expr}
is evaluated, in order, after which the OClosure is created with its
slots initialized with the resulting values.

When called as a function (@pxref{Calling Functions}), the OClosure
created by this macro will accept arguments according to @var{arglist}
and will execute the code in @var{body}.  @var{body} can refer to the
value of any of its slot directly as if it were a local variable that
had been captured by static scoping.
@end defmac

@defun oclosure-type object
This function returns the OClosure type (a symbol) of @var{object} if
it is an OClosure, and @code{nil} otherwise.
@end defun

One other function related to OClosures is
@code{oclosure-interactive-form}, which allows some types of OClosures
to compute their interactive forms dynamically.  @xref{Using
Interactive, oclosure-interactive-form}.


@node Advising Functions
@section Advising Emacs Lisp Functions
@cindex advising functions
@cindex piece of advice

When you need to modify a function defined in another library, or when you need
to modify a hook like @code{@var{foo}-function}, a process filter, or basically
any variable or object field which holds a function value, you can use the
appropriate setter function, such as @code{fset} or @code{defun} for named
functions, @code{setq} for hook variables, or @code{set-process-filter} for
process filters, but those are often too blunt, completely throwing away the
previous value.

  The @dfn{advice} feature lets you add to the existing definition of
a function, by @dfn{advising the function}.  This is a cleaner method
than redefining the whole function.

Emacs's advice system provides two sets of primitives for that: the core set,
for function values held in variables and object fields (with the corresponding
primitives being @code{add-function} and @code{remove-function}) and another
set layered on top of it for named functions (with the main primitives being
@code{advice-add} and @code{advice-remove}).

As a trivial example, here's how to add advice that'll modify the
return value of a function every time it's called:

@example
(defun my-double (x)
  (* x 2))
(defun my-increase (x)
  (+ x 1))
(advice-add 'my-double :filter-return #'my-increase)
@end example

After adding this advice, if you call @code{my-double} with @samp{3},
the return value will be @samp{7}.  To remove this advice, say

@example
(advice-remove 'my-double #'my-increase)
@end example

A more advanced example would be to trace the calls to the process
filter of a process @var{proc}:

@example
(defun my-tracing-function (proc string)
  (message "Proc %S received %S" proc string))

(add-function :before (process-filter @var{proc}) #'my-tracing-function)
@end example

This will cause the process's output to be passed to @code{my-tracing-function}
before being passed to the original process filter.  @code{my-tracing-function}
receives the same arguments as the original function.  When you're done with
it, you can revert to the untraced behavior with:

@example
(remove-function (process-filter @var{proc}) #'my-tracing-function)
@end example

Similarly, if you want to trace the execution of the function named
@code{display-buffer}, you could use:

@example
(defun his-tracing-function (orig-fun &rest args)
  (message "display-buffer called with args %S" args)
  (let ((res (apply orig-fun args)))
    (message "display-buffer returned %S" res)
    res))

(advice-add 'display-buffer :around #'his-tracing-function)
@end example

Here, @code{his-tracing-function} is called instead of the original function
and receives the original function (additionally to that function's arguments)
as argument, so it can call it if and when it needs to.
When you're tired of seeing this output, you can revert to the untraced
behavior with:

@example
(advice-remove 'display-buffer #'his-tracing-function)
@end example

The arguments @code{:before} and @code{:around} used in the above examples
specify how the two functions are composed, since there are many different
ways to do it.  The added function is also called a piece of @emph{advice}.

@menu
* Core Advising Primitives::    Primitives to manipulate advice.
* Advising Named Functions::    Advising named functions.
* Advice Combinators::          Ways to compose advice.
* Porting Old Advice::          Adapting code using the old defadvice.
* Advice and Byte Code::        Not all functions can be advised.
@end menu

@node Core Advising Primitives
@subsection Primitives to manipulate advices
@cindex advice, add and remove

@defmac add-function where place function &optional props
This macro is the handy way to add the advice @var{function} to the function
stored in @var{place} (@pxref{Generalized Variables}).

@var{where} determines how @var{function} is composed with the
existing function, e.g., whether @var{function} should be called before, or
after the original function.  @xref{Advice Combinators}, for the list of
available ways to compose the two functions.

When modifying a variable (whose name will usually end with @code{-function}),
you can choose whether @var{function} is used globally or only in the current
buffer: if @var{place} is just a symbol, then @var{function} is added to the
global value of @var{place}.  Whereas if @var{place} is of the form
@code{(local @var{symbol})}, where @var{symbol} is an expression which returns
the variable name, then @var{function} will only be added in the
current buffer.  Finally, if you want to modify a lexical variable, you will
have to use @code{(var @var{variable})}.

Every function added with @code{add-function} can be accompanied by an
association list of properties @var{props}.  Currently only two of those
properties have a special meaning:

@table @code
@item name
This gives a name to the advice, which @code{remove-function} can use to
identify which function to remove.  Typically used when @var{function} is an
anonymous function.

@item depth
This specifies how to order the advice, should several pieces of
advice be present.  By default, the depth is 0.  A depth of 100
indicates that this piece of advice should be kept as deep as
possible, whereas a depth of @minus{}100 indicates that it should stay as the
outermost piece.  When two pieces of advice specify the same depth,
the most recently added one will be outermost.

For @code{:before} advice, being outermost means that this advice will
be run first, before any other advice, whereas being innermost means
that it will run right before the original function, with no other
advice run between itself and the original function.  Similarly, for
@code{:after} advice innermost means that it will run right after the
original function, with no other advice run in between, whereas
outermost means that it will be run right at the end after all other
advice.  An innermost @code{:override} piece of advice will only
override the original function and other pieces of advice will apply
to it, whereas an outermost @code{:override} piece of advice will
override not only the original function but all other advice applied
to it as well.
@end table

If @var{function} is not interactive, then the combined function will inherit
the interactive spec, if any, of the original function.  Else, the combined
function will be interactive and will use the interactive spec of
@var{function}.  One exception: if the interactive spec of @var{function}
is a function (i.e., a @code{lambda} expression or an @code{fbound}
symbol rather than an expression or a string), then the interactive
spec of the combined function will be a call to that function with
the interactive spec of the original function as sole argument.  To
interpret the spec received as argument, use
@code{advice-eval-interactive-spec}.

Note: The interactive spec of @var{function} will apply to the combined
function and should hence obey the calling convention of the combined function
rather than that of @var{function}.  In many cases, it makes no difference
since they are identical, but it does matter for @code{:around},
@code{:filter-args}, and @code{:filter-return}, where @var{function}
receives different arguments than the original function stored in
@var{place}.
@end defmac

@defmac remove-function place function
This macro removes @var{function} from the function stored in
@var{place}.  This only works if @var{function} was added to @var{place}
using @code{add-function}.

@var{function} is compared with functions added to @var{place} using
@code{equal}, to try and make it work also with lambda expressions.  It is
additionally compared also with the @code{name} property of the functions added
to @var{place}, which can be more reliable than comparing lambda expressions
using @code{equal}.
@end defmac

@defun advice-function-member-p advice function-def
Return non-@code{nil} if @var{advice} is already in @var{function-def}.
Like for @code{remove-function} above, instead of @var{advice} being the actual
function, it can also be the @code{name} of the piece of advice.
@end defun

@defun advice-function-mapc f function-def
Call the function @var{f} for every piece of advice that was added to
@var{function-def}.  @var{f} is called with two arguments: the advice function
and its properties.
@end defun

@defun advice-eval-interactive-spec spec
Evaluate the interactive @var{spec} just like an interactive call to a function
with such a spec would, and then return the corresponding list of arguments
that was built.  E.g., @code{(advice-eval-interactive-spec "r\nP")} will
return a list of three elements, containing the boundaries of the region and
the current prefix argument.

For instance, if you want to make the @kbd{C-x m}
(@code{compose-mail}) command prompt for a @samp{From:} header, you
could say something like this:

@example
(defun my-compose-mail-advice (orig &rest args)
  "Read From: address interactively."
  (interactive
   (lambda (spec)
     (let* ((user-mail-address
             (completing-read "From: "
                              '("one.address@@example.net"
                                "alternative.address@@example.net")))
            (from (message-make-from user-full-name
                                     user-mail-address))
            (spec (advice-eval-interactive-spec spec)))
       ;; Put the From header into the OTHER-HEADERS argument.
       (push (cons 'From from) (nth 2 spec))
       spec)))
  (apply orig args))

(advice-add 'compose-mail :around #'my-compose-mail-advice)
@end example
@end defun

@node Advising Named Functions
@subsection Advising Named Functions
@cindex advising named functions

A common use of advice is for named functions and macros.
You could just use @code{add-function} as in:

@example
(add-function :around (symbol-function '@var{fun}) #'his-tracing-function)
@end example

  But you should use @code{advice-add} and @code{advice-remove} for that
instead.  This separate set of functions to manipulate pieces of advice applied
to named functions, offers the following extra features compared to
@code{add-function}: they know how to deal with macros and autoloaded
functions, they let @code{describe-function} preserve the original docstring as
well as document the added advice, and they let you add and remove advice
before a function is even defined.

  @code{advice-add} can be useful for altering the behavior of existing calls
to an existing function without having to redefine the whole function.
However, it can be a source of bugs, since existing callers to the function may
assume the old behavior, and work incorrectly when the behavior is changed by
advice.  Advice can also cause confusion in debugging, if the person doing the
debugging does not notice or remember that the function has been modified
by advice.

  Note that the problems are not due to advice per se, but to the act
of modifying a named function.  It is even more problematic to modify
a named function via lower-level primitives like @code{fset},
@code{defalias}, or @code{cl-letf}.  From that point of view, advice
is the better way to modify a named function because it keeps track of
the modifications, so they can be listed and undone.

  Modifying a named function should be reserved for
the cases where you cannot modify Emacs's behavior in any other way.
If it is possible to do the same thing via a hook, that is preferable
(@pxref{Hooks}).  If you simply want to change what a particular key
does, it may be better to write a new command, and remap the old
command's key bindings to the new one (@pxref{Remapping Commands}).

  If you are writing code for release, for others to use, try to avoid
including advice in it.  If the function you want to advise has no
hook to do the job, please talk with the Emacs developers about adding
a suitable hook.  Especially, Emacs's own source files should not put
advice on functions in Emacs.  (There are currently a few exceptions
to this convention, but we aim to correct them.)  It is generally
cleaner to create a new hook in @code{foo}, and make @code{bar} use
the hook, than to have @code{bar} put advice in @code{foo}.

  Special forms (@pxref{Special Forms}) cannot be advised, however macros can
be advised, in much the same way as functions.  Of course, this will not affect
code that has already been macro-expanded, so you need to make sure the advice
is installed before the macro is expanded.

  It is possible to advise a primitive (@pxref{What Is a Function}),
but one should typically @emph{not} do so, for two reasons.  Firstly,
some primitives are used by the advice mechanism, and advising them
could cause an infinite recursion.  Secondly, many primitives are
called directly from C, and such calls ignore advice; hence, one ends
up in a confusing situation where some calls (occurring from Lisp
code) obey the advice and other calls (from C code) do not.

@defmac define-advice symbol (where lambda-list &optional name depth) &rest body
This macro defines a piece of advice and adds it to the function named
@var{symbol}.  If @var{name} is non-@code{nil}, the advice is named
@code{@var{symbol}@@@var{name}} and installed with the name @var{name}; otherwise,
the advice is anonymous.  See @code{advice-add} for explanation of
other arguments.
@end defmac

@defun advice-add symbol where function &optional props
Add the advice @var{function} to the named function @var{symbol}.
@var{where} and @var{props} have the same meaning as for @code{add-function}
(@pxref{Core Advising Primitives}).
@end defun

@deffn Command advice-remove symbol function
Remove the advice @var{function} from the named function @var{symbol}.
@var{function} can also be the @code{name} of a piece of advice.  When
called interactively, prompt for both an advised @var{function} and
the advice to remove.
@end deffn

@defun advice-member-p function symbol
Return non-@code{nil} if the advice @var{function} is already in the named
function @var{symbol}.  @var{function} can also be the @code{name} of
a piece of advice.
@end defun

@defun advice-mapc function symbol
Call @var{function} for every piece of advice that was added to the
named function @var{symbol}.  @var{function} is called with two
arguments: the advice function and its properties.
@end defun

@node Advice Combinators
@subsection Ways to compose advice

Here are the different possible values for the @var{where} argument of
@code{add-function} and @code{advice-add}, specifying how the advice
@var{function} and the original function should be composed.

@table @code
@item :before
Call @var{function} before the old function.  Both functions receive the
same arguments, and the return value of the composition is the return value of
the old function.  More specifically, the composition of the two functions
behaves like:
@example
(lambda (&rest r) (apply @var{function} r) (apply @var{oldfun} r))
@end example
@code{(add-function :before @var{funvar} @var{function})} is comparable for
single-function hooks to @code{(add-hook '@var{hookvar} @var{function})} for
normal hooks.

@item :after
Call @var{function} after the old function.  Both functions receive the
same arguments, and the return value of the composition is the return value of
the old function.  More specifically, the composition of the two functions
behaves like:
@example
(lambda (&rest r) (prog1 (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after @var{funvar} @var{function})} is comparable for
single-function hooks to @code{(add-hook '@var{hookvar} @var{function}
'append)} for normal hooks.

@item :override
This completely replaces the old function with the new one.  The old function
can of course be recovered if you later call @code{remove-function}.

@item :around
Call @var{function} instead of the old function, but provide the old function
as an extra argument to @var{function}.  This is the most flexible composition.
For example, it lets you call the old function with different arguments, or
many times, or within a let-binding, or you can sometimes delegate the work to
the old function and sometimes override it completely.  More specifically, the
composition of the two functions behaves like:
@example
(lambda (&rest r) (apply @var{function} @var{oldfun} r))
@end example

@item :before-while
Call @var{function} before the old function and don't call the old
function if @var{function} returns @code{nil}.  Both functions receive the
same arguments, and the return value of the composition is the return value of
the old function.  More specifically, the composition of the two functions
behaves like:
@example
(lambda (&rest r) (and (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-while @var{funvar} @var{function})} is comparable
for single-function hooks to @code{(add-hook '@var{hookvar} @var{function})}
when @var{hookvar} is run via @code{run-hook-with-args-until-failure}.

@item :before-until
Call @var{function} before the old function and only call the old function if
@var{function} returns @code{nil}.  More specifically, the composition of the
two functions behaves like:
@example
(lambda (&rest r) (or (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-until @var{funvar} @var{function})} is comparable
for single-function hooks to @code{(add-hook '@var{hookvar} @var{function})}
when @var{hookvar} is run via @code{run-hook-with-args-until-success}.

@item :after-while
Call @var{function} after the old function and only if the old function
returned non-@code{nil}.  Both functions receive the same arguments, and the
return value of the composition is the return value of @var{function}.
More specifically, the composition of the two functions behaves like:
@example
(lambda (&rest r) (and (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-while @var{funvar} @var{function})} is comparable
for single-function hooks to @code{(add-hook '@var{hookvar} @var{function}
'append)} when @var{hookvar} is run via
@code{run-hook-with-args-until-failure}.

@item :after-until
Call @var{function} after the old function and only if the old function
returned @code{nil}.  More specifically, the composition of the two functions
behaves like:
@example
(lambda (&rest r) (or  (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-until @var{funvar} @var{function})} is comparable
for single-function hooks to @code{(add-hook '@var{hookvar} @var{function}
'append)} when @var{hookvar} is run via
@code{run-hook-with-args-until-success}.

@item :filter-args
Call @var{function} first and use the result (which should be a list) as the
new arguments to pass to the old function.  More specifically, the composition
of the two functions behaves like:
@example
(lambda (&rest r) (apply @var{oldfun} (funcall @var{function} r)))
@end example

@item :filter-return
Call the old function first and pass the result to @var{function}.
More specifically, the composition of the two functions behaves like:
@example
(lambda (&rest r) (funcall @var{function} (apply @var{oldfun} r)))
@end example
@end table


@node Porting Old Advice
@subsection Adapting code using the old defadvice
@cindex old advices, porting
@c NB: The following index entries deliberately avoid ``old'',
@c an adjective that does not come to mind for those who grew up
@c on `defadvice' et al.  For those folks, that way is ``current''.
@c They discover its oldness reading this node.
@cindex advices, porting from @code{defadvice}
@findex defadvice
@findex ad-activate

A lot of code uses the old @code{defadvice} mechanism, which has been made
obsolete by the new @code{advice-add}, whose implementation and semantics is
significantly simpler.

An old piece of advice such as:

@example
(defadvice previous-line (before next-line-at-end
                                 (&optional arg try-vscroll))
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

could be translated in the new advice mechanism into a plain function:

@example
(defun previous-line--next-line-at-end (&optional arg try-vscroll)
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

Obviously, this does not actually modify @code{previous-line}.  For that the
old advice needed:
@example
(ad-activate 'previous-line)
@end example
whereas the new advice mechanism needs:
@example
(advice-add 'previous-line :before #'previous-line--next-line-at-end)
@end example

Note that @code{ad-activate} had a global effect: it activated all pieces of
advice enabled for that specified function.  If you wanted to only activate or
deactivate a particular piece, you needed to @emph{enable} or @emph{disable}
it with @code{ad-enable-advice} and @code{ad-disable-advice}.
The new mechanism does away with this distinction.

Around advice such as:

@example
(defadvice foo (around foo-around)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    ad-do-it))
(ad-activate 'foo)
@end example

could translate into:

@example
(defun foo--foo-around (orig-fun &rest args)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    (apply orig-fun args)))
(advice-add 'foo :around #'foo--foo-around)
@end example

Regarding the advice's @emph{class}, note that the new @code{:before} is not
quite equivalent to the old @code{before}, because in the old advice you could
modify the function's arguments (e.g., with @code{ad-set-arg}), and that would
affect the argument values seen by the original function, whereas in the new
@code{:before}, modifying an argument via @code{setq} in the advice has no
effect on the arguments seen by the original function.
When porting @code{before} advice which relied on this behavior, you'll need
to turn it into new @code{:around} or @code{:filter-args} advice instead.

Similarly old @code{after} advice could modify the returned value by
changing @code{ad-return-value}, whereas new @code{:after} advice cannot, so
when porting such old @code{after} advice, you'll need to turn it into new
@code{:around} or @code{:filter-return} advice instead.

@c This is its own node because we link to it from *Help* buffers.
@node Advice and Byte Code
@subsection Advice and Byte Code
@cindex compiler macros, advising
@cindex @code{byte-compile} and  @code{byte-optimize}, advising

  Not all functions can be reliably advised.  The byte compiler may
choose to replace a call to a function with a sequence of instructions
that doesn't call the function you were interested in altering.

This usually happens due to one of the three following mechanisms:

@table @asis
@item @code{byte-compile} properties
If a function's symbol has a @code{byte-compile} property, that
property will be used instead of the symbol's function definition.
@xref{Compilation Functions}.

@item @code{byte-optimize} properties
If a function's symbol has a @code{byte-optimize} property, the byte
compiler may rewrite the function arguments, or decide to use a
different function altogether.

@item @code{compiler-macro} declare forms
A function can have a special @code{compiler-macro} @code{declare}
form in its definition (@pxref{Declare Form}) that defines an
@dfn{expander} to call when compiling the function.  The expander
could then cause the produced byte-code not to call the original
function.
@end table

@node Obsolete Functions
@section Declaring Functions Obsolete
@cindex obsolete functions

  You can mark a named function as @dfn{obsolete}, meaning that it may
be removed at some point in the future.  This causes Emacs to warn
that the function is obsolete whenever it byte-compiles code
containing that function, and whenever it displays the documentation
for that function.  In all other respects, an obsolete function
behaves like any other function.

  The easiest way to mark a function as obsolete is to put a
@code{(declare (obsolete @dots{}))} form in the function's
@code{defun} definition.  @xref{Declare Form}.  Alternatively, you can
use the @code{make-obsolete} function, described below.

  A macro (@pxref{Macros}) can also be marked obsolete with
@code{make-obsolete}; this has the same effects as for a function.  An
alias for a function or macro can also be marked as obsolete; this
makes the alias itself obsolete, not the function or macro which it
resolves to.

@defun make-obsolete obsolete-name current-name when
This function marks @var{obsolete-name} as obsolete.
@var{obsolete-name} should be a symbol naming a function or macro, or
an alias for a function or macro.

If @var{current-name} is a symbol, the warning message says to use
@var{current-name} instead of @var{obsolete-name}.  @var{current-name}
does not need to be an alias for @var{obsolete-name}; it can be a
different function with similar functionality.  @var{current-name} can
also be a string, which serves as the warning message.  The message
should begin in lower case, and end with a period.  It can also be
@code{nil}, in which case the warning message provides no additional
details.

The argument @var{when} should be a string indicating when the function
was first made obsolete---for example, a date or a release number.
@end defun

@defmac define-obsolete-function-alias obsolete-name current-name when &optional doc
This convenience macro marks the function @var{obsolete-name} obsolete
and also defines it as an alias for the function @var{current-name}.
It is equivalent to the following:

@example
(defalias @var{obsolete-name} @var{current-name} @var{doc})
(make-obsolete @var{obsolete-name} @var{current-name} @var{when})
@end example
@end defmac

In addition, you can mark a particular calling convention for a
function as obsolete:

@defun set-advertised-calling-convention function signature when
This function specifies the argument list @var{signature} as the
correct way to call @var{function}.  This causes the Emacs byte
compiler to issue a warning whenever it comes across an Emacs Lisp
program that calls @var{function} any other way (however, it will
still allow the code to be byte compiled).  @var{when} should be a
string indicating when the variable was first made obsolete (usually a
version number string).

For instance, in old versions of Emacs the @code{sit-for} function
accepted three arguments, like this

@example
  (sit-for seconds milliseconds nodisp)
@end example

During a transition period, the function accepted those three
arguments, but declared this old calling convention as deprecated like
this:

@example
(set-advertised-calling-convention
  'sit-for '(seconds &optional nodisp) "22.1")
@end example

@noindent
The alternative to using this function is the
@code{advertised-calling-convention} @code{declare} spec, see
@ref{Declare Form}.
@end defun

@node Inline Functions
@section Inline Functions
@cindex inline functions

  An @dfn{inline function} is a function that works just like an
ordinary function, except for one thing: when you byte-compile a call
to the function (@pxref{Byte Compilation}), the function's definition
is expanded into the caller.

  The simple way to define an inline function, is to write
@code{defsubst} instead of @code{defun}.  The rest of the definition
looks just the same, but using @code{defsubst} says to make it inline
for byte compilation.

@defmac defsubst name args [doc] [declare] [interactive] body@dots{}
This macro defines an inline function.  Its syntax is exactly the same
as @code{defun} (@pxref{Defining Functions}).
@end defmac

  Making a function inline often makes its function calls run faster.
But it also has disadvantages.  For one thing, it reduces flexibility;
if you change the definition of the function, calls already inlined
still use the old definition until you recompile them.

  Another disadvantage is that making a large function inline can
increase the size of compiled code both in files and in memory.  Since
the speed advantage of inline functions is greatest for small
functions, you generally should not make large functions inline.

  Also, inline functions do not behave well with respect to debugging,
tracing, and advising (@pxref{Advising Functions}).  Since ease of
debugging and the flexibility of redefining functions are important
features of Emacs, you should not make a function inline, even if it's
small, unless its speed is really crucial, and you've timed the code
to verify that using @code{defun} actually has performance problems.

  After an inline function is defined, its inline expansion can be
performed later on in the same file, just like macros.

  It's possible to use @code{defmacro} to define a macro to expand
into the same code that an inline function would execute
(@pxref{Macros}).  But the macro would be limited to direct use in
expressions---a macro cannot be called with @code{apply},
@code{mapcar} and so on.  Also, it takes some work to convert an
ordinary function into a macro.  To convert it into an inline function
is easy; just replace @code{defun} with @code{defsubst}.  Since each
argument of an inline function is evaluated exactly once, you needn't
worry about how many times the body uses the arguments, as you do for
macros.

  Alternatively, you can define a function by providing the code which
will inline it as a compiler macro (@pxref{Declare Form}).  The
following macros make this possible.

@c FIXME: Can define-inline use the interactive spec?
@defmac define-inline name args [doc] [declare] body@dots{}
Define a function @var{name} by providing code that does its inlining,
as a compiler macro.  The function will accept the argument list
@var{args} and will have the specified @var{body}.

If present, @var{doc} should be the function's documentation string
(@pxref{Function Documentation}); @var{declare}, if present, should be
a @code{declare} form (@pxref{Declare Form}) specifying the function's
metadata.  In addition to the usual declarations, @var{declare}
can include @code{(noinline @var{NOINLINE})} when a non-@code{nil}
@var{NOINLINE} prevents Emacs from inlining the defined function.
@end defmac

Functions defined via @code{define-inline} have several advantages
with respect to macros defined by @code{defsubst} or @code{defmacro}:

@itemize @minus
@item
They can be passed to @code{mapcar} (@pxref{Mapping Functions}).

@item
They are more efficient.

@item
They can be used as @dfn{place forms} to store values
(@pxref{Generalized Variables}).

@item
They behave in a more predictable way than @code{cl-defsubst}
(@pxref{Argument Lists,,, cl, Common Lisp Extensions for GNU Emacs
Lisp}).
@end itemize

Like @code{defmacro}, a function inlined with @code{define-inline}
inherits the scoping rules, either dynamic or lexical, from the call
site.  @xref{Variable Scoping}.

The following macros should be used in the body of a function defined
by @code{define-inline}.

@defmac inline-quote expression
Quote @var{expression} for @code{define-inline}.  This is similar to
the backquote (@pxref{Backquote}), but quotes code and accepts only
@code{,}, not @code{,@@}.
@end defmac

@defmac inline-letevals (bindings@dots{}) body@dots{}
This provides a convenient way to ensure that the arguments to an
inlined function are evaluated exactly once, as well as to create
local variables.

It's similar to @code{let} (@pxref{Local Variables}): It sets up local
variables as specified by @var{bindings}, and then evaluates
@var{body} with those bindings in effect.

Each element of @var{bindings} should be either a symbol or a list of
the form @w{@code{(@var{var} @var{expr})}}; the result is to evaluate
@var{expr} and bind @var{var} to the result.  However, when an element
of @var{bindings} is just a symbol @var{var}, the result of evaluating
@var{var} is re-bound to @var{var} (which is quite different from the
way @code{let} works).

The tail of @var{bindings} can be either @code{nil} or a symbol which
should hold a list of arguments, in which case each argument is
evaluated, and the symbol is bound to the resulting list.
@end defmac

@defmac inline-const-p expression
Return non-@code{nil} if the value of @var{expression} is already
known.
@end defmac

@defmac inline-const-val expression
Return the value of @var{expression}.
@end defmac

@defmac inline-error format &rest args
Signal an error, formatting @var{args} according to @var{format}.
@end defmac

Here's an example of using @code{define-inline}:

@lisp
(define-inline myaccessor (obj)
  (inline-letevals (obj)
    (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))
@end lisp

@noindent
This is equivalent to

@lisp
(defsubst myaccessor (obj)
  (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))
@end lisp

@node Declare Form
@section The @code{declare} Form
@findex declare

  @code{declare} is a special macro which can be used to add meta
properties to a function or macro: for example, marking it as
obsolete, or giving its forms a special @key{TAB} indentation
convention in Emacs Lisp mode.

@anchor{Definition of declare}
@defmac declare specs@dots{}
This macro ignores its arguments and evaluates to @code{nil}; it has
no run-time effect.  However, when a @code{declare} form occurs in the
@var{declare} argument of a @code{defun} or @code{defsubst} function
definition (@pxref{Defining Functions}) or a @code{defmacro} macro
definition (@pxref{Defining Macros}), it appends the properties
specified by @var{specs} to the function or macro.  This work is
specially performed by @code{defun}, @code{defsubst}, and
@code{defmacro}.

Each element in @var{specs} should have the form @code{(@var{property}
@var{args}@dots{})}, which should not be quoted.  These have the
following effects:

@table @code
@cindex @code{advertised-calling-convention} (@code{declare} spec)
@item (advertised-calling-convention @var{signature} @var{when})
This acts like a call to @code{set-advertised-calling-convention}
(@pxref{Obsolete Functions}); @var{signature} specifies the correct
argument list for calling the function or macro, and @var{when} should
be a string indicating when the old argument list was first made obsolete.

@item (debug @var{edebug-form-spec})
This is valid for macros only.  When stepping through the macro with
Edebug, use @var{edebug-form-spec}.  @xref{Instrumenting Macro Calls}.

@item (doc-string @var{n})
This is used when defining a function or macro which itself will be used to
define entities like functions, macros, or variables.  It indicates that
the @var{n}th argument, if any, should be considered
as a documentation string.

@item (indent @var{indent-spec})
Indent calls to this function or macro according to @var{indent-spec}.
This is typically used for macros, though it works for functions too.
@xref{Indenting Macros}.

@cindex @code{autoload-macro} (@code{declare} spec)
@item (autoload-macro @var{value})
This is used when defining a macro.  If @var{value} is @samp{expand},
any calls to the macro which follow an autoload comment will first be
expanded during generation of the autoloads.  This declaration is used
as an alternative to hard-coding lists of macros to expand in
@code{loaddefs-generate--make-autoload}.  @xref{Autoload}.

@item (interactive-only @var{value})
Set the function's @code{interactive-only} property to @var{value}.
@xref{The interactive-only property}.

@cindex @code{obsolete} (@code{declare} spec)
@item (obsolete @var{current-name} @var{when})
Mark the function or macro as obsolete, similar to a call to
@code{make-obsolete} (@pxref{Obsolete Functions}).  @var{current-name}
should be a symbol (in which case the warning message says to use that
instead), a string (specifying the warning message), or @code{nil} (in
which case the warning message gives no extra details).  @var{when}
should be a string indicating when the function or macro was first
made obsolete.

@cindex compiler macro
@item (compiler-macro @var{expander})
This can only be used for functions, and tells the compiler to use
@var{expander} as an optimization function.  When encountering a call to the
function, of the form @code{(@var{function} @var{args}@dots{})}, the macro
expander will call @var{expander} with that form as well as with
@var{args}@dots{}, and @var{expander} can either return a new expression to use
instead of the function call, or it can return just the form unchanged,
to indicate that the function call should be left alone.

When @var{expander} is a lambda form it should be written with
a single argument (i.e., be of the form @code{(lambda (@var{arg})
@var{body})}) because the function's formal arguments are
automatically added to the lambda's list of arguments for you.

@item (gv-expander @var{expander})
Declare @var{expander} to be the function to handle calls to the macro (or
function) as a generalized variable, similarly to @code{gv-define-expander}.
@var{expander} can be a symbol or it can be of the form @code{(lambda
(@var{arg}) @var{body})} in which case that function will additionally have
access to the macro (or function)'s arguments.

@item (gv-setter @var{setter})
Declare @var{setter} to be the function to handle calls to the macro (or
function) as a generalized variable.  @var{setter} can be a symbol in which
case it will be passed to @code{gv-define-simple-setter}, or it can be of the
form @code{(lambda (@var{arg}) @var{body})} in which case that function will
additionally have access to the macro (or function)'s arguments and it will
be passed to @code{gv-define-setter}.

@item (completion @var{completion-predicate})
Declare @var{completion-predicate} as a function to determine whether
to include a function's symbol in the list of functions when asking
for completions in @kbd{M-x}.  This predicate function will only be
called when @code{read-extended-command-predicate} is customized to
@code{command-completion-default-include-p}; by default the value of
@code{read-extended-command-predicate} is nil (@pxref{Interactive
Call, execute-extended-command}).  The predicate
@var{completion-predicate} is called with two arguments: the
function's symbol and the current buffer.

@item (modes @var{modes})
Specify that this command is meant to be applicable only to specified
@var{modes}.  @xref{Command Modes}.

@item (interactive-args @var{arg} ...)
Specify the arguments that should be stored for @code{repeat-command}.
Each @var{arg} is on the form @code{@var{argument-name} @var{form}}.

@item (pure @var{val})
If @var{val} is non-@code{nil}, this function is @dfn{pure}
(@pxref{What Is a Function}).  This is the same as the @code{pure}
property of the function's symbol (@pxref{Standard Properties}).

@item (side-effect-free @var{val})
If @var{val} is non-@code{nil}, this function is free of side effects,
so the byte compiler can ignore calls whose value is ignored.  This is
the same as the @code{side-effect-free} property of the function's
symbol, @pxref{Standard Properties}.

@item (important-return-value @var{val})
If @var{val} is non-@code{nil}, the byte compiler will warn about
calls to this function that do not use the returned value.  This is the
same as the @code{important-return-value} property of the function's
symbol, @pxref{Standard Properties}.

@item (speed @var{n})
Specify the value of @code{native-comp-speed} in effect for native
compilation of this function (@pxref{Native-Compilation Variables}).
This allows function-level control of the optimization level used for
native code emitted for the function.  In particular, if @var{n} is
@minus{}1, native compilation of the function will emit bytecode
instead of native code for the function.

@item (safety @var{n})
Specify the value of @code{compilation-safety} in effect for this
function.  This allows function-level control of the safety level used
for the code emitted for the function (@pxref{Native-Compilation
Variables}).

@cindex function type declaration
@cindex inferred type of function
@item (ftype @var{type} &optional @var{function})
Declare @var{type} to be the type of this function.  This type is used
by @code{describe-function} for documentation, and by the native
compiler (@pxref{Native Compilation}) for optimizing code generation and
inferring types.  Incorrect type declarations may cause crashes in
natively compiled code (see below).  Functions with type declarations
are shown by @kbd{C-h C-f} as having a @dfn{declared type}, as opposed
to an @dfn{inferred type} for functions without them.

@var{type} is a @dfn{type specifier} (@pxref{Type Specifiers}) of the
form @w{@code{(function (@var{arg-1-type} @dots{} @var{arg-n-type})
RETURN-TYPE)}}.  Argument types can be interleaved with @code{&optional}
and @code{&rest} to reflect the function's calling convention
(@pxref{Argument List}).

@var{function} if present should be the name of function being defined.

Here's an example of using @code{ftype} inside @code{declare} to define
a function @code{positive-p}, which takes an argument of type
@var{number} and returns a @var{boolean}:

@lisp
@group
(defun positive-p (x)
  (declare (ftype (function (number) boolean)))
  (when (> x 0)
    t))
@end group
@end lisp

Similarly, this defines a function @code{cons-or-number} that takes a
first argument of type @var{cons} or a @var{number}, a second optional
argument of type @var{string}, and returns one of the symbols
@code{is-cons} or @code{is-number}:

@lisp
@group
(defun cons-or-number (x &optional err-msg)
  (declare (ftype (function ((or cons number) &optional string)
			    (member is-cons is-number))))
  (if (consp x)
      'is-cons
    (if (numberp x)
	'is-number
      (error (or err-msg "Unexpected input")))))
@end group
@end lisp

For description of additional types, see @ref{Lisp Data Types}).

Declaring a function with an incorrect type causes undefined behavior.
If such a function is natively compiled with @code{compilation-safety}
set to zero (@pxref{compilation-safety}), this may result in incorrect
execution or even Emacs crashing when the compiled code is loaded.
Redefining or advising a type-declared function must preserve the
original signature to avoid these issues.

@item no-font-lock-keyword
This is valid for macros only.  Macros with this declaration are
highlighted by font-lock (@pxref{Font Lock Mode}) as normal functions,
not specially as macros.
@end table

@end defmac

@node Declaring Functions
@section Telling the Compiler that a Function is Defined
@cindex function declaration
@cindex declaring functions
@findex declare-function

Byte-compiling a file often produces warnings about functions that the
compiler doesn't know about (@pxref{Compiler Errors}).  Sometimes this
indicates a real problem, but usually the functions in question are
defined in other files which would be loaded if that code is run.  For
example, byte-compiling @file{simple.el} used to warn:

@example
simple.el:8727:1:Warning: the function `shell-mode' is not known to be
    defined.
@end example

In fact, @code{shell-mode} is used only in a function that executes
@code{(require 'shell)} before calling @code{shell-mode}, so
@code{shell-mode} will be defined properly at run-time.  When you know
that such a warning does not indicate a real problem, it is good to
suppress the warning.  That makes new warnings which might mean real
problems more visible.  You do that with @code{declare-function}.

All you need to do is add a @code{declare-function} statement before the
first use of the function in question:

@example
(declare-function shell-mode "shell" ())
@end example

This says that @code{shell-mode} is defined in @file{shell.el} (the
@samp{.el} can be omitted).  The compiler takes for granted that that file
really defines the function, and does not check.

  The optional third argument specifies the argument list of
@code{shell-mode}.  In this case, it takes no arguments
(@code{nil} is different from not specifying a value).  In other
cases, this might be something like @code{(file &optional overwrite)}.
You don't have to specify the argument list, but if you do the
byte compiler can check that the calls match the declaration.

@defmac declare-function function file &optional arglist fileonly
Tell the byte compiler to assume that @var{function} is defined in the
file @var{file}.  The optional third argument @var{arglist} is either
@code{t}, meaning the argument list is unspecified, or a list of
formal parameters in the same style as @code{defun} (including the
parentheses).  An omitted @var{arglist} defaults to @code{t}, not
@code{nil}; this is atypical behavior for omitted arguments, and it
means that to supply a fourth but not third argument one must specify
@code{t} for the third-argument placeholder instead of the usual
@code{nil}.  The optional fourth argument @var{fileonly}
non-@code{nil} means check only that @var{file} exists, not that it
actually defines @var{function}.
@end defmac

@findex check-declare-file
@findex check-declare-directory
  To verify that these functions really are declared where
@code{declare-function} says they are, use @code{check-declare-file}
to check all @code{declare-function} calls in one source file, or use
@code{check-declare-directory} check all the files in and under a
certain directory.

  These commands find the file that ought to contain a function's
definition using @code{locate-library}; if that finds no file, they
expand the definition file name relative to the directory of the file
that contains the @code{declare-function} call.

  You can also say that a function is a primitive by specifying a file
name ending in @samp{.c} or @samp{.m}.  This is useful only when you
call a primitive that is defined only on certain systems.  Most
primitives are always defined, so they will never give you a warning.

  Sometimes a file will optionally use functions from an external package.
If you prefix the filename in the @code{declare-function} statement with
@samp{ext:}, then it will be checked if it is found, otherwise skipped
without error.

  There are some function definitions that @samp{check-declare} does not
understand (e.g., @code{defstruct} and some other macros).  In such cases,
you can pass a non-@code{nil} @var{fileonly} argument to
@code{declare-function}, meaning to only check that the file exists, not
that it actually defines the function.  Note that to do this without
having to specify an argument list, you should set the @var{arglist}
argument to @code{t} (because @code{nil} means an empty argument list, as
opposed to an unspecified one).

@node Function Safety
@section Determining whether a Function is Safe to Call
@cindex function safety
@cindex safety of functions

Some major modes, such as SES, call functions that are stored in user
files.  (@xref{Top, Simple Emacs Spreadsheet,,ses}, for more
information on SES@.)  User files sometimes have poor pedigrees---you
can get a spreadsheet from someone you've just met, or you can get one
through email from someone you've never met.  So it is risky to call a
function whose source code is stored in a user file until you have
determined that it is safe.

@defun unsafep form &optional unsafep-vars
Returns @code{nil} if @var{form} is a @dfn{safe} Lisp expression, or
returns a list that describes why it might be unsafe.  The argument
@var{unsafep-vars} is a list of symbols known to have temporary
bindings at this point; it is mainly used for internal recursive
calls.  The current buffer is an implicit argument, which provides a
list of buffer-local bindings.
@end defun

Being quick and simple, @code{unsafep} does a very light analysis and
rejects many Lisp expressions that are actually safe.  There are no
known cases where @code{unsafep} returns @code{nil} for an unsafe
expression.  However, a safe Lisp expression can return a string
with a @code{display} property, containing an associated Lisp
expression to be executed after the string is inserted into a buffer.
This associated expression can be malicious.  In order to be safe, you
must delete properties from all strings calculated by user code before
inserting them into buffers.

@ignore
What is a safe Lisp expression?  Basically, it's an expression that
calls only built-in functions with no side effects (or only innocuous
ones).  Innocuous side effects include displaying messages and
altering non-risky buffer-local variables (but not global variables).

@table @dfn
@item Safe expression
@itemize
@item
An atom or quoted thing.
@item
A call to a safe function (see below), if all its arguments are
safe expressions.
@item
One of the special forms @code{and}, @code{catch}, @code{cond},
@code{if}, @code{or}, @code{prog1}, @code{prog2}, @code{progn},
@code{while}, and @code{unwind-protect}], if all its arguments are
safe.
@item
A form that creates temporary bindings (@code{condition-case},
@code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, or
@code{let*}), if all args are safe and the symbols to be bound are not
explicitly risky (@pxref{File Local Variables}).
@item
An assignment using @code{add-to-list}, @code{setq}, @code{push}, or
@code{pop}, if all args are safe and the symbols to be assigned are
not explicitly risky and they already have temporary or buffer-local
bindings.
@item
One of [apply, mapc, mapcar, mapconcat] if the first argument is a
safe explicit lambda and the other args are safe expressions.
@end itemize

@item Safe function
@itemize
@item
A lambda containing safe expressions.
@item
A symbol on the list @code{safe-functions}, so the user says it's safe.
@item
A symbol with a non-@code{nil} @code{side-effect-free} property.
@item
A symbol with a non-@code{nil} @code{safe-function} property.  The
value @code{t} indicates a function that is safe but has innocuous
side effects.  Other values will someday indicate functions with
classes of side effects that are not always safe.
@end itemize

The @code{side-effect-free} and @code{safe-function} properties are
provided for built-in functions and for low-level functions and macros
defined in @file{subr.el}.  You can assign these properties for the
functions you write.
@end table
@end ignore

@node Related Topics
@section Other Topics Related to Functions

  Here is a table of several functions that do things related to
function calling and function definitions.  They are documented
elsewhere, but we provide cross references here.

@table @code
@item apply
@xref{Calling Functions}.

@item autoload
@xref{Autoload}.

@item call-interactively
@xref{Interactive Call}.

@item called-interactively-p
@xref{Distinguish Interactive}.

@item commandp
@xref{Interactive Call}.

@item documentation
@xref{Accessing Documentation}.

@item eval
@xref{Eval}.

@item funcall
@xref{Calling Functions}.

@item function
@xref{Anonymous Functions}.

@item ignore
@xref{Calling Functions}.

@item indirect-function
@xref{Function Indirection}.

@item interactive
@xref{Using Interactive}.

@item interactive-p
@xref{Distinguish Interactive}.

@item mapatoms
@xref{Creating Symbols}.

@item mapcar
@xref{Mapping Functions}.

@item map-char-table
@xref{Char-Tables}.

@item mapconcat
@xref{Mapping Functions}.

@item undefined
@xref{Functions for Key Lookup}.
@end table
